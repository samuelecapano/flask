<html>
<head>
<title>afmLib.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
afmLib.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Module for reading and writing AFM (Adobe Font Metrics) files. 
 
Note that this has been designed to read in AFM files generated by Fontographer 
and has not been tested on many other files. In particular, it does not 
implement the whole Adobe AFM specification [#f1]_ but, it should read most 
&quot;common&quot; AFM files. 
 
Here is an example of using `afmLib` to read, modify and write an AFM file: 
 
    &gt;&gt;&gt; from fontTools.afmLib import AFM 
    &gt;&gt;&gt; f = AFM(&quot;Tests/afmLib/data/TestAFM.afm&quot;) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Accessing a pair gets you the kern value 
    &gt;&gt;&gt; f[(&quot;V&quot;,&quot;A&quot;)] 
    -60 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Accessing a glyph name gets you metrics 
    &gt;&gt;&gt; f[&quot;A&quot;] 
    (65, 668, (8, -25, 660, 666)) 
    &gt;&gt;&gt; # (charnum, width, bounding box) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Accessing an attribute gets you metadata 
    &gt;&gt;&gt; f.FontName 
    'TestFont-Regular' 
    &gt;&gt;&gt; f.FamilyName 
    'TestFont' 
    &gt;&gt;&gt; f.Weight 
    'Regular' 
    &gt;&gt;&gt; f.XHeight 
    500 
    &gt;&gt;&gt; f.Ascender 
    750 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Attributes and items can also be set 
    &gt;&gt;&gt; f[(&quot;A&quot;,&quot;V&quot;)] = -150 # Tighten kerning 
    &gt;&gt;&gt; f.FontName = &quot;TestFont Squished&quot; 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # And the font written out again (remove the # in front) 
    &gt;&gt;&gt; #f.write(&quot;testfont-squished.afm&quot;) 
 
.. rubric:: Footnotes 
 
.. [#f1] `Adobe Technote 5004 &lt;https://www.adobe.com/content/dam/acom/en/devnet/font/pdfs/5004.AFM_Spec.pdf&gt;`_, 
   Adobe Font Metrics File Format Specification. 
 
&quot;&quot;&quot;</span>


<span class="s2">import </span><span class="s1">re</span>

<span class="s3"># every single line starts with a &quot;word&quot;</span>
<span class="s1">identifierRE = re.compile(</span><span class="s4">r&quot;^([A-Za-z]+).*&quot;</span><span class="s1">)</span>

<span class="s3"># regular expression to parse char lines</span>
<span class="s1">charRE = re.compile(</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># charnum</span>
		<span class="s4">r&quot;\s*;\s*WX\s+&quot;			</span><span class="s3"># ; WX</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># width</span>
		<span class="s4">r&quot;\s*;\s*N\s+&quot;			</span><span class="s3"># ; N</span>
		<span class="s4">r&quot;([.A-Za-z0-9_]+)&quot;		</span><span class="s3"># charname</span>
		<span class="s4">r&quot;\s*;\s*B\s+&quot;			</span><span class="s3"># ; B</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># left</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># bottom</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># right</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># top</span>
		<span class="s4">r&quot;\s*;\s*&quot;			</span><span class="s3"># ;</span>
		<span class="s1">)</span>

<span class="s3"># regular expression to parse kerning lines</span>
<span class="s1">kernRE = re.compile(</span>
		<span class="s4">r&quot;([.A-Za-z0-9_]+)&quot;		</span><span class="s3"># leftchar</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;([.A-Za-z0-9_]+)&quot;		</span><span class="s3"># rightchar</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># value</span>
		<span class="s4">r&quot;\s*&quot;</span>
		<span class="s1">)</span>

<span class="s3"># regular expressions to parse composite info lines of the form:</span>
<span class="s3"># Aacute 2 ; PCC A 0 0 ; PCC acute 182 211 ;</span>
<span class="s1">compositeRE = re.compile(</span>
		<span class="s4">r&quot;([.A-Za-z0-9_]+)&quot;		</span><span class="s3"># char name</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(\d+)&quot;				</span><span class="s3"># number of parts</span>
		<span class="s4">r&quot;\s*;\s*&quot;</span>
		<span class="s1">)</span>
<span class="s1">componentRE = re.compile(</span>
		<span class="s4">r&quot;PCC\s+&quot;			</span><span class="s3"># PPC</span>
		<span class="s4">r&quot;([.A-Za-z0-9_]+)&quot;		</span><span class="s3"># base char name</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># x offset</span>
		<span class="s4">r&quot;\s+&quot;</span>
		<span class="s4">r&quot;(-?\d+)&quot;			</span><span class="s3"># y offset</span>
		<span class="s4">r&quot;\s*;\s*&quot;</span>
		<span class="s1">)</span>

<span class="s1">preferredAttributeOrder = [</span>
		<span class="s4">&quot;FontName&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;FullName&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;FamilyName&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;Weight&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;ItalicAngle&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;IsFixedPitch&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;FontBBox&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;UnderlinePosition&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;UnderlineThickness&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;Version&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;Notice&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;EncodingScheme&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;CapHeight&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;XHeight&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;Ascender&quot;</span><span class="s2">,</span>
		<span class="s4">&quot;Descender&quot;</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">class </span><span class="s1">error(Exception):</span>
	<span class="s2">pass</span>


<span class="s2">class </span><span class="s1">AFM(object):</span>

	<span class="s1">_attrs = </span><span class="s2">None</span>

	<span class="s1">_keywords = [</span><span class="s4">'StartFontMetrics'</span><span class="s2">,</span>
			<span class="s4">'EndFontMetrics'</span><span class="s2">,</span>
			<span class="s4">'StartCharMetrics'</span><span class="s2">,</span>
			<span class="s4">'EndCharMetrics'</span><span class="s2">,</span>
			<span class="s4">'StartKernData'</span><span class="s2">,</span>
			<span class="s4">'StartKernPairs'</span><span class="s2">,</span>
			<span class="s4">'EndKernPairs'</span><span class="s2">,</span>
			<span class="s4">'EndKernData'</span><span class="s2">,</span>
			<span class="s4">'StartComposites'</span><span class="s2">,</span>
			<span class="s4">'EndComposites'</span><span class="s2">,</span>
			<span class="s1">]</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s0">&quot;&quot;&quot;AFM file reader. 
 
        Instantiating an object with a path name will cause the file to be opened, 
        read, and parsed. Alternatively the path can be left unspecified, and a 
        file can be parsed later with the :meth:`read` method.&quot;&quot;&quot;</span>
		<span class="s1">self._attrs = {}</span>
		<span class="s1">self._chars = {}</span>
		<span class="s1">self._kerning = {}</span>
		<span class="s1">self._index = {}</span>
		<span class="s1">self._comments = []</span>
		<span class="s1">self._composites = {}</span>
		<span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s1">self.read(path)</span>

	<span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">path):</span>
		<span class="s0">&quot;&quot;&quot;Opens, reads and parses a file.&quot;&quot;&quot;</span>
		<span class="s1">lines = readlines(path)</span>
		<span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
			<span class="s2">if not </span><span class="s1">line.strip():</span>
				<span class="s2">continue</span>
			<span class="s1">m = identifierRE.match(line)</span>
			<span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
				<span class="s2">raise </span><span class="s1">error(</span><span class="s4">&quot;syntax error in AFM file: &quot; </span><span class="s1">+ repr(line))</span>

			<span class="s1">pos = m.regs[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>
			<span class="s1">word = line[:pos]</span>
			<span class="s1">rest = line[pos:].strip()</span>
			<span class="s2">if </span><span class="s1">word </span><span class="s2">in </span><span class="s1">self._keywords:</span>
				<span class="s2">continue</span>
			<span class="s2">if </span><span class="s1">word == </span><span class="s4">&quot;C&quot;</span><span class="s1">:</span>
				<span class="s1">self.parsechar(rest)</span>
			<span class="s2">elif </span><span class="s1">word == </span><span class="s4">&quot;KPX&quot;</span><span class="s1">:</span>
				<span class="s1">self.parsekernpair(rest)</span>
			<span class="s2">elif </span><span class="s1">word == </span><span class="s4">&quot;CC&quot;</span><span class="s1">:</span>
				<span class="s1">self.parsecomposite(rest)</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">self.parseattr(word</span><span class="s2">, </span><span class="s1">rest)</span>

	<span class="s2">def </span><span class="s1">parsechar(self</span><span class="s2">, </span><span class="s1">rest):</span>
		<span class="s1">m = charRE.match(rest)</span>
		<span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">raise </span><span class="s1">error(</span><span class="s4">&quot;syntax error in AFM file: &quot; </span><span class="s1">+ repr(rest))</span>
		<span class="s1">things = []</span>
		<span class="s2">for </span><span class="s1">fr</span><span class="s2">, </span><span class="s1">to </span><span class="s2">in </span><span class="s1">m.regs[</span><span class="s5">1</span><span class="s1">:]:</span>
			<span class="s1">things.append(rest[fr:to])</span>
		<span class="s1">charname = things[</span><span class="s5">2</span><span class="s1">]</span>
		<span class="s2">del </span><span class="s1">things[</span><span class="s5">2</span><span class="s1">]</span>
		<span class="s1">charnum</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t = (int(thing) </span><span class="s2">for </span><span class="s1">thing </span><span class="s2">in </span><span class="s1">things)</span>
		<span class="s1">self._chars[charname] = charnum</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">(l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t)</span>

	<span class="s2">def </span><span class="s1">parsekernpair(self</span><span class="s2">, </span><span class="s1">rest):</span>
		<span class="s1">m = kernRE.match(rest)</span>
		<span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">raise </span><span class="s1">error(</span><span class="s4">&quot;syntax error in AFM file: &quot; </span><span class="s1">+ repr(rest))</span>
		<span class="s1">things = []</span>
		<span class="s2">for </span><span class="s1">fr</span><span class="s2">, </span><span class="s1">to </span><span class="s2">in </span><span class="s1">m.regs[</span><span class="s5">1</span><span class="s1">:]:</span>
			<span class="s1">things.append(rest[fr:to])</span>
		<span class="s1">leftchar</span><span class="s2">, </span><span class="s1">rightchar</span><span class="s2">, </span><span class="s1">value = things</span>
		<span class="s1">value = int(value)</span>
		<span class="s1">self._kerning[(leftchar</span><span class="s2">, </span><span class="s1">rightchar)] = value</span>

	<span class="s2">def </span><span class="s1">parseattr(self</span><span class="s2">, </span><span class="s1">word</span><span class="s2">, </span><span class="s1">rest):</span>
		<span class="s2">if </span><span class="s1">word == </span><span class="s4">&quot;FontBBox&quot;</span><span class="s1">:</span>
			<span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t = [int(thing) </span><span class="s2">for </span><span class="s1">thing </span><span class="s2">in </span><span class="s1">rest.split()]</span>
			<span class="s1">self._attrs[word] = l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t</span>
		<span class="s2">elif </span><span class="s1">word == </span><span class="s4">&quot;Comment&quot;</span><span class="s1">:</span>
			<span class="s1">self._comments.append(rest)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">try</span><span class="s1">:</span>
				<span class="s1">value = int(rest)</span>
			<span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
				<span class="s1">self._attrs[word] = rest</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">self._attrs[word] = value</span>

	<span class="s2">def </span><span class="s1">parsecomposite(self</span><span class="s2">, </span><span class="s1">rest):</span>
		<span class="s1">m = compositeRE.match(rest)</span>
		<span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">raise </span><span class="s1">error(</span><span class="s4">&quot;syntax error in AFM file: &quot; </span><span class="s1">+ repr(rest))</span>
		<span class="s1">charname = m.group(</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">ncomponents = int(m.group(</span><span class="s5">2</span><span class="s1">))</span>
		<span class="s1">rest = rest[m.regs[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]:]</span>
		<span class="s1">components = []</span>
		<span class="s2">while True</span><span class="s1">:</span>
			<span class="s1">m = componentRE.match(rest)</span>
			<span class="s2">if </span><span class="s1">m </span><span class="s2">is None</span><span class="s1">:</span>
				<span class="s2">raise </span><span class="s1">error(</span><span class="s4">&quot;syntax error in AFM file: &quot; </span><span class="s1">+ repr(rest))</span>
			<span class="s1">basechar = m.group(</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">xoffset = int(m.group(</span><span class="s5">2</span><span class="s1">))</span>
			<span class="s1">yoffset = int(m.group(</span><span class="s5">3</span><span class="s1">))</span>
			<span class="s1">components.append((basechar</span><span class="s2">, </span><span class="s1">xoffset</span><span class="s2">, </span><span class="s1">yoffset))</span>
			<span class="s1">rest = rest[m.regs[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]:]</span>
			<span class="s2">if not </span><span class="s1">rest:</span>
				<span class="s2">break</span>
		<span class="s2">assert </span><span class="s1">len(components) == ncomponents</span>
		<span class="s1">self._composites[charname] = components</span>

	<span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">sep=</span><span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s1">):</span>
		<span class="s0">&quot;&quot;&quot;Writes out an AFM font to the given path.&quot;&quot;&quot;</span>
		<span class="s2">import </span><span class="s1">time</span>
		<span class="s1">lines = [	</span><span class="s4">&quot;StartFontMetrics 2.0&quot;</span><span class="s2">,</span>
				<span class="s4">&quot;Comment Generated by afmLib; at %s&quot; </span><span class="s1">% (</span>
						<span class="s1">time.strftime(</span><span class="s4">&quot;%m/%d/%Y %H:%M:%S&quot;</span><span class="s2">,</span>
						<span class="s1">time.localtime(time.time())))]</span>

		<span class="s3"># write comments, assuming (possibly wrongly!) they should</span>
		<span class="s3"># all appear at the top</span>
		<span class="s2">for </span><span class="s1">comment </span><span class="s2">in </span><span class="s1">self._comments:</span>
			<span class="s1">lines.append(</span><span class="s4">&quot;Comment &quot; </span><span class="s1">+ comment)</span>

		<span class="s3"># write attributes, first the ones we know about, in</span>
		<span class="s3"># a preferred order</span>
		<span class="s1">attrs = self._attrs</span>
		<span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">preferredAttributeOrder:</span>
			<span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
				<span class="s1">value = attrs[attr]</span>
				<span class="s2">if </span><span class="s1">attr == </span><span class="s4">&quot;FontBBox&quot;</span><span class="s1">:</span>
					<span class="s1">value = </span><span class="s4">&quot;%s %s %s %s&quot; </span><span class="s1">% value</span>
				<span class="s1">lines.append(attr + </span><span class="s4">&quot; &quot; </span><span class="s1">+ str(value))</span>
		<span class="s3"># then write the attributes we don't know about,</span>
		<span class="s3"># in alphabetical order</span>
		<span class="s1">items = sorted(attrs.items())</span>
		<span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">items:</span>
			<span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">preferredAttributeOrder:</span>
				<span class="s2">continue</span>
			<span class="s1">lines.append(attr + </span><span class="s4">&quot; &quot; </span><span class="s1">+ str(value))</span>

		<span class="s3"># write char metrics</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;StartCharMetrics &quot; </span><span class="s1">+ repr(len(self._chars)))</span>
		<span class="s1">items = [(charnum</span><span class="s2">, </span><span class="s1">(charname</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">box)) </span><span class="s2">for </span><span class="s1">charname</span><span class="s2">, </span><span class="s1">(charnum</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">box) </span><span class="s2">in </span><span class="s1">self._chars.items()]</span>

		<span class="s2">def </span><span class="s1">myKey(a):</span>
			<span class="s0">&quot;&quot;&quot;Custom key function to make sure unencoded chars (-1) 
            end up at the end of the list after sorting.&quot;&quot;&quot;</span>
			<span class="s2">if </span><span class="s1">a[</span><span class="s5">0</span><span class="s1">] == -</span><span class="s5">1</span><span class="s1">:</span>
				<span class="s1">a = (</span><span class="s5">0xffff</span><span class="s2">,</span><span class="s1">) + a[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s3"># 0xffff is an arbitrary large number</span>
			<span class="s2">return </span><span class="s1">a</span>
		<span class="s1">items.sort(key=myKey)</span>

		<span class="s2">for </span><span class="s1">charnum</span><span class="s2">, </span><span class="s1">(charname</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">(l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t)) </span><span class="s2">in </span><span class="s1">items:</span>
			<span class="s1">lines.append(</span><span class="s4">&quot;C %d ; WX %d ; N %s ; B %d %d %d %d ;&quot; </span><span class="s1">%</span>
					<span class="s1">(charnum</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">charname</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t))</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;EndCharMetrics&quot;</span><span class="s1">)</span>

		<span class="s3"># write kerning info</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;StartKernData&quot;</span><span class="s1">)</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;StartKernPairs &quot; </span><span class="s1">+ repr(len(self._kerning)))</span>
		<span class="s1">items = sorted(self._kerning.items())</span>
		<span class="s2">for </span><span class="s1">(leftchar</span><span class="s2">, </span><span class="s1">rightchar)</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">items:</span>
			<span class="s1">lines.append(</span><span class="s4">&quot;KPX %s %s %d&quot; </span><span class="s1">% (leftchar</span><span class="s2">, </span><span class="s1">rightchar</span><span class="s2">, </span><span class="s1">value))</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;EndKernPairs&quot;</span><span class="s1">)</span>
		<span class="s1">lines.append(</span><span class="s4">&quot;EndKernData&quot;</span><span class="s1">)</span>

		<span class="s2">if </span><span class="s1">self._composites:</span>
			<span class="s1">composites = sorted(self._composites.items())</span>
			<span class="s1">lines.append(</span><span class="s4">&quot;StartComposites %s&quot; </span><span class="s1">% len(self._composites))</span>
			<span class="s2">for </span><span class="s1">charname</span><span class="s2">, </span><span class="s1">components </span><span class="s2">in </span><span class="s1">composites:</span>
				<span class="s1">line = </span><span class="s4">&quot;CC %s %s ;&quot; </span><span class="s1">% (charname</span><span class="s2">, </span><span class="s1">len(components))</span>
				<span class="s2">for </span><span class="s1">basechar</span><span class="s2">, </span><span class="s1">xoffset</span><span class="s2">, </span><span class="s1">yoffset </span><span class="s2">in </span><span class="s1">components:</span>
					<span class="s1">line = line + </span><span class="s4">&quot; PCC %s %s %s ;&quot; </span><span class="s1">% (basechar</span><span class="s2">, </span><span class="s1">xoffset</span><span class="s2">, </span><span class="s1">yoffset)</span>
				<span class="s1">lines.append(line)</span>
			<span class="s1">lines.append(</span><span class="s4">&quot;EndComposites&quot;</span><span class="s1">)</span>

		<span class="s1">lines.append(</span><span class="s4">&quot;EndFontMetrics&quot;</span><span class="s1">)</span>

		<span class="s1">writelines(path</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">, </span><span class="s1">sep)</span>

	<span class="s2">def </span><span class="s1">has_kernpair(self</span><span class="s2">, </span><span class="s1">pair):</span>
		<span class="s0">&quot;&quot;&quot;Returns `True` if the given glyph pair (specified as a tuple) exists 
        in the kerning dictionary.&quot;&quot;&quot;</span>
		<span class="s2">return </span><span class="s1">pair </span><span class="s2">in </span><span class="s1">self._kerning</span>

	<span class="s2">def </span><span class="s1">kernpairs(self):</span>
		<span class="s0">&quot;&quot;&quot;Returns a list of all kern pairs in the kerning dictionary.&quot;&quot;&quot;</span>
		<span class="s2">return </span><span class="s1">list(self._kerning.keys())</span>

	<span class="s2">def </span><span class="s1">has_char(self</span><span class="s2">, </span><span class="s1">char):</span>
		<span class="s0">&quot;&quot;&quot;Returns `True` if the given glyph exists in the font.&quot;&quot;&quot;</span>
		<span class="s2">return </span><span class="s1">char </span><span class="s2">in </span><span class="s1">self._chars</span>

	<span class="s2">def </span><span class="s1">chars(self):</span>
		<span class="s0">&quot;&quot;&quot;Returns a list of all glyph names in the font.&quot;&quot;&quot;</span>
		<span class="s2">return </span><span class="s1">list(self._chars.keys())</span>

	<span class="s2">def </span><span class="s1">comments(self):</span>
		<span class="s0">&quot;&quot;&quot;Returns all comments from the file.&quot;&quot;&quot;</span>
		<span class="s2">return </span><span class="s1">self._comments</span>

	<span class="s2">def </span><span class="s1">addComment(self</span><span class="s2">, </span><span class="s1">comment):</span>
		<span class="s0">&quot;&quot;&quot;Adds a new comment to the file.&quot;&quot;&quot;</span>
		<span class="s1">self._comments.append(comment)</span>

	<span class="s2">def </span><span class="s1">addComposite(self</span><span class="s2">, </span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">components):</span>
		<span class="s0">&quot;&quot;&quot;Specifies that the glyph `glyphName` is made up of the given components. 
        The components list should be of the following form:: 
 
            [ 
                (glyphname, xOffset, yOffset), 
                ... 
            ] 
         
        &quot;&quot;&quot;</span>
		<span class="s1">self._composites[glyphName] = components</span>

	<span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
		<span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self._attrs:</span>
			<span class="s2">return </span><span class="s1">self._attrs[attr]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">raise </span><span class="s1">AttributeError(attr)</span>

	<span class="s2">def </span><span class="s1">__setattr__(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">value):</span>
		<span class="s3"># all attrs *not* starting with &quot;_&quot; are consider to be AFM keywords</span>
		<span class="s2">if </span><span class="s1">attr[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">&quot;_&quot;</span><span class="s1">:</span>
			<span class="s1">self.__dict__[attr] = value</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">self._attrs[attr] = value</span>

	<span class="s2">def </span><span class="s1">__delattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
		<span class="s3"># all attrs *not* starting with &quot;_&quot; are consider to be AFM keywords</span>
		<span class="s2">if </span><span class="s1">attr[:</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">&quot;_&quot;</span><span class="s1">:</span>
			<span class="s2">try</span><span class="s1">:</span>
				<span class="s2">del </span><span class="s1">self.__dict__[attr]</span>
			<span class="s2">except </span><span class="s1">KeyError:</span>
				<span class="s2">raise </span><span class="s1">AttributeError(attr)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">try</span><span class="s1">:</span>
				<span class="s2">del </span><span class="s1">self._attrs[attr]</span>
			<span class="s2">except </span><span class="s1">KeyError:</span>
				<span class="s2">raise </span><span class="s1">AttributeError(attr)</span>

	<span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
		<span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple):</span>
			<span class="s3"># key is a tuple, return the kernpair</span>
			<span class="s2">return </span><span class="s1">self._kerning[key]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s3"># return the metrics instead</span>
			<span class="s2">return </span><span class="s1">self._chars[key]</span>

	<span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value):</span>
		<span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple):</span>
			<span class="s3"># key is a tuple, set kernpair</span>
			<span class="s1">self._kerning[key] = value</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s3"># set char metrics</span>
			<span class="s1">self._chars[key] = value</span>

	<span class="s2">def </span><span class="s1">__delitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
		<span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple):</span>
			<span class="s3"># key is a tuple, del kernpair</span>
			<span class="s2">del </span><span class="s1">self._kerning[key]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s3"># del char metrics</span>
			<span class="s2">del </span><span class="s1">self._chars[key]</span>

	<span class="s2">def </span><span class="s1">__repr__(self):</span>
		<span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">&quot;FullName&quot;</span><span class="s1">):</span>
			<span class="s2">return </span><span class="s4">'&lt;AFM object for %s&gt;' </span><span class="s1">% self.FullName</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">return </span><span class="s4">'&lt;AFM object at %x&gt;' </span><span class="s1">% id(self)</span>


<span class="s2">def </span><span class="s1">readlines(path):</span>
	<span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s4">&quot;r&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">&quot;ascii&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">f:</span>
		<span class="s1">data = f.read()</span>
	<span class="s2">return </span><span class="s1">data.splitlines()</span>

<span class="s2">def </span><span class="s1">writelines(path</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">, </span><span class="s1">sep=</span><span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s1">):</span>
	<span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s4">&quot;w&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s4">&quot;ascii&quot;</span><span class="s2">, </span><span class="s1">newline=sep) </span><span class="s2">as </span><span class="s1">f:</span>
		<span class="s1">f.write(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">.join(lines) + </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
	<span class="s2">import </span><span class="s1">EasyDialogs</span>
	<span class="s1">path = EasyDialogs.AskFileForOpen()</span>
	<span class="s2">if </span><span class="s1">path:</span>
		<span class="s1">afm = AFM(path)</span>
		<span class="s1">char = </span><span class="s4">'A'</span>
		<span class="s2">if </span><span class="s1">afm.has_char(char):</span>
			<span class="s1">print(afm[char])	</span><span class="s3"># print charnum, width and boundingbox</span>
		<span class="s1">pair = (</span><span class="s4">'A'</span><span class="s2">, </span><span class="s4">'V'</span><span class="s1">)</span>
		<span class="s2">if </span><span class="s1">afm.has_kernpair(pair):</span>
			<span class="s1">print(afm[pair])	</span><span class="s3"># print kerning value for pair</span>
		<span class="s1">print(afm.Version)	</span><span class="s3"># various other afm entries have become attributes</span>
		<span class="s1">print(afm.Weight)</span>
		<span class="s3"># afm.comments() returns a list of all Comment lines found in the AFM</span>
		<span class="s1">print(afm.comments())</span>
		<span class="s3">#print afm.chars()</span>
		<span class="s3">#print afm.kernpairs()</span>
		<span class="s1">print(afm)</span>
		<span class="s1">afm.write(path + </span><span class="s4">&quot;.muck&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>