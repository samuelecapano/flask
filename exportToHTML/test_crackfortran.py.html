<html>
<head>
<title>test_crackfortran.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_crackfortran.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">importlib</span>
<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">import </span><span class="s1">unicodedata</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.f2py.crackfortran </span><span class="s0">import </span><span class="s1">markinnerspaces</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">util</span>
<span class="s0">from </span><span class="s1">numpy.f2py </span><span class="s0">import </span><span class="s1">crackfortran</span>
<span class="s0">import </span><span class="s1">textwrap</span>


<span class="s0">class </span><span class="s1">TestNoSpace(util.F2PyTest):</span>
    <span class="s2"># issue gh-15035: add handling for endsubroutine, endfunction with no space</span>
    <span class="s2"># between &quot;end&quot; and the block name</span>
    <span class="s1">sources = [util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;gh15035.f&quot;</span><span class="s1">)]</span>

    <span class="s0">def </span><span class="s1">test_module(self):</span>
        <span class="s1">k = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">w = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">self.module.subb(k)</span>
        <span class="s0">assert </span><span class="s1">np.allclose(k</span><span class="s0">, </span><span class="s1">w + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.module.subc([w</span><span class="s0">, </span><span class="s1">k])</span>
        <span class="s0">assert </span><span class="s1">np.allclose(k</span><span class="s0">, </span><span class="s1">w + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">self.module.t0(</span><span class="s3">&quot;23&quot;</span><span class="s1">) == </span><span class="s5">b&quot;2&quot;</span>


<span class="s0">class </span><span class="s1">TestPublicPrivate:</span>
    <span class="s0">def </span><span class="s1">test_defaultPrivate(self):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;privatemod.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;private&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;public&quot; </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;private&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;b&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;public&quot; </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;b&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;private&quot; </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;seta&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;public&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;seta&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_defaultPublic(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;publicmod.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;private&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;public&quot; </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;a&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;private&quot; </span><span class="s0">not in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;seta&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;public&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;seta&quot;</span><span class="s1">][</span><span class="s3">&quot;attrspec&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_access_type(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;accesstype.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">tt = mod[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">'vars'</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">set(tt[</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]) == {</span><span class="s3">'private'</span><span class="s0">, </span><span class="s3">'bind(c)'</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">set(tt[</span><span class="s3">'b_'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]) == {</span><span class="s3">'public'</span><span class="s0">, </span><span class="s3">'bind(c)'</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">set(tt[</span><span class="s3">'c'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">]) == {</span><span class="s3">'public'</span><span class="s1">}</span>


<span class="s0">class </span><span class="s1">TestModuleProcedure():</span>
    <span class="s0">def </span><span class="s1">test_moduleOperators(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;operators.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s3">&quot;body&quot; </span><span class="s0">in </span><span class="s1">mod </span><span class="s0">and </span><span class="s1">len(mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">]) == </span><span class="s4">9</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;name&quot;</span><span class="s1">] == </span><span class="s3">&quot;operator(.item.)&quot;</span>
        <span class="s0">assert </span><span class="s3">&quot;implementedby&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">][</span><span class="s3">&quot;implementedby&quot;</span><span class="s1">] == \</span>
            <span class="s1">[</span><span class="s3">&quot;item_int&quot;</span><span class="s0">, </span><span class="s3">&quot;item_real&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">2</span><span class="s1">][</span><span class="s3">&quot;name&quot;</span><span class="s1">] == </span><span class="s3">&quot;operator(==)&quot;</span>
        <span class="s0">assert </span><span class="s3">&quot;implementedby&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">2</span><span class="s1">][</span><span class="s3">&quot;implementedby&quot;</span><span class="s1">] == [</span><span class="s3">&quot;items_are_equal&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][</span><span class="s3">&quot;name&quot;</span><span class="s1">] == </span><span class="s3">&quot;assignment(=)&quot;</span>
        <span class="s0">assert </span><span class="s3">&quot;implementedby&quot; </span><span class="s0">in </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">3</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">&quot;body&quot;</span><span class="s1">][</span><span class="s4">3</span><span class="s1">][</span><span class="s3">&quot;implementedby&quot;</span><span class="s1">] == \</span>
            <span class="s1">[</span><span class="s3">&quot;get_int&quot;</span><span class="s0">, </span><span class="s3">&quot;get_real&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_notPublicPrivate(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;pubprivmod.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s1">mod = mod[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'a'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">] == [</span><span class="s3">'private'</span><span class="s0">, </span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'b'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">] == [</span><span class="s3">'public'</span><span class="s0">, </span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s3">'vars'</span><span class="s1">][</span><span class="s3">'seta'</span><span class="s1">][</span><span class="s3">'attrspec'</span><span class="s1">] == [</span><span class="s3">'public'</span><span class="s0">, </span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">TestExternal(util.F2PyTest):</span>
    <span class="s2"># issue gh-17859: add external attribute support</span>
    <span class="s1">sources = [util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;gh17859.f&quot;</span><span class="s1">)]</span>

    <span class="s0">def </span><span class="s1">test_external_as_statement(self):</span>
        <span class="s0">def </span><span class="s1">incr(x):</span>
            <span class="s0">return </span><span class="s1">x + </span><span class="s4">123</span>

        <span class="s1">r = self.module.external_as_statement(incr)</span>
        <span class="s0">assert </span><span class="s1">r == </span><span class="s4">123</span>

    <span class="s0">def </span><span class="s1">test_external_as_attribute(self):</span>
        <span class="s0">def </span><span class="s1">incr(x):</span>
            <span class="s0">return </span><span class="s1">x + </span><span class="s4">123</span>

        <span class="s1">r = self.module.external_as_attribute(incr)</span>
        <span class="s0">assert </span><span class="s1">r == </span><span class="s4">123</span>


<span class="s0">class </span><span class="s1">TestCrackFortran(util.F2PyTest):</span>
    <span class="s2"># gh-2848: commented lines between parameters in subroutine parameter lists</span>
    <span class="s1">sources = [util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;gh2848.f90&quot;</span><span class="s1">)]</span>

    <span class="s0">def </span><span class="s1">test_gh2848(self):</span>
        <span class="s1">r = self.module.gh2848(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">r == (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMarkinnerspaces:</span>
    <span class="s2"># gh-14118: markinnerspaces does not handle multiple quotations</span>

    <span class="s0">def </span><span class="s1">test_do_not_touch_normal_spaces(self):</span>
        <span class="s1">test_list = [</span><span class="s3">&quot;a &quot;</span><span class="s0">, </span><span class="s3">&quot; a&quot;</span><span class="s0">, </span><span class="s3">&quot;a b c&quot;</span><span class="s0">, </span><span class="s3">&quot;'abcdefghij'&quot;</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">test_list:</span>
            <span class="s0">assert </span><span class="s1">markinnerspaces(i) == i</span>

    <span class="s0">def </span><span class="s1">test_one_relevant_space(self):</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">&quot;a 'b c' </span><span class="s0">\\</span><span class="s3">' </span><span class="s0">\\</span><span class="s3">'&quot;</span><span class="s1">) == </span><span class="s3">&quot;a 'b@_@c' </span><span class="s0">\\</span><span class="s3">' </span><span class="s0">\\</span><span class="s3">'&quot;</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">r'a &quot;b c&quot; \&quot; \&quot;'</span><span class="s1">) == </span><span class="s3">r'a &quot;b@_@c&quot; \&quot; \&quot;'</span>

    <span class="s0">def </span><span class="s1">test_ignore_inner_quotes(self):</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">&quot;a 'b c</span><span class="s0">\&quot; \&quot; </span><span class="s3">d' e&quot;</span><span class="s1">) == </span><span class="s3">&quot;a 'b@_@c</span><span class="s0">\&quot;</span><span class="s3">@_@</span><span class="s0">\&quot;</span><span class="s3">@_@d' e&quot;</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">&quot;a </span><span class="s0">\&quot;</span><span class="s3">b c' ' d</span><span class="s0">\&quot; </span><span class="s3">e&quot;</span><span class="s1">) == </span><span class="s3">&quot;a </span><span class="s0">\&quot;</span><span class="s3">b@_@c'@_@'@_@d</span><span class="s0">\&quot; </span><span class="s3">e&quot;</span>

    <span class="s0">def </span><span class="s1">test_multiple_relevant_spaces(self):</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">&quot;a 'b c' 'd e'&quot;</span><span class="s1">) == </span><span class="s3">&quot;a 'b@_@c' 'd@_@e'&quot;</span>
        <span class="s0">assert </span><span class="s1">markinnerspaces(</span><span class="s3">r'a &quot;b c&quot; &quot;d e&quot;'</span><span class="s1">) == </span><span class="s3">r'a &quot;b@_@c&quot; &quot;d@_@e&quot;'</span>

<span class="s0">class </span><span class="s1">TestDimSpec(util.F2PyTest):</span>
    <span class="s6">&quot;&quot;&quot;This test suite tests various expressions that are used as dimension 
    specifications. 
 
    There exists two usage cases where analyzing dimensions 
    specifications are important. 
 
    In the first case, the size of output arrays must be defined based 
    on the inputs to a Fortran function. Because Fortran supports 
    arbitrary bases for indexing, for instance, `arr(lower:upper)`, 
    f2py has to evaluate an expression `upper - lower + 1` where 
    `lower` and `upper` are arbitrary expressions of input parameters. 
    The evaluation is performed in C, so f2py has to translate Fortran 
    expressions to valid C expressions (an alternative approach is 
    that a developer specifies the corresponding C expressions in a 
    .pyf file). 
 
    In the second case, when user provides an input array with a given 
    size but some hidden parameters used in dimensions specifications 
    need to be determined based on the input array size. This is a 
    harder problem because f2py has to solve the inverse problem: find 
    a parameter `p` such that `upper(p) - lower(p) + 1` equals to the 
    size of input array. In the case when this equation cannot be 
    solved (e.g. because the input array size is wrong), raise an 
    error before calling the Fortran function (that otherwise would 
    likely crash Python process when the size of input arrays is 
    wrong). f2py currently supports this case only when the equation 
    is linear with respect to unknown parameter. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">suffix = </span><span class="s3">&quot;.f90&quot;</span>

    <span class="s1">code_template = textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
      function get_arr_size_{count}(a, n) result (length) 
        integer, intent(in) :: n 
        integer, dimension({dimspec}), intent(out) :: a 
        integer length 
        length = size(a) 
      end function 
 
      subroutine get_inv_arr_size_{count}(a, n) 
        integer :: n 
        ! the value of n is computed in f2py wrapper 
        !f2py intent(out) n 
        integer, dimension({dimspec}), intent(in) :: a 
        if (a({first}).gt.0) then 
          print*, &quot;a=&quot;, a 
        endif 
      end subroutine 
    &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">linear_dimspecs = [</span>
        <span class="s3">&quot;n&quot;</span><span class="s0">, </span><span class="s3">&quot;2*n&quot;</span><span class="s0">, </span><span class="s3">&quot;2:n&quot;</span><span class="s0">, </span><span class="s3">&quot;n/2&quot;</span><span class="s0">, </span><span class="s3">&quot;5 - n/2&quot;</span><span class="s0">, </span><span class="s3">&quot;3*n:20&quot;</span><span class="s0">, </span><span class="s3">&quot;n*(n+1):n*(n+5)&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;2*n, n&quot;</span>
    <span class="s1">]</span>
    <span class="s1">nonlinear_dimspecs = [</span><span class="s3">&quot;2*n:3*n*n+2*n&quot;</span><span class="s1">]</span>
    <span class="s1">all_dimspecs = linear_dimspecs + nonlinear_dimspecs</span>

    <span class="s1">code = </span><span class="s3">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">count</span><span class="s0">, </span><span class="s1">dimspec </span><span class="s0">in </span><span class="s1">enumerate(all_dimspecs):</span>
        <span class="s1">lst = [(d.split(</span><span class="s3">&quot;:&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">if </span><span class="s3">&quot;:&quot; </span><span class="s0">in </span><span class="s1">d </span><span class="s0">else </span><span class="s3">&quot;1&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dimspec.split(</span><span class="s3">','</span><span class="s1">)]</span>
        <span class="s1">code += code_template.format(</span>
            <span class="s1">count=count</span><span class="s0">,</span>
            <span class="s1">dimspec=dimspec</span><span class="s0">,</span>
            <span class="s1">first=</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(lst)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dimspec&quot;</span><span class="s0">, </span><span class="s1">all_dimspecs)</span>
    <span class="s0">def </span><span class="s1">test_array_size(self</span><span class="s0">, </span><span class="s1">dimspec):</span>

        <span class="s1">count = self.all_dimspecs.index(dimspec)</span>
        <span class="s1">get_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f&quot;get_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">sz</span><span class="s0">, </span><span class="s1">a = get_arr_size(n)</span>
            <span class="s0">assert </span><span class="s1">a.size == sz</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dimspec&quot;</span><span class="s0">, </span><span class="s1">all_dimspecs)</span>
    <span class="s0">def </span><span class="s1">test_inv_array_size(self</span><span class="s0">, </span><span class="s1">dimspec):</span>

        <span class="s1">count = self.all_dimspecs.index(dimspec)</span>
        <span class="s1">get_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f&quot;get_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">get_inv_arr_size = getattr(self.module</span><span class="s0">, </span><span class="s3">f&quot;get_inv_arr_size_</span><span class="s0">{</span><span class="s1">count</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]:</span>
            <span class="s1">sz</span><span class="s0">, </span><span class="s1">a = get_arr_size(n)</span>
            <span class="s0">if </span><span class="s1">dimspec </span><span class="s0">in </span><span class="s1">self.nonlinear_dimspecs:</span>
                <span class="s2"># one must specify n as input, the call we'll ensure</span>
                <span class="s2"># that a and n are compatible:</span>
                <span class="s1">n1 = get_inv_arr_size(a</span><span class="s0">, </span><span class="s1">n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s2"># in case of linear dependence, n can be determined</span>
                <span class="s2"># from the shape of a:</span>
                <span class="s1">n1 = get_inv_arr_size(a)</span>
            <span class="s2"># n1 may be different from n (for instance, when `a` size</span>
            <span class="s2"># is a function of some `n` fraction) but it must produce</span>
            <span class="s2"># the same sized array</span>
            <span class="s1">sz1</span><span class="s0">, </span><span class="s1">_ = get_arr_size(n1)</span>
            <span class="s0">assert </span><span class="s1">sz == sz1</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">n1</span><span class="s0">, </span><span class="s1">sz</span><span class="s0">, </span><span class="s1">sz1)</span>


<span class="s0">class </span><span class="s1">TestModuleDeclaration:</span>
    <span class="s0">def </span><span class="s1">test_dependencies(self</span><span class="s0">, </span><span class="s1">tmp_path):</span>
        <span class="s1">fpath = util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;foo_deps.f90&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(fpath)])</span>
        <span class="s0">assert </span><span class="s1">len(mod) == </span><span class="s4">1</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;vars&quot;</span><span class="s1">][</span><span class="s3">&quot;abar&quot;</span><span class="s1">][</span><span class="s3">&quot;=&quot;</span><span class="s1">] == </span><span class="s3">&quot;bar('abar')&quot;</span>

<span class="s0">class </span><span class="s1">TestEval(util.F2PyTest):</span>
    <span class="s0">def </span><span class="s1">test_eval_scalar(self):</span>
        <span class="s1">eval_scalar = crackfortran._eval_scalar</span>

        <span class="s0">assert </span><span class="s1">eval_scalar(</span><span class="s3">'123'</span><span class="s0">, </span><span class="s1">{}) == </span><span class="s3">'123'</span>
        <span class="s0">assert </span><span class="s1">eval_scalar(</span><span class="s3">'12 + 3'</span><span class="s0">, </span><span class="s1">{}) == </span><span class="s3">'15'</span>
        <span class="s0">assert </span><span class="s1">eval_scalar(</span><span class="s3">'a + b'</span><span class="s0">, </span><span class="s1">dict(a=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">b=</span><span class="s4">2</span><span class="s1">)) == </span><span class="s3">'3'</span>
        <span class="s0">assert </span><span class="s1">eval_scalar(</span><span class="s3">'&quot;123&quot;'</span><span class="s0">, </span><span class="s1">{}) == </span><span class="s3">&quot;'123'&quot;</span>


<span class="s0">class </span><span class="s1">TestFortranReader(util.F2PyTest):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;encoding&quot;</span><span class="s0">,</span>
                             <span class="s1">[</span><span class="s3">'ascii'</span><span class="s0">, </span><span class="s3">'utf-8'</span><span class="s0">, </span><span class="s3">'utf-16'</span><span class="s0">, </span><span class="s3">'utf-32'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_input_encoding(self</span><span class="s0">, </span><span class="s1">tmp_path</span><span class="s0">, </span><span class="s1">encoding):</span>
        <span class="s2"># gh-635</span>
        <span class="s1">f_path = tmp_path / </span><span class="s3">f&quot;input_with_</span><span class="s0">{</span><span class="s1">encoding</span><span class="s0">}</span><span class="s3">_encoding.f90&quot;</span>
        <span class="s0">with </span><span class="s1">f_path.open(</span><span class="s3">'w'</span><span class="s0">, </span><span class="s1">encoding=encoding) </span><span class="s0">as </span><span class="s1">ff:</span>
            <span class="s1">ff.write(</span><span class="s3">&quot;&quot;&quot; 
                     subroutine foo() 
                     end subroutine foo 
                     &quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">mod = crackfortran.crackfortran([str(f_path)])</span>
        <span class="s0">assert </span><span class="s1">mod[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">'name'</span><span class="s1">] == </span><span class="s3">'foo'</span>

<span class="s0">class </span><span class="s1">TestUnicodeComment(util.F2PyTest):</span>
    <span class="s1">sources = [util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;crackfortran&quot;</span><span class="s0">, </span><span class="s3">&quot;unicode_comment.f90&quot;</span><span class="s1">)]</span>

    <span class="s1">@pytest.mark.skipif(</span>
        <span class="s1">(importlib.util.find_spec(</span><span class="s3">&quot;charset_normalizer&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">reason=</span><span class="s3">&quot;test requires charset_normalizer which is not installed&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_encoding_comment(self):</span>
        <span class="s1">self.module.foo(</span><span class="s4">3</span><span class="s1">)</span>
</pre>
</body>
</html>