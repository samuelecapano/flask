<html>
<head>
<title>lines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lines.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
2D lines with support for a variety of line styles, markers, colors, etc. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">copy</span>

<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span><span class="s2">, </span><span class="s1">Number</span><span class="s2">, </span><span class="s1">Real</span>
<span class="s2">import </span><span class="s1">logging</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">colors </span><span class="s2">as </span><span class="s1">mcolors</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">from </span><span class="s1">.artist </span><span class="s2">import </span><span class="s1">Artist</span><span class="s2">, </span><span class="s1">allow_rasterization</span>
<span class="s2">from </span><span class="s1">.cbook </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_to_unmasked_float_array</span><span class="s2">, </span><span class="s1">ls_mapper</span><span class="s2">, </span><span class="s1">ls_mapper_r</span><span class="s2">, </span><span class="s1">STEP_LOOKUP_MAP)</span>
<span class="s2">from </span><span class="s1">.markers </span><span class="s2">import </span><span class="s1">MarkerStyle</span>
<span class="s2">from </span><span class="s1">.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">.transforms </span><span class="s2">import </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxTransformTo</span><span class="s2">, </span><span class="s1">TransformedPath</span>
<span class="s2">from </span><span class="s1">._enums </span><span class="s2">import </span><span class="s1">JoinStyle</span><span class="s2">, </span><span class="s1">CapStyle</span>

<span class="s3"># Imported here for backward compatibility, even though they don't</span>
<span class="s3"># really belong.</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_path</span>
<span class="s2">from </span><span class="s1">.markers </span><span class="s2">import </span><span class="s1">(  </span><span class="s3"># noqa</span>
    <span class="s1">CARETLEFT</span><span class="s2">, </span><span class="s1">CARETRIGHT</span><span class="s2">, </span><span class="s1">CARETUP</span><span class="s2">, </span><span class="s1">CARETDOWN</span><span class="s2">,</span>
    <span class="s1">CARETLEFTBASE</span><span class="s2">, </span><span class="s1">CARETRIGHTBASE</span><span class="s2">, </span><span class="s1">CARETUPBASE</span><span class="s2">, </span><span class="s1">CARETDOWNBASE</span><span class="s2">,</span>
    <span class="s1">TICKLEFT</span><span class="s2">, </span><span class="s1">TICKRIGHT</span><span class="s2">, </span><span class="s1">TICKUP</span><span class="s2">, </span><span class="s1">TICKDOWN)</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">_get_dash_pattern(style):</span>
    <span class="s0">&quot;&quot;&quot;Convert linestyle to dash pattern.&quot;&quot;&quot;</span>
    <span class="s3"># go from short hand -&gt; full strings</span>
    <span class="s2">if </span><span class="s1">isinstance(style</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">style = ls_mapper.get(style</span><span class="s2">, </span><span class="s1">style)</span>
    <span class="s3"># un-dashed styles</span>
    <span class="s2">if </span><span class="s1">style </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'solid'</span><span class="s2">, </span><span class="s4">'None'</span><span class="s1">]:</span>
        <span class="s1">offset = </span><span class="s5">0</span>
        <span class="s1">dashes = </span><span class="s2">None</span>
    <span class="s3"># dashed styles</span>
    <span class="s2">elif </span><span class="s1">style </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'dashed'</span><span class="s2">, </span><span class="s4">'dashdot'</span><span class="s2">, </span><span class="s4">'dotted'</span><span class="s1">]:</span>
        <span class="s1">offset = </span><span class="s5">0</span>
        <span class="s1">dashes = tuple(mpl.rcParams[</span><span class="s4">'lines.{}_pattern'</span><span class="s1">.format(style)])</span>
    <span class="s3">#</span>
    <span class="s2">elif </span><span class="s1">isinstance(style</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s1">offset</span><span class="s2">, </span><span class="s1">dashes = style</span>
        <span class="s2">if </span><span class="s1">offset </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'Unrecognized linestyle: </span><span class="s2">{</span><span class="s1">style</span><span class="s2">!r}</span><span class="s4">'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'Unrecognized linestyle: </span><span class="s2">{</span><span class="s1">style</span><span class="s2">!r}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s3"># normalize offset to be positive and shorter than the dash cycle</span>
    <span class="s2">if </span><span class="s1">dashes </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">dsum = sum(dashes)</span>
        <span class="s2">if </span><span class="s1">dsum:</span>
            <span class="s1">offset %= dsum</span>

    <span class="s2">return </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">dashes</span>


<span class="s2">def </span><span class="s1">_scale_dashes(offset</span><span class="s2">, </span><span class="s1">dashes</span><span class="s2">, </span><span class="s1">lw):</span>
    <span class="s2">if not </span><span class="s1">mpl.rcParams[</span><span class="s4">'lines.scale_dashes'</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">dashes</span>
    <span class="s1">scaled_offset = offset * lw</span>
    <span class="s1">scaled_dashes = ([x * lw </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None else None for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dashes]</span>
                     <span class="s2">if </span><span class="s1">dashes </span><span class="s2">is not None else None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">scaled_offset</span><span class="s2">, </span><span class="s1">scaled_dashes</span>


<span class="s2">def </span><span class="s1">segment_hits(cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">radius):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the indices of the segments in the polyline with coordinates (*cx*, 
    *cy*) that are within a distance *radius* of the point (*x*, *y*). 
    &quot;&quot;&quot;</span>
    <span class="s3"># Process single points specially</span>
    <span class="s2">if </span><span class="s1">len(x) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">= np.nonzero((cx - x) ** </span><span class="s5">2 </span><span class="s1">+ (cy - y) ** </span><span class="s5">2 </span><span class="s1">&lt;= radius ** </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">res</span>

    <span class="s3"># We need to lop the last element off a lot.</span>
    <span class="s1">xr</span><span class="s2">, </span><span class="s1">yr = x[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3"># Only look at line segments whose nearest point to C on the line</span>
    <span class="s3"># lies within the segment.</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x[</span><span class="s5">1</span><span class="s1">:] - xr</span><span class="s2">, </span><span class="s1">y[</span><span class="s5">1</span><span class="s1">:] - yr</span>
    <span class="s1">Lnorm_sq = dx ** </span><span class="s5">2 </span><span class="s1">+ dy ** </span><span class="s5">2  </span><span class="s3"># Possibly want to eliminate Lnorm==0</span>
    <span class="s1">u = ((cx - xr) * dx + (cy - yr) * dy) / Lnorm_sq</span>
    <span class="s1">candidates = (u &gt;= </span><span class="s5">0</span><span class="s1">) &amp; (u &lt;= </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3"># Note that there is a little area near one side of each point</span>
    <span class="s3"># which will be near neither segment, and another which will</span>
    <span class="s3"># be near both, depending on the angle of the lines.  The</span>
    <span class="s3"># following radius test eliminates these ambiguities.</span>
    <span class="s1">point_hits = (cx - x) ** </span><span class="s5">2 </span><span class="s1">+ (cy - y) ** </span><span class="s5">2 </span><span class="s1">&lt;= radius ** </span><span class="s5">2</span>
    <span class="s1">candidates = candidates &amp; ~(point_hits[:-</span><span class="s5">1</span><span class="s1">] | point_hits[</span><span class="s5">1</span><span class="s1">:])</span>

    <span class="s3"># For those candidates which remain, determine how far they lie away</span>
    <span class="s3"># from the line.</span>
    <span class="s1">px</span><span class="s2">, </span><span class="s1">py = xr + u * dx</span><span class="s2">, </span><span class="s1">yr + u * dy</span>
    <span class="s1">line_hits = (cx - px) ** </span><span class="s5">2 </span><span class="s1">+ (cy - py) ** </span><span class="s5">2 </span><span class="s1">&lt;= radius ** </span><span class="s5">2</span>
    <span class="s1">line_hits = line_hits &amp; candidates</span>
    <span class="s1">points</span><span class="s2">, </span><span class="s1">= point_hits.ravel().nonzero()</span>
    <span class="s1">lines</span><span class="s2">, </span><span class="s1">= line_hits.ravel().nonzero()</span>
    <span class="s2">return </span><span class="s1">np.concatenate((points</span><span class="s2">, </span><span class="s1">lines))</span>


<span class="s2">def </span><span class="s1">_mark_every_path(markevery</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">ax):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function that sorts out how to deal the input 
    `markevery` and returns the points where markers should be drawn. 
 
    Takes in the `markevery` value and the line path and returns the 
    sub-sampled path. 
    &quot;&quot;&quot;</span>
    <span class="s3"># pull out the two bits of data we want from the path</span>
    <span class="s1">codes</span><span class="s2">, </span><span class="s1">verts = tpath.codes</span><span class="s2">, </span><span class="s1">tpath.vertices</span>

    <span class="s2">def </span><span class="s1">_slice_or_none(in_v</span><span class="s2">, </span><span class="s1">slc):</span>
        <span class="s0">&quot;&quot;&quot;Helper function to cope with `codes` being an ndarray or `None`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">in_v </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">in_v[slc]</span>

    <span class="s3"># if just an int, assume starting at 0 and make a tuple</span>
    <span class="s2">if </span><span class="s1">isinstance(markevery</span><span class="s2">, </span><span class="s1">Integral):</span>
        <span class="s1">markevery = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">markevery)</span>
    <span class="s3"># if just a float, assume starting at 0.0 and make a tuple</span>
    <span class="s2">elif </span><span class="s1">isinstance(markevery</span><span class="s2">, </span><span class="s1">Real):</span>
        <span class="s1">markevery = (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">markevery)</span>

    <span class="s2">if </span><span class="s1">isinstance(markevery</span><span class="s2">, </span><span class="s1">tuple):</span>
        <span class="s2">if </span><span class="s1">len(markevery) != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'`markevery` is a tuple but its len is not 2; '</span>
                             <span class="s4">'markevery={}'</span><span class="s1">.format(markevery))</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">step = markevery</span>
        <span class="s3"># if step is an int, old behavior</span>
        <span class="s2">if </span><span class="s1">isinstance(step</span><span class="s2">, </span><span class="s1">Integral):</span>
            <span class="s3"># tuple of 2 int is for backwards compatibility,</span>
            <span class="s2">if not </span><span class="s1">isinstance(start</span><span class="s2">, </span><span class="s1">Integral):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">'`markevery` is a tuple with len 2 and second element is '</span>
                    <span class="s4">'an int, but the first element is not an int; markevery={}'</span>
                    <span class="s1">.format(markevery))</span>
            <span class="s3"># just return, we are done here</span>

            <span class="s2">return </span><span class="s1">Path(verts[slice(start</span><span class="s2">, None, </span><span class="s1">step)]</span><span class="s2">,</span>
                        <span class="s1">_slice_or_none(codes</span><span class="s2">, </span><span class="s1">slice(start</span><span class="s2">, None, </span><span class="s1">step)))</span>

        <span class="s2">elif </span><span class="s1">isinstance(step</span><span class="s2">, </span><span class="s1">Real):</span>
            <span class="s2">if not </span><span class="s1">isinstance(start</span><span class="s2">, </span><span class="s1">Real):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">'`markevery` is a tuple with len 2 and second element is '</span>
                    <span class="s4">'a float, but the first element is not a float or an int; '</span>
                    <span class="s4">'markevery={}'</span><span class="s1">.format(markevery))</span>
            <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;markevery is specified relative to the axes size, but &quot;</span>
                    <span class="s4">&quot;the line does not have a Axes as parent&quot;</span><span class="s1">)</span>

            <span class="s3"># calc cumulative distance along path (in display coords):</span>
            <span class="s1">fin = np.isfinite(verts).all(axis=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">fverts = verts[fin]</span>
            <span class="s1">disp_coords = affine.transform(fverts)</span>

            <span class="s1">delta = np.empty((len(disp_coords)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">delta[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s5">0</span>
            <span class="s1">delta[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = disp_coords[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] - disp_coords[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s1">delta = np.hypot(*delta.T).cumsum()</span>
            <span class="s3"># calc distance between markers along path based on the axes</span>
            <span class="s3"># bounding box diagonal being a distance of unity:</span>
            <span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1) = ax.transAxes.transform([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s1">scale = np.hypot(x1 - x0</span><span class="s2">, </span><span class="s1">y1 - y0)</span>
            <span class="s1">marker_delta = np.arange(start * scale</span><span class="s2">, </span><span class="s1">delta[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">step * scale)</span>
            <span class="s3"># find closest actual data point that is closest to</span>
            <span class="s3"># the theoretical distance along the path:</span>
            <span class="s1">inds = np.abs(delta[np.newaxis</span><span class="s2">, </span><span class="s1">:] - marker_delta[:</span><span class="s2">, </span><span class="s1">np.newaxis])</span>
            <span class="s1">inds = inds.argmin(axis=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">inds = np.unique(inds)</span>
            <span class="s3"># return, we are done here</span>
            <span class="s2">return </span><span class="s1">Path(fverts[inds]</span><span class="s2">, </span><span class="s1">_slice_or_none(codes</span><span class="s2">, </span><span class="s1">inds))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;markevery=</span><span class="s2">{</span><span class="s1">markevery</span><span class="s2">!r} </span><span class="s4">is a tuple with len 2, but its &quot;</span>
                <span class="s4">f&quot;second element is not an int or a float&quot;</span><span class="s1">)</span>

    <span class="s2">elif </span><span class="s1">isinstance(markevery</span><span class="s2">, </span><span class="s1">slice):</span>
        <span class="s3"># mazol tov, it's already a slice, just return</span>
        <span class="s2">return </span><span class="s1">Path(verts[markevery]</span><span class="s2">, </span><span class="s1">_slice_or_none(codes</span><span class="s2">, </span><span class="s1">markevery))</span>

    <span class="s2">elif </span><span class="s1">np.iterable(markevery):</span>
        <span class="s3"># fancy indexing</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">Path(verts[markevery]</span><span class="s2">, </span><span class="s1">_slice_or_none(codes</span><span class="s2">, </span><span class="s1">markevery))</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">IndexError) </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;markevery=</span><span class="s2">{</span><span class="s1">markevery</span><span class="s2">!r} </span><span class="s4">is iterable but not a valid numpy &quot;</span>
                <span class="s4">f&quot;fancy index&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;markevery=</span><span class="s2">{</span><span class="s1">markevery</span><span class="s2">!r} </span><span class="s4">is not a recognized value&quot;</span><span class="s1">)</span>


<span class="s1">@_docstring.interpd</span>
<span class="s1">@_api.define_aliases({</span>
    <span class="s4">&quot;antialiased&quot;</span><span class="s1">: [</span><span class="s4">&quot;aa&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;color&quot;</span><span class="s1">: [</span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;drawstyle&quot;</span><span class="s1">: [</span><span class="s4">&quot;ds&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;linestyle&quot;</span><span class="s1">: [</span><span class="s4">&quot;ls&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;linewidth&quot;</span><span class="s1">: [</span><span class="s4">&quot;lw&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;markeredgecolor&quot;</span><span class="s1">: [</span><span class="s4">&quot;mec&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;markeredgewidth&quot;</span><span class="s1">: [</span><span class="s4">&quot;mew&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;markerfacecolor&quot;</span><span class="s1">: [</span><span class="s4">&quot;mfc&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;markerfacecoloralt&quot;</span><span class="s1">: [</span><span class="s4">&quot;mfcalt&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;markersize&quot;</span><span class="s1">: [</span><span class="s4">&quot;ms&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">})</span>
<span class="s2">class </span><span class="s1">Line2D(Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A line - the line can have both a solid linestyle connecting all 
    the vertices, and a marker at each vertex.  Additionally, the 
    drawing of the solid line is influenced by the drawstyle, e.g., one 
    can create &quot;stepped&quot; lines in various styles. 
    &quot;&quot;&quot;</span>

    <span class="s1">lineStyles = _lineStyles = {  </span><span class="s3"># hidden names deprecated</span>
        <span class="s4">'-'</span><span class="s1">:    </span><span class="s4">'_draw_solid'</span><span class="s2">,</span>
        <span class="s4">'--'</span><span class="s1">:   </span><span class="s4">'_draw_dashed'</span><span class="s2">,</span>
        <span class="s4">'-.'</span><span class="s1">:   </span><span class="s4">'_draw_dash_dot'</span><span class="s2">,</span>
        <span class="s4">':'</span><span class="s1">:    </span><span class="s4">'_draw_dotted'</span><span class="s2">,</span>
        <span class="s4">'None'</span><span class="s1">: </span><span class="s4">'_draw_nothing'</span><span class="s2">,</span>
        <span class="s4">' '</span><span class="s1">:    </span><span class="s4">'_draw_nothing'</span><span class="s2">,</span>
        <span class="s4">''</span><span class="s1">:     </span><span class="s4">'_draw_nothing'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s1">_drawStyles_l = {</span>
        <span class="s4">'default'</span><span class="s1">:    </span><span class="s4">'_draw_lines'</span><span class="s2">,</span>
        <span class="s4">'steps-mid'</span><span class="s1">:  </span><span class="s4">'_draw_steps_mid'</span><span class="s2">,</span>
        <span class="s4">'steps-pre'</span><span class="s1">:  </span><span class="s4">'_draw_steps_pre'</span><span class="s2">,</span>
        <span class="s4">'steps-post'</span><span class="s1">: </span><span class="s4">'_draw_steps_post'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s1">_drawStyles_s = {</span>
        <span class="s4">'steps'</span><span class="s1">: </span><span class="s4">'_draw_steps_pre'</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s3"># drawStyles should now be deprecated.</span>
    <span class="s1">drawStyles = {**_drawStyles_l</span><span class="s2">, </span><span class="s1">**_drawStyles_s}</span>
    <span class="s3"># Need a list ordered with long names first:</span>
    <span class="s1">drawStyleKeys = [*_drawStyles_l</span><span class="s2">, </span><span class="s1">*_drawStyles_s]</span>

    <span class="s3"># Referenced here to maintain API.  These are defined in</span>
    <span class="s3"># MarkerStyle</span>
    <span class="s1">markers = MarkerStyle.markers</span>
    <span class="s1">filled_markers = MarkerStyle.filled_markers</span>
    <span class="s1">fillStyles = MarkerStyle.fillstyles</span>

    <span class="s1">zorder = </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self._label != </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">f&quot;Line2D(</span><span class="s2">{</span><span class="s1">self._label</span><span class="s2">}</span><span class="s4">)&quot;</span>
        <span class="s2">elif </span><span class="s1">self._x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;Line2D()&quot;</span>
        <span class="s2">elif </span><span class="s1">len(self._x) &gt; </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;Line2D((%g,%g),(%g,%g),...,(%g,%g))&quot; </span><span class="s1">% (</span>
                <span class="s1">self._x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._y[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._x[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self._y[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._x[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._y[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;Line2D(%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;,&quot;</span><span class="s1">.join(</span>
                <span class="s1">map(</span><span class="s4">&quot;({:g},{:g})&quot;</span><span class="s1">.format</span><span class="s2">, </span><span class="s1">self._x</span><span class="s2">, </span><span class="s1">self._y))</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;linewidth&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">,</span>
                 <span class="s1">linewidth=</span><span class="s2">None,  </span><span class="s3"># all Nones default to rc</span>
                 <span class="s1">linestyle=</span><span class="s2">None,</span>
                 <span class="s1">color=</span><span class="s2">None,</span>
                 <span class="s1">gapcolor=</span><span class="s2">None,</span>
                 <span class="s1">marker=</span><span class="s2">None,</span>
                 <span class="s1">markersize=</span><span class="s2">None,</span>
                 <span class="s1">markeredgewidth=</span><span class="s2">None,</span>
                 <span class="s1">markeredgecolor=</span><span class="s2">None,</span>
                 <span class="s1">markerfacecolor=</span><span class="s2">None,</span>
                 <span class="s1">markerfacecoloralt=</span><span class="s4">'none'</span><span class="s2">,</span>
                 <span class="s1">fillstyle=</span><span class="s2">None,</span>
                 <span class="s1">antialiased=</span><span class="s2">None,</span>
                 <span class="s1">dash_capstyle=</span><span class="s2">None,</span>
                 <span class="s1">solid_capstyle=</span><span class="s2">None,</span>
                 <span class="s1">dash_joinstyle=</span><span class="s2">None,</span>
                 <span class="s1">solid_joinstyle=</span><span class="s2">None,</span>
                 <span class="s1">pickradius=</span><span class="s5">5</span><span class="s2">,</span>
                 <span class="s1">drawstyle=</span><span class="s2">None,</span>
                 <span class="s1">markevery=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a `.Line2D` instance with *x* and *y* data in sequences of 
        *xdata*, *ydata*. 
 
        Additional keyword arguments are `.Line2D` properties: 
 
        %(Line2D:kwdoc)s 
 
        See :meth:`set_linestyle` for a description of the line styles, 
        :meth:`set_marker` for a description of the markers, and 
        :meth:`set_drawstyle` for a description of the draw styles. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>

        <span class="s3"># Convert sequences to NumPy arrays.</span>
        <span class="s2">if not </span><span class="s1">np.iterable(xdata):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'xdata must be a sequence'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">np.iterable(ydata):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'ydata must be a sequence'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">linewidth </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">linewidth = mpl.rcParams[</span><span class="s4">'lines.linewidth'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">linestyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">linestyle = mpl.rcParams[</span><span class="s4">'lines.linestyle'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">marker </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">marker = mpl.rcParams[</span><span class="s4">'lines.marker'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = mpl.rcParams[</span><span class="s4">'lines.color'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">markersize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">markersize = mpl.rcParams[</span><span class="s4">'lines.markersize'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">antialiased </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">antialiased = mpl.rcParams[</span><span class="s4">'lines.antialiased'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">dash_capstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dash_capstyle = mpl.rcParams[</span><span class="s4">'lines.dash_capstyle'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">dash_joinstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dash_joinstyle = mpl.rcParams[</span><span class="s4">'lines.dash_joinstyle'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">solid_capstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">solid_capstyle = mpl.rcParams[</span><span class="s4">'lines.solid_capstyle'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">solid_joinstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">solid_joinstyle = mpl.rcParams[</span><span class="s4">'lines.solid_joinstyle'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">drawstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">drawstyle = </span><span class="s4">'default'</span>

        <span class="s1">self._dashcapstyle = </span><span class="s2">None</span>
        <span class="s1">self._dashjoinstyle = </span><span class="s2">None</span>
        <span class="s1">self._solidjoinstyle = </span><span class="s2">None</span>
        <span class="s1">self._solidcapstyle = </span><span class="s2">None</span>
        <span class="s1">self.set_dash_capstyle(dash_capstyle)</span>
        <span class="s1">self.set_dash_joinstyle(dash_joinstyle)</span>
        <span class="s1">self.set_solid_capstyle(solid_capstyle)</span>
        <span class="s1">self.set_solid_joinstyle(solid_joinstyle)</span>

        <span class="s1">self._linestyles = </span><span class="s2">None</span>
        <span class="s1">self._drawstyle = </span><span class="s2">None</span>
        <span class="s1">self._linewidth = linewidth</span>
        <span class="s1">self._unscaled_dash_pattern = (</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)  </span><span class="s3"># offset, dash</span>
        <span class="s1">self._dash_pattern = (</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)  </span><span class="s3"># offset, dash (scaled by linewidth)</span>

        <span class="s1">self.set_linewidth(linewidth)</span>
        <span class="s1">self.set_linestyle(linestyle)</span>
        <span class="s1">self.set_drawstyle(drawstyle)</span>

        <span class="s1">self._color = </span><span class="s2">None</span>
        <span class="s1">self.set_color(color)</span>
        <span class="s2">if </span><span class="s1">marker </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">marker = </span><span class="s4">'none'  </span><span class="s3"># Default.</span>
        <span class="s2">if not </span><span class="s1">isinstance(marker</span><span class="s2">, </span><span class="s1">MarkerStyle):</span>
            <span class="s1">self._marker = MarkerStyle(marker</span><span class="s2">, </span><span class="s1">fillstyle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._marker = marker</span>

        <span class="s1">self._gapcolor = </span><span class="s2">None</span>
        <span class="s1">self.set_gapcolor(gapcolor)</span>

        <span class="s1">self._markevery = </span><span class="s2">None</span>
        <span class="s1">self._markersize = </span><span class="s2">None</span>
        <span class="s1">self._antialiased = </span><span class="s2">None</span>

        <span class="s1">self.set_markevery(markevery)</span>
        <span class="s1">self.set_antialiased(antialiased)</span>
        <span class="s1">self.set_markersize(markersize)</span>

        <span class="s1">self._markeredgecolor = </span><span class="s2">None</span>
        <span class="s1">self._markeredgewidth = </span><span class="s2">None</span>
        <span class="s1">self._markerfacecolor = </span><span class="s2">None</span>
        <span class="s1">self._markerfacecoloralt = </span><span class="s2">None</span>

        <span class="s1">self.set_markerfacecolor(markerfacecolor)  </span><span class="s3"># Normalizes None to rc.</span>
        <span class="s1">self.set_markerfacecoloralt(markerfacecoloralt)</span>
        <span class="s1">self.set_markeredgecolor(markeredgecolor)  </span><span class="s3"># Normalizes None to rc.</span>
        <span class="s1">self.set_markeredgewidth(markeredgewidth)</span>

        <span class="s3"># update kwargs before updating data to give the caller a</span>
        <span class="s3"># chance to init axes (and hence unit support)</span>
        <span class="s1">self._internal_update(kwargs)</span>
        <span class="s1">self._pickradius = pickradius</span>
        <span class="s1">self.ind_offset = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">(isinstance(self._picker</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">isinstance(self._picker</span><span class="s2">, </span><span class="s1">bool)):</span>
            <span class="s1">self._pickradius = self._picker</span>

        <span class="s1">self._xorig = np.asarray([])</span>
        <span class="s1">self._yorig = np.asarray([])</span>
        <span class="s1">self._invalidx = </span><span class="s2">True</span>
        <span class="s1">self._invalidy = </span><span class="s2">True</span>
        <span class="s1">self._x = </span><span class="s2">None</span>
        <span class="s1">self._y = </span><span class="s2">None</span>
        <span class="s1">self._xy = </span><span class="s2">None</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self._transformed_path = </span><span class="s2">None</span>
        <span class="s1">self._subslice = </span><span class="s2">False</span>
        <span class="s1">self._x_filled = </span><span class="s2">None  </span><span class="s3"># used in subslicing; only x is needed</span>

        <span class="s1">self.set_data(xdata</span><span class="s2">, </span><span class="s1">ydata)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether *mouseevent* occurred on the line. 
 
        An event is deemed to have occurred &quot;on&quot; the line if it is less 
        than ``self.pickradius`` (default: 5 points) away from it.  Use 
        `~.Line2D.get_pickradius` or `~.Line2D.set_pickradius` to get or set 
        the pick radius. 
 
        Parameters 
        ---------- 
        mouseevent : `matplotlib.backend_bases.MouseEvent` 
 
        Returns 
        ------- 
        contains : bool 
            Whether any values are within the radius. 
        details : dict 
            A dictionary ``{'ind': pointlist}``, where *pointlist* is a 
            list of points of the line that are within the pickradius around 
            the event position. 
 
            TODO: sort returned indices by distance 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s3"># Make sure we have data to plot</span>
        <span class="s2">if </span><span class="s1">self._invalidy </span><span class="s2">or </span><span class="s1">self._invalidx:</span>
            <span class="s1">self.recache()</span>
        <span class="s2">if </span><span class="s1">len(self._xy) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>

        <span class="s3"># Convert points to pixels</span>
        <span class="s1">transformed_path = self._get_transformed_path()</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">affine = transformed_path.get_transformed_path_and_affine()</span>
        <span class="s1">path = affine.transform_path(path)</span>
        <span class="s1">xy = path.vertices</span>
        <span class="s1">xt = xy[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">yt = xy[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3"># Convert pick radius from points to pixels</span>
        <span class="s2">if </span><span class="s1">self.figure </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">_log.warning(</span><span class="s4">'no figure set when check if mouse is on line'</span><span class="s1">)</span>
            <span class="s1">pixels = self._pickradius</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pixels = self.figure.dpi / </span><span class="s5">72. </span><span class="s1">* self._pickradius</span>

        <span class="s3"># The math involved in checking for containment (here and inside of</span>
        <span class="s3"># segment_hits) assumes that it is OK to overflow, so temporarily set</span>
        <span class="s3"># the error flags accordingly.</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s3"># Check for collision</span>
            <span class="s2">if </span><span class="s1">self._linestyle </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'None'</span><span class="s2">, None</span><span class="s1">]:</span>
                <span class="s3"># If no line, return the nearby point(s)</span>
                <span class="s1">ind</span><span class="s2">, </span><span class="s1">= np.nonzero(</span>
                    <span class="s1">(xt - mouseevent.x) ** </span><span class="s5">2 </span><span class="s1">+ (yt - mouseevent.y) ** </span><span class="s5">2</span>
                    <span class="s1">&lt;= pixels ** </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># If line, return the nearby segment(s)</span>
                <span class="s1">ind = segment_hits(mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y</span><span class="s2">, </span><span class="s1">xt</span><span class="s2">, </span><span class="s1">yt</span><span class="s2">, </span><span class="s1">pixels)</span>
                <span class="s2">if </span><span class="s1">self._drawstyle.startswith(</span><span class="s4">&quot;steps&quot;</span><span class="s1">):</span>
                    <span class="s1">ind //= </span><span class="s5">2</span>

        <span class="s1">ind += self.ind_offset</span>

        <span class="s3"># Return the point(s) within radius</span>
        <span class="s2">return </span><span class="s1">len(ind) &gt; </span><span class="s5">0</span><span class="s2">, </span><span class="s1">dict(ind=ind)</span>

    <span class="s2">def </span><span class="s1">get_pickradius(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the pick radius used for containment tests. 
 
        See `.contains` for more details. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._pickradius</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;d&quot;</span><span class="s2">, </span><span class="s4">&quot;pickradius&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_pickradius(self</span><span class="s2">, </span><span class="s1">pickradius):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the pick radius used for containment tests. 
 
        See `.contains` for more details. 
 
        Parameters 
        ---------- 
        pickradius : float 
            Pick radius, in points. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(pickradius</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">or </span><span class="s1">pickradius &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;pick radius should be a distance&quot;</span><span class="s1">)</span>
        <span class="s1">self._pickradius = pickradius</span>

    <span class="s1">pickradius = property(get_pickradius</span><span class="s2">, </span><span class="s1">set_pickradius)</span>

    <span class="s2">def </span><span class="s1">get_fillstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the marker fill style. 
 
        See also `~.Line2D.set_fillstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._marker.get_fillstyle()</span>

    <span class="s2">def </span><span class="s1">set_fillstyle(self</span><span class="s2">, </span><span class="s1">fs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the marker fill style. 
 
        Parameters 
        ---------- 
        fs : {'full', 'left', 'right', 'bottom', 'top', 'none'} 
            Possible values: 
 
            - 'full': Fill the whole marker with the *markerfacecolor*. 
            - 'left', 'right', 'bottom', 'top': Fill the marker half at 
              the given side with the *markerfacecolor*. The other 
              half of the marker is filled with *markerfacecoloralt*. 
            - 'none': No filling. 
 
            For examples see :ref:`marker_fill_styles`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_marker(MarkerStyle(self._marker.get_marker()</span><span class="s2">, </span><span class="s1">fs))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_markevery(self</span><span class="s2">, </span><span class="s1">every):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the markevery property to subsample the plot when using markers. 
 
        e.g., if ``every=5``, every 5-th marker will be plotted. 
 
        Parameters 
        ---------- 
        every : None or int or (int, int) or slice or list[int] or float or \ 
(float, float) or list[bool] 
            Which markers to plot. 
 
            - ``every=None``: every point will be plotted. 
            - ``every=N``: every N-th marker will be plotted starting with 
              marker 0. 
            - ``every=(start, N)``: every N-th marker, starting at index 
              *start*, will be plotted. 
            - ``every=slice(start, end, N)``: every N-th marker, starting at 
              index *start*, up to but not including index *end*, will be 
              plotted. 
            - ``every=[i, j, m, ...]``: only markers at the given indices 
              will be plotted. 
            - ``every=[True, False, True, ...]``: only positions that are True 
              will be plotted. The list must have the same length as the data 
              points. 
            - ``every=0.1``, (i.e. a float): markers will be spaced at 
              approximately equal visual distances along the line; the distance 
              along the line between markers is determined by multiplying the 
              display-coordinate distance of the axes bounding-box diagonal 
              by the value of *every*. 
            - ``every=(0.5, 0.1)`` (i.e. a length-2 tuple of float): similar 
              to ``every=0.1`` but the first marker will be offset along the 
              line by 0.5 multiplied by the 
              display-coordinate-diagonal-distance along the line. 
 
            For examples see 
            :doc:`/gallery/lines_bars_and_markers/markevery_demo`. 
 
        Notes 
        ----- 
        Setting *markevery* will still only draw markers at actual data points. 
        While the float argument form aims for uniform visual spacing, it has 
        to coerce from the ideal spacing to the nearest available data point. 
        Depending on the number and distribution of data points, the result 
        may still not look evenly spaced. 
 
        When using a start offset to specify the first marker, the offset will 
        be from the first data point which may be different from the first 
        the visible data point if the plot is zoomed in. 
 
        If zooming in on a plot when using float arguments then the actual 
        data points that have markers will change because the distance between 
        markers is always determined from the display-coordinates 
        axes-bounding-box-diagonal regardless of the actual axes data limits. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._markevery = every</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_markevery(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the markevery setting for marker subsampling. 
 
        See also `~.Line2D.set_markevery`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._markevery</span>

    <span class="s2">def </span><span class="s1">set_picker(self</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the event picker details for the line. 
 
        Parameters 
        ---------- 
        p : float or callable[[Artist, Event], tuple[bool, dict]] 
            If a float, it is used as the pick radius in points. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">callable(p):</span>
            <span class="s1">self.set_pickradius(p)</span>
        <span class="s1">self._picker = p</span>

    <span class="s2">def </span><span class="s1">get_bbox(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the bounding box of this line.&quot;&quot;&quot;</span>
        <span class="s1">bbox = Bbox([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">bbox.update_from_data_xy(self.get_xydata())</span>
        <span class="s2">return </span><span class="s1">bbox</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">bbox = Bbox([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">trans_data_to_xy = self.get_transform().transform</span>
        <span class="s1">bbox.update_from_data_xy(trans_data_to_xy(self.get_xydata())</span><span class="s2">,</span>
                                 <span class="s1">ignore=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s3"># correct for marker size, if any</span>
        <span class="s2">if </span><span class="s1">self._marker:</span>
            <span class="s1">ms = (self._markersize / </span><span class="s5">72.0 </span><span class="s1">* self.figure.dpi) * </span><span class="s5">0.5</span>
            <span class="s1">bbox = bbox.padded(ms)</span>
        <span class="s2">return </span><span class="s1">bbox</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the x and y data. 
 
        Parameters 
        ---------- 
        *args : (2, N) array or two 1D arrays 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">= args</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = args</span>

        <span class="s1">self.set_xdata(x)</span>
        <span class="s1">self.set_ydata(y)</span>

    <span class="s2">def </span><span class="s1">recache_always(self):</span>
        <span class="s1">self.recache(always=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">recache(self</span><span class="s2">, </span><span class="s1">always=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">always </span><span class="s2">or </span><span class="s1">self._invalidx:</span>
            <span class="s1">xconv = self.convert_xunits(self._xorig)</span>
            <span class="s1">x = _to_unmasked_float_array(xconv).ravel()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = self._x</span>
        <span class="s2">if </span><span class="s1">always </span><span class="s2">or </span><span class="s1">self._invalidy:</span>
            <span class="s1">yconv = self.convert_yunits(self._yorig)</span>
            <span class="s1">y = _to_unmasked_float_array(yconv).ravel()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = self._y</span>

        <span class="s1">self._xy = np.column_stack(np.broadcast_arrays(x</span><span class="s2">, </span><span class="s1">y)).astype(float)</span>
        <span class="s1">self._x</span><span class="s2">, </span><span class="s1">self._y = self._xy.T  </span><span class="s3"># views</span>

        <span class="s1">self._subslice = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">(self.axes </span><span class="s2">and </span><span class="s1">len(x) &gt; </span><span class="s5">1000 </span><span class="s2">and </span><span class="s1">self._is_sorted(x) </span><span class="s2">and</span>
                <span class="s1">self.axes.name == </span><span class="s4">'rectilinear' </span><span class="s2">and</span>
                <span class="s1">self.axes.get_xscale() == </span><span class="s4">'linear' </span><span class="s2">and</span>
                <span class="s1">self._markevery </span><span class="s2">is None and</span>
                <span class="s1">self.get_clip_on() </span><span class="s2">and</span>
                <span class="s1">self.get_transform() == self.axes.transData):</span>
            <span class="s1">self._subslice = </span><span class="s2">True</span>
            <span class="s1">nanmask = np.isnan(x)</span>
            <span class="s2">if </span><span class="s1">nanmask.any():</span>
                <span class="s1">self._x_filled = self._x.copy()</span>
                <span class="s1">indices = np.arange(len(x))</span>
                <span class="s1">self._x_filled[nanmask] = np.interp(</span>
                    <span class="s1">indices[nanmask]</span><span class="s2">, </span><span class="s1">indices[~nanmask]</span><span class="s2">, </span><span class="s1">self._x[~nanmask])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._x_filled = self._x</span>

        <span class="s2">if </span><span class="s1">self._path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">interpolation_steps = self._path._interpolation_steps</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">interpolation_steps = </span><span class="s5">1</span>
        <span class="s1">xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)</span>
        <span class="s1">self._path = Path(np.asarray(xy).T</span><span class="s2">,</span>
                          <span class="s1">_interpolation_steps=interpolation_steps)</span>
        <span class="s1">self._transformed_path = </span><span class="s2">None</span>
        <span class="s1">self._invalidx = </span><span class="s2">False</span>
        <span class="s1">self._invalidy = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_transform_path(self</span><span class="s2">, </span><span class="s1">subslice=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Put a TransformedPath instance at self._transformed_path; 
        all invalidation of the transform is then handled by the 
        TransformedPath instance. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Masked arrays are now handled by the Path class itself</span>
        <span class="s2">if </span><span class="s1">subslice </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy[subslice</span><span class="s2">, </span><span class="s1">:].T)</span>
            <span class="s1">_path = Path(np.asarray(xy).T</span><span class="s2">,</span>
                         <span class="s1">_interpolation_steps=self._path._interpolation_steps)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_path = self._path</span>
        <span class="s1">self._transformed_path = TransformedPath(_path</span><span class="s2">, </span><span class="s1">self.get_transform())</span>

    <span class="s2">def </span><span class="s1">_get_transformed_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this line's `~matplotlib.transforms.TransformedPath`.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._transformed_path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._transform_path()</span>
        <span class="s2">return </span><span class="s1">self._transformed_path</span>

    <span class="s2">def </span><span class="s1">set_transform(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">self._invalidx = </span><span class="s2">True</span>
        <span class="s1">self._invalidy = </span><span class="s2">True</span>
        <span class="s1">super().set_transform(t)</span>

    <span class="s2">def </span><span class="s1">_is_sorted(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Return whether x is sorted in ascending order.&quot;&quot;&quot;</span>
        <span class="s3"># We don't handle the monotonically decreasing case.</span>
        <span class="s2">return </span><span class="s1">_path.is_sorted(x)</span>

    <span class="s1">@allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self._invalidy </span><span class="s2">or </span><span class="s1">self._invalidx:</span>
            <span class="s1">self.recache()</span>
        <span class="s1">self.ind_offset = </span><span class="s5">0  </span><span class="s3"># Needed for contains() method.</span>
        <span class="s2">if </span><span class="s1">self._subslice </span><span class="s2">and </span><span class="s1">self.axes:</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 = self.axes.get_xbound()</span>
            <span class="s1">i0 = self._x_filled.searchsorted(x0</span><span class="s2">, </span><span class="s4">'left'</span><span class="s1">)</span>
            <span class="s1">i1 = self._x_filled.searchsorted(x1</span><span class="s2">, </span><span class="s4">'right'</span><span class="s1">)</span>
            <span class="s1">subslice = slice(max(i0 - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">i1 + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.ind_offset = subslice.start</span>
            <span class="s1">self._transform_path(subslice)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subslice = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.get_path_effects():</span>
            <span class="s2">from </span><span class="s1">matplotlib.patheffects </span><span class="s2">import </span><span class="s1">PathEffectRenderer</span>
            <span class="s1">renderer = PathEffectRenderer(self.get_path_effects()</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s1">renderer.open_group(</span><span class="s4">'line2d'</span><span class="s2">, </span><span class="s1">self.get_gid())</span>
        <span class="s2">if </span><span class="s1">self._lineStyles[self._linestyle] != </span><span class="s4">'_draw_nothing'</span><span class="s1">:</span>
            <span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine = (self._get_transformed_path()</span>
                             <span class="s1">.get_transformed_path_and_affine())</span>
            <span class="s2">if </span><span class="s1">len(tpath.vertices):</span>
                <span class="s1">gc = renderer.new_gc()</span>
                <span class="s1">self._set_gc_clip(gc)</span>
                <span class="s1">gc.set_url(self.get_url())</span>

                <span class="s1">gc.set_antialiased(self._antialiased)</span>
                <span class="s1">gc.set_linewidth(self._linewidth)</span>

                <span class="s2">if </span><span class="s1">self.is_dashed():</span>
                    <span class="s1">cap = self._dashcapstyle</span>
                    <span class="s1">join = self._dashjoinstyle</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">cap = self._solidcapstyle</span>
                    <span class="s1">join = self._solidjoinstyle</span>
                <span class="s1">gc.set_joinstyle(join)</span>
                <span class="s1">gc.set_capstyle(cap)</span>
                <span class="s1">gc.set_snap(self.get_snap())</span>
                <span class="s2">if </span><span class="s1">self.get_sketch_params() </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">gc.set_sketch_params(*self.get_sketch_params())</span>

                <span class="s3"># We first draw a path within the gaps if needed.</span>
                <span class="s2">if </span><span class="s1">self.is_dashed() </span><span class="s2">and </span><span class="s1">self._gapcolor </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">lc_rgba = mcolors.to_rgba(self._gapcolor</span><span class="s2">, </span><span class="s1">self._alpha)</span>
                    <span class="s1">gc.set_foreground(lc_rgba</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>

                    <span class="s3"># Define the inverse pattern by moving the last gap to the</span>
                    <span class="s3"># start of the sequence.</span>
                    <span class="s1">dashes = self._dash_pattern[</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">gaps = dashes[-</span><span class="s5">1</span><span class="s1">:] + dashes[:-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s3"># Set the offset so that this new first segment is skipped</span>
                    <span class="s3"># (see backend_bases.GraphicsContextBase.set_dashes for</span>
                    <span class="s3"># offset definition).</span>
                    <span class="s1">offset_gaps = self._dash_pattern[</span><span class="s5">0</span><span class="s1">] + dashes[-</span><span class="s5">1</span><span class="s1">]</span>

                    <span class="s1">gc.set_dashes(offset_gaps</span><span class="s2">, </span><span class="s1">gaps)</span>
                    <span class="s1">renderer.draw_path(gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine.frozen())</span>

                <span class="s1">lc_rgba = mcolors.to_rgba(self._color</span><span class="s2">, </span><span class="s1">self._alpha)</span>
                <span class="s1">gc.set_foreground(lc_rgba</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>

                <span class="s1">gc.set_dashes(*self._dash_pattern)</span>
                <span class="s1">renderer.draw_path(gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine.frozen())</span>
                <span class="s1">gc.restore()</span>

        <span class="s2">if </span><span class="s1">self._marker </span><span class="s2">and </span><span class="s1">self._markersize &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">gc = renderer.new_gc()</span>
            <span class="s1">self._set_gc_clip(gc)</span>
            <span class="s1">gc.set_url(self.get_url())</span>
            <span class="s1">gc.set_linewidth(self._markeredgewidth)</span>
            <span class="s1">gc.set_antialiased(self._antialiased)</span>

            <span class="s1">ec_rgba = mcolors.to_rgba(</span>
                <span class="s1">self.get_markeredgecolor()</span><span class="s2">, </span><span class="s1">self._alpha)</span>
            <span class="s1">fc_rgba = mcolors.to_rgba(</span>
                <span class="s1">self._get_markerfacecolor()</span><span class="s2">, </span><span class="s1">self._alpha)</span>
            <span class="s1">fcalt_rgba = mcolors.to_rgba(</span>
                <span class="s1">self._get_markerfacecolor(alt=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">self._alpha)</span>
            <span class="s3"># If the edgecolor is &quot;auto&quot;, it is set according to the *line*</span>
            <span class="s3"># color but inherits the alpha value of the *face* color, if any.</span>
            <span class="s2">if </span><span class="s1">(cbook._str_equal(self._markeredgecolor</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">)</span>
                    <span class="s2">and not </span><span class="s1">cbook._str_lower_equal(</span>
                        <span class="s1">self.get_markerfacecolor()</span><span class="s2">, </span><span class="s4">&quot;none&quot;</span><span class="s1">)):</span>
                <span class="s1">ec_rgba = ec_rgba[:</span><span class="s5">3</span><span class="s1">] + (fc_rgba[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s1">gc.set_foreground(ec_rgba</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.get_sketch_params() </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">scale</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">randomness = self.get_sketch_params()</span>
                <span class="s1">gc.set_sketch_params(scale/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">length/</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">*randomness)</span>

            <span class="s1">marker = self._marker</span>

            <span class="s3"># Markers *must* be drawn ignoring the drawstyle (but don't pay the</span>
            <span class="s3"># recaching if drawstyle is already &quot;default&quot;).</span>
            <span class="s2">if </span><span class="s1">self.get_drawstyle() != </span><span class="s4">&quot;default&quot;</span><span class="s1">:</span>
                <span class="s2">with </span><span class="s1">cbook._setattr_cm(</span>
                        <span class="s1">self</span><span class="s2">, </span><span class="s1">_drawstyle=</span><span class="s4">&quot;default&quot;</span><span class="s2">, </span><span class="s1">_transformed_path=</span><span class="s2">None</span><span class="s1">):</span>
                    <span class="s1">self.recache()</span>
                    <span class="s1">self._transform_path(subslice)</span>
                    <span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine = (self._get_transformed_path()</span>
                                     <span class="s1">.get_transformed_points_and_affine())</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine = (self._get_transformed_path()</span>
                                 <span class="s1">.get_transformed_points_and_affine())</span>

            <span class="s2">if </span><span class="s1">len(tpath.vertices):</span>
                <span class="s3"># subsample the markers if markevery is not None</span>
                <span class="s1">markevery = self.get_markevery()</span>
                <span class="s2">if </span><span class="s1">markevery </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">subsampled = _mark_every_path(</span>
                        <span class="s1">markevery</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">self.axes)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">subsampled = tpath</span>

                <span class="s1">snap = marker.get_snap_threshold()</span>
                <span class="s2">if </span><span class="s1">isinstance(snap</span><span class="s2">, </span><span class="s1">Real):</span>
                    <span class="s1">snap = renderer.points_to_pixels(self._markersize) &gt;= snap</span>
                <span class="s1">gc.set_snap(snap)</span>
                <span class="s1">gc.set_joinstyle(marker.get_joinstyle())</span>
                <span class="s1">gc.set_capstyle(marker.get_capstyle())</span>
                <span class="s1">marker_path = marker.get_path()</span>
                <span class="s1">marker_trans = marker.get_transform()</span>
                <span class="s1">w = renderer.points_to_pixels(self._markersize)</span>

                <span class="s2">if </span><span class="s1">cbook._str_equal(marker.get_marker()</span><span class="s2">, </span><span class="s4">&quot;,&quot;</span><span class="s1">):</span>
                    <span class="s1">gc.set_linewidth(</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s3"># Don't scale for pixels, and don't stroke them</span>
                    <span class="s1">marker_trans = marker_trans.scale(w)</span>
                <span class="s1">renderer.draw_markers(gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">,</span>
                                      <span class="s1">subsampled</span><span class="s2">, </span><span class="s1">affine.frozen()</span><span class="s2">,</span>
                                      <span class="s1">fc_rgba)</span>

                <span class="s1">alt_marker_path = marker.get_alt_path()</span>
                <span class="s2">if </span><span class="s1">alt_marker_path:</span>
                    <span class="s1">alt_marker_trans = marker.get_alt_transform()</span>
                    <span class="s1">alt_marker_trans = alt_marker_trans.scale(w)</span>
                    <span class="s1">renderer.draw_markers(</span>
                            <span class="s1">gc</span><span class="s2">, </span><span class="s1">alt_marker_path</span><span class="s2">, </span><span class="s1">alt_marker_trans</span><span class="s2">, </span><span class="s1">subsampled</span><span class="s2">,</span>
                            <span class="s1">affine.frozen()</span><span class="s2">, </span><span class="s1">fcalt_rgba)</span>

            <span class="s1">gc.restore()</span>

        <span class="s1">renderer.close_group(</span><span class="s4">'line2d'</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_antialiased(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether antialiased rendering is used.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._antialiased</span>

    <span class="s2">def </span><span class="s1">get_color(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the line color. 
 
        See also `~.Line2D.set_color`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._color</span>

    <span class="s2">def </span><span class="s1">get_drawstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the drawstyle. 
 
        See also `~.Line2D.set_drawstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._drawstyle</span>

    <span class="s2">def </span><span class="s1">get_gapcolor(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the line gapcolor. 
 
        See also `~.Line2D.set_gapcolor`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._gapcolor</span>

    <span class="s2">def </span><span class="s1">get_linestyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the linestyle. 
 
        See also `~.Line2D.set_linestyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linestyle</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the linewidth in points. 
 
        See also `~.Line2D.set_linewidth`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linewidth</span>

    <span class="s2">def </span><span class="s1">get_marker(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the line marker. 
 
        See also `~.Line2D.set_marker`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._marker.get_marker()</span>

    <span class="s2">def </span><span class="s1">get_markeredgecolor(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the marker edge color. 
 
        See also `~.Line2D.set_markeredgecolor`. 
        &quot;&quot;&quot;</span>
        <span class="s1">mec = self._markeredgecolor</span>
        <span class="s2">if </span><span class="s1">cbook._str_equal(mec</span><span class="s2">, </span><span class="s4">'auto'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'_internal.classic_mode'</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">self._marker.get_marker() </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'.'</span><span class="s2">, </span><span class="s4">','</span><span class="s1">):</span>
                    <span class="s2">return </span><span class="s1">self._color</span>
                <span class="s2">if </span><span class="s1">(self._marker.is_filled()</span>
                        <span class="s2">and </span><span class="s1">self._marker.get_fillstyle() != </span><span class="s4">'none'</span><span class="s1">):</span>
                    <span class="s2">return </span><span class="s4">'k'  </span><span class="s3"># Bad hard-wired default...</span>
            <span class="s2">return </span><span class="s1">self._color</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">mec</span>

    <span class="s2">def </span><span class="s1">get_markeredgewidth(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the marker edge width in points. 
 
        See also `~.Line2D.set_markeredgewidth`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._markeredgewidth</span>

    <span class="s2">def </span><span class="s1">_get_markerfacecolor(self</span><span class="s2">, </span><span class="s1">alt=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self._marker.get_fillstyle() == </span><span class="s4">'none'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">'none'</span>
        <span class="s1">fc = self._markerfacecoloralt </span><span class="s2">if </span><span class="s1">alt </span><span class="s2">else </span><span class="s1">self._markerfacecolor</span>
        <span class="s2">if </span><span class="s1">cbook._str_lower_equal(fc</span><span class="s2">, </span><span class="s4">'auto'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self._color</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">fc</span>

    <span class="s2">def </span><span class="s1">get_markerfacecolor(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the marker face color. 
 
        See also `~.Line2D.set_markerfacecolor`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_markerfacecolor(alt=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_markerfacecoloralt(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the alternate marker face color. 
 
        See also `~.Line2D.set_markerfacecoloralt`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_markerfacecolor(alt=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_markersize(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the marker size in points. 
 
        See also `~.Line2D.set_markersize`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._markersize</span>

    <span class="s2">def </span><span class="s1">get_data(self</span><span class="s2">, </span><span class="s1">orig=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the line data as an ``(xdata, ydata)`` pair. 
 
        If *orig* is *True*, return the original data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_xdata(orig=orig)</span><span class="s2">, </span><span class="s1">self.get_ydata(orig=orig)</span>

    <span class="s2">def </span><span class="s1">get_xdata(self</span><span class="s2">, </span><span class="s1">orig=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the xdata. 
 
        If *orig* is *True*, return the original data, else the 
        processed data. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">orig:</span>
            <span class="s2">return </span><span class="s1">self._xorig</span>
        <span class="s2">if </span><span class="s1">self._invalidx:</span>
            <span class="s1">self.recache()</span>
        <span class="s2">return </span><span class="s1">self._x</span>

    <span class="s2">def </span><span class="s1">get_ydata(self</span><span class="s2">, </span><span class="s1">orig=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ydata. 
 
        If *orig* is *True*, return the original data, else the 
        processed data. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">orig:</span>
            <span class="s2">return </span><span class="s1">self._yorig</span>
        <span class="s2">if </span><span class="s1">self._invalidy:</span>
            <span class="s1">self.recache()</span>
        <span class="s2">return </span><span class="s1">self._y</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `~matplotlib.path.Path` associated with this line.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._invalidy </span><span class="s2">or </span><span class="s1">self._invalidx:</span>
            <span class="s1">self.recache()</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">get_xydata(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the *xy* data as a Nx2 numpy array. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._invalidy </span><span class="s2">or </span><span class="s1">self._invalidx:</span>
            <span class="s1">self.recache()</span>
        <span class="s2">return </span><span class="s1">self._xy</span>

    <span class="s2">def </span><span class="s1">set_antialiased(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether to use antialiased rendering. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._antialiased != b:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._antialiased = b</span>

    <span class="s2">def </span><span class="s1">set_color(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the color of the line. 
 
        Parameters 
        ---------- 
        color : color 
        &quot;&quot;&quot;</span>
        <span class="s1">mcolors._check_color_like(color=color)</span>
        <span class="s1">self._color = color</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_drawstyle(self</span><span class="s2">, </span><span class="s1">drawstyle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the drawstyle of the plot. 
 
        The drawstyle determines how the points are connected. 
 
        Parameters 
        ---------- 
        drawstyle : {'default', 'steps', 'steps-pre', 'steps-mid', \ 
'steps-post'}, default: 'default' 
            For 'default', the points are connected with straight lines. 
 
            The steps variants connect the points with step-like lines, 
            i.e. horizontal lines with vertical steps. They differ in the 
            location of the step: 
 
            - 'steps-pre': The step is at the beginning of the line segment, 
              i.e. the line will be at the y-value of point to the right. 
            - 'steps-mid': The step is halfway between the points. 
            - 'steps-post: The step is at the end of the line segment, 
              i.e. the line will be at the y-value of the point to the left. 
            - 'steps' is equal to 'steps-pre' and is maintained for 
              backward-compatibility. 
 
            For examples see :doc:`/gallery/lines_bars_and_markers/step_demo`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">drawstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">drawstyle = </span><span class="s4">'default'</span>
        <span class="s1">_api.check_in_list(self.drawStyles</span><span class="s2">, </span><span class="s1">drawstyle=drawstyle)</span>
        <span class="s2">if </span><span class="s1">self._drawstyle != drawstyle:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
            <span class="s3"># invalidate to trigger a recache of the path</span>
            <span class="s1">self._invalidx = </span><span class="s2">True</span>
        <span class="s1">self._drawstyle = drawstyle</span>

    <span class="s2">def </span><span class="s1">set_gapcolor(self</span><span class="s2">, </span><span class="s1">gapcolor):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set a color to fill the gaps in the dashed line style. 
 
        .. note:: 
 
            Striped lines are created by drawing two interleaved dashed lines. 
            There can be overlaps between those two, which may result in 
            artifacts when using transparency. 
 
            This functionality is experimental and may change. 
 
        Parameters 
        ---------- 
        gapcolor : color or None 
            The color with which to fill the gaps. If None, the gaps are 
            unfilled. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">gapcolor </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mcolors._check_color_like(color=gapcolor)</span>
        <span class="s1">self._gapcolor = gapcolor</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_linewidth(self</span><span class="s2">, </span><span class="s1">w):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the line width in points. 
 
        Parameters 
        ---------- 
        w : float 
            Line width, in points. 
        &quot;&quot;&quot;</span>
        <span class="s1">w = float(w)</span>
        <span class="s2">if </span><span class="s1">self._linewidth != w:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._linewidth = w</span>
        <span class="s1">self._dash_pattern = _scale_dashes(*self._unscaled_dash_pattern</span><span class="s2">, </span><span class="s1">w)</span>

    <span class="s2">def </span><span class="s1">set_linestyle(self</span><span class="s2">, </span><span class="s1">ls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the linestyle of the line. 
 
        Parameters 
        ---------- 
        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} 
            Possible values: 
 
            - A string: 
 
              ==========================================  ================= 
              linestyle                                   description 
              ==========================================  ================= 
              ``'-'`` or ``'solid'``                      solid line 
              ``'--'`` or  ``'dashed'``                   dashed line 
              ``'-.'`` or  ``'dashdot'``                  dash-dotted line 
              ``':'`` or ``'dotted'``                     dotted line 
              ``'none'``, ``'None'``, ``' '``, or ``''``  draw nothing 
              ==========================================  ================= 
 
            - Alternatively a dash tuple of the following form can be 
              provided:: 
 
                  (offset, onoffseq) 
 
              where ``onoffseq`` is an even length tuple of on and off ink 
              in points. See also :meth:`set_dashes`. 
 
            For examples see :doc:`/gallery/lines_bars_and_markers/linestyles`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(ls</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">ls </span><span class="s2">in </span><span class="s1">[</span><span class="s4">' '</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">]:</span>
                <span class="s1">ls = </span><span class="s4">'None'</span>
            <span class="s1">_api.check_in_list([*self._lineStyles</span><span class="s2">, </span><span class="s1">*ls_mapper_r]</span><span class="s2">, </span><span class="s1">ls=ls)</span>
            <span class="s2">if </span><span class="s1">ls </span><span class="s2">not in </span><span class="s1">self._lineStyles:</span>
                <span class="s1">ls = ls_mapper_r[ls]</span>
            <span class="s1">self._linestyle = ls</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._linestyle = </span><span class="s4">'--'</span>
        <span class="s1">self._unscaled_dash_pattern = _get_dash_pattern(ls)</span>
        <span class="s1">self._dash_pattern = _scale_dashes(</span>
            <span class="s1">*self._unscaled_dash_pattern</span><span class="s2">, </span><span class="s1">self._linewidth)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_marker(self</span><span class="s2">, </span><span class="s1">marker):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the line marker. 
 
        Parameters 
        ---------- 
        marker : marker style string, `~.path.Path` or `~.markers.MarkerStyle` 
            See `~matplotlib.markers` for full description of possible 
            arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._marker = MarkerStyle(marker</span><span class="s2">, </span><span class="s1">self._marker.get_fillstyle())</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_set_markercolor(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">has_rcdefault</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">val = mpl.rcParams[</span><span class="s4">f&quot;lines.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">] </span><span class="s2">if </span><span class="s1">has_rcdefault </span><span class="s2">else </span><span class="s4">&quot;auto&quot;</span>
        <span class="s1">attr = </span><span class="s4">f&quot;_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span>
        <span class="s1">current = getattr(self</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">current </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">neq = current != val</span>
            <span class="s3"># Much faster than `np.any(current != val)` if no arrays are used.</span>
            <span class="s2">if </span><span class="s1">neq.any() </span><span class="s2">if </span><span class="s1">isinstance(neq</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">else </span><span class="s1">neq:</span>
                <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>

    <span class="s2">def </span><span class="s1">set_markeredgecolor(self</span><span class="s2">, </span><span class="s1">ec):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the marker edge color. 
 
        Parameters 
        ---------- 
        ec : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_markercolor(</span><span class="s4">&quot;markeredgecolor&quot;</span><span class="s2">, True, </span><span class="s1">ec)</span>

    <span class="s2">def </span><span class="s1">set_markerfacecolor(self</span><span class="s2">, </span><span class="s1">fc):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the marker face color. 
 
        Parameters 
        ---------- 
        fc : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_markercolor(</span><span class="s4">&quot;markerfacecolor&quot;</span><span class="s2">, True, </span><span class="s1">fc)</span>

    <span class="s2">def </span><span class="s1">set_markerfacecoloralt(self</span><span class="s2">, </span><span class="s1">fc):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the alternate marker face color. 
 
        Parameters 
        ---------- 
        fc : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_markercolor(</span><span class="s4">&quot;markerfacecoloralt&quot;</span><span class="s2">, False, </span><span class="s1">fc)</span>

    <span class="s2">def </span><span class="s1">set_markeredgewidth(self</span><span class="s2">, </span><span class="s1">ew):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the marker edge width in points. 
 
        Parameters 
        ---------- 
        ew : float 
             Marker edge width, in points. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">ew </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ew = mpl.rcParams[</span><span class="s4">'lines.markeredgewidth'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._markeredgewidth != ew:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._markeredgewidth = ew</span>

    <span class="s2">def </span><span class="s1">set_markersize(self</span><span class="s2">, </span><span class="s1">sz):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the marker size in points. 
 
        Parameters 
        ---------- 
        sz : float 
             Marker size, in points. 
        &quot;&quot;&quot;</span>
        <span class="s1">sz = float(sz)</span>
        <span class="s2">if </span><span class="s1">self._markersize != sz:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._markersize = sz</span>

    <span class="s2">def </span><span class="s1">set_xdata(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the data array for x. 
 
        Parameters 
        ---------- 
        x : 1D array 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.iterable(x):</span>
            <span class="s3"># When deprecation cycle is completed</span>
            <span class="s3"># raise RuntimeError('x must be a sequence')</span>
            <span class="s1">_api.warn_deprecated(</span>
                <span class="s1">since=</span><span class="s5">3.7</span><span class="s2">,</span>
                <span class="s1">message=</span><span class="s4">&quot;Setting data with a non sequence type &quot;</span>
                <span class="s4">&quot;is deprecated since %(since)s and will be &quot;</span>
                <span class="s4">&quot;remove %(removal)s&quot;</span><span class="s1">)</span>
            <span class="s1">x = [x</span><span class="s2">, </span><span class="s1">]</span>
        <span class="s1">self._xorig = copy.copy(x)</span>
        <span class="s1">self._invalidx = </span><span class="s2">True</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_ydata(self</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the data array for y. 
 
        Parameters 
        ---------- 
        y : 1D array 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.iterable(y):</span>
            <span class="s3"># When deprecation cycle is completed</span>
            <span class="s3"># raise RuntimeError('y must be a sequence')</span>
            <span class="s1">_api.warn_deprecated(</span>
                <span class="s1">since=</span><span class="s5">3.7</span><span class="s2">,</span>
                <span class="s1">message=</span><span class="s4">&quot;Setting data with a non sequence type &quot;</span>
                <span class="s4">&quot;is deprecated since %(since)s and will be &quot;</span>
                <span class="s4">&quot;remove %(removal)s&quot;</span><span class="s1">)</span>
            <span class="s1">y = [y</span><span class="s2">, </span><span class="s1">]</span>
        <span class="s1">self._yorig = copy.copy(y)</span>
        <span class="s1">self._invalidy = </span><span class="s2">True</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_dashes(self</span><span class="s2">, </span><span class="s1">seq):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the dash sequence. 
 
        The dash sequence is a sequence of floats of even length describing 
        the length of dashes and spaces in points. 
 
        For example, (5, 2, 1, 2) describes a sequence of 5 point and 1 point 
        dashes separated by 2 point spaces. 
 
        See also `~.Line2D.set_gapcolor`, which allows those spaces to be 
        filled with a color. 
 
        Parameters 
        ---------- 
        seq : sequence of floats (on/off ink in points) or (None, None) 
            If *seq* is empty or ``(None, None)``, the linestyle will be set 
            to solid. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">seq == (</span><span class="s2">None, None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">len(seq) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.set_linestyle(</span><span class="s4">'-'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set_linestyle((</span><span class="s5">0</span><span class="s2">, </span><span class="s1">seq))</span>

    <span class="s2">def </span><span class="s1">update_from(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Copy properties from *other* to self.&quot;&quot;&quot;</span>
        <span class="s1">super().update_from(other)</span>
        <span class="s1">self._linestyle = other._linestyle</span>
        <span class="s1">self._linewidth = other._linewidth</span>
        <span class="s1">self._color = other._color</span>
        <span class="s1">self._gapcolor = other._gapcolor</span>
        <span class="s1">self._markersize = other._markersize</span>
        <span class="s1">self._markerfacecolor = other._markerfacecolor</span>
        <span class="s1">self._markerfacecoloralt = other._markerfacecoloralt</span>
        <span class="s1">self._markeredgecolor = other._markeredgecolor</span>
        <span class="s1">self._markeredgewidth = other._markeredgewidth</span>
        <span class="s1">self._unscaled_dash_pattern = other._unscaled_dash_pattern</span>
        <span class="s1">self._dash_pattern = other._dash_pattern</span>
        <span class="s1">self._dashcapstyle = other._dashcapstyle</span>
        <span class="s1">self._dashjoinstyle = other._dashjoinstyle</span>
        <span class="s1">self._solidcapstyle = other._solidcapstyle</span>
        <span class="s1">self._solidjoinstyle = other._solidjoinstyle</span>

        <span class="s1">self._linestyle = other._linestyle</span>
        <span class="s1">self._marker = MarkerStyle(marker=other._marker)</span>
        <span class="s1">self._drawstyle = other._drawstyle</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_dash_joinstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        How to join segments of the line if it `~Line2D.is_dashed`. 
 
        The default joinstyle is :rc:`lines.dash_joinstyle`. 
 
        Parameters 
        ---------- 
        s : `.JoinStyle` or %(JoinStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">js = JoinStyle(s)</span>
        <span class="s2">if </span><span class="s1">self._dashjoinstyle != js:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._dashjoinstyle = js</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_solid_joinstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        How to join segments if the line is solid (not `~Line2D.is_dashed`). 
 
        The default joinstyle is :rc:`lines.solid_joinstyle`. 
 
        Parameters 
        ---------- 
        s : `.JoinStyle` or %(JoinStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">js = JoinStyle(s)</span>
        <span class="s2">if </span><span class="s1">self._solidjoinstyle != js:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._solidjoinstyle = js</span>

    <span class="s2">def </span><span class="s1">get_dash_joinstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.JoinStyle` for dashed lines. 
 
        See also `~.Line2D.set_dash_joinstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dashjoinstyle.name</span>

    <span class="s2">def </span><span class="s1">get_solid_joinstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.JoinStyle` for solid lines. 
 
        See also `~.Line2D.set_solid_joinstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._solidjoinstyle.name</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_dash_capstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        How to draw the end caps if the line is `~Line2D.is_dashed`. 
 
        The default capstyle is :rc:`lines.dash_capstyle`. 
 
        Parameters 
        ---------- 
        s : `.CapStyle` or %(CapStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">cs = CapStyle(s)</span>
        <span class="s2">if </span><span class="s1">self._dashcapstyle != cs:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._dashcapstyle = cs</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_solid_capstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        How to draw the end caps if the line is solid (not `~Line2D.is_dashed`) 
 
        The default capstyle is :rc:`lines.solid_capstyle`. 
 
        Parameters 
        ---------- 
        s : `.CapStyle` or %(CapStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">cs = CapStyle(s)</span>
        <span class="s2">if </span><span class="s1">self._solidcapstyle != cs:</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._solidcapstyle = cs</span>

    <span class="s2">def </span><span class="s1">get_dash_capstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.CapStyle` for dashed lines. 
 
        See also `~.Line2D.set_dash_capstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dashcapstyle.name</span>

    <span class="s2">def </span><span class="s1">get_solid_capstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.CapStyle` for solid lines. 
 
        See also `~.Line2D.set_solid_capstyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._solidcapstyle.name</span>

    <span class="s2">def </span><span class="s1">is_dashed(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether line has a dashed linestyle. 
 
        A custom linestyle is assumed to be dashed, we do not inspect the 
        ``onoffseq`` directly. 
 
        See also `~.Line2D.set_linestyle`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linestyle </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'--'</span><span class="s2">, </span><span class="s4">'-.'</span><span class="s2">, </span><span class="s4">':'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_AxLine(Line2D):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper class that implements `~.Axes.axline`, by recomputing the artist 
    transform at draw time. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy1</span><span class="s2">, </span><span class="s1">xy2</span><span class="s2">, </span><span class="s1">slope</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">if </span><span class="s1">(xy2 </span><span class="s2">is None and </span><span class="s1">slope </span><span class="s2">is None or</span>
                <span class="s1">xy2 </span><span class="s2">is not None and </span><span class="s1">slope </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Exactly one of 'xy2' and 'slope' must be given&quot;</span><span class="s1">)</span>

        <span class="s1">self._slope = slope</span>
        <span class="s1">self._xy1 = xy1</span>
        <span class="s1">self._xy2 = xy2</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s1">ax = self.axes</span>
        <span class="s1">points_transform = self._transform - ax.transData + ax.transScale</span>

        <span class="s2">if </span><span class="s1">self._xy2 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># two points were given</span>
            <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2) = \</span>
                <span class="s1">points_transform.transform([self._xy1</span><span class="s2">, </span><span class="s1">self._xy2])</span>
            <span class="s1">dx = x2 - x1</span>
            <span class="s1">dy = y2 - y1</span>
            <span class="s2">if </span><span class="s1">np.allclose(x1</span><span class="s2">, </span><span class="s1">x2):</span>
                <span class="s2">if </span><span class="s1">np.allclose(y1</span><span class="s2">, </span><span class="s1">y2):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f&quot;Cannot draw a line through two identical points &quot;</span>
                        <span class="s4">f&quot;(x=</span><span class="s2">{</span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">x2)</span><span class="s2">}</span><span class="s4">, y=</span><span class="s2">{</span><span class="s1">(y1</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">}</span><span class="s4">)&quot;</span><span class="s1">)</span>
                <span class="s1">slope = np.inf</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">slope = dy / dx</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># one point and a slope were given</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = points_transform.transform(self._xy1)</span>
            <span class="s1">slope = self._slope</span>
        <span class="s1">(vxlo</span><span class="s2">, </span><span class="s1">vylo)</span><span class="s2">, </span><span class="s1">(vxhi</span><span class="s2">, </span><span class="s1">vyhi) = ax.transScale.transform(ax.viewLim)</span>
        <span class="s3"># General case: find intersections with view limits in either</span>
        <span class="s3"># direction, and draw between the middle two points.</span>
        <span class="s2">if </span><span class="s1">np.isclose(slope</span><span class="s2">, </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s1">start = vxlo</span><span class="s2">, </span><span class="s1">y1</span>
            <span class="s1">stop = vxhi</span><span class="s2">, </span><span class="s1">y1</span>
        <span class="s2">elif </span><span class="s1">np.isinf(slope):</span>
            <span class="s1">start = x1</span><span class="s2">, </span><span class="s1">vylo</span>
            <span class="s1">stop = x1</span><span class="s2">, </span><span class="s1">vyhi</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">_ = sorted([</span>
                <span class="s1">(vxlo</span><span class="s2">, </span><span class="s1">y1 + (vxlo - x1) * slope)</span><span class="s2">,</span>
                <span class="s1">(vxhi</span><span class="s2">, </span><span class="s1">y1 + (vxhi - x1) * slope)</span><span class="s2">,</span>
                <span class="s1">(x1 + (vylo - y1) / slope</span><span class="s2">, </span><span class="s1">vylo)</span><span class="s2">,</span>
                <span class="s1">(x1 + (vyhi - y1) / slope</span><span class="s2">, </span><span class="s1">vyhi)</span><span class="s2">,</span>
            <span class="s1">])</span>
        <span class="s2">return </span><span class="s1">(BboxTransformTo(Bbox([start</span><span class="s2">, </span><span class="s1">stop]))</span>
                <span class="s1">+ ax.transLimits + ax.transAxes)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self._transformed_path = </span><span class="s2">None  </span><span class="s3"># Force regen.</span>
        <span class="s1">super().draw(renderer)</span>


<span class="s2">class </span><span class="s1">VertexSelector:</span>
    <span class="s0">&quot;&quot;&quot; 
    Manage the callbacks to maintain a list of selected vertices for `.Line2D`. 
    Derived classes should override the `process_selected` method to do 
    something with the picks. 
 
    Here is an example which highlights the selected verts with red circles:: 
 
        import numpy as np 
        import matplotlib.pyplot as plt 
        import matplotlib.lines as lines 
 
        class HighlightSelected(lines.VertexSelector): 
            def __init__(self, line, fmt='ro', **kwargs): 
                super().__init__(line) 
                self.markers, = self.axes.plot([], [], fmt, **kwargs) 
 
            def process_selected(self, ind, xs, ys): 
                self.markers.set_data(xs, ys) 
                self.canvas.draw() 
 
        fig, ax = plt.subplots() 
        x, y = np.random.rand(2, 30) 
        line, = ax.plot(x, y, 'bs-', picker=5) 
 
        selector = HighlightSelected(line) 
        plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">line):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        line : `.Line2D` 
            The line must already have been added to an `~.axes.Axes` and must 
            have its picker property set. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">line.axes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first add the line to the Axes'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">line.get_picker() </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first set the picker property '</span>
                               <span class="s4">'of the line'</span><span class="s1">)</span>
        <span class="s1">self.axes = line.axes</span>
        <span class="s1">self.line = line</span>
        <span class="s1">self.cid = self.canvas.callbacks._connect_picklable(</span>
            <span class="s4">'pick_event'</span><span class="s2">, </span><span class="s1">self.onpick)</span>
        <span class="s1">self.ind = set()</span>

    <span class="s1">canvas = property(</span><span class="s2">lambda </span><span class="s1">self: self.axes.figure.canvas)</span>

    <span class="s2">def </span><span class="s1">process_selected(self</span><span class="s2">, </span><span class="s1">ind</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys):</span>
        <span class="s0">&quot;&quot;&quot; 
        Default &quot;do nothing&quot; implementation of the `process_selected` method. 
 
        Parameters 
        ---------- 
        ind : list of int 
            The indices of the selected vertices. 
        xs, ys : array-like 
            The coordinates of the selected vertices. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">onpick(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;When the line is picked, update the set of selected indices.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">event.artist </span><span class="s2">is not </span><span class="s1">self.line:</span>
            <span class="s2">return</span>
        <span class="s1">self.ind ^= set(event.ind)</span>
        <span class="s1">ind = sorted(self.ind)</span>
        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata = self.line.get_data()</span>
        <span class="s1">self.process_selected(ind</span><span class="s2">, </span><span class="s1">xdata[ind]</span><span class="s2">, </span><span class="s1">ydata[ind])</span>


<span class="s1">lineStyles = Line2D._lineStyles</span>
<span class="s1">lineMarkers = MarkerStyle.markers</span>
<span class="s1">drawStyles = Line2D.drawStyles</span>
<span class="s1">fillStyles = MarkerStyle.fillstyles</span>
</pre>
</body>
</html>