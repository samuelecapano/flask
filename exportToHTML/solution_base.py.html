<html>
<head>
<title>solution_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
solution_base.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2020 The MediaPipe Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;MediaPipe SolutionBase module. 
 
MediaPipe SolutionBase is the common base class for the high-level MediaPipe 
Solution APIs such as BlazeFace, hand tracking, and BlazePose. The SolutionBase 
class contains the shared logic among the high-level Solution APIs including 
graph initialization, processing image/audio data, and graph shutdown. Thus, 
users can easily create new MediaPipe Solution APIs on top of the SolutionBase 
class. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">enum</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">NamedTuple</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">google.protobuf.internal </span><span class="s3">import </span><span class="s1">containers</span>
<span class="s3">from </span><span class="s1">google.protobuf </span><span class="s3">import </span><span class="s1">descriptor</span>
<span class="s3">from </span><span class="s1">google.protobuf </span><span class="s3">import </span><span class="s1">message</span>
<span class="s0"># resources dependency</span>
<span class="s0"># pylint: disable=unused-import</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.core </span><span class="s3">import </span><span class="s1">constant_side_packet_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.image </span><span class="s3">import </span><span class="s1">image_transformation_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.tensor </span><span class="s3">import </span><span class="s1">tensors_to_detections_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.util </span><span class="s3">import </span><span class="s1">landmarks_smoothing_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.util </span><span class="s3">import </span><span class="s1">logic_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.calculators.util </span><span class="s3">import </span><span class="s1">thresholding_calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.framework </span><span class="s3">import </span><span class="s1">calculator_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.framework.formats </span><span class="s3">import </span><span class="s1">classification_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.framework.formats </span><span class="s3">import </span><span class="s1">detection_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.framework.formats </span><span class="s3">import </span><span class="s1">landmark_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.framework.formats </span><span class="s3">import </span><span class="s1">rect_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.modules.objectron.calculators </span><span class="s3">import </span><span class="s1">annotation_data_pb2</span>
<span class="s3">from </span><span class="s1">mediapipe.modules.objectron.calculators </span><span class="s3">import </span><span class="s1">lift_2d_frame_annotation_to_3d_calculator_pb2</span>
<span class="s0"># pylint: enable=unused-import</span>
<span class="s3">from </span><span class="s1">mediapipe.python </span><span class="s3">import </span><span class="s1">packet_creator</span>
<span class="s3">from </span><span class="s1">mediapipe.python </span><span class="s3">import </span><span class="s1">packet_getter</span>
<span class="s3">from </span><span class="s1">mediapipe.python._framework_bindings </span><span class="s3">import </span><span class="s1">calculator_graph</span>
<span class="s3">from </span><span class="s1">mediapipe.python._framework_bindings </span><span class="s3">import </span><span class="s1">image_frame</span>
<span class="s3">from </span><span class="s1">mediapipe.python._framework_bindings </span><span class="s3">import </span><span class="s1">packet</span>
<span class="s3">from </span><span class="s1">mediapipe.python._framework_bindings </span><span class="s3">import </span><span class="s1">resource_util</span>
<span class="s3">from </span><span class="s1">mediapipe.python._framework_bindings </span><span class="s3">import </span><span class="s1">validated_graph_config</span>

<span class="s1">RGB_CHANNELS = </span><span class="s4">3</span>
<span class="s0"># TODO: Enable calculator options modification for more calculators.</span>
<span class="s1">CALCULATOR_TO_OPTIONS = {</span>
    <span class="s5">'ConstantSidePacketCalculator'</span><span class="s1">:</span>
        <span class="s1">constant_side_packet_calculator_pb2.ConstantSidePacketCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'ImageTransformationCalculator'</span><span class="s1">:</span>
        <span class="s1">image_transformation_calculator_pb2</span>
        <span class="s1">.ImageTransformationCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'LandmarksSmoothingCalculator'</span><span class="s1">:</span>
        <span class="s1">landmarks_smoothing_calculator_pb2.LandmarksSmoothingCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'LogicCalculator'</span><span class="s1">:</span>
        <span class="s1">logic_calculator_pb2.LogicCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'ThresholdingCalculator'</span><span class="s1">:</span>
        <span class="s1">thresholding_calculator_pb2.ThresholdingCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'TensorsToDetectionsCalculator'</span><span class="s1">:</span>
        <span class="s1">tensors_to_detections_calculator_pb2</span>
        <span class="s1">.TensorsToDetectionsCalculatorOptions</span><span class="s3">,</span>
    <span class="s5">'Lift2DFrameAnnotationTo3DCalculator'</span><span class="s1">:</span>
        <span class="s1">lift_2d_frame_annotation_to_3d_calculator_pb2</span>
        <span class="s1">.Lift2DFrameAnnotationTo3DCalculatorOptions</span><span class="s3">,</span>
<span class="s1">}</span>


<span class="s3">def </span><span class="s1">type_names_from_oneof(oneof_type_name: str) -&gt; Optional[List[str]]:</span>
  <span class="s3">if </span><span class="s1">oneof_type_name.startswith(</span><span class="s5">'OneOf&lt;'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">oneof_type_name.endswith(</span><span class="s5">'&gt;'</span><span class="s1">):</span>
    <span class="s1">comma_separated_types = oneof_type_name[len(</span><span class="s5">'OneOf&lt;'</span><span class="s1">):-len(</span><span class="s5">'&gt;'</span><span class="s1">)]</span>
    <span class="s3">return </span><span class="s1">[n.strip() </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">comma_separated_types.split(</span><span class="s5">','</span><span class="s1">)]</span>
  <span class="s3">return None</span>


<span class="s0"># TODO: Support more packet data types, such as &quot;Any&quot; type.</span>
<span class="s1">@enum.unique</span>
<span class="s3">class </span><span class="s1">PacketDataType(enum.Enum):</span>
  <span class="s2">&quot;&quot;&quot;The packet data types supported by the SolutionBase class.&quot;&quot;&quot;</span>
  <span class="s1">STRING = </span><span class="s5">'string'</span>
  <span class="s1">BOOL = </span><span class="s5">'bool'</span>
  <span class="s1">BOOL_LIST = </span><span class="s5">'bool_list'</span>
  <span class="s1">INT = </span><span class="s5">'int'</span>
  <span class="s1">INT_LIST = </span><span class="s5">'int_list'</span>
  <span class="s1">FLOAT = </span><span class="s5">'float'</span>
  <span class="s1">FLOAT_LIST = </span><span class="s5">'float_list'</span>
  <span class="s1">AUDIO = </span><span class="s5">'matrix'</span>
  <span class="s1">IMAGE = </span><span class="s5">'image'</span>
  <span class="s1">IMAGE_LIST = </span><span class="s5">'image_list'</span>
  <span class="s1">IMAGE_FRAME = </span><span class="s5">'image_frame'</span>
  <span class="s1">PROTO = </span><span class="s5">'proto'</span>
  <span class="s1">PROTO_LIST = </span><span class="s5">'proto_list'</span>

  <span class="s1">@staticmethod</span>
  <span class="s3">def </span><span class="s1">from_registered_name(registered_name: str) -&gt; </span><span class="s5">'PacketDataType'</span><span class="s1">:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">NAME_TO_TYPE[registered_name]</span>
    <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s1">names = type_names_from_oneof(registered_name)</span>
      <span class="s3">if </span><span class="s1">names:</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">names:</span>
          <span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">NAME_TO_TYPE.keys():</span>
            <span class="s3">return </span><span class="s1">NAME_TO_TYPE[n]</span>
      <span class="s3">raise </span><span class="s1">e</span>

<span class="s1">NAME_TO_TYPE: Mapping[str</span><span class="s3">, </span><span class="s5">'PacketDataType'</span><span class="s1">] = {</span>
    <span class="s5">'string'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.STRING</span><span class="s3">,</span>
    <span class="s5">'bool'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.BOOL</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;bool&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.BOOL_LIST</span><span class="s3">,</span>
    <span class="s5">'int'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.INT</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;int&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.INT_LIST</span><span class="s3">,</span>
    <span class="s5">'int64'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.INT</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;int64&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.INT_LIST</span><span class="s3">,</span>
    <span class="s5">'float'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.FLOAT</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;float&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.FLOAT_LIST</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Matrix'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.AUDIO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::ImageFrame'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.IMAGE_FRAME</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Classification'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::ClassificationList'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::ClassificationListCollection'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Detection'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::DetectionList'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Landmark'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::LandmarkList'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::LandmarkListCollection'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::NormalizedLandmark'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::FrameAnnotation'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Trigger'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Rect'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::NormalizedRect'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::NormalizedLandmarkList'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::NormalizedLandmarkListCollection'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO</span><span class="s3">,</span>
    <span class="s5">'::mediapipe::Image'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.IMAGE</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::Image&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.IMAGE_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::Classification&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::ClassificationList&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::Detection&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::DetectionList&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::Landmark&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::LandmarkList&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::NormalizedLandmark&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::NormalizedLandmarkList&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::Rect&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
    <span class="s5">'::std::vector&lt;::mediapipe::NormalizedRect&gt;'</span><span class="s1">:</span>
        <span class="s1">PacketDataType.PROTO_LIST</span><span class="s3">,</span>
<span class="s1">}</span>


<span class="s3">class </span><span class="s1">SolutionBase:</span>
  <span class="s2">&quot;&quot;&quot;The common base class for the high-level MediaPipe Solution APIs. 
 
  The SolutionBase class contains the shared logic among the high-level solution 
  APIs including graph initialization, processing image/audio data, and graph 
  shutdown. 
 
  Example usage: 
    with solution_base.SolutionBase( 
        binary_graph_path='mediapipe/modules/hand_landmark/hand_landmark_tracking_cpu.binarypb', 
        side_inputs={'num_hands': 2}) as hand_tracker: 
      # Read an image and convert the BGR image to RGB. 
      input_image = cv2.cvtColor(cv2.imread('/tmp/hand.png'), COLOR_BGR2RGB) 
      results = hand_tracker.process(input_image) 
      print(results.palm_detections) 
      print(results.multi_hand_landmarks) 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">binary_graph_path: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">graph_config: Optional[calculator_pb2.CalculatorGraphConfig] = </span><span class="s3">None,</span>
      <span class="s1">calculator_params: Optional[Mapping[str</span><span class="s3">, </span><span class="s1">Any]] = </span><span class="s3">None,</span>
      <span class="s1">graph_options: Optional[message.Message] = </span><span class="s3">None,</span>
      <span class="s1">side_inputs: Optional[Mapping[str</span><span class="s3">, </span><span class="s1">Any]] = </span><span class="s3">None,</span>
      <span class="s1">outputs: Optional[List[str]] = </span><span class="s3">None,</span>
      <span class="s1">stream_type_hints: Optional[Mapping[str</span><span class="s3">, </span><span class="s1">PacketDataType]] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes the SolutionBase object. 
 
    Args: 
      binary_graph_path: The path to a binary mediapipe graph file (.binarypb). 
      graph_config: A CalculatorGraphConfig proto message or its text proto 
        format. 
      calculator_params: A mapping from the 
        {calculator_name}.{options_field_name} str to the field value. 
      graph_options: The graph options protobuf for the mediapipe graph. 
      side_inputs: A mapping from the side packet name to the packet raw data. 
      outputs: A list of the graph output stream names to observe. If the list 
        is empty, all the output streams listed in the graph config will be 
        automatically observed by default. 
      stream_type_hints: A mapping from the stream name to its packet type hint. 
 
    Raises: 
      FileNotFoundError: If the binary graph file can't be found. 
      RuntimeError: If the underlying calculator graph can't be successfully 
        initialized or started. 
      ValueError: If any of the following: 
        a) If not exactly one of 'binary_graph_path' or 'graph_config' arguments 
        is provided. 
        b) If the graph validation process contains error. 
        c) If the registered type name of the streams and side packets can't be 
        found. 
        d) If the calculator options of the calculator listed in 
        calculator_params is not allowed to be modified. 
        e) If the calculator options field is a repeated field but the field 
        value to be set is not iterable. 
        f) If not all calculator params are valid. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">bool(binary_graph_path) == bool(graph_config):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s5">&quot;Must provide exactly one of 'binary_graph_path' or 'graph_config'.&quot;</span><span class="s1">)</span>
    <span class="s0"># MediaPipe package root path</span>
    <span class="s1">root_path = os.sep.join(os.path.abspath(__file__).split(os.sep)[:-</span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">resource_util.set_resource_dir(root_path)</span>
    <span class="s1">validated_graph = validated_graph_config.ValidatedGraphConfig()</span>
    <span class="s3">if </span><span class="s1">binary_graph_path:</span>
      <span class="s1">validated_graph.initialize(</span>
          <span class="s1">binary_graph_path=os.path.join(root_path</span><span class="s3">, </span><span class="s1">binary_graph_path))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">validated_graph.initialize(graph_config=graph_config)</span>

    <span class="s1">canonical_graph_config_proto = self._initialize_graph_interface(</span>
        <span class="s1">validated_graph</span><span class="s3">, </span><span class="s1">side_inputs</span><span class="s3">, </span><span class="s1">outputs</span><span class="s3">, </span><span class="s1">stream_type_hints)</span>
    <span class="s3">if </span><span class="s1">calculator_params:</span>
      <span class="s1">self._modify_calculator_options(canonical_graph_config_proto</span><span class="s3">,</span>
                                      <span class="s1">calculator_params)</span>
    <span class="s3">if </span><span class="s1">graph_options:</span>
      <span class="s1">self._set_extension(canonical_graph_config_proto.graph_options</span><span class="s3">,</span>
                          <span class="s1">graph_options)</span>

    <span class="s1">self._graph = calculator_graph.CalculatorGraph(</span>
        <span class="s1">graph_config=canonical_graph_config_proto)</span>
    <span class="s1">self._simulated_timestamp = </span><span class="s4">0</span>
    <span class="s1">self._graph_outputs = {}</span>

    <span class="s3">def </span><span class="s1">callback(stream_name: str</span><span class="s3">, </span><span class="s1">output_packet: packet.Packet) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
      <span class="s1">self._graph_outputs[stream_name] = output_packet</span>

    <span class="s3">for </span><span class="s1">stream_name </span><span class="s3">in </span><span class="s1">self._output_stream_type_info.keys():</span>
      <span class="s1">self._graph.observe_output_stream(stream_name</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s1">self._input_side_packets = {</span>
        <span class="s1">name: self._make_packet(self._side_input_type_info[name]</span><span class="s3">, </span><span class="s1">data)</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">data </span><span class="s3">in </span><span class="s1">(side_inputs </span><span class="s3">or </span><span class="s1">{}).items()</span>
    <span class="s1">}</span>
    <span class="s1">self._graph.start_run(self._input_side_packets)</span>

  <span class="s0"># TODO: Use &quot;inspect.Parameter&quot; to fetch the input argument names and</span>
  <span class="s0"># types from &quot;_input_stream_type_info&quot; and then auto generate the process</span>
  <span class="s0"># method signature by &quot;inspect.Signature&quot; in __init__.</span>
  <span class="s3">def </span><span class="s1">process(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">input_data: Union[np.ndarray</span><span class="s3">, </span><span class="s1">Mapping[str</span><span class="s3">, </span><span class="s1">Union[np.ndarray</span><span class="s3">,</span>
                                                             <span class="s1">message.Message]]]</span>
  <span class="s1">) -&gt; NamedTuple:</span>
    <span class="s2">&quot;&quot;&quot;Processes a set of RGB image data and output SolutionOutputs. 
 
    Args: 
      input_data: Either a single numpy ndarray object representing the solo 
        image input of a graph or a mapping from the stream name to the image or 
        proto data that represents every input streams of a graph. 
 
    Raises: 
      NotImplementedError: If input_data contains audio data or a list of proto 
        objects. 
      RuntimeError: If the underlying graph occurs any error. 
      ValueError: If the input image data is not three channel RGB. 
 
    Returns: 
      A NamedTuple object that contains the output data of a graph run. 
        The field names in the NamedTuple object are mapping to the graph output 
        stream names. 
 
    Examples: 
      solution = solution_base.SolutionBase(graph_config=hand_landmark_graph) 
      results = solution.process(cv2.imread('/tmp/hand0.png')[:, :, ::-1]) 
      print(results.detection) 
      results = solution.process( 
          {'video_in' : cv2.imread('/tmp/hand1.png')[:, :, ::-1]}) 
      print(results.hand_landmarks) 
    &quot;&quot;&quot;</span>
    <span class="s1">self._graph_outputs.clear()</span>

    <span class="s3">if </span><span class="s1">isinstance(input_data</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
      <span class="s3">if </span><span class="s1">len(self._input_stream_type_info.keys()) != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s5">&quot;Can't process single image input since the graph has more than one input streams.&quot;</span>
        <span class="s1">)</span>
      <span class="s1">input_dict = {next(iter(self._input_stream_type_info)): input_data}</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">input_dict = input_data</span>

    <span class="s0"># Set the timestamp increment to 33333 us to simulate the 30 fps video</span>
    <span class="s0"># input.</span>
    <span class="s1">self._simulated_timestamp += </span><span class="s4">33333</span>
    <span class="s3">for </span><span class="s1">stream_name</span><span class="s3">, </span><span class="s1">data </span><span class="s3">in </span><span class="s1">input_dict.items():</span>
      <span class="s1">input_stream_type = self._input_stream_type_info[stream_name]</span>
      <span class="s3">if </span><span class="s1">(input_stream_type == PacketDataType.PROTO_LIST </span><span class="s3">or</span>
          <span class="s1">input_stream_type == PacketDataType.AUDIO):</span>
        <span class="s0"># TODO: Support audio data.</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s5">f'SolutionBase can only process non-audio and non-proto-list data. '</span>
            <span class="s5">f'</span><span class="s3">{</span><span class="s1">self._input_stream_type_info[stream_name].name</span><span class="s3">} </span><span class="s5">'</span>
            <span class="s5">f'type is not supported yet.'</span><span class="s1">)</span>
      <span class="s3">elif </span><span class="s1">(input_stream_type == PacketDataType.IMAGE_FRAME </span><span class="s3">or</span>
            <span class="s1">input_stream_type == PacketDataType.IMAGE):</span>
        <span class="s3">if </span><span class="s1">data.shape[</span><span class="s4">2</span><span class="s1">] != RGB_CHANNELS:</span>
          <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Input image must contain three channel rgb data.'</span><span class="s1">)</span>
        <span class="s1">self._graph.add_packet_to_input_stream(</span>
            <span class="s1">stream=stream_name</span><span class="s3">,</span>
            <span class="s1">packet=self._make_packet(input_stream_type</span><span class="s3">,</span>
                                     <span class="s1">data).at(self._simulated_timestamp))</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">self._graph.add_packet_to_input_stream(</span>
            <span class="s1">stream=stream_name</span><span class="s3">,</span>
            <span class="s1">packet=self._make_packet(input_stream_type</span><span class="s3">,</span>
                                     <span class="s1">data).at(self._simulated_timestamp))</span>

    <span class="s1">self._graph.wait_until_idle()</span>
    <span class="s0"># Create a NamedTuple object where the field names are mapping to the graph</span>
    <span class="s0"># output stream names.</span>
    <span class="s1">solution_outputs = collections.namedtuple(</span>
        <span class="s5">'SolutionOutputs'</span><span class="s3">, </span><span class="s1">self._output_stream_type_info.keys())</span>
    <span class="s3">for </span><span class="s1">stream_name </span><span class="s3">in </span><span class="s1">self._output_stream_type_info.keys():</span>
      <span class="s3">if </span><span class="s1">stream_name </span><span class="s3">in </span><span class="s1">self._graph_outputs:</span>
        <span class="s1">setattr(</span>
            <span class="s1">solution_outputs</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">,</span>
            <span class="s1">self._get_packet_content(self._output_stream_type_info[stream_name]</span><span class="s3">,</span>
                                     <span class="s1">self._graph_outputs[stream_name]))</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">setattr(solution_outputs</span><span class="s3">, </span><span class="s1">stream_name</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">solution_outputs</span>

  <span class="s3">def </span><span class="s1">close(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Closes all the input sources and the graph.&quot;&quot;&quot;</span>
    <span class="s1">self._graph.close()</span>
    <span class="s1">self._graph = </span><span class="s3">None</span>
    <span class="s1">self._input_stream_type_info = </span><span class="s3">None</span>
    <span class="s1">self._output_stream_type_info = </span><span class="s3">None</span>

  <span class="s3">def </span><span class="s1">reset(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Resets the graph for another run.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self._graph:</span>
      <span class="s1">self._graph.close()</span>
      <span class="s1">self._graph.start_run(self._input_side_packets)</span>

  <span class="s3">def </span><span class="s1">_initialize_graph_interface(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">validated_graph: validated_graph_config.ValidatedGraphConfig</span><span class="s3">,</span>
      <span class="s1">side_inputs: Optional[Mapping[str</span><span class="s3">, </span><span class="s1">Any]] = </span><span class="s3">None,</span>
      <span class="s1">outputs: Optional[List[str]] = </span><span class="s3">None,</span>
      <span class="s1">stream_type_hints: Optional[Mapping[str</span><span class="s3">, </span><span class="s1">PacketDataType]] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Gets graph interface type information and returns the canonical graph config proto.&quot;&quot;&quot;</span>

    <span class="s1">canonical_graph_config_proto = calculator_pb2.CalculatorGraphConfig()</span>
    <span class="s1">canonical_graph_config_proto.ParseFromString(validated_graph.binary_config)</span>

    <span class="s0"># Gets name from a 'TAG:index:name' str.</span>
    <span class="s3">def </span><span class="s1">get_name(tag_index_name):</span>
      <span class="s3">return </span><span class="s1">tag_index_name.split(</span><span class="s5">':'</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0"># Gets the packet type information of the input streams and output streams</span>
    <span class="s0"># from the user provided stream_type_hints field or validated calculator</span>
    <span class="s0"># graph. The mappings from the stream names to the packet data types is</span>
    <span class="s0"># for deciding which packet creator and getter methods to call in the</span>
    <span class="s0"># process() method.</span>
    <span class="s3">def </span><span class="s1">get_stream_packet_type(packet_tag_index_name):</span>
      <span class="s1">stream_name = get_name(packet_tag_index_name)</span>
      <span class="s3">if </span><span class="s1">stream_type_hints </span><span class="s3">and </span><span class="s1">stream_name </span><span class="s3">in </span><span class="s1">stream_type_hints.keys():</span>
        <span class="s3">return </span><span class="s1">stream_type_hints[stream_name]</span>
      <span class="s3">return </span><span class="s1">PacketDataType.from_registered_name(</span>
          <span class="s1">validated_graph.registered_stream_type_name(stream_name))</span>

    <span class="s1">self._input_stream_type_info = {</span>
        <span class="s1">get_name(tag_index_name): get_stream_packet_type(tag_index_name)</span>
        <span class="s3">for </span><span class="s1">tag_index_name </span><span class="s3">in </span><span class="s1">canonical_graph_config_proto.input_stream</span>
    <span class="s1">}</span>

    <span class="s3">if not </span><span class="s1">outputs:</span>
      <span class="s1">output_streams = canonical_graph_config_proto.output_stream</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">output_streams = outputs</span>
    <span class="s1">self._output_stream_type_info = {</span>
        <span class="s1">get_name(tag_index_name): get_stream_packet_type(tag_index_name)</span>
        <span class="s3">for </span><span class="s1">tag_index_name </span><span class="s3">in </span><span class="s1">output_streams</span>
    <span class="s1">}</span>

    <span class="s0"># Gets the packet type information of the input side packets from the</span>
    <span class="s0"># validated calculator graph. The mappings from the side packet names to the</span>
    <span class="s0"># packet data types is for making the input_side_packets dict for graph</span>
    <span class="s0"># start_run().</span>
    <span class="s3">def </span><span class="s1">get_side_packet_type(packet_tag_index_name):</span>
      <span class="s3">return </span><span class="s1">PacketDataType.from_registered_name(</span>
          <span class="s1">validated_graph.registered_side_packet_type_name(</span>
              <span class="s1">get_name(packet_tag_index_name)))</span>

    <span class="s1">self._side_input_type_info = {</span>
        <span class="s1">get_name(tag_index_name): get_side_packet_type(tag_index_name)</span>
        <span class="s3">for </span><span class="s1">tag_index_name</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">(side_inputs </span><span class="s3">or </span><span class="s1">{}).items()</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">canonical_graph_config_proto</span>

  <span class="s3">def </span><span class="s1">_modify_calculator_options(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">calculator_graph_config: calculator_pb2.CalculatorGraphConfig</span><span class="s3">,</span>
      <span class="s1">calculator_params: Mapping[str</span><span class="s3">, </span><span class="s1">Any]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Modifies the CalculatorOptions of the calculators listed in calculator_params.&quot;&quot;&quot;</span>

    <span class="s0"># Reorganizes the calculator options field data by calculator name and puts</span>
    <span class="s0"># all the field data of the same calculator in a list.</span>
    <span class="s3">def </span><span class="s1">generate_nested_calculator_params(flat_map):</span>
      <span class="s1">nested_map = {}</span>
      <span class="s3">for </span><span class="s1">compound_name</span><span class="s3">, </span><span class="s1">field_value </span><span class="s3">in </span><span class="s1">flat_map.items():</span>
        <span class="s1">calculator_and_field_name = compound_name.split(</span><span class="s5">'.'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(calculator_and_field_name) != </span><span class="s4">2</span><span class="s1">:</span>
          <span class="s3">raise </span><span class="s1">ValueError(</span>
              <span class="s5">f'The key &quot;</span><span class="s3">{</span><span class="s1">compound_name</span><span class="s3">}</span><span class="s5">&quot; in the calculator_params is invalid.'</span><span class="s1">)</span>
        <span class="s1">calculator_name = calculator_and_field_name[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">field_name = calculator_and_field_name[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">calculator_name </span><span class="s3">in </span><span class="s1">nested_map:</span>
          <span class="s1">nested_map[calculator_name].append((field_name</span><span class="s3">, </span><span class="s1">field_value))</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">nested_map[calculator_name] = [(field_name</span><span class="s3">, </span><span class="s1">field_value)]</span>
      <span class="s3">return </span><span class="s1">nested_map</span>

    <span class="s3">def </span><span class="s1">modify_options_fields(calculator_options</span><span class="s3">, </span><span class="s1">options_field_list):</span>
      <span class="s3">for </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">field_value </span><span class="s3">in </span><span class="s1">options_field_list:</span>
        <span class="s3">if </span><span class="s1">field_value </span><span class="s3">is None</span><span class="s1">:</span>
          <span class="s1">calculator_options.ClearField(field_name)</span>
        <span class="s3">else</span><span class="s1">:</span>
          <span class="s1">field_label = calculator_options.DESCRIPTOR.fields_by_name[</span>
              <span class="s1">field_name].label</span>
          <span class="s3">if </span><span class="s1">field_label == descriptor.FieldDescriptor.LABEL_REPEATED:</span>
            <span class="s3">if not </span><span class="s1">isinstance(field_value</span><span class="s3">, </span><span class="s1">Iterable):</span>
              <span class="s3">raise </span><span class="s1">ValueError(</span>
                  <span class="s5">f'</span><span class="s3">{</span><span class="s1">field_name</span><span class="s3">} </span><span class="s5">is a repeated proto field but the value '</span>
                  <span class="s5">f'to be set is </span><span class="s3">{</span><span class="s1">type(field_value)</span><span class="s3">}</span><span class="s5">, which is not iterable.'</span><span class="s1">)</span>
            <span class="s0"># TODO: Support resetting the entire repeated field</span>
            <span class="s0"># (array-option) and changing the individual values in the repeated</span>
            <span class="s0"># field (array-element-option).</span>
            <span class="s1">calculator_options.ClearField(field_name)</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">field_value:</span>
              <span class="s1">getattr(calculator_options</span><span class="s3">, </span><span class="s1">field_name).append(elem)</span>
          <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">setattr(calculator_options</span><span class="s3">, </span><span class="s1">field_name</span><span class="s3">, </span><span class="s1">field_value)</span>

    <span class="s1">nested_calculator_params = generate_nested_calculator_params(</span>
        <span class="s1">calculator_params)</span>

    <span class="s1">num_modified = </span><span class="s4">0</span>
    <span class="s3">for </span><span class="s1">node </span><span class="s3">in </span><span class="s1">calculator_graph_config.node:</span>
      <span class="s3">if </span><span class="s1">node.name </span><span class="s3">not in </span><span class="s1">nested_calculator_params:</span>
        <span class="s3">continue</span>
      <span class="s1">options_type = CALCULATOR_TO_OPTIONS.get(node.calculator)</span>
      <span class="s3">if </span><span class="s1">options_type </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s5">f'Modifying the calculator options of </span><span class="s3">{</span><span class="s1">node.name</span><span class="s3">} </span><span class="s5">is not supported.'</span>
        <span class="s1">)</span>
      <span class="s1">options_field_list = nested_calculator_params[node.name]</span>
      <span class="s3">if </span><span class="s1">node.HasField(</span><span class="s5">'options'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">node.node_options:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s5">f'Cannot modify the calculator options of </span><span class="s3">{</span><span class="s1">node.name</span><span class="s3">} </span><span class="s5">because it '</span>
            <span class="s5">f'has both options and node_options fields.'</span><span class="s1">)</span>
      <span class="s3">if </span><span class="s1">node.node_options:</span>
        <span class="s0"># The &quot;node_options&quot; case for the proto3 syntax.</span>
        <span class="s1">node_options_modified = </span><span class="s3">False</span>
        <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">node.node_options:</span>
          <span class="s1">type_name = elem.type_url.split(</span><span class="s5">'/'</span><span class="s1">)[-</span><span class="s4">1</span><span class="s1">]</span>
          <span class="s3">if </span><span class="s1">type_name == options_type.DESCRIPTOR.full_name:</span>
            <span class="s1">calculator_options = options_type.FromString(elem.value)</span>
            <span class="s1">modify_options_fields(calculator_options</span><span class="s3">, </span><span class="s1">options_field_list)</span>
            <span class="s1">elem.value = calculator_options.SerializeToString()</span>
            <span class="s1">node_options_modified = </span><span class="s3">True</span>
            <span class="s3">break</span>
        <span class="s0"># There is no existing node_options being modified. Add a new</span>
        <span class="s0"># node_options instead.</span>
        <span class="s3">if not </span><span class="s1">node_options_modified:</span>
          <span class="s1">calculator_options = options_type()</span>
          <span class="s1">modify_options_fields(calculator_options</span><span class="s3">, </span><span class="s1">options_field_list)</span>
          <span class="s1">node.node_options.add().Pack(calculator_options)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># The &quot;options&quot; case for the proto2 syntax as well as the fallback</span>
        <span class="s0"># when the calculator doesn't have either &quot;options&quot; or &quot;node_options&quot;.</span>
        <span class="s1">modify_options_fields(node.options.Extensions[options_type.ext]</span><span class="s3">,</span>
                              <span class="s1">options_field_list)</span>

      <span class="s1">num_modified += </span><span class="s4">1</span>
      <span class="s0"># Exits the loop early when every elements in nested_calculator_params</span>
      <span class="s0"># have been visited.</span>
      <span class="s3">if </span><span class="s1">num_modified == len(nested_calculator_params):</span>
        <span class="s3">break</span>
    <span class="s3">if </span><span class="s1">num_modified &lt; len(nested_calculator_params):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Not all calculator params are valid.'</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">create_graph_options(self</span><span class="s3">, </span><span class="s1">options_message: message.Message</span><span class="s3">,</span>
                           <span class="s1">values: Mapping[str</span><span class="s3">, </span><span class="s1">Any]) -&gt; message.Message:</span>
    <span class="s2">&quot;&quot;&quot;Sets protobuf field values. 
 
    Args: 
      options_message: the options protobuf message. 
      values: field value pairs, where each field may be a &quot;.&quot; separated path. 
 
    Returns: 
      the options protobuf message. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">hasattr(values</span><span class="s3">, </span><span class="s5">'items'</span><span class="s1">):</span>
      <span class="s1">values = values.items()</span>
    <span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">values:</span>
      <span class="s1">(field</span><span class="s3">, </span><span class="s1">value) = pair</span>
      <span class="s1">fields = field.split(</span><span class="s5">'.'</span><span class="s1">)</span>
      <span class="s1">m = options_message</span>
      <span class="s3">while </span><span class="s1">len(fields) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">m = getattr(m</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s3">del </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">]</span>
      <span class="s1">v = getattr(m</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">])</span>
      <span class="s3">if </span><span class="s1">hasattr(v</span><span class="s3">, </span><span class="s5">'append'</span><span class="s1">):</span>
        <span class="s3">del </span><span class="s1">v[:]</span>
        <span class="s1">v.extend(value)</span>
      <span class="s3">elif </span><span class="s1">hasattr(v</span><span class="s3">, </span><span class="s5">'CopyFrom'</span><span class="s1">):</span>
        <span class="s1">v.CopyFrom(value)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">setattr(m</span><span class="s3">, </span><span class="s1">fields[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">value)</span>
    <span class="s3">return </span><span class="s1">options_message</span>

  <span class="s3">def </span><span class="s1">_set_extension(self</span><span class="s3">,</span>
                     <span class="s1">extension_list: containers.RepeatedCompositeFieldContainer</span><span class="s3">,</span>
                     <span class="s1">extension_value: message.Message) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Sets one value in a repeated protobuf.Any extension field.&quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">extension_any </span><span class="s3">in </span><span class="s1">extension_list:</span>
      <span class="s3">if </span><span class="s1">extension_any.Is(extension_value.DESCRIPTOR):</span>
        <span class="s1">v = type(extension_value)()</span>
        <span class="s1">extension_any.Unpack(v)</span>
        <span class="s1">v.MergeFrom(extension_value)</span>
        <span class="s1">extension_any.Pack(v)</span>
        <span class="s3">return</span>
    <span class="s1">extension_list.add().Pack(extension_value)</span>

  <span class="s3">def </span><span class="s1">_make_packet(self</span><span class="s3">, </span><span class="s1">packet_data_type: PacketDataType</span><span class="s3">,</span>
                   <span class="s1">data: Any) -&gt; packet.Packet:</span>
    <span class="s3">if </span><span class="s1">(packet_data_type == PacketDataType.IMAGE_FRAME </span><span class="s3">or</span>
        <span class="s1">packet_data_type == PacketDataType.IMAGE):</span>
      <span class="s3">return </span><span class="s1">getattr(packet_creator</span><span class="s3">, </span><span class="s5">'create_' </span><span class="s1">+ packet_data_type.value)(</span>
          <span class="s1">data</span><span class="s3">, </span><span class="s1">image_format=image_frame.ImageFormat.SRGB)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">getattr(packet_creator</span><span class="s3">, </span><span class="s5">'create_' </span><span class="s1">+ packet_data_type.value)(data)</span>

  <span class="s3">def </span><span class="s1">_get_packet_content(self</span><span class="s3">, </span><span class="s1">packet_data_type: PacketDataType</span><span class="s3">,</span>
                          <span class="s1">output_packet: packet.Packet) -&gt; Any:</span>
    <span class="s2">&quot;&quot;&quot;Gets packet content from a packet by type. 
 
    Args: 
      packet_data_type: The supported packet data type. 
      output_packet: The packet to get content from. 
 
    Returns: 
      Packet content by packet data type. None to indicate &quot;no output&quot;. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">output_packet.is_empty():</span>
      <span class="s3">return None</span>
    <span class="s3">if </span><span class="s1">packet_data_type == PacketDataType.STRING:</span>
      <span class="s3">return </span><span class="s1">packet_getter.get_str(output_packet)</span>
    <span class="s3">elif </span><span class="s1">(packet_data_type == PacketDataType.IMAGE_FRAME </span><span class="s3">or</span>
          <span class="s1">packet_data_type == PacketDataType.IMAGE):</span>
      <span class="s3">return </span><span class="s1">getattr(packet_getter</span><span class="s3">, </span><span class="s5">'get_' </span><span class="s1">+</span>
                     <span class="s1">packet_data_type.value)(output_packet).numpy_view()</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">getattr(packet_getter</span><span class="s3">, </span><span class="s5">'get_' </span><span class="s1">+ packet_data_type.value)(</span>
          <span class="s1">output_packet)</span>

  <span class="s3">def </span><span class="s1">__enter__(self):</span>
    <span class="s2">&quot;&quot;&quot;A &quot;with&quot; statement support.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self</span>

  <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">exc_type</span><span class="s3">, </span><span class="s1">exc_val</span><span class="s3">, </span><span class="s1">exc_tb):</span>
    <span class="s2">&quot;&quot;&quot;Closes all the input sources and the graph.&quot;&quot;&quot;</span>
    <span class="s1">self.close()</span>
</pre>
</body>
</html>