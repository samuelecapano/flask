<html>
<head>
<title>polar.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
polar.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">types</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">cbook</span>
<span class="s0">from </span><span class="s1">matplotlib.axes </span><span class="s0">import </span><span class="s1">Axes</span>
<span class="s0">import </span><span class="s1">matplotlib.axis </span><span class="s0">as </span><span class="s1">maxis</span>
<span class="s0">import </span><span class="s1">matplotlib.markers </span><span class="s0">as </span><span class="s1">mmarkers</span>
<span class="s0">import </span><span class="s1">matplotlib.patches </span><span class="s0">as </span><span class="s1">mpatches</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">import </span><span class="s1">matplotlib.ticker </span><span class="s0">as </span><span class="s1">mticker</span>
<span class="s0">import </span><span class="s1">matplotlib.transforms </span><span class="s0">as </span><span class="s1">mtransforms</span>
<span class="s0">from </span><span class="s1">matplotlib.spines </span><span class="s0">import </span><span class="s1">Spine</span>


<span class="s0">class </span><span class="s1">PolarTransform(mtransforms.Transform):</span>
    <span class="s2">r&quot;&quot;&quot; 
    The base polar transform. 
 
    This transform maps polar coordinates :math:`\theta, r` into Cartesian 
    coordinates :math:`x, y = r \cos(\theta), r \sin(\theta)` 
    (but does not fully transform into Axes coordinates or 
    handle positioning in screen space). 
 
    This transformation is designed to be applied to data after any scaling 
    along the radial axis (e.g. log-scaling) has been applied to the input 
    data. 
 
    Path segments at a fixed radius are automatically transformed to circular 
    arcs as long as ``path._interpolation_steps &gt; 1``. 
    &quot;&quot;&quot;</span>

    <span class="s1">input_dims = output_dims = </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">use_rmin=</span><span class="s0">True,</span>
                 <span class="s1">_apply_theta_transforms=</span><span class="s0">True, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">scale_transform=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `~matplotlib.axis.Axis`, optional 
            Axis associated with this transform. This is used to get the 
            minimum radial limit. 
        use_rmin : `bool`, optional 
            If ``True``, subtract the minimum radial axis limit before 
            transforming to Cartesian coordinates. *axis* must also be 
            specified for this to take effect. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._axis = axis</span>
        <span class="s1">self._use_rmin = use_rmin</span>
        <span class="s1">self._apply_theta_transforms = _apply_theta_transforms</span>
        <span class="s1">self._scale_transform = scale_transform</span>

    <span class="s1">__str__ = mtransforms._make_str_method(</span>
        <span class="s4">&quot;_axis&quot;</span><span class="s0">,</span>
        <span class="s1">use_rmin=</span><span class="s4">&quot;_use_rmin&quot;</span><span class="s0">,</span>
        <span class="s1">_apply_theta_transforms=</span><span class="s4">&quot;_apply_theta_transforms&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_rorigin(self):</span>
        <span class="s5"># Get lower r limit after being scaled by the radial scale transform</span>
        <span class="s0">return </span><span class="s1">self._scale_transform.transform(</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">self._axis.get_rorigin()))[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">tr):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">theta</span><span class="s0">, </span><span class="s1">r = np.transpose(tr)</span>
        <span class="s5"># PolarAxes does not use the theta transforms here, but apply them for</span>
        <span class="s5"># backwards-compatibility if not being used by it.</span>
        <span class="s0">if </span><span class="s1">self._apply_theta_transforms </span><span class="s0">and </span><span class="s1">self._axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">theta *= self._axis.get_theta_direction()</span>
            <span class="s1">theta += self._axis.get_theta_offset()</span>
        <span class="s0">if </span><span class="s1">self._use_rmin </span><span class="s0">and </span><span class="s1">self._axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">r = (r - self._get_rorigin()) * self._axis.get_rsign()</span>
        <span class="s1">r = np.where(r &gt;= </span><span class="s3">0</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s0">return </span><span class="s1">np.column_stack([r * np.cos(theta)</span><span class="s0">, </span><span class="s1">r * np.sin(theta)])</span>

    <span class="s0">def </span><span class="s1">transform_path_non_affine(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">if not </span><span class="s1">len(path) </span><span class="s0">or </span><span class="s1">path._interpolation_steps == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">Path(self.transform_non_affine(path.vertices)</span><span class="s0">, </span><span class="s1">path.codes)</span>
        <span class="s1">xys = []</span>
        <span class="s1">codes = []</span>
        <span class="s1">last_t = last_r = </span><span class="s0">None</span>
        <span class="s0">for </span><span class="s1">trs</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">path.iter_segments():</span>
            <span class="s1">trs = trs.reshape((-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">c == Path.LINETO:</span>
                <span class="s1">(t</span><span class="s0">, </span><span class="s1">r)</span><span class="s0">, </span><span class="s1">= trs</span>
                <span class="s0">if </span><span class="s1">t == last_t:  </span><span class="s5"># Same angle: draw a straight line.</span>
                    <span class="s1">xys.extend(self.transform_non_affine(trs))</span>
                    <span class="s1">codes.append(Path.LINETO)</span>
                <span class="s0">elif </span><span class="s1">r == last_r:  </span><span class="s5"># Same radius: draw an arc.</span>
                    <span class="s5"># The following is complicated by Path.arc() being</span>
                    <span class="s5"># &quot;helpful&quot; and unwrapping the angles, but we don't want</span>
                    <span class="s5"># that behavior here.</span>
                    <span class="s1">last_td</span><span class="s0">, </span><span class="s1">td = np.rad2deg([last_t</span><span class="s0">, </span><span class="s1">t])</span>
                    <span class="s0">if </span><span class="s1">self._use_rmin </span><span class="s0">and </span><span class="s1">self._axis </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">r = ((r - self._get_rorigin())</span>
                             <span class="s1">* self._axis.get_rsign())</span>
                    <span class="s0">if </span><span class="s1">last_td &lt;= td:</span>
                        <span class="s0">while </span><span class="s1">td - last_td &gt; </span><span class="s3">360</span><span class="s1">:</span>
                            <span class="s1">arc = Path.arc(last_td</span><span class="s0">, </span><span class="s1">last_td + </span><span class="s3">360</span><span class="s1">)</span>
                            <span class="s1">xys.extend(arc.vertices[</span><span class="s3">1</span><span class="s1">:] * r)</span>
                            <span class="s1">codes.extend(arc.codes[</span><span class="s3">1</span><span class="s1">:])</span>
                            <span class="s1">last_td += </span><span class="s3">360</span>
                        <span class="s1">arc = Path.arc(last_td</span><span class="s0">, </span><span class="s1">td)</span>
                        <span class="s1">xys.extend(arc.vertices[</span><span class="s3">1</span><span class="s1">:] * r)</span>
                        <span class="s1">codes.extend(arc.codes[</span><span class="s3">1</span><span class="s1">:])</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s5"># The reverse version also relies on the fact that all</span>
                        <span class="s5"># codes but the first one are the same.</span>
                        <span class="s0">while </span><span class="s1">last_td - td &gt; </span><span class="s3">360</span><span class="s1">:</span>
                            <span class="s1">arc = Path.arc(last_td - </span><span class="s3">360</span><span class="s0">, </span><span class="s1">last_td)</span>
                            <span class="s1">xys.extend(arc.vertices[::-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:] * r)</span>
                            <span class="s1">codes.extend(arc.codes[</span><span class="s3">1</span><span class="s1">:])</span>
                            <span class="s1">last_td -= </span><span class="s3">360</span>
                        <span class="s1">arc = Path.arc(td</span><span class="s0">, </span><span class="s1">last_td)</span>
                        <span class="s1">xys.extend(arc.vertices[::-</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:] * r)</span>
                        <span class="s1">codes.extend(arc.codes[</span><span class="s3">1</span><span class="s1">:])</span>
                <span class="s0">else</span><span class="s1">:  </span><span class="s5"># Interpolate.</span>
                    <span class="s1">trs = cbook.simple_linear_interpolation(</span>
                        <span class="s1">np.row_stack([(last_t</span><span class="s0">, </span><span class="s1">last_r)</span><span class="s0">, </span><span class="s1">trs])</span><span class="s0">,</span>
                        <span class="s1">path._interpolation_steps)[</span><span class="s3">1</span><span class="s1">:]</span>
                    <span class="s1">xys.extend(self.transform_non_affine(trs))</span>
                    <span class="s1">codes.extend([Path.LINETO] * len(trs))</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s5"># Not a straight line.</span>
                <span class="s1">xys.extend(self.transform_non_affine(trs))</span>
                <span class="s1">codes.extend([c] * len(trs))</span>
            <span class="s1">last_t</span><span class="s0">, </span><span class="s1">last_r = trs[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">Path(xys</span><span class="s0">, </span><span class="s1">codes)</span>

    <span class="s0">def </span><span class="s1">inverted(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">return </span><span class="s1">PolarAxes.InvertedPolarTransform(self._axis</span><span class="s0">, </span><span class="s1">self._use_rmin</span><span class="s0">,</span>
                                                <span class="s1">self._apply_theta_transforms)</span>


<span class="s0">class </span><span class="s1">PolarAffine(mtransforms.Affine2DBase):</span>
    <span class="s2">r&quot;&quot;&quot; 
    The affine part of the polar projection. 
 
    Scales the output so that maximum radius rests on the edge of the axes 
    circle and the origin is mapped to (0.5, 0.5). The transform applied is 
    the same to x and y components and given by: 
 
    .. math:: 
 
        x_{1} = 0.5 \left [ \frac{x_{0}}{(r_{\max} - r_{\min})} + 1 \right ] 
 
    :math:`r_{\min}, r_{\max}` are the minimum and maximum radial limits after 
    any scaling (e.g. log scaling) has been removed. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">scale_transform</span><span class="s0">, </span><span class="s1">limits):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        scale_transform : `~matplotlib.transforms.Transform` 
            Scaling transform for the data. This is used to remove any scaling 
            from the radial view limits. 
        limits : `~matplotlib.transforms.BboxBase` 
            View limits of the data. The only part of its bounds that is used 
            is the y limits (for the radius limits). 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._scale_transform = scale_transform</span>
        <span class="s1">self._limits = limits</span>
        <span class="s1">self.set_children(scale_transform</span><span class="s0">, </span><span class="s1">limits)</span>
        <span class="s1">self._mtx = </span><span class="s0">None</span>

    <span class="s1">__str__ = mtransforms._make_str_method(</span><span class="s4">&quot;_scale_transform&quot;</span><span class="s0">, </span><span class="s4">&quot;_limits&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_matrix(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">self._invalid:</span>
            <span class="s1">limits_scaled = self._limits.transformed(self._scale_transform)</span>
            <span class="s1">yscale = limits_scaled.ymax - limits_scaled.ymin</span>
            <span class="s1">affine = mtransforms.Affine2D() \</span>
                <span class="s1">.scale(</span><span class="s3">0.5 </span><span class="s1">/ yscale) \</span>
                <span class="s1">.translate(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
            <span class="s1">self._mtx = affine.get_matrix()</span>
            <span class="s1">self._inverted = </span><span class="s0">None</span>
            <span class="s1">self._invalid = </span><span class="s3">0</span>
        <span class="s0">return </span><span class="s1">self._mtx</span>


<span class="s0">class </span><span class="s1">InvertedPolarTransform(mtransforms.Transform):</span>
    <span class="s2">&quot;&quot;&quot; 
    The inverse of the polar transform, mapping Cartesian 
    coordinate space *x* and *y* back to *theta* and *r*. 
    &quot;&quot;&quot;</span>
    <span class="s1">input_dims = output_dims = </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">use_rmin=</span><span class="s0">True,</span>
                 <span class="s1">_apply_theta_transforms=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `~matplotlib.axis.Axis`, optional 
            Axis associated with this transform. This is used to get the 
            minimum radial limit. 
        use_rmin : `bool`, optional 
            If ``True`` add the minimum radial axis limit after 
            transforming from Cartesian coordinates. *axis* must also be 
            specified for this to take effect. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._axis = axis</span>
        <span class="s1">self._use_rmin = use_rmin</span>
        <span class="s1">self._apply_theta_transforms = _apply_theta_transforms</span>

    <span class="s1">__str__ = mtransforms._make_str_method(</span>
        <span class="s4">&quot;_axis&quot;</span><span class="s0">,</span>
        <span class="s1">use_rmin=</span><span class="s4">&quot;_use_rmin&quot;</span><span class="s0">,</span>
        <span class="s1">_apply_theta_transforms=</span><span class="s4">&quot;_apply_theta_transforms&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">xy):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = xy.T</span>
        <span class="s1">r = np.hypot(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">theta = (np.arctan2(y</span><span class="s0">, </span><span class="s1">x) + </span><span class="s3">2 </span><span class="s1">* np.pi) % (</span><span class="s3">2 </span><span class="s1">* np.pi)</span>
        <span class="s5"># PolarAxes does not use the theta transforms here, but apply them for</span>
        <span class="s5"># backwards-compatibility if not being used by it.</span>
        <span class="s0">if </span><span class="s1">self._apply_theta_transforms </span><span class="s0">and </span><span class="s1">self._axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">theta -= self._axis.get_theta_offset()</span>
            <span class="s1">theta *= self._axis.get_theta_direction()</span>
            <span class="s1">theta %= </span><span class="s3">2 </span><span class="s1">* np.pi</span>
        <span class="s0">if </span><span class="s1">self._use_rmin </span><span class="s0">and </span><span class="s1">self._axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">r += self._axis.get_rorigin()</span>
            <span class="s1">r *= self._axis.get_rsign()</span>
        <span class="s0">return </span><span class="s1">np.column_stack([theta</span><span class="s0">, </span><span class="s1">r])</span>

    <span class="s0">def </span><span class="s1">inverted(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">return </span><span class="s1">PolarAxes.PolarTransform(self._axis</span><span class="s0">, </span><span class="s1">self._use_rmin</span><span class="s0">,</span>
                                        <span class="s1">self._apply_theta_transforms)</span>


<span class="s0">class </span><span class="s1">ThetaFormatter(mticker.Formatter):</span>
    <span class="s2">&quot;&quot;&quot; 
    Used to format the *theta* tick labels.  Converts the native 
    unit of radians into degrees and adds a degree symbol. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pos=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s1">d = np.rad2deg(abs(vmax - vmin))</span>
        <span class="s1">digits = max(-int(np.log10(d) - </span><span class="s3">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s5"># Use Unicode rather than mathtext with \circ, so that it will work</span>
        <span class="s5"># correctly with any arbitrary font (assuming it has a degree sign),</span>
        <span class="s5"># whereas $5\circ$ will only work correctly with one of the supported</span>
        <span class="s5"># math fonts (Computer Modern and STIX).</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;{value:0.{digits:d}f}</span><span class="s0">\N{DEGREE SIGN}</span><span class="s4">&quot;</span>
                <span class="s1">.format(value=np.rad2deg(x)</span><span class="s0">, </span><span class="s1">digits=digits))</span>


<span class="s0">class </span><span class="s1">_AxisWrapper:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">self._axis = axis</span>

    <span class="s0">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self._axis.get_view_interval())</span>

    <span class="s0">def </span><span class="s1">set_view_interval(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">self._axis.set_view_interval(*np.deg2rad((vmin</span><span class="s0">, </span><span class="s1">vmax)))</span>

    <span class="s0">def </span><span class="s1">get_minpos(self):</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self._axis.get_minpos())</span>

    <span class="s0">def </span><span class="s1">get_data_interval(self):</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self._axis.get_data_interval())</span>

    <span class="s0">def </span><span class="s1">set_data_interval(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">self._axis.set_data_interval(*np.deg2rad((vmin</span><span class="s0">, </span><span class="s1">vmax)))</span>

    <span class="s0">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s0">return </span><span class="s1">self._axis.get_tick_space()</span>


<span class="s0">class </span><span class="s1">ThetaLocator(mticker.Locator):</span>
    <span class="s2">&quot;&quot;&quot; 
    Used to locate theta ticks. 
 
    This will work the same as the base locator except in the case that the 
    view spans the entire circle. In such cases, the previously used default 
    locations of every 45 degrees are returned. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">base):</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.axis = self.base.axis = _AxisWrapper(self.base.axis)</span>

    <span class="s0">def </span><span class="s1">set_axis(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">self.axis = _AxisWrapper(axis)</span>
        <span class="s1">self.base.set_axis(self.axis)</span>

    <span class="s0">def </span><span class="s1">__call__(self):</span>
        <span class="s1">lim = self.axis.get_view_interval()</span>
        <span class="s0">if </span><span class="s1">_is_full_circle_deg(lim[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lim[</span><span class="s3">1</span><span class="s1">]):</span>
            <span class="s0">return </span><span class="s1">np.arange(</span><span class="s3">8</span><span class="s1">) * </span><span class="s3">2 </span><span class="s1">* np.pi / </span><span class="s3">8</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.deg2rad(self.base())</span>

    <span class="s0">def </span><span class="s1">view_limits(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = np.rad2deg((vmin</span><span class="s0">, </span><span class="s1">vmax))</span>
        <span class="s0">return </span><span class="s1">np.deg2rad(self.base.view_limits(vmin</span><span class="s0">, </span><span class="s1">vmax))</span>


<span class="s0">class </span><span class="s1">ThetaTick(maxis.XTick):</span>
    <span class="s2">&quot;&quot;&quot; 
    A theta-axis tick. 
 
    This subclass of `.XTick` provides angular ticks with some small 
    modification to their re-positioning such that ticks are rotated based on 
    tick location. This results in ticks that are correctly perpendicular to 
    the arc spine. 
 
    When 'auto' rotation is enabled, labels are also rotated to be parallel to 
    the spine. The label padding is also applied here since it's not possible 
    to use a generic axes transform to produce tick-specific padding. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._text1_translate = mtransforms.ScaledTranslation(</span>
            <span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">axes.figure.dpi_scale_trans)</span>
        <span class="s1">self._text2_translate = mtransforms.ScaledTranslation(</span>
            <span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">axes.figure.dpi_scale_trans)</span>
        <span class="s1">super().__init__(axes</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.label1.set(</span>
            <span class="s1">rotation_mode=</span><span class="s4">'anchor'</span><span class="s0">,</span>
            <span class="s1">transform=self.label1.get_transform() + self._text1_translate)</span>
        <span class="s1">self.label2.set(</span>
            <span class="s1">rotation_mode=</span><span class="s4">'anchor'</span><span class="s0">,</span>
            <span class="s1">transform=self.label2.get_transform() + self._text2_translate)</span>

    <span class="s0">def </span><span class="s1">_apply_params(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super()._apply_params(**kwargs)</span>
        <span class="s5"># Ensure transform is correct; sometimes this gets reset.</span>
        <span class="s1">trans = self.label1.get_transform()</span>
        <span class="s0">if not </span><span class="s1">trans.contains_branch(self._text1_translate):</span>
            <span class="s1">self.label1.set_transform(trans + self._text1_translate)</span>
        <span class="s1">trans = self.label2.get_transform()</span>
        <span class="s0">if not </span><span class="s1">trans.contains_branch(self._text2_translate):</span>
            <span class="s1">self.label2.set_transform(trans + self._text2_translate)</span>

    <span class="s0">def </span><span class="s1">_update_padding(self</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s1">angle):</span>
        <span class="s1">padx = pad * np.cos(angle) / </span><span class="s3">72</span>
        <span class="s1">pady = pad * np.sin(angle) / </span><span class="s3">72</span>
        <span class="s1">self._text1_translate._t = (padx</span><span class="s0">, </span><span class="s1">pady)</span>
        <span class="s1">self._text1_translate.invalidate()</span>
        <span class="s1">self._text2_translate._t = (-padx</span><span class="s0">, </span><span class="s1">-pady)</span>
        <span class="s1">self._text2_translate.invalidate()</span>

    <span class="s0">def </span><span class="s1">update_position(self</span><span class="s0">, </span><span class="s1">loc):</span>
        <span class="s1">super().update_position(loc)</span>
        <span class="s1">axes = self.axes</span>
        <span class="s1">angle = loc * axes.get_theta_direction() + axes.get_theta_offset()</span>
        <span class="s1">text_angle = np.rad2deg(angle) % </span><span class="s3">360 </span><span class="s1">- </span><span class="s3">90</span>
        <span class="s1">angle -= np.pi / </span><span class="s3">2</span>

        <span class="s1">marker = self.tick1line.get_marker()</span>
        <span class="s0">if </span><span class="s1">marker </span><span class="s0">in </span><span class="s1">(mmarkers.TICKUP</span><span class="s0">, </span><span class="s4">'|'</span><span class="s1">):</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).rotate(angle)</span>
        <span class="s0">elif </span><span class="s1">marker == mmarkers.TICKDOWN:</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">).rotate(angle)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Don't modify custom tick line markers.</span>
            <span class="s1">trans = self.tick1line._marker._transform</span>
        <span class="s1">self.tick1line._marker._transform = trans</span>

        <span class="s1">marker = self.tick2line.get_marker()</span>
        <span class="s0">if </span><span class="s1">marker </span><span class="s0">in </span><span class="s1">(mmarkers.TICKUP</span><span class="s0">, </span><span class="s4">'|'</span><span class="s1">):</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).rotate(angle)</span>
        <span class="s0">elif </span><span class="s1">marker == mmarkers.TICKDOWN:</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">).rotate(angle)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Don't modify custom tick line markers.</span>
            <span class="s1">trans = self.tick2line._marker._transform</span>
        <span class="s1">self.tick2line._marker._transform = trans</span>

        <span class="s1">mode</span><span class="s0">, </span><span class="s1">user_angle = self._labelrotation</span>
        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">'default'</span><span class="s1">:</span>
            <span class="s1">text_angle = user_angle</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">text_angle &gt; </span><span class="s3">90</span><span class="s1">:</span>
                <span class="s1">text_angle -= </span><span class="s3">180</span>
            <span class="s0">elif </span><span class="s1">text_angle &lt; -</span><span class="s3">90</span><span class="s1">:</span>
                <span class="s1">text_angle += </span><span class="s3">180</span>
            <span class="s1">text_angle += user_angle</span>
        <span class="s1">self.label1.set_rotation(text_angle)</span>
        <span class="s1">self.label2.set_rotation(text_angle)</span>

        <span class="s5"># This extra padding helps preserve the look from previous releases but</span>
        <span class="s5"># is also needed because labels are anchored to their center.</span>
        <span class="s1">pad = self._pad + </span><span class="s3">7</span>
        <span class="s1">self._update_padding(pad</span><span class="s0">,</span>
                             <span class="s1">self._loc * axes.get_theta_direction() +</span>
                             <span class="s1">axes.get_theta_offset())</span>


<span class="s0">class </span><span class="s1">ThetaAxis(maxis.XAxis):</span>
    <span class="s2">&quot;&quot;&quot; 
    A theta Axis. 
 
    This overrides certain properties of an `.XAxis` to provide special-casing 
    for an angular axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">__name__ = </span><span class="s4">'thetaaxis'</span>
    <span class="s1">axis_name = </span><span class="s4">'theta'  </span><span class="s5">#: Read-only name identifying the axis.</span>
    <span class="s1">_tick_class = ThetaTick</span>

    <span class="s0">def </span><span class="s1">_wrap_locator_formatter(self):</span>
        <span class="s1">self.set_major_locator(ThetaLocator(self.get_major_locator()))</span>
        <span class="s1">self.set_major_formatter(ThetaFormatter())</span>
        <span class="s1">self.isDefault_majloc = </span><span class="s0">True</span>
        <span class="s1">self.isDefault_majfmt = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().clear()</span>
        <span class="s1">self.set_ticks_position(</span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">self._wrap_locator_formatter()</span>

    <span class="s0">def </span><span class="s1">_set_scale(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">value != </span><span class="s4">'linear'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">&quot;The xscale cannot be set on a polar plot&quot;</span><span class="s1">)</span>
        <span class="s1">super()._set_scale(value</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s5"># LinearScale.set_default_locators_and_formatters just set the major</span>
        <span class="s5"># locator to be an AutoLocator, so we customize it here to have ticks</span>
        <span class="s5"># at sensible degree multiples.</span>
        <span class="s1">self.get_major_locator().set_params(steps=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4.5</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">])</span>
        <span class="s1">self._wrap_locator_formatter()</span>

    <span class="s0">def </span><span class="s1">_copy_tick_props(self</span><span class="s0">, </span><span class="s1">src</span><span class="s0">, </span><span class="s1">dest):</span>
        <span class="s2">&quot;&quot;&quot;Copy the props from src tick to dest tick.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">src </span><span class="s0">is None or </span><span class="s1">dest </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s1">super()._copy_tick_props(src</span><span class="s0">, </span><span class="s1">dest)</span>

        <span class="s5"># Ensure that tick transforms are independent so that padding works.</span>
        <span class="s1">trans = dest._get_text1_transform()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">dest.label1.set_transform(trans + dest._text1_translate)</span>
        <span class="s1">trans = dest._get_text2_transform()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">dest.label2.set_transform(trans + dest._text2_translate)</span>


<span class="s0">class </span><span class="s1">RadialLocator(mticker.Locator):</span>
    <span class="s2">&quot;&quot;&quot; 
    Used to locate radius ticks. 
 
    Ensures that all ticks are strictly positive.  For all other tasks, it 
    delegates to the base `.Locator` (which may be different depending on the 
    scale of the *r*-axis). 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self._axes = axes</span>

    <span class="s0">def </span><span class="s1">set_axis(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">self.base.set_axis(axis)</span>

    <span class="s0">def </span><span class="s1">__call__(self):</span>
        <span class="s5"># Ensure previous behaviour with full circle non-annular views.</span>
        <span class="s0">if </span><span class="s1">self._axes:</span>
            <span class="s0">if </span><span class="s1">_is_full_circle_rad(*self._axes.viewLim.intervalx):</span>
                <span class="s1">rorigin = self._axes.get_rorigin() * self._axes.get_rsign()</span>
                <span class="s0">if </span><span class="s1">self._axes.get_rmin() &lt;= rorigin:</span>
                    <span class="s0">return </span><span class="s1">[tick </span><span class="s0">for </span><span class="s1">tick </span><span class="s0">in </span><span class="s1">self.base() </span><span class="s0">if </span><span class="s1">tick &gt; rorigin]</span>
        <span class="s0">return </span><span class="s1">self.base()</span>

    <span class="s0">def </span><span class="s1">_zero_in_bounds(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return True if zero is within the valid values for the 
        scale of the radial axis. 
        &quot;&quot;&quot;</span>
        <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self._axes.yaxis._scale.limit_range_for_scale(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1e-5</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">vmin == </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">nonsingular(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">self._zero_in_bounds() </span><span class="s0">and </span><span class="s1">(vmin</span><span class="s0">, </span><span class="s1">vmax) == (-np.inf</span><span class="s0">, </span><span class="s1">np.inf):</span>
            <span class="s5"># Initial view limits</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.base.nonsingular(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>

    <span class="s0">def </span><span class="s1">view_limits(self</span><span class="s0">, </span><span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax):</span>
        <span class="s1">vmin</span><span class="s0">, </span><span class="s1">vmax = self.base.view_limits(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>
        <span class="s0">if </span><span class="s1">self._zero_in_bounds() </span><span class="s0">and </span><span class="s1">vmax &gt; vmin:</span>
            <span class="s5"># this allows inverted r/y-lims</span>
            <span class="s1">vmin = min(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">vmin)</span>
        <span class="s0">return </span><span class="s1">mtransforms.nonsingular(vmin</span><span class="s0">, </span><span class="s1">vmax)</span>


<span class="s0">class </span><span class="s1">_ThetaShift(mtransforms.ScaledTranslation):</span>
    <span class="s2">&quot;&quot;&quot; 
    Apply a padding shift based on axes theta limits. 
 
    This is used to create padding for radial ticks. 
 
    Parameters 
    ---------- 
    axes : `~matplotlib.axes.Axes` 
        The owning axes; used to determine limits. 
    pad : float 
        The padding to apply, in points. 
    mode : {'min', 'max', 'rlabel'} 
        Whether to shift away from the start (``'min'``) or the end (``'max'``) 
        of the axes, or using the rlabel position (``'rlabel'``). 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s1">mode):</span>
        <span class="s1">super().__init__(pad</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s1">axes.figure.dpi_scale_trans)</span>
        <span class="s1">self.set_children(axes._realViewLim)</span>
        <span class="s1">self.axes = axes</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self.pad = pad</span>

    <span class="s1">__str__ = mtransforms._make_str_method(</span><span class="s4">&quot;axes&quot;</span><span class="s0">, </span><span class="s4">&quot;pad&quot;</span><span class="s0">, </span><span class="s4">&quot;mode&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_matrix(self):</span>
        <span class="s0">if </span><span class="s1">self._invalid:</span>
            <span class="s0">if </span><span class="s1">self.mode == </span><span class="s4">'rlabel'</span><span class="s1">:</span>
                <span class="s1">angle = (</span>
                    <span class="s1">np.deg2rad(self.axes.get_rlabel_position()) *</span>
                    <span class="s1">self.axes.get_theta_direction() +</span>
                    <span class="s1">self.axes.get_theta_offset()</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">self.mode == </span><span class="s4">'min'</span><span class="s1">:</span>
                    <span class="s1">angle = self.axes._realViewLim.xmin</span>
                <span class="s0">elif </span><span class="s1">self.mode == </span><span class="s4">'max'</span><span class="s1">:</span>
                    <span class="s1">angle = self.axes._realViewLim.xmax</span>

            <span class="s0">if </span><span class="s1">self.mode </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'rlabel'</span><span class="s0">, </span><span class="s4">'min'</span><span class="s1">):</span>
                <span class="s1">padx = np.cos(angle - np.pi / </span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">pady = np.sin(angle - np.pi / </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">padx = np.cos(angle + np.pi / </span><span class="s3">2</span><span class="s1">)</span>
                <span class="s1">pady = np.sin(angle + np.pi / </span><span class="s3">2</span><span class="s1">)</span>

            <span class="s1">self._t = (self.pad * padx / </span><span class="s3">72</span><span class="s0">, </span><span class="s1">self.pad * pady / </span><span class="s3">72</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">super().get_matrix()</span>


<span class="s0">class </span><span class="s1">RadialTick(maxis.YTick):</span>
    <span class="s2">&quot;&quot;&quot; 
    A radial-axis tick. 
 
    This subclass of `.YTick` provides radial ticks with some small 
    modification to their re-positioning such that ticks are rotated based on 
    axes limits.  This results in ticks that are correctly perpendicular to 
    the spine. Labels are also rotated to be perpendicular to the spine, when 
    'auto' rotation is enabled. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.label1.set_rotation_mode(</span><span class="s4">'anchor'</span><span class="s1">)</span>
        <span class="s1">self.label2.set_rotation_mode(</span><span class="s4">'anchor'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_determine_anchor(self</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">start):</span>
        <span class="s5"># Note: angle is the (spine angle - 90) because it's used for the tick</span>
        <span class="s5"># &amp; text setup, so all numbers below are -90 from (normed) spine angle.</span>
        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">'auto'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">start:</span>
                <span class="s0">if </span><span class="s1">-</span><span class="s3">90 </span><span class="s1">&lt;= angle &lt;= </span><span class="s3">90</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'center'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">-</span><span class="s3">90 </span><span class="s1">&lt;= angle &lt;= </span><span class="s3">90</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'center'</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">start:</span>
                <span class="s0">if </span><span class="s1">angle &lt; -</span><span class="s3">68.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; -</span><span class="s3">23.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">22.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">67.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">112.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">157.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">202.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">247.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'top'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">angle &lt; -</span><span class="s3">68.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; -</span><span class="s3">23.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">22.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">67.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">112.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">157.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'top'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">202.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'center'</span>
                <span class="s0">elif </span><span class="s1">angle &lt; </span><span class="s3">247.5</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'bottom'</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'bottom'</span>

    <span class="s0">def </span><span class="s1">update_position(self</span><span class="s0">, </span><span class="s1">loc):</span>
        <span class="s1">super().update_position(loc)</span>
        <span class="s1">axes = self.axes</span>
        <span class="s1">thetamin = axes.get_thetamin()</span>
        <span class="s1">thetamax = axes.get_thetamax()</span>
        <span class="s1">direction = axes.get_theta_direction()</span>
        <span class="s1">offset_rad = axes.get_theta_offset()</span>
        <span class="s1">offset = np.rad2deg(offset_rad)</span>
        <span class="s1">full = _is_full_circle_deg(thetamin</span><span class="s0">, </span><span class="s1">thetamax)</span>

        <span class="s0">if </span><span class="s1">full:</span>
            <span class="s1">angle = (axes.get_rlabel_position() * direction +</span>
                     <span class="s1">offset) % </span><span class="s3">360 </span><span class="s1">- </span><span class="s3">90</span>
            <span class="s1">tick_angle = </span><span class="s3">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">angle = (thetamin * direction + offset) % </span><span class="s3">360 </span><span class="s1">- </span><span class="s3">90</span>
            <span class="s0">if </span><span class="s1">direction &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">tick_angle = np.deg2rad(angle)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">tick_angle = np.deg2rad(angle + </span><span class="s3">180</span><span class="s1">)</span>
        <span class="s1">text_angle = (angle + </span><span class="s3">90</span><span class="s1">) % </span><span class="s3">180 </span><span class="s1">- </span><span class="s3">90  </span><span class="s5"># between -90 and +90.</span>
        <span class="s1">mode</span><span class="s0">, </span><span class="s1">user_angle = self._labelrotation</span>
        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">'auto'</span><span class="s1">:</span>
            <span class="s1">text_angle += user_angle</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">text_angle = user_angle</span>

        <span class="s0">if </span><span class="s1">full:</span>
            <span class="s1">ha = self.label1.get_horizontalalignment()</span>
            <span class="s1">va = self.label1.get_verticalalignment()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ha</span><span class="s0">, </span><span class="s1">va = self._determine_anchor(mode</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">direction &gt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.label1.set_horizontalalignment(ha)</span>
        <span class="s1">self.label1.set_verticalalignment(va)</span>
        <span class="s1">self.label1.set_rotation(text_angle)</span>

        <span class="s1">marker = self.tick1line.get_marker()</span>
        <span class="s0">if </span><span class="s1">marker == mmarkers.TICKLEFT:</span>
            <span class="s1">trans = mtransforms.Affine2D().rotate(tick_angle)</span>
        <span class="s0">elif </span><span class="s1">marker == </span><span class="s4">'_'</span><span class="s1">:</span>
            <span class="s1">trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">marker == mmarkers.TICKRIGHT:</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).rotate(tick_angle)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Don't modify custom tick line markers.</span>
            <span class="s1">trans = self.tick1line._marker._transform</span>
        <span class="s1">self.tick1line._marker._transform = trans</span>

        <span class="s0">if </span><span class="s1">full:</span>
            <span class="s1">self.label2.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">self.tick2line.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">angle = (thetamax * direction + offset) % </span><span class="s3">360 </span><span class="s1">- </span><span class="s3">90</span>
        <span class="s0">if </span><span class="s1">direction &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">tick_angle = np.deg2rad(angle)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tick_angle = np.deg2rad(angle + </span><span class="s3">180</span><span class="s1">)</span>
        <span class="s1">text_angle = (angle + </span><span class="s3">90</span><span class="s1">) % </span><span class="s3">180 </span><span class="s1">- </span><span class="s3">90  </span><span class="s5"># between -90 and +90.</span>
        <span class="s1">mode</span><span class="s0">, </span><span class="s1">user_angle = self._labelrotation</span>
        <span class="s0">if </span><span class="s1">mode == </span><span class="s4">'auto'</span><span class="s1">:</span>
            <span class="s1">text_angle += user_angle</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">text_angle = user_angle</span>

        <span class="s1">ha</span><span class="s0">, </span><span class="s1">va = self._determine_anchor(mode</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">direction &lt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.label2.set_ha(ha)</span>
        <span class="s1">self.label2.set_va(va)</span>
        <span class="s1">self.label2.set_rotation(text_angle)</span>

        <span class="s1">marker = self.tick2line.get_marker()</span>
        <span class="s0">if </span><span class="s1">marker == mmarkers.TICKLEFT:</span>
            <span class="s1">trans = mtransforms.Affine2D().rotate(tick_angle)</span>
        <span class="s0">elif </span><span class="s1">marker == </span><span class="s4">'_'</span><span class="s1">:</span>
            <span class="s1">trans = mtransforms.Affine2D().rotate(tick_angle + np.pi / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">marker == mmarkers.TICKRIGHT:</span>
            <span class="s1">trans = mtransforms.Affine2D().scale(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).rotate(tick_angle)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Don't modify custom tick line markers.</span>
            <span class="s1">trans = self.tick2line._marker._transform</span>
        <span class="s1">self.tick2line._marker._transform = trans</span>


<span class="s0">class </span><span class="s1">RadialAxis(maxis.YAxis):</span>
    <span class="s2">&quot;&quot;&quot; 
    A radial Axis. 
 
    This overrides certain properties of a `.YAxis` to provide special-casing 
    for a radial axis. 
    &quot;&quot;&quot;</span>
    <span class="s1">__name__ = </span><span class="s4">'radialaxis'</span>
    <span class="s1">axis_name = </span><span class="s4">'radius'  </span><span class="s5">#: Read-only name identifying the axis.</span>
    <span class="s1">_tick_class = RadialTick</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.sticky_edges.y.append(</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_wrap_locator_formatter(self):</span>
        <span class="s1">self.set_major_locator(RadialLocator(self.get_major_locator()</span><span class="s0">,</span>
                                             <span class="s1">self.axes))</span>
        <span class="s1">self.isDefault_majloc = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().clear()</span>
        <span class="s1">self.set_ticks_position(</span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">self._wrap_locator_formatter()</span>

    <span class="s0">def </span><span class="s1">_set_scale(self</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super()._set_scale(value</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._wrap_locator_formatter()</span>


<span class="s0">def </span><span class="s1">_is_full_circle_deg(thetamin</span><span class="s0">, </span><span class="s1">thetamax):</span>
    <span class="s2">&quot;&quot;&quot; 
    Determine if a wedge (in degrees) spans the full circle. 
 
    The condition is derived from :class:`~matplotlib.patches.Wedge`. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">abs(abs(thetamax - thetamin) - </span><span class="s3">360.0</span><span class="s1">) &lt; </span><span class="s3">1e-12</span>


<span class="s0">def </span><span class="s1">_is_full_circle_rad(thetamin</span><span class="s0">, </span><span class="s1">thetamax):</span>
    <span class="s2">&quot;&quot;&quot; 
    Determine if a wedge (in radians) spans the full circle. 
 
    The condition is derived from :class:`~matplotlib.patches.Wedge`. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">abs(abs(thetamax - thetamin) - </span><span class="s3">2 </span><span class="s1">* np.pi) &lt; </span><span class="s3">1.74e-14</span>


<span class="s0">class </span><span class="s1">_WedgeBbox(mtransforms.Bbox):</span>
    <span class="s2">&quot;&quot;&quot; 
    Transform (theta, r) wedge Bbox into axes bounding box. 
 
    Parameters 
    ---------- 
    center : (float, float) 
        Center of the wedge 
    viewLim : `~matplotlib.transforms.Bbox` 
        Bbox determining the boundaries of the wedge 
    originLim : `~matplotlib.transforms.Bbox` 
        Bbox determining the origin for the wedge, if different from *viewLim* 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">viewLim</span><span class="s0">, </span><span class="s1">originLim</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._center = center</span>
        <span class="s1">self._viewLim = viewLim</span>
        <span class="s1">self._originLim = originLim</span>
        <span class="s1">self.set_children(viewLim</span><span class="s0">, </span><span class="s1">originLim)</span>

    <span class="s1">__str__ = mtransforms._make_str_method(</span><span class="s4">&quot;_center&quot;</span><span class="s0">, </span><span class="s4">&quot;_viewLim&quot;</span><span class="s0">, </span><span class="s4">&quot;_originLim&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_points(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">self._invalid:</span>
            <span class="s1">points = self._viewLim.get_points().copy()</span>
            <span class="s5"># Scale angular limits to work with Wedge.</span>
            <span class="s1">points[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] *= </span><span class="s3">180 </span><span class="s1">/ np.pi</span>
            <span class="s0">if </span><span class="s1">points[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] &gt; points[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]:</span>
                <span class="s1">points[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = points[::-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>

            <span class="s5"># Scale radial limits based on origin radius.</span>
            <span class="s1">points[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] -= self._originLim.y0</span>

            <span class="s5"># Scale radial limits to match axes limits.</span>
            <span class="s1">rscale = </span><span class="s3">0.5 </span><span class="s1">/ points[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">points[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] *= rscale</span>
            <span class="s1">width = min(points[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] - points[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>

            <span class="s5"># Generate bounding box for wedge.</span>
            <span class="s1">wedge = mpatches.Wedge(self._center</span><span class="s0">, </span><span class="s1">points[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                                   <span class="s1">points[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">points[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                                   <span class="s1">width=width)</span>
            <span class="s1">self.update_from_path(wedge.get_path())</span>

            <span class="s5"># Ensure equal aspect ratio.</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">h = self._points[</span><span class="s3">1</span><span class="s1">] - self._points[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">deltah = max(w - h</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) / </span><span class="s3">2</span>
            <span class="s1">deltaw = max(h - w</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) / </span><span class="s3">2</span>
            <span class="s1">self._points += np.array([[-deltaw</span><span class="s0">, </span><span class="s1">-deltah]</span><span class="s0">, </span><span class="s1">[deltaw</span><span class="s0">, </span><span class="s1">deltah]])</span>

            <span class="s1">self._invalid = </span><span class="s3">0</span>

        <span class="s0">return </span><span class="s1">self._points</span>


<span class="s0">class </span><span class="s1">PolarAxes(Axes):</span>
    <span class="s2">&quot;&quot;&quot; 
    A polar graph projection, where the input dimensions are *theta*, *r*. 
 
    Theta starts pointing east and goes anti-clockwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s4">'polar'</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">,</span>
                 <span class="s1">theta_offset=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">theta_direction=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">rlabel_position=</span><span class="s3">22.5</span><span class="s0">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">self._default_theta_offset = theta_offset</span>
        <span class="s1">self._default_theta_direction = theta_direction</span>
        <span class="s1">self._default_rlabel_position = np.deg2rad(rlabel_position)</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.use_sticky_edges = </span><span class="s0">True</span>
        <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">self.clear()</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().clear()</span>

        <span class="s1">self.title.set_y(</span><span class="s3">1.05</span><span class="s1">)</span>

        <span class="s1">start = self.spines.get(</span><span class="s4">'start'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">start:</span>
            <span class="s1">start.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">end = self.spines.get(</span><span class="s4">'end'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">end:</span>
            <span class="s1">end.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self.set_xlim(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* np.pi)</span>

        <span class="s1">self.grid(mpl.rcParams[</span><span class="s4">'polaraxes.grid'</span><span class="s1">])</span>
        <span class="s1">inner = self.spines.get(</span><span class="s4">'inner'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">inner:</span>
            <span class="s1">inner.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">self.set_rorigin(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">self.set_theta_offset(self._default_theta_offset)</span>
        <span class="s1">self.set_theta_direction(self._default_theta_direction)</span>

    <span class="s0">def </span><span class="s1">_init_axis(self):</span>
        <span class="s5"># This is moved out of __init__ because non-separable axes don't use it</span>
        <span class="s1">self.xaxis = ThetaAxis(self)</span>
        <span class="s1">self.yaxis = RadialAxis(self)</span>
        <span class="s5"># Calling polar_axes.xaxis.clear() or polar_axes.yaxis.clear()</span>
        <span class="s5"># results in weird artifacts. Therefore we disable this for now.</span>
        <span class="s5"># self.spines['polar'].register_axis(self.yaxis)</span>

    <span class="s0">def </span><span class="s1">_set_lim_and_transforms(self):</span>
        <span class="s5"># A view limit where the minimum radius can be locked if the user</span>
        <span class="s5"># specifies an alternate origin.</span>
        <span class="s1">self._originViewLim = mtransforms.LockableBbox(self.viewLim)</span>

        <span class="s5"># Handle angular offset and direction.</span>
        <span class="s1">self._direction = mtransforms.Affine2D() \</span>
            <span class="s1">.scale(self._default_theta_direction</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span>
        <span class="s1">self._theta_offset = mtransforms.Affine2D() \</span>
            <span class="s1">.translate(self._default_theta_offset</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">self.transShift = self._direction + self._theta_offset</span>
        <span class="s5"># A view limit shifted to the correct location after accounting for</span>
        <span class="s5"># orientation and offset.</span>
        <span class="s1">self._realViewLim = mtransforms.TransformedBbox(self.viewLim</span><span class="s0">,</span>
                                                        <span class="s1">self.transShift)</span>

        <span class="s5"># Transforms the x and y axis separately by a scale factor</span>
        <span class="s5"># It is assumed that this part will have non-linear components</span>
        <span class="s1">self.transScale = mtransforms.TransformWrapper(</span>
            <span class="s1">mtransforms.IdentityTransform())</span>

        <span class="s5"># Scale view limit into a bbox around the selected wedge. This may be</span>
        <span class="s5"># smaller than the usual unit axes rectangle if not plotting the full</span>
        <span class="s5"># circle.</span>
        <span class="s1">self.axesLim = _WedgeBbox((</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">self._realViewLim</span><span class="s0">, </span><span class="s1">self._originViewLim)</span>

        <span class="s5"># Scale the wedge to fill the axes.</span>
        <span class="s1">self.transWedge = mtransforms.BboxTransformFrom(self.axesLim)</span>

        <span class="s5"># Scale the axes to fill the figure.</span>
        <span class="s1">self.transAxes = mtransforms.BboxTransformTo(self.bbox)</span>

        <span class="s5"># A (possibly non-linear) projection on the (already scaled)</span>
        <span class="s5"># data.  This one is aware of rmin</span>
        <span class="s1">self.transProjection = self.PolarTransform(</span>
            <span class="s1">self</span><span class="s0">,</span>
            <span class="s1">_apply_theta_transforms=</span><span class="s0">False,</span>
            <span class="s1">scale_transform=self.transScale</span>
        <span class="s1">)</span>
        <span class="s5"># Add dependency on rorigin.</span>
        <span class="s1">self.transProjection.set_children(self._originViewLim)</span>

        <span class="s5"># An affine transformation on the data, generally to limit the</span>
        <span class="s5"># range of the axes</span>
        <span class="s1">self.transProjectionAffine = self.PolarAffine(self.transScale</span><span class="s0">,</span>
                                                      <span class="s1">self._originViewLim)</span>

        <span class="s5"># The complete data transformation stack -- from data all the</span>
        <span class="s5"># way to display coordinates</span>
        <span class="s5">#</span>
        <span class="s5"># 1. Remove any radial axis scaling (e.g. log scaling)</span>
        <span class="s5"># 2. Shift data in the theta direction</span>
        <span class="s5"># 3. Project the data from polar to cartesian values</span>
        <span class="s5">#    (with the origin in the same place)</span>
        <span class="s5"># 4. Scale and translate the cartesian values to Axes coordinates</span>
        <span class="s5">#    (here the origin is moved to the lower left of the Axes)</span>
        <span class="s5"># 5. Move and scale to fill the Axes</span>
        <span class="s5"># 6. Convert from Axes coordinates to Figure coordinates</span>
        <span class="s1">self.transData = (</span>
            <span class="s1">self.transScale +</span>
            <span class="s1">self.transShift +</span>
            <span class="s1">self.transProjection +</span>
            <span class="s1">(</span>
                <span class="s1">self.transProjectionAffine +</span>
                <span class="s1">self.transWedge +</span>
                <span class="s1">self.transAxes</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s5"># This is the transform for theta-axis ticks.  It is</span>
        <span class="s5"># equivalent to transData, except it always puts r == 0.0 and r == 1.0</span>
        <span class="s5"># at the edge of the axis circles.</span>
        <span class="s1">self._xaxis_transform = (</span>
            <span class="s1">mtransforms.blended_transform_factory(</span>
                <span class="s1">mtransforms.IdentityTransform()</span><span class="s0">,</span>
                <span class="s1">mtransforms.BboxTransformTo(self.viewLim)) +</span>
            <span class="s1">self.transData)</span>
        <span class="s5"># The theta labels are flipped along the radius, so that text 1 is on</span>
        <span class="s5"># the outside by default. This should work the same as before.</span>
        <span class="s1">flipr_transform = mtransforms.Affine2D() \</span>
            <span class="s1">.translate(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">) \</span>
            <span class="s1">.scale(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">) \</span>
            <span class="s1">.translate(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">self._xaxis_text_transform = flipr_transform + self._xaxis_transform</span>

        <span class="s5"># This is the transform for r-axis ticks.  It scales the theta</span>
        <span class="s5"># axis so the gridlines from 0.0 to 1.0, now go from thetamin to</span>
        <span class="s5"># thetamax.</span>
        <span class="s1">self._yaxis_transform = (</span>
            <span class="s1">mtransforms.blended_transform_factory(</span>
                <span class="s1">mtransforms.BboxTransformTo(self.viewLim)</span><span class="s0">,</span>
                <span class="s1">mtransforms.IdentityTransform()) +</span>
            <span class="s1">self.transData)</span>
        <span class="s5"># The r-axis labels are put at an angle and padded in the r-direction</span>
        <span class="s1">self._r_label_position = mtransforms.Affine2D() \</span>
            <span class="s1">.translate(self._default_rlabel_position</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">self._yaxis_text_transform = mtransforms.TransformWrapper(</span>
            <span class="s1">self._r_label_position + self.transData)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'tick1'</span><span class="s0">, </span><span class="s4">'tick2'</span><span class="s0">, </span><span class="s4">'grid'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">which=which)</span>
        <span class="s0">return </span><span class="s1">self._xaxis_transform</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._xaxis_text_transform</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'center'</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._xaxis_text_transform</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'center'</span>

    <span class="s0">def </span><span class="s1">get_yaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">which </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'tick1'</span><span class="s0">, </span><span class="s4">'tick2'</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">self._yaxis_text_transform</span>
        <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'grid'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._yaxis_transform</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_api.check_in_list([</span><span class="s4">'tick1'</span><span class="s0">, </span><span class="s4">'tick2'</span><span class="s0">, </span><span class="s4">'grid'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">which=which)</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s1">thetamin</span><span class="s0">, </span><span class="s1">thetamax = self._realViewLim.intervalx</span>
        <span class="s0">if </span><span class="s1">_is_full_circle_rad(thetamin</span><span class="s0">, </span><span class="s1">thetamax):</span>
            <span class="s0">return </span><span class="s1">self._yaxis_text_transform</span><span class="s0">, </span><span class="s4">'bottom'</span><span class="s0">, </span><span class="s4">'left'</span>
        <span class="s0">elif </span><span class="s1">self.get_theta_direction() &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">halign = </span><span class="s4">'left'</span>
            <span class="s1">pad_shift = _ThetaShift(self</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s4">'min'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">halign = </span><span class="s4">'right'</span>
            <span class="s1">pad_shift = _ThetaShift(self</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s4">'max'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._yaxis_text_transform + pad_shift</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s1">halign</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">if </span><span class="s1">self.get_theta_direction() &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">halign = </span><span class="s4">'right'</span>
            <span class="s1">pad_shift = _ThetaShift(self</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s4">'max'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">halign = </span><span class="s4">'left'</span>
            <span class="s1">pad_shift = _ThetaShift(self</span><span class="s0">, </span><span class="s1">pad</span><span class="s0">, </span><span class="s4">'min'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._yaxis_text_transform + pad_shift</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s1">halign</span>

    <span class="s0">def </span><span class="s1">draw(self</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s1">self._unstale_viewLim()</span>
        <span class="s1">thetamin</span><span class="s0">, </span><span class="s1">thetamax = np.rad2deg(self._realViewLim.intervalx)</span>
        <span class="s0">if </span><span class="s1">thetamin &gt; thetamax:</span>
            <span class="s1">thetamin</span><span class="s0">, </span><span class="s1">thetamax = thetamax</span><span class="s0">, </span><span class="s1">thetamin</span>
        <span class="s1">rmin</span><span class="s0">, </span><span class="s1">rmax = ((self._realViewLim.intervaly - self.get_rorigin()) *</span>
                      <span class="s1">self.get_rsign())</span>
        <span class="s0">if </span><span class="s1">isinstance(self.patch</span><span class="s0">, </span><span class="s1">mpatches.Wedge):</span>
            <span class="s5"># Backwards-compatibility: Any subclassed Axes might override the</span>
            <span class="s5"># patch to not be the Wedge that PolarAxes uses.</span>
            <span class="s1">center = self.transWedge.transform((</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">))</span>
            <span class="s1">self.patch.set_center(center)</span>
            <span class="s1">self.patch.set_theta1(thetamin)</span>
            <span class="s1">self.patch.set_theta2(thetamax)</span>

            <span class="s1">edge</span><span class="s0">, </span><span class="s1">_ = self.transWedge.transform((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
            <span class="s1">radius = edge - center[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">width = min(radius * (rmax - rmin) / rmax</span><span class="s0">, </span><span class="s1">radius)</span>
            <span class="s1">self.patch.set_radius(radius)</span>
            <span class="s1">self.patch.set_width(width)</span>

            <span class="s1">inner_width = radius - width</span>
            <span class="s1">inner = self.spines.get(</span><span class="s4">'inner'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">inner:</span>
                <span class="s1">inner.set_visible(inner_width != </span><span class="s3">0.0</span><span class="s1">)</span>

        <span class="s1">visible = </span><span class="s0">not </span><span class="s1">_is_full_circle_deg(thetamin</span><span class="s0">, </span><span class="s1">thetamax)</span>
        <span class="s5"># For backwards compatibility, any subclassed Axes might override the</span>
        <span class="s5"># spines to not include start/end that PolarAxes uses.</span>
        <span class="s1">start = self.spines.get(</span><span class="s4">'start'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">end = self.spines.get(</span><span class="s4">'end'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">start:</span>
            <span class="s1">start.set_visible(visible)</span>
        <span class="s0">if </span><span class="s1">end:</span>
            <span class="s1">end.set_visible(visible)</span>
        <span class="s0">if </span><span class="s1">visible:</span>
            <span class="s1">yaxis_text_transform = self._yaxis_transform</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">yaxis_text_transform = self._r_label_position + self.transData</span>
        <span class="s0">if </span><span class="s1">self._yaxis_text_transform != yaxis_text_transform:</span>
            <span class="s1">self._yaxis_text_transform.set(yaxis_text_transform)</span>
            <span class="s1">self.yaxis.reset_ticks()</span>
            <span class="s1">self.yaxis.set_clip_path(self.patch)</span>

        <span class="s1">super().draw(renderer)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_patch(self):</span>
        <span class="s0">return </span><span class="s1">mpatches.Wedge((</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">360.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_spines(self):</span>
        <span class="s1">spines = {</span>
            <span class="s4">'polar'</span><span class="s1">: Spine.arc_spine(self</span><span class="s0">, </span><span class="s4">'top'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">360</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">'start'</span><span class="s1">: Spine.linear_spine(self</span><span class="s0">, </span><span class="s4">'left'</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">'end'</span><span class="s1">: Spine.linear_spine(self</span><span class="s0">, </span><span class="s4">'right'</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s4">'inner'</span><span class="s1">: Spine.arc_spine(self</span><span class="s0">, </span><span class="s4">'bottom'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">360</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">spines[</span><span class="s4">'polar'</span><span class="s1">].set_transform(self.transWedge + self.transAxes)</span>
        <span class="s1">spines[</span><span class="s4">'inner'</span><span class="s1">].set_transform(self.transWedge + self.transAxes)</span>
        <span class="s1">spines[</span><span class="s4">'start'</span><span class="s1">].set_transform(self._yaxis_transform)</span>
        <span class="s1">spines[</span><span class="s4">'end'</span><span class="s1">].set_transform(self._yaxis_transform)</span>
        <span class="s0">return </span><span class="s1">spines</span>

    <span class="s0">def </span><span class="s1">set_thetamax(self</span><span class="s0">, </span><span class="s1">thetamax):</span>
        <span class="s2">&quot;&quot;&quot;Set the maximum theta limit in degrees.&quot;&quot;&quot;</span>
        <span class="s1">self.viewLim.x1 = np.deg2rad(thetamax)</span>

    <span class="s0">def </span><span class="s1">get_thetamax(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the maximum theta limit in degrees.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self.viewLim.xmax)</span>

    <span class="s0">def </span><span class="s1">set_thetamin(self</span><span class="s0">, </span><span class="s1">thetamin):</span>
        <span class="s2">&quot;&quot;&quot;Set the minimum theta limit in degrees.&quot;&quot;&quot;</span>
        <span class="s1">self.viewLim.x0 = np.deg2rad(thetamin)</span>

    <span class="s0">def </span><span class="s1">get_thetamin(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the minimum theta limit in degrees.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self.viewLim.xmin)</span>

    <span class="s0">def </span><span class="s1">set_thetalim(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">r&quot;&quot;&quot; 
        Set the minimum and maximum theta values. 
 
        Can take the following signatures: 
 
        - ``set_thetalim(minval, maxval)``: Set the limits in radians. 
        - ``set_thetalim(thetamin=minval, thetamax=maxval)``: Set the limits 
          in degrees. 
 
        where minval and maxval are the minimum and maximum limits. Values are 
        wrapped in to the range :math:`[0, 2\pi]` (in radians), so for example 
        it is possible to do ``set_thetalim(-np.pi / 2, np.pi / 2)`` to have 
        an axis symmetric around 0. A ValueError is raised if the absolute 
        angle difference is larger than a full circle. 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_lim = self.get_xlim()  </span><span class="s5"># in radians</span>
        <span class="s0">if </span><span class="s4">'thetamin' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s4">'xmin'</span><span class="s1">] = np.deg2rad(kwargs.pop(</span><span class="s4">'thetamin'</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s4">'thetamax' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s4">'xmax'</span><span class="s1">] = np.deg2rad(kwargs.pop(</span><span class="s4">'thetamax'</span><span class="s1">))</span>
        <span class="s1">new_min</span><span class="s0">, </span><span class="s1">new_max = self.set_xlim(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s5"># Parsing all permutations of *args, **kwargs is tricky; it is simpler</span>
        <span class="s5"># to let set_xlim() do it and then validate the limits.</span>
        <span class="s0">if </span><span class="s1">abs(new_max - new_min) &gt; </span><span class="s3">2 </span><span class="s1">* np.pi:</span>
            <span class="s1">self.set_xlim(orig_lim)  </span><span class="s5"># un-accept the change</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The angle range must be less than a full circle&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">tuple(np.rad2deg((new_min</span><span class="s0">, </span><span class="s1">new_max)))</span>

    <span class="s0">def </span><span class="s1">set_theta_offset(self</span><span class="s0">, </span><span class="s1">offset):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the offset for the location of 0 in radians. 
        &quot;&quot;&quot;</span>
        <span class="s1">mtx = self._theta_offset.get_matrix()</span>
        <span class="s1">mtx[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">] = offset</span>
        <span class="s1">self._theta_offset.invalidate()</span>

    <span class="s0">def </span><span class="s1">get_theta_offset(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the offset for the location of 0 in radians. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._theta_offset.get_matrix()[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">set_theta_zero_location(self</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">offset=</span><span class="s3">0.0</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the location of theta's zero. 
 
        This simply calls `set_theta_offset` with the correct value in radians. 
 
        Parameters 
        ---------- 
        loc : str 
            May be one of &quot;N&quot;, &quot;NW&quot;, &quot;W&quot;, &quot;SW&quot;, &quot;S&quot;, &quot;SE&quot;, &quot;E&quot;, or &quot;NE&quot;. 
        offset : float, default: 0 
            An offset in degrees to apply from the specified *loc*. **Note:** 
            this offset is *always* applied counter-clockwise regardless of 
            the direction setting. 
        &quot;&quot;&quot;</span>
        <span class="s1">mapping = {</span>
            <span class="s4">'N'</span><span class="s1">: np.pi * </span><span class="s3">0.5</span><span class="s0">,</span>
            <span class="s4">'NW'</span><span class="s1">: np.pi * </span><span class="s3">0.75</span><span class="s0">,</span>
            <span class="s4">'W'</span><span class="s1">: np.pi</span><span class="s0">,</span>
            <span class="s4">'SW'</span><span class="s1">: np.pi * </span><span class="s3">1.25</span><span class="s0">,</span>
            <span class="s4">'S'</span><span class="s1">: np.pi * </span><span class="s3">1.5</span><span class="s0">,</span>
            <span class="s4">'SE'</span><span class="s1">: np.pi * </span><span class="s3">1.75</span><span class="s0">,</span>
            <span class="s4">'E'</span><span class="s1">: </span><span class="s3">0</span><span class="s0">,</span>
            <span class="s4">'NE'</span><span class="s1">: np.pi * </span><span class="s3">0.25</span><span class="s1">}</span>
        <span class="s0">return </span><span class="s1">self.set_theta_offset(mapping[loc] + np.deg2rad(offset))</span>

    <span class="s0">def </span><span class="s1">set_theta_direction(self</span><span class="s0">, </span><span class="s1">direction):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the direction in which theta increases. 
 
        clockwise, -1: 
           Theta increases in the clockwise direction 
 
        counterclockwise, anticlockwise, 1: 
           Theta increases in the counterclockwise direction 
        &quot;&quot;&quot;</span>
        <span class="s1">mtx = self._direction.get_matrix()</span>
        <span class="s0">if </span><span class="s1">direction </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'clockwise'</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">mtx[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = -</span><span class="s3">1</span>
        <span class="s0">elif </span><span class="s1">direction </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'counterclockwise'</span><span class="s0">, </span><span class="s4">'anticlockwise'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">mtx[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_api.check_in_list(</span>
                <span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s4">'clockwise'</span><span class="s0">, </span><span class="s4">'counterclockwise'</span><span class="s0">, </span><span class="s4">'anticlockwise'</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">direction=direction)</span>
        <span class="s1">self._direction.invalidate()</span>

    <span class="s0">def </span><span class="s1">get_theta_direction(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the direction in which theta increases. 
 
        -1: 
           Theta increases in the clockwise direction 
 
        1: 
           Theta increases in the counterclockwise direction 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._direction.get_matrix()[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">set_rmax(self</span><span class="s0">, </span><span class="s1">rmax):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the outer radial limit. 
 
        Parameters 
        ---------- 
        rmax : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.viewLim.y1 = rmax</span>

    <span class="s0">def </span><span class="s1">get_rmax(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        float 
            Outer radial limit. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.viewLim.ymax</span>

    <span class="s0">def </span><span class="s1">set_rmin(self</span><span class="s0">, </span><span class="s1">rmin):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the inner radial limit. 
 
        Parameters 
        ---------- 
        rmin : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.viewLim.y0 = rmin</span>

    <span class="s0">def </span><span class="s1">get_rmin(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        float 
            The inner radial limit. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.viewLim.ymin</span>

    <span class="s0">def </span><span class="s1">set_rorigin(self</span><span class="s0">, </span><span class="s1">rorigin):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update the radial origin. 
 
        Parameters 
        ---------- 
        rorigin : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._originViewLim.locked_y0 = rorigin</span>

    <span class="s0">def </span><span class="s1">get_rorigin(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        float 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._originViewLim.y0</span>

    <span class="s0">def </span><span class="s1">get_rsign(self):</span>
        <span class="s0">return </span><span class="s1">np.sign(self._originViewLim.y1 - self._originViewLim.y0)</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s4">&quot;emit&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_rlim(self</span><span class="s0">, </span><span class="s1">bottom=</span><span class="s0">None, </span><span class="s1">top=</span><span class="s0">None, </span><span class="s1">emit=</span><span class="s0">True, </span><span class="s1">auto=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the radial axis view limits. 
 
        This function behaves like `.Axes.set_ylim`, but additionally supports 
        *rmin* and *rmax* as aliases for *bottom* and *top*. 
 
        See Also 
        -------- 
        .Axes.set_ylim 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">'rmin' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s0">if </span><span class="s1">bottom </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">bottom = kwargs.pop(</span><span class="s4">'rmin'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot supply both positional &quot;bottom&quot;'</span>
                                 <span class="s4">'argument and kwarg &quot;rmin&quot;'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s4">'rmax' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s0">if </span><span class="s1">top </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">top = kwargs.pop(</span><span class="s4">'rmax'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot supply both positional &quot;top&quot;'</span>
                                 <span class="s4">'argument and kwarg &quot;rmax&quot;'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.set_ylim(bottom=bottom</span><span class="s0">, </span><span class="s1">top=top</span><span class="s0">, </span><span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=auto</span><span class="s0">,</span>
                             <span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">get_rlabel_position(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        float 
            The theta position of the radius labels in degrees. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">np.rad2deg(self._r_label_position.get_matrix()[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">set_rlabel_position(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update the theta position of the radius labels. 
 
        Parameters 
        ---------- 
        value : number 
            The angular position of the radius labels in degrees. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._r_label_position.clear().translate(np.deg2rad(value)</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_yscale(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().set_yscale(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.yaxis.set_major_locator(</span>
            <span class="s1">self.RadialLocator(self.yaxis.get_major_locator()</span><span class="s0">, </span><span class="s1">self))</span>

    <span class="s0">def </span><span class="s1">set_rscale(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">Axes.set_yscale(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">set_rticks(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">return </span><span class="s1">Axes.set_yticks(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">set_thetagrids(self</span><span class="s0">, </span><span class="s1">angles</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">None, </span><span class="s1">fmt=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the theta gridlines in a polar plot. 
 
        Parameters 
        ---------- 
        angles : tuple with floats, degrees 
            The angles of the theta gridlines. 
 
        labels : tuple with strings or None 
            The labels to use at each theta gridline. The 
            `.projections.polar.ThetaFormatter` will be used if None. 
 
        fmt : str or None 
            Format string used in `matplotlib.ticker.FormatStrFormatter`. 
            For example '%f'. Note that the angle that is used is in 
            radians. 
 
        Returns 
        ------- 
        lines : list of `.lines.Line2D` 
            The theta gridlines. 
 
        labels : list of `.text.Text` 
            The tick labels. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            *kwargs* are optional `.Text` properties for the labels. 
 
        See Also 
        -------- 
        .PolarAxes.set_rgrids 
        .Axis.get_gridlines 
        .Axis.get_ticklabels 
        &quot;&quot;&quot;</span>

        <span class="s5"># Make sure we take into account unitized data</span>
        <span class="s1">angles = self.convert_yunits(angles)</span>
        <span class="s1">angles = np.deg2rad(angles)</span>
        <span class="s1">self.set_xticks(angles)</span>
        <span class="s0">if </span><span class="s1">labels </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_xticklabels(labels)</span>
        <span class="s0">elif </span><span class="s1">fmt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.xaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.xaxis.get_ticklabels():</span>
            <span class="s1">t._internal_update(kwargs)</span>
        <span class="s0">return </span><span class="s1">self.xaxis.get_ticklines()</span><span class="s0">, </span><span class="s1">self.xaxis.get_ticklabels()</span>

    <span class="s0">def </span><span class="s1">set_rgrids(self</span><span class="s0">, </span><span class="s1">radii</span><span class="s0">, </span><span class="s1">labels=</span><span class="s0">None, </span><span class="s1">angle=</span><span class="s0">None, </span><span class="s1">fmt=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the radial gridlines on a polar plot. 
 
        Parameters 
        ---------- 
        radii : tuple with floats 
            The radii for the radial gridlines 
 
        labels : tuple with strings or None 
            The labels to use at each radial gridline. The 
            `matplotlib.ticker.ScalarFormatter` will be used if None. 
 
        angle : float 
            The angular position of the radius labels in degrees. 
 
        fmt : str or None 
            Format string used in `matplotlib.ticker.FormatStrFormatter`. 
            For example '%f'. 
 
        Returns 
        ------- 
        lines : list of `.lines.Line2D` 
            The radial gridlines. 
 
        labels : list of `.text.Text` 
            The tick labels. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            *kwargs* are optional `.Text` properties for the labels. 
 
        See Also 
        -------- 
        .PolarAxes.set_thetagrids 
        .Axis.get_gridlines 
        .Axis.get_ticklabels 
        &quot;&quot;&quot;</span>
        <span class="s5"># Make sure we take into account unitized data</span>
        <span class="s1">radii = self.convert_xunits(radii)</span>
        <span class="s1">radii = np.asarray(radii)</span>

        <span class="s1">self.set_yticks(radii)</span>
        <span class="s0">if </span><span class="s1">labels </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_yticklabels(labels)</span>
        <span class="s0">elif </span><span class="s1">fmt </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.yaxis.set_major_formatter(mticker.FormatStrFormatter(fmt))</span>
        <span class="s0">if </span><span class="s1">angle </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">angle = self.get_rlabel_position()</span>
        <span class="s1">self.set_rlabel_position(angle)</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.yaxis.get_ticklabels():</span>
            <span class="s1">t._internal_update(kwargs)</span>
        <span class="s0">return </span><span class="s1">self.yaxis.get_gridlines()</span><span class="s0">, </span><span class="s1">self.yaxis.get_ticklabels()</span>

    <span class="s0">def </span><span class="s1">format_coord(self</span><span class="s0">, </span><span class="s1">theta</span><span class="s0">, </span><span class="s1">r):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">screen_xy = self.transData.transform((theta</span><span class="s0">, </span><span class="s1">r))</span>
        <span class="s1">screen_xys = screen_xy + np.stack(</span>
            <span class="s1">np.meshgrid([-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)).T</span>
        <span class="s1">ts</span><span class="s0">, </span><span class="s1">rs = self.transData.inverted().transform(screen_xys).T</span>
        <span class="s1">delta_t = abs((ts - theta + np.pi) % (</span><span class="s3">2 </span><span class="s1">* np.pi) - np.pi).max()</span>
        <span class="s1">delta_t_halfturns = delta_t / np.pi</span>
        <span class="s1">delta_t_degrees = delta_t_halfturns * </span><span class="s3">180</span>
        <span class="s1">delta_r = abs(rs - r).max()</span>
        <span class="s0">if </span><span class="s1">theta &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">theta += </span><span class="s3">2 </span><span class="s1">* np.pi</span>
        <span class="s1">theta_halfturns = theta / np.pi</span>
        <span class="s1">theta_degrees = theta_halfturns * </span><span class="s3">180</span>

        <span class="s5"># See ScalarFormatter.format_data_short.  For r, use #g-formatting</span>
        <span class="s5"># (as for linear axes), but for theta, use f-formatting as scientific</span>
        <span class="s5"># notation doesn't make sense and the trailing dot is ugly.</span>
        <span class="s0">def </span><span class="s1">format_sig(value</span><span class="s0">, </span><span class="s1">delta</span><span class="s0">, </span><span class="s1">opt</span><span class="s0">, </span><span class="s1">fmt):</span>
            <span class="s5"># For &quot;f&quot;, only count digits after decimal point.</span>
            <span class="s1">prec = (max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-math.floor(math.log10(delta))) </span><span class="s0">if </span><span class="s1">fmt == </span><span class="s4">&quot;f&quot; </span><span class="s0">else</span>
                    <span class="s1">cbook._g_sig_digits(value</span><span class="s0">, </span><span class="s1">delta))</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">value</span><span class="s0">:</span><span class="s4">-</span><span class="s0">{</span><span class="s1">opt</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">prec</span><span class="s0">}{</span><span class="s1">fmt</span><span class="s0">}}</span><span class="s4">&quot;</span>

        <span class="s0">return </span><span class="s1">(</span><span class="s4">'</span><span class="s0">\N{GREEK SMALL LETTER THETA}</span><span class="s4">={}</span><span class="s0">\N{GREEK SMALL LETTER PI} </span><span class="s4">'</span>
                <span class="s4">'({}</span><span class="s0">\N{DEGREE SIGN}</span><span class="s4">), r={}'</span><span class="s1">).format(</span>
                    <span class="s1">format_sig(theta_halfturns</span><span class="s0">, </span><span class="s1">delta_t_halfturns</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">format_sig(theta_degrees</span><span class="s0">, </span><span class="s1">delta_t_degrees</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">format_sig(r</span><span class="s0">, </span><span class="s1">delta_r</span><span class="s0">, </span><span class="s4">&quot;#&quot;</span><span class="s0">, </span><span class="s4">&quot;g&quot;</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_data_ratio(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the aspect ratio of the data itself.  For a polar plot, 
        this should always be 1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s3">1.0</span>

    <span class="s5"># # # Interactive panning</span>

    <span class="s0">def </span><span class="s1">can_zoom(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports the zoom box button functionality. 
 
        A polar Axes does not support zoom boxes. 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">can_pan(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports the pan/zoom button functionality. 
 
        For a polar Axes, this is slightly misleading. Both panning and 
        zooming are performed by the same button. Panning is performed 
        in azimuth while zooming is done along the radial. 
        &quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">start_pan(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">button):</span>
        <span class="s1">angle = np.deg2rad(self.get_rlabel_position())</span>
        <span class="s1">mode = </span><span class="s4">''</span>
        <span class="s0">if </span><span class="s1">button == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">epsilon = np.pi / </span><span class="s3">45.0</span>
            <span class="s1">t</span><span class="s0">, </span><span class="s1">r = self.transData.inverted().transform((x</span><span class="s0">, </span><span class="s1">y))</span>
            <span class="s0">if </span><span class="s1">angle - epsilon &lt;= t &lt;= angle + epsilon:</span>
                <span class="s1">mode = </span><span class="s4">'drag_r_labels'</span>
        <span class="s0">elif </span><span class="s1">button == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s4">'zoom'</span>

        <span class="s1">self._pan_start = types.SimpleNamespace(</span>
            <span class="s1">rmax=self.get_rmax()</span><span class="s0">,</span>
            <span class="s1">trans=self.transData.frozen()</span><span class="s0">,</span>
            <span class="s1">trans_inverse=self.transData.inverted().frozen()</span><span class="s0">,</span>
            <span class="s1">r_label_angle=self.get_rlabel_position()</span><span class="s0">,</span>
            <span class="s1">x=x</span><span class="s0">,</span>
            <span class="s1">y=y</span><span class="s0">,</span>
            <span class="s1">mode=mode)</span>

    <span class="s0">def </span><span class="s1">end_pan(self):</span>
        <span class="s0">del </span><span class="s1">self._pan_start</span>

    <span class="s0">def </span><span class="s1">drag_pan(self</span><span class="s0">, </span><span class="s1">button</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s1">p = self._pan_start</span>

        <span class="s0">if </span><span class="s1">p.mode == </span><span class="s4">'drag_r_labels'</span><span class="s1">:</span>
            <span class="s1">(startt</span><span class="s0">, </span><span class="s1">startr)</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">r) = p.trans_inverse.transform(</span>
                <span class="s1">[(p.x</span><span class="s0">, </span><span class="s1">p.y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y)])</span>

            <span class="s5"># Deal with theta</span>
            <span class="s1">dt = np.rad2deg(startt - t)</span>
            <span class="s1">self.set_rlabel_position(p.r_label_angle - dt)</span>

            <span class="s1">trans</span><span class="s0">, </span><span class="s1">vert1</span><span class="s0">, </span><span class="s1">horiz1 = self.get_yaxis_text1_transform(</span><span class="s3">0.0</span><span class="s1">)</span>
            <span class="s1">trans</span><span class="s0">, </span><span class="s1">vert2</span><span class="s0">, </span><span class="s1">horiz2 = self.get_yaxis_text2_transform(</span><span class="s3">0.0</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.yaxis.majorTicks + self.yaxis.minorTicks:</span>
                <span class="s1">t.label1.set_va(vert1)</span>
                <span class="s1">t.label1.set_ha(horiz1)</span>
                <span class="s1">t.label2.set_va(vert2)</span>
                <span class="s1">t.label2.set_ha(horiz2)</span>

        <span class="s0">elif </span><span class="s1">p.mode == </span><span class="s4">'zoom'</span><span class="s1">:</span>
            <span class="s1">(startt</span><span class="s0">, </span><span class="s1">startr)</span><span class="s0">, </span><span class="s1">(t</span><span class="s0">, </span><span class="s1">r) = p.trans_inverse.transform(</span>
                <span class="s1">[(p.x</span><span class="s0">, </span><span class="s1">p.y)</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y)])</span>

            <span class="s5"># Deal with r</span>
            <span class="s1">scale = r / startr</span>
            <span class="s1">self.set_rmax(p.rmax / scale)</span>


<span class="s5"># To keep things all self-contained, we can put aliases to the Polar classes</span>
<span class="s5"># defined above. This isn't strictly necessary, but it makes some of the</span>
<span class="s5"># code more readable, and provides a backwards compatible Polar API. In</span>
<span class="s5"># particular, this is used by the :doc:`/gallery/specialty_plots/radar_chart`</span>
<span class="s5"># example to override PolarTransform on a PolarAxes subclass, so make sure that</span>
<span class="s5"># that example is unaffected before changing this.</span>
<span class="s1">PolarAxes.PolarTransform = PolarTransform</span>
<span class="s1">PolarAxes.PolarAffine = PolarAffine</span>
<span class="s1">PolarAxes.InvertedPolarTransform = InvertedPolarTransform</span>
<span class="s1">PolarAxes.ThetaFormatter = ThetaFormatter</span>
<span class="s1">PolarAxes.RadialLocator = RadialLocator</span>
<span class="s1">PolarAxes.ThetaLocator = ThetaLocator</span>
</pre>
</body>
</html>