<html>
<head>
<title>models.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
models.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Variation fonts interpolation models.&quot;&quot;&quot;</span>

<span class="s1">__all__ = [</span>
    <span class="s2">&quot;normalizeValue&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;normalizeLocation&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;supportScalar&quot;</span><span class="s3">,</span>
    <span class="s2">&quot;VariationModel&quot;</span><span class="s3">,</span>
<span class="s1">]</span>

<span class="s3">from </span><span class="s1">fontTools.misc.roundTools </span><span class="s3">import </span><span class="s1">noRound</span>
<span class="s3">from </span><span class="s1">.errors </span><span class="s3">import </span><span class="s1">VariationModelError</span>


<span class="s3">def </span><span class="s1">nonNone(lst):</span>
    <span class="s3">return </span><span class="s1">[l </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">lst </span><span class="s3">if </span><span class="s1">l </span><span class="s3">is not None</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">allNone(lst):</span>
    <span class="s3">return </span><span class="s1">all(l </span><span class="s3">is None for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">lst)</span>


<span class="s3">def </span><span class="s1">allEqualTo(ref</span><span class="s3">, </span><span class="s1">lst</span><span class="s3">, </span><span class="s1">mapper=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">mapper </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">all(ref == item </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">lst)</span>

    <span class="s1">mapped = mapper(ref)</span>
    <span class="s3">return </span><span class="s1">all(mapped == mapper(item) </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">lst)</span>


<span class="s3">def </span><span class="s1">allEqual(lst</span><span class="s3">, </span><span class="s1">mapper=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if not </span><span class="s1">lst:</span>
        <span class="s3">return True</span>
    <span class="s1">it = iter(lst)</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">first = next(it)</span>
    <span class="s3">except </span><span class="s1">StopIteration:</span>
        <span class="s3">return True</span>
    <span class="s3">return </span><span class="s1">allEqualTo(first</span><span class="s3">, </span><span class="s1">it</span><span class="s3">, </span><span class="s1">mapper=mapper)</span>


<span class="s3">def </span><span class="s1">subList(truth</span><span class="s3">, </span><span class="s1">lst):</span>
    <span class="s3">assert </span><span class="s1">len(truth) == len(lst)</span>
    <span class="s3">return </span><span class="s1">[l </span><span class="s3">for </span><span class="s1">l</span><span class="s3">, </span><span class="s1">t </span><span class="s3">in </span><span class="s1">zip(lst</span><span class="s3">, </span><span class="s1">truth) </span><span class="s3">if </span><span class="s1">t]</span>


<span class="s3">def </span><span class="s1">normalizeValue(v</span><span class="s3">, </span><span class="s1">triple</span><span class="s3">, </span><span class="s1">extrapolate=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Normalizes value based on a min/default/max triple. 
 
      &gt;&gt;&gt; normalizeValue(400, (100, 400, 900)) 
      0.0 
      &gt;&gt;&gt; normalizeValue(100, (100, 400, 900)) 
      -1.0 
      &gt;&gt;&gt; normalizeValue(650, (100, 400, 900)) 
      0.5 
    &quot;&quot;&quot;</span>
    <span class="s1">lower</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">upper = triple</span>
    <span class="s3">if not </span><span class="s1">(lower &lt;= default &lt;= upper):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s2">f&quot;Invalid axis values, must be minimum, default, maximum: &quot;</span>
            <span class="s2">f&quot;</span><span class="s3">{</span><span class="s1">lower</span><span class="s3">:</span><span class="s2">3.3f</span><span class="s3">}</span><span class="s2">, </span><span class="s3">{</span><span class="s1">default</span><span class="s3">:</span><span class="s2">3.3f</span><span class="s3">}</span><span class="s2">, </span><span class="s3">{</span><span class="s1">upper</span><span class="s3">:</span><span class="s2">3.3f</span><span class="s3">}</span><span class="s2">&quot;</span>
        <span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">extrapolate:</span>
        <span class="s1">v = max(min(v</span><span class="s3">, </span><span class="s1">upper)</span><span class="s3">, </span><span class="s1">lower)</span>

    <span class="s3">if </span><span class="s1">v == default </span><span class="s3">or </span><span class="s1">lower == upper:</span>
        <span class="s3">return </span><span class="s4">0.0</span>

    <span class="s3">if </span><span class="s1">(v &lt; default </span><span class="s3">and </span><span class="s1">lower != default) </span><span class="s3">or </span><span class="s1">(v &gt; default </span><span class="s3">and </span><span class="s1">upper == default):</span>
        <span class="s3">return </span><span class="s1">(v - default) / (default - lower)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">assert </span><span class="s1">(v &gt; default </span><span class="s3">and </span><span class="s1">upper != default) </span><span class="s3">or </span><span class="s1">(</span>
            <span class="s1">v &lt; default </span><span class="s3">and </span><span class="s1">lower == default</span>
        <span class="s1">)</span><span class="s3">, </span><span class="s2">f&quot;Ooops... v=</span><span class="s3">{</span><span class="s1">v</span><span class="s3">}</span><span class="s2">, triple=(</span><span class="s3">{</span><span class="s1">lower</span><span class="s3">}</span><span class="s2">, </span><span class="s3">{</span><span class="s1">default</span><span class="s3">}</span><span class="s2">, </span><span class="s3">{</span><span class="s1">upper</span><span class="s3">}</span><span class="s2">)&quot;</span>
        <span class="s3">return </span><span class="s1">(v - default) / (upper - default)</span>


<span class="s3">def </span><span class="s1">normalizeLocation(location</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">, </span><span class="s1">extrapolate=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Normalizes location based on axis min/default/max values from axes. 
 
      &gt;&gt;&gt; axes = {&quot;wght&quot;: (100, 400, 900)} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 400}, axes) 
      {'wght': 0.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 100}, axes) 
      {'wght': -1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 900}, axes) 
      {'wght': 1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 650}, axes) 
      {'wght': 0.5} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
      {'wght': 1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
      {'wght': -1.0} 
      &gt;&gt;&gt; axes = {&quot;wght&quot;: (0, 0, 1000)} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
      {'wght': 0.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: -1}, axes) 
      {'wght': 0.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
      {'wght': 1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 500}, axes) 
      {'wght': 0.5} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1001}, axes) 
      {'wght': 1.0} 
      &gt;&gt;&gt; axes = {&quot;wght&quot;: (0, 1000, 1000)} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 0}, axes) 
      {'wght': -1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: -1}, axes) 
      {'wght': -1.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 500}, axes) 
      {'wght': -0.5} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1000}, axes) 
      {'wght': 0.0} 
      &gt;&gt;&gt; normalizeLocation({&quot;wght&quot;: 1001}, axes) 
      {'wght': 0.0} 
    &quot;&quot;&quot;</span>
    <span class="s1">out = {}</span>
    <span class="s3">for </span><span class="s1">tag</span><span class="s3">, </span><span class="s1">triple </span><span class="s3">in </span><span class="s1">axes.items():</span>
        <span class="s1">v = location.get(tag</span><span class="s3">, </span><span class="s1">triple[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">out[tag] = normalizeValue(v</span><span class="s3">, </span><span class="s1">triple</span><span class="s3">, </span><span class="s1">extrapolate=extrapolate)</span>
    <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">supportScalar(location</span><span class="s3">, </span><span class="s1">support</span><span class="s3">, </span><span class="s1">ot=</span><span class="s3">True, </span><span class="s1">extrapolate=</span><span class="s3">False, </span><span class="s1">axisRanges=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Returns the scalar multiplier at location, for a master 
    with support.  If ot is True, then a peak value of zero 
    for support of an axis means &quot;axis does not participate&quot;.  That 
    is how OpenType Variation Font technology works. 
 
    If extrapolate is True, axisRanges must be a dict that maps axis 
    names to (axisMin, axisMax) tuples. 
 
      &gt;&gt;&gt; supportScalar({}, {}) 
      1.0 
      &gt;&gt;&gt; supportScalar({'wght':.2}, {}) 
      1.0 
      &gt;&gt;&gt; supportScalar({'wght':.2}, {'wght':(0,2,3)}) 
      0.1 
      &gt;&gt;&gt; supportScalar({'wght':2.5}, {'wght':(0,2,4)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}, ot=False) 
      0.375 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':0}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':2.5, 'wdth':.5}, {'wght':(0,2,4), 'wdth':(-1,0,+1)}) 
      0.75 
      &gt;&gt;&gt; supportScalar({'wght':3}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -1.0 
      &gt;&gt;&gt; supportScalar({'wght':-1}, {'wght':(0,1,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -1.0 
      &gt;&gt;&gt; supportScalar({'wght':3}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      1.5 
      &gt;&gt;&gt; supportScalar({'wght':-1}, {'wght':(0,2,2)}, extrapolate=True, axisRanges={'wght':(0, 2)}) 
      -0.5 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">extrapolate </span><span class="s3">and </span><span class="s1">axisRanges </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;axisRanges must be passed when extrapolate is True&quot;</span><span class="s1">)</span>
    <span class="s1">scalar = </span><span class="s4">1.0</span>
    <span class="s3">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">(lower</span><span class="s3">, </span><span class="s1">peak</span><span class="s3">, </span><span class="s1">upper) </span><span class="s3">in </span><span class="s1">support.items():</span>
        <span class="s3">if </span><span class="s1">ot:</span>
            <span class="s5"># OpenType-specific case handling</span>
            <span class="s3">if </span><span class="s1">peak == </span><span class="s4">0.0</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">lower &gt; peak </span><span class="s3">or </span><span class="s1">peak &gt; upper:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">lower &lt; </span><span class="s4">0.0 </span><span class="s3">and </span><span class="s1">upper &gt; </span><span class="s4">0.0</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">v = location.get(axis</span><span class="s3">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">location</span>
            <span class="s1">v = location[axis]</span>
        <span class="s3">if </span><span class="s1">v == peak:</span>
            <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">extrapolate:</span>
            <span class="s1">axisMin</span><span class="s3">, </span><span class="s1">axisMax = axisRanges[axis]</span>
            <span class="s3">if </span><span class="s1">v &lt; axisMin </span><span class="s3">and </span><span class="s1">lower &lt;= axisMin:</span>
                <span class="s3">if </span><span class="s1">peak &lt;= axisMin </span><span class="s3">and </span><span class="s1">peak &lt; upper:</span>
                    <span class="s1">scalar *= (v - upper) / (peak - upper)</span>
                    <span class="s3">continue</span>
                <span class="s3">elif </span><span class="s1">axisMin &lt; peak:</span>
                    <span class="s1">scalar *= (v - lower) / (peak - lower)</span>
                    <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">axisMax &lt; v </span><span class="s3">and </span><span class="s1">axisMax &lt;= upper:</span>
                <span class="s3">if </span><span class="s1">axisMax &lt;= peak </span><span class="s3">and </span><span class="s1">lower &lt; peak:</span>
                    <span class="s1">scalar *= (v - lower) / (peak - lower)</span>
                    <span class="s3">continue</span>
                <span class="s3">elif </span><span class="s1">peak &lt; axisMax:</span>
                    <span class="s1">scalar *= (v - upper) / (peak - upper)</span>
                    <span class="s3">continue</span>

        <span class="s3">if </span><span class="s1">v &lt;= lower </span><span class="s3">or </span><span class="s1">upper &lt;= v:</span>
            <span class="s1">scalar = </span><span class="s4">0.0</span>
            <span class="s3">break</span>

        <span class="s3">if </span><span class="s1">v &lt; peak:</span>
            <span class="s1">scalar *= (v - lower) / (peak - lower)</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s5"># v &gt; peak</span>
            <span class="s1">scalar *= (v - upper) / (peak - upper)</span>
    <span class="s3">return </span><span class="s1">scalar</span>


<span class="s3">class </span><span class="s1">VariationModel(object):</span>
    <span class="s0">&quot;&quot;&quot;Locations must have the base master at the origin (ie. 0). 
 
    If the extrapolate argument is set to True, then values are extrapolated 
    outside the axis range. 
 
      &gt;&gt;&gt; from pprint import pprint 
      &gt;&gt;&gt; locations = [ \ 
      {'wght':100}, \ 
      {'wght':-100}, \ 
      {'wght':-180}, \ 
      {'wdth':+.3}, \ 
      {'wght':+120,'wdth':.3}, \ 
      {'wght':+120,'wdth':.2}, \ 
      {}, \ 
      {'wght':+180,'wdth':.3}, \ 
      {'wght':+180}, \ 
      ] 
      &gt;&gt;&gt; model = VariationModel(locations, axisOrder=['wght']) 
      &gt;&gt;&gt; pprint(model.locations) 
      [{}, 
       {'wght': -100}, 
       {'wght': -180}, 
       {'wght': 100}, 
       {'wght': 180}, 
       {'wdth': 0.3}, 
       {'wdth': 0.3, 'wght': 180}, 
       {'wdth': 0.3, 'wght': 120}, 
       {'wdth': 0.2, 'wght': 120}] 
      &gt;&gt;&gt; pprint(model.deltaWeights) 
      [{}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0}, 
       {0: 1.0, 4: 1.0, 5: 1.0}, 
       {0: 1.0, 3: 0.75, 4: 0.25, 5: 1.0, 6: 0.6666666666666666}, 
       {0: 1.0, 
        3: 0.75, 
        4: 0.25, 
        5: 0.6666666666666667, 
        6: 0.4444444444444445, 
        7: 0.6666666666666667}] 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">locations</span><span class="s3">, </span><span class="s1">axisOrder=</span><span class="s3">None, </span><span class="s1">extrapolate=</span><span class="s3">False</span><span class="s1">):</span>

        <span class="s3">if </span><span class="s1">len(set(tuple(sorted(l.items())) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">locations)) != len(locations):</span>
            <span class="s3">raise </span><span class="s1">VariationModelError(</span><span class="s2">&quot;Locations must be unique.&quot;</span><span class="s1">)</span>

        <span class="s1">self.origLocations = locations</span>
        <span class="s1">self.axisOrder = axisOrder </span><span class="s3">if </span><span class="s1">axisOrder </span><span class="s3">is not None else </span><span class="s1">[]</span>
        <span class="s1">self.extrapolate = extrapolate</span>
        <span class="s1">self.axisRanges = self.computeAxisRanges(locations) </span><span class="s3">if </span><span class="s1">extrapolate </span><span class="s3">else None</span>

        <span class="s1">locations = [{k: v </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">loc.items() </span><span class="s3">if </span><span class="s1">v != </span><span class="s4">0.0</span><span class="s1">} </span><span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">locations]</span>
        <span class="s1">keyFunc = self.getMasterLocationsSortKeyFunc(</span>
            <span class="s1">locations</span><span class="s3">, </span><span class="s1">axisOrder=self.axisOrder</span>
        <span class="s1">)</span>
        <span class="s1">self.locations = sorted(locations</span><span class="s3">, </span><span class="s1">key=keyFunc)</span>

        <span class="s5"># Mapping from user's master order to our master order</span>
        <span class="s1">self.mapping = [self.locations.index(l) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">locations]</span>
        <span class="s1">self.reverseMapping = [locations.index(l) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">self.locations]</span>

        <span class="s1">self._computeMasterSupports()</span>
        <span class="s1">self._subModels = {}</span>

    <span class="s3">def </span><span class="s1">getSubModel(self</span><span class="s3">, </span><span class="s1">items):</span>
        <span class="s3">if None not in </span><span class="s1">items:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s3">, </span><span class="s1">items</span>
        <span class="s1">key = tuple(v </span><span class="s3">is not None for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">items)</span>
        <span class="s1">subModel = self._subModels.get(key)</span>
        <span class="s3">if </span><span class="s1">subModel </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">subModel = VariationModel(subList(key</span><span class="s3">, </span><span class="s1">self.origLocations)</span><span class="s3">, </span><span class="s1">self.axisOrder)</span>
            <span class="s1">self._subModels[key] = subModel</span>
        <span class="s3">return </span><span class="s1">subModel</span><span class="s3">, </span><span class="s1">subList(key</span><span class="s3">, </span><span class="s1">items)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">computeAxisRanges(locations):</span>
        <span class="s1">axisRanges = {}</span>
        <span class="s1">allAxes = {axis </span><span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">locations </span><span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">loc.keys()}</span>
        <span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">locations:</span>
            <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">allAxes:</span>
                <span class="s1">value = loc.get(axis</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">axisMin</span><span class="s3">, </span><span class="s1">axisMax = axisRanges.get(axis</span><span class="s3">, </span><span class="s1">(value</span><span class="s3">, </span><span class="s1">value))</span>
                <span class="s1">axisRanges[axis] = min(value</span><span class="s3">, </span><span class="s1">axisMin)</span><span class="s3">, </span><span class="s1">max(value</span><span class="s3">, </span><span class="s1">axisMax)</span>
        <span class="s3">return </span><span class="s1">axisRanges</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">getMasterLocationsSortKeyFunc(locations</span><span class="s3">, </span><span class="s1">axisOrder=[]):</span>
        <span class="s3">if </span><span class="s1">{} </span><span class="s3">not in </span><span class="s1">locations:</span>
            <span class="s3">raise </span><span class="s1">VariationModelError(</span><span class="s2">&quot;Base master not found.&quot;</span><span class="s1">)</span>
        <span class="s1">axisPoints = {}</span>
        <span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">locations:</span>
            <span class="s3">if </span><span class="s1">len(loc) != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3">continue</span>
            <span class="s1">axis = next(iter(loc))</span>
            <span class="s1">value = loc[axis]</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s3">not in </span><span class="s1">axisPoints:</span>
                <span class="s1">axisPoints[axis] = {</span><span class="s4">0.0</span><span class="s1">}</span>
            <span class="s3">assert </span><span class="s1">(</span>
                <span class="s1">value </span><span class="s3">not in </span><span class="s1">axisPoints[axis]</span>
            <span class="s1">)</span><span class="s3">, </span><span class="s2">'Value &quot;%s&quot; in axisPoints[&quot;%s&quot;] --&gt;  %s' </span><span class="s1">% (value</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">axisPoints)</span>
            <span class="s1">axisPoints[axis].add(value)</span>

        <span class="s3">def </span><span class="s1">getKey(axisPoints</span><span class="s3">, </span><span class="s1">axisOrder):</span>
            <span class="s3">def </span><span class="s1">sign(v):</span>
                <span class="s3">return </span><span class="s1">-</span><span class="s4">1 </span><span class="s3">if </span><span class="s1">v &lt; </span><span class="s4">0 </span><span class="s3">else </span><span class="s1">+</span><span class="s4">1 </span><span class="s3">if </span><span class="s1">v &gt; </span><span class="s4">0 </span><span class="s3">else </span><span class="s4">0</span>

            <span class="s3">def </span><span class="s1">key(loc):</span>
                <span class="s1">rank = len(loc)</span>
                <span class="s1">onPointAxes = [</span>
                    <span class="s1">axis</span>
                    <span class="s3">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">loc.items()</span>
                    <span class="s3">if </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">axisPoints </span><span class="s3">and </span><span class="s1">value </span><span class="s3">in </span><span class="s1">axisPoints[axis]</span>
                <span class="s1">]</span>
                <span class="s1">orderedAxes = [axis </span><span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">axisOrder </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">loc]</span>
                <span class="s1">orderedAxes.extend(</span>
                    <span class="s1">[axis </span><span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">sorted(loc.keys()) </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">not in </span><span class="s1">axisOrder]</span>
                <span class="s1">)</span>
                <span class="s3">return </span><span class="s1">(</span>
                    <span class="s1">rank</span><span class="s3">,  </span><span class="s5"># First, order by increasing rank</span>
                    <span class="s1">-len(onPointAxes)</span><span class="s3">,  </span><span class="s5"># Next, by decreasing number of onPoint axes</span>
                    <span class="s1">tuple(</span>
                        <span class="s1">axisOrder.index(axis) </span><span class="s3">if </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">axisOrder </span><span class="s3">else </span><span class="s4">0x10000</span>
                        <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">orderedAxes</span>
                    <span class="s1">)</span><span class="s3">,  </span><span class="s5"># Next, by known axes</span>
                    <span class="s1">tuple(orderedAxes)</span><span class="s3">,  </span><span class="s5"># Next, by all axes</span>
                    <span class="s1">tuple(</span>
                        <span class="s1">sign(loc[axis]) </span><span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">orderedAxes</span>
                    <span class="s1">)</span><span class="s3">,  </span><span class="s5"># Next, by signs of axis values</span>
                    <span class="s1">tuple(</span>
                        <span class="s1">abs(loc[axis]) </span><span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">orderedAxes</span>
                    <span class="s1">)</span><span class="s3">,  </span><span class="s5"># Next, by absolute value of axis values</span>
                <span class="s1">)</span>

            <span class="s3">return </span><span class="s1">key</span>

        <span class="s1">ret = getKey(axisPoints</span><span class="s3">, </span><span class="s1">axisOrder)</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s3">def </span><span class="s1">reorderMasters(self</span><span class="s3">, </span><span class="s1">master_list</span><span class="s3">, </span><span class="s1">mapping):</span>
        <span class="s5"># For changing the master data order without</span>
        <span class="s5"># recomputing supports and deltaWeights.</span>
        <span class="s1">new_list = [master_list[idx] </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">mapping]</span>
        <span class="s1">self.origLocations = [self.origLocations[idx] </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">mapping]</span>
        <span class="s1">locations = [</span>
            <span class="s1">{k: v </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">loc.items() </span><span class="s3">if </span><span class="s1">v != </span><span class="s4">0.0</span><span class="s1">} </span><span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">self.origLocations</span>
        <span class="s1">]</span>
        <span class="s1">self.mapping = [self.locations.index(l) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">locations]</span>
        <span class="s1">self.reverseMapping = [locations.index(l) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">self.locations]</span>
        <span class="s1">self._subModels = {}</span>
        <span class="s3">return </span><span class="s1">new_list</span>

    <span class="s3">def </span><span class="s1">_computeMasterSupports(self):</span>
        <span class="s1">self.supports = []</span>
        <span class="s1">regions = self._locationsToRegions()</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">region </span><span class="s3">in </span><span class="s1">enumerate(regions):</span>
            <span class="s1">locAxes = set(region.keys())</span>
            <span class="s5"># Walk over previous masters now</span>
            <span class="s3">for </span><span class="s1">prev_region </span><span class="s3">in </span><span class="s1">regions[:i]:</span>
                <span class="s5"># Master with extra axes do not participte</span>
                <span class="s3">if not </span><span class="s1">set(prev_region.keys()).issubset(locAxes):</span>
                    <span class="s3">continue</span>
                <span class="s5"># If it's NOT in the current box, it does not participate</span>
                <span class="s1">relevant = </span><span class="s3">True</span>
                <span class="s3">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">(lower</span><span class="s3">, </span><span class="s1">peak</span><span class="s3">, </span><span class="s1">upper) </span><span class="s3">in </span><span class="s1">region.items():</span>
                    <span class="s3">if </span><span class="s1">axis </span><span class="s3">not in </span><span class="s1">prev_region </span><span class="s3">or not </span><span class="s1">(</span>
                        <span class="s1">prev_region[axis][</span><span class="s4">1</span><span class="s1">] == peak</span>
                        <span class="s3">or </span><span class="s1">lower &lt; prev_region[axis][</span><span class="s4">1</span><span class="s1">] &lt; upper</span>
                    <span class="s1">):</span>
                        <span class="s1">relevant = </span><span class="s3">False</span>
                        <span class="s3">break</span>
                <span class="s3">if not </span><span class="s1">relevant:</span>
                    <span class="s3">continue</span>

                <span class="s5"># Split the box for new master; split in whatever direction</span>
                <span class="s5"># that has largest range ratio.</span>
                <span class="s5">#</span>
                <span class="s5"># For symmetry, we actually cut across multiple axes</span>
                <span class="s5"># if they have the largest, equal, ratio.</span>
                <span class="s5"># https://github.com/fonttools/fonttools/commit/7ee81c8821671157968b097f3e55309a1faa511e#commitcomment-31054804</span>

                <span class="s1">bestAxes = {}</span>
                <span class="s1">bestRatio = -</span><span class="s4">1</span>
                <span class="s3">for </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">prev_region.keys():</span>
                    <span class="s1">val = prev_region[axis][</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s3">assert </span><span class="s1">axis </span><span class="s3">in </span><span class="s1">region</span>
                    <span class="s1">lower</span><span class="s3">, </span><span class="s1">locV</span><span class="s3">, </span><span class="s1">upper = region[axis]</span>
                    <span class="s1">newLower</span><span class="s3">, </span><span class="s1">newUpper = lower</span><span class="s3">, </span><span class="s1">upper</span>
                    <span class="s3">if </span><span class="s1">val &lt; locV:</span>
                        <span class="s1">newLower = val</span>
                        <span class="s1">ratio = (val - locV) / (lower - locV)</span>
                    <span class="s3">elif </span><span class="s1">locV &lt; val:</span>
                        <span class="s1">newUpper = val</span>
                        <span class="s1">ratio = (val - locV) / (upper - locV)</span>
                    <span class="s3">else</span><span class="s1">:  </span><span class="s5"># val == locV</span>
                        <span class="s5"># Can't split box in this direction.</span>
                        <span class="s3">continue</span>
                    <span class="s3">if </span><span class="s1">ratio &gt; bestRatio:</span>
                        <span class="s1">bestAxes = {}</span>
                        <span class="s1">bestRatio = ratio</span>
                    <span class="s3">if </span><span class="s1">ratio == bestRatio:</span>
                        <span class="s1">bestAxes[axis] = (newLower</span><span class="s3">, </span><span class="s1">locV</span><span class="s3">, </span><span class="s1">newUpper)</span>

                <span class="s3">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">triple </span><span class="s3">in </span><span class="s1">bestAxes.items():</span>
                    <span class="s1">region[axis] = triple</span>
            <span class="s1">self.supports.append(region)</span>
        <span class="s1">self._computeDeltaWeights()</span>

    <span class="s3">def </span><span class="s1">_locationsToRegions(self):</span>
        <span class="s1">locations = self.locations</span>
        <span class="s5"># Compute min/max across each axis, use it as total range.</span>
        <span class="s5"># TODO Take this as input from outside?</span>
        <span class="s1">minV = {}</span>
        <span class="s1">maxV = {}</span>
        <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">locations:</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">l.items():</span>
                <span class="s1">minV[k] = min(v</span><span class="s3">, </span><span class="s1">minV.get(k</span><span class="s3">, </span><span class="s1">v))</span>
                <span class="s1">maxV[k] = max(v</span><span class="s3">, </span><span class="s1">maxV.get(k</span><span class="s3">, </span><span class="s1">v))</span>

        <span class="s1">regions = []</span>
        <span class="s3">for </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">locations:</span>
            <span class="s1">region = {}</span>
            <span class="s3">for </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">locV </span><span class="s3">in </span><span class="s1">loc.items():</span>
                <span class="s3">if </span><span class="s1">locV &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">region[axis] = (</span><span class="s4">0</span><span class="s3">, </span><span class="s1">locV</span><span class="s3">, </span><span class="s1">maxV[axis])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">region[axis] = (minV[axis]</span><span class="s3">, </span><span class="s1">locV</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">regions.append(region)</span>
        <span class="s3">return </span><span class="s1">regions</span>

    <span class="s3">def </span><span class="s1">_computeDeltaWeights(self):</span>
        <span class="s1">self.deltaWeights = []</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">loc </span><span class="s3">in </span><span class="s1">enumerate(self.locations):</span>
            <span class="s1">deltaWeight = {}</span>
            <span class="s5"># Walk over previous masters now, populate deltaWeight</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">support </span><span class="s3">in </span><span class="s1">enumerate(self.supports[:i]):</span>
                <span class="s1">scalar = supportScalar(loc</span><span class="s3">, </span><span class="s1">support)</span>
                <span class="s3">if </span><span class="s1">scalar:</span>
                    <span class="s1">deltaWeight[j] = scalar</span>
            <span class="s1">self.deltaWeights.append(deltaWeight)</span>

    <span class="s3">def </span><span class="s1">getDeltas(self</span><span class="s3">, </span><span class="s1">masterValues</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">round=noRound):</span>
        <span class="s3">assert </span><span class="s1">len(masterValues) == len(self.deltaWeights)</span>
        <span class="s1">mapping = self.reverseMapping</span>
        <span class="s1">out = []</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">weights </span><span class="s3">in </span><span class="s1">enumerate(self.deltaWeights):</span>
            <span class="s1">delta = masterValues[mapping[i]]</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">weight </span><span class="s3">in </span><span class="s1">weights.items():</span>
                <span class="s3">if </span><span class="s1">weight == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">delta -= out[j]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">delta -= out[j] * weight</span>
            <span class="s1">out.append(round(delta))</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s3">def </span><span class="s1">getDeltasAndSupports(self</span><span class="s3">, </span><span class="s1">items</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">round=noRound):</span>
        <span class="s1">model</span><span class="s3">, </span><span class="s1">items = self.getSubModel(items)</span>
        <span class="s3">return </span><span class="s1">model.getDeltas(items</span><span class="s3">, </span><span class="s1">round=round)</span><span class="s3">, </span><span class="s1">model.supports</span>

    <span class="s3">def </span><span class="s1">getScalars(self</span><span class="s3">, </span><span class="s1">loc):</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">supportScalar(</span>
                <span class="s1">loc</span><span class="s3">, </span><span class="s1">support</span><span class="s3">, </span><span class="s1">extrapolate=self.extrapolate</span><span class="s3">, </span><span class="s1">axisRanges=self.axisRanges</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">support </span><span class="s3">in </span><span class="s1">self.supports</span>
        <span class="s1">]</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">interpolateFromDeltasAndScalars(deltas</span><span class="s3">, </span><span class="s1">scalars):</span>
        <span class="s1">v = </span><span class="s3">None</span>
        <span class="s3">assert </span><span class="s1">len(deltas) == len(scalars)</span>
        <span class="s3">for </span><span class="s1">delta</span><span class="s3">, </span><span class="s1">scalar </span><span class="s3">in </span><span class="s1">zip(deltas</span><span class="s3">, </span><span class="s1">scalars):</span>
            <span class="s3">if not </span><span class="s1">scalar:</span>
                <span class="s3">continue</span>
            <span class="s1">contribution = delta * scalar</span>
            <span class="s3">if </span><span class="s1">v </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">v = contribution</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">v += contribution</span>
        <span class="s3">return </span><span class="s1">v</span>

    <span class="s3">def </span><span class="s1">interpolateFromDeltas(self</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">deltas):</span>
        <span class="s1">scalars = self.getScalars(loc)</span>
        <span class="s3">return </span><span class="s1">self.interpolateFromDeltasAndScalars(deltas</span><span class="s3">, </span><span class="s1">scalars)</span>

    <span class="s3">def </span><span class="s1">interpolateFromMasters(self</span><span class="s3">, </span><span class="s1">loc</span><span class="s3">, </span><span class="s1">masterValues</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">round=noRound):</span>
        <span class="s1">deltas = self.getDeltas(masterValues</span><span class="s3">, </span><span class="s1">round=round)</span>
        <span class="s3">return </span><span class="s1">self.interpolateFromDeltas(loc</span><span class="s3">, </span><span class="s1">deltas)</span>

    <span class="s3">def </span><span class="s1">interpolateFromMastersAndScalars(self</span><span class="s3">, </span><span class="s1">masterValues</span><span class="s3">, </span><span class="s1">scalars</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">round=noRound):</span>
        <span class="s1">deltas = self.getDeltas(masterValues</span><span class="s3">, </span><span class="s1">round=round)</span>
        <span class="s3">return </span><span class="s1">self.interpolateFromDeltasAndScalars(deltas</span><span class="s3">, </span><span class="s1">scalars)</span>


<span class="s3">def </span><span class="s1">piecewiseLinearMap(v</span><span class="s3">, </span><span class="s1">mapping):</span>
    <span class="s1">keys = mapping.keys()</span>
    <span class="s3">if not </span><span class="s1">keys:</span>
        <span class="s3">return </span><span class="s1">v</span>
    <span class="s3">if </span><span class="s1">v </span><span class="s3">in </span><span class="s1">keys:</span>
        <span class="s3">return </span><span class="s1">mapping[v]</span>
    <span class="s1">k = min(keys)</span>
    <span class="s3">if </span><span class="s1">v &lt; k:</span>
        <span class="s3">return </span><span class="s1">v + mapping[k] - k</span>
    <span class="s1">k = max(keys)</span>
    <span class="s3">if </span><span class="s1">v &gt; k:</span>
        <span class="s3">return </span><span class="s1">v + mapping[k] - k</span>
    <span class="s5"># Interpolate</span>
    <span class="s1">a = max(k </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys </span><span class="s3">if </span><span class="s1">k &lt; v)</span>
    <span class="s1">b = min(k </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">keys </span><span class="s3">if </span><span class="s1">k &gt; v)</span>
    <span class="s1">va = mapping[a]</span>
    <span class="s1">vb = mapping[b]</span>
    <span class="s3">return </span><span class="s1">va + (vb - va) * (v - a) / (b - a)</span>


<span class="s3">def </span><span class="s1">main(args=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Normalize locations on a given designspace&quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">fontTools </span><span class="s3">import </span><span class="s1">configLogger</span>
    <span class="s3">import </span><span class="s1">argparse</span>

    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s2">&quot;fonttools varLib.models&quot;</span><span class="s3">,</span>
        <span class="s1">description=main.__doc__</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s2">&quot;--loglevel&quot;</span><span class="s3">,</span>
        <span class="s1">metavar=</span><span class="s2">&quot;LEVEL&quot;</span><span class="s3">,</span>
        <span class="s1">default=</span><span class="s2">&quot;INFO&quot;</span><span class="s3">,</span>
        <span class="s1">help=</span><span class="s2">&quot;Logging level (defaults to INFO)&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s1">group = parser.add_mutually_exclusive_group(required=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">group.add_argument(</span><span class="s2">&quot;-d&quot;</span><span class="s3">, </span><span class="s2">&quot;--designspace&quot;</span><span class="s3">, </span><span class="s1">metavar=</span><span class="s2">&quot;DESIGNSPACE&quot;</span><span class="s3">, </span><span class="s1">type=str)</span>
    <span class="s1">group.add_argument(</span>
        <span class="s2">&quot;-l&quot;</span><span class="s3">,</span>
        <span class="s2">&quot;--locations&quot;</span><span class="s3">,</span>
        <span class="s1">metavar=</span><span class="s2">&quot;LOCATION&quot;</span><span class="s3">,</span>
        <span class="s1">nargs=</span><span class="s2">&quot;+&quot;</span><span class="s3">,</span>
        <span class="s1">help=</span><span class="s2">&quot;Master locations as comma-separate coordinates. One must be all zeros.&quot;</span><span class="s3">,</span>
    <span class="s1">)</span>

    <span class="s1">args = parser.parse_args(args)</span>

    <span class="s1">configLogger(level=args.loglevel)</span>
    <span class="s3">from </span><span class="s1">pprint </span><span class="s3">import </span><span class="s1">pprint</span>

    <span class="s3">if </span><span class="s1">args.designspace:</span>
        <span class="s3">from </span><span class="s1">fontTools.designspaceLib </span><span class="s3">import </span><span class="s1">DesignSpaceDocument</span>

        <span class="s1">doc = DesignSpaceDocument()</span>
        <span class="s1">doc.read(args.designspace)</span>
        <span class="s1">locs = [s.location </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">doc.sources]</span>
        <span class="s1">print(</span><span class="s2">&quot;Original locations:&quot;</span><span class="s1">)</span>
        <span class="s1">pprint(locs)</span>
        <span class="s1">doc.normalize()</span>
        <span class="s1">print(</span><span class="s2">&quot;Normalized locations:&quot;</span><span class="s1">)</span>
        <span class="s1">locs = [s.location </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">doc.sources]</span>
        <span class="s1">pprint(locs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">axes = [chr(c) </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">range(ord(</span><span class="s2">&quot;A&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">ord(</span><span class="s2">&quot;Z&quot;</span><span class="s1">) + </span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">locs = [</span>
            <span class="s1">dict(zip(axes</span><span class="s3">, </span><span class="s1">(float(v) </span><span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">s.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)))) </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">args.locations</span>
        <span class="s1">]</span>

    <span class="s1">model = VariationModel(locs)</span>
    <span class="s1">print(</span><span class="s2">&quot;Sorted locations:&quot;</span><span class="s1">)</span>
    <span class="s1">pprint(model.locations)</span>
    <span class="s1">print(</span><span class="s2">&quot;Supports:&quot;</span><span class="s1">)</span>
    <span class="s1">pprint(model.supports)</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">doctest</span><span class="s3">, </span><span class="s1">sys</span>

    <span class="s3">if </span><span class="s1">len(sys.argv) &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">sys.exit(main())</span>

    <span class="s1">sys.exit(doctest.testmod().failed)</span>
</pre>
</body>
</html>