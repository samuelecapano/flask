<html>
<head>
<title>quiver.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
quiver.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Support for plotting vector fields. 
 
Presently this contains Quiver and Barb. Quiver plots an arrow in the 
direction of the vector, with the size of the arrow related to the 
magnitude of the vector. 
 
Barbs are like quiver in that they point along a vector, but 
the magnitude of the vector is given schematically by the presence of barbs 
or flags on the barb. 
 
This will also become a home for things such as standard 
deviation ellipses, which can and will be derived very easily from 
the Quiver code. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">math</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">ma</span>

<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">import </span><span class="s1">matplotlib.collections </span><span class="s2">as </span><span class="s1">mcollections</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">CirclePolygon</span>
<span class="s2">import </span><span class="s1">matplotlib.text </span><span class="s2">as </span><span class="s1">mtext</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">transforms</span>


<span class="s1">_quiver_doc = </span><span class="s3">&quot;&quot;&quot; 
Plot a 2D field of arrows. 
 
Call signature:: 
 
  quiver([X, Y], U, V, [C], **kwargs) 
 
*X*, *Y* define the arrow locations, *U*, *V* define the arrow directions, and 
*C* optionally sets the color. 
 
**Arrow length** 
 
The default settings auto-scales the length of the arrows to a reasonable size. 
To change this behavior see the *scale* and *scale_units* parameters. 
 
**Arrow shape** 
 
The arrow shape is determined by *width*, *headwidth*, *headlength* and 
*headaxislength*. See the notes below. 
 
**Arrow styling** 
 
Each arrow is internally represented by a filled polygon with a default edge 
linewidth of 0. As a result, an arrow is rather a filled area, not a line with 
a head, and `.PolyCollection` properties like *linewidth*, *edgecolor*, 
*facecolor*, etc. act accordingly. 
 
 
Parameters 
---------- 
X, Y : 1D or 2D array-like, optional 
    The x and y coordinates of the arrow locations. 
 
    If not given, they will be generated as a uniform integer meshgrid based 
    on the dimensions of *U* and *V*. 
 
    If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D 
    using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)`` 
    must match the column and row dimensions of *U* and *V*. 
 
U, V : 1D or 2D array-like 
    The x and y direction components of the arrow vectors. The interpretation 
    of these components (in data or in screen space) depends on *angles*. 
 
    *U* and *V* must have the same number of elements, matching the number of 
    arrow locations in  *X*, *Y*. *U* and *V* may be masked. Locations masked 
    in any of *U*, *V*, and *C* will not be drawn. 
 
C : 1D or 2D array-like, optional 
    Numeric data that defines the arrow colors by colormapping via *norm* and 
    *cmap*. 
 
    This does not support explicit colors. If you want to set colors directly, 
    use *color* instead.  The size of *C* must match the number of arrow 
    locations. 
 
angles : {'uv', 'xy'} or array-like, default: 'uv' 
    Method for determining the angle of the arrows. 
 
    - 'uv': Arrow direction in screen coordinates. Use this if the arrows 
      symbolize a quantity that is not based on *X*, *Y* data coordinates. 
 
      If *U* == *V* the orientation of the arrow on the plot is 45 degrees 
      counter-clockwise from the  horizontal axis (positive to the right). 
 
    - 'xy': Arrow direction in data coordinates, i.e. the arrows point from 
      (x, y) to (x+u, y+v). Use this e.g. for plotting a gradient field. 
 
    - Arbitrary angles may be specified explicitly as an array of values 
      in degrees, counter-clockwise from the horizontal axis. 
 
      In this case *U*, *V* is only used to determine the length of the 
      arrows. 
 
    Note: inverting a data axis will correspondingly invert the 
    arrows only with ``angles='xy'``. 
 
pivot : {'tail', 'mid', 'middle', 'tip'}, default: 'tail' 
    The part of the arrow that is anchored to the *X*, *Y* grid. The arrow 
    rotates about this point. 
 
    'mid' is a synonym for 'middle'. 
 
scale : float, optional 
    Scales the length of the arrow inversely. 
 
    Number of data units per arrow length unit, e.g., m/s per plot width; a 
    smaller scale parameter makes the arrow longer. Default is *None*. 
 
    If *None*, a simple autoscaling algorithm is used, based on the average 
    vector length and the number of vectors. The arrow length unit is given by 
    the *scale_units* parameter. 
 
scale_units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, optional 
    If the *scale* kwarg is *None*, the arrow length unit. Default is *None*. 
 
    e.g. *scale_units* is 'inches', *scale* is 2.0, and ``(u, v) = (1, 0)``, 
    then the vector will be 0.5 inches long. 
 
    If *scale_units* is 'width' or 'height', then the vector will be half the 
    width/height of the axes. 
 
    If *scale_units* is 'x' then the vector will be 0.5 x-axis 
    units. To plot vectors in the x-y plane, with u and v having 
    the same units as x and y, use 
    ``angles='xy', scale_units='xy', scale=1``. 
 
units : {'width', 'height', 'dots', 'inches', 'x', 'y', 'xy'}, default: 'width' 
    Affects the arrow size (except for the length). In particular, the shaft 
    *width* is measured in multiples of this unit. 
 
    Supported values are: 
 
    - 'width', 'height': The width or height of the Axes. 
    - 'dots', 'inches': Pixels or inches based on the figure dpi. 
    - 'x', 'y', 'xy': *X*, *Y* or :math:`</span><span class="s2">\\</span><span class="s3">sqrt{X^2 + Y^2}` in data units. 
 
    The following table summarizes how these values affect the visible arrow 
    size under zooming and figure size changes: 
 
    =================  =================   ================== 
    units              zoom                figure size change 
    =================  =================   ================== 
    'x', 'y', 'xy'     arrow size scales   — 
    'width', 'height'  —                   arrow size scales 
    'dots', 'inches'   —                   — 
    =================  =================   ================== 
 
width : float, optional 
    Shaft width in arrow units. All head parameters are relative to *width*. 
 
    The default depends on choice of *units* above, and number of vectors; 
    a typical starting value is about 0.005 times the width of the plot. 
 
headwidth : float, default: 3 
    Head width as multiple of shaft *width*. See the notes below. 
 
headlength : float, default: 5 
    Head length as multiple of shaft *width*. See the notes below. 
 
headaxislength : float, default: 4.5 
    Head length at shaft intersection as multiple of shaft *width*. 
    See the notes below. 
 
minshaft : float, default: 1 
    Length below which arrow scales, in units of head length. Do not 
    set this to less than 1, or small arrows will look terrible! 
 
minlength : float, default: 1 
    Minimum length as a multiple of shaft width; if an arrow length 
    is less than this, plot a dot (hexagon) of this diameter instead. 
 
color : color or color sequence, optional 
    Explicit color(s) for the arrows. If *C* has been set, *color* has no 
    effect. 
 
    This is a synonym for the `.PolyCollection` *facecolor* parameter. 
 
Other Parameters 
---------------- 
data : indexable object, optional 
    DATA_PARAMETER_PLACEHOLDER 
 
**kwargs : `~matplotlib.collections.PolyCollection` properties, optional 
    All other keyword arguments are passed on to `.PolyCollection`: 
 
    %(PolyCollection:kwdoc)s 
 
Returns 
------- 
`~matplotlib.quiver.Quiver` 
 
See Also 
-------- 
.Axes.quiverkey : Add a key to a quiver plot. 
 
Notes 
----- 
 
**Arrow shape** 
 
The arrow is drawn as a polygon using the nodes as shown below. The values 
*headwidth*, *headlength*, and *headaxislength* are in units of *width*. 
 
.. image:: /_static/quiver_sizes.svg 
   :width: 500px 
 
The defaults give a slightly swept-back arrow. Here are some guidelines how to 
get other head shapes: 
 
- To make the head a triangle, make *headaxislength* the same as *headlength*. 
- To make the arrow more pointed, reduce *headwidth* or increase *headlength* 
  and *headaxislength*. 
- To make the head smaller relative to the shaft, scale down all the head 
  parameters proportionally. 
- To remove the head completely, set all *head* parameters to 0. 
- To get a diamond-shaped head, make *headaxislength* larger than *headlength*. 
- Warning: For *headaxislength* &lt; (*headlength* / *headwidth*), the &quot;headaxis&quot; 
  nodes (i.e. the ones connecting the head with the shaft) will protrude out 
  of the head in forward direction so that the arrow head looks broken. 
&quot;&quot;&quot; </span><span class="s1">% _docstring.interpd.params</span>

<span class="s1">_docstring.interpd.update(quiver_doc=_quiver_doc)</span>


<span class="s2">class </span><span class="s1">QuiverKey(martist.Artist):</span>
    <span class="s0">&quot;&quot;&quot;Labelled arrow for use as a quiver plot scale key.&quot;&quot;&quot;</span>
    <span class="s1">halign = {</span><span class="s3">'N'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s2">, </span><span class="s3">'S'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s2">, </span><span class="s3">'E'</span><span class="s1">: </span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'W'</span><span class="s1">: </span><span class="s3">'right'</span><span class="s1">}</span>
    <span class="s1">valign = {</span><span class="s3">'N'</span><span class="s1">: </span><span class="s3">'bottom'</span><span class="s2">, </span><span class="s3">'S'</span><span class="s1">: </span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'E'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s2">, </span><span class="s3">'W'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s1">}</span>
    <span class="s1">pivot = {</span><span class="s3">'N'</span><span class="s1">: </span><span class="s3">'middle'</span><span class="s2">, </span><span class="s3">'S'</span><span class="s1">: </span><span class="s3">'middle'</span><span class="s2">, </span><span class="s3">'E'</span><span class="s1">: </span><span class="s3">'tip'</span><span class="s2">, </span><span class="s3">'W'</span><span class="s1">: </span><span class="s3">'tail'</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">label</span><span class="s2">,</span>
                 <span class="s1">*</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">coordinates=</span><span class="s3">'axes'</span><span class="s2">, </span><span class="s1">color=</span><span class="s2">None, </span><span class="s1">labelsep=</span><span class="s4">0.1</span><span class="s2">,</span>
                 <span class="s1">labelpos=</span><span class="s3">'N'</span><span class="s2">, </span><span class="s1">labelcolor=</span><span class="s2">None, </span><span class="s1">fontproperties=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a key to a quiver plot. 
 
        The positioning of the key depends on *X*, *Y*, *coordinates*, and 
        *labelpos*.  If *labelpos* is 'N' or 'S', *X*, *Y* give the position of 
        the middle of the key arrow.  If *labelpos* is 'E', *X*, *Y* positions 
        the head, and if *labelpos* is 'W', *X*, *Y* positions the tail; in 
        either of these two cases, *X*, *Y* is somewhere in the middle of the 
        arrow+label key object. 
 
        Parameters 
        ---------- 
        Q : `matplotlib.quiver.Quiver` 
            A `.Quiver` object as returned by a call to `~.Axes.quiver()`. 
        X, Y : float 
            The location of the key. 
        U : float 
            The length of the key. 
        label : str 
            The key label (e.g., length and units of the key). 
        angle : float, default: 0 
            The angle of the key arrow, in degrees anti-clockwise from the 
            x-axis. 
        coordinates : {'axes', 'figure', 'data', 'inches'}, default: 'axes' 
            Coordinate system and units for *X*, *Y*: 'axes' and 'figure' are 
            normalized coordinate systems with (0, 0) in the lower left and 
            (1, 1) in the upper right; 'data' are the axes data coordinates 
            (used for the locations of the vectors in the quiver plot itself); 
            'inches' is position in the figure in inches, with (0, 0) at the 
            lower left corner. 
        color : color 
            Overrides face and edge colors from *Q*. 
        labelpos : {'N', 'S', 'E', 'W'} 
            Position the label above, below, to the right, to the left of the 
            arrow, respectively. 
        labelsep : float, default: 0.1 
            Distance in inches between the arrow and the label. 
        labelcolor : color, default: :rc:`text.color` 
            Label color. 
        fontproperties : dict, optional 
            A dictionary with keyword arguments accepted by the 
            `~matplotlib.font_manager.FontProperties` initializer: 
            *family*, *style*, *variant*, *size*, *weight*. 
        **kwargs 
            Any additional keyword arguments are used to override vector 
            properties taken from *Q*. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.Q = Q</span>
        <span class="s1">self.X = X</span>
        <span class="s1">self.Y = Y</span>
        <span class="s1">self.U = U</span>
        <span class="s1">self.angle = angle</span>
        <span class="s1">self.coord = coordinates</span>
        <span class="s1">self.color = color</span>
        <span class="s1">self.label = label</span>
        <span class="s1">self._labelsep_inches = labelsep</span>

        <span class="s1">self.labelpos = labelpos</span>
        <span class="s1">self.labelcolor = labelcolor</span>
        <span class="s1">self.fontproperties = fontproperties </span><span class="s2">or </span><span class="s1">dict()</span>
        <span class="s1">self.kw = kwargs</span>
        <span class="s1">self.text = mtext.Text(</span>
            <span class="s1">text=label</span><span class="s2">,</span>
            <span class="s1">horizontalalignment=self.halign[self.labelpos]</span><span class="s2">,</span>
            <span class="s1">verticalalignment=self.valign[self.labelpos]</span><span class="s2">,</span>
            <span class="s1">fontproperties=self.fontproperties)</span>
        <span class="s2">if </span><span class="s1">self.labelcolor </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.text.set_color(self.labelcolor)</span>
        <span class="s1">self._dpi_at_last_init = </span><span class="s2">None</span>
        <span class="s1">self.zorder = Q.zorder + </span><span class="s4">0.1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">labelsep(self):</span>
        <span class="s2">return </span><span class="s1">self._labelsep_inches * self.Q.axes.figure.dpi</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s2">if True</span><span class="s1">:  </span><span class="s5"># self._dpi_at_last_init != self.axes.figure.dpi</span>
            <span class="s2">if </span><span class="s1">self.Q._dpi_at_last_init != self.Q.axes.figure.dpi:</span>
                <span class="s1">self.Q._init()</span>
            <span class="s1">self._set_transform()</span>
            <span class="s2">with </span><span class="s1">cbook._setattr_cm(self.Q</span><span class="s2">, </span><span class="s1">pivot=self.pivot[self.labelpos]</span><span class="s2">,</span>
                                   <span class="s5"># Hack: save and restore the Umask</span>
                                   <span class="s1">Umask=ma.nomask):</span>
                <span class="s1">u = self.U * np.cos(np.radians(self.angle))</span>
                <span class="s1">v = self.U * np.sin(np.radians(self.angle))</span>
                <span class="s1">angle = (self.Q.angles </span><span class="s2">if </span><span class="s1">isinstance(self.Q.angles</span><span class="s2">, </span><span class="s1">str)</span>
                         <span class="s2">else </span><span class="s3">'uv'</span><span class="s1">)</span>
                <span class="s1">self.verts = self.Q._make_verts(</span>
                    <span class="s1">np.array([u])</span><span class="s2">, </span><span class="s1">np.array([v])</span><span class="s2">, </span><span class="s1">angle)</span>
            <span class="s1">kwargs = self.Q.polykw</span>
            <span class="s1">kwargs.update(self.kw)</span>
            <span class="s1">self.vector = mcollections.PolyCollection(</span>
                <span class="s1">self.verts</span><span class="s2">,</span>
                <span class="s1">offsets=[(self.X</span><span class="s2">, </span><span class="s1">self.Y)]</span><span class="s2">,</span>
                <span class="s1">offset_transform=self.get_transform()</span><span class="s2">,</span>
                <span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">self.color </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.vector.set_color(self.color)</span>
            <span class="s1">self.vector.set_transform(self.Q.get_transform())</span>
            <span class="s1">self.vector.set_figure(self.get_figure())</span>
            <span class="s1">self._dpi_at_last_init = self.Q.axes.figure.dpi</span>

    <span class="s2">def </span><span class="s1">_text_shift(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s3">&quot;N&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s1">+self.labelsep)</span><span class="s2">,</span>
            <span class="s3">&quot;S&quot;</span><span class="s1">: (</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-self.labelsep)</span><span class="s2">,</span>
            <span class="s3">&quot;E&quot;</span><span class="s1">: (+self.labelsep</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;W&quot;</span><span class="s1">: (-self.labelsep</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}[self.labelpos]</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self._init()</span>
        <span class="s1">self.vector.draw(renderer)</span>
        <span class="s1">pos = self.get_transform().transform((self.X</span><span class="s2">, </span><span class="s1">self.Y))</span>
        <span class="s1">self.text.set_position(pos + self._text_shift())</span>
        <span class="s1">self.text.draw(renderer)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">_set_transform(self):</span>
        <span class="s1">self.set_transform(_api.check_getitem({</span>
            <span class="s3">&quot;data&quot;</span><span class="s1">: self.Q.axes.transData</span><span class="s2">,</span>
            <span class="s3">&quot;axes&quot;</span><span class="s1">: self.Q.axes.transAxes</span><span class="s2">,</span>
            <span class="s3">&quot;figure&quot;</span><span class="s1">: self.Q.axes.figure.transFigure</span><span class="s2">,</span>
            <span class="s3">&quot;inches&quot;</span><span class="s1">: self.Q.axes.figure.dpi_scale_trans</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">coordinates=self.coord))</span>

    <span class="s2">def </span><span class="s1">set_figure(self</span><span class="s2">, </span><span class="s1">fig):</span>
        <span class="s1">super().set_figure(fig)</span>
        <span class="s1">self.text.set_figure(fig)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s5"># Maybe the dictionary should allow one to</span>
        <span class="s5"># distinguish between a text hit and a vector hit.</span>
        <span class="s2">if </span><span class="s1">(self.text.contains(mouseevent)[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">self.vector.contains(mouseevent)[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s2">return True, </span><span class="s1">{}</span>
        <span class="s2">return False, </span><span class="s1">{}</span>


<span class="s2">def </span><span class="s1">_parse_args(*args</span><span class="s2">, </span><span class="s1">caller_name=</span><span class="s3">'function'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function to parse positional parameters for colored vector plots. 
 
    This is currently used for Quiver and Barbs. 
 
    Parameters 
    ---------- 
    *args : list 
        list of 2-5 arguments. Depending on their number they are parsed to:: 
 
            U, V 
            U, V, C 
            X, Y, U, V 
            X, Y, U, V, C 
 
    caller_name : str 
        Name of the calling method (used in error messages). 
    &quot;&quot;&quot;</span>
    <span class="s1">X = Y = C = </span><span class="s2">None</span>

    <span class="s1">nargs = len(args)</span>
    <span class="s2">if </span><span class="s1">nargs == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s5"># The use of atleast_1d allows for handling scalar arguments while also</span>
        <span class="s5"># keeping masked arrays</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">V = np.atleast_1d(*args)</span>
    <span class="s2">elif </span><span class="s1">nargs == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C = np.atleast_1d(*args)</span>
    <span class="s2">elif </span><span class="s1">nargs == </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V = np.atleast_1d(*args)</span>
    <span class="s2">elif </span><span class="s1">nargs == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C = np.atleast_1d(*args)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">_api.nargs_error(caller_name</span><span class="s2">, </span><span class="s1">takes=</span><span class="s3">&quot;from 2 to 5&quot;</span><span class="s2">, </span><span class="s1">given=nargs)</span>

    <span class="s1">nr</span><span class="s2">, </span><span class="s1">nc = (</span><span class="s4">1</span><span class="s2">, </span><span class="s1">U.shape[</span><span class="s4">0</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">U.ndim == </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">U.shape</span>

    <span class="s2">if </span><span class="s1">X </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">X = X.ravel()</span>
        <span class="s1">Y = Y.ravel()</span>
        <span class="s2">if </span><span class="s1">len(X) == nc </span><span class="s2">and </span><span class="s1">len(Y) == nr:</span>
            <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = [a.ravel() </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">np.meshgrid(X</span><span class="s2">, </span><span class="s1">Y)]</span>
        <span class="s2">elif </span><span class="s1">len(X) != len(Y):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'X and Y must be the same size, but '</span>
                             <span class="s3">f'X.size is </span><span class="s2">{</span><span class="s1">X.size</span><span class="s2">} </span><span class="s3">and Y.size is </span><span class="s2">{</span><span class="s1">Y.size</span><span class="s2">}</span><span class="s3">.'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">indexgrid = np.meshgrid(np.arange(nc)</span><span class="s2">, </span><span class="s1">np.arange(nr))</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = [np.ravel(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">indexgrid]</span>
    <span class="s5"># Size validation for U, V, C is left to the set_UVC method.</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C</span>


<span class="s2">def </span><span class="s1">_check_consistent_shapes(*arrays):</span>
    <span class="s1">all_shapes = {a.shape </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays}</span>
    <span class="s2">if </span><span class="s1">len(all_shapes) != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'The shapes of the passed in arrays do not match'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Quiver(mcollections.PolyCollection):</span>
    <span class="s0">&quot;&quot;&quot; 
    Specialized PolyCollection for arrows. 
 
    The only API method is set_UVC(), which can be used 
    to change the size, orientation, and color of the 
    arrows; their locations are fixed when the class is 
    instantiated.  Possibly this method will be useful 
    in animations. 
 
    Much of the work in this class is done in the draw() 
    method so that as much information as possible is available 
    about the plot.  In subsequent draw() calls, recalculation 
    is limited to things that might have changed, so there 
    should be no performance penalty from putting the calculations 
    in the draw() method. 
    &quot;&quot;&quot;</span>

    <span class="s1">_PIVOT_VALS = (</span><span class="s3">'tail'</span><span class="s2">, </span><span class="s3">'middle'</span><span class="s2">, </span><span class="s3">'tip'</span><span class="s1">)</span>

    <span class="s1">@_docstring.Substitution(_quiver_doc)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                 <span class="s1">scale=</span><span class="s2">None, </span><span class="s1">headwidth=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">headlength=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">headaxislength=</span><span class="s4">4.5</span><span class="s2">,</span>
                 <span class="s1">minshaft=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">minlength=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">units=</span><span class="s3">'width'</span><span class="s2">, </span><span class="s1">scale_units=</span><span class="s2">None,</span>
                 <span class="s1">angles=</span><span class="s3">'uv'</span><span class="s2">, </span><span class="s1">width=</span><span class="s2">None, </span><span class="s1">color=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">pivot=</span><span class="s3">'tail'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        The constructor takes one required argument, an Axes 
        instance, followed by the args and kwargs described 
        by the following pyplot interface documentation: 
        %s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._axes = ax  </span><span class="s5"># The attr actually set by the Artist.axes property.</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C = _parse_args(*args</span><span class="s2">, </span><span class="s1">caller_name=</span><span class="s3">'quiver'</span><span class="s1">)</span>
        <span class="s1">self.X = X</span>
        <span class="s1">self.Y = Y</span>
        <span class="s1">self.XY = np.column_stack((X</span><span class="s2">, </span><span class="s1">Y))</span>
        <span class="s1">self.N = len(X)</span>
        <span class="s1">self.scale = scale</span>
        <span class="s1">self.headwidth = headwidth</span>
        <span class="s1">self.headlength = float(headlength)</span>
        <span class="s1">self.headaxislength = headaxislength</span>
        <span class="s1">self.minshaft = minshaft</span>
        <span class="s1">self.minlength = minlength</span>
        <span class="s1">self.units = units</span>
        <span class="s1">self.scale_units = scale_units</span>
        <span class="s1">self.angles = angles</span>
        <span class="s1">self.width = width</span>

        <span class="s2">if </span><span class="s1">pivot.lower() == </span><span class="s3">'mid'</span><span class="s1">:</span>
            <span class="s1">pivot = </span><span class="s3">'middle'</span>
        <span class="s1">self.pivot = pivot.lower()</span>
        <span class="s1">_api.check_in_list(self._PIVOT_VALS</span><span class="s2">, </span><span class="s1">pivot=self.pivot)</span>

        <span class="s1">self.transform = kwargs.pop(</span><span class="s3">'transform'</span><span class="s2">, </span><span class="s1">ax.transData)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'facecolors'</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'linewidths'</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">super().__init__([]</span><span class="s2">, </span><span class="s1">offsets=self.XY</span><span class="s2">, </span><span class="s1">offset_transform=self.transform</span><span class="s2">,</span>
                         <span class="s1">closed=</span><span class="s2">False, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.polykw = kwargs</span>
        <span class="s1">self.set_UVC(U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C)</span>
        <span class="s1">self._dpi_at_last_init = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialization delayed until first draw; 
        allow time for axes setup. 
        &quot;&quot;&quot;</span>
        <span class="s5"># It seems that there are not enough event notifications</span>
        <span class="s5"># available to have this work on an as-needed basis at present.</span>
        <span class="s2">if True</span><span class="s1">:  </span><span class="s5"># self._dpi_at_last_init != self.axes.figure.dpi</span>
            <span class="s1">trans = self._set_transform()</span>
            <span class="s1">self.span = trans.inverted().transform_bbox(self.axes.bbox).width</span>
            <span class="s2">if </span><span class="s1">self.width </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">sn = np.clip(math.sqrt(self.N)</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">25</span><span class="s1">)</span>
                <span class="s1">self.width = </span><span class="s4">0.06 </span><span class="s1">* self.span / sn</span>

            <span class="s5"># _make_verts sets self.scale if not already specified</span>
            <span class="s2">if </span><span class="s1">(self._dpi_at_last_init != self.axes.figure.dpi</span>
                    <span class="s2">and </span><span class="s1">self.scale </span><span class="s2">is None</span><span class="s1">):</span>
                <span class="s1">self._make_verts(self.U</span><span class="s2">, </span><span class="s1">self.V</span><span class="s2">, </span><span class="s1">self.angles)</span>

            <span class="s1">self._dpi_at_last_init = self.axes.figure.dpi</span>

    <span class="s2">def </span><span class="s1">get_datalim(self</span><span class="s2">, </span><span class="s1">transData):</span>
        <span class="s1">trans = self.get_transform()</span>
        <span class="s1">offset_trf = self.get_offset_transform()</span>
        <span class="s1">full_transform = (trans - transData) + (offset_trf - transData)</span>
        <span class="s1">XY = full_transform.transform(self.XY)</span>
        <span class="s1">bbox = transforms.Bbox.null()</span>
        <span class="s1">bbox.update_from_data_xy(XY</span><span class="s2">, </span><span class="s1">ignore=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">bbox</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self._init()</span>
        <span class="s1">verts = self._make_verts(self.U</span><span class="s2">, </span><span class="s1">self.V</span><span class="s2">, </span><span class="s1">self.angles)</span>
        <span class="s1">self.set_verts(verts</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">super().draw(renderer)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">set_UVC(self</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5"># We need to ensure we have a copy, not a reference</span>
        <span class="s5"># to an array that might change before draw().</span>
        <span class="s1">U = ma.masked_invalid(U</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>
        <span class="s1">V = ma.masked_invalid(V</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>
        <span class="s2">if </span><span class="s1">C </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">C = ma.masked_invalid(C</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">var </span><span class="s2">in </span><span class="s1">zip((</span><span class="s3">'U'</span><span class="s2">, </span><span class="s3">'V'</span><span class="s2">, </span><span class="s3">'C'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C)):</span>
            <span class="s2">if not </span><span class="s1">(var </span><span class="s2">is None or </span><span class="s1">var.size == self.N </span><span class="s2">or </span><span class="s1">var.size == </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Argument </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">has a size </span><span class="s2">{</span><span class="s1">var.size</span><span class="s2">}</span><span class="s3">'</span>
                                 <span class="s3">f' which does not match </span><span class="s2">{</span><span class="s1">self.N</span><span class="s2">}</span><span class="s3">,'</span>
                                 <span class="s3">' the number of arrow positions'</span><span class="s1">)</span>

        <span class="s1">mask = ma.mask_or(U.mask</span><span class="s2">, </span><span class="s1">V.mask</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">shrink=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">C </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mask = ma.mask_or(mask</span><span class="s2">, </span><span class="s1">C.mask</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False, </span><span class="s1">shrink=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">mask </span><span class="s2">is </span><span class="s1">ma.nomask:</span>
                <span class="s1">C = C.filled()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">C = ma.array(C</span><span class="s2">, </span><span class="s1">mask=mask</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.U = U.filled(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.V = V.filled(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.Umask = mask</span>
        <span class="s2">if </span><span class="s1">C </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_array(C)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_dots_per_unit(self</span><span class="s2">, </span><span class="s1">units):</span>
        <span class="s0">&quot;&quot;&quot;Return a scale factor for converting from units to pixels.&quot;&quot;&quot;</span>
        <span class="s1">bb = self.axes.bbox</span>
        <span class="s1">vl = self.axes.viewLim</span>
        <span class="s2">return </span><span class="s1">_api.check_getitem({</span>
            <span class="s3">'x'</span><span class="s1">: bb.width / vl.width</span><span class="s2">,</span>
            <span class="s3">'y'</span><span class="s1">: bb.height / vl.height</span><span class="s2">,</span>
            <span class="s3">'xy'</span><span class="s1">: np.hypot(*bb.size) / np.hypot(*vl.size)</span><span class="s2">,</span>
            <span class="s3">'width'</span><span class="s1">: bb.width</span><span class="s2">,</span>
            <span class="s3">'height'</span><span class="s1">: bb.height</span><span class="s2">,</span>
            <span class="s3">'dots'</span><span class="s1">: </span><span class="s4">1.</span><span class="s2">,</span>
            <span class="s3">'inches'</span><span class="s1">: self.axes.figure.dpi</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">units=units)</span>

    <span class="s2">def </span><span class="s1">_set_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the PolyCollection transform to go 
        from arrow width units to pixels. 
        &quot;&quot;&quot;</span>
        <span class="s1">dx = self._dots_per_unit(self.units)</span>
        <span class="s1">self._trans_scale = dx  </span><span class="s5"># pixels per arrow width unit</span>
        <span class="s1">trans = transforms.Affine2D().scale(dx)</span>
        <span class="s1">self.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">trans</span>

    <span class="s2">def </span><span class="s1">_angles_lengths(self</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">eps=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">xy = self.axes.transData.transform(self.XY)</span>
        <span class="s1">uv = np.column_stack((U</span><span class="s2">, </span><span class="s1">V))</span>
        <span class="s1">xyp = self.axes.transData.transform(self.XY + eps * uv)</span>
        <span class="s1">dxy = xyp - xy</span>
        <span class="s1">angles = np.arctan2(dxy[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dxy[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">lengths = np.hypot(*dxy.T) / eps</span>
        <span class="s2">return </span><span class="s1">angles</span><span class="s2">, </span><span class="s1">lengths</span>

    <span class="s2">def </span><span class="s1">_make_verts(self</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">angles):</span>
        <span class="s1">uv = (U + V * </span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">str_angles = angles </span><span class="s2">if </span><span class="s1">isinstance(angles</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">str_angles == </span><span class="s3">'xy' </span><span class="s2">and </span><span class="s1">self.scale_units == </span><span class="s3">'xy'</span><span class="s1">:</span>
            <span class="s5"># Here eps is 1 so that if we get U, V by diffing</span>
            <span class="s5"># the X, Y arrays, the vectors will connect the</span>
            <span class="s5"># points, regardless of the axis scaling (including log).</span>
            <span class="s1">angles</span><span class="s2">, </span><span class="s1">lengths = self._angles_lengths(U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">eps=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">str_angles == </span><span class="s3">'xy' </span><span class="s2">or </span><span class="s1">self.scale_units == </span><span class="s3">'xy'</span><span class="s1">:</span>
            <span class="s5"># Calculate eps based on the extents of the plot</span>
            <span class="s5"># so that we don't end up with roundoff error from</span>
            <span class="s5"># adding a small number to a large.</span>
            <span class="s1">eps = np.abs(self.axes.dataLim.extents).max() * </span><span class="s4">0.001</span>
            <span class="s1">angles</span><span class="s2">, </span><span class="s1">lengths = self._angles_lengths(U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">eps=eps)</span>
        <span class="s2">if </span><span class="s1">str_angles </span><span class="s2">and </span><span class="s1">self.scale_units == </span><span class="s3">'xy'</span><span class="s1">:</span>
            <span class="s1">a = lengths</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = np.abs(uv)</span>
        <span class="s2">if </span><span class="s1">self.scale </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">sn = max(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">math.sqrt(self.N))</span>
            <span class="s2">if </span><span class="s1">self.Umask </span><span class="s2">is not </span><span class="s1">ma.nomask:</span>
                <span class="s1">amean = a[~self.Umask].mean()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">amean = a.mean()</span>
            <span class="s5"># crude auto-scaling</span>
            <span class="s5"># scale is typical arrow length as a multiple of the arrow width</span>
            <span class="s1">scale = </span><span class="s4">1.8 </span><span class="s1">* amean * sn / self.span</span>
        <span class="s2">if </span><span class="s1">self.scale_units </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.scale </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.scale = scale</span>
            <span class="s1">widthu_per_lenu = </span><span class="s4">1.0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.scale_units == </span><span class="s3">'xy'</span><span class="s1">:</span>
                <span class="s1">dx = </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dx = self._dots_per_unit(self.scale_units)</span>
            <span class="s1">widthu_per_lenu = dx / self._trans_scale</span>
            <span class="s2">if </span><span class="s1">self.scale </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.scale = scale * widthu_per_lenu</span>
        <span class="s1">length = a * (widthu_per_lenu / (self.scale * self.width))</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = self._h_arrows(length)</span>
        <span class="s2">if </span><span class="s1">str_angles == </span><span class="s3">'xy'</span><span class="s1">:</span>
            <span class="s1">theta = angles</span>
        <span class="s2">elif </span><span class="s1">str_angles == </span><span class="s3">'uv'</span><span class="s1">:</span>
            <span class="s1">theta = np.angle(uv)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">theta = ma.masked_invalid(np.deg2rad(angles)).filled(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">theta = theta.reshape((-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))  </span><span class="s5"># for broadcasting</span>
        <span class="s1">xy = (X + Y * </span><span class="s4">1j</span><span class="s1">) * np.exp(</span><span class="s4">1j </span><span class="s1">* theta) * self.width</span>
        <span class="s1">XY = np.stack((xy.real</span><span class="s2">, </span><span class="s1">xy.imag)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.Umask </span><span class="s2">is not </span><span class="s1">ma.nomask:</span>
            <span class="s1">XY = ma.array(XY)</span>
            <span class="s1">XY[self.Umask] = ma.masked</span>
            <span class="s5"># This might be handled more efficiently with nans, given</span>
            <span class="s5"># that nans will end up in the paths anyway.</span>

        <span class="s2">return </span><span class="s1">XY</span>

    <span class="s2">def </span><span class="s1">_h_arrows(self</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0">&quot;&quot;&quot;Length is in arrow width units.&quot;&quot;&quot;</span>
        <span class="s5"># It might be possible to streamline the code</span>
        <span class="s5"># and speed it up a bit by using complex (x, y)</span>
        <span class="s5"># instead of separate arrays; but any gain would be slight.</span>
        <span class="s1">minsh = self.minshaft * self.headlength</span>
        <span class="s1">N = len(length)</span>
        <span class="s1">length = length.reshape(N</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s5"># This number is chosen based on when pixel values overflow in Agg</span>
        <span class="s5"># causing rendering errors</span>
        <span class="s5"># length = np.minimum(length, 2 ** 16)</span>
        <span class="s1">np.clip(length</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">16</span><span class="s2">, </span><span class="s1">out=length)</span>
        <span class="s5"># x, y: normal horizontal arrow</span>
        <span class="s1">x = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-self.headaxislength</span><span class="s2">,</span>
                      <span class="s1">-self.headlength</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">np.float64)</span>
        <span class="s1">x = x + np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]) * length</span>
        <span class="s1">y = </span><span class="s4">0.5 </span><span class="s1">* np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.headwidth</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">y = np.repeat(y[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># x0, y0: arrow without shaft, for short vectors</span>
        <span class="s1">x0 = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s1">minsh - self.headaxislength</span><span class="s2">,</span>
                       <span class="s1">minsh - self.headlength</span><span class="s2">, </span><span class="s1">minsh]</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">y0 = </span><span class="s4">0.5 </span><span class="s1">* np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self.headwidth</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">ii = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">X = x[:</span><span class="s2">, </span><span class="s1">ii]</span>
        <span class="s1">Y = y[:</span><span class="s2">, </span><span class="s1">ii]</span>
        <span class="s1">Y[:</span><span class="s2">, </span><span class="s4">3</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">] *= -</span><span class="s4">1</span>
        <span class="s1">X0 = x0[ii]</span>
        <span class="s1">Y0 = y0[ii]</span>
        <span class="s1">Y0[</span><span class="s4">3</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">] *= -</span><span class="s4">1</span>
        <span class="s1">shrink = length / minsh </span><span class="s2">if </span><span class="s1">minsh != </span><span class="s4">0. </span><span class="s2">else </span><span class="s4">0.</span>
        <span class="s1">X0 = shrink * X0[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">Y0 = shrink * Y0[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">short = np.repeat(length &lt; minsh</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s5"># Now select X0, Y0 if short, otherwise X, Y</span>
        <span class="s1">np.copyto(X</span><span class="s2">, </span><span class="s1">X0</span><span class="s2">, </span><span class="s1">where=short)</span>
        <span class="s1">np.copyto(Y</span><span class="s2">, </span><span class="s1">Y0</span><span class="s2">, </span><span class="s1">where=short)</span>
        <span class="s2">if </span><span class="s1">self.pivot == </span><span class="s3">'middle'</span><span class="s1">:</span>
            <span class="s1">X -= </span><span class="s4">0.5 </span><span class="s1">* X[:</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
        <span class="s2">elif </span><span class="s1">self.pivot == </span><span class="s3">'tip'</span><span class="s1">:</span>
            <span class="s5"># numpy bug? using -= does not work here unless we multiply by a</span>
            <span class="s5"># float first, as with 'mid'.</span>
            <span class="s1">X = X - X[:</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
        <span class="s2">elif </span><span class="s1">self.pivot != </span><span class="s3">'tail'</span><span class="s1">:</span>
            <span class="s1">_api.check_in_list([</span><span class="s3">&quot;middle&quot;</span><span class="s2">, </span><span class="s3">&quot;tip&quot;</span><span class="s2">, </span><span class="s3">&quot;tail&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pivot=self.pivot)</span>

        <span class="s1">tooshort = length &lt; self.minlength</span>
        <span class="s2">if </span><span class="s1">tooshort.any():</span>
            <span class="s5"># Use a heptagonal dot:</span>
            <span class="s1">th = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.float64) * (np.pi / </span><span class="s4">3.0</span><span class="s1">)</span>
            <span class="s1">x1 = np.cos(th) * self.minlength * </span><span class="s4">0.5</span>
            <span class="s1">y1 = np.sin(th) * self.minlength * </span><span class="s4">0.5</span>
            <span class="s1">X1 = np.repeat(x1[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">Y1 = np.repeat(y1[np.newaxis</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">tooshort = np.repeat(tooshort</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">np.copyto(X</span><span class="s2">, </span><span class="s1">X1</span><span class="s2">, </span><span class="s1">where=tooshort)</span>
            <span class="s1">np.copyto(Y</span><span class="s2">, </span><span class="s1">Y1</span><span class="s2">, </span><span class="s1">where=tooshort)</span>
        <span class="s5"># Mask handling is deferred to the caller, _make_verts.</span>
        <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span>

    <span class="s1">quiver_doc = _api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: _quiver_doc))</span>


<span class="s1">_barbs_doc = </span><span class="s3">r&quot;&quot;&quot; 
Plot a 2D field of barbs. 
 
Call signature:: 
 
  barbs([X, Y], U, V, [C], **kwargs) 
 
Where *X*, *Y* define the barb locations, *U*, *V* define the barb 
directions, and *C* optionally sets the color. 
 
All arguments may be 1D or 2D. *U*, *V*, *C* may be masked arrays, but masked 
*X*, *Y* are not supported at present. 
 
Barbs are traditionally used in meteorology as a way to plot the speed 
and direction of wind observations, but can technically be used to 
plot any two dimensional vector quantity.  As opposed to arrows, which 
give vector magnitude by the length of the arrow, the barbs give more 
quantitative information about the vector magnitude by putting slanted 
lines or a triangle for various increments in magnitude, as show 
schematically below:: 
 
  :                   /\    \ 
  :                  /  \    \ 
  :                 /    \    \    \ 
  :                /      \    \    \ 
  :               ------------------------------ 
 
The largest increment is given by a triangle (or &quot;flag&quot;). After those 
come full lines (barbs). The smallest increment is a half line.  There 
is only, of course, ever at most 1 half line.  If the magnitude is 
small and only needs a single half-line and no full lines or 
triangles, the half-line is offset from the end of the barb so that it 
can be easily distinguished from barbs with a single full line.  The 
magnitude for the barb shown above would nominally be 65, using the 
standard increments of 50, 10, and 5. 
 
See also https://en.wikipedia.org/wiki/Wind_barb. 
 
Parameters 
---------- 
X, Y : 1D or 2D array-like, optional 
    The x and y coordinates of the barb locations. See *pivot* for how the 
    barbs are drawn to the x, y positions. 
 
    If not given, they will be generated as a uniform integer meshgrid based 
    on the dimensions of *U* and *V*. 
 
    If *X* and *Y* are 1D but *U*, *V* are 2D, *X*, *Y* are expanded to 2D 
    using ``X, Y = np.meshgrid(X, Y)``. In this case ``len(X)`` and ``len(Y)`` 
    must match the column and row dimensions of *U* and *V*. 
 
U, V : 1D or 2D array-like 
    The x and y components of the barb shaft. 
 
C : 1D or 2D array-like, optional 
    Numeric data that defines the barb colors by colormapping via *norm* and 
    *cmap*. 
 
    This does not support explicit colors. If you want to set colors directly, 
    use *barbcolor* instead. 
 
length : float, default: 7 
    Length of the barb in points; the other parts of the barb 
    are scaled against this. 
 
pivot : {'tip', 'middle'} or float, default: 'tip' 
    The part of the arrow that is anchored to the *X*, *Y* grid. The barb 
    rotates about this point. This can also be a number, which shifts the 
    start of the barb that many points away from grid point. 
 
barbcolor : color or color sequence 
    The color of all parts of the barb except for the flags.  This parameter 
    is analogous to the *edgecolor* parameter for polygons, which can be used 
    instead. However this parameter will override facecolor. 
 
flagcolor : color or color sequence 
    The color of any flags on the barb.  This parameter is analogous to the 
    *facecolor* parameter for polygons, which can be used instead. However, 
    this parameter will override facecolor.  If this is not set (and *C* has 
    not either) then *flagcolor* will be set to match *barbcolor* so that the 
    barb has a uniform color. If *C* has been set, *flagcolor* has no effect. 
 
sizes : dict, optional 
    A dictionary of coefficients specifying the ratio of a given 
    feature to the length of the barb. Only those values one wishes to 
    override need to be included.  These features include: 
 
    - 'spacing' - space between features (flags, full/half barbs) 
    - 'height' - height (distance from shaft to top) of a flag or full barb 
    - 'width' - width of a flag, twice the width of a full barb 
    - 'emptybarb' - radius of the circle used for low magnitudes 
 
fill_empty : bool, default: False 
    Whether the empty barbs (circles) that are drawn should be filled with 
    the flag color.  If they are not filled, the center is transparent. 
 
rounding : bool, default: True 
    Whether the vector magnitude should be rounded when allocating barb 
    components.  If True, the magnitude is rounded to the nearest multiple 
    of the half-barb increment.  If False, the magnitude is simply truncated 
    to the next lowest multiple. 
 
barb_increments : dict, optional 
    A dictionary of increments specifying values to associate with 
    different parts of the barb. Only those values one wishes to 
    override need to be included. 
 
    - 'half' - half barbs (Default is 5) 
    - 'full' - full barbs (Default is 10) 
    - 'flag' - flags (default is 50) 
 
flip_barb : bool or array-like of bool, default: False 
    Whether the lines and flags should point opposite to normal. 
    Normal behavior is for the barbs and lines to point right (comes from wind 
    barbs having these features point towards low pressure in the Northern 
    Hemisphere). 
 
    A single value is applied to all barbs. Individual barbs can be flipped by 
    passing a bool array of the same size as *U* and *V*. 
 
Returns 
------- 
barbs : `~matplotlib.quiver.Barbs` 
 
Other Parameters 
---------------- 
data : indexable object, optional 
    DATA_PARAMETER_PLACEHOLDER 
 
**kwargs 
    The barbs can further be customized using `.PolyCollection` keyword 
    arguments: 
 
    %(PolyCollection:kwdoc)s 
&quot;&quot;&quot; </span><span class="s1">% _docstring.interpd.params</span>

<span class="s1">_docstring.interpd.update(barbs_doc=_barbs_doc)</span>


<span class="s2">class </span><span class="s1">Barbs(mcollections.PolyCollection):</span>
    <span class="s0">&quot;&quot;&quot; 
    Specialized PolyCollection for barbs. 
 
    The only API method is :meth:`set_UVC`, which can be used to 
    change the size, orientation, and color of the arrows.  Locations 
    are changed using the :meth:`set_offsets` collection method. 
    Possibly this method will be useful in animations. 
 
    There is one internal function :meth:`_find_tails` which finds 
    exactly what should be put on the barb given the vector magnitude. 
    From there :meth:`_make_barbs` is used to find the vertices of the 
    polygon to represent the barb based on this information. 
    &quot;&quot;&quot;</span>

    <span class="s5"># This may be an abuse of polygons here to render what is essentially maybe</span>
    <span class="s5"># 1 triangle and a series of lines.  It works fine as far as I can tell</span>
    <span class="s5"># however.</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                 <span class="s1">pivot=</span><span class="s3">'tip'</span><span class="s2">, </span><span class="s1">length=</span><span class="s4">7</span><span class="s2">, </span><span class="s1">barbcolor=</span><span class="s2">None, </span><span class="s1">flagcolor=</span><span class="s2">None,</span>
                 <span class="s1">sizes=</span><span class="s2">None, </span><span class="s1">fill_empty=</span><span class="s2">False, </span><span class="s1">barb_increments=</span><span class="s2">None,</span>
                 <span class="s1">rounding=</span><span class="s2">True, </span><span class="s1">flip_barb=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        The constructor takes one required argument, an Axes 
        instance, followed by the args and kwargs described 
        by the following pyplot interface documentation: 
        %(barbs_doc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self.sizes = sizes </span><span class="s2">or </span><span class="s1">dict()</span>
        <span class="s1">self.fill_empty = fill_empty</span>
        <span class="s1">self.barb_increments = barb_increments </span><span class="s2">or </span><span class="s1">dict()</span>
        <span class="s1">self.rounding = rounding</span>
        <span class="s1">self.flip = np.atleast_1d(flip_barb)</span>
        <span class="s1">transform = kwargs.pop(</span><span class="s3">'transform'</span><span class="s2">, </span><span class="s1">ax.transData)</span>
        <span class="s1">self._pivot = pivot</span>
        <span class="s1">self._length = length</span>

        <span class="s5"># Flagcolor and barbcolor provide convenience parameters for</span>
        <span class="s5"># setting the facecolor and edgecolor, respectively, of the barb</span>
        <span class="s5"># polygon.  We also work here to make the flag the same color as the</span>
        <span class="s5"># rest of the barb by default</span>

        <span class="s2">if None in </span><span class="s1">(barbcolor</span><span class="s2">, </span><span class="s1">flagcolor):</span>
            <span class="s1">kwargs[</span><span class="s3">'edgecolors'</span><span class="s1">] = </span><span class="s3">'face'</span>
            <span class="s2">if </span><span class="s1">flagcolor:</span>
                <span class="s1">kwargs[</span><span class="s3">'facecolors'</span><span class="s1">] = flagcolor</span>
            <span class="s2">elif </span><span class="s1">barbcolor:</span>
                <span class="s1">kwargs[</span><span class="s3">'facecolors'</span><span class="s1">] = barbcolor</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># Set to facecolor passed in or default to black</span>
                <span class="s1">kwargs.setdefault(</span><span class="s3">'facecolors'</span><span class="s2">, </span><span class="s3">'k'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'edgecolors'</span><span class="s1">] = barbcolor</span>
            <span class="s1">kwargs[</span><span class="s3">'facecolors'</span><span class="s1">] = flagcolor</span>

        <span class="s5"># Explicitly set a line width if we're not given one, otherwise</span>
        <span class="s5"># polygons are not outlined and we get no barbs</span>
        <span class="s2">if </span><span class="s3">'linewidth' </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s3">'lw' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s3">'linewidth'</span><span class="s1">] = </span><span class="s4">1</span>

        <span class="s5"># Parse out the data arrays from the various configurations supported</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c = _parse_args(*args</span><span class="s2">, </span><span class="s1">caller_name=</span><span class="s3">'barbs'</span><span class="s1">)</span>
        <span class="s1">self.x = x</span>
        <span class="s1">self.y = y</span>
        <span class="s1">xy = np.column_stack((x</span><span class="s2">, </span><span class="s1">y))</span>

        <span class="s5"># Make a collection</span>
        <span class="s1">barb_size = self._length ** </span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">4  </span><span class="s5"># Empirically determined</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">[]</span><span class="s2">, </span><span class="s1">(barb_size</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">offsets=xy</span><span class="s2">, </span><span class="s1">offset_transform=transform</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_transform(transforms.IdentityTransform())</span>

        <span class="s1">self.set_UVC(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c)</span>

    <span class="s2">def </span><span class="s1">_find_tails(self</span><span class="s2">, </span><span class="s1">mag</span><span class="s2">, </span><span class="s1">rounding=</span><span class="s2">True, </span><span class="s1">half=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">full=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">flag=</span><span class="s4">50</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find how many of each of the tail pieces is necessary. 
 
        Parameters 
        ---------- 
        mag : `~numpy.ndarray` 
            Vector magnitudes; must be non-negative (and an actual ndarray). 
        rounding : bool, default: True 
            Whether to round or to truncate to the nearest half-barb. 
        half, full, flag : float, defaults: 5, 10, 50 
            Increments for a half-barb, a barb, and a flag. 
 
        Returns 
        ------- 
        n_flags, n_barbs : int array 
            For each entry in *mag*, the number of flags and barbs. 
        half_flag : bool array 
            For each entry in *mag*, whether a half-barb is needed. 
        empty_flag : bool array 
            For each entry in *mag*, whether nothing is drawn. 
        &quot;&quot;&quot;</span>
        <span class="s5"># If rounding, round to the nearest multiple of half, the smallest</span>
        <span class="s5"># increment</span>
        <span class="s2">if </span><span class="s1">rounding:</span>
            <span class="s1">mag = half * np.around(mag / half)</span>
        <span class="s1">n_flags</span><span class="s2">, </span><span class="s1">mag = divmod(mag</span><span class="s2">, </span><span class="s1">flag)</span>
        <span class="s1">n_barb</span><span class="s2">, </span><span class="s1">mag = divmod(mag</span><span class="s2">, </span><span class="s1">full)</span>
        <span class="s1">half_flag = mag &gt;= half</span>
        <span class="s1">empty_flag = ~(half_flag | (n_flags &gt; </span><span class="s4">0</span><span class="s1">) | (n_barb &gt; </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">n_flags.astype(int)</span><span class="s2">, </span><span class="s1">n_barb.astype(int)</span><span class="s2">, </span><span class="s1">half_flag</span><span class="s2">, </span><span class="s1">empty_flag</span>

    <span class="s2">def </span><span class="s1">_make_barbs(self</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">nflags</span><span class="s2">, </span><span class="s1">nbarbs</span><span class="s2">, </span><span class="s1">half_barb</span><span class="s2">, </span><span class="s1">empty_flag</span><span class="s2">, </span><span class="s1">length</span><span class="s2">,</span>
                    <span class="s1">pivot</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">fill_empty</span><span class="s2">, </span><span class="s1">flip):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create the wind barbs. 
 
        Parameters 
        ---------- 
        u, v 
            Components of the vector in the x and y directions, respectively. 
 
        nflags, nbarbs, half_barb, empty_flag 
            Respectively, the number of flags, number of barbs, flag for 
            half a barb, and flag for empty barb, ostensibly obtained from 
            :meth:`_find_tails`. 
 
        length 
            The length of the barb staff in points. 
 
        pivot : {&quot;tip&quot;, &quot;middle&quot;} or number 
            The point on the barb around which the entire barb should be 
            rotated.  If a number, the start of the barb is shifted by that 
            many points from the origin. 
 
        sizes : dict 
            Coefficients specifying the ratio of a given feature to the length 
            of the barb. These features include: 
 
            - *spacing*: space between features (flags, full/half barbs). 
            - *height*: distance from shaft of top of a flag or full barb. 
            - *width*: width of a flag, twice the width of a full barb. 
            - *emptybarb*: radius of the circle used for low magnitudes. 
 
        fill_empty : bool 
            Whether the circle representing an empty barb should be filled or 
            not (this changes the drawing of the polygon). 
 
        flip : list of bool 
            Whether the features should be flipped to the other side of the 
            barb (useful for winds in the southern hemisphere). 
 
        Returns 
        ------- 
        list of arrays of vertices 
            Polygon vertices for each of the wind barbs.  These polygons have 
            been rotated to properly align with the vector direction. 
        &quot;&quot;&quot;</span>

        <span class="s5"># These control the spacing and size of barb elements relative to the</span>
        <span class="s5"># length of the shaft</span>
        <span class="s1">spacing = length * sizes.get(</span><span class="s3">'spacing'</span><span class="s2">, </span><span class="s4">0.125</span><span class="s1">)</span>
        <span class="s1">full_height = length * sizes.get(</span><span class="s3">'height'</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">)</span>
        <span class="s1">full_width = length * sizes.get(</span><span class="s3">'width'</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">empty_rad = length * sizes.get(</span><span class="s3">'emptybarb'</span><span class="s2">, </span><span class="s4">0.15</span><span class="s1">)</span>

        <span class="s5"># Controls y point where to pivot the barb.</span>
        <span class="s1">pivot_points = dict(tip=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">middle=-length / </span><span class="s4">2.</span><span class="s1">)</span>

        <span class="s1">endx = </span><span class="s4">0.0</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">endy = float(pivot)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s1">endy = pivot_points[pivot.lower()]</span>

        <span class="s5"># Get the appropriate angle for the vector components.  The offset is</span>
        <span class="s5"># due to the way the barb is initially drawn, going down the y-axis.</span>
        <span class="s5"># This makes sense in a meteorological mode of thinking since there 0</span>
        <span class="s5"># degrees corresponds to north (the y-axis traditionally)</span>
        <span class="s1">angles = -(ma.arctan2(v</span><span class="s2">, </span><span class="s1">u) + np.pi / </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s5"># Used for low magnitude.  We just get the vertices, so if we make it</span>
        <span class="s5"># out here, it can be reused.  The center set here should put the</span>
        <span class="s5"># center of the circle at the location(offset), rather than at the</span>
        <span class="s5"># same point as the barb pivot; this seems more sensible.</span>
        <span class="s1">circ = CirclePolygon((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">radius=empty_rad).get_verts()</span>
        <span class="s2">if </span><span class="s1">fill_empty:</span>
            <span class="s1">empty_barb = circ</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># If we don't want the empty one filled, we make a degenerate</span>
            <span class="s5"># polygon that wraps back over itself</span>
            <span class="s1">empty_barb = np.concatenate((circ</span><span class="s2">, </span><span class="s1">circ[::-</span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s1">barb_list = []</span>
        <span class="s2">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">angle </span><span class="s2">in </span><span class="s1">np.ndenumerate(angles):</span>
            <span class="s5"># If the vector magnitude is too weak to draw anything, plot an</span>
            <span class="s5"># empty circle instead</span>
            <span class="s2">if </span><span class="s1">empty_flag[index]:</span>
                <span class="s5"># We can skip the transform since the circle has no preferred</span>
                <span class="s5"># orientation</span>
                <span class="s1">barb_list.append(empty_barb)</span>
                <span class="s2">continue</span>

            <span class="s1">poly_verts = [(endx</span><span class="s2">, </span><span class="s1">endy)]</span>
            <span class="s1">offset = length</span>

            <span class="s5"># Handle if this barb should be flipped</span>
            <span class="s1">barb_height = -full_height </span><span class="s2">if </span><span class="s1">flip[index] </span><span class="s2">else </span><span class="s1">full_height</span>

            <span class="s5"># Add vertices for each flag</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nflags[index]):</span>
                <span class="s5"># The spacing that works for the barbs is a little to much for</span>
                <span class="s5"># the flags, but this only occurs when we have more than 1</span>
                <span class="s5"># flag.</span>
                <span class="s2">if </span><span class="s1">offset != length:</span>
                    <span class="s1">offset += spacing / </span><span class="s4">2.</span>
                <span class="s1">poly_verts.extend(</span>
                    <span class="s1">[[endx</span><span class="s2">, </span><span class="s1">endy + offset]</span><span class="s2">,</span>
                     <span class="s1">[endx + barb_height</span><span class="s2">, </span><span class="s1">endy - full_width / </span><span class="s4">2 </span><span class="s1">+ offset]</span><span class="s2">,</span>
                     <span class="s1">[endx</span><span class="s2">, </span><span class="s1">endy - full_width + offset]])</span>

                <span class="s1">offset -= full_width + spacing</span>

            <span class="s5"># Add vertices for each barb.  These really are lines, but works</span>
            <span class="s5"># great adding 3 vertices that basically pull the polygon out and</span>
            <span class="s5"># back down the line</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nbarbs[index]):</span>
                <span class="s1">poly_verts.extend(</span>
                    <span class="s1">[(endx</span><span class="s2">, </span><span class="s1">endy + offset)</span><span class="s2">,</span>
                     <span class="s1">(endx + barb_height</span><span class="s2">, </span><span class="s1">endy + offset + full_width / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">(endx</span><span class="s2">, </span><span class="s1">endy + offset)])</span>

                <span class="s1">offset -= spacing</span>

            <span class="s5"># Add the vertices for half a barb, if needed</span>
            <span class="s2">if </span><span class="s1">half_barb[index]:</span>
                <span class="s5"># If the half barb is the first on the staff, traditionally it</span>
                <span class="s5"># is offset from the end to make it easy to distinguish from a</span>
                <span class="s5"># barb with a full one</span>
                <span class="s2">if </span><span class="s1">offset == length:</span>
                    <span class="s1">poly_verts.append((endx</span><span class="s2">, </span><span class="s1">endy + offset))</span>
                    <span class="s1">offset -= </span><span class="s4">1.5 </span><span class="s1">* spacing</span>
                <span class="s1">poly_verts.extend(</span>
                    <span class="s1">[(endx</span><span class="s2">, </span><span class="s1">endy + offset)</span><span class="s2">,</span>
                     <span class="s1">(endx + barb_height / </span><span class="s4">2</span><span class="s2">, </span><span class="s1">endy + offset + full_width / </span><span class="s4">4</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">(endx</span><span class="s2">, </span><span class="s1">endy + offset)])</span>

            <span class="s5"># Rotate the barb according the angle. Making the barb first and</span>
            <span class="s5"># then rotating it made the math for drawing the barb really easy.</span>
            <span class="s5"># Also, the transform framework makes doing the rotation simple.</span>
            <span class="s1">poly_verts = transforms.Affine2D().rotate(-angle).transform(</span>
                <span class="s1">poly_verts)</span>
            <span class="s1">barb_list.append(poly_verts)</span>

        <span class="s2">return </span><span class="s1">barb_list</span>

    <span class="s2">def </span><span class="s1">set_UVC(self</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">C=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5"># We need to ensure we have a copy, not a reference to an array that</span>
        <span class="s5"># might change before draw().</span>
        <span class="s1">self.u = ma.masked_invalid(U</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>
        <span class="s1">self.v = ma.masked_invalid(V</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>

        <span class="s5"># Flip needs to have the same number of entries as everything else.</span>
        <span class="s5"># Use broadcast_to to avoid a bloated array of identical values.</span>
        <span class="s5"># (can't rely on actual broadcasting)</span>
        <span class="s2">if </span><span class="s1">len(self.flip) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">flip = np.broadcast_to(self.flip</span><span class="s2">, </span><span class="s1">self.u.shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">flip = self.flip</span>

        <span class="s2">if </span><span class="s1">C </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">c = ma.masked_invalid(C</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">).ravel()</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">flip = cbook.delete_masked_points(</span>
                <span class="s1">self.x.ravel()</span><span class="s2">, </span><span class="s1">self.y.ravel()</span><span class="s2">, </span><span class="s1">self.u</span><span class="s2">, </span><span class="s1">self.v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">,</span>
                <span class="s1">flip.ravel())</span>
            <span class="s1">_check_consistent_shapes(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">flip)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">flip = cbook.delete_masked_points(</span>
                <span class="s1">self.x.ravel()</span><span class="s2">, </span><span class="s1">self.y.ravel()</span><span class="s2">, </span><span class="s1">self.u</span><span class="s2">, </span><span class="s1">self.v</span><span class="s2">, </span><span class="s1">flip.ravel())</span>
            <span class="s1">_check_consistent_shapes(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">flip)</span>

        <span class="s1">magnitude = np.hypot(u</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">flags</span><span class="s2">, </span><span class="s1">barbs</span><span class="s2">, </span><span class="s1">halves</span><span class="s2">, </span><span class="s1">empty = self._find_tails(</span>
            <span class="s1">magnitude</span><span class="s2">, </span><span class="s1">self.rounding</span><span class="s2">, </span><span class="s1">**self.barb_increments)</span>

        <span class="s5"># Get the vertices for each of the barbs</span>

        <span class="s1">plot_barbs = self._make_barbs(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">barbs</span><span class="s2">, </span><span class="s1">halves</span><span class="s2">, </span><span class="s1">empty</span><span class="s2">,</span>
                                      <span class="s1">self._length</span><span class="s2">, </span><span class="s1">self._pivot</span><span class="s2">, </span><span class="s1">self.sizes</span><span class="s2">,</span>
                                      <span class="s1">self.fill_empty</span><span class="s2">, </span><span class="s1">flip)</span>
        <span class="s1">self.set_verts(plot_barbs)</span>

        <span class="s5"># Set the color array</span>
        <span class="s2">if </span><span class="s1">C </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_array(c)</span>

        <span class="s5"># Update the offsets in case the masked data changed</span>
        <span class="s1">xy = np.column_stack((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">self._offsets = xy</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_offsets(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offsets for the barb polygons.  This saves the offsets passed 
        in and masks them as appropriate for the existing U/V data. 
 
        Parameters 
        ---------- 
        xy : sequence of pairs of floats 
        &quot;&quot;&quot;</span>
        <span class="s1">self.x = xy[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.y = xy[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v = cbook.delete_masked_points(</span>
            <span class="s1">self.x.ravel()</span><span class="s2">, </span><span class="s1">self.y.ravel()</span><span class="s2">, </span><span class="s1">self.u</span><span class="s2">, </span><span class="s1">self.v)</span>
        <span class="s1">_check_consistent_shapes(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">xy = np.column_stack((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">super().set_offsets(xy)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">barbs_doc = _api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: _barbs_doc))</span>
</pre>
</body>
</html>