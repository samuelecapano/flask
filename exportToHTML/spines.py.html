<html>
<head>
<title>spines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
spines.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">MutableMapping</span>
<span class="s0">import </span><span class="s1">functools</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">_docstring</span>
<span class="s0">from </span><span class="s1">matplotlib.artist </span><span class="s0">import </span><span class="s1">allow_rasterization</span>
<span class="s0">import </span><span class="s1">matplotlib.transforms </span><span class="s0">as </span><span class="s1">mtransforms</span>
<span class="s0">import </span><span class="s1">matplotlib.patches </span><span class="s0">as </span><span class="s1">mpatches</span>
<span class="s0">import </span><span class="s1">matplotlib.path </span><span class="s0">as </span><span class="s1">mpath</span>


<span class="s0">class </span><span class="s1">Spine(mpatches.Patch):</span>
    <span class="s2">&quot;&quot;&quot; 
    An axis spine -- the line noting the data area boundaries. 
 
    Spines are the lines connecting the axis tick marks and noting the 
    boundaries of the data area. They can be placed at arbitrary 
    positions. See `~.Spine.set_position` for more information. 
 
    The default position is ``('outward', 0)``. 
 
    Spines are subclasses of `.Patch`, and inherit much of their behavior. 
 
    Spines draw a line, a circle, or an arc depending on if 
    `~.Spine.set_patch_line`, `~.Spine.set_patch_circle`, or 
    `~.Spine.set_patch_arc` has been called. Line-like is the default. 
 
    For examples see :ref:`spines_examples`. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s3">&quot;Spine&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axes : `~matplotlib.axes.Axes` 
            The `~.axes.Axes` instance containing the spine. 
        spine_type : str 
            The spine type. 
        path : `~matplotlib.path.Path` 
            The `.Path` instance used to draw the spine. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            Valid keyword arguments are: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.axes = axes</span>
        <span class="s1">self.set_figure(self.axes.figure)</span>
        <span class="s1">self.spine_type = spine_type</span>
        <span class="s1">self.set_facecolor(</span><span class="s3">'none'</span><span class="s1">)</span>
        <span class="s1">self.set_edgecolor(mpl.rcParams[</span><span class="s3">'axes.edgecolor'</span><span class="s1">])</span>
        <span class="s1">self.set_linewidth(mpl.rcParams[</span><span class="s3">'axes.linewidth'</span><span class="s1">])</span>
        <span class="s1">self.set_capstyle(</span><span class="s3">'projecting'</span><span class="s1">)</span>
        <span class="s1">self.axis = </span><span class="s0">None</span>

        <span class="s1">self.set_zorder(</span><span class="s4">2.5</span><span class="s1">)</span>
        <span class="s1">self.set_transform(self.axes.transData)  </span><span class="s5"># default transform</span>

        <span class="s1">self._bounds = </span><span class="s0">None  </span><span class="s5"># default bounds</span>

        <span class="s5"># Defer initial position determination. (Not much support for</span>
        <span class="s5"># non-rectangular axes is currently implemented, and this lets</span>
        <span class="s5"># them pass through the spines machinery without errors.)</span>
        <span class="s1">self._position = </span><span class="s0">None</span>
        <span class="s1">_api.check_isinstance(mpath.Path</span><span class="s0">, </span><span class="s1">path=path)</span>
        <span class="s1">self._path = path</span>

        <span class="s5"># To support drawing both linear and circular spines, this</span>
        <span class="s5"># class implements Patch behavior three ways. If</span>
        <span class="s5"># self._patch_type == 'line', behave like a mpatches.PathPatch</span>
        <span class="s5"># instance. If self._patch_type == 'circle', behave like a</span>
        <span class="s5"># mpatches.Ellipse instance. If self._patch_type == 'arc', behave like</span>
        <span class="s5"># a mpatches.Arc instance.</span>
        <span class="s1">self._patch_type = </span><span class="s3">'line'</span>

        <span class="s5"># Behavior copied from mpatches.Ellipse:</span>
        <span class="s5"># Note: This cannot be calculated until this is added to an Axes</span>
        <span class="s1">self._patch_transform = mtransforms.IdentityTransform()</span>

    <span class="s0">def </span><span class="s1">set_patch_arc(self</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">theta1</span><span class="s0">, </span><span class="s1">theta2):</span>
        <span class="s2">&quot;&quot;&quot;Set the spine to be arc-like.&quot;&quot;&quot;</span>
        <span class="s1">self._patch_type = </span><span class="s3">'arc'</span>
        <span class="s1">self._center = center</span>
        <span class="s1">self._width = radius * </span><span class="s4">2</span>
        <span class="s1">self._height = radius * </span><span class="s4">2</span>
        <span class="s1">self._theta1 = theta1</span>
        <span class="s1">self._theta2 = theta2</span>
        <span class="s1">self._path = mpath.Path.arc(theta1</span><span class="s0">, </span><span class="s1">theta2)</span>
        <span class="s5"># arc drawn on axes transform</span>
        <span class="s1">self.set_transform(self.axes.transAxes)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_patch_circle(self</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius):</span>
        <span class="s2">&quot;&quot;&quot;Set the spine to be circular.&quot;&quot;&quot;</span>
        <span class="s1">self._patch_type = </span><span class="s3">'circle'</span>
        <span class="s1">self._center = center</span>
        <span class="s1">self._width = radius * </span><span class="s4">2</span>
        <span class="s1">self._height = radius * </span><span class="s4">2</span>
        <span class="s5"># circle drawn on axes transform</span>
        <span class="s1">self.set_transform(self.axes.transAxes)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_patch_line(self):</span>
        <span class="s2">&quot;&quot;&quot;Set the spine to be linear.&quot;&quot;&quot;</span>
        <span class="s1">self._patch_type = </span><span class="s3">'line'</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s5"># Behavior copied from mpatches.Ellipse:</span>
    <span class="s0">def </span><span class="s1">_recompute_transform(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Notes 
        ----- 
        This cannot be called until after this has been added to an Axes, 
        otherwise unit conversion will fail. This makes it very important to 
        call the accessor method and not directly access the transformation 
        member variable. 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self._patch_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'arc'</span><span class="s0">, </span><span class="s3">'circle'</span><span class="s1">)</span>
        <span class="s1">center = (self.convert_xunits(self._center[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">,</span>
                  <span class="s1">self.convert_yunits(self._center[</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">width = self.convert_xunits(self._width)</span>
        <span class="s1">height = self.convert_yunits(self._height)</span>
        <span class="s1">self._patch_transform = mtransforms.Affine2D() \</span>
            <span class="s1">.scale(width * </span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">height * </span><span class="s4">0.5</span><span class="s1">) \</span>
            <span class="s1">.translate(*center)</span>

    <span class="s0">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s0">if </span><span class="s1">self._patch_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'arc'</span><span class="s0">, </span><span class="s3">'circle'</span><span class="s1">):</span>
            <span class="s1">self._recompute_transform()</span>
            <span class="s0">return </span><span class="s1">self._patch_transform</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().get_patch_transform()</span>

    <span class="s0">def </span><span class="s1">get_window_extent(self</span><span class="s0">, </span><span class="s1">renderer=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the window extent of the spines in display space, including 
        padding for ticks (but not their labels) 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.get_tightbbox 
        matplotlib.axes.Axes.get_window_extent 
        &quot;&quot;&quot;</span>
        <span class="s5"># make sure the location is updated so that transforms etc are correct:</span>
        <span class="s1">self._adjust_location()</span>
        <span class="s1">bb = super().get_window_extent(renderer=renderer)</span>
        <span class="s0">if </span><span class="s1">self.axis </span><span class="s0">is None or not </span><span class="s1">self.axis.get_visible():</span>
            <span class="s0">return </span><span class="s1">bb</span>
        <span class="s1">bboxes = [bb]</span>
        <span class="s1">drawn_ticks = self.axis._update_ticks()</span>

        <span class="s1">major_tick = next(iter({*drawn_ticks} &amp; {*self.axis.majorTicks})</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">minor_tick = next(iter({*drawn_ticks} &amp; {*self.axis.minorTicks})</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">tick </span><span class="s0">in </span><span class="s1">[major_tick</span><span class="s0">, </span><span class="s1">minor_tick]:</span>
            <span class="s0">if </span><span class="s1">tick </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s1">bb0 = bb.frozen()</span>
            <span class="s1">tickl = tick._size</span>
            <span class="s1">tickdir = tick._tickdir</span>
            <span class="s0">if </span><span class="s1">tickdir == </span><span class="s3">'out'</span><span class="s1">:</span>
                <span class="s1">padout = </span><span class="s4">1</span>
                <span class="s1">padin = </span><span class="s4">0</span>
            <span class="s0">elif </span><span class="s1">tickdir == </span><span class="s3">'in'</span><span class="s1">:</span>
                <span class="s1">padout = </span><span class="s4">0</span>
                <span class="s1">padin = </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">padout = </span><span class="s4">0.5</span>
                <span class="s1">padin = </span><span class="s4">0.5</span>
            <span class="s1">padout = padout * tickl / </span><span class="s4">72 </span><span class="s1">* self.figure.dpi</span>
            <span class="s1">padin = padin * tickl / </span><span class="s4">72 </span><span class="s1">* self.figure.dpi</span>

            <span class="s0">if </span><span class="s1">tick.tick1line.get_visible():</span>
                <span class="s0">if </span><span class="s1">self.spine_type == </span><span class="s3">'left'</span><span class="s1">:</span>
                    <span class="s1">bb0.x0 = bb0.x0 - padout</span>
                    <span class="s1">bb0.x1 = bb0.x1 + padin</span>
                <span class="s0">elif </span><span class="s1">self.spine_type == </span><span class="s3">'bottom'</span><span class="s1">:</span>
                    <span class="s1">bb0.y0 = bb0.y0 - padout</span>
                    <span class="s1">bb0.y1 = bb0.y1 + padin</span>

            <span class="s0">if </span><span class="s1">tick.tick2line.get_visible():</span>
                <span class="s0">if </span><span class="s1">self.spine_type == </span><span class="s3">'right'</span><span class="s1">:</span>
                    <span class="s1">bb0.x1 = bb0.x1 + padout</span>
                    <span class="s1">bb0.x0 = bb0.x0 - padin</span>
                <span class="s0">elif </span><span class="s1">self.spine_type == </span><span class="s3">'top'</span><span class="s1">:</span>
                    <span class="s1">bb0.y1 = bb0.y1 + padout</span>
                    <span class="s1">bb0.y0 = bb0.y0 - padout</span>
            <span class="s1">bboxes.append(bb0)</span>

        <span class="s0">return </span><span class="s1">mtransforms.Bbox.union(bboxes)</span>

    <span class="s0">def </span><span class="s1">get_path(self):</span>
        <span class="s0">return </span><span class="s1">self._path</span>

    <span class="s0">def </span><span class="s1">_ensure_position_is_set(self):</span>
        <span class="s0">if </span><span class="s1">self._position </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s5"># default position</span>
            <span class="s1">self._position = (</span><span class="s3">'outward'</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">)  </span><span class="s5"># in points</span>
            <span class="s1">self.set_position(self._position)</span>

    <span class="s0">def </span><span class="s1">register_axis(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s2">&quot;&quot;&quot; 
        Register an axis. 
 
        An axis should be registered with its corresponding spine from 
        the Axes instance. This allows the spine to clear any axis 
        properties when needed. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.axis = axis</span>
        <span class="s0">if </span><span class="s1">self.axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.axis.clear()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s2">&quot;&quot;&quot;Clear the current spine.&quot;&quot;&quot;</span>
        <span class="s1">self._position = </span><span class="s0">None  </span><span class="s5"># clear position</span>
        <span class="s0">if </span><span class="s1">self.axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.axis.clear()</span>

    <span class="s0">def </span><span class="s1">_adjust_location(self):</span>
        <span class="s2">&quot;&quot;&quot;Automatically set spine bounds to the view interval.&quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">self.spine_type == </span><span class="s3">'circle'</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">self._bounds </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">low</span><span class="s0">, </span><span class="s1">high = self._bounds</span>
        <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'left'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">):</span>
            <span class="s1">low</span><span class="s0">, </span><span class="s1">high = self.axes.viewLim.intervaly</span>
        <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'top'</span><span class="s0">, </span><span class="s3">'bottom'</span><span class="s1">):</span>
            <span class="s1">low</span><span class="s0">, </span><span class="s1">high = self.axes.viewLim.intervalx</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f'unknown spine spine_type: </span><span class="s0">{</span><span class="s1">self.spine_type</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self._patch_type == </span><span class="s3">'arc'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'bottom'</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">direction = self.axes.get_theta_direction()</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s1">direction = </span><span class="s4">1</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">offset = self.axes.get_theta_offset()</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s1">offset = </span><span class="s4">0</span>
                <span class="s1">low = low * direction + offset</span>
                <span class="s1">high = high * direction + offset</span>
                <span class="s0">if </span><span class="s1">low &gt; high:</span>
                    <span class="s1">low</span><span class="s0">, </span><span class="s1">high = high</span><span class="s0">, </span><span class="s1">low</span>

                <span class="s1">self._path = mpath.Path.arc(np.rad2deg(low)</span><span class="s0">, </span><span class="s1">np.rad2deg(high))</span>

                <span class="s0">if </span><span class="s1">self.spine_type == </span><span class="s3">'bottom'</span><span class="s1">:</span>
                    <span class="s1">rmin</span><span class="s0">, </span><span class="s1">rmax = self.axes.viewLim.intervaly</span>
                    <span class="s0">try</span><span class="s1">:</span>
                        <span class="s1">rorigin = self.axes.get_rorigin()</span>
                    <span class="s0">except </span><span class="s1">AttributeError:</span>
                        <span class="s1">rorigin = rmin</span>
                    <span class="s1">scaled_diameter = (rmin - rorigin) / (rmax - rorigin)</span>
                    <span class="s1">self._height = scaled_diameter</span>
                    <span class="s1">self._width = scaled_diameter</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'unable to set bounds for spine &quot;%s&quot;' </span><span class="s1">%</span>
                                 <span class="s1">self.spine_type)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">v1 = self._path.vertices</span>
            <span class="s0">assert </span><span class="s1">v1.shape == (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'unexpected vertices shape'</span>
            <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'left'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">]:</span>
                <span class="s1">v1[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = low</span>
                <span class="s1">v1[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">] = high</span>
            <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'bottom'</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">]:</span>
                <span class="s1">v1[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = low</span>
                <span class="s1">v1[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = high</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'unable to set bounds for spine &quot;%s&quot;' </span><span class="s1">%</span>
                                 <span class="s1">self.spine_type)</span>

    <span class="s1">@allow_rasterization</span>
    <span class="s0">def </span><span class="s1">draw(self</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s1">self._adjust_location()</span>
        <span class="s1">ret = super().draw(renderer)</span>
        <span class="s1">self.stale = </span><span class="s0">False</span>
        <span class="s0">return </span><span class="s1">ret</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">position):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the position of the spine. 
 
        Spine position is specified by a 2 tuple of (position type, 
        amount). The position types are: 
 
        * 'outward': place the spine out from the data area by the specified 
          number of points. (Negative values place the spine inwards.) 
        * 'axes': place the spine at the specified Axes coordinate (0 to 1). 
        * 'data': place the spine at the specified data coordinate. 
 
        Additionally, shorthand notations define a special positions: 
 
        * 'center' -&gt; ``('axes', 0.5)`` 
        * 'zero' -&gt; ``('data', 0.0)`` 
 
        Examples 
        -------- 
        :doc:`/gallery/spines/spine_placement_demo` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">position </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'center'</span><span class="s0">, </span><span class="s3">'zero'</span><span class="s1">):  </span><span class="s5"># special positions</span>
            <span class="s0">pass</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">len(position) != </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;position should be 'center' or 2-tuple&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">position[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">[</span><span class="s3">'outward'</span><span class="s0">, </span><span class="s3">'axes'</span><span class="s0">, </span><span class="s3">'data'</span><span class="s1">]:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;position[0] should be one of 'outward', &quot;</span>
                                 <span class="s3">&quot;'axes', or 'data' &quot;</span><span class="s1">)</span>
        <span class="s1">self._position = position</span>
        <span class="s1">self.set_transform(self.get_spine_transform())</span>
        <span class="s0">if </span><span class="s1">self.axis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.axis.reset_ticks()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_position(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the spine position.&quot;&quot;&quot;</span>
        <span class="s1">self._ensure_position_is_set()</span>
        <span class="s0">return </span><span class="s1">self._position</span>

    <span class="s0">def </span><span class="s1">get_spine_transform(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the spine transform.&quot;&quot;&quot;</span>
        <span class="s1">self._ensure_position_is_set()</span>

        <span class="s1">position = self._position</span>
        <span class="s0">if </span><span class="s1">isinstance(position</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">if </span><span class="s1">position == </span><span class="s3">'center'</span><span class="s1">:</span>
                <span class="s1">position = (</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">position == </span><span class="s3">'zero'</span><span class="s1">:</span>
                <span class="s1">position = (</span><span class="s3">'data'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">len(position) == </span><span class="s4">2</span><span class="s0">, </span><span class="s3">'position should be 2-tuple'</span>
        <span class="s1">position_type</span><span class="s0">, </span><span class="s1">amount = position</span>
        <span class="s1">_api.check_in_list([</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s3">'outward'</span><span class="s0">, </span><span class="s3">'data'</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">position_type=position_type)</span>
        <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'left'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">]:</span>
            <span class="s1">base_transform = self.axes.get_yaxis_transform(which=</span><span class="s3">'grid'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'top'</span><span class="s0">, </span><span class="s3">'bottom'</span><span class="s1">]:</span>
            <span class="s1">base_transform = self.axes.get_xaxis_transform(which=</span><span class="s3">'grid'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f'unknown spine spine_type: </span><span class="s0">{</span><span class="s1">self.spine_type</span><span class="s0">!r}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">position_type == </span><span class="s3">'outward'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">amount == </span><span class="s4">0</span><span class="s1">:  </span><span class="s5"># short circuit commonest case</span>
                <span class="s0">return </span><span class="s1">base_transform</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">offset_vec = {</span><span class="s3">'left'</span><span class="s1">: (-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">: (</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s3">'bottom'</span><span class="s1">: (</span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">: (</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">}[self.spine_type]</span>
                <span class="s5"># calculate x and y offset in dots</span>
                <span class="s1">offset_dots = amount * np.array(offset_vec) / </span><span class="s4">72</span>
                <span class="s0">return </span><span class="s1">(base_transform</span>
                        <span class="s1">+ mtransforms.ScaledTranslation(</span>
                            <span class="s1">*offset_dots</span><span class="s0">, </span><span class="s1">self.figure.dpi_scale_trans))</span>
        <span class="s0">elif </span><span class="s1">position_type == </span><span class="s3">'axes'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'left'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">]:</span>
                <span class="s5"># keep y unchanged, fix x at amount</span>
                <span class="s0">return </span><span class="s1">(mtransforms.Affine2D.from_values(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">amount</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
                        <span class="s1">+ base_transform)</span>
            <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'bottom'</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">]:</span>
                <span class="s5"># keep x unchanged, fix y at amount</span>
                <span class="s0">return </span><span class="s1">(mtransforms.Affine2D.from_values(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">amount)</span>
                        <span class="s1">+ base_transform)</span>
        <span class="s0">elif </span><span class="s1">position_type == </span><span class="s3">'data'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'right'</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">):</span>
                <span class="s5"># The right and top spines have a default position of 1 in</span>
                <span class="s5"># axes coordinates.  When specifying the position in data</span>
                <span class="s5"># coordinates, we need to calculate the position relative to 0.</span>
                <span class="s1">amount -= </span><span class="s4">1</span>
            <span class="s0">if </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'left'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">mtransforms.blended_transform_factory(</span>
                    <span class="s1">mtransforms.Affine2D().translate(amount</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
                    <span class="s1">+ self.axes.transData</span><span class="s0">,</span>
                    <span class="s1">self.axes.transData)</span>
            <span class="s0">elif </span><span class="s1">self.spine_type </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'bottom'</span><span class="s0">, </span><span class="s3">'top'</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">mtransforms.blended_transform_factory(</span>
                    <span class="s1">self.axes.transData</span><span class="s0">,</span>
                    <span class="s1">mtransforms.Affine2D().translate(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">amount)</span>
                    <span class="s1">+ self.axes.transData)</span>

    <span class="s0">def </span><span class="s1">set_bounds(self</span><span class="s0">, </span><span class="s1">low=</span><span class="s0">None, </span><span class="s1">high=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the spine bounds. 
 
        Parameters 
        ---------- 
        low : float or None, optional 
            The lower spine bound. Passing *None* leaves the limit unchanged. 
 
            The bounds may also be passed as the tuple (*low*, *high*) as the 
            first positional argument. 
 
            .. ACCEPTS: (low: float, high: float) 
 
        high : float or None, optional 
            The higher spine bound. Passing *None* leaves the limit unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.spine_type == </span><span class="s3">'circle'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'set_bounds() method incompatible with circular spines'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">high </span><span class="s0">is None and </span><span class="s1">np.iterable(low):</span>
            <span class="s1">low</span><span class="s0">, </span><span class="s1">high = low</span>
        <span class="s1">old_low</span><span class="s0">, </span><span class="s1">old_high = self.get_bounds() </span><span class="s0">or </span><span class="s1">(</span><span class="s0">None, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">low </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">low = old_low</span>
        <span class="s0">if </span><span class="s1">high </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">high = old_high</span>
        <span class="s1">self._bounds = (low</span><span class="s0">, </span><span class="s1">high)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_bounds(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the bounds of the spine.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._bounds</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">linear_spine(cls</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Create and return a linear `Spine`.&quot;&quot;&quot;</span>
        <span class="s5"># all values of 0.999 get replaced upon call to set_bounds()</span>
        <span class="s0">if </span><span class="s1">spine_type == </span><span class="s3">'left'</span><span class="s1">:</span>
            <span class="s1">path = mpath.Path([(</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.999</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">0.999</span><span class="s1">)])</span>
        <span class="s0">elif </span><span class="s1">spine_type == </span><span class="s3">'right'</span><span class="s1">:</span>
            <span class="s1">path = mpath.Path([(</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">0.999</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">0.999</span><span class="s1">)])</span>
        <span class="s0">elif </span><span class="s1">spine_type == </span><span class="s3">'bottom'</span><span class="s1">:</span>
            <span class="s1">path = mpath.Path([(</span><span class="s4">0.999</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.999</span><span class="s0">, </span><span class="s4">0.0</span><span class="s1">)])</span>
        <span class="s0">elif </span><span class="s1">spine_type == </span><span class="s3">'top'</span><span class="s1">:</span>
            <span class="s1">path = mpath.Path([(</span><span class="s4">0.999</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.999</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">)])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'unable to make path for spine &quot;%s&quot;' </span><span class="s1">% spine_type)</span>
        <span class="s1">result = cls(axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">result.set_visible(mpl.rcParams[</span><span class="s3">'axes.spines.{0}'</span><span class="s1">.format(spine_type)])</span>

        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">arc_spine(cls</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">theta1</span><span class="s0">, </span><span class="s1">theta2</span><span class="s0">,</span>
                  <span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Create and return an arc `Spine`.&quot;&quot;&quot;</span>
        <span class="s1">path = mpath.Path.arc(theta1</span><span class="s0">, </span><span class="s1">theta2)</span>
        <span class="s1">result = cls(axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">result.set_patch_arc(center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">theta1</span><span class="s0">, </span><span class="s1">theta2)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">circular_spine(cls</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">center</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Create and return a circular `Spine`.&quot;&quot;&quot;</span>
        <span class="s1">path = mpath.Path.unit_circle()</span>
        <span class="s1">spine_type = </span><span class="s3">'circle'</span>
        <span class="s1">result = cls(axes</span><span class="s0">, </span><span class="s1">spine_type</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">result.set_patch_circle(center</span><span class="s0">, </span><span class="s1">radius)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">set_color(self</span><span class="s0">, </span><span class="s1">c):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the edgecolor. 
 
        Parameters 
        ---------- 
        c : color 
 
        Notes 
        ----- 
        This method does not modify the facecolor (which defaults to &quot;none&quot;), 
        unlike the `.Patch.set_color` method defined in the parent class.  Use 
        `.Patch.set_facecolor` to set the facecolor. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_edgecolor(c)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>


<span class="s0">class </span><span class="s1">SpinesProxy:</span>
    <span class="s2">&quot;&quot;&quot; 
    A proxy to broadcast ``set_*`` method calls to all contained `.Spines`. 
 
    The proxy cannot be used for any other operations on its members. 
 
    The supported methods are determined dynamically based on the contained 
    spines. If not all spines support a given method, it's executed only on 
    the subset of spines that support it. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">spine_dict):</span>
        <span class="s1">self._spine_dict = spine_dict</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">broadcast_targets = [spine </span><span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">self._spine_dict.values()</span>
                             <span class="s0">if </span><span class="s1">hasattr(spine</span><span class="s0">, </span><span class="s1">name)]</span>
        <span class="s0">if not </span><span class="s1">name.startswith(</span><span class="s3">'set_'</span><span class="s1">) </span><span class="s0">or not </span><span class="s1">broadcast_targets:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span>
                <span class="s3">f&quot;'SpinesProxy' object has no attribute '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">'&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">x(_targets</span><span class="s0">, </span><span class="s1">_funcname</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">_targets:</span>
                <span class="s1">getattr(spine</span><span class="s0">, </span><span class="s1">_funcname)(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">x = functools.partial(x</span><span class="s0">, </span><span class="s1">broadcast_targets</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">x.__doc__ = broadcast_targets[</span><span class="s4">0</span><span class="s1">].__doc__</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">__dir__(self):</span>
        <span class="s1">names = []</span>
        <span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">self._spine_dict.values():</span>
            <span class="s1">names.extend(name</span>
                         <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(spine) </span><span class="s0">if </span><span class="s1">name.startswith(</span><span class="s3">'set_'</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">list(sorted(set(names)))</span>


<span class="s0">class </span><span class="s1">Spines(MutableMapping):</span>
    <span class="s2">r&quot;&quot;&quot; 
    The container of all `.Spine`\s in an Axes. 
 
    The interface is dict-like mapping names (e.g. 'left') to `.Spine` objects. 
    Additionally, it implements some pandas.Series-like features like accessing 
    elements by attribute:: 
 
        spines['top'].set_visible(False) 
        spines.top.set_visible(False) 
 
    Multiple spines can be addressed simultaneously by passing a list:: 
 
        spines[['top', 'right']].set_visible(False) 
 
    Use an open slice to address all spines:: 
 
        spines[:].set_visible(False) 
 
    The latter two indexing methods will return a `SpinesProxy` that broadcasts 
    all ``set_*`` calls to its members, but cannot be used for any other 
    operation. 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._dict = kwargs</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_dict(cls</span><span class="s0">, </span><span class="s1">d):</span>
        <span class="s0">return </span><span class="s1">cls(**d)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s0">return </span><span class="s1">self._dict</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s1">self.__init__(**state)</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._dict[name]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span>
                <span class="s3">f&quot;'Spines' object does not contain a '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s3">' spine&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s1">unknown_keys = [k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key </span><span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">self._dict]</span>
            <span class="s0">if </span><span class="s1">unknown_keys:</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s3">', '</span><span class="s1">.join(unknown_keys))</span>
            <span class="s0">return </span><span class="s1">SpinesProxy({k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._dict.items()</span>
                                <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">key})</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'Multiple spines must be passed as a single list'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">slice):</span>
            <span class="s0">if </span><span class="s1">key.start </span><span class="s0">is None and </span><span class="s1">key.stop </span><span class="s0">is None and </span><span class="s1">key.step </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">SpinesProxy(self._dict)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">'Spines does not support slicing except for the fully '</span>
                    <span class="s3">'open slice [:] to access all spines.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._dict[key]</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s5"># TODO: Do we want to deprecate adding spines?</span>
        <span class="s1">self._dict[key] = value</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s5"># TODO: Do we want to deprecate deleting spines?</span>
        <span class="s0">del </span><span class="s1">self._dict[key]</span>

    <span class="s0">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">return </span><span class="s1">iter(self._dict)</span>

    <span class="s0">def </span><span class="s1">__len__(self):</span>
        <span class="s0">return </span><span class="s1">len(self._dict)</span>
</pre>
</body>
</html>