<html>
<head>
<title>test_ufunc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ufunc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">ctypes </span><span class="s0">as </span><span class="s1">ct</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">param</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">numpy.core._umath_tests </span><span class="s0">as </span><span class="s1">umt</span>
<span class="s0">import </span><span class="s1">numpy.linalg._umath_linalg </span><span class="s0">as </span><span class="s1">uml</span>
<span class="s0">import </span><span class="s1">numpy.core._operand_flag_tests </span><span class="s0">as </span><span class="s1">opflag_tests</span>
<span class="s0">import </span><span class="s1">numpy.core._rational_tests </span><span class="s0">as </span><span class="s1">_rational_tests</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_array_equal</span><span class="s0">,</span>
    <span class="s1">assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_no_warnings</span><span class="s0">,</span>
    <span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">HAS_REFCOUNT</span><span class="s0">, </span><span class="s1">suppress_warnings</span><span class="s0">, </span><span class="s1">IS_WASM</span>
    <span class="s1">)</span>
<span class="s0">from </span><span class="s1">numpy.testing._private.utils </span><span class="s0">import </span><span class="s1">requires_memory</span>
<span class="s0">from </span><span class="s1">numpy.compat </span><span class="s0">import </span><span class="s1">pickle</span>


<span class="s1">UNARY_UFUNCS = [obj </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">np.core.umath.__dict__.values()</span>
                    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">np.ufunc)]</span>
<span class="s1">UNARY_OBJECT_UFUNCS = [uf </span><span class="s0">for </span><span class="s1">uf </span><span class="s0">in </span><span class="s1">UNARY_UFUNCS </span><span class="s0">if </span><span class="s2">&quot;O-&gt;O&quot; </span><span class="s0">in </span><span class="s1">uf.types]</span>


<span class="s0">class </span><span class="s1">TestUfuncKwargs:</span>
    <span class="s0">def </span><span class="s1">test_kwarg_exact(self):</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">castingx=</span><span class="s2">'safe'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtypex=int)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">extobjx=[</span><span class="s3">4096</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">outx=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">sigx=</span><span class="s2">'ii-&gt;i'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">signaturex=</span><span class="s2">'ii-&gt;i'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">subokx=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">wherex=[</span><span class="s0">True</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_sig_signature(self):</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'ii-&gt;i'</span><span class="s0">,</span>
                      <span class="s1">signature=</span><span class="s2">'ii-&gt;i'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sig_dtype(self):</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'ii-&gt;i'</span><span class="s0">,</span>
                      <span class="s1">dtype=int)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">'ii-&gt;i'</span><span class="s0">,</span>
                      <span class="s1">dtype=int)</span>

    <span class="s0">def </span><span class="s1">test_extobj_refcount(self):</span>
        <span class="s4"># Should not segfault with USE_DEBUG.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">extobj=[</span><span class="s3">4096</span><span class="s1">]</span><span class="s0">, </span><span class="s1">parrot=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestUfuncGenericLoops:</span>
    <span class="s5">&quot;&quot;&quot;Test generic loops. 
 
    The loops to be tested are: 
 
        PyUFunc_ff_f_As_dd_d 
        PyUFunc_ff_f 
        PyUFunc_dd_d 
        PyUFunc_gg_g 
        PyUFunc_FF_F_As_DD_D 
        PyUFunc_DD_D 
        PyUFunc_FF_F 
        PyUFunc_GG_G 
        PyUFunc_OO_O 
        PyUFunc_OO_O_method 
        PyUFunc_f_f_As_d_d 
        PyUFunc_d_d 
        PyUFunc_f_f 
        PyUFunc_g_g 
        PyUFunc_F_F_As_D_D 
        PyUFunc_F_F 
        PyUFunc_D_D 
        PyUFunc_G_G 
        PyUFunc_O_O 
        PyUFunc_O_O_method 
        PyUFunc_On_Om 
 
    Where: 
 
        f -- float 
        d -- double 
        g -- long double 
        F -- complex float 
        D -- complex double 
        G -- complex long double 
        O -- python object 
 
    It is difficult to assure that each of these loops is entered from the 
    Python level as the special cased loops are a moving target and the 
    corresponding types are architecture dependent. We probably need to 
    define C level testing ufuncs to get at them. For the time being, I've 
    just looked at the signatures registered in the build directory to find 
    relevant functions. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">np_dtypes = [</span>
        <span class="s1">(np.single</span><span class="s0">, </span><span class="s1">np.single)</span><span class="s0">, </span><span class="s1">(np.single</span><span class="s0">, </span><span class="s1">np.double)</span><span class="s0">,</span>
        <span class="s1">(np.csingle</span><span class="s0">, </span><span class="s1">np.csingle)</span><span class="s0">, </span><span class="s1">(np.csingle</span><span class="s0">, </span><span class="s1">np.cdouble)</span><span class="s0">,</span>
        <span class="s1">(np.double</span><span class="s0">, </span><span class="s1">np.double)</span><span class="s0">, </span><span class="s1">(np.longdouble</span><span class="s0">, </span><span class="s1">np.longdouble)</span><span class="s0">,</span>
        <span class="s1">(np.cdouble</span><span class="s0">, </span><span class="s1">np.cdouble)</span><span class="s0">, </span><span class="s1">(np.clongdouble</span><span class="s0">, </span><span class="s1">np.clongdouble)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'input_dtype,output_dtype'</span><span class="s0">, </span><span class="s1">np_dtypes)</span>
    <span class="s0">def </span><span class="s1">test_unary_PyUFunc(self</span><span class="s0">, </span><span class="s1">input_dtype</span><span class="s0">, </span><span class="s1">output_dtype</span><span class="s0">, </span><span class="s1">f=np.exp</span><span class="s0">, </span><span class="s1">x=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">xs = np.full(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">input_dtype(x)</span><span class="s0">, </span><span class="s1">dtype=output_dtype)</span>
        <span class="s1">ys = f(xs)[::</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">assert_allclose(ys</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_equal(ys.dtype</span><span class="s0">, </span><span class="s1">output_dtype)</span>

    <span class="s0">def </span><span class="s1">f2(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">return </span><span class="s1">x**y</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'input_dtype,output_dtype'</span><span class="s0">, </span><span class="s1">np_dtypes)</span>
    <span class="s0">def </span><span class="s1">test_binary_PyUFunc(self</span><span class="s0">, </span><span class="s1">input_dtype</span><span class="s0">, </span><span class="s1">output_dtype</span><span class="s0">, </span><span class="s1">f=f2</span><span class="s0">, </span><span class="s1">x=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">xs = np.full(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">input_dtype(x)</span><span class="s0">, </span><span class="s1">dtype=output_dtype)</span>
        <span class="s1">ys = f(xs</span><span class="s0">, </span><span class="s1">xs)[::</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">assert_allclose(ys</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_equal(ys.dtype</span><span class="s0">, </span><span class="s1">output_dtype)</span>

    <span class="s4"># class to use in testing object method loops</span>
    <span class="s0">class </span><span class="s1">foo:</span>
        <span class="s0">def </span><span class="s1">conjugate(self):</span>
            <span class="s0">return </span><span class="s1">np.bool_(</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">logical_xor(self</span><span class="s0">, </span><span class="s1">obj):</span>
            <span class="s0">return </span><span class="s1">np.bool_(</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_unary_PyUFunc_O_O(self):</span>
        <span class="s1">x = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_(np.all(np.abs(x) == </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_unary_PyUFunc_O_O_method_simple(self</span><span class="s0">, </span><span class="s1">foo=foo):</span>
        <span class="s1">x = np.full(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">foo()</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_(np.all(np.conjugate(x) == </span><span class="s0">True</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_binary_PyUFunc_OO_O(self):</span>
        <span class="s1">x = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_(np.all(np.add(x</span><span class="s0">, </span><span class="s1">x) == </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_binary_PyUFunc_OO_O_method(self</span><span class="s0">, </span><span class="s1">foo=foo):</span>
        <span class="s1">x = np.full(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">foo()</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_(np.all(np.logical_xor(x</span><span class="s0">, </span><span class="s1">x)))</span>

    <span class="s0">def </span><span class="s1">test_binary_PyUFunc_On_Om_method(self</span><span class="s0">, </span><span class="s1">foo=foo):</span>
        <span class="s1">x = np.full((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">foo()</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_(np.all(np.logical_xor(x</span><span class="s0">, </span><span class="s1">x)))</span>

    <span class="s0">def </span><span class="s1">test_python_complex_conjugate(self):</span>
        <span class="s4"># The conjugate ufunc should fall back to calling the method:</span>
        <span class="s1">arr = np.array([</span><span class="s3">1</span><span class="s1">+</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">3</span><span class="s1">-</span><span class="s3">4j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">isinstance(arr[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">complex)</span>
        <span class="s1">res = np.conjugate(arr)</span>
        <span class="s0">assert </span><span class="s1">res.dtype == np.dtype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s1">-</span><span class="s3">2j</span><span class="s0">, </span><span class="s3">3</span><span class="s1">+</span><span class="s3">4j</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;O&quot;</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">, </span><span class="s1">UNARY_OBJECT_UFUNCS)</span>
    <span class="s0">def </span><span class="s1">test_unary_PyUFunc_O_O_method_full(self</span><span class="s0">, </span><span class="s1">ufunc):</span>
        <span class="s5">&quot;&quot;&quot;Compare the result of the object loop with non-object one&quot;&quot;&quot;</span>
        <span class="s1">val = np.float64(np.pi/</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s0">class </span><span class="s1">MyFloat(np.float64):</span>
            <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">attr):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">super().__getattr__(attr)</span>
                <span class="s0">except </span><span class="s1">AttributeError:</span>
                    <span class="s0">return lambda</span><span class="s1">: getattr(np.core.umath</span><span class="s0">, </span><span class="s1">attr)(val)</span>

        <span class="s4"># Use 0-D arrays, to ensure the same element call</span>
        <span class="s1">num_arr = np.array(val</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">obj_arr = np.array(MyFloat(val)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;raise&quot;</span><span class="s1">):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">res_num = ufunc(num_arr)</span>
            <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">exc:</span>
                <span class="s0">with </span><span class="s1">assert_raises(type(exc)):</span>
                    <span class="s1">ufunc(obj_arr)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res_obj = ufunc(obj_arr)</span>
                <span class="s1">assert_array_almost_equal(res_num.astype(</span><span class="s2">&quot;O&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">res_obj)</span>


<span class="s0">def </span><span class="s1">_pickleable_module_global():</span>
    <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">TestUfunc:</span>
    <span class="s0">def </span><span class="s1">test_pickle(self):</span>
        <span class="s0">for </span><span class="s1">proto </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">pickle.HIGHEST_PROTOCOL + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">assert_(pickle.loads(pickle.dumps(np.sin</span><span class="s0">,</span>
                                              <span class="s1">protocol=proto)) </span><span class="s0">is </span><span class="s1">np.sin)</span>

            <span class="s4"># Check that ufunc not defined in the top level numpy namespace</span>
            <span class="s4"># such as numpy.core._rational_tests.test_add can also be pickled</span>
            <span class="s1">res = pickle.loads(pickle.dumps(_rational_tests.test_add</span><span class="s0">,</span>
                                            <span class="s1">protocol=proto))</span>
            <span class="s1">assert_(res </span><span class="s0">is </span><span class="s1">_rational_tests.test_add)</span>

    <span class="s0">def </span><span class="s1">test_pickle_withstring(self):</span>
        <span class="s1">astring = (</span><span class="s6">b&quot;cnumpy.core</span><span class="s0">\n</span><span class="s6">_ufunc_reconstruct</span><span class="s0">\n</span><span class="s6">p0</span><span class="s0">\n</span><span class="s6">&quot;</span>
                   <span class="s6">b&quot;(S'numpy.core.umath'</span><span class="s0">\n</span><span class="s6">p1</span><span class="s0">\n</span><span class="s6">S'cos'</span><span class="s0">\n</span><span class="s6">p2</span><span class="s0">\n</span><span class="s6">tp3</span><span class="s0">\n</span><span class="s6">Rp4</span><span class="s0">\n</span><span class="s6">.&quot;</span><span class="s1">)</span>
        <span class="s1">assert_(pickle.loads(astring) </span><span class="s0">is </span><span class="s1">np.cos)</span>

    <span class="s0">def </span><span class="s1">test_pickle_name_is_qualname(self):</span>
        <span class="s4"># This tests that a simplification of our ufunc pickle code will</span>
        <span class="s4"># lead to allowing qualnames as names.  Future ufuncs should</span>
        <span class="s4"># possible add a specific qualname, or a hook into pickling instead</span>
        <span class="s4"># (dask+numba may benefit).</span>
        <span class="s1">_pickleable_module_global.ufunc = umt._pickleable_module_global_ufunc</span>
        <span class="s1">obj = pickle.loads(pickle.dumps(_pickleable_module_global.ufunc))</span>
        <span class="s0">assert </span><span class="s1">obj </span><span class="s0">is </span><span class="s1">umt._pickleable_module_global_ufunc</span>

    <span class="s0">def </span><span class="s1">test_reduceat_shifting_sum(self):</span>
        <span class="s1">L = </span><span class="s3">6</span>
        <span class="s1">x = np.arange(L)</span>
        <span class="s1">idx = np.array(list(zip(np.arange(L - </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(L - </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">2</span><span class="s1">))).ravel()</span>
        <span class="s1">assert_array_equal(np.add.reduceat(x</span><span class="s0">, </span><span class="s1">idx)[::</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_all_ufunc(self):</span>
        <span class="s5">&quot;&quot;&quot;Try to check presence and results of all ufuncs. 
 
        The list of ufuncs comes from generate_umath.py and is as follows: 
 
        =====  ====  =============  ===============  ======================== 
        done   args   function        types                notes 
        =====  ====  =============  ===============  ======================== 
        n      1     conjugate      nums + O 
        n      1     absolute       nums + O         complex -&gt; real 
        n      1     negative       nums + O 
        n      1     sign           nums + O         -&gt; int 
        n      1     invert         bool + ints + O  flts raise an error 
        n      1     degrees        real + M         cmplx raise an error 
        n      1     radians        real + M         cmplx raise an error 
        n      1     arccos         flts + M 
        n      1     arccosh        flts + M 
        n      1     arcsin         flts + M 
        n      1     arcsinh        flts + M 
        n      1     arctan         flts + M 
        n      1     arctanh        flts + M 
        n      1     cos            flts + M 
        n      1     sin            flts + M 
        n      1     tan            flts + M 
        n      1     cosh           flts + M 
        n      1     sinh           flts + M 
        n      1     tanh           flts + M 
        n      1     exp            flts + M 
        n      1     expm1          flts + M 
        n      1     log            flts + M 
        n      1     log10          flts + M 
        n      1     log1p          flts + M 
        n      1     sqrt           flts + M         real x &lt; 0 raises error 
        n      1     ceil           real + M 
        n      1     trunc          real + M 
        n      1     floor          real + M 
        n      1     fabs           real + M 
        n      1     rint           flts + M 
        n      1     isnan          flts             -&gt; bool 
        n      1     isinf          flts             -&gt; bool 
        n      1     isfinite       flts             -&gt; bool 
        n      1     signbit        real             -&gt; bool 
        n      1     modf           real             -&gt; (frac, int) 
        n      1     logical_not    bool + nums + M  -&gt; bool 
        n      2     left_shift     ints + O         flts raise an error 
        n      2     right_shift    ints + O         flts raise an error 
        n      2     add            bool + nums + O  boolean + is || 
        n      2     subtract       bool + nums + O  boolean - is ^ 
        n      2     multiply       bool + nums + O  boolean * is &amp; 
        n      2     divide         nums + O 
        n      2     floor_divide   nums + O 
        n      2     true_divide    nums + O         bBhH -&gt; f, iIlLqQ -&gt; d 
        n      2     fmod           nums + M 
        n      2     power          nums + O 
        n      2     greater        bool + nums + O  -&gt; bool 
        n      2     greater_equal  bool + nums + O  -&gt; bool 
        n      2     less           bool + nums + O  -&gt; bool 
        n      2     less_equal     bool + nums + O  -&gt; bool 
        n      2     equal          bool + nums + O  -&gt; bool 
        n      2     not_equal      bool + nums + O  -&gt; bool 
        n      2     logical_and    bool + nums + M  -&gt; bool 
        n      2     logical_or     bool + nums + M  -&gt; bool 
        n      2     logical_xor    bool + nums + M  -&gt; bool 
        n      2     maximum        bool + nums + O 
        n      2     minimum        bool + nums + O 
        n      2     bitwise_and    bool + ints + O  flts raise an error 
        n      2     bitwise_or     bool + ints + O  flts raise an error 
        n      2     bitwise_xor    bool + ints + O  flts raise an error 
        n      2     arctan2        real + M 
        n      2     remainder      ints + real + O 
        n      2     hypot          real + M 
        =====  ====  =============  ===============  ======================== 
 
        Types other than those listed will be accepted, but they are cast to 
        the smallest compatible type for which the function is defined. The 
        casting rules are: 
 
        bool -&gt; int8 -&gt; float32 
        ints -&gt; double 
 
        &quot;&quot;&quot;</span>
        <span class="s0">pass</span>

    <span class="s4"># from include/numpy/ufuncobject.h</span>
    <span class="s1">size_inferred = </span><span class="s3">2</span>
    <span class="s1">can_ignore = </span><span class="s3">4</span>
    <span class="s0">def </span><span class="s1">test_signature0(self):</span>
        <span class="s4"># the arguments to test_signature are: nin, nout, core_signature</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(i),(i)-&gt;()&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.size_inferred</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature1(self):</span>
        <span class="s4"># empty core signature; treat as plain ufunc (with trivial core)</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(),()-&gt;()&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,  </span><span class="s3">0</span><span class="s0">,  </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">())</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">())</span>

    <span class="s0">def </span><span class="s1">test_signature2(self):</span>
        <span class="s4"># more complicated names for variables</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(i1,i2),(J_1)-&gt;(_kAB)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.size_inferred</span><span class="s0">,</span><span class="s1">)*</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature3(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(i1, i12),   (J_1)-&gt;(i12, i2)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.size_inferred</span><span class="s0">,</span><span class="s1">)*</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature4(self):</span>
        <span class="s4"># matrix_multiply signature from _umath_tests</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(n,k),(k,m)-&gt;(n,m)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.size_inferred</span><span class="s0">,</span><span class="s1">)*</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature5(self):</span>
        <span class="s4"># matmul signature from _umath_tests</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(n?,k),(k,m?)-&gt;(n?,m?)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.size_inferred | self.can_ignore</span><span class="s0">,</span>
                             <span class="s1">self.size_inferred</span><span class="s0">,</span>
                             <span class="s1">self.size_inferred | self.can_ignore))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature6(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(3)-&gt;()&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature7(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(3),(03,3),(n)-&gt;(9)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">self.size_inferred</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">9</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature8(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(3?),(3?,3?),(n)-&gt;(9)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.can_ignore</span><span class="s0">, </span><span class="s1">self.size_inferred</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">9</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature9(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(  3)  -&gt; ( )&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature10(self):</span>
        <span class="s1">enabled</span><span class="s0">, </span><span class="s1">num_dims</span><span class="s0">, </span><span class="s1">ixs</span><span class="s0">, </span><span class="s1">flags</span><span class="s0">, </span><span class="s1">sizes = umt.test_signature(</span>
            <span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;( 3? ) , (3? ,  3?) ,(n )-&gt; ( 9)&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(enabled</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(num_dims</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(ixs</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_equal(flags</span><span class="s0">, </span><span class="s1">(self.can_ignore</span><span class="s0">, </span><span class="s1">self.size_inferred</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_equal(sizes</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">9</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature_failure_extra_parenthesis(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">umt.test_signature(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;((i)),(i)-&gt;()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_signature_failure_mismatching_parenthesis(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">umt.test_signature(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(i),)i(-&gt;()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_signature_failure_signature_missing_input_arg(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">umt.test_signature(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;(i),-&gt;()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_signature_failure_signature_missing_output_arg(self):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">umt.test_signature(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;(i),(i)-&gt;()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_get_signature(self):</span>
        <span class="s1">assert_equal(umt.inner1d.signature</span><span class="s0">, </span><span class="s2">&quot;(i),(i)-&gt;()&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_forced_sig(self):</span>
        <span class="s1">a = </span><span class="s3">0.5</span><span class="s1">*np.arange(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning):</span>
            <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'i'</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'ii-&gt;i'</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning):</span>
            <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">'i4'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">'i4'</span><span class="s0">, </span><span class="s2">'i4'</span><span class="s0">, </span><span class="s2">'i4'</span><span class="s1">)</span><span class="s0">,</span>
                                            <span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">b = np.zeros((</span><span class="s3">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">out=b)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">])</span>
        <span class="s1">b[:] = </span><span class="s3">0</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning):</span>
            <span class="s1">np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'i'</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b[:] = </span><span class="s3">0</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=</span><span class="s2">'ii-&gt;i'</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b[:] = </span><span class="s3">0</span>
        <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning):</span>
            <span class="s1">np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">'i4'</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b[:] = </span><span class="s3">0</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">'i4'</span><span class="s0">, </span><span class="s2">'i4'</span><span class="s0">, </span><span class="s2">'i4'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=b</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">'unsafe'</span><span class="s1">)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_signature_all_None(self):</span>
        <span class="s4"># signature all None, is an acceptable alternative (since 1.21)</span>
        <span class="s4"># to not providing a signature.</span>
        <span class="s1">res1 = np.add([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s0">None, None, None</span><span class="s1">))</span>
        <span class="s1">res2 = np.add([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(res1</span><span class="s0">, </span><span class="s1">res2)</span>
        <span class="s1">res1 = np.maximum([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s0">None, None, None</span><span class="s1">))</span>
        <span class="s1">res2 = np.maximum([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(res1</span><span class="s0">, </span><span class="s1">res2)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s4"># special case, that would be deprecated anyway, so errors:</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_signature_dtype_type(self):</span>
        <span class="s4"># Since that will be the normal behaviour (past NumPy 1.21)</span>
        <span class="s4"># we do support the types already:</span>
        <span class="s1">float_dtype = type(np.dtype(np.float64))</span>
        <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=(float_dtype</span><span class="s0">, </span><span class="s1">float_dtype</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;get_kwarg&quot;</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s0">lambda </span><span class="s1">dt: dict(dtype=x)</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">dt: dict(signature=(x</span><span class="s0">, None, None</span><span class="s1">))])</span>
    <span class="s0">def </span><span class="s1">test_signature_dtype_instances_allowed(self</span><span class="s0">, </span><span class="s1">get_kwarg):</span>
        <span class="s4"># We allow certain dtype instances when there is a clear singleton</span>
        <span class="s4"># and the given one is equivalent; mainly for backcompat.</span>
        <span class="s1">int64 = np.dtype(</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">int64_2 = pickle.loads(pickle.dumps(int64))</span>
        <span class="s4"># Relies on pickling behavior, if assert fails just remove test...</span>
        <span class="s0">assert </span><span class="s1">int64 </span><span class="s0">is not </span><span class="s1">int64_2</span>

        <span class="s0">assert </span><span class="s1">np.add(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">**get_kwarg(int64_2)).dtype == int64</span>
        <span class="s1">td = np.timedelta(</span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.add(td</span><span class="s0">, </span><span class="s1">td</span><span class="s0">, </span><span class="s1">**get_kwarg(</span><span class="s2">&quot;m8&quot;</span><span class="s1">)).dtype == </span><span class="s2">&quot;m8[s]&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;get_kwarg&quot;</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">param(</span><span class="s0">lambda </span><span class="s1">x: dict(dtype=x)</span><span class="s0">, </span><span class="s1">id=</span><span class="s2">&quot;dtype&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">param(</span><span class="s0">lambda </span><span class="s1">x: dict(signature=(x</span><span class="s0">, None, None</span><span class="s1">))</span><span class="s0">, </span><span class="s1">id=</span><span class="s2">&quot;signature&quot;</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_signature_dtype_instances_allowed(self</span><span class="s0">, </span><span class="s1">get_kwarg):</span>
        <span class="s1">msg = </span><span class="s2">&quot;The `dtype` and `signature` arguments to ufuncs&quot;</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">**get_kwarg(np.dtype(</span><span class="s2">&quot;int64&quot;</span><span class="s1">).newbyteorder()))</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">**get_kwarg(np.dtype(</span><span class="s2">&quot;m8[ns]&quot;</span><span class="s1">)))</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">**get_kwarg(</span><span class="s2">&quot;m8[ns]&quot;</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;casting&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;unsafe&quot;</span><span class="s0">, </span><span class="s2">&quot;same_kind&quot;</span><span class="s0">, </span><span class="s2">&quot;safe&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_partial_signature_mismatch(self</span><span class="s0">, </span><span class="s1">casting):</span>
        <span class="s4"># If the second argument matches already, no need to specify it:</span>
        <span class="s1">res = np.ldexp(np.float32(</span><span class="s3">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.int_(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;d&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.dtype == </span><span class="s2">&quot;d&quot;</span>
        <span class="s1">res = np.ldexp(np.float32(</span><span class="s3">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.int_(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None, None, </span><span class="s2">&quot;d&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">res.dtype == </span><span class="s2">&quot;d&quot;</span>

        <span class="s4"># ldexp only has a loop for long input as second argument, overriding</span>
        <span class="s4"># the output cannot help with that (no matter the casting)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.ldexp(</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">np.uint64(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;d&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.ldexp(</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">np.uint64(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None, None, </span><span class="s2">&quot;d&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_partial_signature_mismatch_with_cache(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add(np.float16(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.uint64(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s4"># Ensure e,d-&gt;None is in the dispatching cache (double loop)</span>
        <span class="s1">np.add(np.float16(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.float64(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s4"># The error must still be raised:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add(np.float16(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.uint64(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sig=(</span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_use_output_signature_for_all_arguments(self):</span>
        <span class="s4"># Test that providing only `dtype=` or `signature=(None, None, dtype)`</span>
        <span class="s4"># is sufficient if falling back to a homogeneous signature works.</span>
        <span class="s4"># In this case, the `intp, intp -&gt; intp` loop is chosen.</span>
        <span class="s1">res = np.power(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.8</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res == </span><span class="s3">1  </span><span class="s4"># the cast happens first.</span>
        <span class="s1">res = np.power(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.8</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None, None, </span><span class="s1">np.intp)</span><span class="s0">,</span>
                       <span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res == </span><span class="s3">1</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s4"># the unsafe casting would normally cause errors though:</span>
            <span class="s1">np.power(</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.8</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

    <span class="s0">def </span><span class="s1">test_signature_errors(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">,</span>
                    <span class="s1">match=</span><span class="s2">&quot;the signature object to ufunc must be a string or&quot;</span><span class="s1">):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=</span><span class="s3">123.</span><span class="s1">)  </span><span class="s4"># neither a string nor a tuple</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s4"># bad symbols that do not translate to dtypes</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">&quot;%^-&gt;#&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=</span><span class="s6">b&quot;ii-i&quot;</span><span class="s1">)  </span><span class="s4"># incomplete and byte string</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">&quot;ii&gt;i&quot;</span><span class="s1">)  </span><span class="s4"># incomplete string</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None, </span><span class="s2">&quot;f8&quot;</span><span class="s1">))  </span><span class="s4"># bad length</span>

        <span class="s0">with </span><span class="s1">pytest.raises(UnicodeDecodeError):</span>
            <span class="s1">np.add(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">signature=</span><span class="s6">b&quot;</span><span class="s0">\xff\xff</span><span class="s6">-&gt;i&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_forced_dtype_times(self):</span>
        <span class="s4"># Signatures only set the type numbers (not the actual loop dtypes)</span>
        <span class="s4"># so using `M` in a signature/dtype should generally work:</span>
        <span class="s1">a = np.array([</span><span class="s2">'2010-01-02'</span><span class="s0">, </span><span class="s2">'1999-03-14'</span><span class="s0">, </span><span class="s2">'1833-03'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'&gt;M8[D]'</span><span class="s1">)</span>
        <span class="s1">np.maximum(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;M&quot;</span><span class="s1">)</span>
        <span class="s1">np.maximum.reduce(a</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;M&quot;</span><span class="s1">)</span>

        <span class="s1">arr = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;m8[s]&quot;</span><span class="s1">)</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;m&quot;</span><span class="s1">)</span>
        <span class="s1">np.maximum(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;m&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">, </span><span class="s1">[np.add</span><span class="s0">, </span><span class="s1">np.sqrt])</span>
    <span class="s0">def </span><span class="s1">test_cast_safety(self</span><span class="s0">, </span><span class="s1">ufunc):</span>
        <span class="s5">&quot;&quot;&quot;Basic test for the safest casts, because ufuncs inner loops can 
        indicate a cast-safety as well (which is normally always &quot;no&quot;). 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">call_ufunc(arr</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">return </span><span class="s1">ufunc(*(arr</span><span class="s0">,</span><span class="s1">) * ufunc.nin</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">arr = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">arr_bs = arr.astype(arr.dtype.newbyteorder())</span>
        <span class="s1">expected = call_ufunc(arr)</span>
        <span class="s4"># Normally, a &quot;no&quot; cast:</span>
        <span class="s1">res = call_ufunc(arr</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;no&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">res)</span>
        <span class="s4"># Byte-swapping is not allowed with &quot;no&quot; though:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">call_ufunc(arr_bs</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;no&quot;</span><span class="s1">)</span>

        <span class="s4"># But is allowed with &quot;equiv&quot;:</span>
        <span class="s1">res = call_ufunc(arr_bs</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;equiv&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">res)</span>

        <span class="s4"># Casting to float64 is safe, but not equiv:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">call_ufunc(arr_bs</span><span class="s0">, </span><span class="s1">dtype=np.float64</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;equiv&quot;</span><span class="s1">)</span>

        <span class="s4"># but it is safe cast:</span>
        <span class="s1">res = call_ufunc(arr_bs</span><span class="s0">, </span><span class="s1">dtype=np.float64</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;safe&quot;</span><span class="s1">)</span>
        <span class="s1">expected = call_ufunc(arr.astype(np.float64))  </span><span class="s4"># upcast</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">res)</span>

    <span class="s0">def </span><span class="s1">test_true_divide(self):</span>
        <span class="s1">a = np.array(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">b = np.array(</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">tgt = np.array(</span><span class="s3">0.5</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">tc </span><span class="s0">in </span><span class="s2">'bhilqBHILQefdgFDG'</span><span class="s1">:</span>
            <span class="s1">dt = np.dtype(tc)</span>
            <span class="s1">aa = a.astype(dt)</span>
            <span class="s1">bb = b.astype(dt)</span>

            <span class="s4"># Check result value and dtype.</span>
            <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y </span><span class="s0">in </span><span class="s1">itertools.product([aa</span><span class="s0">, </span><span class="s1">-aa]</span><span class="s0">, </span><span class="s1">[bb</span><span class="s0">, </span><span class="s1">-bb]):</span>

                <span class="s4"># Check with no output type specified</span>
                <span class="s0">if </span><span class="s1">tc </span><span class="s0">in </span><span class="s2">'FDG'</span><span class="s1">:</span>
                    <span class="s1">tgt = complex(x)/complex(y)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">tgt = float(x)/float(y)</span>

                <span class="s1">res = np.true_divide(x</span><span class="s0">, </span><span class="s1">y)</span>
                <span class="s1">rtol = max(np.finfo(res).resolution</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>
                <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

                <span class="s0">if </span><span class="s1">tc </span><span class="s0">in </span><span class="s2">'bhilqBHILQ'</span><span class="s1">:</span>
                    <span class="s1">assert_(res.dtype.name == </span><span class="s2">'float64'</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_(res.dtype.name == dt.name )</span>

                <span class="s4"># Check with output type specified.  This also checks for the</span>
                <span class="s4"># incorrect casts in issue gh-3484 because the unary '-' does</span>
                <span class="s4"># not change types, even for unsigned types, Hence casts in the</span>
                <span class="s4"># ufunc from signed to unsigned and vice versa will lead to</span>
                <span class="s4"># errors in the values.</span>
                <span class="s0">for </span><span class="s1">tcout </span><span class="s0">in </span><span class="s2">'bhilqBHILQ'</span><span class="s1">:</span>
                    <span class="s1">dtout = np.dtype(tcout)</span>
                    <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.true_divide</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dtype=dtout)</span>

                <span class="s0">for </span><span class="s1">tcout </span><span class="s0">in </span><span class="s2">'efdg'</span><span class="s1">:</span>
                    <span class="s1">dtout = np.dtype(tcout)</span>
                    <span class="s0">if </span><span class="s1">tc </span><span class="s0">in </span><span class="s2">'FDG'</span><span class="s1">:</span>
                        <span class="s4"># Casting complex to float is not allowed</span>
                        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.true_divide</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dtype=dtout)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">tgt = float(x)/float(y)</span>
                        <span class="s1">rtol = max(np.finfo(dtout).resolution</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>
                        <span class="s4"># The value of tiny for double double is NaN</span>
                        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                            <span class="s1">sup.filter(UserWarning)</span>
                            <span class="s0">if not </span><span class="s1">np.isnan(np.finfo(dtout).tiny):</span>
                                <span class="s1">atol = max(np.finfo(dtout).tiny</span><span class="s0">, </span><span class="s3">3e-308</span><span class="s1">)</span>
                            <span class="s0">else</span><span class="s1">:</span>
                                <span class="s1">atol = </span><span class="s3">3e-308</span>
                        <span class="s4"># Some test values result in invalid for float16</span>
                        <span class="s4"># and the cast to it may overflow to inf.</span>
                        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s0">, </span><span class="s1">over=</span><span class="s2">'ignore'</span><span class="s1">):</span>
                            <span class="s1">res = np.true_divide(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dtype=dtout)</span>
                        <span class="s0">if not </span><span class="s1">np.isfinite(res) </span><span class="s0">and </span><span class="s1">tcout == </span><span class="s2">'e'</span><span class="s1">:</span>
                            <span class="s0">continue</span>
                        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol)</span>
                        <span class="s1">assert_(res.dtype.name == dtout.name)</span>

                <span class="s0">for </span><span class="s1">tcout </span><span class="s0">in </span><span class="s2">'FDG'</span><span class="s1">:</span>
                    <span class="s1">dtout = np.dtype(tcout)</span>
                    <span class="s1">tgt = complex(x)/complex(y)</span>
                    <span class="s1">rtol = max(np.finfo(dtout).resolution</span><span class="s0">, </span><span class="s3">1e-15</span><span class="s1">)</span>
                    <span class="s4"># The value of tiny for double double is NaN</span>
                    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                        <span class="s1">sup.filter(UserWarning)</span>
                        <span class="s0">if not </span><span class="s1">np.isnan(np.finfo(dtout).tiny):</span>
                            <span class="s1">atol = max(np.finfo(dtout).tiny</span><span class="s0">, </span><span class="s3">3e-308</span><span class="s1">)</span>
                        <span class="s0">else</span><span class="s1">:</span>
                            <span class="s1">atol = </span><span class="s3">3e-308</span>
                    <span class="s1">res = np.true_divide(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dtype=dtout)</span>
                    <span class="s0">if not </span><span class="s1">np.isfinite(res):</span>
                        <span class="s0">continue</span>
                    <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">tgt</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol)</span>
                    <span class="s1">assert_(res.dtype.name == dtout.name)</span>

        <span class="s4"># Check booleans</span>
        <span class="s1">a = np.ones(()</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s1">res = np.true_divide(a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_(res == </span><span class="s3">1.0</span><span class="s1">)</span>
        <span class="s1">assert_(res.dtype.name == </span><span class="s2">'float64'</span><span class="s1">)</span>
        <span class="s1">res = np.true_divide(~a</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_(res == </span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">assert_(res.dtype.name == </span><span class="s2">'float64'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sum_stability(self):</span>
        <span class="s1">a = np.ones(</span><span class="s3">500</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">assert_almost_equal((a / </span><span class="s3">10.</span><span class="s1">).sum() - a.size / </span><span class="s3">10.</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>

        <span class="s1">a = np.ones(</span><span class="s3">500</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">assert_almost_equal((a / </span><span class="s3">10.</span><span class="s1">).sum() - a.size / </span><span class="s3">10.</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(IS_WASM</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;fp errors don't work in wasm&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_sum(self):</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">(int</span><span class="s0">, </span><span class="s1">np.float16</span><span class="s0">, </span><span class="s1">np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.longdouble):</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">127</span><span class="s0">,</span>
                      <span class="s3">128</span><span class="s0">, </span><span class="s3">1024</span><span class="s0">, </span><span class="s3">1235</span><span class="s1">):</span>
                <span class="s4"># warning if sum overflows, which it does in float16</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
                    <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>

                    <span class="s1">tgt = dt(v * (v + </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">)</span>
                    <span class="s1">overflow = </span><span class="s0">not </span><span class="s1">np.isfinite(tgt)</span>
                    <span class="s1">assert_equal(len(w)</span><span class="s0">, </span><span class="s3">1 </span><span class="s1">* overflow)</span>

                    <span class="s1">d = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">v + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=dt)</span>

                    <span class="s1">assert_almost_equal(np.sum(d)</span><span class="s0">, </span><span class="s1">tgt)</span>
                    <span class="s1">assert_equal(len(w)</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* overflow)</span>

                    <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">tgt)</span>
                    <span class="s1">assert_equal(len(w)</span><span class="s0">, </span><span class="s3">3 </span><span class="s1">* overflow)</span>

            <span class="s1">d = np.ones(</span><span class="s3">500</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[-</span><span class="s3">1</span><span class="s1">::-</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167.</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[-</span><span class="s3">1</span><span class="s1">::-</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167.</span><span class="s1">)</span>
            <span class="s4"># sum with first reduction entry != 0</span>
            <span class="s1">d = np.ones((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">d += d</span>
            <span class="s1">assert_almost_equal(d</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sum_complex(self):</span>
        <span class="s0">for </span><span class="s1">dt </span><span class="s0">in </span><span class="s1">(np.complex64</span><span class="s0">, </span><span class="s1">np.complex128</span><span class="s0">, </span><span class="s1">np.clongdouble):</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">127</span><span class="s0">,</span>
                      <span class="s3">128</span><span class="s0">, </span><span class="s3">1024</span><span class="s0">, </span><span class="s3">1235</span><span class="s1">):</span>
                <span class="s1">tgt = dt(v * (v + </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">) - dt((v * (v + </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">) * </span><span class="s3">1j</span><span class="s1">)</span>
                <span class="s1">d = np.empty(v</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
                <span class="s1">d.real = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">v + </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">d.imag = -np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">v + </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(np.sum(d)</span><span class="s0">, </span><span class="s1">tgt)</span>
                <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">tgt)</span>

            <span class="s1">d = np.ones(</span><span class="s3">500</span><span class="s0">, </span><span class="s1">dtype=dt) + </span><span class="s3">1j</span>
            <span class="s1">assert_almost_equal(np.sum(d[::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250. </span><span class="s1">+ </span><span class="s3">250j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250. </span><span class="s1">+ </span><span class="s3">250j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167. </span><span class="s1">+ </span><span class="s3">167j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167. </span><span class="s1">+ </span><span class="s3">167j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250. </span><span class="s1">+ </span><span class="s3">250j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[-</span><span class="s3">1</span><span class="s1">::-</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s3">250. </span><span class="s1">+ </span><span class="s3">250j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[::-</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167. </span><span class="s1">+ </span><span class="s3">167j</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(np.sum(d[-</span><span class="s3">1</span><span class="s1">::-</span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s3">167. </span><span class="s1">+ </span><span class="s3">167j</span><span class="s1">)</span>
            <span class="s4"># sum with first reduction entry != 0</span>
            <span class="s1">d = np.ones((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=dt) + </span><span class="s3">1j</span>
            <span class="s1">d += d</span>
            <span class="s1">assert_almost_equal(d</span><span class="s0">, </span><span class="s3">2. </span><span class="s1">+ </span><span class="s3">2j</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sum_initial(self):</span>
        <span class="s4"># Integer, single axis</span>
        <span class="s1">assert_equal(np.sum([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

        <span class="s4"># Floating point</span>
        <span class="s1">assert_almost_equal(np.sum([</span><span class="s3">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">0.1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.3</span><span class="s1">)</span>

        <span class="s4"># Multiple non-adjacent axes</span>
        <span class="s1">assert_equal(np.sum(np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                     <span class="s1">[</span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_sum_where(self):</span>
        <span class="s4"># More extensive tests done in test_reduction_with_where.</span>
        <span class="s1">assert_equal(np.sum([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">where=[</span><span class="s0">True, False</span><span class="s1">])</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">5.</span><span class="s0">,</span>
                            <span class="s1">where=[</span><span class="s0">True, False</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">9.</span><span class="s0">, </span><span class="s3">5.</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_inner1d(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.sum(a*a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.sum(a*a))</span>

    <span class="s0">def </span><span class="s1">test_broadcast(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;broadcast&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s1">msg = </span><span class="s2">&quot;extend &amp; broadcast loop dimensions&quot;</span>
        <span class="s1">b = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s4"># Broadcast in core dimensions should fail</span>
        <span class="s1">a = np.arange(</span><span class="s3">8</span><span class="s1">).reshape((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s4"># Extend core dimensions should fail</span>
        <span class="s1">a = np.arange(</span><span class="s3">8</span><span class="s1">).reshape((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.array(</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s4"># Broadcast should fail</span>
        <span class="s1">a = np.arange(</span><span class="s3">2</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">3</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s4"># Writing to a broadcasted array with overlap should warn, gh-2705</span>
        <span class="s1">a = np.arange(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">u</span><span class="s0">, </span><span class="s1">v = np.broadcast_arrays(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(u.strides[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">x = u + v</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">u += v</span>
            <span class="s1">assert_equal(len(w)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_(x[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] != u[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s4"># Output reduction should not be allowed.</span>
        <span class="s4"># See gh-15139</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">b = np.ones(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">out = np.empty(())</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s1">out2 = np.empty(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">c = umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out2)</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">out2)</span>

    <span class="s0">def </span><span class="s1">test_out_broadcasts(self):</span>
        <span class="s4"># For ufuncs and gufuncs (not for reductions), we currently allow</span>
        <span class="s4"># the output to cause broadcasting of the input arrays.</span>
        <span class="s4"># both along dimensions with shape 1 and dimensions which do not</span>
        <span class="s4"># exist at all in the inputs.</span>
        <span class="s1">arr = np.arange(</span><span class="s3">3</span><span class="s1">).reshape(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">out = np.empty((</span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s0">assert </span><span class="s1">(out == np.arange(</span><span class="s3">3</span><span class="s1">) * </span><span class="s3">2</span><span class="s1">).all()</span>

        <span class="s4"># The same holds for gufuncs (gh-16484)</span>
        <span class="s1">umt.inner1d(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s4"># the result would be just a scalar `5`, but is broadcast fully:</span>
        <span class="s0">assert </span><span class="s1">(out == </span><span class="s3">5</span><span class="s1">).all()</span>

    <span class="s1">@pytest.mark.parametrize([</span><span class="s2">&quot;arr&quot;</span><span class="s0">, </span><span class="s2">&quot;out&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span>
                <span class="s1">([</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.empty(()))</span><span class="s0">,</span>
                <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.empty(</span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s1">(np.ones((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.empty((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))]</span><span class="s0">,</span>
            <span class="s1">ids=[</span><span class="s2">&quot;(1,)-&gt;()&quot;</span><span class="s0">, </span><span class="s2">&quot;(2,)-&gt;(1,)&quot;</span><span class="s0">, </span><span class="s2">&quot;(4, 3)-&gt;(4, 1)&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_out_broadcast_errors(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out):</span>
        <span class="s4"># Output is (currently) allowed to broadcast inputs, but it cannot be</span>
        <span class="s4"># smaller than the actual result.</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;non-broadcastable&quot;</span><span class="s1">):</span>
            <span class="s1">np.positive(arr</span><span class="s0">, </span><span class="s1">out=out)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;non-broadcastable&quot;</span><span class="s1">):</span>
            <span class="s1">np.add(np.ones(())</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out=out)</span>

    <span class="s0">def </span><span class="s1">test_type_cast(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;type cast&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'short'</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.sum(a*a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">err_msg=msg)</span>
        <span class="s1">msg = </span><span class="s2">&quot;type cast on one argument&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = a + </span><span class="s3">0.1</span>
        <span class="s1">assert_array_almost_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_endian(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;big endian&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'&gt;i4'</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.sum(a*a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">err_msg=msg)</span>
        <span class="s1">msg = </span><span class="s2">&quot;little endian&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'&lt;i4'</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.sum(a*a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">err_msg=msg)</span>

        <span class="s4"># Output should always be native-endian</span>
        <span class="s1">Ba = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'&gt;f8'</span><span class="s1">)</span>
        <span class="s1">La = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'&lt;f8'</span><span class="s1">)</span>
        <span class="s1">assert_equal((Ba+Ba).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal((Ba+La).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal((La+Ba).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal((La+La).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>

        <span class="s1">assert_equal(np.absolute(La).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.absolute(Ba).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.negative(La).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.negative(Ba).dtype</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f8'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_incontiguous_array(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;incontiguous memory layout of array&quot;</span>
        <span class="s1">x = np.arange(</span><span class="s3">64</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">a = x[:</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,</span><span class="s1">:</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,</span><span class="s1">:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">b = x[:</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">a[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = -</span><span class="s3">1</span>
        <span class="s1">msg2 = </span><span class="s2">&quot;make sure it references to the original array&quot;</span>
        <span class="s1">assert_equal(x[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">err_msg=msg2)</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s1">x = np.arange(</span><span class="s3">24</span><span class="s1">).reshape(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">a = x.T</span>
        <span class="s1">b = x.T</span>
        <span class="s1">a[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = -</span><span class="s3">1</span>
        <span class="s1">assert_equal(x[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">err_msg=msg2)</span>
        <span class="s1">assert_array_equal(umt.inner1d(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_output_argument(self):</span>
        <span class="s1">msg = </span><span class="s2">&quot;output argument&quot;</span>
        <span class="s1">a = np.arange(</span><span class="s3">12</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">4</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)) + </span><span class="s3">1</span>
        <span class="s1">c = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'int'</span><span class="s1">)</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s1">c[:] = -</span><span class="s3">1</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

        <span class="s1">msg = </span><span class="s2">&quot;output argument with type cast&quot;</span>
        <span class="s1">c = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'int16'</span><span class="s1">)</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s1">c[:] = -</span><span class="s3">1</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

        <span class="s1">msg = </span><span class="s2">&quot;output argument with incontiguous layout&quot;</span>
        <span class="s1">c = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'int16'</span><span class="s1">)</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
        <span class="s1">c[:] = -</span><span class="s3">1</span>
        <span class="s1">umt.inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c[...</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.sum(a*b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_axes_argument(self):</span>
        <span class="s4"># inner1d signature: '(i),(i)-&gt;()'</span>
        <span class="s1">inner1d = umt.inner1d</span>
        <span class="s1">a = np.arange(</span><span class="s3">27.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10.</span><span class="s0">, </span><span class="s3">19.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s4"># basic tests on inputs (outputs tested below with matrix_multiply).</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># default</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">()])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># integers ok for single axis.</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">()])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># mix fine</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">()])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># can omit last axis.</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># can pass in other types of integer (with __index__ protocol)</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[np.int8(-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=np.int32)])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># swap some axes</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># Check errors for improperly constructed axes arguments.</span>
        <span class="s4"># should have list.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s4"># needs enough elements</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s4"># should pass in indices.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">1.0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s0">None, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s4"># cannot pass an index unless there is only one dimension</span>
        <span class="s4"># (output is wrong in this case)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s4"># or pass in generally the wrong number of axes</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">()])</span>
        <span class="s4"># axes need to have same length.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

        <span class="s4"># matrix_multiply signature: '(m,n),(n,p)-&gt;(m,p)'</span>
        <span class="s1">mm = umt.matrix_multiply</span>
        <span class="s1">a = np.arange(</span><span class="s3">12</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">8</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)) + </span><span class="s3">1</span>
        <span class="s4"># Sanity check.</span>
        <span class="s1">c = mm(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s4"># Default axes.</span>
        <span class="s1">c = mm(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s4"># Default with explicit axes.</span>
        <span class="s1">c = mm(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s4"># swap some axes.</span>
        <span class="s1">c = mm(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                        <span class="s1">b.transpose(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>
        <span class="s4"># Default with output array.</span>
        <span class="s1">c = np.empty((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">d = mm(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c</span><span class="s0">, </span><span class="s1">axes=[(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">d)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a</span><span class="s0">, </span><span class="s1">b))</span>
        <span class="s4"># Transposed output array</span>
        <span class="s1">c = np.empty((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">d = mm(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)])</span>
        <span class="s1">assert_(c </span><span class="s0">is </span><span class="s1">d)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">np.matmul(a</span><span class="s0">, </span><span class="s1">b).transpose(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s4"># Check errors for improperly constructed axes arguments.</span>
        <span class="s4"># wrong argument</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s4"># axes should be list</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=((-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)))</span>
        <span class="s4"># list needs to have right length</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s4"># list should contain tuples for multiple axes</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">,</span>
                      <span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[[-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">,</span>
                      <span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">])</span>
        <span class="s4"># tuples should not have duplicated values</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)])</span>
        <span class="s4"># arrays should have enough axes.</span>
        <span class="s1">z = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">z[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">out=z[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">z[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">out=z[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s4"># Regular ufuncs should not accept axes.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s4"># should be able to deal with bad unrelated kwargs.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">parrot=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_axis_argument(self):</span>
        <span class="s4"># inner1d signature: '(i),(i)-&gt;()'</span>
        <span class="s1">inner1d = umt.inner1d</span>
        <span class="s1">a = np.arange(</span><span class="s3">27.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10.</span><span class="s0">, </span><span class="s3">19.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">out = np.zeros_like(c)</span>
        <span class="s1">d = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_(d </span><span class="s0">is </span><span class="s1">out)</span>
        <span class="s1">assert_array_equal(d</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s4"># Sanity checks on innerwt and cumsum.</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">16</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">w = np.arange(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">26</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">np.sum(a * b * w</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.cumsum(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.cumsum(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.cumsum(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.cumsum(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">out = np.empty_like(a)</span>
        <span class="s1">b = umt.cumsum(a</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_(out </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(b</span><span class="s0">, </span><span class="s1">np.cumsum(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">b = umt.cumsum(a</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_(out </span><span class="s0">is </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(b</span><span class="s0">, </span><span class="s1">np.cumsum(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s4"># Check errors.</span>
        <span class="s4"># Cannot pass in both axis and axes.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s4"># Not an integer.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s4"># more than 1 core dimensions.</span>
        <span class="s1">mm = umt.matrix_multiply</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s4"># Output wrong size in axis.</span>
        <span class="s1">out = np.empty((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.cumsum</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s4"># Regular ufuncs should not accept axis.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_keepdims_argument(self):</span>
        <span class="s4"># inner1d signature: '(i),(i)-&gt;()'</span>
        <span class="s1">inner1d = umt.inner1d</span>
        <span class="s1">a = np.arange(</span><span class="s3">27.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10.</span><span class="s0">, </span><span class="s3">19.</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">out = np.zeros_like(c)</span>
        <span class="s1">d = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True, </span><span class="s1">out=out)</span>
        <span class="s1">assert_(d </span><span class="s0">is </span><span class="s1">out)</span>
        <span class="s1">assert_array_equal(d</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s4"># Now combined with axis and axes.</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">()]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b).sum(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) * b).sum(-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) * b).sum(-</span><span class="s3">1</span><span class="s0">,</span>
                                                             <span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) * b).sum(-</span><span class="s3">1</span><span class="s0">,</span>
                                                             <span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a * b.transpose(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)).sum(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s4"># Hardly useful, but should work.</span>
        <span class="s1">c = inner1d(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">(a.transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) * b.transpose(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
                           <span class="s1">.sum(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s4"># Check with two core dimensions.</span>
        <span class="s1">a = np.eye(</span><span class="s3">3</span><span class="s1">) * np.arange(</span><span class="s3">4.</span><span class="s1">)[:</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">expected = uml.det(a)</span>
        <span class="s1">c = uml.det(a</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">c = uml.det(a</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(c</span><span class="s0">, </span><span class="s1">expected[:</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">np.newaxis])</span>
        <span class="s1">a = np.eye(</span><span class="s3">3</span><span class="s1">) * np.arange(</span><span class="s3">4.</span><span class="s1">)[:</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">expected_s</span><span class="s0">, </span><span class="s1">expected_l = uml.slogdet(a)</span>
        <span class="s1">cs</span><span class="s0">, </span><span class="s1">cl = uml.slogdet(a</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(cs</span><span class="s0">, </span><span class="s1">expected_s)</span>
        <span class="s1">assert_array_equal(cl</span><span class="s0">, </span><span class="s1">expected_l)</span>
        <span class="s1">cs</span><span class="s0">, </span><span class="s1">cl = uml.slogdet(a</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(cs</span><span class="s0">, </span><span class="s1">expected_s[:</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">np.newaxis])</span>
        <span class="s1">assert_array_equal(cl</span><span class="s0">, </span><span class="s1">expected_l[:</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">, </span><span class="s1">np.newaxis])</span>
        <span class="s4"># Sanity check on innerwt.</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">16</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">w = np.arange(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">26</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">np.sum(a * b * w</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">np.sum(a * b * w</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s4"># Check errors.</span>
        <span class="s4"># Not a boolean</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">inner1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s2">'true'</span><span class="s1">)</span>
        <span class="s4"># More than 1 core dimension, and core output dimensions.</span>
        <span class="s1">mm = umt.matrix_multiply</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mm</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s4"># Regular ufuncs should not accept keepdims.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_innerwt(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">6</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">16</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">w = np.arange(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">26</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">, </span><span class="s1">np.sum(a*b*w</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">a = np.arange(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">124</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">200</span><span class="s0">, </span><span class="s3">224</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">w = np.arange(</span><span class="s3">300</span><span class="s0">, </span><span class="s3">324</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">, </span><span class="s1">np.sum(a*b*w</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_innerwt_empty(self):</span>
        <span class="s5">&quot;&quot;&quot;Test generalized ufunc with zero-sized operands&quot;&quot;&quot;</span>
        <span class="s1">a = np.array([]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">b = np.array([]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">w = np.array([]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(umt.innerwt(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">, </span><span class="s1">np.sum(a*b*w</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_cross1d(self):</span>
        <span class="s5">&quot;&quot;&quot;Test with fixed-sized signature.&quot;&quot;&quot;</span>
        <span class="s1">a = np.eye(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(umt.cross1d(a</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)))</span>
        <span class="s1">out = np.zeros((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">result = umt.cross1d(a[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s1">assert_(result </span><span class="s0">is </span><span class="s1">out)</span>
        <span class="s1">assert_array_equal(result</span><span class="s0">, </span><span class="s1">np.vstack((np.zeros(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">a[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">-a[</span><span class="s3">1</span><span class="s1">])))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.cross1d</span><span class="s0">, </span><span class="s1">np.eye(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.eye(</span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.cross1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4.</span><span class="s1">))</span>
        <span class="s4"># Wrong output core dimension.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.cross1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)))</span>
        <span class="s4"># Wrong output broadcast dimension (see gh-15139).</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.cross1d</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.zeros(</span><span class="s3">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_can_ignore_signature(self):</span>
        <span class="s4"># Comparing the effects of ? in signature:</span>
        <span class="s4"># matrix_multiply: (m,n),(n,p)-&gt;(m,p)    # all must be there.</span>
        <span class="s4"># matmul:        (m?,n),(n,p?)-&gt;(m?,p?)  # allow missing m, p.</span>
        <span class="s1">mat = np.arange(</span><span class="s3">12</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">single_vec = np.arange(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">col_vec = single_vec[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s1">col_vec_array = np.arange(</span><span class="s3">8</span><span class="s1">).reshape((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)) + </span><span class="s3">1</span>
        <span class="s4"># matrix @ single column vector with proper dimension</span>
        <span class="s1">mm_col_vec = umt.matrix_multiply(mat</span><span class="s0">, </span><span class="s1">col_vec)</span>
        <span class="s4"># matmul does the same thing</span>
        <span class="s1">matmul_col_vec = umt.matmul(mat</span><span class="s0">, </span><span class="s1">col_vec)</span>
        <span class="s1">assert_array_equal(matmul_col_vec</span><span class="s0">, </span><span class="s1">mm_col_vec)</span>
        <span class="s4"># matrix @ vector without dimension making it a column vector.</span>
        <span class="s4"># matrix multiply fails -&gt; missing core dim.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.matrix_multiply</span><span class="s0">, </span><span class="s1">mat</span><span class="s0">, </span><span class="s1">single_vec)</span>
        <span class="s4"># matmul mimicker passes, and returns a vector.</span>
        <span class="s1">matmul_col = umt.matmul(mat</span><span class="s0">, </span><span class="s1">single_vec)</span>
        <span class="s1">assert_array_equal(matmul_col</span><span class="s0">, </span><span class="s1">mm_col_vec.squeeze())</span>
        <span class="s4"># Now with a column array: same as for column vector,</span>
        <span class="s4"># broadcasting sensibly.</span>
        <span class="s1">mm_col_vec = umt.matrix_multiply(mat</span><span class="s0">, </span><span class="s1">col_vec_array)</span>
        <span class="s1">matmul_col_vec = umt.matmul(mat</span><span class="s0">, </span><span class="s1">col_vec_array)</span>
        <span class="s1">assert_array_equal(matmul_col_vec</span><span class="s0">, </span><span class="s1">mm_col_vec)</span>
        <span class="s4"># As above, but for row vector</span>
        <span class="s1">single_vec = np.arange(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">row_vec = single_vec[np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>
        <span class="s1">row_vec_array = np.arange(</span><span class="s3">24</span><span class="s1">).reshape((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)) + </span><span class="s3">1</span>
        <span class="s4"># row vector @ matrix</span>
        <span class="s1">mm_row_vec = umt.matrix_multiply(row_vec</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">matmul_row_vec = umt.matmul(row_vec</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">assert_array_equal(matmul_row_vec</span><span class="s0">, </span><span class="s1">mm_row_vec)</span>
        <span class="s4"># single row vector @ matrix</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.matrix_multiply</span><span class="s0">, </span><span class="s1">single_vec</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">matmul_row = umt.matmul(single_vec</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">assert_array_equal(matmul_row</span><span class="s0">, </span><span class="s1">mm_row_vec.squeeze())</span>
        <span class="s4"># row vector array @ matrix</span>
        <span class="s1">mm_row_vec = umt.matrix_multiply(row_vec_array</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">matmul_row_vec = umt.matmul(row_vec_array</span><span class="s0">, </span><span class="s1">mat)</span>
        <span class="s1">assert_array_equal(matmul_row_vec</span><span class="s0">, </span><span class="s1">mm_row_vec)</span>
        <span class="s4"># Now for vector combinations</span>
        <span class="s4"># row vector @ column vector</span>
        <span class="s1">col_vec = row_vec.T</span>
        <span class="s1">col_vec_array = row_vec_array.swapaxes(-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">mm_row_col_vec = umt.matrix_multiply(row_vec</span><span class="s0">, </span><span class="s1">col_vec)</span>
        <span class="s1">matmul_row_col_vec = umt.matmul(row_vec</span><span class="s0">, </span><span class="s1">col_vec)</span>
        <span class="s1">assert_array_equal(matmul_row_col_vec</span><span class="s0">, </span><span class="s1">mm_row_col_vec)</span>
        <span class="s4"># single row vector @ single col vector</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.matrix_multiply</span><span class="s0">, </span><span class="s1">single_vec</span><span class="s0">, </span><span class="s1">single_vec)</span>
        <span class="s1">matmul_row_col = umt.matmul(single_vec</span><span class="s0">, </span><span class="s1">single_vec)</span>
        <span class="s1">assert_array_equal(matmul_row_col</span><span class="s0">, </span><span class="s1">mm_row_col_vec.squeeze())</span>
        <span class="s4"># row vector array @ matrix</span>
        <span class="s1">mm_row_col_array = umt.matrix_multiply(row_vec_array</span><span class="s0">, </span><span class="s1">col_vec_array)</span>
        <span class="s1">matmul_row_col_array = umt.matmul(row_vec_array</span><span class="s0">, </span><span class="s1">col_vec_array)</span>
        <span class="s1">assert_array_equal(matmul_row_col_array</span><span class="s0">, </span><span class="s1">mm_row_col_array)</span>
        <span class="s4"># Finally, check that things are *not* squeezed if one gives an</span>
        <span class="s4"># output.</span>
        <span class="s1">out = np.zeros_like(mm_row_col_array)</span>
        <span class="s1">out = umt.matrix_multiply(row_vec_array</span><span class="s0">, </span><span class="s1">col_vec_array</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">mm_row_col_array)</span>
        <span class="s1">out[:] = </span><span class="s3">0</span>
        <span class="s1">out = umt.matmul(row_vec_array</span><span class="s0">, </span><span class="s1">col_vec_array</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">mm_row_col_array)</span>
        <span class="s4"># And check one cannot put missing dimensions back.</span>
        <span class="s1">out = np.zeros_like(mm_row_col_vec)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.matrix_multiply</span><span class="s0">, </span><span class="s1">single_vec</span><span class="s0">, </span><span class="s1">single_vec</span><span class="s0">,</span>
                      <span class="s1">out)</span>
        <span class="s4"># But fine for matmul, since it is just a broadcast.</span>
        <span class="s1">out = umt.matmul(single_vec</span><span class="s0">, </span><span class="s1">single_vec</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">mm_row_col_vec.squeeze())</span>

    <span class="s0">def </span><span class="s1">test_matrix_multiply(self):</span>
        <span class="s1">self.compare_matrix_multiply_results(np.int64)</span>
        <span class="s1">self.compare_matrix_multiply_results(np.double)</span>

    <span class="s0">def </span><span class="s1">test_matrix_multiply_umath_empty(self):</span>
        <span class="s1">res = umt.matrix_multiply(np.ones((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)))</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)))</span>
        <span class="s1">res = umt.matrix_multiply(np.ones((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)))</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">compare_matrix_multiply_results(self</span><span class="s0">, </span><span class="s1">tp):</span>
        <span class="s1">d1 = np.array(np.random.rand(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=tp)</span>
        <span class="s1">d2 = np.array(np.random.rand(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=tp)</span>
        <span class="s1">msg = </span><span class="s2">&quot;matrix multiply on type %s&quot; </span><span class="s1">% d1.dtype.name</span>

        <span class="s0">def </span><span class="s1">permute_n(n):</span>
            <span class="s0">if </span><span class="s1">n == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">ret = ()</span>
            <span class="s1">base = permute_n(n-</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">perm </span><span class="s0">in </span><span class="s1">base:</span>
                <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
                    <span class="s1">new = perm + [n-</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">new[n-</span><span class="s3">1</span><span class="s1">] = new[i]</span>
                    <span class="s1">new[i] = n-</span><span class="s3">1</span>
                    <span class="s1">ret += (new</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">ret</span>

        <span class="s0">def </span><span class="s1">slice_n(n):</span>
            <span class="s0">if </span><span class="s1">n == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">(()</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">ret = ()</span>
            <span class="s1">base = slice_n(n-</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">sl </span><span class="s0">in </span><span class="s1">base:</span>
                <span class="s1">ret += (sl+(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s1">ret += (sl+(slice(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">ret</span>

        <span class="s0">def </span><span class="s1">broadcastable(s1</span><span class="s0">, </span><span class="s1">s2):</span>
            <span class="s0">return </span><span class="s1">s1 == s2 </span><span class="s0">or </span><span class="s1">s1 == </span><span class="s3">1 </span><span class="s0">or </span><span class="s1">s2 == </span><span class="s3">1</span>

        <span class="s1">permute_3 = permute_n(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">slice_3 = slice_n(</span><span class="s3">3</span><span class="s1">) + ((slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)*</span><span class="s3">3</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">ref = </span><span class="s0">True</span>
        <span class="s0">for </span><span class="s1">p1 </span><span class="s0">in </span><span class="s1">permute_3:</span>
            <span class="s0">for </span><span class="s1">p2 </span><span class="s0">in </span><span class="s1">permute_3:</span>
                <span class="s0">for </span><span class="s1">s1 </span><span class="s0">in </span><span class="s1">slice_3:</span>
                    <span class="s0">for </span><span class="s1">s2 </span><span class="s0">in </span><span class="s1">slice_3:</span>
                        <span class="s1">a1 = d1.transpose(p1)[s1]</span>
                        <span class="s1">a2 = d2.transpose(p2)[s2]</span>
                        <span class="s1">ref = ref </span><span class="s0">and </span><span class="s1">a1.base </span><span class="s0">is not None</span>
                        <span class="s1">ref = ref </span><span class="s0">and </span><span class="s1">a2.base </span><span class="s0">is not None</span>
                        <span class="s0">if </span><span class="s1">(a1.shape[-</span><span class="s3">1</span><span class="s1">] == a2.shape[-</span><span class="s3">2</span><span class="s1">] </span><span class="s0">and</span>
                                <span class="s1">broadcastable(a1.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a2.shape[</span><span class="s3">0</span><span class="s1">])):</span>
                            <span class="s1">assert_array_almost_equal(</span>
                                <span class="s1">umt.matrix_multiply(a1</span><span class="s0">, </span><span class="s1">a2)</span><span class="s0">,</span>
                                <span class="s1">np.sum(a2[...</span><span class="s0">, </span><span class="s1">np.newaxis].swapaxes(-</span><span class="s3">3</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">) *</span>
                                       <span class="s1">a1[...</span><span class="s0">, </span><span class="s1">np.newaxis</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                <span class="s1">err_msg=msg + </span><span class="s2">' %s %s' </span><span class="s1">% (str(a1.shape)</span><span class="s0">,</span>
                                                          <span class="s1">str(a2.shape)))</span>

        <span class="s1">assert_equal(ref</span><span class="s0">, True, </span><span class="s1">err_msg=</span><span class="s2">&quot;reference check&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_euclidean_pdist(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">12</span><span class="s0">, </span><span class="s1">dtype=float).reshape(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">out = np.empty((a.shape[</span><span class="s3">0</span><span class="s1">] * (a.shape[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">) // </span><span class="s3">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>
        <span class="s1">umt.euclidean_pdist(a</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s1">b = np.sqrt(np.sum((a[:</span><span class="s0">, None</span><span class="s1">] - a)**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">b = b[~np.tri(a.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)]</span>
        <span class="s1">assert_almost_equal(out</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s4"># An output array is required to determine p with signature (n,d)-&gt;(p)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">umt.euclidean_pdist</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_cumsum(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">result = umt.cumsum(a)</span>
        <span class="s1">assert_array_equal(result</span><span class="s0">, </span><span class="s1">a.cumsum())</span>

    <span class="s0">def </span><span class="s1">test_object_logical(self):</span>
        <span class="s1">a = np.array([</span><span class="s3">3</span><span class="s0">, None, True, False, </span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_equal(np.logical_or(a</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">or None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_or(a</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">or True for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_or(a</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">or </span><span class="s3">12 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_or(a</span><span class="s0">, </span><span class="s2">&quot;blah&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">or </span><span class="s2">&quot;blah&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>

        <span class="s1">assert_equal(np.logical_and(a</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">and None for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_and(a</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">and True for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_and(a</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">and </span><span class="s3">12 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_equal(np.logical_and(a</span><span class="s0">, </span><span class="s2">&quot;blah&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">np.array([x </span><span class="s0">and </span><span class="s2">&quot;blah&quot; </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>

        <span class="s1">assert_equal(np.logical_not(a)</span><span class="s0">,</span>
                        <span class="s1">np.array([</span><span class="s0">not </span><span class="s1">x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a]</span><span class="s0">, </span><span class="s1">dtype=object))</span>

        <span class="s1">assert_equal(np.logical_or.reduce(a)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.logical_and.reduce(a)</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_object_comparison(self):</span>
        <span class="s0">class </span><span class="s1">HasComparisons:</span>
            <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s0">return </span><span class="s2">'=='</span>

        <span class="s1">arr0d = np.array(HasComparisons())</span>
        <span class="s1">assert_equal(arr0d == arr0d</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.equal(arr0d</span><span class="s0">, </span><span class="s1">arr0d)</span><span class="s0">, True</span><span class="s1">)  </span><span class="s4"># normal behavior is a cast</span>

        <span class="s1">arr1d = np.array([HasComparisons()])</span>
        <span class="s1">assert_equal(arr1d == arr1d</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True</span><span class="s1">]))</span>
        <span class="s1">assert_equal(np.equal(arr1d</span><span class="s0">, </span><span class="s1">arr1d)</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True</span><span class="s1">]))  </span><span class="s4"># normal behavior is a cast</span>
        <span class="s1">assert_equal(np.equal(arr1d</span><span class="s0">, </span><span class="s1">arr1d</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">'=='</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_object_array_reduction(self):</span>
        <span class="s4"># Reductions on object arrays</span>
        <span class="s1">a = np.array([</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_equal(np.sum(a)</span><span class="s0">, </span><span class="s2">'abc'</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.max(a)</span><span class="s0">, </span><span class="s2">'c'</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.min(a)</span><span class="s0">, </span><span class="s2">'a'</span><span class="s1">)</span>
        <span class="s1">a = np.array([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_equal(np.sum(a)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.prod(a)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.any(a)</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.all(a)</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.max(a)</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.min(a)</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.array([[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object).sum()</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.array([[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]]</span><span class="s0">, </span><span class="s1">dtype=object).sum((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.array([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object).sum(initial=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.array([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
                     <span class="s1">.sum(initial=[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">where=[</span><span class="s0">False, True</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_object_array_accumulate_inplace(self):</span>
        <span class="s4"># Checks that in-place accumulates work, see also gh-7402</span>
        <span class="s1">arr = np.ones(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arr[:] = [[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s4"># Twice reproduced also for tuples:</span>
        <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=arr)</span>
        <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=arr)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">,</span>
                           <span class="s1">np.array([[</span><span class="s3">1</span><span class="s1">]*i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
                          <span class="s1">)</span>

        <span class="s4"># And the same if the axis argument is used</span>
        <span class="s1">arr = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arr[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:] = [[</span><span class="s3">2</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=arr</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=arr</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">,</span>
                           <span class="s1">np.array([[</span><span class="s3">2</span><span class="s1">]*i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
                          <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_object_array_accumulate_failure(self):</span>
        <span class="s4"># Typical accumulation on object works as expected:</span>
        <span class="s1">res = np.add.accumulate(np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s4"># But errors are propagated from the inner-loop if they occur:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.accumulate([</span><span class="s3">1</span><span class="s0">, None, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_object_array_reduceat_inplace(self):</span>
        <span class="s4"># Checks that in-place reduceats work, see also gh-7465</span>
        <span class="s1">arr = np.empty(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arr[:] = [[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s1">out = np.empty(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">out[:] = [[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=arr)</span>
        <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=arr)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s4"># And the same if the axis argument is used</span>
        <span class="s1">arr = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">arr[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:] = [[</span><span class="s3">2</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s1">out = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">out[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:] = [[</span><span class="s3">2</span><span class="s1">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
        <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=arr</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=arr</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_object_array_reduceat_failure(self):</span>
        <span class="s4"># Reduceat works as expected when no invalid operation occurs (None is</span>
        <span class="s4"># not involved in an operation here)</span>
        <span class="s1">res = np.add.reduceat(np.array([</span><span class="s3">1</span><span class="s0">, None, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(res</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">None, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object))</span>
        <span class="s4"># But errors when None would be involved in an operation:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.reduceat([</span><span class="s3">1</span><span class="s0">, None, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_zerosize_reduction(self):</span>
        <span class="s4"># Test with default dtype and object dtype</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">[[]</span><span class="s0">, </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=object)]:</span>
            <span class="s1">assert_equal(np.sum(a)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(np.prod(a)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">assert_equal(np.any(a)</span><span class="s0">, False</span><span class="s1">)</span>
            <span class="s1">assert_equal(np.all(a)</span><span class="s0">, True</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.max</span><span class="s0">, </span><span class="s1">a)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.min</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_axis_out_of_bounds(self):</span>
        <span class="s1">a = np.array([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s0">, </span><span class="s1">a.all</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">a = np.array([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s0">, </span><span class="s1">a.all</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">a = np.array([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s0">, </span><span class="s1">a.any</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">a = np.array([</span><span class="s0">False, False</span><span class="s1">])</span>
        <span class="s1">assert_raises(np.AxisError</span><span class="s0">, </span><span class="s1">a.any</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_reduction(self):</span>
        <span class="s4"># The functions 'sum', 'prod', etc allow specifying axis=0</span>
        <span class="s4"># even for scalars</span>
        <span class="s1">assert_equal(np.sum(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.prod(</span><span class="s3">3.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.any(</span><span class="s0">True, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.all(</span><span class="s0">False, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.max(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.min(</span><span class="s3">2.5</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">)</span>

        <span class="s4"># Check scalar behaviour for ufuncs without an identity</span>
        <span class="s1">assert_equal(np.power.reduce(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s4"># Make sure that scalars are coming out from this operation</span>
        <span class="s1">assert_(type(np.prod(np.float32(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)) </span><span class="s0">is </span><span class="s1">np.float32)</span>
        <span class="s1">assert_(type(np.sum(np.float32(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)) </span><span class="s0">is </span><span class="s1">np.float32)</span>
        <span class="s1">assert_(type(np.max(np.float32(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)) </span><span class="s0">is </span><span class="s1">np.float32)</span>
        <span class="s1">assert_(type(np.min(np.float32(</span><span class="s3">2.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)) </span><span class="s0">is </span><span class="s1">np.float32)</span>

        <span class="s4"># check if scalars/0-d arrays get cast</span>
        <span class="s1">assert_(type(np.any(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)) </span><span class="s0">is </span><span class="s1">np.bool_)</span>

        <span class="s4"># assert that 0-d arrays get wrapped</span>
        <span class="s0">class </span><span class="s1">MyArray(np.ndarray):</span>
            <span class="s0">pass</span>
        <span class="s1">a = np.array(</span><span class="s3">1</span><span class="s1">).view(MyArray)</span>
        <span class="s1">assert_(type(np.any(a)) </span><span class="s0">is </span><span class="s1">MyArray)</span>

    <span class="s0">def </span><span class="s1">test_casting_out_param(self):</span>
        <span class="s4"># Test that it's possible to do casts on output</span>
        <span class="s1">a = np.ones((</span><span class="s3">200</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.int64)</span>
        <span class="s1">b = np.ones((</span><span class="s3">200</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.int64)</span>
        <span class="s1">c = np.ones((</span><span class="s3">200</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.float64)</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c)</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">a = np.zeros(</span><span class="s3">65536</span><span class="s1">)</span>
        <span class="s1">b = np.zeros(</span><span class="s3">65536</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">np.subtract(a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=b)</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_where_param(self):</span>
        <span class="s4"># Test that the where= ufunc parameter works with regular arrays</span>
        <span class="s1">a = np.arange(</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">b = np.ones(</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">c = np.zeros(</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c</span><span class="s0">, </span><span class="s1">where=(a % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">a = np.arange(</span><span class="s3">4</span><span class="s1">).reshape(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) + </span><span class="s3">2</span>
        <span class="s1">np.power(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=a</span><span class="s0">, </span><span class="s1">where=[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">27</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">16</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
        <span class="s4"># Broadcasting the where= parameter</span>
        <span class="s1">np.subtract(a</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">out=a</span><span class="s0">, </span><span class="s1">where=[</span><span class="s0">True, False</span><span class="s1">])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">27</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">14</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_where_param_buffer_output(self):</span>
        <span class="s4"># This test is temporarily skipped because it requires</span>
        <span class="s4"># adding masking features to the nditer to work properly</span>

        <span class="s4"># With casting on output</span>
        <span class="s1">a = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">np.int64)</span>
        <span class="s1">b = np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">np.int64)</span>
        <span class="s1">c = </span><span class="s3">1.5 </span><span class="s1">* np.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">np.float64)</span>
        <span class="s1">np.add(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">out=c</span><span class="s0">, </span><span class="s1">where=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(c</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_where_param_alloc(self):</span>
        <span class="s4"># With casting and allocated output</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>
        <span class="s1">m = np.array([</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_equal(np.sqrt(a</span><span class="s0">, </span><span class="s1">where=m)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s4"># No casting and allocated output</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">m = np.array([</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_equal(np.sqrt(a</span><span class="s0">, </span><span class="s1">where=m)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_where_with_broadcasting(self):</span>
        <span class="s4"># See gh-17198</span>
        <span class="s1">a = np.random.random((</span><span class="s3">5000</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">b = np.random.random((</span><span class="s3">5000</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s1">where = a &gt; </span><span class="s3">0.3</span>
        <span class="s1">out = np.full_like(a</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">np.less(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">where=where</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">b_where = np.broadcast_to(b</span><span class="s0">, </span><span class="s1">a.shape)[where]</span>
        <span class="s1">assert_array_equal((a[where] &lt; b_where)</span><span class="s0">, </span><span class="s1">out[where].astype(bool))</span>
        <span class="s0">assert not </span><span class="s1">out[~where].any()  </span><span class="s4"># outside mask, out remains all 0</span>

    <span class="s0">def </span><span class="s1">check_identityless_reduction(self</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s4"># np.minimum.reduce is an identityless reduction</span>

        <span class="s4"># Verify that it sees the zero at various positions</span>
        <span class="s1">a[...] = </span><span class="s3">1</span>
        <span class="s1">a[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=())</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s1">a[...] = </span><span class="s3">1</span>
        <span class="s1">a[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=())</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s1">a[...] = </span><span class="s3">1</span>
        <span class="s1">a[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">assert_equal(np.minimum.reduce(a</span><span class="s0">, </span><span class="s1">axis=())</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s1">@requires_memory(</span><span class="s3">6 </span><span class="s1">* </span><span class="s3">1024</span><span class="s1">**</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_identityless_reduction_huge_array(self):</span>
        <span class="s4"># Regression test for gh-20921 (copying identity incorrectly failed)</span>
        <span class="s1">arr = np.zeros((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**</span><span class="s3">31</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'uint8'</span><span class="s1">)</span>
        <span class="s1">arr[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">arr[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] = [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">res = np.maximum.reduce(arr</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">del </span><span class="s1">arr</span>
        <span class="s0">assert </span><span class="s1">res[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">3</span>
        <span class="s0">assert </span><span class="s1">res[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">4</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_corder(self):</span>
        <span class="s1">a = np.empty((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'C'</span><span class="s1">)</span>
        <span class="s1">self.check_identityless_reduction(a)</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_forder(self):</span>
        <span class="s1">a = np.empty((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'F'</span><span class="s1">)</span>
        <span class="s1">self.check_identityless_reduction(a)</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_otherorder(self):</span>
        <span class="s1">a = np.empty((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'C'</span><span class="s1">).swapaxes(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.check_identityless_reduction(a)</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_noncontig(self):</span>
        <span class="s1">a = np.empty((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">order=</span><span class="s2">'C'</span><span class="s1">).swapaxes(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">a = a[</span><span class="s3">1</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self.check_identityless_reduction(a)</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_noncontig_unaligned(self):</span>
        <span class="s1">a = np.empty((</span><span class="s3">3</span><span class="s1">*</span><span class="s3">4</span><span class="s1">*</span><span class="s3">5</span><span class="s1">*</span><span class="s3">8 </span><span class="s1">+ </span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i1'</span><span class="s1">)</span>
        <span class="s1">a = a[</span><span class="s3">1</span><span class="s1">:].view(dtype=</span><span class="s2">'f8'</span><span class="s1">)</span>
        <span class="s1">a.shape = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">a = a[</span><span class="s3">1</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self.check_identityless_reduction(a)</span>

    <span class="s0">def </span><span class="s1">test_initial_reduction(self):</span>
        <span class="s4"># np.minimum.reduce is an identityless reduction</span>

        <span class="s4"># For cases like np.maximum(np.abs(...), initial=0)</span>
        <span class="s4"># More generally, a supremum over non-negative numbers.</span>
        <span class="s1">assert_equal(np.maximum.reduce([]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s4"># For cases like reduction of an empty array over the reals.</span>
        <span class="s1">assert_equal(np.minimum.reduce([]</span><span class="s0">, </span><span class="s1">initial=np.inf)</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(np.maximum.reduce([]</span><span class="s0">, </span><span class="s1">initial=-np.inf)</span><span class="s0">, </span><span class="s1">-np.inf)</span>

        <span class="s4"># Random tests</span>
        <span class="s1">assert_equal(np.minimum.reduce([</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.maximum.reduce([</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.maximum.reduce([</span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.minimum.reduce([</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>

        <span class="s4"># Check initial=None raises ValueError for both types of ufunc reductions</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.minimum.reduce</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">initial=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s4"># Check that np._NoValue gives default behavior.</span>
        <span class="s1">assert_equal(np.add.reduce([]</span><span class="s0">, </span><span class="s1">initial=np._NoValue)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s4"># Check that initial kwarg behaves as intended for dtype=object</span>
        <span class="s1">a = np.array([</span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">res = np.add.reduce(a</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'axis'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, None</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'where'</span><span class="s0">, </span><span class="s1">(np.array([</span><span class="s0">False, True, True</span><span class="s1">])</span><span class="s0">,</span>
                                       <span class="s1">np.array([[</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True</span><span class="s1">]])</span><span class="s0">,</span>
                                       <span class="s1">np.array([[</span><span class="s0">True, False, False</span><span class="s1">]</span><span class="s0">,</span>
                                                 <span class="s1">[</span><span class="s0">False, True, False</span><span class="s1">]</span><span class="s0">,</span>
                                                 <span class="s1">[</span><span class="s0">False, True, True</span><span class="s1">]])))</span>
    <span class="s0">def </span><span class="s1">test_reduction_with_where(self</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">where):</span>
        <span class="s1">a = np.arange(</span><span class="s3">9.</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">a_copy = a.copy()</span>
        <span class="s1">a_check = np.zeros_like(a)</span>
        <span class="s1">np.positive(a</span><span class="s0">, </span><span class="s1">out=a_check</span><span class="s0">, </span><span class="s1">where=where)</span>

        <span class="s1">res = np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">where=where)</span>
        <span class="s1">check = a_check.sum(axis)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">check)</span>
        <span class="s4"># Check we do not overwrite elements of a internally.</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">a_copy)</span>

    <span class="s1">@pytest.mark.parametrize((</span><span class="s2">'axis'</span><span class="s0">, </span><span class="s2">'where'</span><span class="s1">)</span><span class="s0">,</span>
                             <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True, False, True</span><span class="s1">]))</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, True, False</span><span class="s1">])</span><span class="s0">,</span>
                              <span class="s1">(</span><span class="s0">None, True</span><span class="s1">)))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'initial'</span><span class="s0">, </span><span class="s1">(-np.inf</span><span class="s0">, </span><span class="s3">5.</span><span class="s1">))</span>
    <span class="s0">def </span><span class="s1">test_reduction_with_where_and_initial(self</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">where</span><span class="s0">, </span><span class="s1">initial):</span>
        <span class="s1">a = np.arange(</span><span class="s3">9.</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">a_copy = a.copy()</span>
        <span class="s1">a_check = np.full(a.shape</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">np.positive(a</span><span class="s0">, </span><span class="s1">out=a_check</span><span class="s0">, </span><span class="s1">where=where)</span>

        <span class="s1">res = np.maximum.reduce(a</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">where=where</span><span class="s0">, </span><span class="s1">initial=initial)</span>
        <span class="s1">check = a_check.max(axis</span><span class="s0">, </span><span class="s1">initial=initial)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">check)</span>

    <span class="s0">def </span><span class="s1">test_reduction_where_initial_needed(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">9.</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">m = [</span><span class="s0">False, True, False</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.maximum.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">where=m)</span>

    <span class="s0">def </span><span class="s1">test_identityless_reduction_nonreorderable(self):</span>
        <span class="s1">a = np.array([[</span><span class="s3">8.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.25</span><span class="s1">]])</span>

        <span class="s1">res = np.divide.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">[</span><span class="s3">8.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">8.0</span><span class="s1">])</span>

        <span class="s1">res = np.divide.reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">8.0</span><span class="s1">])</span>

        <span class="s1">res = np.divide.reduce(a</span><span class="s0">, </span><span class="s1">axis=())</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">a)</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.divide.reduce</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_reduce_zero_axis(self):</span>
        <span class="s4"># If we have a n x m array and do a reduction with axis=1, then we are</span>
        <span class="s4"># doing n reductions, and each reduction takes an m-element array. For</span>
        <span class="s4"># a reduction operation without an identity, then:</span>
        <span class="s4">#   n &gt; 0, m &gt; 0: fine</span>
        <span class="s4">#   n = 0, m &gt; 0: fine, doing 0 reductions of m-element arrays</span>
        <span class="s4">#   n &gt; 0, m = 0: can't reduce a 0-element array, ValueError</span>
        <span class="s4">#   n = 0, m = 0: can't reduce a 0-element array, ValueError (for</span>
        <span class="s4">#     consistency with the above case)</span>
        <span class="s4"># This test doesn't actually look at return values, it just checks to</span>
        <span class="s4"># make sure that error we get an error in exactly those cases where we</span>
        <span class="s4"># expect one, and assumes the calculations themselves are done</span>
        <span class="s4"># correctly.</span>

        <span class="s0">def </span><span class="s1">ok(f</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">f(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">def </span><span class="s1">err(f</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">def </span><span class="s1">t(expect</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">m):</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((n</span><span class="s0">, </span><span class="s1">m))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((m</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((n // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">n // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">m))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((n // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n // </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((n</span><span class="s0">, </span><span class="s1">m // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">m // </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((m // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">m // </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((m // </span><span class="s3">3</span><span class="s0">, </span><span class="s1">m // </span><span class="s3">3</span><span class="s0">, </span><span class="s1">m // </span><span class="s3">3</span><span class="s0">,</span>
                                  <span class="s1">n // </span><span class="s3">2</span><span class="s0">, </span><span class="s1">n // </span><span class="s3">2</span><span class="s1">))</span><span class="s0">,</span>
                                 <span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s4"># Check what happens if the inner (resp. outer) dimensions are a</span>
            <span class="s4"># mix of zero and non-zero:</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">10</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">10</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">m))</span><span class="s0">, </span><span class="s1">axis=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((m</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">10</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">expect(func</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s3">10</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">m))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s4"># np.maximum is just an arbitrary ufunc with no reduction identity</span>
        <span class="s1">assert_equal(np.maximum.identity</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.maximum.reduce</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.maximum.reduce</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
        <span class="s1">t(err</span><span class="s0">, </span><span class="s1">np.maximum.reduce</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">t(err</span><span class="s0">, </span><span class="s1">np.maximum.reduce</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">err(np.maximum.reduce</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">np.maximum.reduce(np.zeros((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=())</span>

        <span class="s4"># all of the combinations are fine for a reduction that has an</span>
        <span class="s4"># identity</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">t(ok</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">np.add.reduce([])</span>
        <span class="s1">np.add.reduce(np.zeros((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=())</span>

        <span class="s4"># OTOH, accumulate always makes sense for any combination of n and m,</span>
        <span class="s4"># because it maps an m-element array to an m-element array. These</span>
        <span class="s4"># tests are simpler because accumulate doesn't accept multiple axes.</span>
        <span class="s0">for </span><span class="s1">uf </span><span class="s0">in </span><span class="s1">(np.maximum</span><span class="s0">, </span><span class="s1">np.add):</span>
            <span class="s1">uf.accumulate(np.zeros((</span><span class="s3">30</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">uf.accumulate(np.zeros((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">uf.accumulate(np.zeros((</span><span class="s3">30</span><span class="s0">, </span><span class="s3">30</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">uf.accumulate(np.zeros((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_safe_casting(self):</span>
        <span class="s4"># In old versions of numpy, in-place operations used the 'unsafe'</span>
        <span class="s4"># casting rules. In versions &gt;= 1.10, 'same_kind' is the</span>
        <span class="s4"># default and an exception is raised instead of a warning.</span>
        <span class="s4"># when 'same_kind' is not satisfied.</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s4"># Non-in-place addition is fine</span>
        <span class="s1">assert_array_equal(assert_no_warnings(np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">)</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2.1</span><span class="s0">, </span><span class="s3">3.1</span><span class="s0">, </span><span class="s3">4.1</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">1.1</span><span class="s0">, </span><span class="s1">out=a)</span>

        <span class="s0">def </span><span class="s1">add_inplace(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s1">a += b</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">add_inplace</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">)</span>
        <span class="s4"># Make sure that explicitly overriding the exception is allowed:</span>
        <span class="s1">assert_no_warnings(np.add</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">1.1</span><span class="s0">, </span><span class="s1">out=a</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_ufunc_custom_out(self):</span>
        <span class="s4"># Test ufunc with built in input types and custom output type</span>

        <span class="s1">a = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i8'</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i8'</span><span class="s1">)</span>
        <span class="s1">c = np.empty(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">dtype=_rational_tests.rational)</span>

        <span class="s4"># Output must be specified so numpy knows what</span>
        <span class="s4"># ufunc signature to look for</span>
        <span class="s1">result = _rational_tests.test_add(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c)</span>
        <span class="s1">target = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=_rational_tests.rational)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">target)</span>

        <span class="s4"># The new resolution means that we can (usually) find custom loops</span>
        <span class="s4"># as long as they match exactly:</span>
        <span class="s1">result = _rational_tests.test_add(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">target)</span>

        <span class="s4"># This works even more generally, so long the default common-dtype</span>
        <span class="s4"># promoter works out:</span>
        <span class="s1">result = _rational_tests.test_add(a</span><span class="s0">, </span><span class="s1">b.astype(np.uint16)</span><span class="s0">, </span><span class="s1">out=c)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">target)</span>

        <span class="s4"># But, it can be fooled, e.g. (use scalars, which forces legacy</span>
        <span class="s4"># type resolution to kick in, which then fails):</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">_rational_tests.test_add(a</span><span class="s0">, </span><span class="s1">np.uint16(</span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_operand_flags(self):</span>
        <span class="s1">a = np.arange(</span><span class="s3">16</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'l'</span><span class="s1">).reshape(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s3">9</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'l'</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">opflag_tests.inplace_add(a[:-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">7</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">14</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">18</span><span class="s0">, </span><span class="s3">11</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">12</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">14</span><span class="s0">, </span><span class="s3">15</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'l'</span><span class="s1">))</span>

        <span class="s1">a = np.array(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">opflag_tests.inplace_add(a</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">opflag_tests.inplace_add(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_struct_ufunc(self):</span>
        <span class="s0">import </span><span class="s1">numpy.core._struct_ufunc_tests </span><span class="s0">as </span><span class="s1">struct_ufunc</span>

        <span class="s1">a = np.array([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'u8,u8,u8'</span><span class="s1">)</span>
        <span class="s1">b = np.array([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'u8,u8,u8'</span><span class="s1">)</span>

        <span class="s1">result = struct_ufunc.add_triplet(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">np.array([(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'u8,u8,u8'</span><span class="s1">))</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">struct_ufunc.register_fail)</span>

    <span class="s0">def </span><span class="s1">test_custom_ufunc(self):</span>
        <span class="s1">a = np.array(</span>
            <span class="s1">[_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">dtype=_rational_tests.rational)</span>
        <span class="s1">b = np.array(</span>
            <span class="s1">[_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">dtype=_rational_tests.rational)</span>

        <span class="s1">result = _rational_tests.test_add_rationals(a</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">expected = np.array(</span>
            <span class="s1">[_rational_tests.rational(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
             <span class="s1">_rational_tests.rational(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">,</span>
            <span class="s1">dtype=_rational_tests.rational)</span>
        <span class="s1">assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_custom_ufunc_forced_sig(self):</span>
        <span class="s4"># gh-9351 - looking for a non-first userloop would previously hang</span>
        <span class="s0">with </span><span class="s1">assert_raises(TypeError):</span>
            <span class="s1">np.multiply(_rational_tests.rational(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">,</span>
                        <span class="s1">signature=(_rational_tests.rational</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_custom_array_like(self):</span>

        <span class="s0">class </span><span class="s1">MyThing:</span>
            <span class="s1">__array_priority__ = </span><span class="s3">1000</span>

            <span class="s1">rmul_count = </span><span class="s3">0</span>
            <span class="s1">getitem_count = </span><span class="s3">0</span>

            <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">shape):</span>
                <span class="s1">self.shape = shape</span>

            <span class="s0">def </span><span class="s1">__len__(self):</span>
                <span class="s0">return </span><span class="s1">self.shape[</span><span class="s3">0</span><span class="s1">]</span>

            <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">i):</span>
                <span class="s1">MyThing.getitem_count += </span><span class="s3">1</span>
                <span class="s0">if not </span><span class="s1">isinstance(i</span><span class="s0">, </span><span class="s1">tuple):</span>
                    <span class="s1">i = (i</span><span class="s0">,</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(i) &gt; self.ndim:</span>
                    <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s2">&quot;boo&quot;</span><span class="s1">)</span>

                <span class="s0">return </span><span class="s1">MyThing(self.shape[len(i):])</span>

            <span class="s0">def </span><span class="s1">__rmul__(self</span><span class="s0">, </span><span class="s1">other):</span>
                <span class="s1">MyThing.rmul_count += </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">self</span>

        <span class="s1">np.float64(</span><span class="s3">5</span><span class="s1">)*MyThing((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_(MyThing.rmul_count == </span><span class="s3">1</span><span class="s0">, </span><span class="s1">MyThing.rmul_count)</span>
        <span class="s1">assert_(MyThing.getitem_count &lt;= </span><span class="s3">2</span><span class="s0">, </span><span class="s1">MyThing.getitem_count)</span>

    <span class="s0">def </span><span class="s1">test_inplace_fancy_indexing(self):</span>

        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">202</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">105</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

        <span class="s1">a = np.arange(</span><span class="s3">9</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([[</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">200</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">200</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">300</span><span class="s0">, </span><span class="s3">300</span><span class="s0">, </span><span class="s3">300</span><span class="s1">]])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">201</span><span class="s0">, </span><span class="s3">102</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">404</span><span class="s0">, </span><span class="s3">205</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">607</span><span class="s0">, </span><span class="s3">308</span><span class="s1">]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">27</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">,</span>
            <span class="s1">[[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">401</span><span class="s0">, </span><span class="s3">202</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">404</span><span class="s0">, </span><span class="s3">205</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">407</span><span class="s0">, </span><span class="s3">208</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">9</span><span class="s0">, </span><span class="s3">410</span><span class="s0">, </span><span class="s3">211</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">12</span><span class="s0">, </span><span class="s3">413</span><span class="s0">, </span><span class="s3">214</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">15</span><span class="s0">, </span><span class="s3">416</span><span class="s0">, </span><span class="s3">217</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">18</span><span class="s0">, </span><span class="s3">419</span><span class="s0">, </span><span class="s3">220</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">21</span><span class="s0">, </span><span class="s3">422</span><span class="s0">, </span><span class="s3">223</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">24</span><span class="s0">, </span><span class="s3">425</span><span class="s0">, </span><span class="s3">226</span><span class="s1">]]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">9</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([[</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">200</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">200</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">300</span><span class="s0">, </span><span class="s3">300</span><span class="s0">, </span><span class="s3">300</span><span class="s1">]])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">403</span><span class="s0">, </span><span class="s3">404</span><span class="s0">, </span><span class="s3">405</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">206</span><span class="s0">, </span><span class="s3">207</span><span class="s0">, </span><span class="s3">208</span><span class="s1">]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">27</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">,</span>
            <span class="s1">[[[</span><span class="s3">0</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">203</span><span class="s0">, </span><span class="s3">404</span><span class="s0">, </span><span class="s3">605</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">106</span><span class="s0">, </span><span class="s3">207</span><span class="s0">, </span><span class="s3">308</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">9</span><span class="s0">,  </span><span class="s3">10</span><span class="s0">, </span><span class="s3">11</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">212</span><span class="s0">, </span><span class="s3">413</span><span class="s0">, </span><span class="s3">614</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">115</span><span class="s0">, </span><span class="s3">216</span><span class="s0">, </span><span class="s3">317</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">18</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">221</span><span class="s0">, </span><span class="s3">422</span><span class="s0">, </span><span class="s3">623</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">124</span><span class="s0">, </span><span class="s3">225</span><span class="s0">, </span><span class="s3">326</span><span class="s1">]]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">9</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">401</span><span class="s0">, </span><span class="s3">202</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s1">]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">27</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">,</span>
            <span class="s1">[[[</span><span class="s3">0</span><span class="s0">,  </span><span class="s3">1</span><span class="s0">,  </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">3</span><span class="s0">,  </span><span class="s3">4</span><span class="s0">,  </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">6</span><span class="s0">,  </span><span class="s3">7</span><span class="s0">,  </span><span class="s3">8</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">209</span><span class="s0">, </span><span class="s3">410</span><span class="s0">, </span><span class="s3">611</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">12</span><span class="s0">,  </span><span class="s3">13</span><span class="s0">, </span><span class="s3">14</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">15</span><span class="s0">,  </span><span class="s3">16</span><span class="s0">, </span><span class="s3">17</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">118</span><span class="s0">, </span><span class="s3">219</span><span class="s0">, </span><span class="s3">320</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">21</span><span class="s0">,  </span><span class="s3">22</span><span class="s0">, </span><span class="s3">23</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">24</span><span class="s0">,  </span><span class="s3">25</span><span class="s0">, </span><span class="s3">26</span><span class="s1">]]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">27</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = np.array([</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s0">, </span><span class="s3">300</span><span class="s1">])</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(a</span><span class="s0">,</span>
            <span class="s1">[[[</span><span class="s3">100</span><span class="s0">, </span><span class="s3">201</span><span class="s0">, </span><span class="s3">302</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">103</span><span class="s0">, </span><span class="s3">204</span><span class="s0">, </span><span class="s3">305</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">106</span><span class="s0">, </span><span class="s3">207</span><span class="s0">, </span><span class="s3">308</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">109</span><span class="s0">, </span><span class="s3">210</span><span class="s0">, </span><span class="s3">311</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">112</span><span class="s0">, </span><span class="s3">213</span><span class="s0">, </span><span class="s3">314</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">115</span><span class="s0">, </span><span class="s3">216</span><span class="s0">, </span><span class="s3">317</span><span class="s1">]]</span><span class="s0">,</span>

             <span class="s1">[[</span><span class="s3">118</span><span class="s0">, </span><span class="s3">219</span><span class="s0">, </span><span class="s3">320</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">121</span><span class="s0">, </span><span class="s3">222</span><span class="s0">, </span><span class="s3">323</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">[</span><span class="s3">124</span><span class="s0">, </span><span class="s3">225</span><span class="s0">, </span><span class="s3">326</span><span class="s1">]]])</span>

        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">np.negative.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

        <span class="s4"># Test 0-dim array</span>
        <span class="s1">a = np.array(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">np.add.at</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">np.add.at</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s4"># Test mixed dtypes</span>
        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">np.power.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">4414</span><span class="s0">, </span><span class="s3">46</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]))</span>

        <span class="s4"># Test boolean indexing and boolean ufuncs</span>
        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">index = a % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span>
        <span class="s1">np.equal.at(a</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

        <span class="s4"># Test unary operator</span>
        <span class="s1">a = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'u4'</span><span class="s1">)</span>
        <span class="s1">np.invert.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5 </span><span class="s1">^ </span><span class="s3">0xffffffff</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>

        <span class="s4"># Test empty subspace</span>
        <span class="s1">orig = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">a = orig[:</span><span class="s0">, None</span><span class="s1">][:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">:</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">np.add.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(orig</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">4</span><span class="s1">))</span>

        <span class="s4"># Test with swapped byte order</span>
        <span class="s1">index = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'i'</span><span class="s1">).newbyteorder())</span>
        <span class="s1">values = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">'f'</span><span class="s1">).newbyteorder())</span>
        <span class="s1">np.add.at(values</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(values</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>

        <span class="s4"># Test exception thrown</span>
        <span class="s1">values = np.array([</span><span class="s2">'a'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.add.at</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(values</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">'a'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object))</span>

        <span class="s4"># Test multiple output ufuncs raise error, gh-5665</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">np.modf.at</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s4"># Test maximum</span>
        <span class="s1">a = np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">np.maximum.at(a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s0">def </span><span class="s1">test_at_not_none_signature(self):</span>
        <span class="s4"># Test ufuncs with non-trivial signature raise a TypeError</span>
        <span class="s1">a = np.ones((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">b = np.ones((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.matmul.at</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">a = np.array([[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.linalg._umath_linalg.det.at</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_reduce_arguments(self):</span>
        <span class="s1">f = np.add.reduce</span>
        <span class="s1">d = np.ones((</span><span class="s3">5</span><span class="s0">,</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
        <span class="s1">o = np.ones((</span><span class="s3">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=d.dtype)</span>
        <span class="s1">r = o * </span><span class="s3">5</span>
        <span class="s1">assert_equal(f(d)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s4"># a, axis=0, dtype=None, out=None, keepdims=False</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">'i'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s2">'i'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">out=o)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">o)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r.reshape((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) + r.shape))</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s1">initial=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s3">0</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">where=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s4"># multiple keywords</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>
        <span class="s1">assert_equal(f(d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s1">out=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">False, </span><span class="s1">initial=</span><span class="s3">0</span><span class="s0">,</span>
                       <span class="s1">where=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">r)</span>

        <span class="s4"># too little</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f)</span>
        <span class="s4"># too much</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, None, False, </span><span class="s3">0</span><span class="s0">, True, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s4"># invalid axis</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None,</span>
                      <span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s4"># invalid dtype</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">, </span><span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s4"># invalid out</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, None, </span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">&quot;invalid&quot;</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">out=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s4"># keepdims boolean, no invalid value</span>
        <span class="s4"># assert_raises(TypeError, f, d, 0, None, None, &quot;invalid&quot;)</span>
        <span class="s4"># assert_raises(TypeError, f, d, keepdims=&quot;invalid&quot;, axis=0, dtype=None)</span>
        <span class="s4"># invalid mix</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,</span>
                     <span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s4"># invalid keyword</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">invalid=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">invalid=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True, </span><span class="s1">invalid=</span><span class="s2">&quot;invalid&quot;</span><span class="s0">,</span>
                      <span class="s1">out=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">True,</span>
                      <span class="s1">out=</span><span class="s0">None, </span><span class="s1">invalid=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None,</span>
                      <span class="s1">out=</span><span class="s0">None, </span><span class="s1">invalid=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_structured_equal(self):</span>
        <span class="s4"># https://github.com/numpy/numpy/issues/4855</span>

        <span class="s0">class </span><span class="s1">MyA(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s0">return </span><span class="s1">getattr(ufunc</span><span class="s0">, </span><span class="s1">method)(*(input.view(np.ndarray)</span>
                                              <span class="s0">for </span><span class="s1">input </span><span class="s0">in </span><span class="s1">inputs)</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">a = np.arange(</span><span class="s3">12.</span><span class="s1">).reshape(</span><span class="s3">4</span><span class="s0">,</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">ra = a.view(dtype=(</span><span class="s2">'f8,f8,f8'</span><span class="s1">)).squeeze()</span>
        <span class="s1">mra = ra.view(MyA)</span>

        <span class="s1">target = np.array([ </span><span class="s0">True, False, False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_equal(np.all(target == (mra == ra[</span><span class="s3">0</span><span class="s1">]))</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_equal(self):</span>
        <span class="s4"># Scalar comparisons should always work, without deprecation warnings.</span>
        <span class="s4"># even when the ufunc fails.</span>
        <span class="s1">a = np.array(</span><span class="s3">0.</span><span class="s1">)</span>
        <span class="s1">b = np.array(</span><span class="s2">'a'</span><span class="s1">)</span>
        <span class="s1">assert_(a != b)</span>
        <span class="s1">assert_(b != a)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(a == b))</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">(b == a))</span>

    <span class="s0">def </span><span class="s1">test_NotImplemented_not_returned(self):</span>
        <span class="s4"># See gh-5964 and gh-2091. Some of these functions are not operator</span>
        <span class="s4"># related and were fixed for other reasons in the past.</span>
        <span class="s1">binary_funcs = [</span>
            <span class="s1">np.power</span><span class="s0">, </span><span class="s1">np.add</span><span class="s0">, </span><span class="s1">np.subtract</span><span class="s0">, </span><span class="s1">np.multiply</span><span class="s0">, </span><span class="s1">np.divide</span><span class="s0">,</span>
            <span class="s1">np.true_divide</span><span class="s0">, </span><span class="s1">np.floor_divide</span><span class="s0">, </span><span class="s1">np.bitwise_and</span><span class="s0">, </span><span class="s1">np.bitwise_or</span><span class="s0">,</span>
            <span class="s1">np.bitwise_xor</span><span class="s0">, </span><span class="s1">np.left_shift</span><span class="s0">, </span><span class="s1">np.right_shift</span><span class="s0">, </span><span class="s1">np.fmax</span><span class="s0">,</span>
            <span class="s1">np.fmin</span><span class="s0">, </span><span class="s1">np.fmod</span><span class="s0">, </span><span class="s1">np.hypot</span><span class="s0">, </span><span class="s1">np.logaddexp</span><span class="s0">, </span><span class="s1">np.logaddexp2</span><span class="s0">,</span>
            <span class="s1">np.maximum</span><span class="s0">, </span><span class="s1">np.minimum</span><span class="s0">, </span><span class="s1">np.mod</span><span class="s0">,</span>
            <span class="s1">np.greater</span><span class="s0">, </span><span class="s1">np.greater_equal</span><span class="s0">, </span><span class="s1">np.less</span><span class="s0">, </span><span class="s1">np.less_equal</span><span class="s0">,</span>
            <span class="s1">np.equal</span><span class="s0">, </span><span class="s1">np.not_equal]</span>

        <span class="s1">a = np.array(</span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">b = </span><span class="s3">1</span>
        <span class="s1">c = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">binary_funcs:</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">a)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">,</span>
             <span class="s1">[np.logical_and</span><span class="s0">, </span><span class="s1">np.logical_or])  </span><span class="s4"># logical_xor object loop is bad</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;signature&quot;</span><span class="s0">,</span>
             <span class="s1">[(</span><span class="s0">None, None, </span><span class="s1">object)</span><span class="s0">, </span><span class="s1">(object</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">,</span>
              <span class="s1">(</span><span class="s0">None, </span><span class="s1">object</span><span class="s0">, None</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_logical_ufuncs_object_signatures(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">signature):</span>
        <span class="s1">a = np.array([</span><span class="s0">True, None, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">res = ufunc(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">signature=signature)</span>
        <span class="s0">assert </span><span class="s1">res.dtype == object</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">,</span>
            <span class="s1">[np.logical_and</span><span class="s0">, </span><span class="s1">np.logical_or</span><span class="s0">, </span><span class="s1">np.logical_xor])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;signature&quot;</span><span class="s0">,</span>
                 <span class="s1">[(bool</span><span class="s0">, None, </span><span class="s1">object)</span><span class="s0">, </span><span class="s1">(object</span><span class="s0">, None, </span><span class="s1">bool)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s0">None, </span><span class="s1">object</span><span class="s0">, </span><span class="s1">bool)])</span>
    <span class="s0">def </span><span class="s1">test_logical_ufuncs_mixed_object_signatures(self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">signature):</span>
        <span class="s4"># Most mixed signatures fail (except those with bool out, e.g. `OO-&gt;?`)</span>
        <span class="s1">a = np.array([</span><span class="s0">True, None, False</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">ufunc(a</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">signature=signature)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">,</span>
            <span class="s1">[np.logical_and</span><span class="s0">, </span><span class="s1">np.logical_or</span><span class="s0">, </span><span class="s1">np.logical_xor])</span>
    <span class="s0">def </span><span class="s1">test_logical_ufuncs_support_anything(self</span><span class="s0">, </span><span class="s1">ufunc):</span>
        <span class="s4"># The logical ufuncs support even input that can't be promoted:</span>
        <span class="s1">a = np.array(</span><span class="s6">b'1'</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;V3&quot;</span><span class="s1">)</span>
        <span class="s1">c = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(ufunc(a</span><span class="s0">, </span><span class="s1">c)</span><span class="s0">, </span><span class="s1">ufunc([</span><span class="s0">True, True</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">ufunc.reduce(a) == </span><span class="s0">True</span>
        <span class="s4"># check that the output has no effect:</span>
        <span class="s1">out = np.zeros(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">expected = ufunc([</span><span class="s0">True, True</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">).astype(out.dtype)</span>
        <span class="s1">assert_array_equal(ufunc(a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">out=out)</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">out = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s0">assert </span><span class="s1">ufunc.reduce(a</span><span class="s0">, </span><span class="s1">out=out) == </span><span class="s0">True</span>
        <span class="s4"># Last check, test reduction when out and a match (the complexity here</span>
        <span class="s4"># is that the &quot;i,i-&gt;?&quot; may seem right, but should not match.</span>
        <span class="s1">a = np.array([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span>
        <span class="s1">out = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>
        <span class="s0">assert </span><span class="s1">ufunc.reduce(a</span><span class="s0">, </span><span class="s1">out=out) == </span><span class="s3">1</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">,</span>
            <span class="s1">[np.logical_and</span><span class="s0">, </span><span class="s1">np.logical_or</span><span class="s0">, </span><span class="s1">np.logical_xor])</span>
    <span class="s0">def </span><span class="s1">test_logical_ufuncs_reject_string(self</span><span class="s0">, </span><span class="s1">ufunc):</span>
        <span class="s5">&quot;&quot;&quot; 
        Logical ufuncs are normally well defined by working with the boolean 
        equivalent, i.e. casting all inputs to bools should work. 
 
        However, casting strings to bools is *currently* weird, because it 
        actually uses `bool(int(str))`.  Thus we explicitly reject strings. 
        This test should succeed (and can probably just be removed) as soon as 
        string to bool casts are well defined in NumPy. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;contain a loop with signature&quot;</span><span class="s1">):</span>
            <span class="s1">ufunc([</span><span class="s2">&quot;1&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;3&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;contain a loop with signature&quot;</span><span class="s1">):</span>
            <span class="s1">ufunc.reduce([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;0&quot;</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ufunc&quot;</span><span class="s0">,</span>
             <span class="s1">[np.logical_and</span><span class="s0">, </span><span class="s1">np.logical_or</span><span class="s0">, </span><span class="s1">np.logical_xor])</span>
    <span class="s0">def </span><span class="s1">test_logical_ufuncs_out_cast_check(self</span><span class="s0">, </span><span class="s1">ufunc):</span>
        <span class="s1">a = np.array(</span><span class="s2">'1'</span><span class="s1">)</span>
        <span class="s1">c = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">])</span>
        <span class="s1">out = a.copy()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s4"># It would be safe, but not equiv casting:</span>
            <span class="s1">ufunc(a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;equiv&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reducelike_byteorder_resolution(self):</span>
        <span class="s4"># See gh-20699, byte-order changes need some extra care in the type</span>
        <span class="s4"># resolution to make the following succeed:</span>
        <span class="s1">arr_be = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;&gt;i8&quot;</span><span class="s1">)</span>
        <span class="s1">arr_le = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;&lt;i8&quot;</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">np.add.reduce(arr_be) == np.add.reduce(arr_le)</span>
        <span class="s1">assert_array_equal(np.add.accumulate(arr_be)</span><span class="s0">, </span><span class="s1">np.add.accumulate(arr_le))</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">np.add.reduceat(arr_be</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.add.reduceat(arr_le</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_reducelike_out_promotes(self):</span>
        <span class="s4"># Check that the out argument to reductions is considered for</span>
        <span class="s4"># promotion.  See also gh-20455.</span>
        <span class="s4"># Note that these paths could prefer `initial=` in the future and</span>
        <span class="s4"># do not up-cast to the default integer for add and prod</span>
        <span class="s1">arr = np.ones(</span><span class="s3">1000</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
        <span class="s1">out = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=np.uint16)</span>
        <span class="s0">assert </span><span class="s1">np.add.reduce(arr</span><span class="s0">, </span><span class="s1">out=out) == </span><span class="s3">1000</span>
        <span class="s1">arr[:</span><span class="s3">10</span><span class="s1">] = </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">np.multiply.reduce(arr</span><span class="s0">, </span><span class="s1">out=out) == </span><span class="s3">2</span><span class="s1">**</span><span class="s3">10</span>

        <span class="s4"># For legacy dtypes, the signature currently has to be forced if `out=`</span>
        <span class="s4"># is passed.  The two paths below should differ, without `dtype=` the</span>
        <span class="s4"># expected result should be: `np.prod(arr.astype(&quot;f8&quot;)).astype(&quot;f4&quot;)`!</span>
        <span class="s1">arr = np.full(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**</span><span class="s3">25</span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span>

        <span class="s4"># float32 and int64 promote to float64:</span>
        <span class="s1">res = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s4"># If `dtype=` is passed, the calculation is forced to float32:</span>
        <span class="s1">single_res = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s1">np.multiply.reduce(arr</span><span class="s0">, </span><span class="s1">out=single_res</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
        <span class="s0">assert </span><span class="s1">single_res != res</span>

    <span class="s0">def </span><span class="s1">test_reducelike_output_needs_identical_cast(self):</span>
        <span class="s4"># Checks the case where the we have a simple byte-swap works, maily</span>
        <span class="s4"># tests that this is not rejected directly.</span>
        <span class="s4"># (interesting because we require descriptor identity in reducelikes).</span>
        <span class="s1">arr = np.ones(</span><span class="s3">20</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s1">out = np.empty(()</span><span class="s0">, </span><span class="s1">dtype=arr.dtype.newbyteorder())</span>
        <span class="s1">expected = np.add.reduce(arr)</span>
        <span class="s1">np.add.reduce(arr</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s4"># Check reduceat:</span>
        <span class="s1">out = np.empty(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=arr.dtype.newbyteorder())</span>
        <span class="s1">expected = np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">out)</span>
        <span class="s4"># And accumulate:</span>
        <span class="s1">out = np.empty(arr.shape</span><span class="s0">, </span><span class="s1">dtype=arr.dtype.newbyteorder())</span>
        <span class="s1">expected = np.add.accumulate(arr)</span>
        <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=out)</span>
        <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_reduce_noncontig_output(self):</span>
        <span class="s4"># Check that reduction deals with non-contiguous output arrays</span>
        <span class="s4"># appropriately.</span>
        <span class="s4">#</span>
        <span class="s4"># gh-8036</span>

        <span class="s1">x = np.arange(</span><span class="s3">7</span><span class="s1">*</span><span class="s3">13</span><span class="s1">*</span><span class="s3">8</span><span class="s0">, </span><span class="s1">dtype=np.int16).reshape(</span><span class="s3">7</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">x = x[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">6</span><span class="s0">,</span><span class="s3">1</span><span class="s1">:</span><span class="s3">11</span><span class="s1">:</span><span class="s3">6</span><span class="s0">,</span><span class="s3">1</span><span class="s1">:</span><span class="s3">5</span><span class="s1">].transpose(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">y_base = np.arange(</span><span class="s3">4</span><span class="s1">*</span><span class="s3">4</span><span class="s0">, </span><span class="s1">dtype=np.int16).reshape(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">y = y_base[::</span><span class="s3">2</span><span class="s0">,</span><span class="s1">:]</span>

        <span class="s1">y_base_copy = y_base.copy()</span>

        <span class="s1">r0 = np.add.reduce(x</span><span class="s0">, </span><span class="s1">out=y.copy()</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">r1 = np.add.reduce(x</span><span class="s0">, </span><span class="s1">out=y</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s4"># The results should match, and y_base shouldn't get clobbered</span>
        <span class="s1">assert_equal(r0</span><span class="s0">, </span><span class="s1">r1)</span>
        <span class="s1">assert_equal(y_base[</span><span class="s3">1</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">y_base_copy[</span><span class="s3">1</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_equal(y_base[</span><span class="s3">3</span><span class="s0">,</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">y_base_copy[</span><span class="s3">3</span><span class="s0">,</span><span class="s1">:])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;with_cast&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_reduceat_and_accumulate_out_shape_mismatch(self</span><span class="s0">, </span><span class="s1">with_cast):</span>
        <span class="s4"># Should raise an error mentioning &quot;shape&quot; or &quot;size&quot;</span>
        <span class="s1">arr = np.arange(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">out = np.arange(</span><span class="s3">3</span><span class="s1">)  </span><span class="s4"># definitely wrong shape</span>
        <span class="s0">if </span><span class="s1">with_cast:</span>
            <span class="s4"># If a cast is necessary on the output, we can be sure to use</span>
            <span class="s4"># the generic NpyIter (non-fast) path.</span>
            <span class="s1">out = out.astype(np.float64)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;(shape|size)&quot;</span><span class="s1">):</span>
            <span class="s1">np.add.reduceat(arr</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">out=out)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;(shape|size)&quot;</span><span class="s1">):</span>
            <span class="s1">np.add.accumulate(arr</span><span class="s0">, </span><span class="s1">out=out)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'out_shape'</span><span class="s0">,</span>
                             <span class="s1">[()</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'keepdims'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'f_reduce'</span><span class="s0">, </span><span class="s1">[np.add.reduce</span><span class="s0">, </span><span class="s1">np.minimum.reduce])</span>
    <span class="s0">def </span><span class="s1">test_reduce_wrong_dimension_output(self</span><span class="s0">, </span><span class="s1">f_reduce</span><span class="s0">, </span><span class="s1">keepdims</span><span class="s0">, </span><span class="s1">out_shape):</span>
        <span class="s4"># Test that we're not incorrectly broadcasting dimensions.</span>
        <span class="s4"># See gh-15144 (failed for np.add.reduce previously).</span>
        <span class="s1">a = np.arange(</span><span class="s3">12.</span><span class="s1">).reshape(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">out = np.empty(out_shape</span><span class="s0">, </span><span class="s1">a.dtype)</span>

        <span class="s1">correct_out = f_reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">keepdims=keepdims)</span>
        <span class="s0">if </span><span class="s1">out_shape != correct_out.shape:</span>
            <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
                <span class="s1">f_reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">keepdims=keepdims)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">check = f_reduce(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">keepdims=keepdims)</span>
            <span class="s1">assert_(check </span><span class="s0">is </span><span class="s1">out)</span>
            <span class="s1">assert_array_equal(check</span><span class="s0">, </span><span class="s1">correct_out)</span>

    <span class="s0">def </span><span class="s1">test_reduce_output_does_not_broadcast_input(self):</span>
        <span class="s4"># Test that the output shape cannot broadcast an input dimension</span>
        <span class="s4"># (it never can add dimensions, but it might expand an existing one)</span>
        <span class="s1">a = np.ones((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">out_correct = (np.empty((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>
        <span class="s1">out_incorrect = np.empty((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=out_correct</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=out_correct[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=out_incorrect</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">np.add.reduce(a</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">out=out_incorrect[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_reduce_output_subclass_ok(self):</span>
        <span class="s0">class </span><span class="s1">MyArr(np.ndarray):</span>
            <span class="s0">pass</span>

        <span class="s1">out = np.empty(())</span>
        <span class="s1">np.add.reduce(np.ones(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=out)  </span><span class="s4"># no subclass, all fine</span>
        <span class="s1">out = out.view(MyArr)</span>
        <span class="s0">assert </span><span class="s1">np.add.reduce(np.ones(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">out=out) </span><span class="s0">is </span><span class="s1">out</span>
        <span class="s0">assert </span><span class="s1">type(np.add.reduce(out)) </span><span class="s0">is </span><span class="s1">MyArr</span>

    <span class="s0">def </span><span class="s1">test_no_doc_string(self):</span>
        <span class="s4"># gh-9337</span>
        <span class="s1">assert_(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">' </span><span class="s0">not in </span><span class="s1">umt.inner1d_no_doc.__doc__)</span>

    <span class="s0">def </span><span class="s1">test_invalid_args(self):</span>
        <span class="s4"># gh-7961</span>
        <span class="s1">exc = pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">np.sqrt</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s4"># minimally check the exception text</span>
        <span class="s0">assert </span><span class="s1">exc.match(</span><span class="s2">'loop of ufunc does not support'</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'nat'</span><span class="s0">, </span><span class="s1">[np.datetime64(</span><span class="s2">'nat'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s2">'nat'</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_nat_is_not_finite(self</span><span class="s0">, </span><span class="s1">nat):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">np.isfinite(nat)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">pass  </span><span class="s4"># ok, just not implemented</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'nat'</span><span class="s0">, </span><span class="s1">[np.datetime64(</span><span class="s2">'nat'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s2">'nat'</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_nat_is_nan(self</span><span class="s0">, </span><span class="s1">nat):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">np.isnan(nat)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">pass  </span><span class="s4"># ok, just not implemented</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'nat'</span><span class="s0">, </span><span class="s1">[np.datetime64(</span><span class="s2">'nat'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.timedelta64(</span><span class="s2">'nat'</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_nat_is_not_inf(self</span><span class="s0">, </span><span class="s1">nat):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">np.isinf(nat)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">pass  </span><span class="s4"># ok, just not implemented</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'ufunc'</span><span class="s0">, </span><span class="s1">[getattr(np</span><span class="s0">, </span><span class="s1">x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dir(np)</span>
                                <span class="s0">if </span><span class="s1">isinstance(getattr(np</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">np.ufunc)])</span>
<span class="s0">def </span><span class="s1">test_ufunc_types(ufunc):</span>
    <span class="s5">''' 
    Check all ufuncs that the correct type is returned. Avoid 
    object and boolean types since many operations are not defined for 
    for them. 
 
    Choose the shape so even dot and matmul will succeed 
    '''</span>
    <span class="s0">for </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">ufunc.types:</span>
        <span class="s4"># types is a list of strings like ii-&gt;i</span>
        <span class="s0">if </span><span class="s2">'O' </span><span class="s0">in </span><span class="s1">typ </span><span class="s0">or </span><span class="s2">'?' </span><span class="s0">in </span><span class="s1">typ:</span>
            <span class="s0">continue</span>
        <span class="s1">inp</span><span class="s0">, </span><span class="s1">out = typ.split(</span><span class="s2">'-&gt;'</span><span class="s1">)</span>
        <span class="s1">args = [np.ones((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">inp]</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">res = ufunc(*args)</span>
        <span class="s0">if </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">outs = tuple(out)</span>
            <span class="s0">assert </span><span class="s1">len(res) == len(outs)</span>
            <span class="s0">for </span><span class="s1">r</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">zip(res</span><span class="s0">, </span><span class="s1">outs):</span>
                <span class="s0">assert </span><span class="s1">r.dtype == np.dtype(t)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">res.dtype == np.dtype(out)</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'ufunc'</span><span class="s0">, </span><span class="s1">[getattr(np</span><span class="s0">, </span><span class="s1">x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">dir(np)</span>
                                <span class="s0">if </span><span class="s1">isinstance(getattr(np</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">np.ufunc)])</span>
<span class="s1">@np._no_nep50_warning()</span>
<span class="s0">def </span><span class="s1">test_ufunc_noncontiguous(ufunc):</span>
    <span class="s5">''' 
    Check that contiguous and non-contiguous calls to ufuncs 
    have the same results for values in range(9) 
    '''</span>
    <span class="s0">for </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">ufunc.types:</span>
        <span class="s4"># types is a list of strings like ii-&gt;i</span>
        <span class="s0">if </span><span class="s1">any(set(</span><span class="s2">'O?mM'</span><span class="s1">) &amp; set(typ)):</span>
            <span class="s4"># bool, object, datetime are too irregular for this simple test</span>
            <span class="s0">continue</span>
        <span class="s1">inp</span><span class="s0">, </span><span class="s1">out = typ.split(</span><span class="s2">'-&gt;'</span><span class="s1">)</span>
        <span class="s1">args_c = [np.empty(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">inp]</span>
        <span class="s1">args_n = [np.empty(</span><span class="s3">18</span><span class="s0">, </span><span class="s1">t)[::</span><span class="s3">3</span><span class="s1">] </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">inp]</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args_c:</span>
            <span class="s1">a.flat = range(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args_n:</span>
            <span class="s1">a.flat = range(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s2">&quot;always&quot;</span><span class="s1">)</span>
            <span class="s1">res_c = ufunc(*args_c)</span>
            <span class="s1">res_n = ufunc(*args_n)</span>
        <span class="s0">if </span><span class="s1">len(out) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">res_c = (res_c</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">res_n = (res_n</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">c_ar</span><span class="s0">, </span><span class="s1">n_ar </span><span class="s0">in </span><span class="s1">zip(res_c</span><span class="s0">, </span><span class="s1">res_n):</span>
            <span class="s1">dt = c_ar.dtype</span>
            <span class="s0">if </span><span class="s1">np.issubdtype(dt</span><span class="s0">, </span><span class="s1">np.floating):</span>
                <span class="s4"># for floating point results allow a small fuss in comparisons</span>
                <span class="s4"># since different algorithms (libm vs. intrinsics) can be used</span>
                <span class="s4"># for different input strides</span>
                <span class="s1">res_eps = np.finfo(dt).eps</span>
                <span class="s1">tol = </span><span class="s3">2</span><span class="s1">*res_eps</span>
                <span class="s1">assert_allclose(res_c</span><span class="s0">, </span><span class="s1">res_n</span><span class="s0">, </span><span class="s1">atol=tol</span><span class="s0">, </span><span class="s1">rtol=tol)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_equal(c_ar</span><span class="s0">, </span><span class="s1">n_ar)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'ufunc'</span><span class="s0">, </span><span class="s1">[np.sign</span><span class="s0">, </span><span class="s1">np.equal])</span>
<span class="s0">def </span><span class="s1">test_ufunc_warn_with_nan(ufunc):</span>
    <span class="s4"># issue gh-15127</span>
    <span class="s4"># test that calling certain ufuncs with a non-standard `nan` value does not</span>
    <span class="s4"># emit a warning</span>
    <span class="s4"># `b` holds a 64 bit signaling nan: the most significant bit of the</span>
    <span class="s4"># significand is zero.</span>
    <span class="s1">b = np.array([</span><span class="s3">0x7ff0000000000001</span><span class="s1">]</span><span class="s0">, </span><span class="s2">'i8'</span><span class="s1">).view(</span><span class="s2">'f8'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.isnan(b)</span>
    <span class="s0">if </span><span class="s1">ufunc.nin == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">ufunc(b)</span>
    <span class="s0">elif </span><span class="s1">ufunc.nin == </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s1">ufunc(b</span><span class="s0">, </span><span class="s1">b.copy())</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'ufunc with more than 2 inputs'</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">HAS_REFCOUNT</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;Python lacks refcounts&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_ufunc_out_casterrors():</span>
    <span class="s4"># Tests that casting errors are correctly reported and buffers are</span>
    <span class="s4"># cleared.</span>
    <span class="s4"># The following array can be added to itself as an object array, but</span>
    <span class="s4"># the result cannot be cast to an integer output:</span>
    <span class="s1">value = </span><span class="s3">123  </span><span class="s4"># relies on python cache (leak-check will still find it)</span>
    <span class="s1">arr = np.array([value] * int(np.BUFSIZE * </span><span class="s3">1.5</span><span class="s1">) +</span>
                   <span class="s1">[</span><span class="s2">&quot;string&quot;</span><span class="s1">] +</span>
                   <span class="s1">[value] * int(</span><span class="s3">1.5 </span><span class="s1">* np.BUFSIZE)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">out = np.ones(len(arr)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

    <span class="s1">count = sys.getrefcount(value)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s4"># Output casting failure:</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">count == sys.getrefcount(value)</span>
    <span class="s4"># output is unchanged after the error, this shows that the iteration</span>
    <span class="s4"># was aborted (this is not necessarily defined behaviour)</span>
    <span class="s0">assert </span><span class="s1">out[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s4"># Input casting failure:</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">out=out</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">count == sys.getrefcount(value)</span>
    <span class="s4"># output is unchanged after the error, this shows that the iteration</span>
    <span class="s4"># was aborted (this is not necessarily defined behaviour)</span>
    <span class="s0">assert </span><span class="s1">out[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;bad_offset&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">int(np.BUFSIZE * </span><span class="s3">1.5</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_ufunc_input_casterrors(bad_offset):</span>
    <span class="s1">value = </span><span class="s3">123</span>
    <span class="s1">arr = np.array([value] * bad_offset +</span>
                   <span class="s1">[</span><span class="s2">&quot;string&quot;</span><span class="s1">] +</span>
                   <span class="s1">[value] * int(</span><span class="s3">1.5 </span><span class="s1">* np.BUFSIZE)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s4"># Force cast inputs, but the buffered cast of `arr` to intp fails:</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(IS_WASM</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;fp errors don't work in wasm&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;bad_offset&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">int(np.BUFSIZE * </span><span class="s3">1.5</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_ufunc_input_floatingpoint_error(bad_offset):</span>
    <span class="s1">value = </span><span class="s3">123</span>
    <span class="s1">arr = np.array([value] * bad_offset +</span>
                   <span class="s1">[np.nan] +</span>
                   <span class="s1">[value] * int(</span><span class="s3">1.5 </span><span class="s1">* np.BUFSIZE))</span>
    <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">&quot;raise&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pytest.raises(FloatingPointError):</span>
        <span class="s4"># Force cast inputs, but the buffered cast of `arr` to intp fails:</span>
        <span class="s1">np.add(arr</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;unsafe&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_trivial_loop_invalid_cast():</span>
    <span class="s4"># This tests the fast-path &quot;invalid cast&quot;, see gh-19904.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s2">&quot;cast ufunc 'add' input 0&quot;</span><span class="s1">):</span>
        <span class="s4"># the void dtype definitely cannot cast to double:</span>
        <span class="s1">np.add(np.array(</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;i,i&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">signature=</span><span class="s2">&quot;dd-&gt;d&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">HAS_REFCOUNT</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;Python lacks refcounts&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;offset&quot;</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.BUFSIZE//</span><span class="s3">2</span><span class="s0">, </span><span class="s1">int(</span><span class="s3">1.5</span><span class="s1">*np.BUFSIZE)])</span>
<span class="s0">def </span><span class="s1">test_reduce_casterrors(offset):</span>
    <span class="s4"># Test reporting of casting errors in reductions, we test various</span>
    <span class="s4"># offsets to where the casting error will occur, since these may occur</span>
    <span class="s4"># at different places during the reduction procedure. For example</span>
    <span class="s4"># the first item may be special.</span>
    <span class="s1">value = </span><span class="s3">123  </span><span class="s4"># relies on python cache (leak-check will still find it)</span>
    <span class="s1">arr = np.array([value] * offset +</span>
                   <span class="s1">[</span><span class="s2">&quot;string&quot;</span><span class="s1">] +</span>
                   <span class="s1">[value] * int(</span><span class="s3">1.5 </span><span class="s1">* np.BUFSIZE)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">out = np.array(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>

    <span class="s1">count = sys.getrefcount(value)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;invalid literal&quot;</span><span class="s1">):</span>
        <span class="s4"># This is an unsafe cast, but we currently always allow that.</span>
        <span class="s4"># Note that the double loop is picked, but the cast fails.</span>
        <span class="s1">np.add.reduce(arr</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">out=out)</span>
    <span class="s0">assert </span><span class="s1">count == sys.getrefcount(value)</span>
    <span class="s4"># If an error occurred during casting, the operation is done at most until</span>
    <span class="s4"># the error occurs (the result of which would be `value * offset`) and -1</span>
    <span class="s4"># if the error happened immediately.</span>
    <span class="s4"># This does not define behaviour, the output is invalid and thus undefined</span>
    <span class="s0">assert </span><span class="s1">out[()] &lt; value * offset</span>


<span class="s1">@pytest.mark.skipif(IS_WASM</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;fp errors don't work in wasm&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">,</span>
        <span class="s1">[np.add.accumulate</span><span class="s0">, </span><span class="s1">np.add.reduce</span><span class="s0">,</span>
         <span class="s1">pytest.param(</span><span class="s0">lambda </span><span class="s1">x: np.add.reduceat(x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">id=</span><span class="s2">&quot;reduceat&quot;</span><span class="s1">)</span><span class="s0">,</span>
         <span class="s1">pytest.param(</span><span class="s0">lambda </span><span class="s1">x: np.log.at(x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">id=</span><span class="s2">&quot;at&quot;</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_ufunc_methods_floaterrors(method):</span>
    <span class="s4"># adding inf and -inf (or log(-inf) creates an invalid float and warns</span>
    <span class="s1">arr = np.array([np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-np.inf])</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;warn&quot;</span><span class="s1">):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;invalid value&quot;</span><span class="s1">):</span>
            <span class="s1">method(arr)</span>

    <span class="s1">arr = np.array([np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">-np.inf])</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;raise&quot;</span><span class="s1">):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(FloatingPointError):</span>
            <span class="s1">method(arr)</span>


<span class="s0">def </span><span class="s1">_check_neg_zero(value):</span>
    <span class="s0">if </span><span class="s1">value != </span><span class="s3">0.0</span><span class="s1">:</span>
        <span class="s0">return False</span>
    <span class="s0">if not </span><span class="s1">np.signbit(value.real):</span>
        <span class="s0">return False</span>
    <span class="s0">if </span><span class="s1">value.dtype.kind == </span><span class="s2">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.signbit(value.imag)</span>
    <span class="s0">return True</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">&quot;AllFloat&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_addition_negative_zero(dtype):</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s0">if </span><span class="s1">dtype.kind == </span><span class="s2">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s1">neg_zero = dtype.type(complex(-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">neg_zero = dtype.type(-</span><span class="s3">0.0</span><span class="s1">)</span>

    <span class="s1">arr = np.array(neg_zero)</span>
    <span class="s1">arr2 = np.array(neg_zero)</span>

    <span class="s0">assert </span><span class="s1">_check_neg_zero(arr + arr2)</span>
    <span class="s4"># In-place ops may end up on a different path (reduce path) see gh-21211</span>
    <span class="s1">arr += arr2</span>
    <span class="s0">assert </span><span class="s1">_check_neg_zero(arr)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">np.typecodes[</span><span class="s2">&quot;AllFloat&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;use_initial&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_addition_reduce_negative_zero(dtype</span><span class="s0">, </span><span class="s1">use_initial):</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s0">if </span><span class="s1">dtype.kind == </span><span class="s2">&quot;c&quot;</span><span class="s1">:</span>
        <span class="s1">neg_zero = dtype.type(complex(-</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.0</span><span class="s1">))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">neg_zero = dtype.type(-</span><span class="s3">0.0</span><span class="s1">)</span>

    <span class="s1">kwargs = {}</span>
    <span class="s0">if </span><span class="s1">use_initial:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;initial&quot;</span><span class="s1">] = neg_zero</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">pytest.xfail(</span><span class="s2">&quot;-0. propagation in sum currently requires initial&quot;</span><span class="s1">)</span>

    <span class="s4"># Test various length, in case SIMD paths or chunking play a role.</span>
    <span class="s4"># 150 extends beyond the pairwise blocksize; probably not important.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">150</span><span class="s1">):</span>
        <span class="s1">arr = np.array([neg_zero] * i</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">res = np.sum(arr</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">i &gt; </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">use_initial:</span>
            <span class="s0">assert </span><span class="s1">_check_neg_zero(res)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># `sum([])` should probably be 0.0 and not -0.0 like `sum([-0.0])`</span>
            <span class="s0">assert not </span><span class="s1">np.signbit(res.real)</span>
            <span class="s0">assert not </span><span class="s1">np.signbit(res.imag)</span>

<span class="s0">class </span><span class="s1">TestLowlevelAPIAccess:</span>
    <span class="s0">def </span><span class="s1">test_resolve_dtypes_basic(self):</span>
        <span class="s4"># Basic test for dtype resolution:</span>
        <span class="s1">i4 = np.dtype(</span><span class="s2">&quot;i4&quot;</span><span class="s1">)</span>
        <span class="s1">f4 = np.dtype(</span><span class="s2">&quot;f4&quot;</span><span class="s1">)</span>
        <span class="s1">f8 = np.dtype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span>

        <span class="s1">r = np.add.resolve_dtypes((i4</span><span class="s0">, </span><span class="s1">f4</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">r == (f8</span><span class="s0">, </span><span class="s1">f8</span><span class="s0">, </span><span class="s1">f8)</span>

        <span class="s4"># Signature uses the same logic to parse as ufunc (less strict)</span>
        <span class="s4"># the following is &quot;same-kind&quot; casting so works:</span>
        <span class="s1">r = np.add.resolve_dtypes((</span>
                <span class="s1">i4</span><span class="s0">, </span><span class="s1">i4</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">signature=(</span><span class="s0">None, None, </span><span class="s2">&quot;f4&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">r == (f4</span><span class="s0">, </span><span class="s1">f4</span><span class="s0">, </span><span class="s1">f4)</span>

        <span class="s4"># Check NEP 50 &quot;weak&quot; promotion also:</span>
        <span class="s1">r = np.add.resolve_dtypes((f4</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">r == (f4</span><span class="s0">, </span><span class="s1">f4</span><span class="s0">, </span><span class="s1">f4)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.resolve_dtypes((i4</span><span class="s0">, </span><span class="s1">f4</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">casting=</span><span class="s2">&quot;no&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_weird_dtypes(self):</span>
        <span class="s1">S0 = np.dtype(</span><span class="s2">&quot;S0&quot;</span><span class="s1">)</span>
        <span class="s4"># S0 is often converted by NumPy to S1, but not here:</span>
        <span class="s1">r = np.equal.resolve_dtypes((S0</span><span class="s0">, </span><span class="s1">S0</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">r == (S0</span><span class="s0">, </span><span class="s1">S0</span><span class="s0">, </span><span class="s1">np.dtype(bool))</span>

        <span class="s4"># Subarray dtypes are weird and only really exist nested, they need</span>
        <span class="s4"># the shift to full NEP 50 to be implemented nicely:</span>
        <span class="s1">dts = np.dtype(</span><span class="s2">&quot;10i&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
            <span class="s1">np.equal.resolve_dtypes((dts</span><span class="s0">, </span><span class="s1">dts</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_resolve_dtypes_reduction(self):</span>
        <span class="s1">i4 = np.dtype(</span><span class="s2">&quot;i4&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
            <span class="s1">np.add.resolve_dtypes((i4</span><span class="s0">, </span><span class="s1">i4</span><span class="s0">, </span><span class="s1">i4)</span><span class="s0">, </span><span class="s1">reduction=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtypes&quot;</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">(np.dtype(</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">&quot;i&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">None, </span><span class="s1">np.dtype(</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.dtype(</span><span class="s2">&quot;f&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(np.dtype(</span><span class="s2">&quot;i&quot;</span><span class="s1">)</span><span class="s0">, None, </span><span class="s1">np.dtype(</span><span class="s2">&quot;f&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;i4&quot;</span><span class="s0">, </span><span class="s2">&quot;i4&quot;</span><span class="s0">, None</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_resolve_dtypes_errors(self</span><span class="s0">, </span><span class="s1">dtypes):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.resolve_dtypes(dtypes)</span>

    <span class="s0">def </span><span class="s1">test_resolve_dtypes_reduction(self):</span>
        <span class="s1">i2 = np.dtype(</span><span class="s2">&quot;i2&quot;</span><span class="s1">)</span>
        <span class="s1">long_ = np.dtype(</span><span class="s2">&quot;long&quot;</span><span class="s1">)</span>
        <span class="s4"># Check special addition resolution:</span>
        <span class="s1">res = np.add.resolve_dtypes((</span><span class="s0">None, </span><span class="s1">i2</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">reduction=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res == (long_</span><span class="s0">, </span><span class="s1">long_</span><span class="s0">, </span><span class="s1">long_)</span>

    <span class="s0">def </span><span class="s1">test_resolve_dtypes_reduction_errors(self):</span>
        <span class="s1">i2 = np.dtype(</span><span class="s2">&quot;i2&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.resolve_dtypes((</span><span class="s0">None, </span><span class="s1">i2</span><span class="s0">, </span><span class="s1">i2))</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">np.add.signature((</span><span class="s0">None, None, </span><span class="s2">&quot;i4&quot;</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">hasattr(ct</span><span class="s0">, </span><span class="s2">&quot;pythonapi&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">reason=</span><span class="s2">&quot;`ctypes.pythonapi` required for capsule unpacking.&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_loop_access(self):</span>
        <span class="s4"># This is a basic test for the full strided loop access</span>
        <span class="s1">data_t = ct.ARRAY(ct.c_char_p</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">dim_t = ct.ARRAY(ct.c_ssize_t</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">strides_t = ct.ARRAY(ct.c_ssize_t</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">strided_loop_t = ct.CFUNCTYPE(</span>
                <span class="s1">ct.c_int</span><span class="s0">, </span><span class="s1">ct.c_void_p</span><span class="s0">, </span><span class="s1">data_t</span><span class="s0">, </span><span class="s1">dim_t</span><span class="s0">, </span><span class="s1">strides_t</span><span class="s0">, </span><span class="s1">ct.c_void_p)</span>

        <span class="s0">class </span><span class="s1">call_info_t(ct.Structure):</span>
            <span class="s1">_fields_ = [</span>
                <span class="s1">(</span><span class="s2">&quot;strided_loop&quot;</span><span class="s0">, </span><span class="s1">strided_loop_t)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;context&quot;</span><span class="s0">, </span><span class="s1">ct.c_void_p)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;auxdata&quot;</span><span class="s0">, </span><span class="s1">ct.c_void_p)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;requires_pyapi&quot;</span><span class="s0">, </span><span class="s1">ct.c_byte)</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">&quot;no_floatingpoint_errors&quot;</span><span class="s0">, </span><span class="s1">ct.c_byte)</span><span class="s0">,</span>
            <span class="s1">]</span>

        <span class="s1">i4 = np.dtype(</span><span class="s2">&quot;i4&quot;</span><span class="s1">)</span>
        <span class="s1">dt</span><span class="s0">, </span><span class="s1">call_info_obj = np.negative._resolve_dtypes_and_context((i4</span><span class="s0">, </span><span class="s1">i4))</span>
        <span class="s0">assert </span><span class="s1">dt == (i4</span><span class="s0">, </span><span class="s1">i4)  </span><span class="s4"># can be used without casting</span>

        <span class="s4"># Fill in the rest of the information:</span>
        <span class="s1">np.negative._get_strided_loop(call_info_obj)</span>

        <span class="s1">ct.pythonapi.PyCapsule_GetPointer.restype = ct.c_void_p</span>
        <span class="s1">call_info = ct.pythonapi.PyCapsule_GetPointer(</span>
                <span class="s1">ct.py_object(call_info_obj)</span><span class="s0">,</span>
                <span class="s1">ct.c_char_p(</span><span class="s6">b&quot;numpy_1.24_ufunc_call_info&quot;</span><span class="s1">))</span>

        <span class="s1">call_info = ct.cast(call_info</span><span class="s0">, </span><span class="s1">ct.POINTER(call_info_t)).contents</span>

        <span class="s1">arr = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=i4)</span>
        <span class="s1">call_info.strided_loop(</span>
                <span class="s1">call_info.context</span><span class="s0">,</span>
                <span class="s1">data_t(arr.ctypes.data</span><span class="s0">, </span><span class="s1">arr.ctypes.data)</span><span class="s0">,</span>
                <span class="s1">arr.ctypes.shape</span><span class="s0">,  </span><span class="s4"># is a C-array with 10 here</span>
                <span class="s1">strides_t(arr.ctypes.strides[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">arr.ctypes.strides[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">call_info.auxdata)</span>

        <span class="s4"># We just directly called the negative inner-loop in-place:</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">-np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=i4))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;strides&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test__get_strided_loop_errors_bad_strides(self</span><span class="s0">, </span><span class="s1">strides):</span>
        <span class="s1">i4 = np.dtype(</span><span class="s2">&quot;i4&quot;</span><span class="s1">)</span>
        <span class="s1">dt</span><span class="s0">, </span><span class="s1">call_info = np.negative._resolve_dtypes_and_context((i4</span><span class="s0">, </span><span class="s1">i4))</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;fixed_strides.*tuple.*or None&quot;</span><span class="s1">):</span>
            <span class="s1">np.negative._get_strided_loop(call_info</span><span class="s0">, </span><span class="s1">fixed_strides=strides)</span>

    <span class="s0">def </span><span class="s1">test__get_strided_loop_errors_bad_call_info(self):</span>
        <span class="s1">i4 = np.dtype(</span><span class="s2">&quot;i4&quot;</span><span class="s1">)</span>
        <span class="s1">dt</span><span class="s0">, </span><span class="s1">call_info = np.negative._resolve_dtypes_and_context((i4</span><span class="s0">, </span><span class="s1">i4))</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;PyCapsule&quot;</span><span class="s1">):</span>
            <span class="s1">np.negative._get_strided_loop(</span><span class="s2">&quot;not the capsule!&quot;</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;.*incompatible context&quot;</span><span class="s1">):</span>
            <span class="s1">np.add._get_strided_loop(call_info)</span>

        <span class="s1">np.negative._get_strided_loop(call_info)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s4"># cannot call it a second time:</span>
            <span class="s1">np.negative._get_strided_loop(call_info)</span>
</pre>
</body>
</html>