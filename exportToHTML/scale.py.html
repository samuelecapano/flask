<html>
<head>
<title>scale.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scale.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Scales define the distribution of data values on an axis, e.g. a log scaling. 
They are defined as subclasses of `ScaleBase`. 
 
See also `.axes.Axes.set_xscale` and the scales examples in the documentation. 
 
See :doc:`/gallery/scales/custom_scale` for a full example of defining a custom 
scale. 
 
Matplotlib also supports non-separable transformations that operate on both 
`~.axis.Axis` at the same time.  They are known as projections, and defined in 
`matplotlib.projections`. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">textwrap</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">from </span><span class="s1">matplotlib.ticker </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NullFormatter</span><span class="s2">, </span><span class="s1">ScalarFormatter</span><span class="s2">, </span><span class="s1">LogFormatterSciNotation</span><span class="s2">, </span><span class="s1">LogitFormatter</span><span class="s2">,</span>
    <span class="s1">NullLocator</span><span class="s2">, </span><span class="s1">LogLocator</span><span class="s2">, </span><span class="s1">AutoLocator</span><span class="s2">, </span><span class="s1">AutoMinorLocator</span><span class="s2">,</span>
    <span class="s1">SymmetricalLogLocator</span><span class="s2">, </span><span class="s1">AsinhLocator</span><span class="s2">, </span><span class="s1">LogitLocator)</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Transform</span><span class="s2">, </span><span class="s1">IdentityTransform</span>


<span class="s2">class </span><span class="s1">ScaleBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class for all scales. 
 
    Scales are separable transformations, working on a single dimension. 
 
    Subclasses should override 
 
    :attr:`name` 
        The scale's name. 
    :meth:`get_transform` 
        A method returning a `.Transform`, which converts data coordinates to 
        scaled coordinates.  This transform should be invertible, so that e.g. 
        mouse positions can be converted back to data coordinates. 
    :meth:`set_default_locators_and_formatters` 
        A method that sets default locators and formatters for an `~.axis.Axis` 
        that uses this scale. 
    :meth:`limit_range_for_scale` 
        An optional method that &quot;fixes&quot; the axis range to acceptable values, 
        e.g. restricting log-scaled axes to positive values. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Construct a new scale. 
 
        Notes 
        ----- 
        The following note is for scale implementors. 
 
        For back-compatibility reasons, scales take an `~matplotlib.axis.Axis` 
        object as first argument.  However, this argument should not 
        be used: a single scale object should be usable by multiple 
        `~matplotlib.axis.Axis`\es at the same time. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.Transform` object associated with this scale. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the locators and formatters of *axis* to instances suitable for 
        this scale. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">limit_range_for_scale(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">minpos):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the range *vmin*, *vmax*, restricted to the 
        domain supported by this scale (if any). 
 
        *minpos* should be the minimum positive value in the data. 
        This is used by log scales to determine a minimum value. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>


<span class="s2">class </span><span class="s1">LinearScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    The default linear scale. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">'linear'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># This method is present only to prevent inheritance of the base class'</span>
        <span class="s4"># constructor docstring, which would otherwise end up interpolated into</span>
        <span class="s4"># the docstring of Axis.set_scale.</span>
        <span class="s0">&quot;&quot;&quot; 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">axis.set_major_locator(AutoLocator())</span>
        <span class="s1">axis.set_major_formatter(ScalarFormatter())</span>
        <span class="s1">axis.set_minor_formatter(NullFormatter())</span>
        <span class="s4"># update the minor locator for x and y axis based on rcParams</span>
        <span class="s2">if </span><span class="s1">(axis.axis_name == </span><span class="s3">'x' </span><span class="s2">and </span><span class="s1">mpl.rcParams[</span><span class="s3">'xtick.minor.visible'</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">axis.axis_name == </span><span class="s3">'y' </span><span class="s2">and </span><span class="s1">mpl.rcParams[</span><span class="s3">'ytick.minor.visible'</span><span class="s1">]):</span>
            <span class="s1">axis.set_minor_locator(AutoMinorLocator())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axis.set_minor_locator(NullLocator())</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the transform for linear scaling, which is just the 
        `~matplotlib.transforms.IdentityTransform`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">IdentityTransform()</span>


<span class="s2">class </span><span class="s1">FuncTransform(Transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    A simple transform that takes and arbitrary function for the 
    forward and inverse transform. 
    &quot;&quot;&quot;</span>

    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">forward</span><span class="s2">, </span><span class="s1">inverse):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        forward : callable 
            The forward function for the transform.  This function must have 
            an inverse and, for best behavior, be monotonic. 
            It must have the signature:: 
 
               def forward(values: array-like) -&gt; array-like 
 
        inverse : callable 
            The inverse of the forward function.  Signature as ``forward``. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">callable(forward) </span><span class="s2">and </span><span class="s1">callable(inverse):</span>
            <span class="s1">self._forward = forward</span>
            <span class="s1">self._inverse = inverse</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'arguments to FuncTransform must be functions'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s2">return </span><span class="s1">self._forward(values)</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">FuncTransform(self._inverse</span><span class="s2">, </span><span class="s1">self._forward)</span>


<span class="s2">class </span><span class="s1">FuncScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide an arbitrary scale with user-supplied function for the axis. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">'function'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">functions):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `~matplotlib.axis.Axis` 
            The axis for the scale. 
        functions : (callable, callable) 
            two-tuple of the forward and inverse functions for the scale. 
            The forward function must be monotonic. 
 
            Both functions must have the signature:: 
 
               def forward(values: array-like) -&gt; array-like 
        &quot;&quot;&quot;</span>
        <span class="s1">forward</span><span class="s2">, </span><span class="s1">inverse = functions</span>
        <span class="s1">transform = FuncTransform(forward</span><span class="s2">, </span><span class="s1">inverse)</span>
        <span class="s1">self._transform = transform</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.FuncTransform` associated with this scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">axis.set_major_locator(AutoLocator())</span>
        <span class="s1">axis.set_major_formatter(ScalarFormatter())</span>
        <span class="s1">axis.set_minor_formatter(NullFormatter())</span>
        <span class="s4"># update the minor locator for x and y axis based on rcParams</span>
        <span class="s2">if </span><span class="s1">(axis.axis_name == </span><span class="s3">'x' </span><span class="s2">and </span><span class="s1">mpl.rcParams[</span><span class="s3">'xtick.minor.visible'</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">axis.axis_name == </span><span class="s3">'y' </span><span class="s2">and </span><span class="s1">mpl.rcParams[</span><span class="s3">'ytick.minor.visible'</span><span class="s1">]):</span>
            <span class="s1">axis.set_minor_locator(AutoMinorLocator())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axis.set_minor_locator(NullLocator())</span>


<span class="s2">class </span><span class="s1">LogTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">nonpositive=</span><span class="s3">'clip'</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">base &lt;= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">base == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'The log base cannot be &lt;= 0 or == 1'</span><span class="s1">)</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self._clip = _api.check_getitem(</span>
            <span class="s1">{</span><span class="s3">&quot;clip&quot;</span><span class="s1">: </span><span class="s2">True, </span><span class="s3">&quot;mask&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span><span class="s2">, </span><span class="s1">nonpositive=nonpositive)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;{}(base={}, nonpositive={!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">type(self).__name__</span><span class="s2">, </span><span class="s1">self.base</span><span class="s2">, </span><span class="s3">&quot;clip&quot; </span><span class="s2">if </span><span class="s1">self._clip </span><span class="s2">else </span><span class="s3">&quot;mask&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s4"># Ignore invalid values due to nans being passed to the transform.</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">log = {np.e: np.log</span><span class="s2">, </span><span class="s5">2</span><span class="s1">: np.log2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">: np.log10}.get(self.base)</span>
            <span class="s2">if </span><span class="s1">log:  </span><span class="s4"># If possible, do everything in a single call to NumPy.</span>
                <span class="s1">out = log(a)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">out = np.log(a)</span>
                <span class="s1">out /= np.log(self.base)</span>
            <span class="s2">if </span><span class="s1">self._clip:</span>
                <span class="s4"># SVG spec says that conforming viewers must support values up</span>
                <span class="s4"># to 3.4e38 (C float); however experiments suggest that</span>
                <span class="s4"># Inkscape (which uses cairo for rendering) runs into cairo's</span>
                <span class="s4"># 24-bit limit (which is apparently shared by Agg).</span>
                <span class="s4"># Ghostscript (used for pdf rendering appears to overflow even</span>
                <span class="s4"># earlier, with the max value around 2 ** 15 for the tests to</span>
                <span class="s4"># pass. On the other hand, in practice, we want to clip beyond</span>
                <span class="s4">#     np.log10(np.nextafter(0, 1)) ~ -323</span>
                <span class="s4"># so 1000 seems safe.</span>
                <span class="s1">out[a &lt;= </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1000</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">InvertedLogTransform(self.base)</span>


<span class="s2">class </span><span class="s1">InvertedLogTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.base = base</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;{}(base={})&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s2">, </span><span class="s1">self.base)</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">return </span><span class="s1">np.power(self.base</span><span class="s2">, </span><span class="s1">a)</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">LogTransform(self.base)</span>


<span class="s2">class </span><span class="s1">LogScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A standard logarithmic scale.  Care is taken to only plot positive values. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s3">'log'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">subs=</span><span class="s2">None, </span><span class="s1">nonpositive=</span><span class="s3">&quot;clip&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `~matplotlib.axis.Axis` 
            The axis for the scale. 
        base : float, default: 10 
            The base of the logarithm. 
        nonpositive : {'clip', 'mask'}, default: 'clip' 
            Determines the behavior for non-positive values. They can either 
            be masked as invalid, or clipped to a very small positive number. 
        subs : sequence of int, default: None 
            Where to place the subticks between each major tick.  For example, 
            in a log10 scale, ``[2, 3, 4, 5, 6, 7, 8, 9]`` will place 8 
            logarithmically spaced minor ticks between each major tick. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._transform = LogTransform(base</span><span class="s2">, </span><span class="s1">nonpositive)</span>
        <span class="s1">self.subs = subs</span>

    <span class="s1">base = property(</span><span class="s2">lambda </span><span class="s1">self: self._transform.base)</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">axis.set_major_locator(LogLocator(self.base))</span>
        <span class="s1">axis.set_major_formatter(LogFormatterSciNotation(self.base))</span>
        <span class="s1">axis.set_minor_locator(LogLocator(self.base</span><span class="s2">, </span><span class="s1">self.subs))</span>
        <span class="s1">axis.set_minor_formatter(</span>
            <span class="s1">LogFormatterSciNotation(self.base</span><span class="s2">,</span>
                                    <span class="s1">labelOnlyBase=(self.subs </span><span class="s2">is not None</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.LogTransform` associated with this scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform</span>

    <span class="s2">def </span><span class="s1">limit_range_for_scale(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">minpos):</span>
        <span class="s0">&quot;&quot;&quot;Limit the domain to positive values.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(minpos):</span>
            <span class="s1">minpos = </span><span class="s5">1e-300  </span><span class="s4"># Should rarely (if ever) have a visible effect.</span>

        <span class="s2">return </span><span class="s1">(minpos </span><span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">vmin</span><span class="s2">,</span>
                <span class="s1">minpos </span><span class="s2">if </span><span class="s1">vmax &lt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">vmax)</span>


<span class="s2">class </span><span class="s1">FuncScaleLog(LogScale):</span>
    <span class="s0">&quot;&quot;&quot; 
    Provide an arbitrary scale with user-supplied function for the axis and 
    then put on a logarithmic axes. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">'functionlog'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">functions</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `matplotlib.axis.Axis` 
            The axis for the scale. 
        functions : (callable, callable) 
            two-tuple of the forward and inverse functions for the scale. 
            The forward function must be monotonic. 
 
            Both functions must have the signature:: 
 
                def forward(values: array-like) -&gt; array-like 
 
        base : float, default: 10 
            Logarithmic base of the scale. 
        &quot;&quot;&quot;</span>
        <span class="s1">forward</span><span class="s2">, </span><span class="s1">inverse = functions</span>
        <span class="s1">self.subs = </span><span class="s2">None</span>
        <span class="s1">self._transform = FuncTransform(forward</span><span class="s2">, </span><span class="s1">inverse) + LogTransform(base)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">base(self):</span>
        <span class="s2">return </span><span class="s1">self._transform._b.base  </span><span class="s4"># Base of the LogTransform.</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.Transform` associated with this scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform</span>


<span class="s2">class </span><span class="s1">SymmetricalLogTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">linthresh</span><span class="s2">, </span><span class="s1">linscale):</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">base &lt;= </span><span class="s5">1.0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'base' must be larger than 1&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">linthresh &lt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'linthresh' must be positive&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">linscale &lt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'linscale' must be positive&quot;</span><span class="s1">)</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.linthresh = linthresh</span>
        <span class="s1">self.linscale = linscale</span>
        <span class="s1">self._linscale_adj = (linscale / (</span><span class="s5">1.0 </span><span class="s1">- self.base ** -</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self._log_base = np.log(base)</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s1">abs_a = np.abs(a)</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">out = np.sign(a) * self.linthresh * (</span>
                <span class="s1">self._linscale_adj +</span>
                <span class="s1">np.log(abs_a / self.linthresh) / self._log_base)</span>
            <span class="s1">inside = abs_a &lt;= self.linthresh</span>
        <span class="s1">out[inside] = a[inside] * self._linscale_adj</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">InvertedSymmetricalLogTransform(self.base</span><span class="s2">, </span><span class="s1">self.linthresh</span><span class="s2">,</span>
                                               <span class="s1">self.linscale)</span>


<span class="s2">class </span><span class="s1">InvertedSymmetricalLogTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">linthresh</span><span class="s2">, </span><span class="s1">linscale):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">symlog = SymmetricalLogTransform(base</span><span class="s2">, </span><span class="s1">linthresh</span><span class="s2">, </span><span class="s1">linscale)</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.linthresh = linthresh</span>
        <span class="s1">self.invlinthresh = symlog.transform(linthresh)</span>
        <span class="s1">self.linscale = linscale</span>
        <span class="s1">self._linscale_adj = (linscale / (</span><span class="s5">1.0 </span><span class="s1">- self.base ** -</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s1">abs_a = np.abs(a)</span>
        <span class="s2">if </span><span class="s1">(abs_a &lt; self.linthresh).all():</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s3">&quot;All values for SymLogScale are below linthresh, making &quot;</span>
                <span class="s3">&quot;it effectively linear. You likely should lower the value &quot;</span>
                <span class="s3">&quot;of linthresh. &quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">out = np.sign(a) * self.linthresh * (</span>
                <span class="s1">np.power(self.base</span><span class="s2">,</span>
                         <span class="s1">abs_a / self.linthresh - self._linscale_adj))</span>
            <span class="s1">inside = abs_a &lt;= self.invlinthresh</span>
        <span class="s1">out[inside] = a[inside] / self._linscale_adj</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">SymmetricalLogTransform(self.base</span><span class="s2">,</span>
                                       <span class="s1">self.linthresh</span><span class="s2">, </span><span class="s1">self.linscale)</span>


<span class="s2">class </span><span class="s1">SymmetricalLogScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    The symmetrical logarithmic scale is logarithmic in both the 
    positive and negative directions from the origin. 
 
    Since the values close to zero tend toward infinity, there is a 
    need to have a range around zero that is linear.  The parameter 
    *linthresh* allows the user to specify the size of this range 
    (-*linthresh*, *linthresh*). 
 
    Parameters 
    ---------- 
    base : float, default: 10 
        The base of the logarithm. 
 
    linthresh : float, default: 2 
        Defines the range ``(-x, x)``, within which the plot is linear. 
        This avoids having the plot go to infinity around zero. 
 
    subs : sequence of int 
        Where to place the subticks between each major tick. 
        For example, in a log10 scale: ``[2, 3, 4, 5, 6, 7, 8, 9]`` will place 
        8 logarithmically spaced minor ticks between each major tick. 
 
    linscale : float, optional 
        This allows the linear range ``(-linthresh, linthresh)`` to be 
        stretched relative to the logarithmic range. Its value is the number of 
        decades to use for each half of the linear range. For example, when 
        *linscale* == 1.0 (the default), the space used for the positive and 
        negative halves of the linear range will be equal to one decade in 
        the logarithmic range. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s3">'symlog'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">linthresh=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">subs=</span><span class="s2">None, </span><span class="s1">linscale=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">self._transform = SymmetricalLogTransform(base</span><span class="s2">, </span><span class="s1">linthresh</span><span class="s2">, </span><span class="s1">linscale)</span>
        <span class="s1">self.subs = subs</span>

    <span class="s1">base = property(</span><span class="s2">lambda </span><span class="s1">self: self._transform.base)</span>
    <span class="s1">linthresh = property(</span><span class="s2">lambda </span><span class="s1">self: self._transform.linthresh)</span>
    <span class="s1">linscale = property(</span><span class="s2">lambda </span><span class="s1">self: self._transform.linscale)</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">axis.set_major_locator(SymmetricalLogLocator(self.get_transform()))</span>
        <span class="s1">axis.set_major_formatter(LogFormatterSciNotation(self.base))</span>
        <span class="s1">axis.set_minor_locator(SymmetricalLogLocator(self.get_transform()</span><span class="s2">,</span>
                                                     <span class="s1">self.subs))</span>
        <span class="s1">axis.set_minor_formatter(NullFormatter())</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.SymmetricalLogTransform` associated with this scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform</span>


<span class="s2">class </span><span class="s1">AsinhTransform(Transform):</span>
    <span class="s0">&quot;&quot;&quot;Inverse hyperbolic-sine transformation used by `.AsinhScale`&quot;&quot;&quot;</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">linear_width):</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">linear_width &lt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Scale parameter 'linear_width' &quot; </span><span class="s1">+</span>
                             <span class="s3">&quot;must be strictly positive&quot;</span><span class="s1">)</span>
        <span class="s1">self.linear_width = linear_width</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">return </span><span class="s1">self.linear_width * np.arcsinh(a / self.linear_width)</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">InvertedAsinhTransform(self.linear_width)</span>


<span class="s2">class </span><span class="s1">InvertedAsinhTransform(Transform):</span>
    <span class="s0">&quot;&quot;&quot;Hyperbolic sine transformation used by `.AsinhScale`&quot;&quot;&quot;</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">linear_width):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.linear_width = linear_width</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">return </span><span class="s1">self.linear_width * np.sinh(a / self.linear_width)</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">AsinhTransform(self.linear_width)</span>


<span class="s2">class </span><span class="s1">AsinhScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A quasi-logarithmic scale based on the inverse hyperbolic sine (asinh) 
 
    For values close to zero, this is essentially a linear scale, 
    but for large magnitude values (either positive or negative) 
    it is asymptotically logarithmic. The transition between these 
    linear and logarithmic regimes is smooth, and has no discontinuities 
    in the function gradient in contrast to 
    the `.SymmetricalLogScale` (&quot;symlog&quot;) scale. 
 
    Specifically, the transformation of an axis coordinate :math:`a` is 
    :math:`a \\rightarrow a_0 \\sinh^{-1} (a / a_0)` where :math:`a_0` 
    is the effective width of the linear region of the transformation. 
    In that region, the transformation is 
    :math:`a \\rightarrow a + \\mathcal{O}(a^3)`. 
    For large values of :math:`a` the transformation behaves as 
    :math:`a \\rightarrow a_0 \\, \\mathrm{sgn}(a) \\ln |a| + \\mathcal{O}(1)`. 
 
    .. note:: 
 
       This API is provisional and may be revised in the future 
       based on early user feedback. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">'asinh'</span>

    <span class="s1">auto_tick_multipliers = {</span>
        <span class="s5">3</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">4</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">5</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">8</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">10</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">16</span><span class="s1">: (</span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">64</span><span class="s1">: (</span><span class="s5">4</span><span class="s2">, </span><span class="s5">16</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5">1024</span><span class="s1">: (</span><span class="s5">256</span><span class="s2">, </span><span class="s5">512</span><span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">linear_width=</span><span class="s5">1.0</span><span class="s2">,</span>
                 <span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">subs=</span><span class="s3">'auto'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        linear_width : float, default: 1 
            The scale parameter (elsewhere referred to as :math:`a_0`) 
            defining the extent of the quasi-linear region, 
            and the coordinate values beyond which the transformation 
            becomes asymptotically logarithmic. 
        base : int, default: 10 
            The number base used for rounding tick locations 
            on a logarithmic scale. If this is less than one, 
            then rounding is to the nearest integer multiple 
            of powers of ten. 
        subs : sequence of int 
            Multiples of the number base used for minor ticks. 
            If set to 'auto', this will use built-in defaults, 
            e.g. (2, 5) for base=10. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(axis)</span>
        <span class="s1">self._transform = AsinhTransform(linear_width)</span>
        <span class="s1">self._base = int(base)</span>
        <span class="s2">if </span><span class="s1">subs == </span><span class="s3">'auto'</span><span class="s1">:</span>
            <span class="s1">self._subs = self.auto_tick_multipliers.get(self._base)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._subs = subs</span>

    <span class="s1">linear_width = property(</span><span class="s2">lambda </span><span class="s1">self: self._transform.linear_width)</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s2">return </span><span class="s1">self._transform</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s1">axis.set(major_locator=AsinhLocator(self.linear_width</span><span class="s2">,</span>
                                            <span class="s1">base=self._base)</span><span class="s2">,</span>
                 <span class="s1">minor_locator=AsinhLocator(self.linear_width</span><span class="s2">,</span>
                                            <span class="s1">base=self._base</span><span class="s2">,</span>
                                            <span class="s1">subs=self._subs)</span><span class="s2">,</span>
                 <span class="s1">minor_formatter=NullFormatter())</span>
        <span class="s2">if </span><span class="s1">self._base &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">axis.set_major_formatter(LogFormatterSciNotation(self._base))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axis.set_major_formatter(</span><span class="s3">'{x:.3g}'</span><span class="s1">)</span><span class="s2">,</span>


<span class="s2">class </span><span class="s1">LogitTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nonpositive=</span><span class="s3">'mask'</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">_api.check_in_list([</span><span class="s3">'mask'</span><span class="s2">, </span><span class="s3">'clip'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nonpositive=nonpositive)</span>
        <span class="s1">self._nonpositive = nonpositive</span>
        <span class="s1">self._clip = {</span><span class="s3">&quot;clip&quot;</span><span class="s1">: </span><span class="s2">True, </span><span class="s3">&quot;mask&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}[nonpositive]</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;logit transform (base 10), masked or clipped&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">out = np.log10(a / (</span><span class="s5">1 </span><span class="s1">- a))</span>
        <span class="s2">if </span><span class="s1">self._clip:  </span><span class="s4"># See LogTransform for choice of clip value.</span>
            <span class="s1">out[a &lt;= </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1000</span>
            <span class="s1">out[</span><span class="s5">1 </span><span class="s1">&lt;= a] = </span><span class="s5">1000</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">LogisticTransform(self._nonpositive)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;{}({!r})&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s2">, </span><span class="s1">self._nonpositive)</span>


<span class="s2">class </span><span class="s1">LogisticTransform(Transform):</span>
    <span class="s1">input_dims = output_dims = </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nonpositive=</span><span class="s3">'mask'</span><span class="s1">):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._nonpositive = nonpositive</span>

    <span class="s2">def </span><span class="s1">transform_non_affine(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;logistic transform (base 10)&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1.0 </span><span class="s1">/ (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">10</span><span class="s1">**(-a))</span>

    <span class="s2">def </span><span class="s1">inverted(self):</span>
        <span class="s2">return </span><span class="s1">LogitTransform(self._nonpositive)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;{}({!r})&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s2">, </span><span class="s1">self._nonpositive)</span>


<span class="s2">class </span><span class="s1">LogitScale(ScaleBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Logit scale for data between zero and one, both excluded. 
 
    This scale is similar to a log scale close to zero and to one, and almost 
    linear around 0.5. It maps the interval ]0, 1[ onto ]-infty, +infty[. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s3">'logit'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nonpositive=</span><span class="s3">'mask'</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">one_half=</span><span class="s3">r&quot;\frac{1}{2}&quot;</span><span class="s2">, </span><span class="s1">use_overline=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axis : `matplotlib.axis.Axis` 
            Currently unused. 
        nonpositive : {'mask', 'clip'} 
            Determines the behavior for values beyond the open interval ]0, 1[. 
            They can either be masked as invalid, or clipped to a number very 
            close to 0 or 1. 
        use_overline : bool, default: False 
            Indicate the usage of survival notation (\overline{x}) in place of 
            standard notation (1-x) for probability close to one. 
        one_half : str, default: r&quot;\frac{1}{2}&quot; 
            The string used for ticks formatter to represent 1/2. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._transform = LogitTransform(nonpositive)</span>
        <span class="s1">self._use_overline = use_overline</span>
        <span class="s1">self._one_half = one_half</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.LogitTransform` associated with this scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform</span>

    <span class="s2">def </span><span class="s1">set_default_locators_and_formatters(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># ..., 0.01, 0.1, 0.5, 0.9, 0.99, ...</span>
        <span class="s1">axis.set_major_locator(LogitLocator())</span>
        <span class="s1">axis.set_major_formatter(</span>
            <span class="s1">LogitFormatter(</span>
                <span class="s1">one_half=self._one_half</span><span class="s2">,</span>
                <span class="s1">use_overline=self._use_overline</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">axis.set_minor_locator(LogitLocator(minor=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s1">axis.set_minor_formatter(</span>
            <span class="s1">LogitFormatter(</span>
                <span class="s1">minor=</span><span class="s2">True,</span>
                <span class="s1">one_half=self._one_half</span><span class="s2">,</span>
                <span class="s1">use_overline=self._use_overline</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">limit_range_for_scale(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">minpos):</span>
        <span class="s0">&quot;&quot;&quot; 
        Limit the domain to values between 0 and 1 (excluded). 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(minpos):</span>
            <span class="s1">minpos = </span><span class="s5">1e-7  </span><span class="s4"># Should rarely (if ever) have a visible effect.</span>
        <span class="s2">return </span><span class="s1">(minpos </span><span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">vmin</span><span class="s2">,</span>
                <span class="s5">1 </span><span class="s1">- minpos </span><span class="s2">if </span><span class="s1">vmax &gt;= </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">vmax)</span>


<span class="s1">_scale_mapping = {</span>
    <span class="s3">'linear'</span><span class="s1">: LinearScale</span><span class="s2">,</span>
    <span class="s3">'log'</span><span class="s1">:    LogScale</span><span class="s2">,</span>
    <span class="s3">'symlog'</span><span class="s1">: SymmetricalLogScale</span><span class="s2">,</span>
    <span class="s3">'asinh'</span><span class="s1">:  AsinhScale</span><span class="s2">,</span>
    <span class="s3">'logit'</span><span class="s1">:  LogitScale</span><span class="s2">,</span>
    <span class="s3">'function'</span><span class="s1">: FuncScale</span><span class="s2">,</span>
    <span class="s3">'functionlog'</span><span class="s1">: FuncScaleLog</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">def </span><span class="s1">get_scale_names():</span>
    <span class="s0">&quot;&quot;&quot;Return the names of the available scales.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">sorted(_scale_mapping)</span>


<span class="s2">def </span><span class="s1">scale_factory(scale</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a scale class by name. 
 
    Parameters 
    ---------- 
    scale : {%(names)s} 
    axis : `matplotlib.axis.Axis` 
    &quot;&quot;&quot;</span>
    <span class="s1">scale_cls = _api.check_getitem(_scale_mapping</span><span class="s2">, </span><span class="s1">scale=scale)</span>
    <span class="s2">return </span><span class="s1">scale_cls(axis</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">if </span><span class="s1">scale_factory.__doc__:</span>
    <span class="s1">scale_factory.__doc__ = scale_factory.__doc__ % {</span>
        <span class="s3">&quot;names&quot;</span><span class="s1">: </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(map(repr</span><span class="s2">, </span><span class="s1">get_scale_names()))}</span>


<span class="s2">def </span><span class="s1">register_scale(scale_class):</span>
    <span class="s0">&quot;&quot;&quot; 
    Register a new kind of scale. 
 
    Parameters 
    ---------- 
    scale_class : subclass of `ScaleBase` 
        The scale to register. 
    &quot;&quot;&quot;</span>
    <span class="s1">_scale_mapping[scale_class.name] = scale_class</span>


<span class="s2">def </span><span class="s1">_get_scale_docs():</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function for generating docstrings related to scales. 
    &quot;&quot;&quot;</span>
    <span class="s1">docs = []</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">scale_class </span><span class="s2">in </span><span class="s1">_scale_mapping.items():</span>
        <span class="s1">docstring = inspect.getdoc(scale_class.__init__) </span><span class="s2">or </span><span class="s3">&quot;&quot;</span>
        <span class="s1">docs.extend([</span>
            <span class="s3">f&quot;    </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">textwrap.indent(docstring</span><span class="s2">, </span><span class="s3">&quot; &quot; </span><span class="s1">* </span><span class="s5">8</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;&quot;</span>
        <span class="s1">])</span>
    <span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(docs)</span>


<span class="s1">_docstring.interpd.update(</span>
    <span class="s1">scale_type=</span><span class="s3">'{%s}' </span><span class="s1">% </span><span class="s3">', '</span><span class="s1">.join([repr(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">get_scale_names()])</span><span class="s2">,</span>
    <span class="s1">scale_docs=_get_scale_docs().rstrip()</span><span class="s2">,</span>
    <span class="s1">)</span>
</pre>
</body>
</html>