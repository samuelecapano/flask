<html>
<head>
<title>inset_locator.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
inset_locator.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A collection of functions and objects for creating or placing inset axes. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">from </span><span class="s1">matplotlib.offsetbox </span><span class="s2">import </span><span class="s1">AnchoredOffsetbox</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">Patch</span><span class="s2">, </span><span class="s1">Rectangle</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxTransformTo</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">IdentityTransform</span><span class="s2">, </span><span class="s1">TransformedBbox</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">axes_size </span><span class="s2">as </span><span class="s1">Size</span>
<span class="s2">from </span><span class="s1">.parasite_axes </span><span class="s2">import </span><span class="s1">HostAxes</span>


<span class="s2">class </span><span class="s1">InsetPosition:</span>
    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">lbwh):</span>
        <span class="s0">&quot;&quot;&quot; 
        An object for positioning an inset axes. 
 
        This is created by specifying the normalized coordinates in the axes, 
        instead of the figure. 
 
        Parameters 
        ---------- 
        parent : `~matplotlib.axes.Axes` 
            Axes to use for normalizing coordinates. 
 
        lbwh : iterable of four floats 
            The left edge, bottom edge, width, and height of the inset axes, in 
            units of the normalized coordinate of the *parent* axes. 
 
        See Also 
        -------- 
        :meth:`matplotlib.axes.Axes.set_axes_locator` 
 
        Examples 
        -------- 
        The following bounds the inset axes to a box with 20%% of the parent 
        axes height and 40%% of the width. The size of the axes specified 
        ([0, 0, 1, 1]) ensures that the axes completely fills the bounding box: 
 
        &gt;&gt;&gt; parent_axes = plt.gca() 
        &gt;&gt;&gt; ax_ins = plt.axes([0, 0, 1, 1]) 
        &gt;&gt;&gt; ip = InsetPosition(parent_axes, [0.5, 0.1, 0.4, 0.2]) 
        &gt;&gt;&gt; ax_ins.set_axes_locator(ip) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.parent = parent</span>
        <span class="s1">self.lbwh = lbwh</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">bbox_parent = self.parent.get_position(original=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">trans = BboxTransformTo(bbox_parent)</span>
        <span class="s1">bbox_inset = Bbox.from_bounds(*self.lbwh)</span>
        <span class="s1">bb = TransformedBbox(bbox_inset</span><span class="s2">, </span><span class="s1">trans)</span>
        <span class="s2">return </span><span class="s1">bb</span>


<span class="s2">class </span><span class="s1">AnchoredLocatorBase(AnchoredOffsetbox):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox_to_anchor</span><span class="s2">, </span><span class="s1">offsetbox</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span>
                 <span class="s1">borderpad=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">bbox_transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">pad=</span><span class="s3">0.</span><span class="s2">, </span><span class="s1">child=</span><span class="s2">None, </span><span class="s1">borderpad=borderpad</span><span class="s2">,</span>
            <span class="s1">bbox_to_anchor=bbox_to_anchor</span><span class="s2">, </span><span class="s1">bbox_transform=bbox_transform</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;No draw method should be called&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self.axes = ax</span>
        <span class="s1">bbox = self.get_window_extent(renderer)</span>
        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset(bbox.width</span><span class="s2">, </span><span class="s1">bbox.height</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">bbox_canvas = Bbox.from_bounds(px</span><span class="s2">, </span><span class="s1">py</span><span class="s2">, </span><span class="s1">bbox.width</span><span class="s2">, </span><span class="s1">bbox.height)</span>
        <span class="s1">tr = ax.figure.transSubfigure.inverted()</span>
        <span class="s2">return </span><span class="s1">TransformedBbox(bbox_canvas</span><span class="s2">, </span><span class="s1">tr)</span>


<span class="s2">class </span><span class="s1">AnchoredSizeLocator(AnchoredLocatorBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox_to_anchor</span><span class="s2">, </span><span class="s1">x_size</span><span class="s2">, </span><span class="s1">y_size</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span>
                 <span class="s1">borderpad=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">bbox_transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">bbox_to_anchor</span><span class="s2">, None, </span><span class="s1">loc</span><span class="s2">,</span>
            <span class="s1">borderpad=borderpad</span><span class="s2">, </span><span class="s1">bbox_transform=bbox_transform</span>
        <span class="s1">)</span>

        <span class="s1">self.x_size = Size.from_any(x_size)</span>
        <span class="s1">self.y_size = Size.from_any(y_size)</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">bbox = self.get_bbox_to_anchor()</span>
        <span class="s1">dpi = renderer.points_to_pixels(</span><span class="s3">72.</span><span class="s1">)</span>

        <span class="s1">r</span><span class="s2">, </span><span class="s1">a = self.x_size.get_size(renderer)</span>
        <span class="s1">width = bbox.width * r + a * dpi</span>
        <span class="s1">r</span><span class="s2">, </span><span class="s1">a = self.y_size.get_size(renderer)</span>
        <span class="s1">height = bbox.height * r + a * dpi</span>

        <span class="s1">fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())</span>
        <span class="s1">pad = self.pad * fontsize</span>

        <span class="s2">return </span><span class="s1">Bbox.from_bounds(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height).padded(pad)</span>


<span class="s2">class </span><span class="s1">AnchoredZoomLocator(AnchoredLocatorBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">parent_axes</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span>
                 <span class="s1">borderpad=</span><span class="s3">0.5</span><span class="s2">,</span>
                 <span class="s1">bbox_to_anchor=</span><span class="s2">None,</span>
                 <span class="s1">bbox_transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.parent_axes = parent_axes</span>
        <span class="s1">self.zoom = zoom</span>
        <span class="s2">if </span><span class="s1">bbox_to_anchor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bbox_to_anchor = parent_axes.bbox</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">bbox_to_anchor</span><span class="s2">, None, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">borderpad=borderpad</span><span class="s2">,</span>
            <span class="s1">bbox_transform=bbox_transform)</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">bb = self.parent_axes.transData.transform_bbox(self.axes.viewLim)</span>
        <span class="s1">fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())</span>
        <span class="s1">pad = self.pad * fontsize</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">Bbox.from_bounds(</span>
                <span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">abs(bb.width * self.zoom)</span><span class="s2">, </span><span class="s1">abs(bb.height * self.zoom))</span>
            <span class="s1">.padded(pad))</span>


<span class="s2">class </span><span class="s1">BboxPatch(Patch):</span>
    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Patch showing the shape bounded by a Bbox. 
 
        Parameters 
        ---------- 
        bbox : `~matplotlib.transforms.Bbox` 
            Bbox to use for the extents of this patch. 
 
        **kwargs 
            Patch properties. Valid arguments include: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;transform&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;transform should not be set&quot;</span><span class="s1">)</span>

        <span class="s1">kwargs[</span><span class="s4">&quot;transform&quot;</span><span class="s1">] = IdentityTransform()</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.bbox = bbox</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = self.bbox.extents</span>
        <span class="s2">return </span><span class="s1">Path._create_closed([(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y1)])</span>


<span class="s2">class </span><span class="s1">BboxConnector(Patch):</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">get_bbox_edge_pos(bbox</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ``(x, y)`` coordinates of corner *loc* of *bbox*; parameters 
        behave as documented for the `.BboxConnector` constructor. 
        &quot;&quot;&quot;</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = bbox.extents</span>
        <span class="s2">if </span><span class="s1">loc == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span>
        <span class="s2">elif </span><span class="s1">loc == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y1</span>
        <span class="s2">elif </span><span class="s1">loc == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span>
        <span class="s2">elif </span><span class="s1">loc == </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y0</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">connect_bbox(bbox1</span><span class="s2">, </span><span class="s1">bbox2</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">loc2=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a `.Path` connecting corner *loc1* of *bbox1* to corner 
        *loc2* of *bbox2*, where parameters behave as documented as for the 
        `.BboxConnector` constructor. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(bbox1</span><span class="s2">, </span><span class="s1">Rectangle):</span>
            <span class="s1">bbox1 = TransformedBbox(Bbox.unit()</span><span class="s2">, </span><span class="s1">bbox1.get_transform())</span>
        <span class="s2">if </span><span class="s1">isinstance(bbox2</span><span class="s2">, </span><span class="s1">Rectangle):</span>
            <span class="s1">bbox2 = TransformedBbox(Bbox.unit()</span><span class="s2">, </span><span class="s1">bbox2.get_transform())</span>
        <span class="s2">if </span><span class="s1">loc2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">loc2 = loc1</span>
        <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = BboxConnector.get_bbox_edge_pos(bbox1</span><span class="s2">, </span><span class="s1">loc1)</span>
        <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = BboxConnector.get_bbox_edge_pos(bbox2</span><span class="s2">, </span><span class="s1">loc2)</span>
        <span class="s2">return </span><span class="s1">Path([[x1</span><span class="s2">, </span><span class="s1">y1]</span><span class="s2">, </span><span class="s1">[x2</span><span class="s2">, </span><span class="s1">y2]])</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox1</span><span class="s2">, </span><span class="s1">bbox2</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">loc2=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Connect two bboxes with a straight line. 
 
        Parameters 
        ---------- 
        bbox1, bbox2 : `~matplotlib.transforms.Bbox` 
            Bounding boxes to connect. 
 
        loc1, loc2 : {1, 2, 3, 4} 
            Corner of *bbox1* and *bbox2* to draw the line. Valid values are:: 
 
                'upper right'  : 1, 
                'upper left'   : 2, 
                'lower left'   : 3, 
                'lower right'  : 4 
 
            *loc2* is optional and defaults to *loc1*. 
 
        **kwargs 
            Patch properties for the line drawn. Valid arguments include: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;transform&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;transform should not be set&quot;</span><span class="s1">)</span>

        <span class="s1">kwargs[</span><span class="s4">&quot;transform&quot;</span><span class="s1">] = IdentityTransform()</span>
        <span class="s2">if </span><span class="s4">'fill' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">super().__init__(**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fill = bool({</span><span class="s4">'fc'</span><span class="s2">, </span><span class="s4">'facecolor'</span><span class="s2">, </span><span class="s4">'color'</span><span class="s1">}.intersection(kwargs))</span>
            <span class="s1">super().__init__(fill=fill</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.bbox1 = bbox1</span>
        <span class="s1">self.bbox2 = bbox2</span>
        <span class="s1">self.loc1 = loc1</span>
        <span class="s1">self.loc2 = loc2</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">self.connect_bbox(self.bbox1</span><span class="s2">, </span><span class="s1">self.bbox2</span><span class="s2">,</span>
                                 <span class="s1">self.loc1</span><span class="s2">, </span><span class="s1">self.loc2)</span>


<span class="s2">class </span><span class="s1">BboxConnectorPatch(BboxConnector):</span>
    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox1</span><span class="s2">, </span><span class="s1">bbox2</span><span class="s2">, </span><span class="s1">loc1a</span><span class="s2">, </span><span class="s1">loc2a</span><span class="s2">, </span><span class="s1">loc1b</span><span class="s2">, </span><span class="s1">loc2b</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Connect two bboxes with a quadrilateral. 
 
        The quadrilateral is specified by two lines that start and end at 
        corners of the bboxes. The four sides of the quadrilateral are defined 
        by the two lines given, the line between the two corners specified in 
        *bbox1* and the line between the two corners specified in *bbox2*. 
 
        Parameters 
        ---------- 
        bbox1, bbox2 : `~matplotlib.transforms.Bbox` 
            Bounding boxes to connect. 
 
        loc1a, loc2a, loc1b, loc2b : {1, 2, 3, 4} 
            The first line connects corners *loc1a* of *bbox1* and *loc2a* of 
            *bbox2*; the second line connects corners *loc1b* of *bbox1* and 
            *loc2b* of *bbox2*.  Valid values are:: 
 
                'upper right'  : 1, 
                'upper left'   : 2, 
                'lower left'   : 3, 
                'lower right'  : 4 
 
        **kwargs 
            Patch properties for the line drawn: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">&quot;transform&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;transform should not be set&quot;</span><span class="s1">)</span>
        <span class="s1">super().__init__(bbox1</span><span class="s2">, </span><span class="s1">bbox2</span><span class="s2">, </span><span class="s1">loc1a</span><span class="s2">, </span><span class="s1">loc2a</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.loc1b = loc1b</span>
        <span class="s1">self.loc2b = loc2b</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">path1 = self.connect_bbox(self.bbox1</span><span class="s2">, </span><span class="s1">self.bbox2</span><span class="s2">, </span><span class="s1">self.loc1</span><span class="s2">, </span><span class="s1">self.loc2)</span>
        <span class="s1">path2 = self.connect_bbox(self.bbox2</span><span class="s2">, </span><span class="s1">self.bbox1</span><span class="s2">,</span>
                                  <span class="s1">self.loc2b</span><span class="s2">, </span><span class="s1">self.loc1b)</span>
        <span class="s1">path_merged = [*path1.vertices</span><span class="s2">, </span><span class="s1">*path2.vertices</span><span class="s2">, </span><span class="s1">path1.vertices[</span><span class="s3">0</span><span class="s1">]]</span>
        <span class="s2">return </span><span class="s1">Path(path_merged)</span>


<span class="s2">def </span><span class="s1">_add_inset_axes(parent_axes</span><span class="s2">, </span><span class="s1">inset_axes):</span>
    <span class="s0">&quot;&quot;&quot;Helper function to add an inset axes and disable navigation in it.&quot;&quot;&quot;</span>
    <span class="s1">parent_axes.figure.add_axes(inset_axes)</span>
    <span class="s1">inset_axes.set_navigate(</span><span class="s2">False</span><span class="s1">)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">inset_axes(parent_axes</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">'upper right'</span><span class="s2">,</span>
               <span class="s1">bbox_to_anchor=</span><span class="s2">None, </span><span class="s1">bbox_transform=</span><span class="s2">None,</span>
               <span class="s1">axes_class=</span><span class="s2">None, </span><span class="s1">axes_kwargs=</span><span class="s2">None,</span>
               <span class="s1">borderpad=</span><span class="s3">0.5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an inset axes with a given width and height. 
 
    Both sizes used can be specified either in inches or percentage. 
    For example,:: 
 
        inset_axes(parent_axes, width='40%%', height='30%%', loc='lower left') 
 
    creates in inset axes in the lower left corner of *parent_axes* which spans 
    over 30%% in height and 40%% in width of the *parent_axes*. Since the usage 
    of `.inset_axes` may become slightly tricky when exceeding such standard 
    cases, it is recommended to read :doc:`the examples 
    &lt;/gallery/axes_grid1/inset_locator_demo&gt;`. 
 
    Notes 
    ----- 
    The meaning of *bbox_to_anchor* and *bbox_to_transform* is interpreted 
    differently from that of legend. The value of bbox_to_anchor 
    (or the return value of its get_points method; the default is 
    *parent_axes.bbox*) is transformed by the bbox_transform (the default 
    is Identity transform) and then interpreted as points in the pixel 
    coordinate (which is dpi dependent). 
 
    Thus, following three calls are identical and creates an inset axes 
    with respect to the *parent_axes*:: 
 
       axins = inset_axes(parent_axes, &quot;30%%&quot;, &quot;40%%&quot;) 
       axins = inset_axes(parent_axes, &quot;30%%&quot;, &quot;40%%&quot;, 
                          bbox_to_anchor=parent_axes.bbox) 
       axins = inset_axes(parent_axes, &quot;30%%&quot;, &quot;40%%&quot;, 
                          bbox_to_anchor=(0, 0, 1, 1), 
                          bbox_transform=parent_axes.transAxes) 
 
    Parameters 
    ---------- 
    parent_axes : `matplotlib.axes.Axes` 
        Axes to place the inset axes. 
 
    width, height : float or str 
        Size of the inset axes to create. If a float is provided, it is 
        the size in inches, e.g. *width=1.3*. If a string is provided, it is 
        the size in relative units, e.g. *width='40%%'*. By default, i.e. if 
        neither *bbox_to_anchor* nor *bbox_transform* are specified, those 
        are relative to the parent_axes. Otherwise, they are to be understood 
        relative to the bounding box provided via *bbox_to_anchor*. 
 
    loc : str, default: 'upper right' 
        Location to place the inset axes.  Valid locations are 
        'upper left', 'upper center', 'upper right', 
        'center left', 'center', 'center right', 
        'lower left', 'lower center', 'lower right'. 
        For backward compatibility, numeric values are accepted as well. 
        See the parameter *loc* of `.Legend` for details. 
 
    bbox_to_anchor : tuple or `~matplotlib.transforms.BboxBase`, optional 
        Bbox that the inset axes will be anchored to. If None, 
        a tuple of (0, 0, 1, 1) is used if *bbox_transform* is set 
        to *parent_axes.transAxes* or *parent_axes.figure.transFigure*. 
        Otherwise, *parent_axes.bbox* is used. If a tuple, can be either 
        [left, bottom, width, height], or [left, bottom]. 
        If the kwargs *width* and/or *height* are specified in relative units, 
        the 2-tuple [left, bottom] cannot be used. Note that, 
        unless *bbox_transform* is set, the units of the bounding box 
        are interpreted in the pixel coordinate. When using *bbox_to_anchor* 
        with tuple, it almost always makes sense to also specify 
        a *bbox_transform*. This might often be the axes transform 
        *parent_axes.transAxes*. 
 
    bbox_transform : `~matplotlib.transforms.Transform`, optional 
        Transformation for the bbox that contains the inset axes. 
        If None, a `.transforms.IdentityTransform` is used. The value 
        of *bbox_to_anchor* (or the return value of its get_points method) 
        is transformed by the *bbox_transform* and then interpreted 
        as points in the pixel coordinate (which is dpi dependent). 
        You may provide *bbox_to_anchor* in some normalized coordinate, 
        and give an appropriate transform (e.g., *parent_axes.transAxes*). 
 
    axes_class : `~matplotlib.axes.Axes` type, default: `.HostAxes` 
        The type of the newly created inset axes. 
 
    axes_kwargs : dict, optional 
        Keyword arguments to pass to the constructor of the inset axes. 
        Valid arguments include: 
 
        %(Axes:kwdoc)s 
 
    borderpad : float, default: 0.5 
        Padding between inset axes and the bbox_to_anchor. 
        The units are axes font size, i.e. for a default font size of 10 points 
        *borderpad = 0.5* is equivalent to a padding of 5 points. 
 
    Returns 
    ------- 
    inset_axes : *axes_class* 
        Inset axes object created. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">axes_class </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axes_class = HostAxes</span>
    <span class="s2">if </span><span class="s1">axes_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axes_kwargs = {}</span>
    <span class="s1">inset_axes = axes_class(parent_axes.figure</span><span class="s2">, </span><span class="s1">parent_axes.get_position()</span><span class="s2">,</span>
                            <span class="s1">**axes_kwargs)</span>

    <span class="s2">if </span><span class="s1">bbox_transform </span><span class="s2">in </span><span class="s1">[parent_axes.transAxes</span><span class="s2">,</span>
                          <span class="s1">parent_axes.figure.transFigure]:</span>
        <span class="s2">if </span><span class="s1">bbox_to_anchor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">_api.warn_external(</span><span class="s4">&quot;Using the axes or figure transform requires a &quot;</span>
                               <span class="s4">&quot;bounding box in the respective coordinates. &quot;</span>
                               <span class="s4">&quot;Using bbox_to_anchor=(0, 0, 1, 1) now.&quot;</span><span class="s1">)</span>
            <span class="s1">bbox_to_anchor = (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">bbox_to_anchor </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">bbox_to_anchor = parent_axes.bbox</span>

    <span class="s2">if </span><span class="s1">(isinstance(bbox_to_anchor</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and</span>
            <span class="s1">(isinstance(width</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">isinstance(height</span><span class="s2">, </span><span class="s1">str))):</span>
        <span class="s2">if </span><span class="s1">len(bbox_to_anchor) != </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Using relative units for width or height &quot;</span>
                             <span class="s4">&quot;requires to provide a 4-tuple or a &quot;</span>
                             <span class="s4">&quot;`Bbox` instance to `bbox_to_anchor.&quot;</span><span class="s1">)</span>

    <span class="s1">axes_locator = AnchoredSizeLocator(bbox_to_anchor</span><span class="s2">,</span>
                                       <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">,</span>
                                       <span class="s1">loc=loc</span><span class="s2">,</span>
                                       <span class="s1">bbox_transform=bbox_transform</span><span class="s2">,</span>
                                       <span class="s1">borderpad=borderpad)</span>

    <span class="s1">inset_axes.set_axes_locator(axes_locator)</span>

    <span class="s1">_add_inset_axes(parent_axes</span><span class="s2">, </span><span class="s1">inset_axes)</span>

    <span class="s2">return </span><span class="s1">inset_axes</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">zoomed_inset_axes(parent_axes</span><span class="s2">, </span><span class="s1">zoom</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">'upper right'</span><span class="s2">,</span>
                      <span class="s1">bbox_to_anchor=</span><span class="s2">None, </span><span class="s1">bbox_transform=</span><span class="s2">None,</span>
                      <span class="s1">axes_class=</span><span class="s2">None, </span><span class="s1">axes_kwargs=</span><span class="s2">None,</span>
                      <span class="s1">borderpad=</span><span class="s3">0.5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an anchored inset axes by scaling a parent axes. For usage, also see 
    :doc:`the examples &lt;/gallery/axes_grid1/inset_locator_demo2&gt;`. 
 
    Parameters 
    ---------- 
    parent_axes : `~matplotlib.axes.Axes` 
        Axes to place the inset axes. 
 
    zoom : float 
        Scaling factor of the data axes. *zoom* &gt; 1 will enlarge the 
        coordinates (i.e., &quot;zoomed in&quot;), while *zoom* &lt; 1 will shrink the 
        coordinates (i.e., &quot;zoomed out&quot;). 
 
    loc : str, default: 'upper right' 
        Location to place the inset axes.  Valid locations are 
        'upper left', 'upper center', 'upper right', 
        'center left', 'center', 'center right', 
        'lower left', 'lower center', 'lower right'. 
        For backward compatibility, numeric values are accepted as well. 
        See the parameter *loc* of `.Legend` for details. 
 
    bbox_to_anchor : tuple or `~matplotlib.transforms.BboxBase`, optional 
        Bbox that the inset axes will be anchored to. If None, 
        *parent_axes.bbox* is used. If a tuple, can be either 
        [left, bottom, width, height], or [left, bottom]. 
        If the kwargs *width* and/or *height* are specified in relative units, 
        the 2-tuple [left, bottom] cannot be used. Note that 
        the units of the bounding box are determined through the transform 
        in use. When using *bbox_to_anchor* it almost always makes sense to 
        also specify a *bbox_transform*. This might often be the axes transform 
        *parent_axes.transAxes*. 
 
    bbox_transform : `~matplotlib.transforms.Transform`, optional 
        Transformation for the bbox that contains the inset axes. 
        If None, a `.transforms.IdentityTransform` is used (i.e. pixel 
        coordinates). This is useful when not providing any argument to 
        *bbox_to_anchor*. When using *bbox_to_anchor* it almost always makes 
        sense to also specify a *bbox_transform*. This might often be the 
        axes transform *parent_axes.transAxes*. Inversely, when specifying 
        the axes- or figure-transform here, be aware that not specifying 
        *bbox_to_anchor* will use *parent_axes.bbox*, the units of which are 
        in display (pixel) coordinates. 
 
    axes_class : `~matplotlib.axes.Axes` type, default: `.HostAxes` 
        The type of the newly created inset axes. 
 
    axes_kwargs : dict, optional 
        Keyword arguments to pass to the constructor of the inset axes. 
        Valid arguments include: 
 
        %(Axes:kwdoc)s 
 
    borderpad : float, default: 0.5 
        Padding between inset axes and the bbox_to_anchor. 
        The units are axes font size, i.e. for a default font size of 10 points 
        *borderpad = 0.5* is equivalent to a padding of 5 points. 
 
    Returns 
    ------- 
    inset_axes : *axes_class* 
        Inset axes object created. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">axes_class </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axes_class = HostAxes</span>
    <span class="s2">if </span><span class="s1">axes_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">axes_kwargs = {}</span>
    <span class="s1">inset_axes = axes_class(parent_axes.figure</span><span class="s2">, </span><span class="s1">parent_axes.get_position()</span><span class="s2">,</span>
                            <span class="s1">**axes_kwargs)</span>

    <span class="s1">axes_locator = AnchoredZoomLocator(parent_axes</span><span class="s2">, </span><span class="s1">zoom=zoom</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">,</span>
                                       <span class="s1">bbox_to_anchor=bbox_to_anchor</span><span class="s2">,</span>
                                       <span class="s1">bbox_transform=bbox_transform</span><span class="s2">,</span>
                                       <span class="s1">borderpad=borderpad)</span>
    <span class="s1">inset_axes.set_axes_locator(axes_locator)</span>

    <span class="s1">_add_inset_axes(parent_axes</span><span class="s2">, </span><span class="s1">inset_axes)</span>

    <span class="s2">return </span><span class="s1">inset_axes</span>


<span class="s2">class </span><span class="s1">_TransformedBboxWithCallback(TransformedBbox):</span>
    <span class="s0">&quot;&quot;&quot; 
    Variant of `.TransformBbox` which calls *callback* before returning points. 
 
    Used by `.mark_inset` to unstale the parent axes' viewlim as needed. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._callback = callback</span>

    <span class="s2">def </span><span class="s1">get_points(self):</span>
        <span class="s1">self._callback()</span>
        <span class="s2">return </span><span class="s1">super().get_points()</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">mark_inset(parent_axes</span><span class="s2">, </span><span class="s1">inset_axes</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Draw a box to mark the location of an area represented by an inset axes. 
 
    This function draws a box in *parent_axes* at the bounding box of 
    *inset_axes*, and shows a connection with the inset axes by drawing lines 
    at the corners, giving a &quot;zoomed in&quot; effect. 
 
    Parameters 
    ---------- 
    parent_axes : `~matplotlib.axes.Axes` 
        Axes which contains the area of the inset axes. 
 
    inset_axes : `~matplotlib.axes.Axes` 
        The inset axes. 
 
    loc1, loc2 : {1, 2, 3, 4} 
        Corners to use for connecting the inset axes and the area in the 
        parent axes. 
 
    **kwargs 
        Patch properties for the lines and box drawn: 
 
        %(Patch:kwdoc)s 
 
    Returns 
    ------- 
    pp : `~matplotlib.patches.Patch` 
        The patch drawn to represent the area of the inset axes. 
 
    p1, p2 : `~matplotlib.patches.Patch` 
        The patches connecting two corners of the inset axes and its area. 
    &quot;&quot;&quot;</span>
    <span class="s1">rect = _TransformedBboxWithCallback(</span>
        <span class="s1">inset_axes.viewLim</span><span class="s2">, </span><span class="s1">parent_axes.transData</span><span class="s2">,</span>
        <span class="s1">callback=parent_axes._unstale_viewLim)</span>

    <span class="s2">if </span><span class="s4">'fill' </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">pp = BboxPatch(rect</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">fill = bool({</span><span class="s4">'fc'</span><span class="s2">, </span><span class="s4">'facecolor'</span><span class="s2">, </span><span class="s4">'color'</span><span class="s1">}.intersection(kwargs))</span>
        <span class="s1">pp = BboxPatch(rect</span><span class="s2">, </span><span class="s1">fill=fill</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">parent_axes.add_patch(pp)</span>

    <span class="s1">p1 = BboxConnector(inset_axes.bbox</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">loc1=loc1</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">inset_axes.add_patch(p1)</span>
    <span class="s1">p1.set_clip_on(</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">p2 = BboxConnector(inset_axes.bbox</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">loc1=loc2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">inset_axes.add_patch(p2)</span>
    <span class="s1">p2.set_clip_on(</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">pp</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span>
</pre>
</body>
</html>