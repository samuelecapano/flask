<html>
<head>
<title>angle_helper.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
angle_helper.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">math</span>

<span class="s0">from </span><span class="s1">mpl_toolkits.axisartist.grid_finder </span><span class="s0">import </span><span class="s1">ExtremeFinderSimple</span>


<span class="s0">def </span><span class="s1">select_step_degree(dv):</span>

    <span class="s1">degree_limits_ = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">40</span><span class="s0">, </span><span class="s2">70</span><span class="s0">, </span><span class="s2">120</span><span class="s0">, </span><span class="s2">270</span><span class="s0">, </span><span class="s2">520</span><span class="s1">]</span>
    <span class="s1">degree_steps_  = [</span><span class="s2">1</span><span class="s0">,   </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">30</span><span class="s0">, </span><span class="s2">45</span><span class="s0">,  </span><span class="s2">90</span><span class="s0">, </span><span class="s2">180</span><span class="s0">, </span><span class="s2">360</span><span class="s1">]</span>
    <span class="s1">degree_factors = [</span><span class="s2">1.</span><span class="s1">] * len(degree_steps_)</span>

    <span class="s1">minsec_limits_ = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">3.5</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">45</span><span class="s1">]</span>
    <span class="s1">minsec_steps_  = [</span><span class="s2">1</span><span class="s0">,   </span><span class="s2">2</span><span class="s0">,   </span><span class="s2">3</span><span class="s0">,   </span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]</span>

    <span class="s1">minute_limits_ = np.array(minsec_limits_) / </span><span class="s2">60</span>
    <span class="s1">minute_factors = [</span><span class="s2">60.</span><span class="s1">] * len(minute_limits_)</span>

    <span class="s1">second_limits_ = np.array(minsec_limits_) / </span><span class="s2">3600</span>
    <span class="s1">second_factors = [</span><span class="s2">3600.</span><span class="s1">] * len(second_limits_)</span>

    <span class="s1">degree_limits = [*second_limits_</span><span class="s0">, </span><span class="s1">*minute_limits_</span><span class="s0">, </span><span class="s1">*degree_limits_]</span>
    <span class="s1">degree_steps = [*minsec_steps_</span><span class="s0">, </span><span class="s1">*minsec_steps_</span><span class="s0">, </span><span class="s1">*degree_steps_]</span>
    <span class="s1">degree_factors = [*second_factors</span><span class="s0">, </span><span class="s1">*minute_factors</span><span class="s0">, </span><span class="s1">*degree_factors]</span>

    <span class="s1">n = np.searchsorted(degree_limits</span><span class="s0">, </span><span class="s1">dv)</span>
    <span class="s1">step = degree_steps[n]</span>
    <span class="s1">factor = degree_factors[n]</span>

    <span class="s0">return </span><span class="s1">step</span><span class="s0">, </span><span class="s1">factor</span>


<span class="s0">def </span><span class="s1">select_step_hour(dv):</span>

    <span class="s1">hour_limits_ = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">3.5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">21</span><span class="s0">, </span><span class="s2">36</span><span class="s1">]</span>
    <span class="s1">hour_steps_  = [</span><span class="s2">1</span><span class="s0">,   </span><span class="s2">2</span><span class="s0">,   </span><span class="s2">3</span><span class="s0">,   </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">,  </span><span class="s2">8</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">24</span><span class="s1">]</span>
    <span class="s1">hour_factors = [</span><span class="s2">1.</span><span class="s1">] * len(hour_steps_)</span>

    <span class="s1">minsec_limits_ = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">3.5</span><span class="s0">, </span><span class="s2">4.5</span><span class="s0">, </span><span class="s2">5.5</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">25</span><span class="s0">, </span><span class="s2">45</span><span class="s1">]</span>
    <span class="s1">minsec_steps_  = [</span><span class="s2">1</span><span class="s0">,   </span><span class="s2">2</span><span class="s0">,   </span><span class="s2">3</span><span class="s0">,   </span><span class="s2">4</span><span class="s0">,   </span><span class="s2">5</span><span class="s0">,   </span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]</span>

    <span class="s1">minute_limits_ = np.array(minsec_limits_) / </span><span class="s2">60</span>
    <span class="s1">minute_factors = [</span><span class="s2">60.</span><span class="s1">] * len(minute_limits_)</span>

    <span class="s1">second_limits_ = np.array(minsec_limits_) / </span><span class="s2">3600</span>
    <span class="s1">second_factors = [</span><span class="s2">3600.</span><span class="s1">] * len(second_limits_)</span>

    <span class="s1">hour_limits = [*second_limits_</span><span class="s0">, </span><span class="s1">*minute_limits_</span><span class="s0">, </span><span class="s1">*hour_limits_]</span>
    <span class="s1">hour_steps = [*minsec_steps_</span><span class="s0">, </span><span class="s1">*minsec_steps_</span><span class="s0">, </span><span class="s1">*hour_steps_]</span>
    <span class="s1">hour_factors = [*second_factors</span><span class="s0">, </span><span class="s1">*minute_factors</span><span class="s0">, </span><span class="s1">*hour_factors]</span>

    <span class="s1">n = np.searchsorted(hour_limits</span><span class="s0">, </span><span class="s1">dv)</span>
    <span class="s1">step = hour_steps[n]</span>
    <span class="s1">factor = hour_factors[n]</span>

    <span class="s0">return </span><span class="s1">step</span><span class="s0">, </span><span class="s1">factor</span>


<span class="s0">def </span><span class="s1">select_step_sub(dv):</span>

    <span class="s3"># subarcsec or degree</span>
    <span class="s1">tmp = </span><span class="s2">10.</span><span class="s1">**(int(math.log10(dv))-</span><span class="s2">1.</span><span class="s1">)</span>

    <span class="s1">factor = </span><span class="s2">1.</span><span class="s1">/tmp</span>

    <span class="s0">if </span><span class="s2">1.5</span><span class="s1">*tmp &gt;= dv:</span>
        <span class="s1">step = </span><span class="s2">1</span>
    <span class="s0">elif </span><span class="s2">3.</span><span class="s1">*tmp &gt;= dv:</span>
        <span class="s1">step = </span><span class="s2">2</span>
    <span class="s0">elif </span><span class="s2">7.</span><span class="s1">*tmp &gt;= dv:</span>
        <span class="s1">step = </span><span class="s2">5</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">step = </span><span class="s2">1</span>
        <span class="s1">factor = </span><span class="s2">0.1</span><span class="s1">*factor</span>

    <span class="s0">return </span><span class="s1">step</span><span class="s0">, </span><span class="s1">factor</span>


<span class="s0">def </span><span class="s1">select_step(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s1">hour=</span><span class="s0">False, </span><span class="s1">include_last=</span><span class="s0">True,</span>
                <span class="s1">threshold_factor=</span><span class="s2">3600.</span><span class="s1">):</span>

    <span class="s0">if </span><span class="s1">v1 &gt; v2:</span>
        <span class="s1">v1</span><span class="s0">, </span><span class="s1">v2 = v2</span><span class="s0">, </span><span class="s1">v1</span>

    <span class="s1">dv = (v2 - v1) / nv</span>

    <span class="s0">if </span><span class="s1">hour:</span>
        <span class="s1">_select_step = select_step_hour</span>
        <span class="s1">cycle = </span><span class="s2">24.</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">_select_step = select_step_degree</span>
        <span class="s1">cycle = </span><span class="s2">360.</span>

    <span class="s3"># for degree</span>
    <span class="s0">if </span><span class="s1">dv &gt; </span><span class="s2">1 </span><span class="s1">/ threshold_factor:</span>
        <span class="s1">step</span><span class="s0">, </span><span class="s1">factor = _select_step(dv)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">step</span><span class="s0">, </span><span class="s1">factor = select_step_sub(dv*threshold_factor)</span>

        <span class="s1">factor = factor * threshold_factor</span>

    <span class="s1">levs = np.arange(np.floor(v1 * factor / step)</span><span class="s0">,</span>
                     <span class="s1">np.ceil(v2 * factor / step) + </span><span class="s2">0.5</span><span class="s0">,</span>
                     <span class="s1">dtype=int) * step</span>

    <span class="s3"># n : number of valid levels. If there is a cycle, e.g., [0, 90, 180,</span>
    <span class="s3"># 270, 360], the grid line needs to be extended from 0 to 360, so</span>
    <span class="s3"># we need to return the whole array. However, the last level (360)</span>
    <span class="s3"># needs to be ignored often. In this case, so we return n=4.</span>

    <span class="s1">n = len(levs)</span>

    <span class="s3"># we need to check the range of values</span>
    <span class="s3"># for example, -90 to 90, 0 to 360,</span>

    <span class="s0">if </span><span class="s1">factor == </span><span class="s2">1. </span><span class="s0">and </span><span class="s1">levs[-</span><span class="s2">1</span><span class="s1">] &gt;= levs[</span><span class="s2">0</span><span class="s1">] + cycle:  </span><span class="s3"># check for cycle</span>
        <span class="s1">nv = int(cycle / step)</span>
        <span class="s0">if </span><span class="s1">include_last:</span>
            <span class="s1">levs = levs[</span><span class="s2">0</span><span class="s1">] + np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">nv+</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) * step</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">levs = levs[</span><span class="s2">0</span><span class="s1">] + np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) * step</span>

        <span class="s1">n = len(levs)</span>

    <span class="s0">return </span><span class="s1">np.array(levs)</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">factor</span>


<span class="s0">def </span><span class="s1">select_step24(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s1">include_last=</span><span class="s0">True, </span><span class="s1">threshold_factor=</span><span class="s2">3600</span><span class="s1">):</span>
    <span class="s1">v1</span><span class="s0">, </span><span class="s1">v2 = v1 / </span><span class="s2">15</span><span class="s0">, </span><span class="s1">v2 / </span><span class="s2">15</span>
    <span class="s1">levs</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">factor = select_step(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s1">hour=</span><span class="s0">True,</span>
                                  <span class="s1">include_last=include_last</span><span class="s0">,</span>
                                  <span class="s1">threshold_factor=threshold_factor)</span>
    <span class="s0">return </span><span class="s1">levs * </span><span class="s2">15</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">factor</span>


<span class="s0">def </span><span class="s1">select_step360(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s1">include_last=</span><span class="s0">True, </span><span class="s1">threshold_factor=</span><span class="s2">3600</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">select_step(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">nv</span><span class="s0">, </span><span class="s1">hour=</span><span class="s0">False,</span>
                       <span class="s1">include_last=include_last</span><span class="s0">,</span>
                       <span class="s1">threshold_factor=threshold_factor)</span>


<span class="s0">class </span><span class="s1">LocatorBase:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">nbins</span><span class="s0">, </span><span class="s1">include_last=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">self.nbins = nbins</span>
        <span class="s1">self._include_last = include_last</span>

    <span class="s0">def </span><span class="s1">set_params(self</span><span class="s0">, </span><span class="s1">nbins=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">nbins </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.nbins = int(nbins)</span>


<span class="s0">class </span><span class="s1">LocatorHMS(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step24(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last)</span>


<span class="s0">class </span><span class="s1">LocatorHM(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step24(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last</span><span class="s0">,</span>
                             <span class="s1">threshold_factor=</span><span class="s2">60</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">LocatorH(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step24(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last</span><span class="s0">,</span>
                             <span class="s1">threshold_factor=</span><span class="s2">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">LocatorDMS(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step360(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last)</span>


<span class="s0">class </span><span class="s1">LocatorDM(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step360(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last</span><span class="s0">,</span>
                              <span class="s1">threshold_factor=</span><span class="s2">60</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">LocatorD(LocatorBase):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">v2):</span>
        <span class="s0">return </span><span class="s1">select_step360(v1</span><span class="s0">, </span><span class="s1">v2</span><span class="s0">, </span><span class="s1">self.nbins</span><span class="s0">, </span><span class="s1">self._include_last</span><span class="s0">,</span>
                              <span class="s1">threshold_factor=</span><span class="s2">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">FormatterDMS:</span>
    <span class="s1">deg_mark = </span><span class="s4">r&quot;^{\circ}&quot;</span>
    <span class="s1">min_mark = </span><span class="s4">r&quot;^{\prime}&quot;</span>
    <span class="s1">sec_mark = </span><span class="s4">r&quot;^{\prime\prime}&quot;</span>

    <span class="s1">fmt_d = </span><span class="s4">&quot;$%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_ds = </span><span class="s4">r&quot;$%d.%s&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">&quot;$&quot;</span>

    <span class="s3"># %s for sign</span>
    <span class="s1">fmt_d_m = </span><span class="s4">r&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d&quot; </span><span class="s1">+ min_mark + </span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_d_ms = </span><span class="s4">r&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d.%s&quot; </span><span class="s1">+ min_mark + </span><span class="s4">&quot;$&quot;</span>

    <span class="s1">fmt_d_m_partial = </span><span class="s4">&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d&quot; </span><span class="s1">+ min_mark + </span><span class="s4">r&quot;\,&quot;</span>
    <span class="s1">fmt_s_partial = </span><span class="s4">&quot;%02d&quot; </span><span class="s1">+ sec_mark + </span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_ss_partial = </span><span class="s4">&quot;%02d.%s&quot; </span><span class="s1">+ sec_mark + </span><span class="s4">&quot;$&quot;</span>

    <span class="s0">def </span><span class="s1">_get_number_fraction(self</span><span class="s0">, </span><span class="s1">factor):</span>
        <span class="s3">## check for fractional numbers</span>
        <span class="s1">number_fraction = </span><span class="s0">None</span>
        <span class="s3"># check for 60</span>

        <span class="s0">for </span><span class="s1">threshold </span><span class="s0">in </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">60</span><span class="s0">, </span><span class="s2">3600</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">factor &lt;= threshold:</span>
                <span class="s0">break</span>

            <span class="s1">d = factor // threshold</span>
            <span class="s1">int_log_d = int(np.floor(np.log10(d)))</span>
            <span class="s0">if </span><span class="s2">10</span><span class="s1">**int_log_d == d </span><span class="s0">and </span><span class="s1">d != </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">number_fraction = int_log_d</span>
                <span class="s1">factor = factor // </span><span class="s2">10</span><span class="s1">**int_log_d</span>
                <span class="s0">return </span><span class="s1">factor</span><span class="s0">, </span><span class="s1">number_fraction</span>

        <span class="s0">return </span><span class="s1">factor</span><span class="s0">, </span><span class="s1">number_fraction</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">direction</span><span class="s0">, </span><span class="s1">factor</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s0">if </span><span class="s1">len(values) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[]</span>

        <span class="s1">ss = np.sign(values)</span>
        <span class="s1">signs = [</span><span class="s4">&quot;-&quot; </span><span class="s0">if </span><span class="s1">v &lt; </span><span class="s2">0 </span><span class="s0">else </span><span class="s4">&quot;&quot; </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">values]</span>

        <span class="s1">factor</span><span class="s0">, </span><span class="s1">number_fraction = self._get_number_fraction(factor)</span>

        <span class="s1">values = np.abs(values)</span>

        <span class="s0">if </span><span class="s1">number_fraction </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">values</span><span class="s0">, </span><span class="s1">frac_part = divmod(values</span><span class="s0">, </span><span class="s2">10 </span><span class="s1">** number_fraction)</span>
            <span class="s1">frac_fmt = </span><span class="s4">&quot;%%0%dd&quot; </span><span class="s1">% (number_fraction</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">frac_str = [frac_fmt % (f1</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">f1 </span><span class="s0">in </span><span class="s1">frac_part]</span>

        <span class="s0">if </span><span class="s1">factor == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">number_fraction </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[self.fmt_d % (s * int(v)</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip(ss</span><span class="s0">, </span><span class="s1">values)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[self.fmt_ds % (s * int(v)</span><span class="s0">, </span><span class="s1">f1)</span>
                        <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">f1 </span><span class="s0">in </span><span class="s1">zip(ss</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">frac_str)]</span>
        <span class="s0">elif </span><span class="s1">factor == </span><span class="s2">60</span><span class="s1">:</span>
            <span class="s1">deg_part</span><span class="s0">, </span><span class="s1">min_part = divmod(values</span><span class="s0">, </span><span class="s2">60</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">number_fraction </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[self.fmt_d_m % (s1</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1)</span>
                        <span class="s0">for </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1 </span><span class="s0">in </span><span class="s1">zip(signs</span><span class="s0">, </span><span class="s1">deg_part</span><span class="s0">, </span><span class="s1">min_part)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">[self.fmt_d_ms % (s</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1</span><span class="s0">, </span><span class="s1">f1)</span>
                        <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1</span><span class="s0">, </span><span class="s1">f1</span>
                        <span class="s0">in </span><span class="s1">zip(signs</span><span class="s0">, </span><span class="s1">deg_part</span><span class="s0">, </span><span class="s1">min_part</span><span class="s0">, </span><span class="s1">frac_str)]</span>

        <span class="s0">elif </span><span class="s1">factor == </span><span class="s2">3600</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">ss[-</span><span class="s2">1</span><span class="s1">] == -</span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">inverse_order = </span><span class="s0">True</span>
                <span class="s1">values = values[::-</span><span class="s2">1</span><span class="s1">]</span>
                <span class="s1">signs = signs[::-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">inverse_order = </span><span class="s0">False</span>

            <span class="s1">l_hm_old = </span><span class="s4">&quot;&quot;</span>
            <span class="s1">r = []</span>

            <span class="s1">deg_part</span><span class="s0">, </span><span class="s1">min_part_ = divmod(values</span><span class="s0">, </span><span class="s2">3600</span><span class="s1">)</span>
            <span class="s1">min_part</span><span class="s0">, </span><span class="s1">sec_part = divmod(min_part_</span><span class="s0">, </span><span class="s2">60</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">number_fraction </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">sec_str = [self.fmt_s_partial % (s1</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">s1 </span><span class="s0">in </span><span class="s1">sec_part]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">sec_str = [self.fmt_ss_partial % (s1</span><span class="s0">, </span><span class="s1">f1)</span>
                           <span class="s0">for </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">f1 </span><span class="s0">in </span><span class="s1">zip(sec_part</span><span class="s0">, </span><span class="s1">frac_str)]</span>

            <span class="s0">for </span><span class="s1">s</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1</span><span class="s0">, </span><span class="s1">s1 </span><span class="s0">in </span><span class="s1">zip(signs</span><span class="s0">, </span><span class="s1">deg_part</span><span class="s0">, </span><span class="s1">min_part</span><span class="s0">, </span><span class="s1">sec_str):</span>
                <span class="s1">l_hm = self.fmt_d_m_partial % (s</span><span class="s0">, </span><span class="s1">d1</span><span class="s0">, </span><span class="s1">m1)</span>
                <span class="s0">if </span><span class="s1">l_hm != l_hm_old:</span>
                    <span class="s1">l_hm_old = l_hm</span>
                    <span class="s1">l = l_hm + s1</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">l = </span><span class="s4">&quot;$&quot; </span><span class="s1">+ s + s1</span>
                <span class="s1">r.append(l)</span>

            <span class="s0">if </span><span class="s1">inverse_order:</span>
                <span class="s0">return </span><span class="s1">r[::-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">r</span>

        <span class="s0">else</span><span class="s1">:  </span><span class="s3"># factor &gt; 3600.</span>
            <span class="s0">return </span><span class="s1">[</span><span class="s4">r&quot;$%s^{\circ}$&quot; </span><span class="s1">% v </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">ss*values]</span>


<span class="s0">class </span><span class="s1">FormatterHMS(FormatterDMS):</span>
    <span class="s1">deg_mark = </span><span class="s4">r&quot;^\mathrm{h}&quot;</span>
    <span class="s1">min_mark = </span><span class="s4">r&quot;^\mathrm{m}&quot;</span>
    <span class="s1">sec_mark = </span><span class="s4">r&quot;^\mathrm{s}&quot;</span>

    <span class="s1">fmt_d = </span><span class="s4">&quot;$%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_ds = </span><span class="s4">r&quot;$%d.%s&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">&quot;$&quot;</span>

    <span class="s3"># %s for sign</span>
    <span class="s1">fmt_d_m = </span><span class="s4">r&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d&quot; </span><span class="s1">+ min_mark+</span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_d_ms = </span><span class="s4">r&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d.%s&quot; </span><span class="s1">+ min_mark+</span><span class="s4">&quot;$&quot;</span>

    <span class="s1">fmt_d_m_partial = </span><span class="s4">&quot;$%s%d&quot; </span><span class="s1">+ deg_mark + </span><span class="s4">r&quot;\,%02d&quot; </span><span class="s1">+ min_mark + </span><span class="s4">r&quot;\,&quot;</span>
    <span class="s1">fmt_s_partial = </span><span class="s4">&quot;%02d&quot; </span><span class="s1">+ sec_mark + </span><span class="s4">&quot;$&quot;</span>
    <span class="s1">fmt_ss_partial = </span><span class="s4">&quot;%02d.%s&quot; </span><span class="s1">+ sec_mark + </span><span class="s4">&quot;$&quot;</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">direction</span><span class="s0">, </span><span class="s1">factor</span><span class="s0">, </span><span class="s1">values):  </span><span class="s3"># hour</span>
        <span class="s0">return </span><span class="s1">super().__call__(direction</span><span class="s0">, </span><span class="s1">factor</span><span class="s0">, </span><span class="s1">np.asarray(values) / </span><span class="s2">15</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">ExtremeFinderCycle(ExtremeFinderSimple):</span>
    <span class="s3"># docstring inherited</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">nx</span><span class="s0">, </span><span class="s1">ny</span><span class="s0">,</span>
                 <span class="s1">lon_cycle=</span><span class="s2">360.</span><span class="s0">, </span><span class="s1">lat_cycle=</span><span class="s0">None,</span>
                 <span class="s1">lon_minmax=</span><span class="s0">None, </span><span class="s1">lat_minmax=(-</span><span class="s2">90</span><span class="s0">, </span><span class="s2">90</span><span class="s1">)):</span>
        <span class="s5">&quot;&quot;&quot; 
        This subclass handles the case where one or both coordinates should be 
        taken modulo 360, or be restricted to not exceed a specific range. 
 
        Parameters 
        ---------- 
        nx, ny : int 
            The number of samples in each direction. 
 
        lon_cycle, lat_cycle : 360 or None 
            If not None, values in the corresponding direction are taken modulo 
            *lon_cycle* or *lat_cycle*; in theory this can be any number but 
            the implementation actually assumes that it is 360 (if not None); 
            other values give nonsensical results. 
 
            This is done by &quot;unwrapping&quot; the transformed grid coordinates so 
            that jumps are less than a half-cycle; then normalizing the span to 
            no more than a full cycle. 
 
            For example, if values are in the union of the [0, 2] and 
            [358, 360] intervals (typically, angles measured modulo 360), the 
            values in the second interval are normalized to [-2, 0] instead so 
            that the values now cover [-2, 2].  If values are in a range of 
            [5, 1000], this gets normalized to [5, 365]. 
 
        lon_minmax, lat_minmax : (float, float) or None 
            If not None, the computed bounding box is clipped to the given 
            range in the corresponding direction. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.nx</span><span class="s0">, </span><span class="s1">self.ny = nx</span><span class="s0">, </span><span class="s1">ny</span>
        <span class="s1">self.lon_cycle</span><span class="s0">, </span><span class="s1">self.lat_cycle = lon_cycle</span><span class="s0">, </span><span class="s1">lat_cycle</span>
        <span class="s1">self.lon_minmax = lon_minmax</span>
        <span class="s1">self.lat_minmax = lat_minmax</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">transform_xy</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">y2):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(</span>
            <span class="s1">np.linspace(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">self.nx)</span><span class="s0">, </span><span class="s1">np.linspace(y1</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">self.ny))</span>
        <span class="s1">lon</span><span class="s0">, </span><span class="s1">lat = transform_xy(np.ravel(x)</span><span class="s0">, </span><span class="s1">np.ravel(y))</span>

        <span class="s3"># iron out jumps, but algorithm should be improved.</span>
        <span class="s3"># This is just naive way of doing and my fail for some cases.</span>
        <span class="s3"># Consider replacing this with numpy.unwrap</span>
        <span class="s3"># We are ignoring invalid warnings. They are triggered when</span>
        <span class="s3"># comparing arrays with NaNs using &gt; We are already handling</span>
        <span class="s3"># that correctly using np.nanmin and np.nanmax</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">self.lon_cycle </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">lon0 = np.nanmin(lon)</span>
                <span class="s1">lon -= </span><span class="s2">360. </span><span class="s1">* ((lon - lon0) &gt; </span><span class="s2">180.</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.lat_cycle </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">lat0 = np.nanmin(lat)</span>
                <span class="s1">lat -= </span><span class="s2">360. </span><span class="s1">* ((lat - lat0) &gt; </span><span class="s2">180.</span><span class="s1">)</span>

        <span class="s1">lon_min</span><span class="s0">, </span><span class="s1">lon_max = np.nanmin(lon)</span><span class="s0">, </span><span class="s1">np.nanmax(lon)</span>
        <span class="s1">lat_min</span><span class="s0">, </span><span class="s1">lat_max = np.nanmin(lat)</span><span class="s0">, </span><span class="s1">np.nanmax(lat)</span>

        <span class="s1">lon_min</span><span class="s0">, </span><span class="s1">lon_max</span><span class="s0">, </span><span class="s1">lat_min</span><span class="s0">, </span><span class="s1">lat_max = \</span>
            <span class="s1">self._add_pad(lon_min</span><span class="s0">, </span><span class="s1">lon_max</span><span class="s0">, </span><span class="s1">lat_min</span><span class="s0">, </span><span class="s1">lat_max)</span>

        <span class="s3"># check cycle</span>
        <span class="s0">if </span><span class="s1">self.lon_cycle:</span>
            <span class="s1">lon_max = min(lon_max</span><span class="s0">, </span><span class="s1">lon_min + self.lon_cycle)</span>
        <span class="s0">if </span><span class="s1">self.lat_cycle:</span>
            <span class="s1">lat_max = min(lat_max</span><span class="s0">, </span><span class="s1">lat_min + self.lat_cycle)</span>

        <span class="s0">if </span><span class="s1">self.lon_minmax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">min0 = self.lon_minmax[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">lon_min = max(min0</span><span class="s0">, </span><span class="s1">lon_min)</span>
            <span class="s1">max0 = self.lon_minmax[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">lon_max = min(max0</span><span class="s0">, </span><span class="s1">lon_max)</span>

        <span class="s0">if </span><span class="s1">self.lat_minmax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">min0 = self.lat_minmax[</span><span class="s2">0</span><span class="s1">]</span>
            <span class="s1">lat_min = max(min0</span><span class="s0">, </span><span class="s1">lat_min)</span>
            <span class="s1">max0 = self.lat_minmax[</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">lat_max = min(max0</span><span class="s0">, </span><span class="s1">lat_max)</span>

        <span class="s0">return </span><span class="s1">lon_min</span><span class="s0">, </span><span class="s1">lon_max</span><span class="s0">, </span><span class="s1">lat_min</span><span class="s0">, </span><span class="s1">lat_max</span>
</pre>
</body>
</html>