<html>
<head>
<title>descriptor_pool.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
descriptor_pool.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0"># https://developers.google.com/protocol-buffers/</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0">#     * Redistributions of source code must retain the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#     * Redistributions in binary form must reproduce the above</span>
<span class="s0"># copyright notice, this list of conditions and the following disclaimer</span>
<span class="s0"># in the documentation and/or other materials provided with the</span>
<span class="s0"># distribution.</span>
<span class="s0">#     * Neither the name of Google Inc. nor the names of its</span>
<span class="s0"># contributors may be used to endorse or promote products derived from</span>
<span class="s0"># this software without specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">&quot;&quot;&quot;Provides DescriptorPool to use as a container for proto2 descriptors. 
 
The DescriptorPool is used in conjection with a DescriptorDatabase to maintain 
a collection of protocol buffer descriptors for use when dynamically creating 
message types at runtime. 
 
For most applications protocol buffers should be used via modules generated by 
the protocol buffer compiler tool. This should only be used when the type of 
protocol buffers used in an application or library cannot be predetermined. 
 
Below is a straightforward example on how to use this class:: 
 
  pool = DescriptorPool() 
  file_descriptor_protos = [ ... ] 
  for file_descriptor_proto in file_descriptor_protos: 
    pool.Add(file_descriptor_proto) 
  my_message_descriptor = pool.FindMessageTypeByName('some.package.MessageType') 
 
The message descriptor can be used in conjunction with the message_factory 
module in order to create a protocol buffer class that can be encoded and 
decoded. 
 
If you want to get a Python class for the specified proto, use the 
helper functions inside google.protobuf.message_factory 
directly instead of this class. 
&quot;&quot;&quot;</span>

<span class="s1">__author__ = </span><span class="s3">'matthewtoia@google.com (Matt Toia)'</span>

<span class="s4">import </span><span class="s1">collections</span>
<span class="s4">import </span><span class="s1">warnings</span>

<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">descriptor</span>
<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">descriptor_database</span>
<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">text_encoding</span>


<span class="s1">_USE_C_DESCRIPTORS = descriptor._USE_C_DESCRIPTORS  </span><span class="s0"># pylint: disable=protected-access</span>


<span class="s4">def </span><span class="s1">_Deprecated(func):</span>
  <span class="s2">&quot;&quot;&quot;Mark functions as deprecated.&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">NewFunc(*args</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">warnings.warn(</span>
        <span class="s3">'Call to deprecated function %s(). Note: Do add unlinked descriptors '</span>
        <span class="s3">'to descriptor_pool is wrong. Use Add() or AddSerializedFile() '</span>
        <span class="s3">'instead.' </span><span class="s1">% func.__name__</span><span class="s4">,</span>
        <span class="s1">category=DeprecationWarning)</span>
    <span class="s4">return </span><span class="s1">func(*args</span><span class="s4">, </span><span class="s1">**kwargs)</span>
  <span class="s1">NewFunc.__name__ = func.__name__</span>
  <span class="s1">NewFunc.__doc__ = func.__doc__</span>
  <span class="s1">NewFunc.__dict__.update(func.__dict__)</span>
  <span class="s4">return </span><span class="s1">NewFunc</span>


<span class="s4">def </span><span class="s1">_NormalizeFullyQualifiedName(name):</span>
  <span class="s2">&quot;&quot;&quot;Remove leading period from fully-qualified type name. 
 
  Due to b/13860351 in descriptor_database.py, types in the root namespace are 
  generated with a leading period. This function removes that prefix. 
 
  Args: 
    name (str): The fully-qualified symbol name. 
 
  Returns: 
    str: The normalized fully-qualified symbol name. 
  &quot;&quot;&quot;</span>
  <span class="s4">return </span><span class="s1">name.lstrip(</span><span class="s3">'.'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_OptionsOrNone(descriptor_proto):</span>
  <span class="s2">&quot;&quot;&quot;Returns the value of the field `options`, or None if it is not set.&quot;&quot;&quot;</span>
  <span class="s4">if </span><span class="s1">descriptor_proto.HasField(</span><span class="s3">'options'</span><span class="s1">):</span>
    <span class="s4">return </span><span class="s1">descriptor_proto.options</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s4">return None</span>


<span class="s4">def </span><span class="s1">_IsMessageSetExtension(field):</span>
  <span class="s4">return </span><span class="s1">(field.is_extension </span><span class="s4">and</span>
          <span class="s1">field.containing_type.has_options </span><span class="s4">and</span>
          <span class="s1">field.containing_type.GetOptions().message_set_wire_format </span><span class="s4">and</span>
          <span class="s1">field.type == descriptor.FieldDescriptor.TYPE_MESSAGE </span><span class="s4">and</span>
          <span class="s1">field.label == descriptor.FieldDescriptor.LABEL_OPTIONAL)</span>


<span class="s4">class </span><span class="s1">DescriptorPool(object):</span>
  <span class="s2">&quot;&quot;&quot;A collection of protobufs dynamically constructed by descriptor protos.&quot;&quot;&quot;</span>

  <span class="s4">if </span><span class="s1">_USE_C_DESCRIPTORS:</span>

    <span class="s4">def </span><span class="s1">__new__(cls</span><span class="s4">, </span><span class="s1">descriptor_db=</span><span class="s4">None</span><span class="s1">):</span>
      <span class="s0"># pylint: disable=protected-access</span>
      <span class="s4">return </span><span class="s1">descriptor._message.DescriptorPool(descriptor_db)</span>

  <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">descriptor_db=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes a Pool of proto buffs. 
 
    The descriptor_db argument to the constructor is provided to allow 
    specialized file descriptor proto lookup code to be triggered on demand. An 
    example would be an implementation which will read and compile a file 
    specified in a call to FindFileByName() and not require the call to Add() 
    at all. Results from this database will be cached internally here as well. 
 
    Args: 
      descriptor_db: A secondary source of file descriptors. 
    &quot;&quot;&quot;</span>

    <span class="s1">self._internal_db = descriptor_database.DescriptorDatabase()</span>
    <span class="s1">self._descriptor_db = descriptor_db</span>
    <span class="s1">self._descriptors = {}</span>
    <span class="s1">self._enum_descriptors = {}</span>
    <span class="s1">self._service_descriptors = {}</span>
    <span class="s1">self._file_descriptors = {}</span>
    <span class="s1">self._toplevel_extensions = {}</span>
    <span class="s0"># TODO(jieluo): Remove _file_desc_by_toplevel_extension after</span>
    <span class="s0"># maybe year 2020 for compatibility issue (with 3.4.1 only).</span>
    <span class="s1">self._file_desc_by_toplevel_extension = {}</span>
    <span class="s1">self._top_enum_values = {}</span>
    <span class="s0"># We store extensions in two two-level mappings: The first key is the</span>
    <span class="s0"># descriptor of the message being extended, the second key is the extension</span>
    <span class="s0"># full name or its tag number.</span>
    <span class="s1">self._extensions_by_name = collections.defaultdict(dict)</span>
    <span class="s1">self._extensions_by_number = collections.defaultdict(dict)</span>

  <span class="s4">def </span><span class="s1">_CheckConflictRegister(self</span><span class="s4">, </span><span class="s1">desc</span><span class="s4">, </span><span class="s1">desc_name</span><span class="s4">, </span><span class="s1">file_name):</span>
    <span class="s2">&quot;&quot;&quot;Check if the descriptor name conflicts with another of the same name. 
 
    Args: 
      desc: Descriptor of a message, enum, service, extension or enum value. 
      desc_name (str): the full name of desc. 
      file_name (str): The file name of descriptor. 
    &quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">register</span><span class="s4">, </span><span class="s1">descriptor_type </span><span class="s4">in </span><span class="s1">[</span>
        <span class="s1">(self._descriptors</span><span class="s4">, </span><span class="s1">descriptor.Descriptor)</span><span class="s4">,</span>
        <span class="s1">(self._enum_descriptors</span><span class="s4">, </span><span class="s1">descriptor.EnumDescriptor)</span><span class="s4">,</span>
        <span class="s1">(self._service_descriptors</span><span class="s4">, </span><span class="s1">descriptor.ServiceDescriptor)</span><span class="s4">,</span>
        <span class="s1">(self._toplevel_extensions</span><span class="s4">, </span><span class="s1">descriptor.FieldDescriptor)</span><span class="s4">,</span>
        <span class="s1">(self._top_enum_values</span><span class="s4">, </span><span class="s1">descriptor.EnumValueDescriptor)]:</span>
      <span class="s4">if </span><span class="s1">desc_name </span><span class="s4">in </span><span class="s1">register:</span>
        <span class="s1">old_desc = register[desc_name]</span>
        <span class="s4">if </span><span class="s1">isinstance(old_desc</span><span class="s4">, </span><span class="s1">descriptor.EnumValueDescriptor):</span>
          <span class="s1">old_file = old_desc.type.file.name</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s1">old_file = old_desc.file.name</span>

        <span class="s4">if not </span><span class="s1">isinstance(desc</span><span class="s4">, </span><span class="s1">descriptor_type) </span><span class="s4">or </span><span class="s1">(</span>
            <span class="s1">old_file != file_name):</span>
          <span class="s1">error_msg = (</span><span class="s3">'Conflict register for file &quot;' </span><span class="s1">+ file_name +</span>
                       <span class="s3">'&quot;: ' </span><span class="s1">+ desc_name +</span>
                       <span class="s3">' is already defined in file &quot;' </span><span class="s1">+</span>
                       <span class="s1">old_file + </span><span class="s3">'&quot;. Please fix the conflict by adding '</span>
                       <span class="s3">'package name on the proto file, or use different '</span>
                       <span class="s3">'name for the duplication.'</span><span class="s1">)</span>
          <span class="s4">if </span><span class="s1">isinstance(desc</span><span class="s4">, </span><span class="s1">descriptor.EnumValueDescriptor):</span>
            <span class="s1">error_msg += (</span><span class="s3">'</span><span class="s4">\n</span><span class="s3">Note: enum values appear as '</span>
                          <span class="s3">'siblings of the enum type instead of '</span>
                          <span class="s3">'children of it.'</span><span class="s1">)</span>

          <span class="s4">raise </span><span class="s1">TypeError(error_msg)</span>

        <span class="s4">return</span>

  <span class="s4">def </span><span class="s1">Add(self</span><span class="s4">, </span><span class="s1">file_desc_proto):</span>
    <span class="s2">&quot;&quot;&quot;Adds the FileDescriptorProto and its types to this pool. 
 
    Args: 
      file_desc_proto (FileDescriptorProto): The file descriptor to add. 
    &quot;&quot;&quot;</span>

    <span class="s1">self._internal_db.Add(file_desc_proto)</span>

  <span class="s4">def </span><span class="s1">AddSerializedFile(self</span><span class="s4">, </span><span class="s1">serialized_file_desc_proto):</span>
    <span class="s2">&quot;&quot;&quot;Adds the FileDescriptorProto and its types to this pool. 
 
    Args: 
      serialized_file_desc_proto (bytes): A bytes string, serialization of the 
        :class:`FileDescriptorProto` to add. 
 
    Returns: 
      FileDescriptor: Descriptor for the added file. 
    &quot;&quot;&quot;</span>

    <span class="s0"># pylint: disable=g-import-not-at-top</span>
    <span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">descriptor_pb2</span>
    <span class="s1">file_desc_proto = descriptor_pb2.FileDescriptorProto.FromString(</span>
        <span class="s1">serialized_file_desc_proto)</span>
    <span class="s1">file_desc = self._ConvertFileProtoToFileDescriptor(file_desc_proto)</span>
    <span class="s1">file_desc.serialized_pb = serialized_file_desc_proto</span>
    <span class="s4">return </span><span class="s1">file_desc</span>

  <span class="s0"># Add Descriptor to descriptor pool is dreprecated. Please use Add()</span>
  <span class="s0"># or AddSerializedFile() to add a FileDescriptorProto instead.</span>
  <span class="s1">@_Deprecated</span>
  <span class="s4">def </span><span class="s1">AddDescriptor(self</span><span class="s4">, </span><span class="s1">desc):</span>
    <span class="s1">self._AddDescriptor(desc)</span>

  <span class="s0"># Never call this method. It is for internal usage only.</span>
  <span class="s4">def </span><span class="s1">_AddDescriptor(self</span><span class="s4">, </span><span class="s1">desc):</span>
    <span class="s2">&quot;&quot;&quot;Adds a Descriptor to the pool, non-recursively. 
 
    If the Descriptor contains nested messages or enums, the caller must 
    explicitly register them. This method also registers the FileDescriptor 
    associated with the message. 
 
    Args: 
      desc: A Descriptor. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance(desc</span><span class="s4">, </span><span class="s1">descriptor.Descriptor):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Expected instance of descriptor.Descriptor.'</span><span class="s1">)</span>

    <span class="s1">self._CheckConflictRegister(desc</span><span class="s4">, </span><span class="s1">desc.full_name</span><span class="s4">, </span><span class="s1">desc.file.name)</span>

    <span class="s1">self._descriptors[desc.full_name] = desc</span>
    <span class="s1">self._AddFileDescriptor(desc.file)</span>

  <span class="s0"># Add EnumDescriptor to descriptor pool is dreprecated. Please use Add()</span>
  <span class="s0"># or AddSerializedFile() to add a FileDescriptorProto instead.</span>
  <span class="s1">@_Deprecated</span>
  <span class="s4">def </span><span class="s1">AddEnumDescriptor(self</span><span class="s4">, </span><span class="s1">enum_desc):</span>
    <span class="s1">self._AddEnumDescriptor(enum_desc)</span>

  <span class="s0"># Never call this method. It is for internal usage only.</span>
  <span class="s4">def </span><span class="s1">_AddEnumDescriptor(self</span><span class="s4">, </span><span class="s1">enum_desc):</span>
    <span class="s2">&quot;&quot;&quot;Adds an EnumDescriptor to the pool. 
 
    This method also registers the FileDescriptor associated with the enum. 
 
    Args: 
      enum_desc: An EnumDescriptor. 
    &quot;&quot;&quot;</span>

    <span class="s4">if not </span><span class="s1">isinstance(enum_desc</span><span class="s4">, </span><span class="s1">descriptor.EnumDescriptor):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Expected instance of descriptor.EnumDescriptor.'</span><span class="s1">)</span>

    <span class="s1">file_name = enum_desc.file.name</span>
    <span class="s1">self._CheckConflictRegister(enum_desc</span><span class="s4">, </span><span class="s1">enum_desc.full_name</span><span class="s4">, </span><span class="s1">file_name)</span>
    <span class="s1">self._enum_descriptors[enum_desc.full_name] = enum_desc</span>

    <span class="s0"># Top enum values need to be indexed.</span>
    <span class="s0"># Count the number of dots to see whether the enum is toplevel or nested</span>
    <span class="s0"># in a message. We cannot use enum_desc.containing_type at this stage.</span>
    <span class="s4">if </span><span class="s1">enum_desc.file.package:</span>
      <span class="s1">top_level = (enum_desc.full_name.count(</span><span class="s3">'.'</span><span class="s1">)</span>
                   <span class="s1">- enum_desc.file.package.count(</span><span class="s3">'.'</span><span class="s1">) == </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">top_level = enum_desc.full_name.count(</span><span class="s3">'.'</span><span class="s1">) == </span><span class="s5">0</span>
    <span class="s4">if </span><span class="s1">top_level:</span>
      <span class="s1">file_name = enum_desc.file.name</span>
      <span class="s1">package = enum_desc.file.package</span>
      <span class="s4">for </span><span class="s1">enum_value </span><span class="s4">in </span><span class="s1">enum_desc.values:</span>
        <span class="s1">full_name = _NormalizeFullyQualifiedName(</span>
            <span class="s3">'.'</span><span class="s1">.join((package</span><span class="s4">, </span><span class="s1">enum_value.name)))</span>
        <span class="s1">self._CheckConflictRegister(enum_value</span><span class="s4">, </span><span class="s1">full_name</span><span class="s4">, </span><span class="s1">file_name)</span>
        <span class="s1">self._top_enum_values[full_name] = enum_value</span>
    <span class="s1">self._AddFileDescriptor(enum_desc.file)</span>

  <span class="s0"># Add ServiceDescriptor to descriptor pool is dreprecated. Please use Add()</span>
  <span class="s0"># or AddSerializedFile() to add a FileDescriptorProto instead.</span>
  <span class="s1">@_Deprecated</span>
  <span class="s4">def </span><span class="s1">AddServiceDescriptor(self</span><span class="s4">, </span><span class="s1">service_desc):</span>
    <span class="s1">self._AddServiceDescriptor(service_desc)</span>

  <span class="s0"># Never call this method. It is for internal usage only.</span>
  <span class="s4">def </span><span class="s1">_AddServiceDescriptor(self</span><span class="s4">, </span><span class="s1">service_desc):</span>
    <span class="s2">&quot;&quot;&quot;Adds a ServiceDescriptor to the pool. 
 
    Args: 
      service_desc: A ServiceDescriptor. 
    &quot;&quot;&quot;</span>

    <span class="s4">if not </span><span class="s1">isinstance(service_desc</span><span class="s4">, </span><span class="s1">descriptor.ServiceDescriptor):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Expected instance of descriptor.ServiceDescriptor.'</span><span class="s1">)</span>

    <span class="s1">self._CheckConflictRegister(service_desc</span><span class="s4">, </span><span class="s1">service_desc.full_name</span><span class="s4">,</span>
                                <span class="s1">service_desc.file.name)</span>
    <span class="s1">self._service_descriptors[service_desc.full_name] = service_desc</span>

  <span class="s0"># Add ExtensionDescriptor to descriptor pool is dreprecated. Please use Add()</span>
  <span class="s0"># or AddSerializedFile() to add a FileDescriptorProto instead.</span>
  <span class="s1">@_Deprecated</span>
  <span class="s4">def </span><span class="s1">AddExtensionDescriptor(self</span><span class="s4">, </span><span class="s1">extension):</span>
    <span class="s1">self._AddExtensionDescriptor(extension)</span>

  <span class="s0"># Never call this method. It is for internal usage only.</span>
  <span class="s4">def </span><span class="s1">_AddExtensionDescriptor(self</span><span class="s4">, </span><span class="s1">extension):</span>
    <span class="s2">&quot;&quot;&quot;Adds a FieldDescriptor describing an extension to the pool. 
 
    Args: 
      extension: A FieldDescriptor. 
 
    Raises: 
      AssertionError: when another extension with the same number extends the 
        same message. 
      TypeError: when the specified extension is not a 
        descriptor.FieldDescriptor. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">(isinstance(extension</span><span class="s4">, </span><span class="s1">descriptor.FieldDescriptor) </span><span class="s4">and</span>
            <span class="s1">extension.is_extension):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Expected an extension descriptor.'</span><span class="s1">)</span>

    <span class="s4">if </span><span class="s1">extension.extension_scope </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s1">self._toplevel_extensions[extension.full_name] = extension</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">existing_desc = self._extensions_by_number[</span>
          <span class="s1">extension.containing_type][extension.number]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">if </span><span class="s1">extension </span><span class="s4">is not </span><span class="s1">existing_desc:</span>
        <span class="s4">raise </span><span class="s1">AssertionError(</span>
            <span class="s3">'Extensions &quot;%s&quot; and &quot;%s&quot; both try to extend message type &quot;%s&quot; '</span>
            <span class="s3">'with field number %d.' </span><span class="s1">%</span>
            <span class="s1">(extension.full_name</span><span class="s4">, </span><span class="s1">existing_desc.full_name</span><span class="s4">,</span>
             <span class="s1">extension.containing_type.full_name</span><span class="s4">, </span><span class="s1">extension.number))</span>

    <span class="s1">self._extensions_by_number[extension.containing_type][</span>
        <span class="s1">extension.number] = extension</span>
    <span class="s1">self._extensions_by_name[extension.containing_type][</span>
        <span class="s1">extension.full_name] = extension</span>

    <span class="s0"># Also register MessageSet extensions with the type name.</span>
    <span class="s4">if </span><span class="s1">_IsMessageSetExtension(extension):</span>
      <span class="s1">self._extensions_by_name[extension.containing_type][</span>
          <span class="s1">extension.message_type.full_name] = extension</span>

  <span class="s1">@_Deprecated</span>
  <span class="s4">def </span><span class="s1">AddFileDescriptor(self</span><span class="s4">, </span><span class="s1">file_desc):</span>
    <span class="s1">self._InternalAddFileDescriptor(file_desc)</span>

  <span class="s0"># Never call this method. It is for internal usage only.</span>
  <span class="s4">def </span><span class="s1">_InternalAddFileDescriptor(self</span><span class="s4">, </span><span class="s1">file_desc):</span>
    <span class="s2">&quot;&quot;&quot;Adds a FileDescriptor to the pool, non-recursively. 
 
    If the FileDescriptor contains messages or enums, the caller must explicitly 
    register them. 
 
    Args: 
      file_desc: A FileDescriptor. 
    &quot;&quot;&quot;</span>

    <span class="s1">self._AddFileDescriptor(file_desc)</span>
    <span class="s0"># TODO(jieluo): This is a temporary solution for FieldDescriptor.file.</span>
    <span class="s0"># FieldDescriptor.file is added in code gen. Remove this solution after</span>
    <span class="s0"># maybe 2020 for compatibility reason (with 3.4.1 only).</span>
    <span class="s4">for </span><span class="s1">extension </span><span class="s4">in </span><span class="s1">file_desc.extensions_by_name.values():</span>
      <span class="s1">self._file_desc_by_toplevel_extension[</span>
          <span class="s1">extension.full_name] = file_desc</span>

  <span class="s4">def </span><span class="s1">_AddFileDescriptor(self</span><span class="s4">, </span><span class="s1">file_desc):</span>
    <span class="s2">&quot;&quot;&quot;Adds a FileDescriptor to the pool, non-recursively. 
 
    If the FileDescriptor contains messages or enums, the caller must explicitly 
    register them. 
 
    Args: 
      file_desc: A FileDescriptor. 
    &quot;&quot;&quot;</span>

    <span class="s4">if not </span><span class="s1">isinstance(file_desc</span><span class="s4">, </span><span class="s1">descriptor.FileDescriptor):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'Expected instance of descriptor.FileDescriptor.'</span><span class="s1">)</span>
    <span class="s1">self._file_descriptors[file_desc.name] = file_desc</span>

  <span class="s4">def </span><span class="s1">FindFileByName(self</span><span class="s4">, </span><span class="s1">file_name):</span>
    <span class="s2">&quot;&quot;&quot;Gets a FileDescriptor by file name. 
 
    Args: 
      file_name (str): The path to the file to get a descriptor for. 
 
    Returns: 
      FileDescriptor: The descriptor for the named file. 
 
    Raises: 
      KeyError: if the file cannot be found in the pool. 
    &quot;&quot;&quot;</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._file_descriptors[file_name]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">file_proto = self._internal_db.FindFileByName(file_name)</span>
    <span class="s4">except </span><span class="s1">KeyError </span><span class="s4">as </span><span class="s1">error:</span>
      <span class="s4">if </span><span class="s1">self._descriptor_db:</span>
        <span class="s1">file_proto = self._descriptor_db.FindFileByName(file_name)</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">error</span>
    <span class="s4">if not </span><span class="s1">file_proto:</span>
      <span class="s4">raise </span><span class="s1">KeyError(</span><span class="s3">'Cannot find a file named %s' </span><span class="s1">% file_name)</span>
    <span class="s4">return </span><span class="s1">self._ConvertFileProtoToFileDescriptor(file_proto)</span>

  <span class="s4">def </span><span class="s1">FindFileContainingSymbol(self</span><span class="s4">, </span><span class="s1">symbol):</span>
    <span class="s2">&quot;&quot;&quot;Gets the FileDescriptor for the file containing the specified symbol. 
 
    Args: 
      symbol (str): The name of the symbol to search for. 
 
    Returns: 
      FileDescriptor: Descriptor for the file that contains the specified 
      symbol. 
 
    Raises: 
      KeyError: if the file cannot be found in the pool. 
    &quot;&quot;&quot;</span>

    <span class="s1">symbol = _NormalizeFullyQualifiedName(symbol)</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._InternalFindFileContainingSymbol(symbol)</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s0"># Try fallback database. Build and find again if possible.</span>
      <span class="s1">self._FindFileContainingSymbolInDb(symbol)</span>
      <span class="s4">return </span><span class="s1">self._InternalFindFileContainingSymbol(symbol)</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">raise </span><span class="s1">KeyError(</span><span class="s3">'Cannot find a file containing %s' </span><span class="s1">% symbol)</span>

  <span class="s4">def </span><span class="s1">_InternalFindFileContainingSymbol(self</span><span class="s4">, </span><span class="s1">symbol):</span>
    <span class="s2">&quot;&quot;&quot;Gets the already built FileDescriptor containing the specified symbol. 
 
    Args: 
      symbol (str): The name of the symbol to search for. 
 
    Returns: 
      FileDescriptor: Descriptor for the file that contains the specified 
      symbol. 
 
    Raises: 
      KeyError: if the file cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._descriptors[symbol].file</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._enum_descriptors[symbol].file</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._service_descriptors[symbol].file</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._top_enum_values[symbol].type.file</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._file_desc_by_toplevel_extension[symbol]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>

    <span class="s0"># Try fields, enum values and nested extensions inside a message.</span>
    <span class="s1">top_name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">sub_name = symbol.rpartition(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">message = self.FindMessageTypeByName(top_name)</span>
      <span class="s4">assert </span><span class="s1">(sub_name </span><span class="s4">in </span><span class="s1">message.extensions_by_name </span><span class="s4">or</span>
              <span class="s1">sub_name </span><span class="s4">in </span><span class="s1">message.fields_by_name </span><span class="s4">or</span>
              <span class="s1">sub_name </span><span class="s4">in </span><span class="s1">message.enum_values_by_name)</span>
      <span class="s4">return </span><span class="s1">message.file</span>
    <span class="s4">except </span><span class="s1">(KeyError</span><span class="s4">, </span><span class="s1">AssertionError):</span>
      <span class="s4">raise </span><span class="s1">KeyError(</span><span class="s3">'Cannot find a file containing %s' </span><span class="s1">% symbol)</span>

  <span class="s4">def </span><span class="s1">FindMessageTypeByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the descriptor to load. 
 
    Returns: 
      Descriptor: The descriptor for the named type. 
 
    Raises: 
      KeyError: if the message cannot be found in the pool. 
    &quot;&quot;&quot;</span>

    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s4">if </span><span class="s1">full_name </span><span class="s4">not in </span><span class="s1">self._descriptors:</span>
      <span class="s1">self._FindFileContainingSymbolInDb(full_name)</span>
    <span class="s4">return </span><span class="s1">self._descriptors[full_name]</span>

  <span class="s4">def </span><span class="s1">FindEnumTypeByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named enum descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the enum descriptor to load. 
 
    Returns: 
      EnumDescriptor: The enum descriptor for the named type. 
 
    Raises: 
      KeyError: if the enum cannot be found in the pool. 
    &quot;&quot;&quot;</span>

    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s4">if </span><span class="s1">full_name </span><span class="s4">not in </span><span class="s1">self._enum_descriptors:</span>
      <span class="s1">self._FindFileContainingSymbolInDb(full_name)</span>
    <span class="s4">return </span><span class="s1">self._enum_descriptors[full_name]</span>

  <span class="s4">def </span><span class="s1">FindFieldByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named field descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the field descriptor to load. 
 
    Returns: 
      FieldDescriptor: The field descriptor for the named field. 
 
    Raises: 
      KeyError: if the field cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s1">message_name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">field_name = full_name.rpartition(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s1">message_descriptor = self.FindMessageTypeByName(message_name)</span>
    <span class="s4">return </span><span class="s1">message_descriptor.fields_by_name[field_name]</span>

  <span class="s4">def </span><span class="s1">FindOneofByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named oneof descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the oneof descriptor to load. 
 
    Returns: 
      OneofDescriptor: The oneof descriptor for the named oneof. 
 
    Raises: 
      KeyError: if the oneof cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s1">message_name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">oneof_name = full_name.rpartition(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s1">message_descriptor = self.FindMessageTypeByName(message_name)</span>
    <span class="s4">return </span><span class="s1">message_descriptor.oneofs_by_name[oneof_name]</span>

  <span class="s4">def </span><span class="s1">FindExtensionByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named extension descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the extension descriptor to load. 
 
    Returns: 
      FieldDescriptor: The field descriptor for the named extension. 
 
    Raises: 
      KeyError: if the extension cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s0"># The proto compiler does not give any link between the FileDescriptor</span>
      <span class="s0"># and top-level extensions unless the FileDescriptorProto is added to</span>
      <span class="s0"># the DescriptorDatabase, but this can impact memory usage.</span>
      <span class="s0"># So we registered these extensions by name explicitly.</span>
      <span class="s4">return </span><span class="s1">self._toplevel_extensions[full_name]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">pass</span>
    <span class="s1">message_name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">extension_name = full_name.rpartition(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s0"># Most extensions are nested inside a message.</span>
      <span class="s1">scope = self.FindMessageTypeByName(message_name)</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s0"># Some extensions are defined at file scope.</span>
      <span class="s1">scope = self._FindFileContainingSymbolInDb(full_name)</span>
    <span class="s4">return </span><span class="s1">scope.extensions_by_name[extension_name]</span>

  <span class="s4">def </span><span class="s1">FindExtensionByNumber(self</span><span class="s4">, </span><span class="s1">message_descriptor</span><span class="s4">, </span><span class="s1">number):</span>
    <span class="s2">&quot;&quot;&quot;Gets the extension of the specified message with the specified number. 
 
    Extensions have to be registered to this pool by calling :func:`Add` or 
    :func:`AddExtensionDescriptor`. 
 
    Args: 
      message_descriptor (Descriptor): descriptor of the extended message. 
      number (int): Number of the extension field. 
 
    Returns: 
      FieldDescriptor: The descriptor for the extension. 
 
    Raises: 
      KeyError: when no extension with the given number is known for the 
        specified message. 
    &quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">self._extensions_by_number[message_descriptor][number]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s1">self._TryLoadExtensionFromDB(message_descriptor</span><span class="s4">, </span><span class="s1">number)</span>
      <span class="s4">return </span><span class="s1">self._extensions_by_number[message_descriptor][number]</span>

  <span class="s4">def </span><span class="s1">FindAllExtensions(self</span><span class="s4">, </span><span class="s1">message_descriptor):</span>
    <span class="s2">&quot;&quot;&quot;Gets all the known extensions of a given message. 
 
    Extensions have to be registered to this pool by build related 
    :func:`Add` or :func:`AddExtensionDescriptor`. 
 
    Args: 
      message_descriptor (Descriptor): Descriptor of the extended message. 
 
    Returns: 
      list[FieldDescriptor]: Field descriptors describing the extensions. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Fallback to descriptor db if FindAllExtensionNumbers is provided.</span>
    <span class="s4">if </span><span class="s1">self._descriptor_db </span><span class="s4">and </span><span class="s1">hasattr(</span>
        <span class="s1">self._descriptor_db</span><span class="s4">, </span><span class="s3">'FindAllExtensionNumbers'</span><span class="s1">):</span>
      <span class="s1">full_name = message_descriptor.full_name</span>
      <span class="s1">all_numbers = self._descriptor_db.FindAllExtensionNumbers(full_name)</span>
      <span class="s4">for </span><span class="s1">number </span><span class="s4">in </span><span class="s1">all_numbers:</span>
        <span class="s4">if </span><span class="s1">number </span><span class="s4">in </span><span class="s1">self._extensions_by_number[message_descriptor]:</span>
          <span class="s4">continue</span>
        <span class="s1">self._TryLoadExtensionFromDB(message_descriptor</span><span class="s4">, </span><span class="s1">number)</span>

    <span class="s4">return </span><span class="s1">list(self._extensions_by_number[message_descriptor].values())</span>

  <span class="s4">def </span><span class="s1">_TryLoadExtensionFromDB(self</span><span class="s4">, </span><span class="s1">message_descriptor</span><span class="s4">, </span><span class="s1">number):</span>
    <span class="s2">&quot;&quot;&quot;Try to Load extensions from descriptor db. 
 
    Args: 
      message_descriptor: descriptor of the extended message. 
      number: the extension number that needs to be loaded. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">self._descriptor_db:</span>
      <span class="s4">return</span>
    <span class="s0"># Only supported when FindFileContainingExtension is provided.</span>
    <span class="s4">if not </span><span class="s1">hasattr(</span>
        <span class="s1">self._descriptor_db</span><span class="s4">, </span><span class="s3">'FindFileContainingExtension'</span><span class="s1">):</span>
      <span class="s4">return</span>

    <span class="s1">full_name = message_descriptor.full_name</span>
    <span class="s1">file_proto = self._descriptor_db.FindFileContainingExtension(</span>
        <span class="s1">full_name</span><span class="s4">, </span><span class="s1">number)</span>

    <span class="s4">if </span><span class="s1">file_proto </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s4">return</span>

    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">self._ConvertFileProtoToFileDescriptor(file_proto)</span>
    <span class="s4">except</span><span class="s1">:</span>
      <span class="s1">warn_msg = (</span><span class="s3">'Unable to load proto file %s for extension number %d.' </span><span class="s1">%</span>
                  <span class="s1">(file_proto.name</span><span class="s4">, </span><span class="s1">number))</span>
      <span class="s1">warnings.warn(warn_msg</span><span class="s4">, </span><span class="s1">RuntimeWarning)</span>

  <span class="s4">def </span><span class="s1">FindServiceByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named service descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the service descriptor to load. 
 
    Returns: 
      ServiceDescriptor: The service descriptor for the named service. 
 
    Raises: 
      KeyError: if the service cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s4">if </span><span class="s1">full_name </span><span class="s4">not in </span><span class="s1">self._service_descriptors:</span>
      <span class="s1">self._FindFileContainingSymbolInDb(full_name)</span>
    <span class="s4">return </span><span class="s1">self._service_descriptors[full_name]</span>

  <span class="s4">def </span><span class="s1">FindMethodByName(self</span><span class="s4">, </span><span class="s1">full_name):</span>
    <span class="s2">&quot;&quot;&quot;Loads the named service method descriptor from the pool. 
 
    Args: 
      full_name (str): The full name of the method descriptor to load. 
 
    Returns: 
      MethodDescriptor: The method descriptor for the service method. 
 
    Raises: 
      KeyError: if the method cannot be found in the pool. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = _NormalizeFullyQualifiedName(full_name)</span>
    <span class="s1">service_name</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">method_name = full_name.rpartition(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s1">service_descriptor = self.FindServiceByName(service_name)</span>
    <span class="s4">return </span><span class="s1">service_descriptor.methods_by_name[method_name]</span>

  <span class="s4">def </span><span class="s1">_FindFileContainingSymbolInDb(self</span><span class="s4">, </span><span class="s1">symbol):</span>
    <span class="s2">&quot;&quot;&quot;Finds the file in descriptor DB containing the specified symbol. 
 
    Args: 
      symbol (str): The name of the symbol to search for. 
 
    Returns: 
      FileDescriptor: The file that contains the specified symbol. 
 
    Raises: 
      KeyError: if the file cannot be found in the descriptor database. 
    &quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">file_proto = self._internal_db.FindFileContainingSymbol(symbol)</span>
    <span class="s4">except </span><span class="s1">KeyError </span><span class="s4">as </span><span class="s1">error:</span>
      <span class="s4">if </span><span class="s1">self._descriptor_db:</span>
        <span class="s1">file_proto = self._descriptor_db.FindFileContainingSymbol(symbol)</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">error</span>
    <span class="s4">if not </span><span class="s1">file_proto:</span>
      <span class="s4">raise </span><span class="s1">KeyError(</span><span class="s3">'Cannot find a file containing %s' </span><span class="s1">% symbol)</span>
    <span class="s4">return </span><span class="s1">self._ConvertFileProtoToFileDescriptor(file_proto)</span>

  <span class="s4">def </span><span class="s1">_ConvertFileProtoToFileDescriptor(self</span><span class="s4">, </span><span class="s1">file_proto):</span>
    <span class="s2">&quot;&quot;&quot;Creates a FileDescriptor from a proto or returns a cached copy. 
 
    This method also has the side effect of loading all the symbols found in 
    the file into the appropriate dictionaries in the pool. 
 
    Args: 
      file_proto: The proto to convert. 
 
    Returns: 
      A FileDescriptor matching the passed in proto. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">file_proto.name </span><span class="s4">not in </span><span class="s1">self._file_descriptors:</span>
      <span class="s1">built_deps = list(self._GetDeps(file_proto.dependency))</span>
      <span class="s1">direct_deps = [self.FindFileByName(n) </span><span class="s4">for </span><span class="s1">n </span><span class="s4">in </span><span class="s1">file_proto.dependency]</span>
      <span class="s1">public_deps = [direct_deps[i] </span><span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">file_proto.public_dependency]</span>

      <span class="s1">file_descriptor = descriptor.FileDescriptor(</span>
          <span class="s1">pool=self</span><span class="s4">,</span>
          <span class="s1">name=file_proto.name</span><span class="s4">,</span>
          <span class="s1">package=file_proto.package</span><span class="s4">,</span>
          <span class="s1">syntax=file_proto.syntax</span><span class="s4">,</span>
          <span class="s1">options=_OptionsOrNone(file_proto)</span><span class="s4">,</span>
          <span class="s1">serialized_pb=file_proto.SerializeToString()</span><span class="s4">,</span>
          <span class="s1">dependencies=direct_deps</span><span class="s4">,</span>
          <span class="s1">public_dependencies=public_deps</span><span class="s4">,</span>
          <span class="s0"># pylint: disable=protected-access</span>
          <span class="s1">create_key=descriptor._internal_create_key)</span>
      <span class="s1">scope = {}</span>

      <span class="s0"># This loop extracts all the message and enum types from all the</span>
      <span class="s0"># dependencies of the file_proto. This is necessary to create the</span>
      <span class="s0"># scope of available message types when defining the passed in</span>
      <span class="s0"># file proto.</span>
      <span class="s4">for </span><span class="s1">dependency </span><span class="s4">in </span><span class="s1">built_deps:</span>
        <span class="s1">scope.update(self._ExtractSymbols(</span>
            <span class="s1">dependency.message_types_by_name.values()))</span>
        <span class="s1">scope.update((_PrefixWithDot(enum.full_name)</span><span class="s4">, </span><span class="s1">enum)</span>
                     <span class="s4">for </span><span class="s1">enum </span><span class="s4">in </span><span class="s1">dependency.enum_types_by_name.values())</span>

      <span class="s4">for </span><span class="s1">message_type </span><span class="s4">in </span><span class="s1">file_proto.message_type:</span>
        <span class="s1">message_desc = self._ConvertMessageDescriptor(</span>
            <span class="s1">message_type</span><span class="s4">, </span><span class="s1">file_proto.package</span><span class="s4">, </span><span class="s1">file_descriptor</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">,</span>
            <span class="s1">file_proto.syntax)</span>
        <span class="s1">file_descriptor.message_types_by_name[message_desc.name] = (</span>
            <span class="s1">message_desc)</span>

      <span class="s4">for </span><span class="s1">enum_type </span><span class="s4">in </span><span class="s1">file_proto.enum_type:</span>
        <span class="s1">file_descriptor.enum_types_by_name[enum_type.name] = (</span>
            <span class="s1">self._ConvertEnumDescriptor(enum_type</span><span class="s4">, </span><span class="s1">file_proto.package</span><span class="s4">,</span>
                                        <span class="s1">file_descriptor</span><span class="s4">, None, </span><span class="s1">scope</span><span class="s4">, True</span><span class="s1">))</span>

      <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">extension_proto </span><span class="s4">in </span><span class="s1">enumerate(file_proto.extension):</span>
        <span class="s1">extension_desc = self._MakeFieldDescriptor(</span>
            <span class="s1">extension_proto</span><span class="s4">, </span><span class="s1">file_proto.package</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">file_descriptor</span><span class="s4">,</span>
            <span class="s1">is_extension=</span><span class="s4">True</span><span class="s1">)</span>
        <span class="s1">extension_desc.containing_type = self._GetTypeFromScope(</span>
            <span class="s1">file_descriptor.package</span><span class="s4">, </span><span class="s1">extension_proto.extendee</span><span class="s4">, </span><span class="s1">scope)</span>
        <span class="s1">self._SetFieldType(extension_proto</span><span class="s4">, </span><span class="s1">extension_desc</span><span class="s4">,</span>
                           <span class="s1">file_descriptor.package</span><span class="s4">, </span><span class="s1">scope)</span>
        <span class="s1">file_descriptor.extensions_by_name[extension_desc.name] = (</span>
            <span class="s1">extension_desc)</span>
        <span class="s1">self._file_desc_by_toplevel_extension[extension_desc.full_name] = (</span>
            <span class="s1">file_descriptor)</span>

      <span class="s4">for </span><span class="s1">desc_proto </span><span class="s4">in </span><span class="s1">file_proto.message_type:</span>
        <span class="s1">self._SetAllFieldTypes(file_proto.package</span><span class="s4">, </span><span class="s1">desc_proto</span><span class="s4">, </span><span class="s1">scope)</span>

      <span class="s4">if </span><span class="s1">file_proto.package:</span>
        <span class="s1">desc_proto_prefix = _PrefixWithDot(file_proto.package)</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">desc_proto_prefix = </span><span class="s3">''</span>

      <span class="s4">for </span><span class="s1">desc_proto </span><span class="s4">in </span><span class="s1">file_proto.message_type:</span>
        <span class="s1">desc = self._GetTypeFromScope(</span>
            <span class="s1">desc_proto_prefix</span><span class="s4">, </span><span class="s1">desc_proto.name</span><span class="s4">, </span><span class="s1">scope)</span>
        <span class="s1">file_descriptor.message_types_by_name[desc_proto.name] = desc</span>

      <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">service_proto </span><span class="s4">in </span><span class="s1">enumerate(file_proto.service):</span>
        <span class="s1">file_descriptor.services_by_name[service_proto.name] = (</span>
            <span class="s1">self._MakeServiceDescriptor(service_proto</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">,</span>
                                        <span class="s1">file_proto.package</span><span class="s4">, </span><span class="s1">file_descriptor))</span>

      <span class="s1">self._file_descriptors[file_proto.name] = file_descriptor</span>

    <span class="s0"># Add extensions to the pool</span>
    <span class="s1">file_desc = self._file_descriptors[file_proto.name]</span>
    <span class="s4">for </span><span class="s1">extension </span><span class="s4">in </span><span class="s1">file_desc.extensions_by_name.values():</span>
      <span class="s1">self._AddExtensionDescriptor(extension)</span>
    <span class="s4">for </span><span class="s1">message_type </span><span class="s4">in </span><span class="s1">file_desc.message_types_by_name.values():</span>
      <span class="s4">for </span><span class="s1">extension </span><span class="s4">in </span><span class="s1">message_type.extensions:</span>
        <span class="s1">self._AddExtensionDescriptor(extension)</span>

    <span class="s4">return </span><span class="s1">file_desc</span>

  <span class="s4">def </span><span class="s1">_ConvertMessageDescriptor(self</span><span class="s4">, </span><span class="s1">desc_proto</span><span class="s4">, </span><span class="s1">package=</span><span class="s4">None, </span><span class="s1">file_desc=</span><span class="s4">None,</span>
                                <span class="s1">scope=</span><span class="s4">None, </span><span class="s1">syntax=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Adds the proto to the pool in the specified package. 
 
    Args: 
      desc_proto: The descriptor_pb2.DescriptorProto protobuf message. 
      package: The package the proto should be located in. 
      file_desc: The file containing this message. 
      scope: Dict mapping short and full symbols to message and enum types. 
      syntax: string indicating syntax of the file (&quot;proto2&quot; or &quot;proto3&quot;) 
 
    Returns: 
      The added descriptor. 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">package:</span>
      <span class="s1">desc_name = </span><span class="s3">'.'</span><span class="s1">.join((package</span><span class="s4">, </span><span class="s1">desc_proto.name))</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">desc_name = desc_proto.name</span>

    <span class="s4">if </span><span class="s1">file_desc </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s1">file_name = </span><span class="s4">None</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">file_name = file_desc.name</span>

    <span class="s4">if </span><span class="s1">scope </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s1">scope = {}</span>

    <span class="s1">nested = [</span>
        <span class="s1">self._ConvertMessageDescriptor(</span>
            <span class="s1">nested</span><span class="s4">, </span><span class="s1">desc_name</span><span class="s4">, </span><span class="s1">file_desc</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">, </span><span class="s1">syntax)</span>
        <span class="s4">for </span><span class="s1">nested </span><span class="s4">in </span><span class="s1">desc_proto.nested_type]</span>
    <span class="s1">enums = [</span>
        <span class="s1">self._ConvertEnumDescriptor(enum</span><span class="s4">, </span><span class="s1">desc_name</span><span class="s4">, </span><span class="s1">file_desc</span><span class="s4">, None,</span>
                                    <span class="s1">scope</span><span class="s4">, False</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">enum </span><span class="s4">in </span><span class="s1">desc_proto.enum_type]</span>
    <span class="s1">fields = [self._MakeFieldDescriptor(field</span><span class="s4">, </span><span class="s1">desc_name</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">file_desc)</span>
              <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">field </span><span class="s4">in </span><span class="s1">enumerate(desc_proto.field)]</span>
    <span class="s1">extensions = [</span>
        <span class="s1">self._MakeFieldDescriptor(extension</span><span class="s4">, </span><span class="s1">desc_name</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">file_desc</span><span class="s4">,</span>
                                  <span class="s1">is_extension=</span><span class="s4">True</span><span class="s1">)</span>
        <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">extension </span><span class="s4">in </span><span class="s1">enumerate(desc_proto.extension)]</span>
    <span class="s1">oneofs = [</span>
        <span class="s0"># pylint: disable=g-complex-comprehension</span>
        <span class="s1">descriptor.OneofDescriptor(</span>
            <span class="s1">desc.name</span><span class="s4">,</span>
            <span class="s3">'.'</span><span class="s1">.join((desc_name</span><span class="s4">, </span><span class="s1">desc.name))</span><span class="s4">,</span>
            <span class="s1">index</span><span class="s4">,</span>
            <span class="s4">None,</span>
            <span class="s1">[]</span><span class="s4">,</span>
            <span class="s1">_OptionsOrNone(desc)</span><span class="s4">,</span>
            <span class="s0"># pylint: disable=protected-access</span>
            <span class="s1">create_key=descriptor._internal_create_key)</span>
        <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">desc </span><span class="s4">in </span><span class="s1">enumerate(desc_proto.oneof_decl)</span>
    <span class="s1">]</span>
    <span class="s1">extension_ranges = [(r.start</span><span class="s4">, </span><span class="s1">r.end) </span><span class="s4">for </span><span class="s1">r </span><span class="s4">in </span><span class="s1">desc_proto.extension_range]</span>
    <span class="s4">if </span><span class="s1">extension_ranges:</span>
      <span class="s1">is_extendable = </span><span class="s4">True</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">is_extendable = </span><span class="s4">False</span>
    <span class="s1">desc = descriptor.Descriptor(</span>
        <span class="s1">name=desc_proto.name</span><span class="s4">,</span>
        <span class="s1">full_name=desc_name</span><span class="s4">,</span>
        <span class="s1">filename=file_name</span><span class="s4">,</span>
        <span class="s1">containing_type=</span><span class="s4">None,</span>
        <span class="s1">fields=fields</span><span class="s4">,</span>
        <span class="s1">oneofs=oneofs</span><span class="s4">,</span>
        <span class="s1">nested_types=nested</span><span class="s4">,</span>
        <span class="s1">enum_types=enums</span><span class="s4">,</span>
        <span class="s1">extensions=extensions</span><span class="s4">,</span>
        <span class="s1">options=_OptionsOrNone(desc_proto)</span><span class="s4">,</span>
        <span class="s1">is_extendable=is_extendable</span><span class="s4">,</span>
        <span class="s1">extension_ranges=extension_ranges</span><span class="s4">,</span>
        <span class="s1">file=file_desc</span><span class="s4">,</span>
        <span class="s1">serialized_start=</span><span class="s4">None,</span>
        <span class="s1">serialized_end=</span><span class="s4">None,</span>
        <span class="s1">syntax=syntax</span><span class="s4">,</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">create_key=descriptor._internal_create_key)</span>
    <span class="s4">for </span><span class="s1">nested </span><span class="s4">in </span><span class="s1">desc.nested_types:</span>
      <span class="s1">nested.containing_type = desc</span>
    <span class="s4">for </span><span class="s1">enum </span><span class="s4">in </span><span class="s1">desc.enum_types:</span>
      <span class="s1">enum.containing_type = desc</span>
    <span class="s4">for </span><span class="s1">field_index</span><span class="s4">, </span><span class="s1">field_desc </span><span class="s4">in </span><span class="s1">enumerate(desc_proto.field):</span>
      <span class="s4">if </span><span class="s1">field_desc.HasField(</span><span class="s3">'oneof_index'</span><span class="s1">):</span>
        <span class="s1">oneof_index = field_desc.oneof_index</span>
        <span class="s1">oneofs[oneof_index].fields.append(fields[field_index])</span>
        <span class="s1">fields[field_index].containing_oneof = oneofs[oneof_index]</span>

    <span class="s1">scope[_PrefixWithDot(desc_name)] = desc</span>
    <span class="s1">self._CheckConflictRegister(desc</span><span class="s4">, </span><span class="s1">desc.full_name</span><span class="s4">, </span><span class="s1">desc.file.name)</span>
    <span class="s1">self._descriptors[desc_name] = desc</span>
    <span class="s4">return </span><span class="s1">desc</span>

  <span class="s4">def </span><span class="s1">_ConvertEnumDescriptor(self</span><span class="s4">, </span><span class="s1">enum_proto</span><span class="s4">, </span><span class="s1">package=</span><span class="s4">None, </span><span class="s1">file_desc=</span><span class="s4">None,</span>
                             <span class="s1">containing_type=</span><span class="s4">None, </span><span class="s1">scope=</span><span class="s4">None, </span><span class="s1">top_level=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Make a protobuf EnumDescriptor given an EnumDescriptorProto protobuf. 
 
    Args: 
      enum_proto: The descriptor_pb2.EnumDescriptorProto protobuf message. 
      package: Optional package name for the new message EnumDescriptor. 
      file_desc: The file containing the enum descriptor. 
      containing_type: The type containing this enum. 
      scope: Scope containing available types. 
      top_level: If True, the enum is a top level symbol. If False, the enum 
          is defined inside a message. 
 
    Returns: 
      The added descriptor 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">package:</span>
      <span class="s1">enum_name = </span><span class="s3">'.'</span><span class="s1">.join((package</span><span class="s4">, </span><span class="s1">enum_proto.name))</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">enum_name = enum_proto.name</span>

    <span class="s4">if </span><span class="s1">file_desc </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s1">file_name = </span><span class="s4">None</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">file_name = file_desc.name</span>

    <span class="s1">values = [self._MakeEnumValueDescriptor(value</span><span class="s4">, </span><span class="s1">index)</span>
              <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">enumerate(enum_proto.value)]</span>
    <span class="s1">desc = descriptor.EnumDescriptor(name=enum_proto.name</span><span class="s4">,</span>
                                     <span class="s1">full_name=enum_name</span><span class="s4">,</span>
                                     <span class="s1">filename=file_name</span><span class="s4">,</span>
                                     <span class="s1">file=file_desc</span><span class="s4">,</span>
                                     <span class="s1">values=values</span><span class="s4">,</span>
                                     <span class="s1">containing_type=containing_type</span><span class="s4">,</span>
                                     <span class="s1">options=_OptionsOrNone(enum_proto)</span><span class="s4">,</span>
                                     <span class="s0"># pylint: disable=protected-access</span>
                                     <span class="s1">create_key=descriptor._internal_create_key)</span>
    <span class="s1">scope[</span><span class="s3">'.%s' </span><span class="s1">% enum_name] = desc</span>
    <span class="s1">self._CheckConflictRegister(desc</span><span class="s4">, </span><span class="s1">desc.full_name</span><span class="s4">, </span><span class="s1">desc.file.name)</span>
    <span class="s1">self._enum_descriptors[enum_name] = desc</span>

    <span class="s0"># Add top level enum values.</span>
    <span class="s4">if </span><span class="s1">top_level:</span>
      <span class="s4">for </span><span class="s1">value </span><span class="s4">in </span><span class="s1">values:</span>
        <span class="s1">full_name = _NormalizeFullyQualifiedName(</span>
            <span class="s3">'.'</span><span class="s1">.join((package</span><span class="s4">, </span><span class="s1">value.name)))</span>
        <span class="s1">self._CheckConflictRegister(value</span><span class="s4">, </span><span class="s1">full_name</span><span class="s4">, </span><span class="s1">file_name)</span>
        <span class="s1">self._top_enum_values[full_name] = value</span>

    <span class="s4">return </span><span class="s1">desc</span>

  <span class="s4">def </span><span class="s1">_MakeFieldDescriptor(self</span><span class="s4">, </span><span class="s1">field_proto</span><span class="s4">, </span><span class="s1">message_name</span><span class="s4">, </span><span class="s1">index</span><span class="s4">,</span>
                           <span class="s1">file_desc</span><span class="s4">, </span><span class="s1">is_extension=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Creates a field descriptor from a FieldDescriptorProto. 
 
    For message and enum type fields, this method will do a look up 
    in the pool for the appropriate descriptor for that type. If it 
    is unavailable, it will fall back to the _source function to 
    create it. If this type is still unavailable, construction will 
    fail. 
 
    Args: 
      field_proto: The proto describing the field. 
      message_name: The name of the containing message. 
      index: Index of the field 
      file_desc: The file containing the field descriptor. 
      is_extension: Indication that this field is for an extension. 
 
    Returns: 
      An initialized FieldDescriptor object 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">message_name:</span>
      <span class="s1">full_name = </span><span class="s3">'.'</span><span class="s1">.join((message_name</span><span class="s4">, </span><span class="s1">field_proto.name))</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">full_name = field_proto.name</span>

    <span class="s4">if </span><span class="s1">field_proto.json_name:</span>
      <span class="s1">json_name = field_proto.json_name</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">json_name = </span><span class="s4">None</span>

    <span class="s4">return </span><span class="s1">descriptor.FieldDescriptor(</span>
        <span class="s1">name=field_proto.name</span><span class="s4">,</span>
        <span class="s1">full_name=full_name</span><span class="s4">,</span>
        <span class="s1">index=index</span><span class="s4">,</span>
        <span class="s1">number=field_proto.number</span><span class="s4">,</span>
        <span class="s1">type=field_proto.type</span><span class="s4">,</span>
        <span class="s1">cpp_type=</span><span class="s4">None,</span>
        <span class="s1">message_type=</span><span class="s4">None,</span>
        <span class="s1">enum_type=</span><span class="s4">None,</span>
        <span class="s1">containing_type=</span><span class="s4">None,</span>
        <span class="s1">label=field_proto.label</span><span class="s4">,</span>
        <span class="s1">has_default_value=</span><span class="s4">False,</span>
        <span class="s1">default_value=</span><span class="s4">None,</span>
        <span class="s1">is_extension=is_extension</span><span class="s4">,</span>
        <span class="s1">extension_scope=</span><span class="s4">None,</span>
        <span class="s1">options=_OptionsOrNone(field_proto)</span><span class="s4">,</span>
        <span class="s1">json_name=json_name</span><span class="s4">,</span>
        <span class="s1">file=file_desc</span><span class="s4">,</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">create_key=descriptor._internal_create_key)</span>

  <span class="s4">def </span><span class="s1">_SetAllFieldTypes(self</span><span class="s4">, </span><span class="s1">package</span><span class="s4">, </span><span class="s1">desc_proto</span><span class="s4">, </span><span class="s1">scope):</span>
    <span class="s2">&quot;&quot;&quot;Sets all the descriptor's fields's types. 
 
    This method also sets the containing types on any extensions. 
 
    Args: 
      package: The current package of desc_proto. 
      desc_proto: The message descriptor to update. 
      scope: Enclosing scope of available types. 
    &quot;&quot;&quot;</span>

    <span class="s1">package = _PrefixWithDot(package)</span>

    <span class="s1">main_desc = self._GetTypeFromScope(package</span><span class="s4">, </span><span class="s1">desc_proto.name</span><span class="s4">, </span><span class="s1">scope)</span>

    <span class="s4">if </span><span class="s1">package == </span><span class="s3">'.'</span><span class="s1">:</span>
      <span class="s1">nested_package = _PrefixWithDot(desc_proto.name)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">nested_package = </span><span class="s3">'.'</span><span class="s1">.join([package</span><span class="s4">, </span><span class="s1">desc_proto.name])</span>

    <span class="s4">for </span><span class="s1">field_proto</span><span class="s4">, </span><span class="s1">field_desc </span><span class="s4">in </span><span class="s1">zip(desc_proto.field</span><span class="s4">, </span><span class="s1">main_desc.fields):</span>
      <span class="s1">self._SetFieldType(field_proto</span><span class="s4">, </span><span class="s1">field_desc</span><span class="s4">, </span><span class="s1">nested_package</span><span class="s4">, </span><span class="s1">scope)</span>

    <span class="s4">for </span><span class="s1">extension_proto</span><span class="s4">, </span><span class="s1">extension_desc </span><span class="s4">in </span><span class="s1">(</span>
        <span class="s1">zip(desc_proto.extension</span><span class="s4">, </span><span class="s1">main_desc.extensions)):</span>
      <span class="s1">extension_desc.containing_type = self._GetTypeFromScope(</span>
          <span class="s1">nested_package</span><span class="s4">, </span><span class="s1">extension_proto.extendee</span><span class="s4">, </span><span class="s1">scope)</span>
      <span class="s1">self._SetFieldType(extension_proto</span><span class="s4">, </span><span class="s1">extension_desc</span><span class="s4">, </span><span class="s1">nested_package</span><span class="s4">, </span><span class="s1">scope)</span>

    <span class="s4">for </span><span class="s1">nested_type </span><span class="s4">in </span><span class="s1">desc_proto.nested_type:</span>
      <span class="s1">self._SetAllFieldTypes(nested_package</span><span class="s4">, </span><span class="s1">nested_type</span><span class="s4">, </span><span class="s1">scope)</span>

  <span class="s4">def </span><span class="s1">_SetFieldType(self</span><span class="s4">, </span><span class="s1">field_proto</span><span class="s4">, </span><span class="s1">field_desc</span><span class="s4">, </span><span class="s1">package</span><span class="s4">, </span><span class="s1">scope):</span>
    <span class="s2">&quot;&quot;&quot;Sets the field's type, cpp_type, message_type and enum_type. 
 
    Args: 
      field_proto: Data about the field in proto format. 
      field_desc: The descriptor to modify. 
      package: The package the field's container is in. 
      scope: Enclosing scope of available types. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">field_proto.type_name:</span>
      <span class="s1">desc = self._GetTypeFromScope(package</span><span class="s4">, </span><span class="s1">field_proto.type_name</span><span class="s4">, </span><span class="s1">scope)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">desc = </span><span class="s4">None</span>

    <span class="s4">if not </span><span class="s1">field_proto.HasField(</span><span class="s3">'type'</span><span class="s1">):</span>
      <span class="s4">if </span><span class="s1">isinstance(desc</span><span class="s4">, </span><span class="s1">descriptor.Descriptor):</span>
        <span class="s1">field_proto.type = descriptor.FieldDescriptor.TYPE_MESSAGE</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">field_proto.type = descriptor.FieldDescriptor.TYPE_ENUM</span>

    <span class="s1">field_desc.cpp_type = descriptor.FieldDescriptor.ProtoTypeToCppProtoType(</span>
        <span class="s1">field_proto.type)</span>

    <span class="s4">if </span><span class="s1">(field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE</span>
        <span class="s4">or </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_GROUP):</span>
      <span class="s1">field_desc.message_type = desc</span>

    <span class="s4">if </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:</span>
      <span class="s1">field_desc.enum_type = desc</span>

    <span class="s4">if </span><span class="s1">field_proto.label == descriptor.FieldDescriptor.LABEL_REPEATED:</span>
      <span class="s1">field_desc.has_default_value = </span><span class="s4">False</span>
      <span class="s1">field_desc.default_value = []</span>
    <span class="s4">elif </span><span class="s1">field_proto.HasField(</span><span class="s3">'default_value'</span><span class="s1">):</span>
      <span class="s1">field_desc.has_default_value = </span><span class="s4">True</span>
      <span class="s4">if </span><span class="s1">(field_proto.type == descriptor.FieldDescriptor.TYPE_DOUBLE </span><span class="s4">or</span>
          <span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_FLOAT):</span>
        <span class="s1">field_desc.default_value = float(field_proto.default_value)</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_STRING:</span>
        <span class="s1">field_desc.default_value = field_proto.default_value</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_BOOL:</span>
        <span class="s1">field_desc.default_value = field_proto.default_value.lower() == </span><span class="s3">'true'</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:</span>
        <span class="s1">field_desc.default_value = field_desc.enum_type.values_by_name[</span>
            <span class="s1">field_proto.default_value].number</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_BYTES:</span>
        <span class="s1">field_desc.default_value = text_encoding.CUnescape(</span>
            <span class="s1">field_proto.default_value)</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE:</span>
        <span class="s1">field_desc.default_value = </span><span class="s4">None</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># All other types are of the &quot;int&quot; type.</span>
        <span class="s1">field_desc.default_value = int(field_proto.default_value)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">field_desc.has_default_value = </span><span class="s4">False</span>
      <span class="s4">if </span><span class="s1">(field_proto.type == descriptor.FieldDescriptor.TYPE_DOUBLE </span><span class="s4">or</span>
          <span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_FLOAT):</span>
        <span class="s1">field_desc.default_value = </span><span class="s5">0.0</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_STRING:</span>
        <span class="s1">field_desc.default_value = </span><span class="s3">u''</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_BOOL:</span>
        <span class="s1">field_desc.default_value = </span><span class="s4">False</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_ENUM:</span>
        <span class="s1">field_desc.default_value = field_desc.enum_type.values[</span><span class="s5">0</span><span class="s1">].number</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_BYTES:</span>
        <span class="s1">field_desc.default_value = </span><span class="s6">b''</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_MESSAGE:</span>
        <span class="s1">field_desc.default_value = </span><span class="s4">None</span>
      <span class="s4">elif </span><span class="s1">field_proto.type == descriptor.FieldDescriptor.TYPE_GROUP:</span>
        <span class="s1">field_desc.default_value = </span><span class="s4">None</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s0"># All other types are of the &quot;int&quot; type.</span>
        <span class="s1">field_desc.default_value = </span><span class="s5">0</span>

    <span class="s1">field_desc.type = field_proto.type</span>

  <span class="s4">def </span><span class="s1">_MakeEnumValueDescriptor(self</span><span class="s4">, </span><span class="s1">value_proto</span><span class="s4">, </span><span class="s1">index):</span>
    <span class="s2">&quot;&quot;&quot;Creates a enum value descriptor object from a enum value proto. 
 
    Args: 
      value_proto: The proto describing the enum value. 
      index: The index of the enum value. 
 
    Returns: 
      An initialized EnumValueDescriptor object. 
    &quot;&quot;&quot;</span>

    <span class="s4">return </span><span class="s1">descriptor.EnumValueDescriptor(</span>
        <span class="s1">name=value_proto.name</span><span class="s4">,</span>
        <span class="s1">index=index</span><span class="s4">,</span>
        <span class="s1">number=value_proto.number</span><span class="s4">,</span>
        <span class="s1">options=_OptionsOrNone(value_proto)</span><span class="s4">,</span>
        <span class="s1">type=</span><span class="s4">None,</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">create_key=descriptor._internal_create_key)</span>

  <span class="s4">def </span><span class="s1">_MakeServiceDescriptor(self</span><span class="s4">, </span><span class="s1">service_proto</span><span class="s4">, </span><span class="s1">service_index</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">,</span>
                             <span class="s1">package</span><span class="s4">, </span><span class="s1">file_desc):</span>
    <span class="s2">&quot;&quot;&quot;Make a protobuf ServiceDescriptor given a ServiceDescriptorProto. 
 
    Args: 
      service_proto: The descriptor_pb2.ServiceDescriptorProto protobuf message. 
      service_index: The index of the service in the File. 
      scope: Dict mapping short and full symbols to message and enum types. 
      package: Optional package name for the new message EnumDescriptor. 
      file_desc: The file containing the service descriptor. 
 
    Returns: 
      The added descriptor. 
    &quot;&quot;&quot;</span>

    <span class="s4">if </span><span class="s1">package:</span>
      <span class="s1">service_name = </span><span class="s3">'.'</span><span class="s1">.join((package</span><span class="s4">, </span><span class="s1">service_proto.name))</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">service_name = service_proto.name</span>

    <span class="s1">methods = [self._MakeMethodDescriptor(method_proto</span><span class="s4">, </span><span class="s1">service_name</span><span class="s4">, </span><span class="s1">package</span><span class="s4">,</span>
                                          <span class="s1">scope</span><span class="s4">, </span><span class="s1">index)</span>
               <span class="s4">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">method_proto </span><span class="s4">in </span><span class="s1">enumerate(service_proto.method)]</span>
    <span class="s1">desc = descriptor.ServiceDescriptor(</span>
        <span class="s1">name=service_proto.name</span><span class="s4">,</span>
        <span class="s1">full_name=service_name</span><span class="s4">,</span>
        <span class="s1">index=service_index</span><span class="s4">,</span>
        <span class="s1">methods=methods</span><span class="s4">,</span>
        <span class="s1">options=_OptionsOrNone(service_proto)</span><span class="s4">,</span>
        <span class="s1">file=file_desc</span><span class="s4">,</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">create_key=descriptor._internal_create_key)</span>
    <span class="s1">self._CheckConflictRegister(desc</span><span class="s4">, </span><span class="s1">desc.full_name</span><span class="s4">, </span><span class="s1">desc.file.name)</span>
    <span class="s1">self._service_descriptors[service_name] = desc</span>
    <span class="s4">return </span><span class="s1">desc</span>

  <span class="s4">def </span><span class="s1">_MakeMethodDescriptor(self</span><span class="s4">, </span><span class="s1">method_proto</span><span class="s4">, </span><span class="s1">service_name</span><span class="s4">, </span><span class="s1">package</span><span class="s4">, </span><span class="s1">scope</span><span class="s4">,</span>
                            <span class="s1">index):</span>
    <span class="s2">&quot;&quot;&quot;Creates a method descriptor from a MethodDescriptorProto. 
 
    Args: 
      method_proto: The proto describing the method. 
      service_name: The name of the containing service. 
      package: Optional package name to look up for types. 
      scope: Scope containing available types. 
      index: Index of the method in the service. 
 
    Returns: 
      An initialized MethodDescriptor object. 
    &quot;&quot;&quot;</span>
    <span class="s1">full_name = </span><span class="s3">'.'</span><span class="s1">.join((service_name</span><span class="s4">, </span><span class="s1">method_proto.name))</span>
    <span class="s1">input_type = self._GetTypeFromScope(</span>
        <span class="s1">package</span><span class="s4">, </span><span class="s1">method_proto.input_type</span><span class="s4">, </span><span class="s1">scope)</span>
    <span class="s1">output_type = self._GetTypeFromScope(</span>
        <span class="s1">package</span><span class="s4">, </span><span class="s1">method_proto.output_type</span><span class="s4">, </span><span class="s1">scope)</span>
    <span class="s4">return </span><span class="s1">descriptor.MethodDescriptor(</span>
        <span class="s1">name=method_proto.name</span><span class="s4">,</span>
        <span class="s1">full_name=full_name</span><span class="s4">,</span>
        <span class="s1">index=index</span><span class="s4">,</span>
        <span class="s1">containing_service=</span><span class="s4">None,</span>
        <span class="s1">input_type=input_type</span><span class="s4">,</span>
        <span class="s1">output_type=output_type</span><span class="s4">,</span>
        <span class="s1">client_streaming=method_proto.client_streaming</span><span class="s4">,</span>
        <span class="s1">server_streaming=method_proto.server_streaming</span><span class="s4">,</span>
        <span class="s1">options=_OptionsOrNone(method_proto)</span><span class="s4">,</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">create_key=descriptor._internal_create_key)</span>

  <span class="s4">def </span><span class="s1">_ExtractSymbols(self</span><span class="s4">, </span><span class="s1">descriptors):</span>
    <span class="s2">&quot;&quot;&quot;Pulls out all the symbols from descriptor protos. 
 
    Args: 
      descriptors: The messages to extract descriptors from. 
    Yields: 
      A two element tuple of the type name and descriptor object. 
    &quot;&quot;&quot;</span>

    <span class="s4">for </span><span class="s1">desc </span><span class="s4">in </span><span class="s1">descriptors:</span>
      <span class="s4">yield </span><span class="s1">(_PrefixWithDot(desc.full_name)</span><span class="s4">, </span><span class="s1">desc)</span>
      <span class="s4">for </span><span class="s1">symbol </span><span class="s4">in </span><span class="s1">self._ExtractSymbols(desc.nested_types):</span>
        <span class="s4">yield </span><span class="s1">symbol</span>
      <span class="s4">for </span><span class="s1">enum </span><span class="s4">in </span><span class="s1">desc.enum_types:</span>
        <span class="s4">yield </span><span class="s1">(_PrefixWithDot(enum.full_name)</span><span class="s4">, </span><span class="s1">enum)</span>

  <span class="s4">def </span><span class="s1">_GetDeps(self</span><span class="s4">, </span><span class="s1">dependencies</span><span class="s4">, </span><span class="s1">visited=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Recursively finds dependencies for file protos. 
 
    Args: 
      dependencies: The names of the files being depended on. 
      visited: The names of files already found. 
 
    Yields: 
      Each direct and indirect dependency. 
    &quot;&quot;&quot;</span>

    <span class="s1">visited = visited </span><span class="s4">or </span><span class="s1">set()</span>
    <span class="s4">for </span><span class="s1">dependency </span><span class="s4">in </span><span class="s1">dependencies:</span>
      <span class="s4">if </span><span class="s1">dependency </span><span class="s4">not in </span><span class="s1">visited:</span>
        <span class="s1">visited.add(dependency)</span>
        <span class="s1">dep_desc = self.FindFileByName(dependency)</span>
        <span class="s4">yield </span><span class="s1">dep_desc</span>
        <span class="s1">public_files = [d.name </span><span class="s4">for </span><span class="s1">d </span><span class="s4">in </span><span class="s1">dep_desc.public_dependencies]</span>
        <span class="s4">yield from </span><span class="s1">self._GetDeps(public_files</span><span class="s4">, </span><span class="s1">visited)</span>

  <span class="s4">def </span><span class="s1">_GetTypeFromScope(self</span><span class="s4">, </span><span class="s1">package</span><span class="s4">, </span><span class="s1">type_name</span><span class="s4">, </span><span class="s1">scope):</span>
    <span class="s2">&quot;&quot;&quot;Finds a given type name in the current scope. 
 
    Args: 
      package: The package the proto should be located in. 
      type_name: The name of the type to be found in the scope. 
      scope: Dict mapping short and full symbols to message and enum types. 
 
    Returns: 
      The descriptor for the requested type. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">type_name </span><span class="s4">not in </span><span class="s1">scope:</span>
      <span class="s1">components = _PrefixWithDot(package).split(</span><span class="s3">'.'</span><span class="s1">)</span>
      <span class="s4">while </span><span class="s1">components:</span>
        <span class="s1">possible_match = </span><span class="s3">'.'</span><span class="s1">.join(components + [type_name])</span>
        <span class="s4">if </span><span class="s1">possible_match </span><span class="s4">in </span><span class="s1">scope:</span>
          <span class="s1">type_name = possible_match</span>
          <span class="s4">break</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s1">components.pop(-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4">return </span><span class="s1">scope[type_name]</span>


<span class="s4">def </span><span class="s1">_PrefixWithDot(name):</span>
  <span class="s4">return </span><span class="s1">name </span><span class="s4">if </span><span class="s1">name.startswith(</span><span class="s3">'.'</span><span class="s1">) </span><span class="s4">else </span><span class="s3">'.%s' </span><span class="s1">% name</span>


<span class="s4">if </span><span class="s1">_USE_C_DESCRIPTORS:</span>
  <span class="s0"># TODO(amauryfa): This pool could be constructed from Python code, when we</span>
  <span class="s0"># support a flag like 'use_cpp_generated_pool=True'.</span>
  <span class="s0"># pylint: disable=protected-access</span>
  <span class="s1">_DEFAULT = descriptor._message.default_pool</span>
<span class="s4">else</span><span class="s1">:</span>
  <span class="s1">_DEFAULT = DescriptorPool()</span>


<span class="s4">def </span><span class="s1">Default():</span>
  <span class="s4">return </span><span class="s1">_DEFAULT</span>
</pre>
</body>
</html>