<html>
<head>
<title>figure.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
figure.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
`matplotlib.figure` implements the following classes: 
 
`Figure` 
    Top level `~matplotlib.artist.Artist`, which holds all plot elements. 
    Many methods are implemented in `FigureBase`. 
 
`SubFigure` 
    A logical figure inside a figure, usually added to a figure (or parent 
    `SubFigure`) with `Figure.add_subfigure` or `Figure.subfigures` methods 
    (provisional API v3.4). 
 
`SubplotParams` 
    Control the default spacing between subplots. 
 
See :ref:`figure_explanation` for narrative on how figures are used in 
Matplotlib. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">ExitStack</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_blocking_input</span><span class="s2">, </span><span class="s1">backend_bases</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">, </span><span class="s1">projections</span>
<span class="s2">from </span><span class="s1">matplotlib.artist </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Artist</span><span class="s2">, </span><span class="s1">allow_rasterization</span><span class="s2">, </span><span class="s1">_finalize_rasterization)</span>
<span class="s2">from </span><span class="s1">matplotlib.backend_bases </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DrawEvent</span><span class="s2">, </span><span class="s1">FigureCanvasBase</span><span class="s2">, </span><span class="s1">NonGuiException</span><span class="s2">, </span><span class="s1">MouseButton</span><span class="s2">, </span><span class="s1">_get_renderer)</span>
<span class="s2">import </span><span class="s1">matplotlib._api </span><span class="s2">as </span><span class="s1">_api</span>
<span class="s2">import </span><span class="s1">matplotlib.cbook </span><span class="s2">as </span><span class="s1">cbook</span>
<span class="s2">import </span><span class="s1">matplotlib.colorbar </span><span class="s2">as </span><span class="s1">cbar</span>
<span class="s2">import </span><span class="s1">matplotlib.image </span><span class="s2">as </span><span class="s1">mimage</span>

<span class="s2">from </span><span class="s1">matplotlib.axes </span><span class="s2">import </span><span class="s1">Axes</span>
<span class="s2">from </span><span class="s1">matplotlib.gridspec </span><span class="s2">import </span><span class="s1">GridSpec</span>
<span class="s2">from </span><span class="s1">matplotlib.layout_engine </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ConstrainedLayoutEngine</span><span class="s2">, </span><span class="s1">TightLayoutEngine</span><span class="s2">, </span><span class="s1">LayoutEngine</span><span class="s2">,</span>
    <span class="s1">PlaceHolderLayoutEngine</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">matplotlib.legend </span><span class="s2">as </span><span class="s1">mlegend</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">Rectangle</span>
<span class="s2">from </span><span class="s1">matplotlib.text </span><span class="s2">import </span><span class="s1">Text</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">(Affine2D</span><span class="s2">, </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxTransformTo</span><span class="s2">,</span>
                                   <span class="s1">TransformedBbox)</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">_stale_figure_callback(self</span><span class="s2">, </span><span class="s1">val):</span>
    <span class="s2">if </span><span class="s1">self.figure:</span>
        <span class="s1">self.figure.stale = val</span>


<span class="s2">class </span><span class="s1">_AxesStack:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper class to track axes in a figure. 
 
    Axes are tracked both in the order in which they have been added 
    (``self._axes`` insertion/iteration order) and in the separate &quot;gca&quot; stack 
    (which is the index to which they map in the ``self._axes`` dict). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._axes = {}  </span><span class="s3"># Mapping of axes to &quot;gca&quot; order.</span>
        <span class="s1">self._counter = itertools.count()</span>

    <span class="s2">def </span><span class="s1">as_list(self):</span>
        <span class="s0">&quot;&quot;&quot;List the axes that have been added to the figure.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[*self._axes]  </span><span class="s3"># This relies on dict preserving order.</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Remove the axes from the stack.&quot;&quot;&quot;</span>
        <span class="s1">self._axes.pop(a)</span>

    <span class="s2">def </span><span class="s1">bubble(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Move an axes, which must already exist in the stack, to the top.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">self._axes:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Axes has not been added yet&quot;</span><span class="s1">)</span>
        <span class="s1">self._axes[a] = next(self._counter)</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Add an axes to the stack, ignoring it if already present.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">not in </span><span class="s1">self._axes:</span>
            <span class="s1">self._axes[a] = next(self._counter)</span>

    <span class="s2">def </span><span class="s1">current(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the active axes, or None if the stack is empty.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">max(self._axes</span><span class="s2">, </span><span class="s1">key=self._axes.__getitem__</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">SubplotParams:</span>
    <span class="s0">&quot;&quot;&quot; 
    A class to hold the parameters for a subplot. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">None, </span><span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">right=</span><span class="s2">None, </span><span class="s1">top=</span><span class="s2">None,</span>
                 <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Defaults are given by :rc:`figure.subplot.[name]`. 
 
        Parameters 
        ---------- 
        left : float 
            The position of the left edge of the subplots, 
            as a fraction of the figure width. 
        right : float 
            The position of the right edge of the subplots, 
            as a fraction of the figure width. 
        bottom : float 
            The position of the bottom edge of the subplots, 
            as a fraction of the figure height. 
        top : float 
            The position of the top edge of the subplots, 
            as a fraction of the figure height. 
        wspace : float 
            The width of the padding between subplots, 
            as a fraction of the average Axes width. 
        hspace : float 
            The height of the padding between subplots, 
            as a fraction of the average Axes height. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;left&quot;</span><span class="s2">, </span><span class="s4">&quot;bottom&quot;</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s2">, </span><span class="s4">&quot;top&quot;</span><span class="s2">, </span><span class="s4">&quot;wspace&quot;</span><span class="s2">, </span><span class="s4">&quot;hspace&quot;</span><span class="s1">]:</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">f&quot;figure.subplot.</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">])</span>
        <span class="s1">self.update(left</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">wspace</span><span class="s2">, </span><span class="s1">hspace)</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">None, </span><span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">right=</span><span class="s2">None, </span><span class="s1">top=</span><span class="s2">None,</span>
               <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the dimensions of the passed parameters. *None* means unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">((left </span><span class="s2">if </span><span class="s1">left </span><span class="s2">is not None else </span><span class="s1">self.left)</span>
                <span class="s1">&gt;= (right </span><span class="s2">if </span><span class="s1">right </span><span class="s2">is not None else </span><span class="s1">self.right)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'left cannot be &gt;= right'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">((bottom </span><span class="s2">if </span><span class="s1">bottom </span><span class="s2">is not None else </span><span class="s1">self.bottom)</span>
                <span class="s1">&gt;= (top </span><span class="s2">if </span><span class="s1">top </span><span class="s2">is not None else </span><span class="s1">self.top)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'bottom cannot be &gt;= top'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">left </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.left = left</span>
        <span class="s2">if </span><span class="s1">right </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.right = right</span>
        <span class="s2">if </span><span class="s1">bottom </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.bottom = bottom</span>
        <span class="s2">if </span><span class="s1">top </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.top = top</span>
        <span class="s2">if </span><span class="s1">wspace </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.wspace = wspace</span>
        <span class="s2">if </span><span class="s1">hspace </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.hspace = hspace</span>


<span class="s2">class </span><span class="s1">FigureBase(Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for `.Figure` and `.SubFigure` containing the methods that add 
    artists to the figure or subfigure, create Axes, etc. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__()</span>
        <span class="s3"># remove the non-figure artist _axes property</span>
        <span class="s3"># as it makes no sense for a figure to be _in_ an Axes</span>
        <span class="s3"># this is used by the property methods in the artist base class</span>
        <span class="s3"># which are over-ridden in this class</span>
        <span class="s2">del </span><span class="s1">self._axes</span>

        <span class="s1">self._suptitle = </span><span class="s2">None</span>
        <span class="s1">self._supxlabel = </span><span class="s2">None</span>
        <span class="s1">self._supylabel = </span><span class="s2">None</span>

        <span class="s3"># groupers to keep track of x and y labels we want to align.</span>
        <span class="s3"># see self.align_xlabels and self.align_ylabels and</span>
        <span class="s3"># axis._get_tick_boxes_siblings</span>
        <span class="s1">self._align_label_groups = {</span><span class="s4">&quot;x&quot;</span><span class="s1">: cbook.Grouper()</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">: cbook.Grouper()}</span>

        <span class="s1">self.figure = self</span>
        <span class="s1">self._localaxes = []  </span><span class="s3"># track all axes</span>
        <span class="s1">self.artists = []</span>
        <span class="s1">self.lines = []</span>
        <span class="s1">self.patches = []</span>
        <span class="s1">self.texts = []</span>
        <span class="s1">self.images = []</span>
        <span class="s1">self.legends = []</span>
        <span class="s1">self.subfigs = []</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self.suppressComposite = </span><span class="s2">None</span>
        <span class="s1">self.set(**kwargs)</span>

    <span class="s2">def </span><span class="s1">_get_draw_artists(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Also runs apply_aspect&quot;&quot;&quot;</span>
        <span class="s1">artists = self.get_children()</span>
        <span class="s2">for </span><span class="s1">sfig </span><span class="s2">in </span><span class="s1">self.subfigs:</span>
            <span class="s1">artists.remove(sfig)</span>
            <span class="s1">childa = sfig.get_children()</span>
            <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">childa:</span>
                <span class="s2">if </span><span class="s1">child </span><span class="s2">in </span><span class="s1">artists:</span>
                    <span class="s1">artists.remove(child)</span>

        <span class="s1">artists.remove(self.patch)</span>
        <span class="s1">artists = sorted(</span>
            <span class="s1">(artist </span><span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">artists </span><span class="s2">if not </span><span class="s1">artist.get_animated())</span><span class="s2">,</span>
            <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">artist: artist.get_zorder())</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._localaxes:</span>
            <span class="s1">locator = ax.get_axes_locator()</span>
            <span class="s1">ax.apply_aspect(locator(ax</span><span class="s2">, </span><span class="s1">renderer) </span><span class="s2">if </span><span class="s1">locator </span><span class="s2">else None</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">ax.get_children():</span>
                <span class="s2">if </span><span class="s1">hasattr(child</span><span class="s2">, </span><span class="s4">'apply_aspect'</span><span class="s1">):</span>
                    <span class="s1">locator = child.get_axes_locator()</span>
                    <span class="s1">child.apply_aspect(</span>
                        <span class="s1">locator(child</span><span class="s2">, </span><span class="s1">renderer) </span><span class="s2">if </span><span class="s1">locator </span><span class="s2">else None</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">artists</span>

    <span class="s2">def </span><span class="s1">autofmt_xdate(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">bottom=</span><span class="s5">0.2</span><span class="s2">, </span><span class="s1">rotation=</span><span class="s5">30</span><span class="s2">, </span><span class="s1">ha=</span><span class="s4">'right'</span><span class="s2">, </span><span class="s1">which=</span><span class="s4">'major'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Date ticklabels often overlap, so it is useful to rotate them 
        and right align them.  Also, a common use case is a number of 
        subplots with shared x-axis where the x-axis is date data.  The 
        ticklabels are often long, and it helps to rotate them on the 
        bottom subplot and turn them off on other subplots, as well as 
        turn off xlabels. 
 
        Parameters 
        ---------- 
        bottom : float, default: 0.2 
            The bottom of the subplots for `subplots_adjust`. 
        rotation : float, default: 30 degrees 
            The rotation angle of the xtick labels in degrees. 
        ha : {'left', 'center', 'right'}, default: 'right' 
            The horizontal alignment of the xticklabels. 
        which : {'major', 'minor', 'both'}, default: 'major' 
            Selects which ticklabels to rotate. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'major'</span><span class="s2">, </span><span class="s4">'minor'</span><span class="s2">, </span><span class="s4">'both'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">which=which)</span>
        <span class="s1">allsubplots = all(ax.get_subplotspec() </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes)</span>
        <span class="s2">if </span><span class="s1">len(self.axes) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">self.axes[</span><span class="s5">0</span><span class="s1">].get_xticklabels(which=which):</span>
                <span class="s1">label.set_ha(ha)</span>
                <span class="s1">label.set_rotation(rotation)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">allsubplots:</span>
                <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.get_axes():</span>
                    <span class="s2">if </span><span class="s1">ax.get_subplotspec().is_last_row():</span>
                        <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">ax.get_xticklabels(which=which):</span>
                            <span class="s1">label.set_ha(ha)</span>
                            <span class="s1">label.set_rotation(rotation)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">for </span><span class="s1">label </span><span class="s2">in </span><span class="s1">ax.get_xticklabels(which=which):</span>
                            <span class="s1">label.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
                        <span class="s1">ax.set_xlabel(</span><span class="s4">''</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">allsubplots:</span>
            <span class="s1">self.subplots_adjust(bottom=bottom)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Get a list of artists contained in the figure.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self.patch</span><span class="s2">,</span>
                <span class="s1">*self.artists</span><span class="s2">,</span>
                <span class="s1">*self._localaxes</span><span class="s2">,</span>
                <span class="s1">*self.lines</span><span class="s2">,</span>
                <span class="s1">*self.patches</span><span class="s2">,</span>
                <span class="s1">*self.texts</span><span class="s2">,</span>
                <span class="s1">*self.images</span><span class="s2">,</span>
                <span class="s1">*self.legends</span><span class="s2">,</span>
                <span class="s1">*self.subfigs]</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether the mouse event occurred on the figure. 
 
        Returns 
        ------- 
            bool, {} 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent</span><span class="s2">, </span><span class="s1">figure=self)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s1">inside = self.bbox.contains(mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y)</span>
        <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s1">@_api.delete_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;args&quot;</span><span class="s1">)</span>
    <span class="s1">@_api.delete_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;kwargs&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">self.bbox</span>

    <span class="s2">def </span><span class="s1">_suplabels(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a centered %(name)s to the figure. 
 
        Parameters 
        ---------- 
        t : str 
            The %(name)s text. 
        x : float, default: %(x0)s 
            The x location of the text in figure coordinates. 
        y : float, default: %(y0)s 
            The y location of the text in figure coordinates. 
        horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s 
            The horizontal alignment of the text relative to (*x*, *y*). 
        verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \ 
default: %(va)s 
            The vertical alignment of the text relative to (*x*, *y*). 
        fontsize, size : default: :rc:`figure.%(rc)ssize` 
            The font size of the text. See `.Text.set_size` for possible 
            values. 
        fontweight, weight : default: :rc:`figure.%(rc)sweight` 
            The font weight of the text. See `.Text.set_weight` for possible 
            values. 
 
        Returns 
        ------- 
        text 
            The `.Text` instance of the %(name)s. 
 
        Other Parameters 
        ---------------- 
        fontproperties : None or dict, optional 
            A dict of font properties. If *fontproperties* is given the 
            default values for font size and weight are taken from the 
            `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and 
            :rc:`figure.%(rc)sweight` are ignored in this case. 
 
        **kwargs 
            Additional kwargs are `matplotlib.text.Text` properties. 
        &quot;&quot;&quot;</span>

        <span class="s1">suplab = getattr(self</span><span class="s2">, </span><span class="s1">info[</span><span class="s4">'name'</span><span class="s1">])</span>

        <span class="s1">x = kwargs.pop(</span><span class="s4">'x'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">y = kwargs.pop(</span><span class="s4">'y'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">info[</span><span class="s4">'name'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'_supxlabel'</span><span class="s2">, </span><span class="s4">'_suptitle'</span><span class="s1">]:</span>
            <span class="s1">autopos = y </span><span class="s2">is None</span>
        <span class="s2">elif </span><span class="s1">info[</span><span class="s4">'name'</span><span class="s1">] == </span><span class="s4">'_supylabel'</span><span class="s1">:</span>
            <span class="s1">autopos = x </span><span class="s2">is None</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x = info[</span><span class="s4">'x0'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">y = info[</span><span class="s4">'y0'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s4">'horizontalalignment' </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s4">'ha' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s4">'horizontalalignment'</span><span class="s1">] = info[</span><span class="s4">'ha'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s4">'verticalalignment' </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s4">'va' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s4">'verticalalignment'</span><span class="s1">] = info[</span><span class="s4">'va'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s4">'rotation' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s1">kwargs[</span><span class="s4">'rotation'</span><span class="s1">] = info[</span><span class="s4">'rotation'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s4">'fontproperties' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s2">if </span><span class="s4">'fontsize' </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s4">'size' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
                <span class="s1">kwargs[</span><span class="s4">'size'</span><span class="s1">] = mpl.rcParams[info[</span><span class="s4">'size'</span><span class="s1">]]</span>
            <span class="s2">if </span><span class="s4">'fontweight' </span><span class="s2">not in </span><span class="s1">kwargs </span><span class="s2">and </span><span class="s4">'weight' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
                <span class="s1">kwargs[</span><span class="s4">'weight'</span><span class="s1">] = mpl.rcParams[info[</span><span class="s4">'weight'</span><span class="s1">]]</span>

        <span class="s1">sup = self.text(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s1">suplab </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">suplab.set_text(t)</span>
            <span class="s1">suplab.set_position((x</span><span class="s2">, </span><span class="s1">y))</span>
            <span class="s1">suplab.update_from(sup)</span>
            <span class="s1">sup.remove()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">suplab = sup</span>
        <span class="s1">suplab._autopos = autopos</span>
        <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">info[</span><span class="s4">'name'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">suplab)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">suplab</span>

    <span class="s1">@_docstring.Substitution(x0=</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">y0=</span><span class="s5">0.98</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'suptitle'</span><span class="s2">, </span><span class="s1">ha=</span><span class="s4">'center'</span><span class="s2">,</span>
                             <span class="s1">va=</span><span class="s4">'top'</span><span class="s2">, </span><span class="s1">rc=</span><span class="s4">'title'</span><span class="s1">)</span>
    <span class="s1">@_docstring.copy(_suplabels)</span>
    <span class="s2">def </span><span class="s1">suptitle(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># docstring from _suplabels...</span>
        <span class="s1">info = {</span><span class="s4">'name'</span><span class="s1">: </span><span class="s4">'_suptitle'</span><span class="s2">, </span><span class="s4">'x0'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s2">, </span><span class="s4">'y0'</span><span class="s1">: </span><span class="s5">0.98</span><span class="s2">,</span>
                <span class="s4">'ha'</span><span class="s1">: </span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'va'</span><span class="s1">: </span><span class="s4">'top'</span><span class="s2">, </span><span class="s4">'rotation'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s4">'size'</span><span class="s1">: </span><span class="s4">'figure.titlesize'</span><span class="s2">, </span><span class="s4">'weight'</span><span class="s1">: </span><span class="s4">'figure.titleweight'</span><span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self._suplabels(t</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@_docstring.Substitution(x0=</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">y0=</span><span class="s5">0.01</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'supxlabel'</span><span class="s2">, </span><span class="s1">ha=</span><span class="s4">'center'</span><span class="s2">,</span>
                             <span class="s1">va=</span><span class="s4">'bottom'</span><span class="s2">, </span><span class="s1">rc=</span><span class="s4">'label'</span><span class="s1">)</span>
    <span class="s1">@_docstring.copy(_suplabels)</span>
    <span class="s2">def </span><span class="s1">supxlabel(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># docstring from _suplabels...</span>
        <span class="s1">info = {</span><span class="s4">'name'</span><span class="s1">: </span><span class="s4">'_supxlabel'</span><span class="s2">, </span><span class="s4">'x0'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s2">, </span><span class="s4">'y0'</span><span class="s1">: </span><span class="s5">0.01</span><span class="s2">,</span>
                <span class="s4">'ha'</span><span class="s1">: </span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'va'</span><span class="s1">: </span><span class="s4">'bottom'</span><span class="s2">, </span><span class="s4">'rotation'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">,</span>
                <span class="s4">'size'</span><span class="s1">: </span><span class="s4">'figure.labelsize'</span><span class="s2">, </span><span class="s4">'weight'</span><span class="s1">: </span><span class="s4">'figure.labelweight'</span><span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self._suplabels(t</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@_docstring.Substitution(x0=</span><span class="s5">0.02</span><span class="s2">, </span><span class="s1">y0=</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'supylabel'</span><span class="s2">, </span><span class="s1">ha=</span><span class="s4">'left'</span><span class="s2">,</span>
                             <span class="s1">va=</span><span class="s4">'center'</span><span class="s2">, </span><span class="s1">rc=</span><span class="s4">'label'</span><span class="s1">)</span>
    <span class="s1">@_docstring.copy(_suplabels)</span>
    <span class="s2">def </span><span class="s1">supylabel(self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># docstring from _suplabels...</span>
        <span class="s1">info = {</span><span class="s4">'name'</span><span class="s1">: </span><span class="s4">'_supylabel'</span><span class="s2">, </span><span class="s4">'x0'</span><span class="s1">: </span><span class="s5">0.02</span><span class="s2">, </span><span class="s4">'y0'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s2">,</span>
                <span class="s4">'ha'</span><span class="s1">: </span><span class="s4">'left'</span><span class="s2">, </span><span class="s4">'va'</span><span class="s1">: </span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'rotation'</span><span class="s1">: </span><span class="s4">'vertical'</span><span class="s2">,</span>
                <span class="s4">'rotation_mode'</span><span class="s1">: </span><span class="s4">'anchor'</span><span class="s2">, </span><span class="s4">'size'</span><span class="s1">: </span><span class="s4">'figure.labelsize'</span><span class="s2">,</span>
                <span class="s4">'weight'</span><span class="s1">: </span><span class="s4">'figure.labelweight'</span><span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self._suplabels(t</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the edge color of the Figure rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.patch.get_edgecolor()</span>

    <span class="s2">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the face color of the Figure rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.patch.get_facecolor()</span>

    <span class="s2">def </span><span class="s1">get_frameon(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the figure's background patch visibility, i.e. 
        whether the figure background will be drawn. Equivalent to 
        ``Figure.patch.get_visible()``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.patch.get_visible()</span>

    <span class="s2">def </span><span class="s1">set_linewidth(self</span><span class="s2">, </span><span class="s1">linewidth):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the line width of the Figure rectangle. 
 
        Parameters 
        ---------- 
        linewidth : number 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patch.set_linewidth(linewidth)</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the line width of the Figure rectangle. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.patch.get_linewidth()</span>

    <span class="s2">def </span><span class="s1">set_edgecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the edge color of the Figure rectangle. 
 
        Parameters 
        ---------- 
        color : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patch.set_edgecolor(color)</span>

    <span class="s2">def </span><span class="s1">set_facecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the face color of the Figure rectangle. 
 
        Parameters 
        ---------- 
        color : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patch.set_facecolor(color)</span>

    <span class="s2">def </span><span class="s1">set_frameon(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the figure's background patch visibility, i.e. 
        whether the figure background will be drawn. Equivalent to 
        ``Figure.patch.set_visible()``. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patch.set_visible(b)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">frameon = property(get_frameon</span><span class="s2">, </span><span class="s1">set_frameon)</span>

    <span class="s2">def </span><span class="s1">add_artist(self</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add an `.Artist` to the figure. 
 
        Usually artists are added to `~.axes.Axes` objects using 
        `.Axes.add_artist`; this method can be used in the rare cases where 
        one needs to add artists directly to the figure instead. 
 
        Parameters 
        ---------- 
        artist : `~matplotlib.artist.Artist` 
            The artist to add to the figure. If the added artist has no 
            transform previously set, its transform will be set to 
            ``figure.transSubfigure``. 
        clip : bool, default: False 
            Whether the added artist should be clipped by the figure patch. 
 
        Returns 
        ------- 
        `~matplotlib.artist.Artist` 
            The added artist. 
        &quot;&quot;&quot;</span>
        <span class="s1">artist.set_figure(self)</span>
        <span class="s1">self.artists.append(artist)</span>
        <span class="s1">artist._remove_method = self.artists.remove</span>

        <span class="s2">if not </span><span class="s1">artist.is_transform_set():</span>
            <span class="s1">artist.set_transform(self.transSubfigure)</span>

        <span class="s2">if </span><span class="s1">clip:</span>
            <span class="s1">artist.set_clip_path(self.patch)</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">artist</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">add_axes(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add an `~.axes.Axes` to the figure. 
 
        Call signatures:: 
 
            add_axes(rect, projection=None, polar=False, **kwargs) 
            add_axes(ax) 
 
        Parameters 
        ---------- 
        rect : tuple (left, bottom, width, height) 
            The dimensions (left, bottom, width, height) of the new 
            `~.axes.Axes`. All quantities are in fractions of figure width and 
            height. 
 
        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \ 
'polar', 'rectilinear', str}, optional 
            The projection type of the `~.axes.Axes`. *str* is the name of 
            a custom projection, see `~matplotlib.projections`. The default 
            None results in a 'rectilinear' projection. 
 
        polar : bool, default: False 
            If True, equivalent to projection='polar'. 
 
        axes_class : subclass type of `~.axes.Axes`, optional 
            The `.axes.Axes` subclass that is instantiated.  This parameter 
            is incompatible with *projection* and *polar*.  See 
            :ref:`axisartist_users-guide-index` for examples. 
 
        sharex, sharey : `~.axes.Axes`, optional 
            Share the x or y `~matplotlib.axis` with sharex and/or sharey. 
            The axis will have the same limits, ticks, and scale as the axis 
            of the shared axes. 
 
        label : str 
            A label for the returned Axes. 
 
        Returns 
        ------- 
        `~.axes.Axes`, or a subclass of `~.axes.Axes` 
            The returned axes class depends on the projection used. It is 
            `~.axes.Axes` if rectilinear projection is used and 
            `.projections.polar.PolarAxes` if polar projection is used. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            This method also takes the keyword arguments for 
            the returned Axes class. The keyword arguments for the 
            rectilinear Axes class `~.axes.Axes` can be found in 
            the following table but there might also be other keyword 
            arguments if another projection is used, see the actual Axes 
            class. 
 
            %(Axes:kwdoc)s 
 
        Notes 
        ----- 
        In rare circumstances, `.add_axes` may be called with a single 
        argument, an Axes instance already created in the present figure but 
        not in the figure's list of Axes. 
 
        See Also 
        -------- 
        .Figure.add_subplot 
        .pyplot.subplot 
        .pyplot.axes 
        .Figure.subplots 
        .pyplot.subplots 
 
        Examples 
        -------- 
        Some simple examples:: 
 
            rect = l, b, w, h 
            fig = plt.figure() 
            fig.add_axes(rect) 
            fig.add_axes(rect, frameon=False, facecolor='g') 
            fig.add_axes(rect, polar=True) 
            ax = fig.add_axes(rect, projection='polar') 
            fig.delaxes(ax) 
            fig.add_axes(ax) 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">len(args) </span><span class="s2">and </span><span class="s4">'rect' </span><span class="s2">not in </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;add_axes() missing 1 required positional argument: 'rect'&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s4">'rect' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s2">if </span><span class="s1">len(args):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;add_axes() got multiple values for argument 'rect'&quot;</span><span class="s1">)</span>
            <span class="s1">args = (kwargs.pop(</span><span class="s4">'rect'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Axes):</span>
            <span class="s1">a = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">key = a._projection_init</span>
            <span class="s2">if </span><span class="s1">a.get_figure() </span><span class="s2">is not </span><span class="s1">self:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;The Axes must have been created in the present figure&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rect = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(rect).all():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'all entries in rect must be finite '</span>
                                 <span class="s4">'not {}'</span><span class="s1">.format(rect))</span>
            <span class="s1">projection_class</span><span class="s2">, </span><span class="s1">pkw = self._process_projection_requirements(</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

            <span class="s3"># create the new axes using the axes class given</span>
            <span class="s1">a = projection_class(self</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">**pkw)</span>
            <span class="s1">key = (projection_class</span><span class="s2">, </span><span class="s1">pkw)</span>
        <span class="s2">return </span><span class="s1">self._add_axes_internal(a</span><span class="s2">, </span><span class="s1">key)</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">add_subplot(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add an `~.axes.Axes` to the figure as part of a subplot arrangement. 
 
        Call signatures:: 
 
           add_subplot(nrows, ncols, index, **kwargs) 
           add_subplot(pos, **kwargs) 
           add_subplot(ax) 
           add_subplot() 
 
        Parameters 
        ---------- 
        *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1) 
            The position of the subplot described by one of 
 
            - Three integers (*nrows*, *ncols*, *index*). The subplot will 
              take the *index* position on a grid with *nrows* rows and 
              *ncols* columns. *index* starts at 1 in the upper left corner 
              and increases to the right.  *index* can also be a two-tuple 
              specifying the (*first*, *last*) indices (1-based, and including 
              *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))`` 
              makes a subplot that spans the upper 2/3 of the figure. 
            - A 3-digit integer. The digits are interpreted as if given 
              separately as three single-digit integers, i.e. 
              ``fig.add_subplot(235)`` is the same as 
              ``fig.add_subplot(2, 3, 5)``. Note that this can only be used 
              if there are no more than 9 subplots. 
            - A `.SubplotSpec`. 
 
            In rare circumstances, `.add_subplot` may be called with a single 
            argument, a subplot Axes instance already created in the 
            present figure but not in the figure's list of Axes. 
 
        projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \ 
'polar', 'rectilinear', str}, optional 
            The projection type of the subplot (`~.axes.Axes`). *str* is the 
            name of a custom projection, see `~matplotlib.projections`. The 
            default None results in a 'rectilinear' projection. 
 
        polar : bool, default: False 
            If True, equivalent to projection='polar'. 
 
        axes_class : subclass type of `~.axes.Axes`, optional 
            The `.axes.Axes` subclass that is instantiated.  This parameter 
            is incompatible with *projection* and *polar*.  See 
            :ref:`axisartist_users-guide-index` for examples. 
 
        sharex, sharey : `~.axes.Axes`, optional 
            Share the x or y `~matplotlib.axis` with sharex and/or sharey. 
            The axis will have the same limits, ticks, and scale as the axis 
            of the shared axes. 
 
        label : str 
            A label for the returned Axes. 
 
        Returns 
        ------- 
        `~.axes.Axes` 
 
            The Axes of the subplot. The returned Axes can actually be an 
            instance of a subclass, such as `.projections.polar.PolarAxes` for 
            polar projections. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            This method also takes the keyword arguments for the returned Axes 
            base class; except for the *figure* argument. The keyword arguments 
            for the rectilinear base class `~.axes.Axes` can be found in 
            the following table but there might also be other keyword 
            arguments if another projection is used. 
 
            %(Axes:kwdoc)s 
 
        See Also 
        -------- 
        .Figure.add_axes 
        .pyplot.subplot 
        .pyplot.axes 
        .Figure.subplots 
        .pyplot.subplots 
 
        Examples 
        -------- 
        :: 
 
            fig = plt.figure() 
 
            fig.add_subplot(231) 
            ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general 
 
            fig.add_subplot(232, frameon=False)  # subplot with no frame 
            fig.add_subplot(233, projection='polar')  # polar subplot 
            fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1 
            fig.add_subplot(235, facecolor=&quot;red&quot;)  # red subplot 
 
            ax1.remove()  # delete ax1 from the figure 
            fig.add_subplot(ax1)  # add ax1 back to the figure 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s4">'figure' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s3"># Axes itself allows for a 'figure' kwarg, but since we want to</span>
            <span class="s3"># bind the created Axes to self, it is not allowed here.</span>
            <span class="s2">raise </span><span class="s1">_api.kwarg_error(</span><span class="s4">&quot;add_subplot&quot;</span><span class="s2">, </span><span class="s4">&quot;figure&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(len(args) == </span><span class="s5">1</span>
                <span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mpl.axes._base._AxesBase)</span>
                <span class="s2">and </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">].get_subplotspec()):</span>
            <span class="s1">ax = args[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">key = ax._projection_init</span>
            <span class="s2">if </span><span class="s1">ax.get_figure() </span><span class="s2">is not </span><span class="s1">self:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The Axes must have been created in &quot;</span>
                                 <span class="s4">&quot;the present figure&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">args:</span>
                <span class="s1">args = (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3"># Normalize correct ijk values to (i, j, k) here so that</span>
            <span class="s3"># add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will</span>
            <span class="s3"># trigger errors later (via SubplotSpec._from_subplot_args).</span>
            <span class="s2">if </span><span class="s1">(len(args) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Integral)</span>
                    <span class="s2">and </span><span class="s5">100 </span><span class="s1">&lt;= args[</span><span class="s5">0</span><span class="s1">] &lt;= </span><span class="s5">999</span><span class="s1">):</span>
                <span class="s1">args = tuple(map(int</span><span class="s2">, </span><span class="s1">str(args[</span><span class="s5">0</span><span class="s1">])))</span>
            <span class="s1">projection_class</span><span class="s2">, </span><span class="s1">pkw = self._process_projection_requirements(</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">ax = projection_class(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**pkw)</span>
            <span class="s1">key = (projection_class</span><span class="s2">, </span><span class="s1">pkw)</span>
        <span class="s2">return </span><span class="s1">self._add_axes_internal(ax</span><span class="s2">, </span><span class="s1">key)</span>

    <span class="s2">def </span><span class="s1">_add_axes_internal(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Private helper for `add_axes` and `add_subplot`.&quot;&quot;&quot;</span>
        <span class="s1">self._axstack.add(ax)</span>
        <span class="s2">if </span><span class="s1">ax </span><span class="s2">not in </span><span class="s1">self._localaxes:</span>
            <span class="s1">self._localaxes.append(ax)</span>
        <span class="s1">self.sca(ax)</span>
        <span class="s1">ax._remove_method = self.delaxes</span>
        <span class="s3"># this is to support plt.subplot's re-selection logic</span>
        <span class="s1">ax._projection_init = key</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">ax.stale_callback = _stale_figure_callback</span>
        <span class="s2">return </span><span class="s1">ax</span>

    <span class="s2">def </span><span class="s1">subplots(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">ncols=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">sharex=</span><span class="s2">False, </span><span class="s1">sharey=</span><span class="s2">False,</span>
                 <span class="s1">squeeze=</span><span class="s2">True, </span><span class="s1">width_ratios=</span><span class="s2">None, </span><span class="s1">height_ratios=</span><span class="s2">None,</span>
                 <span class="s1">subplot_kw=</span><span class="s2">None, </span><span class="s1">gridspec_kw=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a set of subplots to this figure. 
 
        This utility wrapper makes it convenient to create common layouts of 
        subplots in a single call. 
 
        Parameters 
        ---------- 
        nrows, ncols : int, default: 1 
            Number of rows/columns of the subplot grid. 
 
        sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False 
            Controls sharing of x-axis (*sharex*) or y-axis (*sharey*): 
 
            - True or 'all': x- or y-axis will be shared among all subplots. 
            - False or 'none': each subplot x- or y-axis will be independent. 
            - 'row': each subplot row will share an x- or y-axis. 
            - 'col': each subplot column will share an x- or y-axis. 
 
            When subplots have a shared x-axis along a column, only the x tick 
            labels of the bottom subplot are created. Similarly, when subplots 
            have a shared y-axis along a row, only the y tick labels of the 
            first column subplot are created. To later turn other subplots' 
            ticklabels on, use `~matplotlib.axes.Axes.tick_params`. 
 
            When subplots have a shared axis that has units, calling 
            `.Axis.set_units` will update each axis with the new units. 
 
        squeeze : bool, default: True 
            - If True, extra dimensions are squeezed out from the returned 
              array of Axes: 
 
              - if only one subplot is constructed (nrows=ncols=1), the 
                resulting single Axes object is returned as a scalar. 
              - for Nx1 or 1xM subplots, the returned object is a 1D numpy 
                object array of Axes objects. 
              - for NxM, subplots with N&gt;1 and M&gt;1 are returned as a 2D array. 
 
            - If False, no squeezing at all is done: the returned Axes object 
              is always a 2D array containing Axes instances, even if it ends 
              up being 1x1. 
 
        width_ratios : array-like of length *ncols*, optional 
            Defines the relative widths of the columns. Each column gets a 
            relative width of ``width_ratios[i] / sum(width_ratios)``. 
            If not given, all columns will have the same width.  Equivalent 
            to ``gridspec_kw={'width_ratios': [...]}``. 
 
        height_ratios : array-like of length *nrows*, optional 
            Defines the relative heights of the rows. Each row gets a 
            relative height of ``height_ratios[i] / sum(height_ratios)``. 
            If not given, all rows will have the same height. Equivalent 
            to ``gridspec_kw={'height_ratios': [...]}``. 
 
        subplot_kw : dict, optional 
            Dict with keywords passed to the `.Figure.add_subplot` call used to 
            create each subplot. 
 
        gridspec_kw : dict, optional 
            Dict with keywords passed to the 
            `~matplotlib.gridspec.GridSpec` constructor used to create 
            the grid the subplots are placed on. 
 
        Returns 
        ------- 
        `~.axes.Axes` or array of Axes 
            Either a single `~matplotlib.axes.Axes` object or an array of Axes 
            objects if more than one subplot was created. The dimensions of the 
            resulting array can be controlled with the *squeeze* keyword, see 
            above. 
 
        See Also 
        -------- 
        .pyplot.subplots 
        .Figure.add_subplot 
        .pyplot.subplot 
 
        Examples 
        -------- 
        :: 
 
            # First create some toy data: 
            x = np.linspace(0, 2*np.pi, 400) 
            y = np.sin(x**2) 
 
            # Create a figure 
            plt.figure() 
 
            # Create a subplot 
            ax = fig.subplots() 
            ax.plot(x, y) 
            ax.set_title('Simple plot') 
 
            # Create two subplots and unpack the output array immediately 
            ax1, ax2 = fig.subplots(1, 2, sharey=True) 
            ax1.plot(x, y) 
            ax1.set_title('Sharing Y axis') 
            ax2.scatter(x, y) 
 
            # Create four polar Axes and access them through the returned array 
            axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar')) 
            axes[0, 0].plot(x, y) 
            axes[1, 1].scatter(x, y) 
 
            # Share an X-axis with each column of subplots 
            fig.subplots(2, 2, sharex='col') 
 
            # Share a Y-axis with each row of subplots 
            fig.subplots(2, 2, sharey='row') 
 
            # Share both X- and Y-axes with all subplots 
            fig.subplots(2, 2, sharex='all', sharey='all') 
 
            # Note that this is the same as 
            fig.subplots(2, 2, sharex=True, sharey=True) 
        &quot;&quot;&quot;</span>
        <span class="s1">gridspec_kw = dict(gridspec_kw </span><span class="s2">or </span><span class="s1">{})</span>
        <span class="s2">if </span><span class="s1">height_ratios </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s4">'height_ratios' </span><span class="s2">in </span><span class="s1">gridspec_kw:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'height_ratios' must not be defined both as &quot;</span>
                                 <span class="s4">&quot;parameter and as key in 'gridspec_kw'&quot;</span><span class="s1">)</span>
            <span class="s1">gridspec_kw[</span><span class="s4">'height_ratios'</span><span class="s1">] = height_ratios</span>
        <span class="s2">if </span><span class="s1">width_ratios </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s4">'width_ratios' </span><span class="s2">in </span><span class="s1">gridspec_kw:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'width_ratios' must not be defined both as &quot;</span>
                                 <span class="s4">&quot;parameter and as key in 'gridspec_kw'&quot;</span><span class="s1">)</span>
            <span class="s1">gridspec_kw[</span><span class="s4">'width_ratios'</span><span class="s1">] = width_ratios</span>

        <span class="s1">gs = self.add_gridspec(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">figure=self</span><span class="s2">, </span><span class="s1">**gridspec_kw)</span>
        <span class="s1">axs = gs.subplots(sharex=sharex</span><span class="s2">, </span><span class="s1">sharey=sharey</span><span class="s2">, </span><span class="s1">squeeze=squeeze</span><span class="s2">,</span>
                          <span class="s1">subplot_kw=subplot_kw)</span>
        <span class="s2">return </span><span class="s1">axs</span>

    <span class="s2">def </span><span class="s1">delaxes(self</span><span class="s2">, </span><span class="s1">ax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove the `~.axes.Axes` *ax* from the figure; update the current Axes. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">_reset_locators_and_formatters(axis):</span>
            <span class="s3"># Set the formatters and locators to be associated with axis</span>
            <span class="s3"># (where previously they may have been associated with another</span>
            <span class="s3"># Axis instance)</span>
            <span class="s1">axis.get_major_formatter().set_axis(axis)</span>
            <span class="s1">axis.get_major_locator().set_axis(axis)</span>
            <span class="s1">axis.get_minor_formatter().set_axis(axis)</span>
            <span class="s1">axis.get_minor_locator().set_axis(axis)</span>

        <span class="s2">def </span><span class="s1">_break_share_link(ax</span><span class="s2">, </span><span class="s1">grouper):</span>
            <span class="s1">siblings = grouper.get_siblings(ax)</span>
            <span class="s2">if </span><span class="s1">len(siblings) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">grouper.remove(ax)</span>
                <span class="s2">for </span><span class="s1">last_ax </span><span class="s2">in </span><span class="s1">siblings:</span>
                    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is not </span><span class="s1">last_ax:</span>
                        <span class="s2">return </span><span class="s1">last_ax</span>
            <span class="s2">return None</span>

        <span class="s1">self._axstack.remove(ax)</span>
        <span class="s1">self._axobservers.process(</span><span class="s4">&quot;_axes_change_event&quot;</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s1">self._localaxes.remove(ax)</span>

        <span class="s3"># Break link between any shared axes</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">ax._axis_names:</span>
            <span class="s1">last_ax = _break_share_link(ax</span><span class="s2">, </span><span class="s1">ax._shared_axes[name])</span>
            <span class="s2">if </span><span class="s1">last_ax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_reset_locators_and_formatters(getattr(last_ax</span><span class="s2">, </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">axis&quot;</span><span class="s1">))</span>

        <span class="s3"># Break link between any twinned axes</span>
        <span class="s1">_break_share_link(ax</span><span class="s2">, </span><span class="s1">ax._twinned_axes)</span>

    <span class="s2">def </span><span class="s1">clear(self</span><span class="s2">, </span><span class="s1">keep_observers=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Clear the figure. 
 
        Parameters 
        ---------- 
        keep_observers: bool, default: False 
            Set *keep_observers* to True if, for example, 
            a gui widget is tracking the Axes in the figure. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.suppressComposite = </span><span class="s2">None</span>

        <span class="s3"># first clear the axes in any subfigures</span>
        <span class="s2">for </span><span class="s1">subfig </span><span class="s2">in </span><span class="s1">self.subfigs:</span>
            <span class="s1">subfig.clear(keep_observers=keep_observers)</span>
        <span class="s1">self.subfigs = []</span>

        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">tuple(self.axes):  </span><span class="s3"># Iterate over the copy.</span>
            <span class="s1">ax.clear()</span>
            <span class="s1">self.delaxes(ax)  </span><span class="s3"># Remove ax from self._axstack.</span>

        <span class="s1">self.artists = []</span>
        <span class="s1">self.lines = []</span>
        <span class="s1">self.patches = []</span>
        <span class="s1">self.texts = []</span>
        <span class="s1">self.images = []</span>
        <span class="s1">self.legends = []</span>
        <span class="s2">if not </span><span class="s1">keep_observers:</span>
            <span class="s1">self._axobservers = cbook.CallbackRegistry()</span>
        <span class="s1">self._suptitle = </span><span class="s2">None</span>
        <span class="s1">self._supxlabel = </span><span class="s2">None</span>
        <span class="s1">self._supylabel = </span><span class="s2">None</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s3"># synonym for `clear`.</span>
    <span class="s2">def </span><span class="s1">clf(self</span><span class="s2">, </span><span class="s1">keep_observers=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        [*Discouraged*] Alias for the `clear()` method. 
 
        .. admonition:: Discouraged 
 
            The use of ``clf()`` is discouraged. Use ``clear()`` instead. 
 
        Parameters 
        ---------- 
        keep_observers: bool, default: False 
            Set *keep_observers* to True if, for example, 
            a gui widget is tracking the Axes in the figure. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.clear(keep_observers=keep_observers)</span>

    <span class="s3"># Note: the docstring below is modified with replace for the pyplot</span>
    <span class="s3"># version of this function because the method name differs (plt.figlegend)</span>
    <span class="s3"># the replacements are:</span>
    <span class="s3">#    &quot; legend(&quot; -&gt; &quot; figlegend(&quot; for the signatures</span>
    <span class="s3">#    &quot;fig.legend(&quot; -&gt; &quot;plt.figlegend&quot; for the code examples</span>
    <span class="s3">#    &quot;ax.plot&quot; -&gt; &quot;plt.plot&quot; for consistency in using pyplot when able</span>
    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">legend(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Place a legend on the figure. 
 
        Call signatures:: 
 
            legend() 
            legend(handles, labels) 
            legend(handles=handles) 
            legend(labels) 
 
        The call signatures correspond to the following different ways to use 
        this method: 
 
        **1. Automatic detection of elements to be shown in the legend** 
 
        The elements to be added to the legend are automatically determined, 
        when you do not pass in any extra arguments. 
 
        In this case, the labels are taken from the artist. You can specify 
        them either at artist creation or by calling the 
        :meth:`~.Artist.set_label` method on the artist:: 
 
            ax.plot([1, 2, 3], label='Inline label') 
            fig.legend() 
 
        or:: 
 
            line, = ax.plot([1, 2, 3]) 
            line.set_label('Label via method') 
            fig.legend() 
 
        Specific lines can be excluded from the automatic legend element 
        selection by defining a label starting with an underscore. 
        This is default for all artists, so calling `.Figure.legend` without 
        any arguments and without setting the labels manually will result in 
        no legend being drawn. 
 
 
        **2. Explicitly listing the artists and labels in the legend** 
 
        For full control of which artists have a legend entry, it is possible 
        to pass an iterable of legend artists followed by an iterable of 
        legend labels respectively:: 
 
            fig.legend([line1, line2, line3], ['label1', 'label2', 'label3']) 
 
 
        **3. Explicitly listing the artists in the legend** 
 
        This is similar to 2, but the labels are taken from the artists' 
        label properties. Example:: 
 
            line1, = ax1.plot([1, 2, 3], label='label1') 
            line2, = ax2.plot([1, 2, 3], label='label2') 
            fig.legend(handles=[line1, line2]) 
 
 
        **4. Labeling existing plot elements** 
 
        .. admonition:: Discouraged 
 
            This call signature is discouraged, because the relation between 
            plot elements and labels is only implicit by their order and can 
            easily be mixed up. 
 
        To make a legend for all artists on all Axes, call this function with 
        an iterable of strings, one for each legend item. For example:: 
 
            fig, (ax1, ax2) = plt.subplots(1, 2) 
            ax1.plot([1, 3, 5], color='blue') 
            ax2.plot([2, 4, 6], color='red') 
            fig.legend(['the blues', 'the reds']) 
 
 
        Parameters 
        ---------- 
        handles : list of `.Artist`, optional 
            A list of Artists (lines, patches) to be added to the legend. 
            Use this together with *labels*, if you need full control on what 
            is shown in the legend and the automatic mechanism described above 
            is not sufficient. 
 
            The length of handles and labels should be the same in this 
            case. If they are not, they are truncated to the smaller length. 
 
        labels : list of str, optional 
            A list of labels to show next to the artists. 
            Use this together with *handles*, if you need full control on what 
            is shown in the legend and the automatic mechanism described above 
            is not sufficient. 
 
        Returns 
        ------- 
        `~matplotlib.legend.Legend` 
 
        Other Parameters 
        ---------------- 
        %(_legend_kw_figure)s 
 
 
        See Also 
        -------- 
        .Axes.legend 
 
        Notes 
        ----- 
        Some artists are not supported by this function.  See 
        :doc:`/tutorials/intermediate/legend_guide` for details. 
        &quot;&quot;&quot;</span>

        <span class="s1">handles</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">extra_args</span><span class="s2">, </span><span class="s1">kwargs = mlegend._parse_legend_args(</span>
                <span class="s1">self.axes</span><span class="s2">,</span>
                <span class="s1">*args</span><span class="s2">,</span>
                <span class="s1">**kwargs)</span>
        <span class="s3"># check for third arg</span>
        <span class="s2">if </span><span class="s1">len(extra_args):</span>
            <span class="s3"># _api.warn_deprecated(</span>
            <span class="s3">#     &quot;2.1&quot;,</span>
            <span class="s3">#     message=&quot;Figure.legend will accept no more than two &quot;</span>
            <span class="s3">#     &quot;positional arguments in the future.  Use &quot;</span>
            <span class="s3">#     &quot;'fig.legend(handles, labels, loc=location)' &quot;</span>
            <span class="s3">#     &quot;instead.&quot;)</span>
            <span class="s3"># kwargs['loc'] = extra_args[0]</span>
            <span class="s3"># extra_args = extra_args[1:]</span>
            <span class="s2">pass</span>
        <span class="s1">transform = kwargs.pop(</span><span class="s4">'bbox_transform'</span><span class="s2">, </span><span class="s1">self.transSubfigure)</span>
        <span class="s3"># explicitly set the bbox transform if the user hasn't.</span>
        <span class="s1">l = mlegend.Legend(self</span><span class="s2">, </span><span class="s1">handles</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">*extra_args</span><span class="s2">,</span>
                           <span class="s1">bbox_transform=transform</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.legends.append(l)</span>
        <span class="s1">l._remove_method = self.legends.remove</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">l</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">text(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">fontdict=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add text to figure. 
 
        Parameters 
        ---------- 
        x, y : float 
            The position to place the text. By default, this is in figure 
            coordinates, floats in [0, 1]. The coordinate system can be changed 
            using the *transform* keyword. 
 
        s : str 
            The text string. 
 
        fontdict : dict, optional 
            A dictionary to override the default text properties. If not given, 
            the defaults are determined by :rc:`font.*`. Properties passed as 
            *kwargs* override the corresponding ones given in *fontdict*. 
 
        Returns 
        ------- 
        `~.text.Text` 
 
        Other Parameters 
        ---------------- 
        **kwargs : `~matplotlib.text.Text` properties 
            Other miscellaneous text parameters. 
 
            %(Text:kwdoc)s 
 
        See Also 
        -------- 
        .Axes.text 
        .pyplot.text 
        &quot;&quot;&quot;</span>
        <span class="s1">effective_kwargs = {</span>
            <span class="s4">'transform'</span><span class="s1">: self.transSubfigure</span><span class="s2">,</span>
            <span class="s1">**(fontdict </span><span class="s2">if </span><span class="s1">fontdict </span><span class="s2">is not None else </span><span class="s1">{})</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">text = Text(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">text=s</span><span class="s2">, </span><span class="s1">**effective_kwargs)</span>
        <span class="s1">text.set_figure(self)</span>
        <span class="s1">text.stale_callback = _stale_figure_callback</span>

        <span class="s1">self.texts.append(text)</span>
        <span class="s1">text._remove_method = self.texts.remove</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">text</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">colorbar(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">mappable</span><span class="s2">, </span><span class="s1">cax=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">use_gridspec=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a colorbar to a plot. 
 
        Parameters 
        ---------- 
        mappable 
            The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`, 
            `.ContourSet`, etc.) described by this colorbar.  This argument is 
            mandatory for the `.Figure.colorbar` method but optional for the 
            `.pyplot.colorbar` function, which sets the default to the current 
            image. 
 
            Note that one can create a `.ScalarMappable` &quot;on-the-fly&quot; to 
            generate colorbars not attached to a previously drawn artist, e.g. 
            :: 
 
                fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax) 
 
        cax : `~matplotlib.axes.Axes`, optional 
            Axes into which the colorbar will be drawn. 
 
        ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional 
            One or more parent axes from which space for a new colorbar axes 
            will be stolen, if *cax* is None.  This has no effect if *cax* is 
            set. 
 
        use_gridspec : bool, optional 
            If *cax* is ``None``, a new *cax* is created as an instance of 
            Axes.  If *ax* is positioned with a subplotspec and *use_gridspec* 
            is ``True``, then *cax* is also positioned with a subplotspec. 
 
        Returns 
        ------- 
        colorbar : `~matplotlib.colorbar.Colorbar` 
 
        Other Parameters 
        ---------------- 
        %(_make_axes_kw_doc)s 
        %(_colormap_kw_doc)s 
 
        Notes 
        ----- 
        If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is 
        included automatically. 
 
        The *shrink* kwarg provides a simple way to scale the colorbar with 
        respect to the axes. Note that if *cax* is specified, it determines the 
        size of the colorbar and *shrink* and *aspect* kwargs are ignored. 
 
        For more precise control, you can manually specify the positions of the 
        axes objects in which the mappable and the colorbar are drawn.  In this 
        case, do not use any of the axes properties kwargs. 
 
        It is known that some vector graphics viewers (svg and pdf) renders 
        white gaps between segments of the colorbar.  This is due to bugs in 
        the viewers, not Matplotlib.  As a workaround, the colorbar can be 
        rendered with overlapping segments:: 
 
            cbar = colorbar() 
            cbar.solids.set_edgecolor(&quot;face&quot;) 
            draw() 
 
        However, this has negative consequences in other circumstances, e.g. 
        with semi-transparent images (alpha &lt; 1) and colorbar extensions; 
        therefore, this workaround is not used by default (see issue #1188). 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ax = getattr(mappable</span><span class="s2">, </span><span class="s4">&quot;axes&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(self.get_layout_engine() </span><span class="s2">is not None and</span>
                <span class="s2">not </span><span class="s1">self.get_layout_engine().colorbar_gridspec):</span>
            <span class="s1">use_gridspec = </span><span class="s2">False</span>
        <span class="s3"># Store the value of gca so that we can set it back later on.</span>
        <span class="s2">if </span><span class="s1">cax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">_api.warn_deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">message=(</span>
                    <span class="s4">'Unable to determine Axes to steal space for Colorbar. '</span>
                    <span class="s4">'Using gca(), but will raise in the future. '</span>
                    <span class="s4">'Either provide the *cax* argument to use as the Axes for '</span>
                    <span class="s4">'the Colorbar, provide the *ax* argument to steal space '</span>
                    <span class="s4">'from it, or add *mappable* to an Axes.'</span><span class="s1">))</span>
                <span class="s1">ax = self.gca()</span>
            <span class="s1">current_ax = self.gca()</span>
            <span class="s1">userax = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">(use_gridspec</span>
                    <span class="s2">and </span><span class="s1">isinstance(ax</span><span class="s2">, </span><span class="s1">mpl.axes._base._AxesBase)</span>
                    <span class="s2">and </span><span class="s1">ax.get_subplotspec()):</span>
                <span class="s1">cax</span><span class="s2">, </span><span class="s1">kwargs = cbar.make_axes_gridspec(ax</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cax</span><span class="s2">, </span><span class="s1">kwargs = cbar.make_axes(ax</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">cax.grid(visible=</span><span class="s2">False, </span><span class="s1">which=</span><span class="s4">'both'</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">userax = </span><span class="s2">True</span>

        <span class="s3"># need to remove kws that cannot be passed to Colorbar</span>
        <span class="s1">NON_COLORBAR_KEYS = [</span><span class="s4">'fraction'</span><span class="s2">, </span><span class="s4">'pad'</span><span class="s2">, </span><span class="s4">'shrink'</span><span class="s2">, </span><span class="s4">'aspect'</span><span class="s2">, </span><span class="s4">'anchor'</span><span class="s2">,</span>
                             <span class="s4">'panchor'</span><span class="s1">]</span>
        <span class="s1">cb_kw = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">NON_COLORBAR_KEYS}</span>

        <span class="s1">cb = cbar.Colorbar(cax</span><span class="s2">, </span><span class="s1">mappable</span><span class="s2">, </span><span class="s1">**cb_kw)</span>

        <span class="s2">if not </span><span class="s1">userax:</span>
            <span class="s1">self.sca(current_ax)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">cb</span>

    <span class="s2">def </span><span class="s1">subplots_adjust(self</span><span class="s2">, </span><span class="s1">left=</span><span class="s2">None, </span><span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">right=</span><span class="s2">None, </span><span class="s1">top=</span><span class="s2">None,</span>
                        <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust the subplot layout parameters. 
 
        Unset parameters are left unmodified; initial values are given by 
        :rc:`figure.subplot.[name]`. 
 
        Parameters 
        ---------- 
        left : float, optional 
            The position of the left edge of the subplots, 
            as a fraction of the figure width. 
        right : float, optional 
            The position of the right edge of the subplots, 
            as a fraction of the figure width. 
        bottom : float, optional 
            The position of the bottom edge of the subplots, 
            as a fraction of the figure height. 
        top : float, optional 
            The position of the top edge of the subplots, 
            as a fraction of the figure height. 
        wspace : float, optional 
            The width of the padding between subplots, 
            as a fraction of the average Axes width. 
        hspace : float, optional 
            The height of the padding between subplots, 
            as a fraction of the average Axes height. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(self.get_layout_engine() </span><span class="s2">is not None and</span>
                <span class="s2">not </span><span class="s1">self.get_layout_engine().adjust_compatible):</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s4">&quot;This figure was using a layout engine that is &quot;</span>
                <span class="s4">&quot;incompatible with subplots_adjust and/or tight_layout; &quot;</span>
                <span class="s4">&quot;not calling subplots_adjust.&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s1">self.subplotpars.update(left</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">wspace</span><span class="s2">, </span><span class="s1">hspace)</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes:</span>
            <span class="s2">if </span><span class="s1">ax.get_subplotspec() </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">ax._set_position(ax.get_subplotspec().get_position(self))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">align_xlabels(self</span><span class="s2">, </span><span class="s1">axs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Align the xlabels of subplots in the same subplot column if label 
        alignment is being done automatically (i.e. the label position is 
        not manually set). 
 
        Alignment persists for draw events after this is called. 
 
        If a label is on the bottom, it is aligned with labels on Axes that 
        also have their label on the bottom and that have the same 
        bottom-most subplot row.  If the label is on the top, 
        it is aligned with labels on Axes with the same top-most row. 
 
        Parameters 
        ---------- 
        axs : list of `~matplotlib.axes.Axes` 
            Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes` 
            to align the xlabels. 
            Default is to align all Axes on the figure. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.align_ylabels 
        matplotlib.figure.Figure.align_labels 
 
        Notes 
        ----- 
        This assumes that ``axs`` are from the same `.GridSpec`, so that 
        their `.SubplotSpec` positions correspond to figure positions. 
 
        Examples 
        -------- 
        Example with rotated xtick labels:: 
 
            fig, axs = plt.subplots(1, 2) 
            for tick in axs[0].get_xticklabels(): 
                tick.set_rotation(55) 
            axs[0].set_xlabel('XLabel 0') 
            axs[1].set_xlabel('XLabel 1') 
            fig.align_xlabels() 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">axs = self.axes</span>
        <span class="s1">axs = [ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">np.ravel(axs) </span><span class="s2">if </span><span class="s1">ax.get_subplotspec() </span><span class="s2">is not None</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axs:</span>
            <span class="s1">_log.debug(</span><span class="s4">' Working on: %s'</span><span class="s2">, </span><span class="s1">ax.get_xlabel())</span>
            <span class="s1">rowspan = ax.get_subplotspec().rowspan</span>
            <span class="s1">pos = ax.xaxis.get_label_position()  </span><span class="s3"># top or bottom</span>
            <span class="s3"># Search through other axes for label positions that are same as</span>
            <span class="s3"># this one and that share the appropriate row number.</span>
            <span class="s3"># Add to a grouper associated with each axes of siblings.</span>
            <span class="s3"># This list is inspected in `axis.draw` by</span>
            <span class="s3"># `axis._update_label_position`.</span>
            <span class="s2">for </span><span class="s1">axc </span><span class="s2">in </span><span class="s1">axs:</span>
                <span class="s2">if </span><span class="s1">axc.xaxis.get_label_position() == pos:</span>
                    <span class="s1">rowspanc = axc.get_subplotspec().rowspan</span>
                    <span class="s2">if </span><span class="s1">(pos == </span><span class="s4">'top' </span><span class="s2">and </span><span class="s1">rowspan.start == rowspanc.start </span><span class="s2">or</span>
                            <span class="s1">pos == </span><span class="s4">'bottom' </span><span class="s2">and </span><span class="s1">rowspan.stop == rowspanc.stop):</span>
                        <span class="s3"># grouper for groups of xlabels to align</span>
                        <span class="s1">self._align_label_groups[</span><span class="s4">'x'</span><span class="s1">].join(ax</span><span class="s2">, </span><span class="s1">axc)</span>

    <span class="s2">def </span><span class="s1">align_ylabels(self</span><span class="s2">, </span><span class="s1">axs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Align the ylabels of subplots in the same subplot column if label 
        alignment is being done automatically (i.e. the label position is 
        not manually set). 
 
        Alignment persists for draw events after this is called. 
 
        If a label is on the left, it is aligned with labels on Axes that 
        also have their label on the left and that have the same 
        left-most subplot column.  If the label is on the right, 
        it is aligned with labels on Axes with the same right-most column. 
 
        Parameters 
        ---------- 
        axs : list of `~matplotlib.axes.Axes` 
            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes` 
            to align the ylabels. 
            Default is to align all Axes on the figure. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.align_xlabels 
        matplotlib.figure.Figure.align_labels 
 
        Notes 
        ----- 
        This assumes that ``axs`` are from the same `.GridSpec`, so that 
        their `.SubplotSpec` positions correspond to figure positions. 
 
        Examples 
        -------- 
        Example with large yticks labels:: 
 
            fig, axs = plt.subplots(2, 1) 
            axs[0].plot(np.arange(0, 1000, 50)) 
            axs[0].set_ylabel('YLabel 0') 
            axs[1].set_ylabel('YLabel 1') 
            fig.align_ylabels() 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">axs = self.axes</span>
        <span class="s1">axs = [ax </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">np.ravel(axs) </span><span class="s2">if </span><span class="s1">ax.get_subplotspec() </span><span class="s2">is not None</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axs:</span>
            <span class="s1">_log.debug(</span><span class="s4">' Working on: %s'</span><span class="s2">, </span><span class="s1">ax.get_ylabel())</span>
            <span class="s1">colspan = ax.get_subplotspec().colspan</span>
            <span class="s1">pos = ax.yaxis.get_label_position()  </span><span class="s3"># left or right</span>
            <span class="s3"># Search through other axes for label positions that are same as</span>
            <span class="s3"># this one and that share the appropriate column number.</span>
            <span class="s3"># Add to a list associated with each axes of siblings.</span>
            <span class="s3"># This list is inspected in `axis.draw` by</span>
            <span class="s3"># `axis._update_label_position`.</span>
            <span class="s2">for </span><span class="s1">axc </span><span class="s2">in </span><span class="s1">axs:</span>
                <span class="s2">if </span><span class="s1">axc.yaxis.get_label_position() == pos:</span>
                    <span class="s1">colspanc = axc.get_subplotspec().colspan</span>
                    <span class="s2">if </span><span class="s1">(pos == </span><span class="s4">'left' </span><span class="s2">and </span><span class="s1">colspan.start == colspanc.start </span><span class="s2">or</span>
                            <span class="s1">pos == </span><span class="s4">'right' </span><span class="s2">and </span><span class="s1">colspan.stop == colspanc.stop):</span>
                        <span class="s3"># grouper for groups of ylabels to align</span>
                        <span class="s1">self._align_label_groups[</span><span class="s4">'y'</span><span class="s1">].join(ax</span><span class="s2">, </span><span class="s1">axc)</span>

    <span class="s2">def </span><span class="s1">align_labels(self</span><span class="s2">, </span><span class="s1">axs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Align the xlabels and ylabels of subplots with the same subplots 
        row or column (respectively) if label alignment is being 
        done automatically (i.e. the label position is not manually set). 
 
        Alignment persists for draw events after this is called. 
 
        Parameters 
        ---------- 
        axs : list of `~matplotlib.axes.Axes` 
            Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes` 
            to align the labels. 
            Default is to align all Axes on the figure. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.align_xlabels 
 
        matplotlib.figure.Figure.align_ylabels 
        &quot;&quot;&quot;</span>
        <span class="s1">self.align_xlabels(axs=axs)</span>
        <span class="s1">self.align_ylabels(axs=axs)</span>

    <span class="s2">def </span><span class="s1">add_gridspec(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">ncols=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a `.GridSpec` that has this figure as a parent.  This allows 
        complex layout of Axes in the figure. 
 
        Parameters 
        ---------- 
        nrows : int, default: 1 
            Number of rows in grid. 
 
        ncols : int, default: 1 
            Number of columns in grid. 
 
        Returns 
        ------- 
        `.GridSpec` 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            Keyword arguments are passed to `.GridSpec`. 
 
        See Also 
        -------- 
        matplotlib.pyplot.subplots 
 
        Examples 
        -------- 
        Adding a subplot that spans two rows:: 
 
            fig = plt.figure() 
            gs = fig.add_gridspec(2, 2) 
            ax1 = fig.add_subplot(gs[0, 0]) 
            ax2 = fig.add_subplot(gs[1, 0]) 
            # spans two rows: 
            ax3 = fig.add_subplot(gs[:, 1]) 
 
        &quot;&quot;&quot;</span>

        <span class="s1">_ = kwargs.pop(</span><span class="s4">'figure'</span><span class="s2">, None</span><span class="s1">)  </span><span class="s3"># pop in case user has added this...</span>
        <span class="s1">gs = GridSpec(nrows=nrows</span><span class="s2">, </span><span class="s1">ncols=ncols</span><span class="s2">, </span><span class="s1">figure=self</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">gs</span>

    <span class="s2">def </span><span class="s1">subfigures(self</span><span class="s2">, </span><span class="s1">nrows=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">ncols=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">squeeze=</span><span class="s2">True,</span>
                   <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None,</span>
                   <span class="s1">width_ratios=</span><span class="s2">None, </span><span class="s1">height_ratios=</span><span class="s2">None,</span>
                   <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a set of subfigures to this figure or subfigure. 
 
        A subfigure has the same artist methods as a figure, and is logically 
        the same as a figure, but cannot print itself. 
        See :doc:`/gallery/subplots_axes_and_figures/subfigures`. 
 
        Parameters 
        ---------- 
        nrows, ncols : int, default: 1 
            Number of rows/columns of the subfigure grid. 
 
        squeeze : bool, default: True 
            If True, extra dimensions are squeezed out from the returned 
            array of subfigures. 
 
        wspace, hspace : float, default: None 
            The amount of width/height reserved for space between subfigures, 
            expressed as a fraction of the average subfigure width/height. 
            If not given, the values will be inferred from a figure or 
            rcParams when necessary. 
 
        width_ratios : array-like of length *ncols*, optional 
            Defines the relative widths of the columns. Each column gets a 
            relative width of ``width_ratios[i] / sum(width_ratios)``. 
            If not given, all columns will have the same width. 
 
        height_ratios : array-like of length *nrows*, optional 
            Defines the relative heights of the rows. Each row gets a 
            relative height of ``height_ratios[i] / sum(height_ratios)``. 
            If not given, all rows will have the same height. 
        &quot;&quot;&quot;</span>
        <span class="s1">gs = GridSpec(nrows=nrows</span><span class="s2">, </span><span class="s1">ncols=ncols</span><span class="s2">, </span><span class="s1">figure=self</span><span class="s2">,</span>
                      <span class="s1">wspace=wspace</span><span class="s2">, </span><span class="s1">hspace=hspace</span><span class="s2">,</span>
                      <span class="s1">width_ratios=width_ratios</span><span class="s2">,</span>
                      <span class="s1">height_ratios=height_ratios)</span>

        <span class="s1">sfarr = np.empty((nrows</span><span class="s2">, </span><span class="s1">ncols)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(ncols):</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(nrows):</span>
                <span class="s1">sfarr[j</span><span class="s2">, </span><span class="s1">i] = self.add_subfigure(gs[j</span><span class="s2">, </span><span class="s1">i]</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">if </span><span class="s1">squeeze:</span>
            <span class="s3"># Discarding unneeded dimensions that equal 1.  If we only have one</span>
            <span class="s3"># subfigure, just return it instead of a 1-element array.</span>
            <span class="s2">return </span><span class="s1">sfarr.item() </span><span class="s2">if </span><span class="s1">sfarr.size == </span><span class="s5">1 </span><span class="s2">else </span><span class="s1">sfarr.squeeze()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Returned axis array will be always 2-d, even if nrows=ncols=1.</span>
            <span class="s2">return </span><span class="s1">sfarr</span>

    <span class="s2">def </span><span class="s1">add_subfigure(self</span><span class="s2">, </span><span class="s1">subplotspec</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a `.SubFigure` to the figure as part of a subplot arrangement. 
 
        Parameters 
        ---------- 
        subplotspec : `.gridspec.SubplotSpec` 
            Defines the region in a parent gridspec where the subfigure will 
            be placed. 
 
        Returns 
        ------- 
        `.SubFigure` 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            Are passed to the `.SubFigure` object. 
 
        See Also 
        -------- 
        .Figure.subfigures 
        &quot;&quot;&quot;</span>
        <span class="s1">sf = SubFigure(self</span><span class="s2">, </span><span class="s1">subplotspec</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.subfigs += [sf]</span>
        <span class="s2">return </span><span class="s1">sf</span>

    <span class="s2">def </span><span class="s1">sca(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Set the current Axes to be *a* and return *a*.&quot;&quot;&quot;</span>
        <span class="s1">self._axstack.bubble(a)</span>
        <span class="s1">self._axobservers.process(</span><span class="s4">&quot;_axes_change_event&quot;</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">return </span><span class="s1">a</span>

    <span class="s2">def </span><span class="s1">gca(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the current Axes. 
 
        If there is currently no Axes on this Figure, a new one is created 
        using `.Figure.add_subplot`.  (To test whether there is currently an 
        Axes on a Figure, check whether ``figure.axes`` is empty.  To test 
        whether there is currently a Figure on the pyplot figure stack, check 
        whether `.pyplot.get_fignums()` is empty.) 
        &quot;&quot;&quot;</span>
        <span class="s1">ax = self._axstack.current()</span>
        <span class="s2">return </span><span class="s1">ax </span><span class="s2">if </span><span class="s1">ax </span><span class="s2">is not None else </span><span class="s1">self.add_subplot()</span>

    <span class="s2">def </span><span class="s1">_gci(self):</span>
        <span class="s3"># Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the current colorable artist. 
 
        Specifically, returns the current `.ScalarMappable` instance (`.Image` 
        created by `imshow` or `figimage`, `.Collection` created by `pcolor` or 
        `scatter`, etc.), or *None* if no such instance has been defined. 
 
        The current image is an attribute of the current Axes, or the nearest 
        earlier Axes in the current figure that contains an image. 
 
        Notes 
        ----- 
        Historically, the only colorable artists were images; hence the name 
        ``gci`` (get current image). 
        &quot;&quot;&quot;</span>
        <span class="s3"># Look first for an image in the current Axes.</span>
        <span class="s1">ax = self._axstack.current()</span>
        <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s1">im = ax._gci()</span>
        <span class="s2">if </span><span class="s1">im </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">im</span>
        <span class="s3"># If there is no image in the current Axes, search for</span>
        <span class="s3"># one in a previously created Axes.  Whether this makes</span>
        <span class="s3"># sense is debatable, but it is the documented behavior.</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">reversed(self.axes):</span>
            <span class="s1">im = ax._gci()</span>
            <span class="s2">if </span><span class="s1">im </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">im</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_process_projection_requirements(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">axes_class=</span><span class="s2">None, </span><span class="s1">polar=</span><span class="s2">False, </span><span class="s1">projection=</span><span class="s2">None,</span>
            <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle the args/kwargs to add_axes/add_subplot/gca, returning:: 
 
            (axes_proj_class, proj_class_kwargs) 
 
        which can be used for new Axes initialization/identification. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">axes_class </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">polar </span><span class="s2">or </span><span class="s1">projection </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Cannot combine 'axes_class' and 'projection' or 'polar'&quot;</span><span class="s1">)</span>
            <span class="s1">projection_class = axes_class</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">if </span><span class="s1">polar:</span>
                <span class="s2">if </span><span class="s1">projection </span><span class="s2">is not None and </span><span class="s1">projection != </span><span class="s4">'polar'</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f&quot;polar=</span><span class="s2">{</span><span class="s1">polar</span><span class="s2">}</span><span class="s4">, yet projection=</span><span class="s2">{</span><span class="s1">projection</span><span class="s2">!r}</span><span class="s4">. &quot;</span>
                        <span class="s4">&quot;Only one of these arguments should be supplied.&quot;</span>
                    <span class="s1">)</span>
                <span class="s1">projection = </span><span class="s4">'polar'</span>

            <span class="s2">if </span><span class="s1">isinstance(projection</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">projection </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">projection_class = projections.get_projection_class(projection)</span>
            <span class="s2">elif </span><span class="s1">hasattr(projection</span><span class="s2">, </span><span class="s4">'_as_mpl_axes'</span><span class="s1">):</span>
                <span class="s1">projection_class</span><span class="s2">, </span><span class="s1">extra_kwargs = projection._as_mpl_axes()</span>
                <span class="s1">kwargs.update(**extra_kwargs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">f&quot;projection must be a string, None or implement a &quot;</span>
                    <span class="s4">f&quot;_as_mpl_axes method, not </span><span class="s2">{</span><span class="s1">projection</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">projection_class</span><span class="s2">, </span><span class="s1">kwargs</span>

    <span class="s2">def </span><span class="s1">get_default_bbox_extra_artists(self):</span>
        <span class="s1">bbox_artists = [artist </span><span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">self.get_children()</span>
                        <span class="s2">if </span><span class="s1">(artist.get_visible() </span><span class="s2">and </span><span class="s1">artist.get_in_layout())]</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes:</span>
            <span class="s2">if </span><span class="s1">ax.get_visible():</span>
                <span class="s1">bbox_artists.extend(ax.get_default_bbox_extra_artists())</span>
        <span class="s2">return </span><span class="s1">bbox_artists</span>

    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">bbox_extra_artists=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a (tight) bounding box of the figure *in inches*. 
 
        Note that `.FigureBase` differs from all other artists, which return 
        their `.Bbox` in pixels. 
 
        Artists that have ``artist.set_in_layout(False)`` are not included 
        in the bbox. 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass 
            Renderer that will be used to draw the figures (i.e. 
            ``fig.canvas.get_renderer()``) 
 
        bbox_extra_artists : list of `.Artist` or ``None`` 
            List of artists to include in the tight bounding box.  If 
            ``None`` (default), then all artist children of each Axes are 
            included in the tight bounding box. 
 
        Returns 
        ------- 
        `.BboxBase` 
            containing the bounding box (in figure inches). 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>

        <span class="s1">bb = []</span>
        <span class="s2">if </span><span class="s1">bbox_extra_artists </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">artists = self.get_default_bbox_extra_artists()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">artists = bbox_extra_artists</span>

        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s1">bbox = a.get_tightbbox(renderer)</span>
            <span class="s2">if </span><span class="s1">bbox </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">bb.append(bbox)</span>

        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes:</span>
            <span class="s2">if </span><span class="s1">ax.get_visible():</span>
                <span class="s3"># some axes don't take the bbox_extra_artists kwarg so we</span>
                <span class="s3"># need this conditional....</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">bbox = ax.get_tightbbox(</span>
                        <span class="s1">renderer</span><span class="s2">, </span><span class="s1">bbox_extra_artists=bbox_extra_artists)</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s1">bbox = ax.get_tightbbox(renderer)</span>
                <span class="s1">bb.append(bbox)</span>
        <span class="s1">bb = [b </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">bb</span>
              <span class="s2">if </span><span class="s1">(np.isfinite(b.width) </span><span class="s2">and </span><span class="s1">np.isfinite(b.height)</span>
                  <span class="s2">and </span><span class="s1">(b.width != </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">b.height != </span><span class="s5">0</span><span class="s1">))]</span>

        <span class="s1">isfigure = hasattr(self</span><span class="s2">, </span><span class="s4">'bbox_inches'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(bb) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isfigure:</span>
                <span class="s2">return </span><span class="s1">self.bbox_inches</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># subfigures do not have bbox_inches, but do have a bbox</span>
                <span class="s1">bb = [self.bbox]</span>

        <span class="s1">_bbox = Bbox.union(bb)</span>

        <span class="s2">if </span><span class="s1">isfigure:</span>
            <span class="s3"># transform from pixels to inches...</span>
            <span class="s1">_bbox = TransformedBbox(_bbox</span><span class="s2">, </span><span class="s1">self.dpi_scale_trans.inverted())</span>

        <span class="s2">return </span><span class="s1">_bbox</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_norm_per_subplot_kw(per_subplot_kw):</span>
        <span class="s1">expanded = {}</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">per_subplot_kw.items():</span>
            <span class="s2">if </span><span class="s1">isinstance(k</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s2">for </span><span class="s1">sub_key </span><span class="s2">in </span><span class="s1">k:</span>
                    <span class="s2">if </span><span class="s1">sub_key </span><span class="s2">in </span><span class="s1">expanded:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">f'The key </span><span class="s2">{</span><span class="s1">sub_key</span><span class="s2">!r} </span><span class="s4">appears multiple times.'</span>
                            <span class="s1">)</span>
                    <span class="s1">expanded[sub_key] = v</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">expanded:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f'The key </span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r} </span><span class="s4">appears multiple times.'</span>
                    <span class="s1">)</span>
                <span class="s1">expanded[k] = v</span>
        <span class="s2">return </span><span class="s1">expanded</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_normalize_grid_string(layout):</span>
        <span class="s2">if </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">' </span><span class="s2">not in </span><span class="s1">layout:</span>
            <span class="s3"># single-line string</span>
            <span class="s2">return </span><span class="s1">[list(ln) </span><span class="s2">for </span><span class="s1">ln </span><span class="s2">in </span><span class="s1">layout.split(</span><span class="s4">';'</span><span class="s1">)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># multi-line string</span>
            <span class="s1">layout = inspect.cleandoc(layout)</span>
            <span class="s2">return </span><span class="s1">[list(ln) </span><span class="s2">for </span><span class="s1">ln </span><span class="s2">in </span><span class="s1">layout.strip(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">).split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">subplot_mosaic(self</span><span class="s2">, </span><span class="s1">mosaic</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">sharex=</span><span class="s2">False, </span><span class="s1">sharey=</span><span class="s2">False,</span>
                       <span class="s1">width_ratios=</span><span class="s2">None, </span><span class="s1">height_ratios=</span><span class="s2">None,</span>
                       <span class="s1">empty_sentinel=</span><span class="s4">'.'</span><span class="s2">,</span>
                       <span class="s1">subplot_kw=</span><span class="s2">None, </span><span class="s1">per_subplot_kw=</span><span class="s2">None, </span><span class="s1">gridspec_kw=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Build a layout of Axes based on ASCII art or nested lists. 
 
        This is a helper function to build complex GridSpec layouts visually. 
 
        See :doc:`/gallery/subplots_axes_and_figures/mosaic` 
        for an example and full API documentation 
 
        Parameters 
        ---------- 
        mosaic : list of list of {hashable or nested} or str 
 
            A visual layout of how you want your Axes to be arranged 
            labeled as strings.  For example :: 
 
               x = [['A panel', 'A panel', 'edge'], 
                    ['C panel', '.',       'edge']] 
 
            produces 4 Axes: 
 
            - 'A panel' which is 1 row high and spans the first two columns 
            - 'edge' which is 2 rows high and is on the right edge 
            - 'C panel' which in 1 row and 1 column wide in the bottom left 
            - a blank space 1 row and 1 column wide in the bottom center 
 
            Any of the entries in the layout can be a list of lists 
            of the same form to create nested layouts. 
 
            If input is a str, then it can either be a multi-line string of 
            the form :: 
 
              ''' 
              AAE 
              C.E 
              ''' 
 
            where each character is a column and each line is a row. Or it 
            can be a single-line string where rows are separated by ``;``:: 
 
              'AB;CC' 
 
            The string notation allows only single character Axes labels and 
            does not support nesting but is very terse. 
 
            The Axes identifiers may be `str` or a non-iterable hashable 
            object (e.g. `tuple` s may not be used). 
 
        sharex, sharey : bool, default: False 
            If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared 
            among all subplots.  In that case, tick label visibility and axis 
            units behave as for `subplots`.  If False, each subplot's x- or 
            y-axis will be independent. 
 
        width_ratios : array-like of length *ncols*, optional 
            Defines the relative widths of the columns. Each column gets a 
            relative width of ``width_ratios[i] / sum(width_ratios)``. 
            If not given, all columns will have the same width.  Equivalent 
            to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested 
            layouts, this argument applies only to the outer layout. 
 
        height_ratios : array-like of length *nrows*, optional 
            Defines the relative heights of the rows. Each row gets a 
            relative height of ``height_ratios[i] / sum(height_ratios)``. 
            If not given, all rows will have the same height. Equivalent 
            to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested 
            layouts, this argument applies only to the outer layout. 
 
        subplot_kw : dict, optional 
            Dictionary with keywords passed to the `.Figure.add_subplot` call 
            used to create each subplot.  These values may be overridden by 
            values in *per_subplot_kw*. 
 
        per_subplot_kw : dict, optional 
            A dictionary mapping the Axes identifiers or tuples of identifiers 
            to a dictionary of keyword arguments to be passed to the 
            `.Figure.add_subplot` call used to create each subplot.  The values 
            in these dictionaries have precedence over the values in 
            *subplot_kw*. 
 
            If *mosaic* is a string, and thus all keys are single characters, 
            it is possible to use a single string instead of a tuple as keys; 
            i.e. ``&quot;AB&quot;`` is equivalent to ``(&quot;A&quot;, &quot;B&quot;)``. 
 
            .. versionadded:: 3.7 
 
        gridspec_kw : dict, optional 
            Dictionary with keywords passed to the `.GridSpec` constructor used 
            to create the grid the subplots are placed on. In the case of 
            nested layouts, this argument applies only to the outer layout. 
            For more complex layouts, users should use `.Figure.subfigures` 
            to create the nesting. 
 
        empty_sentinel : object, optional 
            Entry in the layout to mean &quot;leave this space empty&quot;.  Defaults 
            to ``'.'``. Note, if *layout* is a string, it is processed via 
            `inspect.cleandoc` to remove leading white space, which may 
            interfere with using white-space as the empty sentinel. 
 
        Returns 
        ------- 
        dict[label, Axes] 
           A dictionary mapping the labels to the Axes objects.  The order of 
           the axes is left-to-right and top-to-bottom of their position in the 
           total layout. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">subplot_kw = subplot_kw </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">gridspec_kw = dict(gridspec_kw </span><span class="s2">or </span><span class="s1">{})</span>
        <span class="s1">per_subplot_kw = per_subplot_kw </span><span class="s2">or </span><span class="s1">{}</span>

        <span class="s2">if </span><span class="s1">height_ratios </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s4">'height_ratios' </span><span class="s2">in </span><span class="s1">gridspec_kw:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'height_ratios' must not be defined both as &quot;</span>
                                 <span class="s4">&quot;parameter and as key in 'gridspec_kw'&quot;</span><span class="s1">)</span>
            <span class="s1">gridspec_kw[</span><span class="s4">'height_ratios'</span><span class="s1">] = height_ratios</span>
        <span class="s2">if </span><span class="s1">width_ratios </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s4">'width_ratios' </span><span class="s2">in </span><span class="s1">gridspec_kw:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'width_ratios' must not be defined both as &quot;</span>
                                 <span class="s4">&quot;parameter and as key in 'gridspec_kw'&quot;</span><span class="s1">)</span>
            <span class="s1">gridspec_kw[</span><span class="s4">'width_ratios'</span><span class="s1">] = width_ratios</span>

        <span class="s3"># special-case string input</span>
        <span class="s2">if </span><span class="s1">isinstance(mosaic</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">mosaic = self._normalize_grid_string(mosaic)</span>
            <span class="s1">per_subplot_kw = {</span>
                <span class="s1">tuple(k): v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">per_subplot_kw.items()</span>
            <span class="s1">}</span>

        <span class="s1">per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)</span>

        <span class="s3"># Only accept strict bools to allow a possible future API expansion.</span>
        <span class="s1">_api.check_isinstance(bool</span><span class="s2">, </span><span class="s1">sharex=sharex</span><span class="s2">, </span><span class="s1">sharey=sharey)</span>

        <span class="s2">def </span><span class="s1">_make_array(inp):</span>
            <span class="s0">&quot;&quot;&quot; 
            Convert input into 2D array 
 
            We need to have this internal function rather than 
            ``np.asarray(..., dtype=object)`` so that a list of lists 
            of lists does not get converted to an array of dimension &gt; 
            2 
 
            Returns 
            ------- 
            2D object array 
 
            &quot;&quot;&quot;</span>
            <span class="s1">r0</span><span class="s2">, </span><span class="s1">*rest = inp</span>
            <span class="s2">if </span><span class="s1">isinstance(r0</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'List mosaic specification must be 2D'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">enumerate(rest</span><span class="s2">, </span><span class="s1">start=</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">isinstance(r</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'List mosaic specification must be 2D'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">len(r0) != len(r):</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;All of the rows must be the same length, however &quot;</span>
                        <span class="s4">f&quot;the first row (</span><span class="s2">{</span><span class="s1">r0</span><span class="s2">!r}</span><span class="s4">) has length </span><span class="s2">{</span><span class="s1">len(r0)</span><span class="s2">} </span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;and row </span><span class="s2">{</span><span class="s1">j</span><span class="s2">} </span><span class="s4">(</span><span class="s2">{</span><span class="s1">r</span><span class="s2">!r}</span><span class="s4">) has length </span><span class="s2">{</span><span class="s1">len(r)</span><span class="s2">}</span><span class="s4">.&quot;</span>
                    <span class="s1">)</span>
            <span class="s1">out = np.zeros((len(inp)</span><span class="s2">, </span><span class="s1">len(r0))</span><span class="s2">, </span><span class="s1">dtype=object)</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">r </span><span class="s2">in </span><span class="s1">enumerate(inp):</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(r):</span>
                    <span class="s1">out[j</span><span class="s2">, </span><span class="s1">k] = v</span>
            <span class="s2">return </span><span class="s1">out</span>

        <span class="s2">def </span><span class="s1">_identify_keys_and_nested(mosaic):</span>
            <span class="s0">&quot;&quot;&quot; 
            Given a 2D object array, identify unique IDs and nested mosaics 
 
            Parameters 
            ---------- 
            mosaic : 2D numpy object array 
 
            Returns 
            ------- 
            unique_ids : tuple 
                The unique non-sub mosaic entries in this mosaic 
            nested : dict[tuple[int, int]], 2D object array 
            &quot;&quot;&quot;</span>
            <span class="s3"># make sure we preserve the user supplied order</span>
            <span class="s1">unique_ids = cbook._OrderedSet()</span>
            <span class="s1">nested = {}</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">row </span><span class="s2">in </span><span class="s1">enumerate(mosaic):</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(row):</span>
                    <span class="s2">if </span><span class="s1">v == empty_sentinel:</span>
                        <span class="s2">continue</span>
                    <span class="s2">elif not </span><span class="s1">cbook.is_scalar_or_string(v):</span>
                        <span class="s1">nested[(j</span><span class="s2">, </span><span class="s1">k)] = _make_array(v)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">unique_ids.add(v)</span>

            <span class="s2">return </span><span class="s1">tuple(unique_ids)</span><span class="s2">, </span><span class="s1">nested</span>

        <span class="s2">def </span><span class="s1">_do_layout(gs</span><span class="s2">, </span><span class="s1">mosaic</span><span class="s2">, </span><span class="s1">unique_ids</span><span class="s2">, </span><span class="s1">nested):</span>
            <span class="s0">&quot;&quot;&quot; 
            Recursively do the mosaic. 
 
            Parameters 
            ---------- 
            gs : GridSpec 
            mosaic : 2D object array 
                The input converted to a 2D numpy array for this level. 
            unique_ids : tuple 
                The identified scalar labels at this level of nesting. 
            nested : dict[tuple[int, int]], 2D object array 
                The identified nested mosaics, if any. 
 
            Returns 
            ------- 
            dict[label, Axes] 
                A flat dict of all of the Axes created. 
            &quot;&quot;&quot;</span>
            <span class="s1">output = dict()</span>

            <span class="s3"># we need to merge together the Axes at this level and the axes</span>
            <span class="s3"># in the (recursively) nested sub-mosaics so that we can add</span>
            <span class="s3"># them to the figure in the &quot;natural&quot; order if you were to</span>
            <span class="s3"># ravel in c-order all of the Axes that will be created</span>
            <span class="s3">#</span>
            <span class="s3"># This will stash the upper left index of each object (axes or</span>
            <span class="s3"># nested mosaic) at this level</span>
            <span class="s1">this_level = dict()</span>

            <span class="s3"># go through the unique keys,</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">unique_ids:</span>
                <span class="s3"># sort out where each axes starts/ends</span>
                <span class="s1">indx = np.argwhere(mosaic == name)</span>
                <span class="s1">start_row</span><span class="s2">, </span><span class="s1">start_col = np.min(indx</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">end_row</span><span class="s2">, </span><span class="s1">end_col = np.max(indx</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>
                <span class="s3"># and construct the slice object</span>
                <span class="s1">slc = (slice(start_row</span><span class="s2">, </span><span class="s1">end_row)</span><span class="s2">, </span><span class="s1">slice(start_col</span><span class="s2">, </span><span class="s1">end_col))</span>
                <span class="s3"># some light error checking</span>
                <span class="s2">if </span><span class="s1">(mosaic[slc] != name).any():</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f&quot;While trying to layout</span><span class="s2">\n{</span><span class="s1">mosaic</span><span class="s2">!r}\n</span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;we found that the label </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s4">specifies a &quot;</span>
                        <span class="s4">&quot;non-rectangular or non-contiguous area.&quot;</span><span class="s1">)</span>
                <span class="s3"># and stash this slice for later</span>
                <span class="s1">this_level[(start_row</span><span class="s2">, </span><span class="s1">start_col)] = (name</span><span class="s2">, </span><span class="s1">slc</span><span class="s2">, </span><span class="s4">'axes'</span><span class="s1">)</span>

            <span class="s3"># do the same thing for the nested mosaics (simpler because these</span>
            <span class="s3"># can not be spans yet!)</span>
            <span class="s2">for </span><span class="s1">(j</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">, </span><span class="s1">nested_mosaic </span><span class="s2">in </span><span class="s1">nested.items():</span>
                <span class="s1">this_level[(j</span><span class="s2">, </span><span class="s1">k)] = (</span><span class="s2">None, </span><span class="s1">nested_mosaic</span><span class="s2">, </span><span class="s4">'nested'</span><span class="s1">)</span>

            <span class="s3"># now go through the things in this level and add them</span>
            <span class="s3"># in order left-to-right top-to-bottom</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">sorted(this_level):</span>
                <span class="s1">name</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">method = this_level[key]</span>
                <span class="s3"># we are doing some hokey function dispatch here based</span>
                <span class="s3"># on the 'method' string stashed above to sort out if this</span>
                <span class="s3"># element is an Axes or a nested mosaic.</span>
                <span class="s2">if </span><span class="s1">method == </span><span class="s4">'axes'</span><span class="s1">:</span>
                    <span class="s1">slc = arg</span>
                    <span class="s3"># add a single axes</span>
                    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">output:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;There are duplicate keys </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">&quot;</span>
                                         <span class="s4">f&quot;in the layout</span><span class="s2">\n{</span><span class="s1">mosaic</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
                    <span class="s1">ax = self.add_subplot(</span>
                        <span class="s1">gs[slc]</span><span class="s2">, </span><span class="s1">**{</span>
                            <span class="s4">'label'</span><span class="s1">: str(name)</span><span class="s2">,</span>
                            <span class="s1">**subplot_kw</span><span class="s2">,</span>
                            <span class="s1">**per_subplot_kw.get(name</span><span class="s2">, </span><span class="s1">{})</span>
                        <span class="s1">}</span>
                    <span class="s1">)</span>
                    <span class="s1">output[name] = ax</span>
                <span class="s2">elif </span><span class="s1">method == </span><span class="s4">'nested'</span><span class="s1">:</span>
                    <span class="s1">nested_mosaic = arg</span>
                    <span class="s1">j</span><span class="s2">, </span><span class="s1">k = key</span>
                    <span class="s3"># recursively add the nested mosaic</span>
                    <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = nested_mosaic.shape</span>
                    <span class="s1">nested_output = _do_layout(</span>
                        <span class="s1">gs[j</span><span class="s2">, </span><span class="s1">k].subgridspec(rows</span><span class="s2">, </span><span class="s1">cols)</span><span class="s2">,</span>
                        <span class="s1">nested_mosaic</span><span class="s2">,</span>
                        <span class="s1">*_identify_keys_and_nested(nested_mosaic)</span>
                    <span class="s1">)</span>
                    <span class="s1">overlap = set(output) &amp; set(nested_output)</span>
                    <span class="s2">if </span><span class="s1">overlap:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s4">f&quot;There are duplicate keys </span><span class="s2">{</span><span class="s1">overlap</span><span class="s2">} </span><span class="s4">&quot;</span>
                            <span class="s4">f&quot;between the outer layout</span><span class="s2">\n{</span><span class="s1">mosaic</span><span class="s2">!r}\n</span><span class="s4">&quot;</span>
                            <span class="s4">f&quot;and the nested layout</span><span class="s2">\n{</span><span class="s1">nested_mosaic</span><span class="s2">}</span><span class="s4">&quot;</span>
                        <span class="s1">)</span>
                    <span class="s1">output.update(nested_output)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;This should never happen&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">output</span>

        <span class="s1">mosaic = _make_array(mosaic)</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = mosaic.shape</span>
        <span class="s1">gs = self.add_gridspec(rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">**gridspec_kw)</span>
        <span class="s1">ret = _do_layout(gs</span><span class="s2">, </span><span class="s1">mosaic</span><span class="s2">, </span><span class="s1">*_identify_keys_and_nested(mosaic))</span>
        <span class="s1">ax0 = next(iter(ret.values()))</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">ret.values():</span>
            <span class="s2">if </span><span class="s1">sharex:</span>
                <span class="s1">ax.sharex(ax0)</span>
                <span class="s1">ax._label_outer_xaxis(check_patch=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">sharey:</span>
                <span class="s1">ax.sharey(ax0)</span>
                <span class="s1">ax._label_outer_yaxis(check_patch=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">extra := set(per_subplot_kw) - set(ret):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;The keys </span><span class="s2">{</span><span class="s1">extra</span><span class="s2">} </span><span class="s4">are in *per_subplot_kw* &quot;</span>
                <span class="s4">&quot;but not in the mosaic.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_set_artist_props(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">if </span><span class="s1">a != self:</span>
            <span class="s1">a.set_figure(self)</span>
        <span class="s1">a.stale_callback = _stale_figure_callback</span>
        <span class="s1">a.set_transform(self.transSubfigure)</span>


<span class="s1">@_docstring.interpd</span>
<span class="s2">class </span><span class="s1">SubFigure(FigureBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Logical figure that can be placed inside a figure. 
 
    Typically instantiated using `.Figure.add_subfigure` or 
    `.SubFigure.add_subfigure`, or `.SubFigure.subfigures`.  A subfigure has 
    the same methods as a figure except for those particularly tied to the size 
    or dpi of the figure, and is confined to a prescribed region of the figure. 
    For example the following puts two subfigures side-by-side:: 
 
        fig = plt.figure() 
        sfigs = fig.subfigures(1, 2) 
        axsL = sfigs[0].subplots(1, 2) 
        axsR = sfigs[1].subplots(2, 1) 
 
    See :doc:`/gallery/subplots_axes_and_figures/subfigures` 
    &quot;&quot;&quot;</span>
    <span class="s1">callbacks = _api.deprecated(</span>
            <span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span><span class="s4">&quot;the 'resize_event' signal in &quot;</span>
                                <span class="s4">&quot;Figure.canvas.callbacks&quot;</span><span class="s1">)</span>
            <span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: self._fig_callbacks))</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">subplotspec</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">facecolor=</span><span class="s2">None,</span>
                 <span class="s1">edgecolor=</span><span class="s2">None,</span>
                 <span class="s1">linewidth=</span><span class="s5">0.0</span><span class="s2">,</span>
                 <span class="s1">frameon=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        parent : `.Figure` or `.SubFigure` 
            Figure or subfigure that contains the SubFigure.  SubFigures 
            can be nested. 
 
        subplotspec : `.gridspec.SubplotSpec` 
            Defines the region in a parent gridspec where the subfigure will 
            be placed. 
 
        facecolor : default: :rc:`figure.facecolor` 
            The figure patch face color. 
 
        edgecolor : default: :rc:`figure.edgecolor` 
            The figure patch edge color. 
 
        linewidth : float 
            The linewidth of the frame (i.e. the edge linewidth of the figure 
            patch). 
 
        frameon : bool, default: :rc:`figure.frameon` 
            If ``False``, suppress drawing the figure background patch. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.SubFigure` properties, optional 
 
            %(SubFigure:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s2">if </span><span class="s1">facecolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">facecolor = mpl.rcParams[</span><span class="s4">'figure.facecolor'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">edgecolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">edgecolor = mpl.rcParams[</span><span class="s4">'figure.edgecolor'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">frameon </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">frameon = mpl.rcParams[</span><span class="s4">'figure.frameon'</span><span class="s1">]</span>

        <span class="s1">self._subplotspec = subplotspec</span>
        <span class="s1">self._parent = parent</span>
        <span class="s1">self.figure = parent.figure</span>
        <span class="s1">self._fig_callbacks = parent._fig_callbacks</span>

        <span class="s3"># subfigures use the parent axstack</span>
        <span class="s1">self._axstack = parent._axstack</span>
        <span class="s1">self.subplotpars = parent.subplotpars</span>
        <span class="s1">self.dpi_scale_trans = parent.dpi_scale_trans</span>
        <span class="s1">self._axobservers = parent._axobservers</span>
        <span class="s1">self.canvas = parent.canvas</span>
        <span class="s1">self.transFigure = parent.transFigure</span>
        <span class="s1">self.bbox_relative = </span><span class="s2">None</span>
        <span class="s1">self._redo_transform_rel_fig()</span>
        <span class="s1">self.figbbox = self._parent.figbbox</span>
        <span class="s1">self.bbox = TransformedBbox(self.bbox_relative</span><span class="s2">,</span>
                                    <span class="s1">self._parent.transSubfigure)</span>
        <span class="s1">self.transSubfigure = BboxTransformTo(self.bbox)</span>

        <span class="s1">self.patch = Rectangle(</span>
            <span class="s1">xy=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">width=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">height=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">visible=frameon</span><span class="s2">,</span>
            <span class="s1">facecolor=facecolor</span><span class="s2">, </span><span class="s1">edgecolor=edgecolor</span><span class="s2">, </span><span class="s1">linewidth=linewidth</span><span class="s2">,</span>
            <span class="s3"># Don't let the figure patch influence bbox calculation.</span>
            <span class="s1">in_layout=</span><span class="s2">False, </span><span class="s1">transform=self.transSubfigure)</span>
        <span class="s1">self._set_artist_props(self.patch)</span>
        <span class="s1">self.patch.set_antialiased(</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dpi(self):</span>
        <span class="s2">return </span><span class="s1">self._parent.dpi</span>

    <span class="s1">@dpi.setter</span>
    <span class="s2">def </span><span class="s1">dpi(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._parent.dpi = value</span>

    <span class="s2">def </span><span class="s1">get_dpi(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the resolution of the parent figure in dots-per-inch as a float. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._parent.dpi</span>

    <span class="s2">def </span><span class="s1">set_dpi(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the resolution of parent figure in dots-per-inch. 
 
        Parameters 
        ---------- 
        val : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parent.dpi = val</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_get_renderer(self):</span>
        <span class="s2">return </span><span class="s1">self._parent._get_renderer()</span>

    <span class="s2">def </span><span class="s1">_redo_transform_rel_fig(self</span><span class="s2">, </span><span class="s1">bbox=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make the transSubfigure bbox relative to Figure transform. 
 
        Parameters 
        ---------- 
        bbox : bbox or None 
            If not None, then the bbox is used for relative bounding box. 
            Otherwise, it is calculated from the subplotspec. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bbox </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.bbox_relative.p0 = bbox.p0</span>
            <span class="s1">self.bbox_relative.p1 = bbox.p1</span>
            <span class="s2">return</span>
        <span class="s3"># need to figure out *where* this subplotspec is.</span>
        <span class="s1">gs = self._subplotspec.get_gridspec()</span>
        <span class="s1">wr = np.asarray(gs.get_width_ratios())</span>
        <span class="s1">hr = np.asarray(gs.get_height_ratios())</span>
        <span class="s1">dx = wr[self._subplotspec.colspan].sum() / wr.sum()</span>
        <span class="s1">dy = hr[self._subplotspec.rowspan].sum() / hr.sum()</span>
        <span class="s1">x0 = wr[:self._subplotspec.colspan.start].sum() / wr.sum()</span>
        <span class="s1">y0 = </span><span class="s5">1 </span><span class="s1">- hr[:self._subplotspec.rowspan.stop].sum() / hr.sum()</span>
        <span class="s2">if </span><span class="s1">self.bbox_relative </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.bbox_relative = Bbox.from_bounds(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.bbox_relative.p0 = (x0</span><span class="s2">, </span><span class="s1">y0)</span>
            <span class="s1">self.bbox_relative.p1 = (x0 + dx</span><span class="s2">, </span><span class="s1">y0 + dy)</span>

    <span class="s2">def </span><span class="s1">get_constrained_layout(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether constrained layout is being used. 
 
        See :doc:`/tutorials/intermediate/constrainedlayout_guide`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._parent.get_constrained_layout()</span>

    <span class="s2">def </span><span class="s1">get_constrained_layout_pads(self</span><span class="s2">, </span><span class="s1">relative=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get padding for ``constrained_layout``. 
 
        Returns a list of ``w_pad, h_pad`` in inches and 
        ``wspace`` and ``hspace`` as fractions of the subplot. 
 
        See :doc:`/tutorials/intermediate/constrainedlayout_guide`. 
 
        Parameters 
        ---------- 
        relative : bool 
            If `True`, then convert from inches to figure relative. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._parent.get_constrained_layout_pads(relative=relative)</span>

    <span class="s2">def </span><span class="s1">get_layout_engine(self):</span>
        <span class="s2">return </span><span class="s1">self._parent.get_layout_engine()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">axes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of Axes in the SubFigure.  You can access and modify the Axes 
        in the SubFigure through this list. 
 
        Modifying this list has no effect. Instead, use `~.SubFigure.add_axes`, 
        `~.SubFigure.add_subplot` or `~.SubFigure.delaxes` to add or remove an 
        Axes. 
 
        Note: The `.SubFigure.axes` property and `~.SubFigure.get_axes` method 
        are equivalent. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._localaxes[:]</span>

    <span class="s1">get_axes = axes.fget</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s3"># draw the figure bounding box, perhaps none for white figure</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s1">artists = self._get_draw_artists(renderer)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">renderer.open_group(</span><span class="s4">'subfigure'</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>
            <span class="s1">self.patch.draw(renderer)</span>
            <span class="s1">mimage._draw_list_compositing_images(</span>
                <span class="s1">renderer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">artists</span><span class="s2">, </span><span class="s1">self.figure.suppressComposite)</span>
            <span class="s2">for </span><span class="s1">sfig </span><span class="s2">in </span><span class="s1">self.subfigs:</span>
                <span class="s1">sfig.draw(renderer)</span>
            <span class="s1">renderer.close_group(</span><span class="s4">'subfigure'</span><span class="s1">)</span>

        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s1">@_docstring.interpd</span>
<span class="s2">class </span><span class="s1">Figure(FigureBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    The top level container for all the plot elements. 
 
    Attributes 
    ---------- 
    patch 
        The `.Rectangle` instance representing the figure background patch. 
 
    suppressComposite 
        For multiple images, the figure will make composite images 
        depending on the renderer option_image_nocomposite function.  If 
        *suppressComposite* is a boolean, this will override the renderer. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Remove the self._fig_callbacks properties on figure and subfigure</span>
    <span class="s3"># after the deprecation expires.</span>
    <span class="s1">callbacks = _api.deprecated(</span>
        <span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span><span class="s4">&quot;the 'resize_event' signal in &quot;</span>
                            <span class="s4">&quot;Figure.canvas.callbacks&quot;</span><span class="s1">)</span>
        <span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: self._fig_callbacks))</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;Figure(%gx%g)&quot; </span><span class="s1">% tuple(self.bbox.size)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;{clsname} size {h:g}x{w:g} with {naxes} Axes&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">clsname=self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">h=self.bbox.size[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">w=self.bbox.size[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">naxes=len(self.axes)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;facecolor&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">figsize=</span><span class="s2">None,</span>
                 <span class="s1">dpi=</span><span class="s2">None,</span>
                 <span class="s1">facecolor=</span><span class="s2">None,</span>
                 <span class="s1">edgecolor=</span><span class="s2">None,</span>
                 <span class="s1">linewidth=</span><span class="s5">0.0</span><span class="s2">,</span>
                 <span class="s1">frameon=</span><span class="s2">None,</span>
                 <span class="s1">subplotpars=</span><span class="s2">None,  </span><span class="s3"># rc figure.subplot.*</span>
                 <span class="s1">tight_layout=</span><span class="s2">None,  </span><span class="s3"># rc figure.autolayout</span>
                 <span class="s1">constrained_layout=</span><span class="s2">None,  </span><span class="s3"># rc figure.constrained_layout.use</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">layout=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        figsize : 2-tuple of floats, default: :rc:`figure.figsize` 
            Figure dimension ``(width, height)`` in inches. 
 
        dpi : float, default: :rc:`figure.dpi` 
            Dots per inch. 
 
        facecolor : default: :rc:`figure.facecolor` 
            The figure patch facecolor. 
 
        edgecolor : default: :rc:`figure.edgecolor` 
            The figure patch edge color. 
 
        linewidth : float 
            The linewidth of the frame (i.e. the edge linewidth of the figure 
            patch). 
 
        frameon : bool, default: :rc:`figure.frameon` 
            If ``False``, suppress drawing the figure background patch. 
 
        subplotpars : `SubplotParams` 
            Subplot parameters. If not given, the default subplot 
            parameters :rc:`figure.subplot.*` are used. 
 
        tight_layout : bool or dict, default: :rc:`figure.autolayout` 
            Whether to use the tight layout mechanism. See `.set_tight_layout`. 
 
            .. admonition:: Discouraged 
 
                The use of this parameter is discouraged. Please use 
                ``layout='tight'`` instead for the common case of 
                ``tight_layout=True`` and use `.set_tight_layout` otherwise. 
 
        constrained_layout : bool, default: :rc:`figure.constrained_layout.use` 
            This is equal to ``layout='constrained'``. 
 
            .. admonition:: Discouraged 
 
                The use of this parameter is discouraged. Please use 
                ``layout='constrained'`` instead. 
 
        layout : {'constrained', 'compressed', 'tight', `.LayoutEngine`, None} 
            The layout mechanism for positioning of plot elements to avoid 
            overlapping Axes decorations (labels, ticks, etc). Note that 
            layout managers can have significant performance penalties. 
            Defaults to *None*. 
 
            - 'constrained': The constrained layout solver adjusts axes sizes 
               to avoid overlapping axes decorations.  Can handle complex plot 
               layouts and colorbars, and is thus recommended. 
 
              See :doc:`/tutorials/intermediate/constrainedlayout_guide` 
              for examples. 
 
            - 'compressed': uses the same algorithm as 'constrained', but 
              removes extra space between fixed-aspect-ratio Axes.  Best for 
              simple grids of axes. 
 
            - 'tight': Use the tight layout mechanism. This is a relatively 
              simple algorithm that adjusts the subplot parameters so that 
              decorations do not overlap. See `.Figure.set_tight_layout` for 
              further details. 
 
            - A `.LayoutEngine` instance. Builtin layout classes are 
              `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily 
              accessible by 'constrained' and 'tight'.  Passing an instance 
              allows third parties to provide their own layout engine. 
 
            If not given, fall back to using the parameters *tight_layout* and 
            *constrained_layout*, including their config defaults 
            :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Figure` properties, optional 
 
            %(Figure:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._layout_engine = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">layout </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(tight_layout </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s4">&quot;The Figure parameters 'layout' and 'tight_layout' cannot &quot;</span>
                    <span class="s4">&quot;be used together. Please use 'layout' only.&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">(constrained_layout </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s4">&quot;The Figure parameters 'layout' and 'constrained_layout' &quot;</span>
                    <span class="s4">&quot;cannot be used together. Please use 'layout' only.&quot;</span><span class="s1">)</span>
            <span class="s1">self.set_layout_engine(layout=layout)</span>
        <span class="s2">elif </span><span class="s1">tight_layout </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">constrained_layout </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s4">&quot;The Figure parameters 'tight_layout' and &quot;</span>
                    <span class="s4">&quot;'constrained_layout' cannot be used together. Please use &quot;</span>
                    <span class="s4">&quot;'layout' parameter&quot;</span><span class="s1">)</span>
            <span class="s1">self.set_layout_engine(layout=</span><span class="s4">'tight'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(tight_layout</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">self.get_layout_engine().set(**tight_layout)</span>
        <span class="s2">elif </span><span class="s1">constrained_layout </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(constrained_layout</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s1">self.set_layout_engine(layout=</span><span class="s4">'constrained'</span><span class="s1">)</span>
                <span class="s1">self.get_layout_engine().set(**constrained_layout)</span>
            <span class="s2">elif </span><span class="s1">constrained_layout:</span>
                <span class="s1">self.set_layout_engine(layout=</span><span class="s4">'constrained'</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># everything is None, so use default:</span>
            <span class="s1">self.set_layout_engine(layout=layout)</span>

        <span class="s1">self._fig_callbacks = cbook.CallbackRegistry(signals=[</span><span class="s4">&quot;dpi_changed&quot;</span><span class="s1">])</span>
        <span class="s3"># Callbacks traditionally associated with the canvas (and exposed with</span>
        <span class="s3"># a proxy property), but that actually need to be on the figure for</span>
        <span class="s3"># pickling.</span>
        <span class="s1">self._canvas_callbacks = cbook.CallbackRegistry(</span>
            <span class="s1">signals=FigureCanvasBase.events)</span>
        <span class="s1">connect = self._canvas_callbacks._connect_picklable</span>
        <span class="s1">self._mouse_key_ids = [</span>
            <span class="s1">connect(</span><span class="s4">'key_press_event'</span><span class="s2">, </span><span class="s1">backend_bases._key_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'key_release_event'</span><span class="s2">, </span><span class="s1">backend_bases._key_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'key_release_event'</span><span class="s2">, </span><span class="s1">backend_bases._key_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'button_press_event'</span><span class="s2">, </span><span class="s1">backend_bases._mouse_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'button_release_event'</span><span class="s2">, </span><span class="s1">backend_bases._mouse_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'scroll_event'</span><span class="s2">, </span><span class="s1">backend_bases._mouse_handler)</span><span class="s2">,</span>
            <span class="s1">connect(</span><span class="s4">'motion_notify_event'</span><span class="s2">, </span><span class="s1">backend_bases._mouse_handler)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">self._button_pick_id = connect(</span><span class="s4">'button_press_event'</span><span class="s2">, </span><span class="s1">self.pick)</span>
        <span class="s1">self._scroll_pick_id = connect(</span><span class="s4">'scroll_event'</span><span class="s2">, </span><span class="s1">self.pick)</span>

        <span class="s2">if </span><span class="s1">figsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">figsize = mpl.rcParams[</span><span class="s4">'figure.figsize'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">dpi </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dpi = mpl.rcParams[</span><span class="s4">'figure.dpi'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">facecolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">facecolor = mpl.rcParams[</span><span class="s4">'figure.facecolor'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">edgecolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">edgecolor = mpl.rcParams[</span><span class="s4">'figure.edgecolor'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">frameon </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">frameon = mpl.rcParams[</span><span class="s4">'figure.frameon'</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">np.isfinite(figsize).all() </span><span class="s2">or </span><span class="s1">(np.array(figsize) &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'figure size must be positive finite not '</span>
                             <span class="s4">f'</span><span class="s2">{</span><span class="s1">figsize</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self.bbox_inches = Bbox.from_bounds(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">*figsize)</span>

        <span class="s1">self.dpi_scale_trans = Affine2D().scale(dpi)</span>
        <span class="s3"># do not use property as it will trigger</span>
        <span class="s1">self._dpi = dpi</span>
        <span class="s1">self.bbox = TransformedBbox(self.bbox_inches</span><span class="s2">, </span><span class="s1">self.dpi_scale_trans)</span>
        <span class="s1">self.figbbox = self.bbox</span>
        <span class="s1">self.transFigure = BboxTransformTo(self.bbox)</span>
        <span class="s1">self.transSubfigure = self.transFigure</span>

        <span class="s1">self.patch = Rectangle(</span>
            <span class="s1">xy=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">width=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">height=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">visible=frameon</span><span class="s2">,</span>
            <span class="s1">facecolor=facecolor</span><span class="s2">, </span><span class="s1">edgecolor=edgecolor</span><span class="s2">, </span><span class="s1">linewidth=linewidth</span><span class="s2">,</span>
            <span class="s3"># Don't let the figure patch influence bbox calculation.</span>
            <span class="s1">in_layout=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._set_artist_props(self.patch)</span>
        <span class="s1">self.patch.set_antialiased(</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">FigureCanvasBase(self)  </span><span class="s3"># Set self.canvas.</span>

        <span class="s2">if </span><span class="s1">subplotpars </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subplotpars = SubplotParams()</span>

        <span class="s1">self.subplotpars = subplotpars</span>

        <span class="s1">self._axstack = _AxesStack()  </span><span class="s3"># track all figure axes and current axes</span>
        <span class="s1">self.clear()</span>

    <span class="s2">def </span><span class="s1">pick(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s2">if not </span><span class="s1">self.canvas.widgetlock.locked():</span>
            <span class="s1">super().pick(mouseevent)</span>

    <span class="s2">def </span><span class="s1">_check_layout_engines_compat(self</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper for set_layout engine 
 
        If the figure has used the old engine and added a colorbar then the 
        value of colorbar_gridspec must be the same on the new engine. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">old </span><span class="s2">is None or </span><span class="s1">new </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return True</span>
        <span class="s2">if </span><span class="s1">old.colorbar_gridspec == new.colorbar_gridspec:</span>
            <span class="s2">return True</span>
        <span class="s3"># colorbar layout different, so check if any colorbars are on the</span>
        <span class="s3"># figure...</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes:</span>
            <span class="s2">if </span><span class="s1">hasattr(ax</span><span class="s2">, </span><span class="s4">'_colorbar'</span><span class="s1">):</span>
                <span class="s3"># colorbars list themselves as a colorbar.</span>
                <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">set_layout_engine(self</span><span class="s2">, </span><span class="s1">layout=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the layout engine for this figure. 
 
        Parameters 
        ---------- 
        layout: {'constrained', 'compressed', 'tight', 'none'} or \ 
`LayoutEngine` or None 
 
            - 'constrained' will use `~.ConstrainedLayoutEngine` 
            - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with 
              a correction that attempts to make a good layout for fixed-aspect 
              ratio Axes. 
            - 'tight' uses `~.TightLayoutEngine` 
            - 'none' removes layout engine. 
 
            If `None`, the behavior is controlled by :rc:`figure.autolayout` 
            (which if `True` behaves as if 'tight' was passed) and 
            :rc:`figure.constrained_layout.use` (which if `True` behaves as if 
            'constrained' was passed).  If both are `True`, 
            :rc:`figure.autolayout` takes priority. 
 
            Users and libraries can define their own layout engines and pass 
            the instance directly as well. 
 
        kwargs: dict 
            The keyword arguments are passed to the layout engine to set things 
            like padding and margin sizes.  Only used if *layout* is a string. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">layout </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'figure.autolayout'</span><span class="s1">]:</span>
                <span class="s1">layout = </span><span class="s4">'tight'</span>
            <span class="s2">elif </span><span class="s1">mpl.rcParams[</span><span class="s4">'figure.constrained_layout.use'</span><span class="s1">]:</span>
                <span class="s1">layout = </span><span class="s4">'constrained'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._layout_engine = </span><span class="s2">None</span>
                <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">layout == </span><span class="s4">'tight'</span><span class="s1">:</span>
            <span class="s1">new_layout_engine = TightLayoutEngine(**kwargs)</span>
        <span class="s2">elif </span><span class="s1">layout == </span><span class="s4">'constrained'</span><span class="s1">:</span>
            <span class="s1">new_layout_engine = ConstrainedLayoutEngine(**kwargs)</span>
        <span class="s2">elif </span><span class="s1">layout == </span><span class="s4">'compressed'</span><span class="s1">:</span>
            <span class="s1">new_layout_engine = ConstrainedLayoutEngine(compress=</span><span class="s2">True,</span>
                                                        <span class="s1">**kwargs)</span>
        <span class="s2">elif </span><span class="s1">layout == </span><span class="s4">'none'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._layout_engine </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">new_layout_engine = PlaceHolderLayoutEngine(</span>
                    <span class="s1">self._layout_engine.adjust_compatible</span><span class="s2">,</span>
                    <span class="s1">self._layout_engine.colorbar_gridspec</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">new_layout_engine = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">isinstance(layout</span><span class="s2">, </span><span class="s1">LayoutEngine):</span>
            <span class="s1">new_layout_engine = layout</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid value for 'layout': </span><span class="s2">{</span><span class="s1">layout</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._check_layout_engines_compat(self._layout_engine</span><span class="s2">,</span>
                                             <span class="s1">new_layout_engine):</span>
            <span class="s1">self._layout_engine = new_layout_engine</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Colorbar layout of new layout engine not '</span>
                               <span class="s4">'compatible with old engine, and a colorbar '</span>
                               <span class="s4">'has been created.  Engine not changed.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_layout_engine(self):</span>
        <span class="s2">return </span><span class="s1">self._layout_engine</span>

    <span class="s3"># TODO: I'd like to dynamically add the _repr_html_ method</span>
    <span class="s3"># to the figure in the right context, but then IPython doesn't</span>
    <span class="s3"># use it, for some reason.</span>

    <span class="s2">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s3"># We can't use &quot;isinstance&quot; here, because then we'd end up importing</span>
        <span class="s3"># webagg unconditionally.</span>
        <span class="s2">if </span><span class="s4">'WebAgg' </span><span class="s2">in </span><span class="s1">type(self.canvas).__name__:</span>
            <span class="s2">from </span><span class="s1">matplotlib.backends </span><span class="s2">import </span><span class="s1">backend_webagg</span>
            <span class="s2">return </span><span class="s1">backend_webagg.ipython_inline_display(self)</span>

    <span class="s2">def </span><span class="s1">show(self</span><span class="s2">, </span><span class="s1">warn=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        If using a GUI backend with pyplot, display the figure window. 
 
        If the figure was not created using `~.pyplot.figure`, it will lack 
        a `~.backend_bases.FigureManagerBase`, and this method will raise an 
        AttributeError. 
 
        .. warning:: 
 
            This does not manage an GUI event loop. Consequently, the figure 
            may only be shown briefly or not shown at all if you or your 
            environment are not managing an event loop. 
 
            Use cases for `.Figure.show` include running this from a GUI 
            application (where there is persistently an event loop running) or 
            from a shell, like IPython, that install an input hook to allow the 
            interactive shell to accept input while the figure is also being 
            shown and interactive.  Some, but not all, GUI toolkits will 
            register an input hook on import.  See :ref:`cp_integration` for 
            more details. 
 
            If you're in a shell without input hook integration or executing a 
            python script, you should use `matplotlib.pyplot.show` with 
            ``block=True`` instead, which takes care of starting and running 
            the event loop for you. 
 
        Parameters 
        ---------- 
        warn : bool, default: True 
            If ``True`` and we are not running headless (i.e. on Linux with an 
            unset DISPLAY), issue warning when called on a non-GUI backend. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.canvas.manager </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">&quot;Figure.show works only for figures managed by pyplot, &quot;</span>
                <span class="s4">&quot;normally created by pyplot.figure()&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.canvas.manager.show()</span>
        <span class="s2">except </span><span class="s1">NonGuiException </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s2">if </span><span class="s1">warn:</span>
                <span class="s1">_api.warn_external(str(exc))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">axes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of Axes in the Figure. You can access and modify the Axes in the 
        Figure through this list. 
 
        Do not modify the list itself. Instead, use `~Figure.add_axes`, 
        `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes. 
 
        Note: The `.Figure.axes` property and `~.Figure.get_axes` method are 
        equivalent. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._axstack.as_list()</span>

    <span class="s1">get_axes = axes.fget</span>

    <span class="s2">def </span><span class="s1">_get_renderer(self):</span>
        <span class="s2">if </span><span class="s1">hasattr(self.canvas</span><span class="s2">, </span><span class="s4">'get_renderer'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.canvas.get_renderer()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_get_renderer(self)</span>

    <span class="s2">def </span><span class="s1">_get_dpi(self):</span>
        <span class="s2">return </span><span class="s1">self._dpi</span>

    <span class="s2">def </span><span class="s1">_set_dpi(self</span><span class="s2">, </span><span class="s1">dpi</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        dpi : float 
 
        forward : bool 
            Passed on to `~.Figure.set_size_inches` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dpi == self._dpi:</span>
            <span class="s3"># We don't want to cause undue events in backends.</span>
            <span class="s2">return</span>
        <span class="s1">self._dpi = dpi</span>
        <span class="s1">self.dpi_scale_trans.clear().scale(dpi)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = self.get_size_inches()</span>
        <span class="s1">self.set_size_inches(w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">forward=forward)</span>
        <span class="s1">self._fig_callbacks.process(</span><span class="s4">'dpi_changed'</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s1">dpi = property(_get_dpi</span><span class="s2">, </span><span class="s1">_set_dpi</span><span class="s2">, </span><span class="s1">doc=</span><span class="s4">&quot;The resolution in dots per inch.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_tight_layout(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether `.tight_layout` is called when drawing.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isinstance(self.get_layout_engine()</span><span class="s2">, </span><span class="s1">TightLayoutEngine)</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;set_layout_engine&quot;</span><span class="s2">,</span>
                     <span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_tight_layout(self</span><span class="s2">, </span><span class="s1">tight):</span>
        <span class="s0">&quot;&quot;&quot; 
        [*Discouraged*] Set whether and how `.tight_layout` is called when 
        drawing. 
 
        .. admonition:: Discouraged 
 
            This method is discouraged in favor of `~.set_layout_engine`. 
 
        Parameters 
        ---------- 
        tight : bool or dict with keys &quot;pad&quot;, &quot;w_pad&quot;, &quot;h_pad&quot;, &quot;rect&quot; or None 
            If a bool, sets whether to call `.tight_layout` upon drawing. 
            If ``None``, use :rc:`figure.autolayout` instead. 
            If a dict, pass it as kwargs to `.tight_layout`, overriding the 
            default paddings. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">tight </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tight = mpl.rcParams[</span><span class="s4">'figure.autolayout'</span><span class="s1">]</span>
        <span class="s1">_tight = </span><span class="s4">'tight' </span><span class="s2">if </span><span class="s1">bool(tight) </span><span class="s2">else </span><span class="s4">'none'</span>
        <span class="s1">_tight_parameters = tight </span><span class="s2">if </span><span class="s1">isinstance(tight</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">else </span><span class="s1">{}</span>
        <span class="s1">self.set_layout_engine(_tight</span><span class="s2">, </span><span class="s1">**_tight_parameters)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_constrained_layout(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether constrained layout is being used. 
 
        See :doc:`/tutorials/intermediate/constrainedlayout_guide`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">isinstance(self.get_layout_engine()</span><span class="s2">, </span><span class="s1">ConstrainedLayoutEngine)</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;set_layout_engine('constrained')&quot;</span><span class="s2">,</span>
                     <span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_constrained_layout(self</span><span class="s2">, </span><span class="s1">constrained):</span>
        <span class="s0">&quot;&quot;&quot; 
        [*Discouraged*] Set whether ``constrained_layout`` is used upon 
        drawing. 
 
        If None, :rc:`figure.constrained_layout.use` value will be used. 
 
        When providing a dict containing the keys ``w_pad``, ``h_pad`` 
        the default ``constrained_layout`` paddings will be 
        overridden.  These pads are in inches and default to 3.0/72.0. 
        ``w_pad`` is the width padding and ``h_pad`` is the height padding. 
 
        .. admonition:: Discouraged 
 
            This method is discouraged in favor of `~.set_layout_engine`. 
 
        Parameters 
        ---------- 
        constrained : bool or dict or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">constrained </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">constrained = mpl.rcParams[</span><span class="s4">'figure.constrained_layout.use'</span><span class="s1">]</span>
        <span class="s1">_constrained = </span><span class="s4">'constrained' </span><span class="s2">if </span><span class="s1">bool(constrained) </span><span class="s2">else </span><span class="s4">'none'</span>
        <span class="s1">_parameters = constrained </span><span class="s2">if </span><span class="s1">isinstance(constrained</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">else </span><span class="s1">{}</span>
        <span class="s1">self.set_layout_engine(_constrained</span><span class="s2">, </span><span class="s1">**_parameters)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_api.deprecated(</span>
         <span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;figure.get_layout_engine().set()&quot;</span><span class="s2">,</span>
         <span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_constrained_layout_pads(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set padding for ``constrained_layout``. 
 
        Tip: The parameters can be passed from a dictionary by using 
        ``fig.set_constrained_layout(**pad_dict)``. 
 
        See :doc:`/tutorials/intermediate/constrainedlayout_guide`. 
 
        Parameters 
        ---------- 
        w_pad : float, default: :rc:`figure.constrained_layout.w_pad` 
            Width padding in inches.  This is the pad around Axes 
            and is meant to make sure there is enough room for fonts to 
            look good.  Defaults to 3 pts = 0.04167 inches 
 
        h_pad : float, default: :rc:`figure.constrained_layout.h_pad` 
            Height padding in inches. Defaults to 3 pts. 
 
        wspace : float, default: :rc:`figure.constrained_layout.wspace` 
            Width padding between subplots, expressed as a fraction of the 
            subplot width.  The total padding ends up being w_pad + wspace. 
 
        hspace : float, default: :rc:`figure.constrained_layout.hspace` 
            Height padding between subplots, expressed as a fraction of the 
            subplot width. The total padding ends up being h_pad + hspace. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.get_layout_engine()</span><span class="s2">, </span><span class="s1">ConstrainedLayoutEngine):</span>
            <span class="s1">self.get_layout_engine().set(**kwargs)</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;fig.get_layout_engine().get()&quot;</span><span class="s2">,</span>
                     <span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_constrained_layout_pads(self</span><span class="s2">, </span><span class="s1">relative=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get padding for ``constrained_layout``. 
 
        Returns a list of ``w_pad, h_pad`` in inches and 
        ``wspace`` and ``hspace`` as fractions of the subplot. 
        All values are None if ``constrained_layout`` is not used. 
 
        See :doc:`/tutorials/intermediate/constrainedlayout_guide`. 
 
        Parameters 
        ---------- 
        relative : bool 
            If `True`, then convert from inches to figure relative. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(self.get_layout_engine()</span><span class="s2">, </span><span class="s1">ConstrainedLayoutEngine):</span>
            <span class="s2">return None, None, None, None</span>
        <span class="s1">info = self.get_layout_engine().get_info()</span>
        <span class="s1">w_pad = info[</span><span class="s4">'w_pad'</span><span class="s1">]</span>
        <span class="s1">h_pad = info[</span><span class="s4">'h_pad'</span><span class="s1">]</span>
        <span class="s1">wspace = info[</span><span class="s4">'wspace'</span><span class="s1">]</span>
        <span class="s1">hspace = info[</span><span class="s4">'hspace'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">relative </span><span class="s2">and </span><span class="s1">(w_pad </span><span class="s2">is not None or </span><span class="s1">h_pad </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">renderer = self._get_renderer()</span>
            <span class="s1">dpi = renderer.dpi</span>
            <span class="s1">w_pad = w_pad * dpi / renderer.width</span>
            <span class="s1">h_pad = h_pad * dpi / renderer.height</span>

        <span class="s2">return </span><span class="s1">w_pad</span><span class="s2">, </span><span class="s1">h_pad</span><span class="s2">, </span><span class="s1">wspace</span><span class="s2">, </span><span class="s1">hspace</span>

    <span class="s2">def </span><span class="s1">set_canvas(self</span><span class="s2">, </span><span class="s1">canvas):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the canvas that contains the figure 
 
        Parameters 
        ---------- 
        canvas : FigureCanvas 
        &quot;&quot;&quot;</span>
        <span class="s1">self.canvas = canvas</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">figimage(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">xo=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">yo=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">origin=</span><span class="s2">None, </span><span class="s1">resize=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a non-resampled image to the figure. 
 
        The image is attached to the lower or upper left corner depending on 
        *origin*. 
 
        Parameters 
        ---------- 
        X 
            The image data. This is an array of one of the following shapes: 
 
            - (M, N): an image with scalar data.  Color-mapping is controlled 
              by *cmap*, *norm*, *vmin*, and *vmax*. 
            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int). 
            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int), 
              i.e. including transparency. 
 
        xo, yo : int 
            The *x*/*y* image offset in pixels. 
 
        alpha : None or float 
            The alpha blending value. 
 
        %(cmap_doc)s 
 
            This parameter is ignored if *X* is RGB(A). 
 
        %(norm_doc)s 
 
            This parameter is ignored if *X* is RGB(A). 
 
        %(vmin_vmax_doc)s 
 
            This parameter is ignored if *X* is RGB(A). 
 
        origin : {'upper', 'lower'}, default: :rc:`image.origin` 
            Indicates where the [0, 0] index of the array is in the upper left 
            or lower left corner of the axes. 
 
        resize : bool 
            If *True*, resize the figure to match the given image size. 
 
        Returns 
        ------- 
        `matplotlib.image.FigureImage` 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`. 
 
        Notes 
        ----- 
        figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`) 
        which will be resampled to fit the current Axes.  If you want 
        a resampled image to fill the entire figure, you can define an 
        `~matplotlib.axes.Axes` with extent [0, 0, 1, 1]. 
 
        Examples 
        -------- 
        :: 
 
            f = plt.figure() 
            nx = int(f.get_figwidth() * f.dpi) 
            ny = int(f.get_figheight() * f.dpi) 
            data = np.random.random((ny, nx)) 
            f.figimage(data) 
            plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">resize:</span>
            <span class="s1">dpi = self.get_dpi()</span>
            <span class="s1">figsize = [x / dpi </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">(X.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">])]</span>
            <span class="s1">self.set_size_inches(figsize</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">im = mimage.FigureImage(self</span><span class="s2">, </span><span class="s1">cmap=cmap</span><span class="s2">, </span><span class="s1">norm=norm</span><span class="s2">,</span>
                                <span class="s1">offsetx=xo</span><span class="s2">, </span><span class="s1">offsety=yo</span><span class="s2">,</span>
                                <span class="s1">origin=origin</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">im.stale_callback = _stale_figure_callback</span>

        <span class="s1">im.set_array(X)</span>
        <span class="s1">im.set_alpha(alpha)</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">im.set_clim(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s1">self.images.append(im)</span>
        <span class="s1">im._remove_method = self.images.remove</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">im</span>

    <span class="s2">def </span><span class="s1">set_size_inches(self</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h=</span><span class="s2">None, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the figure size in inches. 
 
        Call signatures:: 
 
             fig.set_size_inches(w, h)  # OR 
             fig.set_size_inches((w, h)) 
 
        Parameters 
        ---------- 
        w : (float, float) or float 
            Width and height in inches (if height not specified as a separate 
            argument) or width. 
        h : float 
            Height in inches. 
        forward : bool, default: True 
            If ``True``, the canvas size is automatically updated, e.g., 
            you can resize the figure window from the shell. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.get_size_inches 
        matplotlib.figure.Figure.set_figwidth 
        matplotlib.figure.Figure.set_figheight 
 
        Notes 
        ----- 
        To transform from pixels to inches divide by `Figure.dpi`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">h </span><span class="s2">is None</span><span class="s1">:  </span><span class="s3"># Got called with a single pair as argument.</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">h = w</span>
        <span class="s1">size = np.array([w</span><span class="s2">, </span><span class="s1">h])</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(size).all() </span><span class="s2">or </span><span class="s1">(size &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'figure size must be positive finite not </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self.bbox_inches.p1 = size</span>
        <span class="s2">if </span><span class="s1">forward:</span>
            <span class="s1">manager = self.canvas.manager</span>
            <span class="s2">if </span><span class="s1">manager </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">manager.resize(*(size * self.dpi).astype(int))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_size_inches(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the current size of the figure in inches. 
 
        Returns 
        ------- 
        ndarray 
           The size (width, height) of the figure in inches. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.set_size_inches 
        matplotlib.figure.Figure.get_figwidth 
        matplotlib.figure.Figure.get_figheight 
 
        Notes 
        ----- 
        The size in pixels can be obtained by multiplying with `Figure.dpi`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.array(self.bbox_inches.p1)</span>

    <span class="s2">def </span><span class="s1">get_figwidth(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the figure width in inches.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.bbox_inches.width</span>

    <span class="s2">def </span><span class="s1">get_figheight(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the figure height in inches.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.bbox_inches.height</span>

    <span class="s2">def </span><span class="s1">get_dpi(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the resolution in dots per inch as a float.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.dpi</span>

    <span class="s2">def </span><span class="s1">set_dpi(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the resolution of the figure in dots-per-inch. 
 
        Parameters 
        ---------- 
        val : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.dpi = val</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_figwidth(self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the width of the figure in inches. 
 
        Parameters 
        ---------- 
        val : float 
        forward : bool 
            See `set_size_inches`. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.set_figheight 
        matplotlib.figure.Figure.set_size_inches 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_size_inches(val</span><span class="s2">, </span><span class="s1">self.get_figheight()</span><span class="s2">, </span><span class="s1">forward=forward)</span>

    <span class="s2">def </span><span class="s1">set_figheight(self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the height of the figure in inches. 
 
        Parameters 
        ---------- 
        val : float 
        forward : bool 
            See `set_size_inches`. 
 
        See Also 
        -------- 
        matplotlib.figure.Figure.set_figwidth 
        matplotlib.figure.Figure.set_size_inches 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_size_inches(self.get_figwidth()</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">forward=forward)</span>

    <span class="s2">def </span><span class="s1">clear(self</span><span class="s2">, </span><span class="s1">keep_observers=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">super().clear(keep_observers=keep_observers)</span>
        <span class="s3"># FigureBase.clear does not clear toolbars, as</span>
        <span class="s3"># only Figure can have toolbars</span>
        <span class="s1">toolbar = self.canvas.toolbar</span>
        <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">toolbar.update()</span>

    <span class="s1">@_finalize_rasterization</span>
    <span class="s1">@allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s3"># draw the figure bounding box, perhaps none for white figure</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s1">artists = self._get_draw_artists(renderer)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">renderer.open_group(</span><span class="s4">'figure'</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>
            <span class="s2">if </span><span class="s1">self.axes </span><span class="s2">and </span><span class="s1">self.get_layout_engine() </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">self.get_layout_engine().execute(self)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">pass</span>
                    <span class="s3"># ValueError can occur when resizing a window.</span>

            <span class="s1">self.patch.draw(renderer)</span>
            <span class="s1">mimage._draw_list_compositing_images(</span>
                <span class="s1">renderer</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">artists</span><span class="s2">, </span><span class="s1">self.suppressComposite)</span>

            <span class="s2">for </span><span class="s1">sfig </span><span class="s2">in </span><span class="s1">self.subfigs:</span>
                <span class="s1">sfig.draw(renderer)</span>

            <span class="s1">renderer.close_group(</span><span class="s4">'figure'</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.stale = </span><span class="s2">False</span>

        <span class="s1">DrawEvent(</span><span class="s4">&quot;draw_event&quot;</span><span class="s2">, </span><span class="s1">self.canvas</span><span class="s2">, </span><span class="s1">renderer)._process()</span>

    <span class="s2">def </span><span class="s1">draw_without_rendering(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw the figure with no output.  Useful to get the final size of 
        artists that require a draw before their size is known (e.g. text). 
        &quot;&quot;&quot;</span>
        <span class="s1">renderer = _get_renderer(self)</span>
        <span class="s2">with </span><span class="s1">renderer._draw_disabled():</span>
            <span class="s1">self.draw(renderer)</span>

    <span class="s2">def </span><span class="s1">draw_artist(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw `.Artist` *a* only. 
        &quot;&quot;&quot;</span>
        <span class="s1">a.draw(self.canvas.get_renderer())</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">state = super().__getstate__()</span>

        <span class="s3"># The canvas cannot currently be pickled, but this has the benefit</span>
        <span class="s3"># of meaning that a figure can be detached from one canvas, and</span>
        <span class="s3"># re-attached to another.</span>
        <span class="s1">state.pop(</span><span class="s4">&quot;canvas&quot;</span><span class="s1">)</span>

        <span class="s3"># discard any changes to the dpi due to pixel ratio changes</span>
        <span class="s1">state[</span><span class="s4">&quot;_dpi&quot;</span><span class="s1">] = state.get(</span><span class="s4">'_original_dpi'</span><span class="s2">, </span><span class="s1">state[</span><span class="s4">'_dpi'</span><span class="s1">])</span>

        <span class="s3"># add version information to the state</span>
        <span class="s1">state[</span><span class="s4">'__mpl_version__'</span><span class="s1">] = mpl.__version__</span>

        <span class="s3"># check whether the figure manager (if any) is registered with pyplot</span>
        <span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_pylab_helpers</span>
        <span class="s2">if </span><span class="s1">self.canvas.manager </span><span class="s2">in </span><span class="s1">_pylab_helpers.Gcf.figs.values():</span>
            <span class="s1">state[</span><span class="s4">'_restore_to_pylab'</span><span class="s1">] = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">state</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s1">version = state.pop(</span><span class="s4">'__mpl_version__'</span><span class="s1">)</span>
        <span class="s1">restore_to_pylab = state.pop(</span><span class="s4">'_restore_to_pylab'</span><span class="s2">, False</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">version != mpl.__version__:</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s4">f&quot;This figure was saved with matplotlib version </span><span class="s2">{</span><span class="s1">version</span><span class="s2">} </span><span class="s4">and &quot;</span>
                <span class="s4">f&quot;is unlikely to function correctly.&quot;</span><span class="s1">)</span>

        <span class="s1">self.__dict__ = state</span>

        <span class="s3"># re-initialise some of the unstored state information</span>
        <span class="s1">FigureCanvasBase(self)  </span><span class="s3"># Set self.canvas.</span>

        <span class="s2">if </span><span class="s1">restore_to_pylab:</span>
            <span class="s3"># lazy import to avoid circularity</span>
            <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
            <span class="s2">import </span><span class="s1">matplotlib._pylab_helpers </span><span class="s2">as </span><span class="s1">pylab_helpers</span>
            <span class="s1">allnums = plt.get_fignums()</span>
            <span class="s1">num = max(allnums) + </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">allnums </span><span class="s2">else </span><span class="s5">1</span>
            <span class="s1">backend = plt._get_backend_mod()</span>
            <span class="s1">mgr = backend.new_figure_manager_given_figure(num</span><span class="s2">, </span><span class="s1">self)</span>
            <span class="s1">pylab_helpers.Gcf._set_new_active_manager(mgr)</span>
            <span class="s1">plt.draw_if_interactive()</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">add_axobserver(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot;Whenever the Axes state change, ``func(self)`` will be called.&quot;&quot;&quot;</span>
        <span class="s3"># Connect a wrapper lambda and not func itself, to avoid it being</span>
        <span class="s3"># weakref-collected.</span>
        <span class="s1">self._axobservers.connect(</span><span class="s4">&quot;_axes_change_event&quot;</span><span class="s2">, lambda </span><span class="s1">arg: func(arg))</span>

    <span class="s2">def </span><span class="s1">savefig(self</span><span class="s2">, </span><span class="s1">fname</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">transparent=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Save the current figure. 
 
        Call signature:: 
 
          savefig(fname, *, dpi='figure', format=None, metadata=None, 
                  bbox_inches=None, pad_inches=0.1, 
                  facecolor='auto', edgecolor='auto', 
                  backend=None, **kwargs 
                 ) 
 
        The available output formats depend on the backend being used. 
 
        Parameters 
        ---------- 
        fname : str or path-like or binary file-like 
            A path, or a Python file-like object, or 
            possibly some backend-dependent object such as 
            `matplotlib.backends.backend_pdf.PdfPages`. 
 
            If *format* is set, it determines the output format, and the file 
            is saved as *fname*.  Note that *fname* is used verbatim, and there 
            is no attempt to make the extension, if any, of *fname* match 
            *format*, and no extension is appended. 
 
            If *format* is not set, then the format is inferred from the 
            extension of *fname*, if there is one.  If *format* is not 
            set and *fname* has no extension, then the file is saved with 
            :rc:`savefig.format` and the appropriate extension is appended to 
            *fname*. 
 
        Other Parameters 
        ---------------- 
        dpi : float or 'figure', default: :rc:`savefig.dpi` 
            The resolution in dots per inch.  If 'figure', use the figure's 
            dpi value. 
 
        format : str 
            The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when 
            this is unset is documented under *fname*. 
 
        metadata : dict, optional 
            Key/value pairs to store in the image metadata. The supported keys 
            and defaults depend on the image format and backend: 
 
            - 'png' with Agg backend: See the parameter ``metadata`` of 
              `~.FigureCanvasAgg.print_png`. 
            - 'pdf' with pdf backend: See the parameter ``metadata`` of 
              `~.backend_pdf.PdfPages`. 
            - 'svg' with svg backend: See the parameter ``metadata`` of 
              `~.FigureCanvasSVG.print_svg`. 
            - 'eps' and 'ps' with PS backend: Only 'Creator' is supported. 
 
        bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox` 
            Bounding box in inches: only the given portion of the figure is 
            saved.  If 'tight', try to figure out the tight bbox of the figure. 
 
        pad_inches : float, default: :rc:`savefig.pad_inches` 
            Amount of padding around the figure when bbox_inches is 'tight'. 
 
        facecolor : color or 'auto', default: :rc:`savefig.facecolor` 
            The facecolor of the figure.  If 'auto', use the current figure 
            facecolor. 
 
        edgecolor : color or 'auto', default: :rc:`savefig.edgecolor` 
            The edgecolor of the figure.  If 'auto', use the current figure 
            edgecolor. 
 
        backend : str, optional 
            Use a non-default backend to render the file, e.g. to render a 
            png file with the &quot;cairo&quot; backend rather than the default &quot;agg&quot;, 
            or a pdf file with the &quot;pgf&quot; backend rather than the default 
            &quot;pdf&quot;.  Note that the default backend is normally sufficient.  See 
            :ref:`the-builtin-backends` for a list of valid backends for each 
            file format.  Custom backends can be referenced as &quot;module://...&quot;. 
 
        orientation : {'landscape', 'portrait'} 
            Currently only supported by the postscript backend. 
 
        papertype : str 
            One of 'letter', 'legal', 'executive', 'ledger', 'a0' through 
            'a10', 'b0' through 'b10'. Only supported for postscript 
            output. 
 
        transparent : bool 
            If *True*, the Axes patches will all be transparent; the 
            Figure patch will also be transparent unless *facecolor* 
            and/or *edgecolor* are specified via kwargs. 
 
            If *False* has no effect and the color of the Axes and 
            Figure patches are unchanged (unless the Figure patch 
            is specified via the *facecolor* and/or *edgecolor* keyword 
            arguments in which case those colors are used). 
 
            The transparency of these patches will be restored to their 
            original values upon exit of this function. 
 
            This is useful, for example, for displaying 
            a plot on top of a colored background on a web page. 
 
        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional 
            A list of extra artists that will be considered when the 
            tight bbox is calculated. 
 
        pil_kwargs : dict, optional 
            Additional keyword arguments that are passed to 
            `PIL.Image.Image.save` when saving the figure. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">kwargs.setdefault(</span><span class="s4">'dpi'</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">'savefig.dpi'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">transparent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">transparent = mpl.rcParams[</span><span class="s4">'savefig.transparent'</span><span class="s1">]</span>

        <span class="s2">with </span><span class="s1">ExitStack() </span><span class="s2">as </span><span class="s1">stack:</span>
            <span class="s2">if </span><span class="s1">transparent:</span>
                <span class="s1">kwargs.setdefault(</span><span class="s4">'facecolor'</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">)</span>
                <span class="s1">kwargs.setdefault(</span><span class="s4">'edgecolor'</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">)</span>
                <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes:</span>
                    <span class="s1">stack.enter_context(</span>
                        <span class="s1">ax.patch._cm_set(facecolor=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">edgecolor=</span><span class="s4">'none'</span><span class="s1">))</span>

            <span class="s1">self.canvas.print_figure(fname</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">ginput(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s5">30</span><span class="s2">, </span><span class="s1">show_clicks=</span><span class="s2">True,</span>
               <span class="s1">mouse_add=MouseButton.LEFT</span><span class="s2">,</span>
               <span class="s1">mouse_pop=MouseButton.RIGHT</span><span class="s2">,</span>
               <span class="s1">mouse_stop=MouseButton.MIDDLE):</span>
        <span class="s0">&quot;&quot;&quot; 
        Blocking call to interact with a figure. 
 
        Wait until the user clicks *n* times on the figure, and return the 
        coordinates of each click in a list. 
 
        There are three possible interactions: 
 
        - Add a point. 
        - Remove the most recently added point. 
        - Stop the interaction and return the points added so far. 
 
        The actions are assigned to mouse buttons via the arguments 
        *mouse_add*, *mouse_pop* and *mouse_stop*. 
 
        Parameters 
        ---------- 
        n : int, default: 1 
            Number of mouse clicks to accumulate. If negative, accumulate 
            clicks until the input is terminated manually. 
        timeout : float, default: 30 seconds 
            Number of seconds to wait before timing out. If zero or negative 
            will never time out. 
        show_clicks : bool, default: True 
            If True, show a red cross at the location of each click. 
        mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT` 
            Mouse button used to add points. 
        mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT` 
            Mouse button used to remove the most recently added point. 
        mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE` 
            Mouse button used to stop input. 
 
        Returns 
        ------- 
        list of tuples 
            A list of the clicked (x, y) coordinates. 
 
        Notes 
        ----- 
        The keyboard can also be used to select points in case your mouse 
        does not have one or more of the buttons.  The delete and backspace 
        keys act like right-clicking (i.e., remove last point), the enter key 
        terminates input and any other key (not already used by the window 
        manager) selects a point. 
        &quot;&quot;&quot;</span>
        <span class="s1">clicks = []</span>
        <span class="s1">marks = []</span>

        <span class="s2">def </span><span class="s1">handler(event):</span>
            <span class="s1">is_button = event.name == </span><span class="s4">&quot;button_press_event&quot;</span>
            <span class="s1">is_key = event.name == </span><span class="s4">&quot;key_press_event&quot;</span>
            <span class="s3"># Quit (even if not in infinite mode; this is consistent with</span>
            <span class="s3"># MATLAB and sometimes quite useful, but will require the user to</span>
            <span class="s3"># test how many points were actually returned before using data).</span>
            <span class="s2">if </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == mouse_stop</span>
                    <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;escape&quot;</span><span class="s2">, </span><span class="s4">&quot;enter&quot;</span><span class="s1">]):</span>
                <span class="s1">self.canvas.stop_event_loop()</span>
            <span class="s3"># Pop last click.</span>
            <span class="s2">elif </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == mouse_pop</span>
                  <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;backspace&quot;</span><span class="s2">, </span><span class="s4">&quot;delete&quot;</span><span class="s1">]):</span>
                <span class="s2">if </span><span class="s1">clicks:</span>
                    <span class="s1">clicks.pop()</span>
                    <span class="s2">if </span><span class="s1">show_clicks:</span>
                        <span class="s1">marks.pop().remove()</span>
                        <span class="s1">self.canvas.draw()</span>
            <span class="s3"># Add new click.</span>
            <span class="s2">elif </span><span class="s1">(is_button </span><span class="s2">and </span><span class="s1">event.button == mouse_add</span>
                  <span class="s3"># On macOS/gtk, some keys return None.</span>
                  <span class="s2">or </span><span class="s1">is_key </span><span class="s2">and </span><span class="s1">event.key </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">event.inaxes:</span>
                    <span class="s1">clicks.append((event.xdata</span><span class="s2">, </span><span class="s1">event.ydata))</span>
                    <span class="s1">_log.info(</span><span class="s4">&quot;input %i: %f, %f&quot;</span><span class="s2">,</span>
                              <span class="s1">len(clicks)</span><span class="s2">, </span><span class="s1">event.xdata</span><span class="s2">, </span><span class="s1">event.ydata)</span>
                    <span class="s2">if </span><span class="s1">show_clicks:</span>
                        <span class="s1">line = mpl.lines.Line2D([event.xdata]</span><span class="s2">, </span><span class="s1">[event.ydata]</span><span class="s2">,</span>
                                                <span class="s1">marker=</span><span class="s4">&quot;+&quot;</span><span class="s2">, </span><span class="s1">color=</span><span class="s4">&quot;r&quot;</span><span class="s1">)</span>
                        <span class="s1">event.inaxes.add_line(line)</span>
                        <span class="s1">marks.append(line)</span>
                        <span class="s1">self.canvas.draw()</span>
            <span class="s2">if </span><span class="s1">len(clicks) == n </span><span class="s2">and </span><span class="s1">n &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.canvas.stop_event_loop()</span>

        <span class="s1">_blocking_input.blocking_input_loop(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;button_press_event&quot;</span><span class="s2">, </span><span class="s4">&quot;key_press_event&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">handler)</span>

        <span class="s3"># Cleanup.</span>
        <span class="s2">for </span><span class="s1">mark </span><span class="s2">in </span><span class="s1">marks:</span>
            <span class="s1">mark.remove()</span>
        <span class="s1">self.canvas.draw()</span>

        <span class="s2">return </span><span class="s1">clicks</span>

    <span class="s2">def </span><span class="s1">waitforbuttonpress(self</span><span class="s2">, </span><span class="s1">timeout=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Blocking call to interact with the figure. 
 
        Wait for user input and return True if a key was pressed, False if a 
        mouse button was pressed and None if no input was given within 
        *timeout* seconds.  Negative values deactivate *timeout*. 
        &quot;&quot;&quot;</span>
        <span class="s1">event = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">handler(ev):</span>
            <span class="s2">nonlocal </span><span class="s1">event</span>
            <span class="s1">event = ev</span>
            <span class="s1">self.canvas.stop_event_loop()</span>

        <span class="s1">_blocking_input.blocking_input_loop(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;button_press_event&quot;</span><span class="s2">, </span><span class="s4">&quot;key_press_event&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">, </span><span class="s1">handler)</span>

        <span class="s2">return None if </span><span class="s1">event </span><span class="s2">is None else </span><span class="s1">event.name == </span><span class="s4">&quot;key_press_event&quot;</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;figure.get_layout_engine().execute()&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">execute_constrained_layout(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Use ``layoutgrid`` to determine pos positions within Axes. 
 
        See also `.set_constrained_layout_pads`. 
 
        Returns 
        ------- 
        layoutgrid : private debugging object 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(self.get_layout_engine()</span><span class="s2">, </span><span class="s1">ConstrainedLayoutEngine):</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self.get_layout_engine().execute(self)</span>

    <span class="s2">def </span><span class="s1">tight_layout(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">pad=</span><span class="s5">1.08</span><span class="s2">, </span><span class="s1">h_pad=</span><span class="s2">None, </span><span class="s1">w_pad=</span><span class="s2">None, </span><span class="s1">rect=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust the padding between and around subplots. 
 
        To exclude an artist on the Axes from the bounding box calculation 
        that determines the subplot parameters (i.e. legend, or annotation), 
        set ``a.set_in_layout(False)`` for that artist. 
 
        Parameters 
        ---------- 
        pad : float, default: 1.08 
            Padding between the figure edge and the edges of subplots, 
            as a fraction of the font size. 
        h_pad, w_pad : float, default: *pad* 
            Padding (height/width) between edges of adjacent subplots, 
            as a fraction of the font size. 
        rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1) 
            A rectangle in normalized figure coordinates into which the whole 
            subplots area (including labels) will fit. 
 
        See Also 
        -------- 
        .Figure.set_layout_engine 
        .pyplot.tight_layout 
        &quot;&quot;&quot;</span>
        <span class="s3"># note that here we do not permanently set the figures engine to</span>
        <span class="s3"># tight_layout but rather just perform the layout in place and remove</span>
        <span class="s3"># any previous engines.</span>
        <span class="s1">engine = TightLayoutEngine(pad=pad</span><span class="s2">, </span><span class="s1">h_pad=h_pad</span><span class="s2">, </span><span class="s1">w_pad=w_pad</span><span class="s2">,</span>
                                   <span class="s1">rect=rect)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">previous_engine = self.get_layout_engine()</span>
            <span class="s1">self.set_layout_engine(engine)</span>
            <span class="s1">engine.execute(self)</span>
            <span class="s2">if not </span><span class="s1">isinstance(previous_engine</span><span class="s2">, </span><span class="s1">TightLayoutEngine) \</span>
                    <span class="s2">and </span><span class="s1">previous_engine </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s4">'The figure layout has changed to tight'</span><span class="s1">)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.set_layout_engine(</span><span class="s2">None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">figaspect(arg):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the width and height for a figure with a specified aspect ratio. 
 
    While the height is taken from :rc:`figure.figsize`, the width is 
    adjusted to match the desired aspect ratio. Additionally, it is ensured 
    that the width is in the range [4., 16.] and the height is in the range 
    [2., 16.]. If necessary, the default height is adjusted to ensure this. 
 
    Parameters 
    ---------- 
    arg : float or 2D array 
        If a float, this defines the aspect ratio (i.e. the ratio height / 
        width). 
        In case of an array the aspect ratio is number of rows / number of 
        columns, so that the array could be fitted in the figure undistorted. 
 
    Returns 
    ------- 
    width, height : float 
        The figure size in inches. 
 
    Notes 
    ----- 
    If you want to create an Axes within the figure, that still preserves the 
    aspect ratio, be sure to create it with equal width and height. See 
    examples below. 
 
    Thanks to Fernando Perez for this function. 
 
    Examples 
    -------- 
    Make a figure twice as tall as it is wide:: 
 
        w, h = figaspect(2.) 
        fig = Figure(figsize=(w, h)) 
        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8]) 
        ax.imshow(A, **kwargs) 
 
    Make a figure with the proper aspect for an array:: 
 
        A = rand(5, 3) 
        w, h = figaspect(A) 
        fig = Figure(figsize=(w, h)) 
        ax = fig.add_axes([0.1, 0.1, 0.8, 0.8]) 
        ax.imshow(A, **kwargs) 
    &quot;&quot;&quot;</span>

    <span class="s1">isarray = hasattr(arg</span><span class="s2">, </span><span class="s4">'shape'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">np.isscalar(arg)</span>

    <span class="s3"># min/max sizes to respect when autoscaling.  If John likes the idea, they</span>
    <span class="s3"># could become rc parameters, for now they're hardwired.</span>
    <span class="s1">figsize_min = np.array((</span><span class="s5">4.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s1">))  </span><span class="s3"># min length for width/height</span>
    <span class="s1">figsize_max = np.array((</span><span class="s5">16.0</span><span class="s2">, </span><span class="s5">16.0</span><span class="s1">))  </span><span class="s3"># max length for width/height</span>

    <span class="s3"># Extract the aspect ratio of the array</span>
    <span class="s2">if </span><span class="s1">isarray:</span>
        <span class="s1">nr</span><span class="s2">, </span><span class="s1">nc = arg.shape[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">arr_ratio = nr / nc</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">arr_ratio = arg</span>

    <span class="s3"># Height of user figure defaults</span>
    <span class="s1">fig_height = mpl.rcParams[</span><span class="s4">'figure.figsize'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3"># New size for the figure, keeping the aspect ratio of the caller</span>
    <span class="s1">newsize = np.array((fig_height / arr_ratio</span><span class="s2">, </span><span class="s1">fig_height))</span>

    <span class="s3"># Sanity checks, don't drop either dimension below figsize_min</span>
    <span class="s1">newsize /= min(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">*(newsize / figsize_min))</span>

    <span class="s3"># Avoid humongous windows as well</span>
    <span class="s1">newsize /= max(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">*(newsize / figsize_max))</span>

    <span class="s3"># Finally, if we have a really funky aspect ratio, break it but respect</span>
    <span class="s3"># the min/max dimensions (we don't want figures 10 feet tall!)</span>
    <span class="s1">newsize = np.clip(newsize</span><span class="s2">, </span><span class="s1">figsize_min</span><span class="s2">, </span><span class="s1">figsize_max)</span>
    <span class="s2">return </span><span class="s1">newsize</span>
</pre>
</body>
</html>