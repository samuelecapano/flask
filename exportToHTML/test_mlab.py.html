<html>
<head>
<title>test_mlab.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mlab.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_allclose</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal_nulp)</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">mlab</span><span class="s0">, </span><span class="s1">_api</span>


<span class="s0">class </span><span class="s1">TestStride:</span>
    <span class="s0">def </span><span class="s1">get_base(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">y = x</span>
        <span class="s0">while </span><span class="s1">y.base </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">y = y.base</span>
        <span class="s0">return </span><span class="s1">y</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">stride_is_deprecated(self):</span>
        <span class="s0">with </span><span class="s1">_api.suppress_matplotlib_deprecation_warning():</span>
            <span class="s0">yield</span>

    <span class="s0">def </span><span class="s1">calc_window_target(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">NFFT</span><span class="s0">, </span><span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        This is an adaptation of the original window extraction algorithm. 
        This is here to test to make sure the new implementation has the same 
        result. 
        &quot;&quot;&quot;</span>
        <span class="s1">step = NFFT - noverlap</span>
        <span class="s1">ind = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">len(x) - NFFT + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">step)</span>
        <span class="s1">n = len(ind)</span>
        <span class="s1">result = np.zeros((NFFT</span><span class="s0">, </span><span class="s1">n))</span>

        <span class="s4"># do the ffts of the slices</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s1">result[:</span><span class="s0">, </span><span class="s1">i] = x[ind[i]:ind[i]+NFFT]</span>
        <span class="s0">if </span><span class="s1">axis == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">result = result.T</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'shape'</span><span class="s0">, </span><span class="s1">[()</span><span class="s0">, </span><span class="s1">(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s5">'0D'</span><span class="s0">, </span><span class="s5">'2D'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_stride_windows_invalid_input_shape(self</span><span class="s0">, </span><span class="s1">shape):</span>
        <span class="s1">x = np.arange(np.prod(shape)).reshape(shape)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.stride_windows(x</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'n, noverlap'</span><span class="s0">,</span>
                             <span class="s1">[(</span><span class="s2">0</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">11</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)]</span><span class="s0">,</span>
                             <span class="s1">ids=[</span><span class="s5">'n less than 1'</span><span class="s0">, </span><span class="s5">'n greater than input'</span><span class="s0">,</span>
                                  <span class="s5">'noverlap greater than n'</span><span class="s0">,</span>
                                  <span class="s5">'noverlap equal to n'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_stride_windows_invalid_params(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">noverlap):</span>
        <span class="s1">x = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.stride_windows(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">noverlap)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'axis'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s5">'axis0'</span><span class="s0">, </span><span class="s5">'axis1'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'n, noverlap'</span><span class="s0">,</span>
                             <span class="s1">[(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">15</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">13</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">)]</span><span class="s0">,</span>
                             <span class="s1">ids=[</span><span class="s5">'n1-noverlap0'</span><span class="s0">, </span><span class="s5">'n5-noverlap0'</span><span class="s0">,</span>
                                  <span class="s5">'n15-noverlap2'</span><span class="s0">, </span><span class="s5">'n13-noverlapn3'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_stride_windows(self</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">noverlap</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">x = np.arange(</span><span class="s2">100</span><span class="s1">)</span>
        <span class="s1">y = mlab.stride_windows(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">noverlap=noverlap</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s1">expected_shape = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">expected_shape[axis] = n</span>
        <span class="s1">expected_shape[</span><span class="s2">1 </span><span class="s1">- axis] = </span><span class="s2">100 </span><span class="s1">// (n - noverlap)</span>
        <span class="s1">yt = self.calc_window_target(x</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">noverlap=noverlap</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s0">assert </span><span class="s1">yt.shape == y.shape</span>
        <span class="s1">assert_array_equal(yt</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">assert </span><span class="s1">tuple(expected_shape) == y.shape</span>
        <span class="s0">assert </span><span class="s1">self.get_base(y) </span><span class="s0">is </span><span class="s1">x</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'axis'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ids=[</span><span class="s5">'axis0'</span><span class="s0">, </span><span class="s5">'axis1'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_stride_windows_n32_noverlap0_unflatten(self</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">n = </span><span class="s2">32</span>
        <span class="s1">x = np.arange(n)[np.newaxis]</span>
        <span class="s1">x1 = np.tile(x</span><span class="s0">, </span><span class="s1">(</span><span class="s2">21</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">x2 = x1.flatten()</span>
        <span class="s1">y = mlab.stride_windows(x2</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">axis=axis)</span>

        <span class="s0">if </span><span class="s1">axis == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">x1 = x1.T</span>
        <span class="s0">assert </span><span class="s1">y.shape == x1.shape</span>
        <span class="s1">assert_array_equal(y</span><span class="s0">, </span><span class="s1">x1)</span>


<span class="s0">def </span><span class="s1">test_window():</span>
    <span class="s1">np.random.seed(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s2">1000</span>
    <span class="s1">rand = np.random.standard_normal(n) + </span><span class="s2">100</span>
    <span class="s1">ones = np.ones(n)</span>
    <span class="s1">assert_array_equal(mlab.window_none(ones)</span><span class="s0">, </span><span class="s1">ones)</span>
    <span class="s1">assert_array_equal(mlab.window_none(rand)</span><span class="s0">, </span><span class="s1">rand)</span>
    <span class="s1">assert_array_equal(np.hanning(len(rand)) * rand</span><span class="s0">, </span><span class="s1">mlab.window_hanning(rand))</span>
    <span class="s1">assert_array_equal(np.hanning(len(ones))</span><span class="s0">, </span><span class="s1">mlab.window_hanning(ones))</span>


<span class="s0">class </span><span class="s1">TestDetrend:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s2">1000</span>
        <span class="s1">x = np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s1">n)</span>

        <span class="s1">self.sig_zeros = np.zeros(n)</span>

        <span class="s1">self.sig_off = self.sig_zeros + </span><span class="s2">100.</span>
        <span class="s1">self.sig_slope = np.linspace(-</span><span class="s2">10.</span><span class="s0">, </span><span class="s2">90.</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">self.sig_slope_mean = x - x.mean()</span>

        <span class="s1">self.sig_base = (</span>
            <span class="s1">np.random.standard_normal(n) + np.sin(x*</span><span class="s2">2</span><span class="s1">*np.pi/(n/</span><span class="s2">100</span><span class="s1">)))</span>
        <span class="s1">self.sig_base -= self.sig_base.mean()</span>

    <span class="s0">def </span><span class="s1">allclose(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">assert_allclose(*args</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_detrend_none(self):</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend_none(</span><span class="s2">0.</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend_none(</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend(</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;none&quot;</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend(</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">key=mlab.detrend_none) == </span><span class="s2">0.</span>
        <span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">[</span>
                <span class="s2">5.5</span><span class="s0">, </span><span class="s1">self.sig_off</span><span class="s0">, </span><span class="s1">self.sig_slope</span><span class="s0">, </span><span class="s1">self.sig_base</span><span class="s0">,</span>
                <span class="s1">(self.sig_base + self.sig_slope + self.sig_off).tolist()</span><span class="s0">,</span>
                <span class="s1">np.vstack([self.sig_base</span><span class="s0">,  </span><span class="s4"># 2D case.</span>
                           <span class="s1">self.sig_base + self.sig_off</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_slope</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_off + self.sig_slope])</span><span class="s0">,</span>
                <span class="s1">np.vstack([self.sig_base</span><span class="s0">,  </span><span class="s4"># 2D transposed case.</span>
                           <span class="s1">self.sig_base + self.sig_off</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_slope</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_off + self.sig_slope]).T</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">isinstance(sig</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">assert_array_equal(mlab.detrend_none(sig)</span><span class="s0">, </span><span class="s1">sig)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">mlab.detrend_none(sig) == sig</span>

    <span class="s0">def </span><span class="s1">test_detrend_mean(self):</span>
        <span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">5.5</span><span class="s1">]:  </span><span class="s4"># 0D.</span>
            <span class="s0">assert </span><span class="s1">mlab.detrend_mean(sig) == </span><span class="s2">0.</span>
            <span class="s0">assert </span><span class="s1">mlab.detrend(sig</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;mean&quot;</span><span class="s1">) == </span><span class="s2">0.</span>
            <span class="s0">assert </span><span class="s1">mlab.detrend(sig</span><span class="s0">, </span><span class="s1">key=mlab.detrend_mean) == </span><span class="s2">0.</span>
        <span class="s4"># 1D.</span>
        <span class="s1">self.allclose(mlab.detrend_mean(self.sig_zeros)</span><span class="s0">, </span><span class="s1">self.sig_zeros)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(self.sig_base)</span><span class="s0">, </span><span class="s1">self.sig_base)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(self.sig_base + self.sig_off)</span><span class="s0">,</span>
                      <span class="s1">self.sig_base)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(self.sig_base + self.sig_slope)</span><span class="s0">,</span>
                      <span class="s1">self.sig_base + self.sig_slope_mean)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend_mean(self.sig_base + self.sig_slope + self.sig_off)</span><span class="s0">,</span>
            <span class="s1">self.sig_base + self.sig_slope_mean)</span>

    <span class="s0">def </span><span class="s1">test_detrend_mean_1d_base_slope_off_list_andor_axis0(self):</span>
        <span class="s1">input = self.sig_base + self.sig_slope + self.sig_off</span>
        <span class="s1">target = self.sig_base + self.sig_slope_mean</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input.tolist())</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input.tolist()</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>

    <span class="s0">def </span><span class="s1">test_detrend_mean_2d(self):</span>
        <span class="s1">input = np.vstack([self.sig_off</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_off])</span>
        <span class="s1">target = np.vstack([self.sig_zeros</span><span class="s0">,</span>
                            <span class="s1">self.sig_base])</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input.T</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">).T</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend(input)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend(input</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input.T</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;constant&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>

        <span class="s1">input = np.vstack([self.sig_base</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_off</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_slope</span><span class="s0">,</span>
                           <span class="s1">self.sig_base + self.sig_off + self.sig_slope])</span>
        <span class="s1">target = np.vstack([self.sig_base</span><span class="s0">,</span>
                            <span class="s1">self.sig_base</span><span class="s0">,</span>
                            <span class="s1">self.sig_base + self.sig_slope_mean</span><span class="s0">,</span>
                            <span class="s1">self.sig_base + self.sig_slope_mean])</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input.T</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_mean(input</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend(input</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;default&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend(input.T</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input.T</span><span class="s0">, </span><span class="s1">key=mlab.detrend_mean</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>

    <span class="s0">def </span><span class="s1">test_detrend_ValueError(self):</span>
        <span class="s0">for </span><span class="s1">signal</span><span class="s0">, </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">[</span>
                <span class="s1">(self.sig_slope[np.newaxis]</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;key&quot;</span><span class="s1">: </span><span class="s5">&quot;spam&quot;</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(self.sig_slope[np.newaxis]</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;key&quot;</span><span class="s1">: </span><span class="s2">5</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s2">5.5</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">0</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(self.sig_slope</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">1</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(self.sig_slope[np.newaxis]</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">2</span><span class="s1">})</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s1">mlab.detrend(signal</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_detrend_mean_ValueError(self):</span>
        <span class="s0">for </span><span class="s1">signal</span><span class="s0">, </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">[</span>
                <span class="s1">(</span><span class="s2">5.5</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">0</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(self.sig_slope</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">1</span><span class="s1">})</span><span class="s0">,</span>
                <span class="s1">(self.sig_slope[np.newaxis]</span><span class="s0">, </span><span class="s1">{</span><span class="s5">&quot;axis&quot;</span><span class="s1">: </span><span class="s2">2</span><span class="s1">})</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s1">mlab.detrend_mean(signal</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_detrend_linear(self):</span>
        <span class="s4"># 0D.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend_linear(</span><span class="s2">0.</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend_linear(</span><span class="s2">5.5</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend(</span><span class="s2">5.5</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;linear&quot;</span><span class="s1">) == </span><span class="s2">0.</span>
        <span class="s0">assert </span><span class="s1">mlab.detrend(</span><span class="s2">5.5</span><span class="s0">, </span><span class="s1">key=mlab.detrend_linear) == </span><span class="s2">0.</span>
        <span class="s0">for </span><span class="s1">sig </span><span class="s0">in </span><span class="s1">[  </span><span class="s4"># 1D.</span>
                <span class="s1">self.sig_off</span><span class="s0">,</span>
                <span class="s1">self.sig_slope</span><span class="s0">,</span>
                <span class="s1">self.sig_slope + self.sig_off</span><span class="s0">,</span>
        <span class="s1">]:</span>
            <span class="s1">self.allclose(mlab.detrend_linear(sig)</span><span class="s0">, </span><span class="s1">self.sig_zeros)</span>

    <span class="s0">def </span><span class="s1">test_detrend_str_linear_1d(self):</span>
        <span class="s1">input = self.sig_slope + self.sig_off</span>
        <span class="s1">target = self.sig_zeros</span>
        <span class="s1">self.allclose(mlab.detrend(input</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;linear&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend(input</span><span class="s0">, </span><span class="s1">key=mlab.detrend_linear)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(mlab.detrend_linear(input.tolist())</span><span class="s0">, </span><span class="s1">target)</span>

    <span class="s0">def </span><span class="s1">test_detrend_linear_2d(self):</span>
        <span class="s1">input = np.vstack([self.sig_off</span><span class="s0">,</span>
                           <span class="s1">self.sig_slope</span><span class="s0">,</span>
                           <span class="s1">self.sig_slope + self.sig_off])</span>
        <span class="s1">target = np.vstack([self.sig_zeros</span><span class="s0">,</span>
                            <span class="s1">self.sig_zeros</span><span class="s0">,</span>
                            <span class="s1">self.sig_zeros])</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input.T</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input.T</span><span class="s0">, </span><span class="s1">key=mlab.detrend_linear</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target.T)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input</span><span class="s0">, </span><span class="s1">key=</span><span class="s5">&quot;linear&quot;</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>
        <span class="s1">self.allclose(</span>
            <span class="s1">mlab.detrend(input</span><span class="s0">, </span><span class="s1">key=mlab.detrend_linear</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">target)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.detrend_linear(self.sig_slope[np.newaxis])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'iscomplex'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">ids=[</span><span class="s5">'real'</span><span class="s0">, </span><span class="s5">'complex'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scope=</span><span class="s5">'class'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'sides'</span><span class="s0">, </span><span class="s1">[</span><span class="s5">'onesided'</span><span class="s0">, </span><span class="s5">'twosided'</span><span class="s0">, </span><span class="s5">'default'</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">scope=</span><span class="s5">'class'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">'fstims,len_x,NFFT_density,nover_density,pad_to_density,pad_to_spectrum'</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([]</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, None, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, None, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s2">1024</span><span class="s0">, </span><span class="s2">512</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">128</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s2">256</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s2">257</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">33</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s2">256</span><span class="s0">, </span><span class="s2">128</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">256</span><span class="s0">, </span><span class="s2">256</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">32</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span>
        <span class="s5">'nosig'</span><span class="s0">,</span>
        <span class="s5">'Fs4'</span><span class="s0">,</span>
        <span class="s5">'FsAll'</span><span class="s0">,</span>
        <span class="s5">'nosig_noNFFT'</span><span class="s0">,</span>
        <span class="s5">'nosig_nopad_to'</span><span class="s0">,</span>
        <span class="s5">'nosig_noNFFT_no_pad_to'</span><span class="s0">,</span>
        <span class="s5">'nosig_trim'</span><span class="s0">,</span>
        <span class="s5">'nosig_odd'</span><span class="s0">,</span>
        <span class="s5">'nosig_oddlen'</span><span class="s0">,</span>
        <span class="s5">'nosig_stretch'</span><span class="s0">,</span>
        <span class="s5">'nosig_overlap'</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">scope=</span><span class="s5">'class'</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">TestSpectral:</span>
    <span class="s1">@pytest.fixture(scope=</span><span class="s5">'class'</span><span class="s0">, </span><span class="s1">autouse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">stim(self</span><span class="s0">, </span><span class="s1">request</span><span class="s0">, </span><span class="s1">fstims</span><span class="s0">, </span><span class="s1">iscomplex</span><span class="s0">, </span><span class="s1">sides</span><span class="s0">, </span><span class="s1">len_x</span><span class="s0">, </span><span class="s1">NFFT_density</span><span class="s0">,</span>
             <span class="s1">nover_density</span><span class="s0">, </span><span class="s1">pad_to_density</span><span class="s0">, </span><span class="s1">pad_to_spectrum):</span>
        <span class="s1">Fs = </span><span class="s2">100.</span>

        <span class="s1">x = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">/ Fs)</span>
        <span class="s0">if </span><span class="s1">len_x </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x = x[:len_x]</span>

        <span class="s4"># get the stimulus frequencies, defaulting to None</span>
        <span class="s1">fstims = [Fs / fstim </span><span class="s0">for </span><span class="s1">fstim </span><span class="s0">in </span><span class="s1">fstims]</span>

        <span class="s4"># get the constants, default to calculated values</span>
        <span class="s0">if </span><span class="s1">NFFT_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">NFFT_density_real = </span><span class="s2">256</span>
        <span class="s0">elif </span><span class="s1">NFFT_density &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">NFFT_density_real = NFFT_density = </span><span class="s2">100</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">NFFT_density_real = NFFT_density</span>

        <span class="s0">if </span><span class="s1">nover_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">nover_density_real = </span><span class="s2">0</span>
        <span class="s0">elif </span><span class="s1">nover_density &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">nover_density_real = nover_density = NFFT_density_real // </span><span class="s2">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">nover_density_real = nover_density</span>

        <span class="s0">if </span><span class="s1">pad_to_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">pad_to_density_real = NFFT_density_real</span>
        <span class="s0">elif </span><span class="s1">pad_to_density &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">pad_to_density = int(</span><span class="s2">2</span><span class="s1">**np.ceil(np.log2(NFFT_density_real)))</span>
            <span class="s1">pad_to_density_real = pad_to_density</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pad_to_density_real = pad_to_density</span>

        <span class="s0">if </span><span class="s1">pad_to_spectrum </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">pad_to_spectrum_real = len(x)</span>
        <span class="s0">elif </span><span class="s1">pad_to_spectrum &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">pad_to_spectrum_real = pad_to_spectrum = len(x)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pad_to_spectrum_real = pad_to_spectrum</span>

        <span class="s0">if </span><span class="s1">pad_to_spectrum </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">NFFT_spectrum_real = NFFT_spectrum = pad_to_spectrum_real</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">NFFT_spectrum_real = NFFT_spectrum = len(x)</span>
        <span class="s1">nover_spectrum = </span><span class="s2">0</span>

        <span class="s1">NFFT_specgram = NFFT_density</span>
        <span class="s1">nover_specgram = nover_density</span>
        <span class="s1">pad_to_specgram = pad_to_density</span>
        <span class="s1">NFFT_specgram_real = NFFT_density_real</span>
        <span class="s1">nover_specgram_real = nover_density_real</span>

        <span class="s0">if </span><span class="s1">sides == </span><span class="s5">'onesided' </span><span class="s0">or </span><span class="s1">(sides == </span><span class="s5">'default' </span><span class="s0">and not </span><span class="s1">iscomplex):</span>
            <span class="s4"># frequencies for specgram, psd, and csd</span>
            <span class="s4"># need to handle even and odd differently</span>
            <span class="s0">if </span><span class="s1">pad_to_density_real % </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">freqs_density = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                            <span class="s1">num=pad_to_density_real</span><span class="s0">,</span>
                                            <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)[::</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">freqs_density = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                            <span class="s1">num=pad_to_density_real // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">)</span>

            <span class="s4"># frequencies for complex, magnitude, angle, and phase spectrums</span>
            <span class="s4"># need to handle even and odd differently</span>
            <span class="s0">if </span><span class="s1">pad_to_spectrum_real % </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">freqs_spectrum = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                             <span class="s1">num=pad_to_spectrum_real</span><span class="s0">,</span>
                                             <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)[::</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">freqs_spectrum = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                             <span class="s1">num=pad_to_spectrum_real // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># frequencies for specgram, psd, and csd</span>
            <span class="s4"># need to handle even and odd differently</span>
            <span class="s0">if </span><span class="s1">pad_to_density_real % </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">freqs_density = np.linspace(-Fs / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                            <span class="s1">num=</span><span class="s2">2 </span><span class="s1">* pad_to_density_real</span><span class="s0">,</span>
                                            <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">freqs_density = np.linspace(-Fs / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                            <span class="s1">num=pad_to_density_real</span><span class="s0">,</span>
                                            <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s4"># frequencies for complex, magnitude, angle, and phase spectrums</span>
            <span class="s4"># need to handle even and odd differently</span>
            <span class="s0">if </span><span class="s1">pad_to_spectrum_real % </span><span class="s2">2</span><span class="s1">:</span>
                <span class="s1">freqs_spectrum = np.linspace(-Fs / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                             <span class="s1">num=</span><span class="s2">2 </span><span class="s1">* pad_to_spectrum_real</span><span class="s0">,</span>
                                             <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">freqs_spectrum = np.linspace(-Fs / </span><span class="s2">2</span><span class="s0">, </span><span class="s1">Fs / </span><span class="s2">2</span><span class="s0">,</span>
                                             <span class="s1">num=pad_to_spectrum_real</span><span class="s0">,</span>
                                             <span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">freqs_specgram = freqs_density</span>
        <span class="s4"># time points for specgram</span>
        <span class="s1">t_start = NFFT_specgram_real // </span><span class="s2">2</span>
        <span class="s1">t_stop = len(x) - NFFT_specgram_real // </span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1</span>
        <span class="s1">t_step = NFFT_specgram_real - nover_specgram_real</span>
        <span class="s1">t_specgram = x[t_start:t_stop:t_step]</span>
        <span class="s0">if </span><span class="s1">NFFT_specgram_real % </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s1">t_specgram += </span><span class="s2">1 </span><span class="s1">/ Fs / </span><span class="s2">2</span>
        <span class="s0">if </span><span class="s1">len(t_specgram) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">t_specgram = np.array([NFFT_specgram_real / (</span><span class="s2">2 </span><span class="s1">* Fs)])</span>
        <span class="s1">t_spectrum = np.array([NFFT_spectrum_real / (</span><span class="s2">2 </span><span class="s1">* Fs)])</span>
        <span class="s1">t_density = t_specgram</span>

        <span class="s1">y = np.zeros_like(x)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">fstim </span><span class="s0">in </span><span class="s1">enumerate(fstims):</span>
            <span class="s1">y += np.sin(fstim * x * np.pi * </span><span class="s2">2</span><span class="s1">) * </span><span class="s2">10</span><span class="s1">**i</span>

        <span class="s0">if </span><span class="s1">iscomplex:</span>
            <span class="s1">y = y.astype(</span><span class="s5">'complex'</span><span class="s1">)</span>

        <span class="s4"># Interestingly, the instance on which this fixture is called is not</span>
        <span class="s4"># the same as the one on which a test is run. So we need to modify the</span>
        <span class="s4"># class itself when using a class-scoped fixture.</span>
        <span class="s1">cls = request.cls</span>

        <span class="s1">cls.Fs = Fs</span>
        <span class="s1">cls.sides = sides</span>
        <span class="s1">cls.fstims = fstims</span>

        <span class="s1">cls.NFFT_density = NFFT_density</span>
        <span class="s1">cls.nover_density = nover_density</span>
        <span class="s1">cls.pad_to_density = pad_to_density</span>

        <span class="s1">cls.NFFT_spectrum = NFFT_spectrum</span>
        <span class="s1">cls.nover_spectrum = nover_spectrum</span>
        <span class="s1">cls.pad_to_spectrum = pad_to_spectrum</span>

        <span class="s1">cls.NFFT_specgram = NFFT_specgram</span>
        <span class="s1">cls.nover_specgram = nover_specgram</span>
        <span class="s1">cls.pad_to_specgram = pad_to_specgram</span>

        <span class="s1">cls.t_specgram = t_specgram</span>
        <span class="s1">cls.t_density = t_density</span>
        <span class="s1">cls.t_spectrum = t_spectrum</span>
        <span class="s1">cls.y = y</span>

        <span class="s1">cls.freqs_density = freqs_density</span>
        <span class="s1">cls.freqs_spectrum = freqs_spectrum</span>
        <span class="s1">cls.freqs_specgram = freqs_specgram</span>

        <span class="s1">cls.NFFT_density_real = NFFT_density_real</span>

    <span class="s0">def </span><span class="s1">check_freqs(self</span><span class="s0">, </span><span class="s1">vals</span><span class="s0">, </span><span class="s1">targfreqs</span><span class="s0">, </span><span class="s1">resfreqs</span><span class="s0">, </span><span class="s1">fstims):</span>
        <span class="s0">assert </span><span class="s1">resfreqs.argmin() == </span><span class="s2">0</span>
        <span class="s0">assert </span><span class="s1">resfreqs.argmax() == len(resfreqs)-</span><span class="s2">1</span>
        <span class="s1">assert_allclose(resfreqs</span><span class="s0">, </span><span class="s1">targfreqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">fstim </span><span class="s0">in </span><span class="s1">fstims:</span>
            <span class="s1">i = np.abs(resfreqs - fstim).argmin()</span>
            <span class="s0">assert </span><span class="s1">vals[i] &gt; vals[i+</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s0">assert </span><span class="s1">vals[i] &gt; vals[i-</span><span class="s2">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">check_maxfreq(self</span><span class="s0">, </span><span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">fstims):</span>
        <span class="s4"># skip the test if there are no frequencies</span>
        <span class="s0">if </span><span class="s1">len(fstims) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s4"># if twosided, do the test for each side</span>
        <span class="s0">if </span><span class="s1">fsp.min() &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">fspa = np.abs(fsp)</span>
            <span class="s1">zeroind = fspa.argmin()</span>
            <span class="s1">self.check_maxfreq(spec[:zeroind]</span><span class="s0">, </span><span class="s1">fspa[:zeroind]</span><span class="s0">, </span><span class="s1">fstims)</span>
            <span class="s1">self.check_maxfreq(spec[zeroind:]</span><span class="s0">, </span><span class="s1">fspa[zeroind:]</span><span class="s0">, </span><span class="s1">fstims)</span>
            <span class="s0">return</span>

        <span class="s1">fstimst = fstims[:]</span>
        <span class="s1">spect = spec.copy()</span>

        <span class="s4"># go through each peak and make sure it is correctly the maximum peak</span>
        <span class="s0">while </span><span class="s1">fstimst:</span>
            <span class="s1">maxind = spect.argmax()</span>
            <span class="s1">maxfreq = fsp[maxind]</span>
            <span class="s1">assert_almost_equal(maxfreq</span><span class="s0">, </span><span class="s1">fstimst[-</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s0">del </span><span class="s1">fstimst[-</span><span class="s2">1</span><span class="s1">]</span>
            <span class="s1">spect[maxind-</span><span class="s2">5</span><span class="s1">:maxind+</span><span class="s2">5</span><span class="s1">] = </span><span class="s2">0</span>

    <span class="s0">def </span><span class="s1">test_spectral_helper_raises(self):</span>
        <span class="s4"># We don't use parametrize here to handle ``y = self.y``.</span>
        <span class="s0">for </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">[  </span><span class="s4"># Various error conditions:</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y+</span><span class="s2">1</span><span class="s0">, </span><span class="s5">&quot;mode&quot;</span><span class="s1">: </span><span class="s5">&quot;complex&quot;</span><span class="s1">}</span><span class="s0">,  </span><span class="s4"># Modes requiring ``x is y``.</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y+</span><span class="s2">1</span><span class="s0">, </span><span class="s5">&quot;mode&quot;</span><span class="s1">: </span><span class="s5">&quot;magnitude&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y+</span><span class="s2">1</span><span class="s0">, </span><span class="s5">&quot;mode&quot;</span><span class="s1">: </span><span class="s5">&quot;angle&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y+</span><span class="s2">1</span><span class="s0">, </span><span class="s5">&quot;mode&quot;</span><span class="s1">: </span><span class="s5">&quot;phase&quot;</span><span class="s1">}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s5">&quot;mode&quot;</span><span class="s1">: </span><span class="s5">&quot;spam&quot;</span><span class="s1">}</span><span class="s0">,  </span><span class="s4"># Bad mode.</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y</span><span class="s0">, </span><span class="s5">&quot;sides&quot;</span><span class="s1">: </span><span class="s5">&quot;eggs&quot;</span><span class="s1">}</span><span class="s0">,  </span><span class="s4"># Bad sides.</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y</span><span class="s0">, </span><span class="s5">&quot;NFFT&quot;</span><span class="s1">: </span><span class="s2">10</span><span class="s0">, </span><span class="s5">&quot;noverlap&quot;</span><span class="s1">: </span><span class="s2">20</span><span class="s1">}</span><span class="s0">,  </span><span class="s4"># noverlap &gt; NFFT.</span>
            <span class="s1">{</span><span class="s5">&quot;NFFT&quot;</span><span class="s1">: </span><span class="s2">10</span><span class="s0">, </span><span class="s5">&quot;noverlap&quot;</span><span class="s1">: </span><span class="s2">10</span><span class="s1">}</span><span class="s0">,  </span><span class="s4"># noverlap == NFFT.</span>
            <span class="s1">{</span><span class="s5">&quot;y&quot;</span><span class="s1">: self.y</span><span class="s0">, </span><span class="s5">&quot;NFFT&quot;</span><span class="s1">: </span><span class="s2">10</span><span class="s0">,</span>
             <span class="s5">&quot;window&quot;</span><span class="s1">: np.ones(</span><span class="s2">9</span><span class="s1">)}</span><span class="s0">,  </span><span class="s4"># len(win) != NFFT.</span>
        <span class="s1">]:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s1">mlab._spectral_helper(x=self.y</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'mode'</span><span class="s0">, </span><span class="s1">[</span><span class="s5">'default'</span><span class="s0">, </span><span class="s5">'psd'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_single_spectrum_helper_unsupported_modes(self</span><span class="s0">, </span><span class="s1">mode):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab._single_spectrum_helper(x=self.y</span><span class="s0">, </span><span class="s1">mode=mode)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;mode, case&quot;</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s5">&quot;psd&quot;</span><span class="s0">, </span><span class="s5">&quot;density&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">&quot;magnitude&quot;</span><span class="s0">, </span><span class="s5">&quot;specgram&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s5">&quot;magnitude&quot;</span><span class="s0">, </span><span class="s5">&quot;spectrum&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_spectral_helper_psd(self</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">case):</span>
        <span class="s1">freqs = getattr(self</span><span class="s0">, </span><span class="s5">f&quot;freqs_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">t = mlab._spectral_helper(</span>
            <span class="s1">x=self.y</span><span class="s0">, </span><span class="s1">y=self.y</span><span class="s0">,</span>
            <span class="s1">NFFT=getattr(self</span><span class="s0">, </span><span class="s5">f&quot;NFFT_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
            <span class="s1">noverlap=getattr(self</span><span class="s0">, </span><span class="s5">f&quot;nover_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">pad_to=getattr(self</span><span class="s0">, </span><span class="s5">f&quot;pad_to_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">sides=self.sides</span><span class="s0">,</span>
            <span class="s1">mode=mode)</span>

        <span class="s1">assert_allclose(fsp</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s1">assert_allclose(t</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s5">f&quot;t_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">spec.shape[</span><span class="s2">0</span><span class="s1">] == freqs.shape[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">spec.shape[</span><span class="s2">1</span><span class="s1">] == getattr(self</span><span class="s0">, </span><span class="s5">f&quot;t_</span><span class="s0">{</span><span class="s1">case</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">).shape[</span><span class="s2">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_csd(self):</span>
        <span class="s1">freqs = self.freqs_density</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = mlab.csd(x=self.y</span><span class="s0">, </span><span class="s1">y=self.y+</span><span class="s2">1</span><span class="s0">,</span>
                             <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                             <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                             <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                             <span class="s1">sides=self.sides)</span>
        <span class="s1">assert_allclose(fsp</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">spec.shape == freqs.shape</span>

    <span class="s0">def </span><span class="s1">test_csd_padding(self):</span>
        <span class="s3">&quot;&quot;&quot;Test zero padding of csd().&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.NFFT_density </span><span class="s0">is None</span><span class="s1">:  </span><span class="s4"># for derived classes</span>
            <span class="s0">return</span>
        <span class="s1">sargs = dict(x=self.y</span><span class="s0">, </span><span class="s1">y=self.y+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">Fs=self.Fs</span><span class="s0">, </span><span class="s1">window=mlab.window_none</span><span class="s0">,</span>
                     <span class="s1">sides=self.sides)</span>

        <span class="s1">spec0</span><span class="s0">, </span><span class="s1">_ = mlab.csd(NFFT=self.NFFT_density</span><span class="s0">, </span><span class="s1">**sargs)</span>
        <span class="s1">spec1</span><span class="s0">, </span><span class="s1">_ = mlab.csd(NFFT=self.NFFT_density*</span><span class="s2">2</span><span class="s0">, </span><span class="s1">**sargs)</span>
        <span class="s1">assert_almost_equal(np.sum(np.conjugate(spec0)*spec0).real</span><span class="s0">,</span>
                            <span class="s1">np.sum(np.conjugate(spec1/</span><span class="s2">2</span><span class="s1">)*spec1/</span><span class="s2">2</span><span class="s1">).real)</span>

    <span class="s0">def </span><span class="s1">test_psd(self):</span>
        <span class="s1">freqs = self.freqs_density</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = mlab.psd(x=self.y</span><span class="s0">,</span>
                             <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                             <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                             <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                             <span class="s1">sides=self.sides)</span>
        <span class="s0">assert </span><span class="s1">spec.shape == freqs.shape</span>
        <span class="s1">self.check_freqs(spec</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">self.fstims)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'make_data, detrend'</span><span class="s0">,</span>
        <span class="s1">[(np.zeros</span><span class="s0">, </span><span class="s1">mlab.detrend_mean)</span><span class="s0">, </span><span class="s1">(np.zeros</span><span class="s0">, </span><span class="s5">'mean'</span><span class="s1">)</span><span class="s0">,</span>
         <span class="s1">(np.arange</span><span class="s0">, </span><span class="s1">mlab.detrend_linear)</span><span class="s0">, </span><span class="s1">(np.arange</span><span class="s0">, </span><span class="s5">'linear'</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_psd_detrend(self</span><span class="s0">, </span><span class="s1">make_data</span><span class="s0">, </span><span class="s1">detrend):</span>
        <span class="s0">if </span><span class="s1">self.NFFT_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s1">ydata = make_data(self.NFFT_density)</span>
        <span class="s1">ydata1 = ydata+</span><span class="s2">5</span>
        <span class="s1">ydata2 = ydata+</span><span class="s2">3.3</span>
        <span class="s1">ydata = np.vstack([ydata1</span><span class="s0">, </span><span class="s1">ydata2])</span>
        <span class="s1">ydata = np.tile(ydata</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">ydatab = ydata.T.flatten()</span>
        <span class="s1">ydata = ydata.flatten()</span>
        <span class="s1">ycontrol = np.zeros_like(ydata)</span>
        <span class="s1">spec_g</span><span class="s0">, </span><span class="s1">fsp_g = mlab.psd(x=ydata</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">detrend=detrend)</span>
        <span class="s1">spec_b</span><span class="s0">, </span><span class="s1">fsp_b = mlab.psd(x=ydatab</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">detrend=detrend)</span>
        <span class="s1">spec_c</span><span class="s0">, </span><span class="s1">fsp_c = mlab.psd(x=ycontrol</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides)</span>
        <span class="s1">assert_array_equal(fsp_g</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_array_equal(fsp_b</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_allclose(spec_g</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>
        <span class="s4"># these should not be almost equal</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s1">assert_allclose(spec_b</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_psd_window_hanning(self):</span>
        <span class="s0">if </span><span class="s1">self.NFFT_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s1">ydata = np.arange(self.NFFT_density)</span>
        <span class="s1">ydata1 = ydata+</span><span class="s2">5</span>
        <span class="s1">ydata2 = ydata+</span><span class="s2">3.3</span>
        <span class="s1">windowVals = mlab.window_hanning(np.ones_like(ydata1))</span>
        <span class="s1">ycontrol1 = ydata1 * windowVals</span>
        <span class="s1">ycontrol2 = mlab.window_hanning(ydata2)</span>
        <span class="s1">ydata = np.vstack([ydata1</span><span class="s0">, </span><span class="s1">ydata2])</span>
        <span class="s1">ycontrol = np.vstack([ycontrol1</span><span class="s0">, </span><span class="s1">ycontrol2])</span>
        <span class="s1">ydata = np.tile(ydata</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">ycontrol = np.tile(ycontrol</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">ydatab = ydata.T.flatten()</span>
        <span class="s1">ydataf = ydata.flatten()</span>
        <span class="s1">ycontrol = ycontrol.flatten()</span>
        <span class="s1">spec_g</span><span class="s0">, </span><span class="s1">fsp_g = mlab.psd(x=ydataf</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning)</span>
        <span class="s1">spec_b</span><span class="s0">, </span><span class="s1">fsp_b = mlab.psd(x=ydatab</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning)</span>
        <span class="s1">spec_c</span><span class="s0">, </span><span class="s1">fsp_c = mlab.psd(x=ycontrol</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_none)</span>
        <span class="s1">spec_c *= len(ycontrol1)/(windowVals**</span><span class="s2">2</span><span class="s1">).sum()</span>
        <span class="s1">assert_array_equal(fsp_g</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_array_equal(fsp_b</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_allclose(spec_g</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>
        <span class="s4"># these should not be almost equal</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s1">assert_allclose(spec_b</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_psd_window_hanning_detrend_linear(self):</span>
        <span class="s0">if </span><span class="s1">self.NFFT_density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s1">ydata = np.arange(self.NFFT_density)</span>
        <span class="s1">ycontrol = np.zeros(self.NFFT_density)</span>
        <span class="s1">ydata1 = ydata+</span><span class="s2">5</span>
        <span class="s1">ydata2 = ydata+</span><span class="s2">3.3</span>
        <span class="s1">ycontrol1 = ycontrol</span>
        <span class="s1">ycontrol2 = ycontrol</span>
        <span class="s1">windowVals = mlab.window_hanning(np.ones_like(ycontrol1))</span>
        <span class="s1">ycontrol1 = ycontrol1 * windowVals</span>
        <span class="s1">ycontrol2 = mlab.window_hanning(ycontrol2)</span>
        <span class="s1">ydata = np.vstack([ydata1</span><span class="s0">, </span><span class="s1">ydata2])</span>
        <span class="s1">ycontrol = np.vstack([ycontrol1</span><span class="s0">, </span><span class="s1">ycontrol2])</span>
        <span class="s1">ydata = np.tile(ydata</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">ycontrol = np.tile(ycontrol</span><span class="s0">, </span><span class="s1">(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">ydatab = ydata.T.flatten()</span>
        <span class="s1">ydataf = ydata.flatten()</span>
        <span class="s1">ycontrol = ycontrol.flatten()</span>
        <span class="s1">spec_g</span><span class="s0">, </span><span class="s1">fsp_g = mlab.psd(x=ydataf</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">detrend=mlab.detrend_linear</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning)</span>
        <span class="s1">spec_b</span><span class="s0">, </span><span class="s1">fsp_b = mlab.psd(x=ydatab</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">detrend=mlab.detrend_linear</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning)</span>
        <span class="s1">spec_c</span><span class="s0">, </span><span class="s1">fsp_c = mlab.psd(x=ycontrol</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_none)</span>
        <span class="s1">spec_c *= len(ycontrol1)/(windowVals**</span><span class="s2">2</span><span class="s1">).sum()</span>
        <span class="s1">assert_array_equal(fsp_g</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_array_equal(fsp_b</span><span class="s0">, </span><span class="s1">fsp_c)</span>
        <span class="s1">assert_allclose(spec_g</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>
        <span class="s4"># these should not be almost equal</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s1">assert_allclose(spec_b</span><span class="s0">, </span><span class="s1">spec_c</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_psd_window_flattop(self):</span>
        <span class="s4"># flattop window</span>
        <span class="s4"># adaption from https://github.com/scipy/scipy/blob\</span>
        <span class="s4"># /v1.10.0/scipy/signal/windows/_windows.py#L562-L622</span>
        <span class="s1">a = [</span><span class="s2">0.21557895</span><span class="s0">, </span><span class="s2">0.41663158</span><span class="s0">, </span><span class="s2">0.277263158</span><span class="s0">, </span><span class="s2">0.083578947</span><span class="s0">, </span><span class="s2">0.006947368</span><span class="s1">]</span>
        <span class="s1">fac = np.linspace(-np.pi</span><span class="s0">, </span><span class="s1">np.pi</span><span class="s0">, </span><span class="s1">self.NFFT_density_real)</span>
        <span class="s1">win = np.zeros(self.NFFT_density_real)</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(len(a)):</span>
            <span class="s1">win += a[k] * np.cos(k * fac)</span>

        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = mlab.psd(x=self.y</span><span class="s0">,</span>
                             <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                             <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                             <span class="s1">window=win</span><span class="s0">,</span>
                             <span class="s1">scale_by_freq=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">spec_a</span><span class="s0">, </span><span class="s1">fsp_a = mlab.psd(x=self.y</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=win)</span>
        <span class="s1">assert_allclose(spec*win.sum()**</span><span class="s2">2</span><span class="s0">,</span>
                        <span class="s1">spec_a*self.Fs*(win**</span><span class="s2">2</span><span class="s1">).sum()</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_psd_windowarray(self):</span>
        <span class="s1">freqs = self.freqs_density</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = mlab.psd(x=self.y</span><span class="s0">,</span>
                             <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                             <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                             <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                             <span class="s1">window=np.ones(self.NFFT_density_real))</span>
        <span class="s1">assert_allclose(fsp</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">spec.shape == freqs.shape</span>

    <span class="s0">def </span><span class="s1">test_psd_windowarray_scale_by_freq(self):</span>
        <span class="s1">win = mlab.window_hanning(np.ones(self.NFFT_density_real))</span>

        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = mlab.psd(x=self.y</span><span class="s0">,</span>
                             <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                             <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                             <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                             <span class="s1">window=mlab.window_hanning)</span>
        <span class="s1">spec_s</span><span class="s0">, </span><span class="s1">fsp_s = mlab.psd(x=self.y</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                                 <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning</span><span class="s0">,</span>
                                 <span class="s1">scale_by_freq=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">spec_n</span><span class="s0">, </span><span class="s1">fsp_n = mlab.psd(x=self.y</span><span class="s0">,</span>
                                 <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                 <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                 <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                                 <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                                 <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                 <span class="s1">window=mlab.window_hanning</span><span class="s0">,</span>
                                 <span class="s1">scale_by_freq=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(fsp</span><span class="s0">, </span><span class="s1">fsp_s)</span>
        <span class="s1">assert_array_equal(fsp</span><span class="s0">, </span><span class="s1">fsp_n)</span>
        <span class="s1">assert_array_equal(spec</span><span class="s0">, </span><span class="s1">spec_s)</span>
        <span class="s1">assert_allclose(spec_s*(win**</span><span class="s2">2</span><span class="s1">).sum()</span><span class="s0">,</span>
                        <span class="s1">spec_n/self.Fs*win.sum()**</span><span class="s2">2</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;kind&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">&quot;complex&quot;</span><span class="s0">, </span><span class="s5">&quot;magnitude&quot;</span><span class="s0">, </span><span class="s5">&quot;angle&quot;</span><span class="s0">, </span><span class="s5">&quot;phase&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_spectrum(self</span><span class="s0">, </span><span class="s1">kind):</span>
        <span class="s1">freqs = self.freqs_spectrum</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp = getattr(mlab</span><span class="s0">, </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">kind</span><span class="s0">}</span><span class="s5">_spectrum&quot;</span><span class="s1">)(</span>
            <span class="s1">x=self.y</span><span class="s0">,</span>
            <span class="s1">Fs=self.Fs</span><span class="s0">, </span><span class="s1">sides=self.sides</span><span class="s0">, </span><span class="s1">pad_to=self.pad_to_spectrum)</span>
        <span class="s1">assert_allclose(fsp</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">spec.shape == freqs.shape</span>
        <span class="s0">if </span><span class="s1">kind == </span><span class="s5">&quot;magnitude&quot;</span><span class="s1">:</span>
            <span class="s1">self.check_maxfreq(spec</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">self.fstims)</span>
            <span class="s1">self.check_freqs(spec</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">self.fstims)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'kwargs'</span><span class="s0">,</span>
        <span class="s1">[{}</span><span class="s0">, </span><span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'default'</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'psd'</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'magnitude'</span><span class="s1">}</span><span class="s0">,</span>
         <span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'complex'</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'angle'</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s5">'mode'</span><span class="s1">: </span><span class="s5">'phase'</span><span class="s1">}])</span>
    <span class="s0">def </span><span class="s1">test_specgram(self</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s1">freqs = self.freqs_specgram</span>
        <span class="s1">spec</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">t = mlab.specgram(x=self.y</span><span class="s0">,</span>
                                     <span class="s1">NFFT=self.NFFT_specgram</span><span class="s0">,</span>
                                     <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                     <span class="s1">noverlap=self.nover_specgram</span><span class="s0">,</span>
                                     <span class="s1">pad_to=self.pad_to_specgram</span><span class="s0">,</span>
                                     <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                     <span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">kwargs.get(</span><span class="s5">'mode'</span><span class="s1">) == </span><span class="s5">'complex'</span><span class="s1">:</span>
            <span class="s1">spec = np.abs(spec)</span>
        <span class="s1">specm = np.mean(spec</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">assert_allclose(fsp</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>
        <span class="s1">assert_allclose(t</span><span class="s0">, </span><span class="s1">self.t_specgram</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">spec.shape[</span><span class="s2">0</span><span class="s1">] == freqs.shape[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">spec.shape[</span><span class="s2">1</span><span class="s1">] == self.t_specgram.shape[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">kwargs.get(</span><span class="s5">'mode'</span><span class="s1">) </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">'complex'</span><span class="s0">, </span><span class="s5">'angle'</span><span class="s0">, </span><span class="s5">'phase'</span><span class="s1">]:</span>
            <span class="s4"># using a single freq, so all time slices should be about the same</span>
            <span class="s0">if </span><span class="s1">np.abs(spec.max()) != </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">np.diff(spec</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">).max() / np.abs(spec.max())</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,</span>
                    <span class="s1">atol=</span><span class="s2">1e-02</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">kwargs.get(</span><span class="s5">'mode'</span><span class="s1">) </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">'angle'</span><span class="s0">, </span><span class="s5">'phase'</span><span class="s1">]:</span>
            <span class="s1">self.check_freqs(specm</span><span class="s0">, </span><span class="s1">freqs</span><span class="s0">, </span><span class="s1">fsp</span><span class="s0">, </span><span class="s1">self.fstims)</span>

    <span class="s0">def </span><span class="s1">test_specgram_warn_only1seg(self):</span>
        <span class="s3">&quot;&quot;&quot;Warning should be raised if len(x) &lt;= NFFT.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s5">&quot;Only one segment is calculated&quot;</span><span class="s1">):</span>
            <span class="s1">mlab.specgram(x=self.y</span><span class="s0">, </span><span class="s1">NFFT=len(self.y)</span><span class="s0">, </span><span class="s1">Fs=self.Fs)</span>

    <span class="s0">def </span><span class="s1">test_psd_csd_equal(self):</span>
        <span class="s1">Pxx</span><span class="s0">, </span><span class="s1">freqsxx = mlab.psd(x=self.y</span><span class="s0">,</span>
                                <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                                <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                                <span class="s1">sides=self.sides)</span>
        <span class="s1">Pxy</span><span class="s0">, </span><span class="s1">freqsxy = mlab.csd(x=self.y</span><span class="s0">, </span><span class="s1">y=self.y</span><span class="s0">,</span>
                                <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                                <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                                <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                                <span class="s1">sides=self.sides)</span>
        <span class="s1">assert_array_almost_equal_nulp(Pxx</span><span class="s0">, </span><span class="s1">Pxy)</span>
        <span class="s1">assert_array_equal(freqsxx</span><span class="s0">, </span><span class="s1">freqsxy)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;mode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">&quot;default&quot;</span><span class="s0">, </span><span class="s5">&quot;psd&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_specgram_auto_default_psd_equal(self</span><span class="s0">, </span><span class="s1">mode):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test that mlab.specgram without mode and with mode 'default' and 'psd' 
        are all the same. 
        &quot;&quot;&quot;</span>
        <span class="s1">speca</span><span class="s0">, </span><span class="s1">freqspeca</span><span class="s0">, </span><span class="s1">ta = mlab.specgram(x=self.y</span><span class="s0">,</span>
                                             <span class="s1">NFFT=self.NFFT_specgram</span><span class="s0">,</span>
                                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                             <span class="s1">noverlap=self.nover_specgram</span><span class="s0">,</span>
                                             <span class="s1">pad_to=self.pad_to_specgram</span><span class="s0">,</span>
                                             <span class="s1">sides=self.sides)</span>
        <span class="s1">specb</span><span class="s0">, </span><span class="s1">freqspecb</span><span class="s0">, </span><span class="s1">tb = mlab.specgram(x=self.y</span><span class="s0">,</span>
                                             <span class="s1">NFFT=self.NFFT_specgram</span><span class="s0">,</span>
                                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                             <span class="s1">noverlap=self.nover_specgram</span><span class="s0">,</span>
                                             <span class="s1">pad_to=self.pad_to_specgram</span><span class="s0">,</span>
                                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                             <span class="s1">mode=mode)</span>
        <span class="s1">assert_array_equal(speca</span><span class="s0">, </span><span class="s1">specb)</span>
        <span class="s1">assert_array_equal(freqspeca</span><span class="s0">, </span><span class="s1">freqspecb)</span>
        <span class="s1">assert_array_equal(ta</span><span class="s0">, </span><span class="s1">tb)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;mode, conv&quot;</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s5">&quot;magnitude&quot;</span><span class="s0">, </span><span class="s1">np.abs)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">&quot;angle&quot;</span><span class="s0">, </span><span class="s1">np.angle)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s5">&quot;phase&quot;</span><span class="s0">, lambda </span><span class="s1">x: np.unwrap(np.angle(x)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_specgram_complex_equivalent(self</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">conv):</span>
        <span class="s1">specc</span><span class="s0">, </span><span class="s1">freqspecc</span><span class="s0">, </span><span class="s1">tc = mlab.specgram(x=self.y</span><span class="s0">,</span>
                                             <span class="s1">NFFT=self.NFFT_specgram</span><span class="s0">,</span>
                                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                             <span class="s1">noverlap=self.nover_specgram</span><span class="s0">,</span>
                                             <span class="s1">pad_to=self.pad_to_specgram</span><span class="s0">,</span>
                                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                             <span class="s1">mode=</span><span class="s5">'complex'</span><span class="s1">)</span>
        <span class="s1">specm</span><span class="s0">, </span><span class="s1">freqspecm</span><span class="s0">, </span><span class="s1">tm = mlab.specgram(x=self.y</span><span class="s0">,</span>
                                             <span class="s1">NFFT=self.NFFT_specgram</span><span class="s0">,</span>
                                             <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                                             <span class="s1">noverlap=self.nover_specgram</span><span class="s0">,</span>
                                             <span class="s1">pad_to=self.pad_to_specgram</span><span class="s0">,</span>
                                             <span class="s1">sides=self.sides</span><span class="s0">,</span>
                                             <span class="s1">mode=mode)</span>

        <span class="s1">assert_array_equal(freqspecc</span><span class="s0">, </span><span class="s1">freqspecm)</span>
        <span class="s1">assert_array_equal(tc</span><span class="s0">, </span><span class="s1">tm)</span>
        <span class="s1">assert_allclose(conv(specc)</span><span class="s0">, </span><span class="s1">specm</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_psd_windowarray_equal(self):</span>
        <span class="s1">win = mlab.window_hanning(np.ones(self.NFFT_density_real))</span>
        <span class="s1">speca</span><span class="s0">, </span><span class="s1">fspa = mlab.psd(x=self.y</span><span class="s0">,</span>
                               <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                               <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                               <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                               <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                               <span class="s1">sides=self.sides</span><span class="s0">,</span>
                               <span class="s1">window=win)</span>
        <span class="s1">specb</span><span class="s0">, </span><span class="s1">fspb = mlab.psd(x=self.y</span><span class="s0">,</span>
                               <span class="s1">NFFT=self.NFFT_density</span><span class="s0">,</span>
                               <span class="s1">Fs=self.Fs</span><span class="s0">,</span>
                               <span class="s1">noverlap=self.nover_density</span><span class="s0">,</span>
                               <span class="s1">pad_to=self.pad_to_density</span><span class="s0">,</span>
                               <span class="s1">sides=self.sides)</span>
        <span class="s1">assert_array_equal(fspa</span><span class="s0">, </span><span class="s1">fspb)</span>
        <span class="s1">assert_allclose(speca</span><span class="s0">, </span><span class="s1">specb</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-08</span><span class="s1">)</span>


<span class="s4"># extra test for cohere...</span>
<span class="s0">def </span><span class="s1">test_cohere():</span>
    <span class="s1">N = </span><span class="s2">1024</span>
    <span class="s1">np.random.seed(</span><span class="s2">19680801</span><span class="s1">)</span>
    <span class="s1">x = np.random.randn(N)</span>
    <span class="s4"># phase offset</span>
    <span class="s1">y = np.roll(x</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>
    <span class="s4"># high-freq roll-off</span>
    <span class="s1">y = np.convolve(y</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">20</span><span class="s1">) / </span><span class="s2">20.</span><span class="s0">, </span><span class="s1">mode=</span><span class="s5">'same'</span><span class="s1">)</span>
    <span class="s1">cohsq</span><span class="s0">, </span><span class="s1">f = mlab.cohere(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">NFFT=</span><span class="s2">256</span><span class="s0">, </span><span class="s1">Fs=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">noverlap=</span><span class="s2">128</span><span class="s1">)</span>
    <span class="s1">assert_allclose(np.mean(cohsq)</span><span class="s0">, </span><span class="s2">0.837</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1.e-3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.isreal(np.mean(cohsq))</span>


<span class="s4"># *****************************************************************</span>
<span class="s4"># These Tests were taken from SCIPY with some minor modifications</span>
<span class="s4"># this can be retrieved from:</span>
<span class="s4"># https://github.com/scipy/scipy/blob/master/scipy/stats/tests/test_kdeoth.py</span>
<span class="s4"># *****************************************************************</span>

<span class="s0">class </span><span class="s1">TestGaussianKDE:</span>

    <span class="s0">def </span><span class="s1">test_kde_integer_input(self):</span>
        <span class="s3">&quot;&quot;&quot;Regression test for #1181.&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">kde = mlab.GaussianKDE(x1)</span>
        <span class="s1">y_expected = [</span><span class="s2">0.13480721</span><span class="s0">, </span><span class="s2">0.18222869</span><span class="s0">, </span><span class="s2">0.19514935</span><span class="s0">, </span><span class="s2">0.18222869</span><span class="s0">,</span>
                      <span class="s2">0.13480721</span><span class="s1">]</span>
        <span class="s1">np.testing.assert_array_almost_equal(kde(x1)</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_gaussian_kde_covariance_caching(self):</span>
        <span class="s1">x1 = np.array([-</span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">xs = np.linspace(-</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">num=</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s4"># These expected values are from scipy 0.10, before some changes to</span>
        <span class="s4"># gaussian_kde. They were not compared with any external reference.</span>
        <span class="s1">y_expected = [</span><span class="s2">0.02463386</span><span class="s0">, </span><span class="s2">0.04689208</span><span class="s0">, </span><span class="s2">0.05395444</span><span class="s0">, </span><span class="s2">0.05337754</span><span class="s0">,</span>
                      <span class="s2">0.01664475</span><span class="s1">]</span>

        <span class="s4"># set it to the default bandwidth.</span>
        <span class="s1">kde2 = mlab.GaussianKDE(x1</span><span class="s0">, </span><span class="s5">'scott'</span><span class="s1">)</span>
        <span class="s1">y2 = kde2(xs)</span>

        <span class="s1">np.testing.assert_array_almost_equal(y_expected</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_kde_bandwidth_method(self):</span>

        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">xn = np.random.randn(n_basesample)</span>

        <span class="s4"># Default</span>
        <span class="s1">gkde = mlab.GaussianKDE(xn)</span>
        <span class="s4"># Supply a callable</span>
        <span class="s1">gkde2 = mlab.GaussianKDE(xn</span><span class="s0">, </span><span class="s5">'scott'</span><span class="s1">)</span>
        <span class="s4"># Supply a scalar</span>
        <span class="s1">gkde3 = mlab.GaussianKDE(xn</span><span class="s0">, </span><span class="s1">bw_method=gkde.factor)</span>

        <span class="s1">xs = np.linspace(-</span><span class="s2">7</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">51</span><span class="s1">)</span>
        <span class="s1">kdepdf = gkde.evaluate(xs)</span>
        <span class="s1">kdepdf2 = gkde2.evaluate(xs)</span>
        <span class="s0">assert </span><span class="s1">kdepdf.all() == kdepdf2.all()</span>
        <span class="s1">kdepdf3 = gkde3.evaluate(xs)</span>
        <span class="s0">assert </span><span class="s1">kdepdf.all() == kdepdf3.all()</span>


<span class="s0">class </span><span class="s1">TestGaussianKDECustom:</span>
    <span class="s0">def </span><span class="s1">test_no_data(self):</span>
        <span class="s3">&quot;&quot;&quot;Pass no data into the GaussianKDE class.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.GaussianKDE([])</span>

    <span class="s0">def </span><span class="s1">test_single_dataset_element(self):</span>
        <span class="s3">&quot;&quot;&quot;Pass a single dataset element into the GaussianKDE class.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.GaussianKDE([</span><span class="s2">42</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_silverman_multidim_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test silverman's for a multi-dimensional array.&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(np.linalg.LinAlgError):</span>
            <span class="s1">mlab.GaussianKDE(x1</span><span class="s0">, </span><span class="s5">&quot;silverman&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_silverman_singledim_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test silverman's output for a single dimension list.&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.array([-</span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">mygauss = mlab.GaussianKDE(x1</span><span class="s0">, </span><span class="s5">&quot;silverman&quot;</span><span class="s1">)</span>
        <span class="s1">y_expected = </span><span class="s2">0.76770389927475502</span>
        <span class="s1">assert_almost_equal(mygauss.covariance_factor()</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scott_multidim_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test scott's output for a multi-dimensional array.&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(np.linalg.LinAlgError):</span>
            <span class="s1">mlab.GaussianKDE(x1</span><span class="s0">, </span><span class="s5">&quot;scott&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scott_singledim_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test scott's output a single-dimensional array.&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.array([-</span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
        <span class="s1">mygauss = mlab.GaussianKDE(x1</span><span class="s0">, </span><span class="s5">&quot;scott&quot;</span><span class="s1">)</span>
        <span class="s1">y_expected = </span><span class="s2">0.72477966367769553</span>
        <span class="s1">assert_almost_equal(mygauss.covariance_factor()</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_empty_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test the scalar's cov factor for an empty array.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.GaussianKDE([]</span><span class="s0">, </span><span class="s1">bw_method=</span><span class="s2">5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_covariance_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test a scalar's cov factor.&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">multidim_data = [np.random.randn(n_basesample) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">)]</span>

        <span class="s1">kde = mlab.GaussianKDE(multidim_data</span><span class="s0">, </span><span class="s1">bw_method=</span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">kde.covariance_factor() == </span><span class="s2">0.5</span>

    <span class="s0">def </span><span class="s1">test_callable_covariance_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test the callable's cov factor for a multi-dimensional array.&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">multidim_data = [np.random.randn(n_basesample) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">callable_fun(x):</span>
            <span class="s0">return </span><span class="s2">0.55</span>
        <span class="s1">kde = mlab.GaussianKDE(multidim_data</span><span class="s0">, </span><span class="s1">bw_method=callable_fun)</span>
        <span class="s0">assert </span><span class="s1">kde.covariance_factor() == </span><span class="s2">0.55</span>

    <span class="s0">def </span><span class="s1">test_callable_singledim_dataset(self):</span>
        <span class="s3">&quot;&quot;&quot;Test the callable's cov factor for a single-dimensional array.&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">multidim_data = np.random.randn(n_basesample)</span>

        <span class="s1">kde = mlab.GaussianKDE(multidim_data</span><span class="s0">, </span><span class="s1">bw_method=</span><span class="s5">'silverman'</span><span class="s1">)</span>
        <span class="s1">y_expected = </span><span class="s2">0.48438841363348911</span>
        <span class="s1">assert_almost_equal(kde.covariance_factor()</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wrong_bw_method(self):</span>
        <span class="s3">&quot;&quot;&quot;Test the error message that should be called when bw is invalid.&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">data = np.random.randn(n_basesample)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">mlab.GaussianKDE(data</span><span class="s0">, </span><span class="s1">bw_method=</span><span class="s5">&quot;invalid&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestGaussianKDEEvaluate:</span>

    <span class="s0">def </span><span class="s1">test_evaluate_diff_dim(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Test the evaluate method when the dim's of dataset and points have 
        different dimensions. 
        &quot;&quot;&quot;</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">kde = mlab.GaussianKDE(x1)</span>
        <span class="s1">x2 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">y_expected = [</span>
            <span class="s2">0.08797252</span><span class="s0">, </span><span class="s2">0.11774109</span><span class="s0">, </span><span class="s2">0.11774109</span><span class="s0">, </span><span class="s2">0.08797252</span><span class="s0">, </span><span class="s2">0.0370153</span>
        <span class="s1">]</span>
        <span class="s1">y = kde.evaluate(x2)</span>
        <span class="s1">np.testing.assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_evaluate_inv_dim(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Invert the dimensions; i.e., for a dataset of dimension 1 [3, 2, 4], 
        the points should have a dimension of 3 [[3], [2], [4]]. 
        &quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s2">8765678</span><span class="s1">)</span>
        <span class="s1">n_basesample = </span><span class="s2">50</span>
        <span class="s1">multidim_data = np.random.randn(n_basesample)</span>
        <span class="s1">kde = mlab.GaussianKDE(multidim_data)</span>
        <span class="s1">x2 = [[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">kde.evaluate(x2)</span>

    <span class="s0">def </span><span class="s1">test_evaluate_dim_and_num(self):</span>
        <span class="s3">&quot;&quot;&quot;Tests if evaluated against a one by one array&quot;&quot;&quot;</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">x2 = np.array([</span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">kde = mlab.GaussianKDE(x1)</span>
        <span class="s1">y_expected = [</span><span class="s2">0.08797252</span><span class="s1">]</span>
        <span class="s1">y = kde.evaluate(x2)</span>
        <span class="s1">np.testing.assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_evaluate_point_dim_not_one(self):</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">x2 = [np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)]</span>
        <span class="s1">kde = mlab.GaussianKDE(x1)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">kde.evaluate(x2)</span>

    <span class="s0">def </span><span class="s1">test_evaluate_equal_dim_and_num_lt(self):</span>
        <span class="s1">x1 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">x2 = np.arange(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">kde = mlab.GaussianKDE(x1)</span>
        <span class="s1">y_expected = [</span><span class="s2">0.08797252</span><span class="s0">, </span><span class="s2">0.11774109</span><span class="s0">, </span><span class="s2">0.11774109</span><span class="s1">]</span>
        <span class="s1">y = kde.evaluate(x2)</span>
        <span class="s1">np.testing.assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y_expected</span><span class="s0">, </span><span class="s2">7</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_psd_onesided_norm():</span>
    <span class="s1">u = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">dt = </span><span class="s2">1.0</span>
    <span class="s1">Su = np.abs(np.fft.fft(u) * dt)**</span><span class="s2">2 </span><span class="s1">/ (dt * u.size)</span>
    <span class="s1">P</span><span class="s0">, </span><span class="s1">f = mlab.psd(u</span><span class="s0">, </span><span class="s1">NFFT=u.size</span><span class="s0">, </span><span class="s1">Fs=</span><span class="s2">1</span><span class="s1">/dt</span><span class="s0">, </span><span class="s1">window=mlab.window_none</span><span class="s0">,</span>
                    <span class="s1">detrend=mlab.detrend_none</span><span class="s0">, </span><span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">pad_to=</span><span class="s0">None,</span>
                    <span class="s1">scale_by_freq=</span><span class="s0">None,</span>
                    <span class="s1">sides=</span><span class="s5">'onesided'</span><span class="s1">)</span>
    <span class="s1">Su_1side = np.append([Su[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">Su[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">] + Su[</span><span class="s2">4</span><span class="s1">:][::-</span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(P</span><span class="s0">, </span><span class="s1">Su_1side</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-06</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_psd_oversampling():</span>
    <span class="s3">&quot;&quot;&quot;Test the case len(x) &lt; NFFT for psd().&quot;&quot;&quot;</span>
    <span class="s1">u = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">dt = </span><span class="s2">1.0</span>
    <span class="s1">Su = np.abs(np.fft.fft(u) * dt)**</span><span class="s2">2 </span><span class="s1">/ (dt * u.size)</span>
    <span class="s1">P</span><span class="s0">, </span><span class="s1">f = mlab.psd(u</span><span class="s0">, </span><span class="s1">NFFT=u.size*</span><span class="s2">2</span><span class="s0">, </span><span class="s1">Fs=</span><span class="s2">1</span><span class="s1">/dt</span><span class="s0">, </span><span class="s1">window=mlab.window_none</span><span class="s0">,</span>
                    <span class="s1">detrend=mlab.detrend_none</span><span class="s0">, </span><span class="s1">noverlap=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">pad_to=</span><span class="s0">None,</span>
                    <span class="s1">scale_by_freq=</span><span class="s0">None,</span>
                    <span class="s1">sides=</span><span class="s5">'onesided'</span><span class="s1">)</span>
    <span class="s1">Su_1side = np.append([Su[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">Su[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">] + Su[</span><span class="s2">4</span><span class="s1">:][::-</span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">assert_almost_equal(np.sum(P)</span><span class="s0">, </span><span class="s1">np.sum(Su_1side))  </span><span class="s4"># same energy</span>
</pre>
</body>
</html>