<html>
<head>
<title>cff.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cff.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">from </span><span class="s1">fontTools.cffLib </span><span class="s0">import </span><span class="s1">(</span>
	<span class="s1">maxStackLimit</span><span class="s0">,</span>
	<span class="s1">TopDictIndex</span><span class="s0">,</span>
	<span class="s1">buildOrder</span><span class="s0">,</span>
	<span class="s1">topDictOperators</span><span class="s0">,</span>
	<span class="s1">topDictOperators2</span><span class="s0">,</span>
	<span class="s1">privateDictOperators</span><span class="s0">,</span>
	<span class="s1">privateDictOperators2</span><span class="s0">,</span>
	<span class="s1">FDArrayIndex</span><span class="s0">,</span>
	<span class="s1">FontDict</span><span class="s0">,</span>
	<span class="s1">VarStoreData</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>
<span class="s0">from </span><span class="s1">fontTools.cffLib.specializer </span><span class="s0">import </span><span class="s1">(</span>
	<span class="s1">specializeCommands</span><span class="s0">, </span><span class="s1">commandsToProgram)</span>
<span class="s0">from </span><span class="s1">fontTools.ttLib </span><span class="s0">import </span><span class="s1">newTable</span>
<span class="s0">from </span><span class="s1">fontTools </span><span class="s0">import </span><span class="s1">varLib</span>
<span class="s0">from </span><span class="s1">fontTools.varLib.models </span><span class="s0">import </span><span class="s1">allEqual</span>
<span class="s0">from </span><span class="s1">fontTools.misc.roundTools </span><span class="s0">import </span><span class="s1">roundFunc</span>
<span class="s0">from </span><span class="s1">fontTools.misc.psCharStrings </span><span class="s0">import </span><span class="s1">T2CharString</span><span class="s0">, </span><span class="s1">T2OutlineExtractor</span>
<span class="s0">from </span><span class="s1">fontTools.pens.t2CharStringPen </span><span class="s0">import </span><span class="s1">T2CharStringPen</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>

<span class="s0">from </span><span class="s1">.errors </span><span class="s0">import </span><span class="s1">(</span>
	<span class="s1">VarLibCFFDictMergeError</span><span class="s0">, </span><span class="s1">VarLibCFFPointTypeMergeError</span><span class="s0">,</span>
	<span class="s1">VarLibCFFHintTypeMergeError</span><span class="s0">,</span><span class="s1">VarLibMergeError)</span>


<span class="s2"># Backwards compatibility</span>
<span class="s1">MergeDictError = VarLibCFFDictMergeError</span>
<span class="s1">MergeTypeError = VarLibCFFPointTypeMergeError</span>


<span class="s0">def </span><span class="s1">addCFFVarStore(varFont</span><span class="s0">, </span><span class="s1">varModel</span><span class="s0">, </span><span class="s1">varDataList</span><span class="s0">, </span><span class="s1">masterSupports):</span>
	<span class="s1">fvarTable = varFont[</span><span class="s3">'fvar'</span><span class="s1">]</span>
	<span class="s1">axisKeys = [axis.axisTag </span><span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">fvarTable.axes]</span>
	<span class="s1">varTupleList = varLib.builder.buildVarRegionList(masterSupports</span><span class="s0">, </span><span class="s1">axisKeys)</span>
	<span class="s1">varStoreCFFV = varLib.builder.buildVarStore(varTupleList</span><span class="s0">, </span><span class="s1">varDataList)</span>

	<span class="s1">topDict = varFont[</span><span class="s3">'CFF2'</span><span class="s1">].cff.topDictIndex[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s1">topDict.VarStore = VarStoreData(otVarStore=varStoreCFFV)</span>
	<span class="s0">if </span><span class="s1">topDict.FDArray[</span><span class="s4">0</span><span class="s1">].vstore </span><span class="s0">is None</span><span class="s1">:</span>
		<span class="s1">fdArray = topDict.FDArray</span>
		<span class="s0">for </span><span class="s1">fontDict </span><span class="s0">in </span><span class="s1">fdArray:</span>
			<span class="s0">if </span><span class="s1">hasattr(fontDict</span><span class="s0">, </span><span class="s3">&quot;Private&quot;</span><span class="s1">):</span>
				<span class="s1">fontDict.Private.vstore = topDict.VarStore</span>


<span class="s0">def </span><span class="s1">lib_convertCFFToCFF2(cff</span><span class="s0">, </span><span class="s1">otFont):</span>
	<span class="s2"># This assumes a decompiled CFF table.</span>
	<span class="s1">cff2GetGlyphOrder = cff.otFont.getGlyphOrder</span>
	<span class="s1">topDictData = TopDictIndex(</span><span class="s0">None, </span><span class="s1">cff2GetGlyphOrder</span><span class="s0">, None</span><span class="s1">)</span>
	<span class="s1">topDictData.items = cff.topDictIndex.items</span>
	<span class="s1">cff.topDictIndex = topDictData</span>
	<span class="s1">topDict = topDictData[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s0">if </span><span class="s1">hasattr(topDict</span><span class="s0">, </span><span class="s3">'Private'</span><span class="s1">):</span>
		<span class="s1">privateDict = topDict.Private</span>
	<span class="s0">else</span><span class="s1">:</span>
		<span class="s1">privateDict = </span><span class="s0">None</span>
	<span class="s1">opOrder = buildOrder(topDictOperators2)</span>
	<span class="s1">topDict.order = opOrder</span>
	<span class="s1">topDict.cff2GetGlyphOrder = cff2GetGlyphOrder</span>
	<span class="s0">if not </span><span class="s1">hasattr(topDict</span><span class="s0">, </span><span class="s3">&quot;FDArray&quot;</span><span class="s1">):</span>
		<span class="s1">fdArray = topDict.FDArray = FDArrayIndex()</span>
		<span class="s1">fdArray.strings = </span><span class="s0">None</span>
		<span class="s1">fdArray.GlobalSubrs = topDict.GlobalSubrs</span>
		<span class="s1">topDict.GlobalSubrs.fdArray = fdArray</span>
		<span class="s1">charStrings = topDict.CharStrings</span>
		<span class="s0">if </span><span class="s1">charStrings.charStringsAreIndexed:</span>
			<span class="s1">charStrings.charStringsIndex.fdArray = fdArray</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">charStrings.fdArray = fdArray</span>
		<span class="s1">fontDict = FontDict()</span>
		<span class="s1">fontDict.setCFF2(</span><span class="s0">True</span><span class="s1">)</span>
		<span class="s1">fdArray.append(fontDict)</span>
		<span class="s1">fontDict.Private = privateDict</span>
		<span class="s1">privateOpOrder = buildOrder(privateDictOperators2)</span>
		<span class="s0">if </span><span class="s1">privateDict </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">privateDictOperators:</span>
				<span class="s1">key = entry[</span><span class="s4">1</span><span class="s1">]</span>
				<span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">privateOpOrder:</span>
					<span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">privateDict.rawDict:</span>
						<span class="s2"># print &quot;Removing private dict&quot;, key</span>
						<span class="s0">del </span><span class="s1">privateDict.rawDict[key]</span>
					<span class="s0">if </span><span class="s1">hasattr(privateDict</span><span class="s0">, </span><span class="s1">key):</span>
						<span class="s1">delattr(privateDict</span><span class="s0">, </span><span class="s1">key)</span>
						<span class="s2"># print &quot;Removing privateDict attr&quot;, key</span>
	<span class="s0">else</span><span class="s1">:</span>
		<span class="s2"># clean up the PrivateDicts in the fdArray</span>
		<span class="s1">fdArray = topDict.FDArray</span>
		<span class="s1">privateOpOrder = buildOrder(privateDictOperators2)</span>
		<span class="s0">for </span><span class="s1">fontDict </span><span class="s0">in </span><span class="s1">fdArray:</span>
			<span class="s1">fontDict.setCFF2(</span><span class="s0">True</span><span class="s1">)</span>
			<span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">list(fontDict.rawDict.keys()):</span>
				<span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">fontDict.order:</span>
					<span class="s0">del </span><span class="s1">fontDict.rawDict[key]</span>
					<span class="s0">if </span><span class="s1">hasattr(fontDict</span><span class="s0">, </span><span class="s1">key):</span>
						<span class="s1">delattr(fontDict</span><span class="s0">, </span><span class="s1">key)</span>

			<span class="s1">privateDict = fontDict.Private</span>
			<span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">privateDictOperators:</span>
				<span class="s1">key = entry[</span><span class="s4">1</span><span class="s1">]</span>
				<span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">privateOpOrder:</span>
					<span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">privateDict.rawDict:</span>
						<span class="s2"># print &quot;Removing private dict&quot;, key</span>
						<span class="s0">del </span><span class="s1">privateDict.rawDict[key]</span>
					<span class="s0">if </span><span class="s1">hasattr(privateDict</span><span class="s0">, </span><span class="s1">key):</span>
						<span class="s1">delattr(privateDict</span><span class="s0">, </span><span class="s1">key)</span>
						<span class="s2"># print &quot;Removing privateDict attr&quot;, key</span>
	<span class="s2"># Now delete up the decrecated topDict operators from CFF 1.0</span>
	<span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">topDictOperators:</span>
		<span class="s1">key = entry[</span><span class="s4">1</span><span class="s1">]</span>
		<span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">opOrder:</span>
			<span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">topDict.rawDict:</span>
				<span class="s0">del </span><span class="s1">topDict.rawDict[key]</span>
			<span class="s0">if </span><span class="s1">hasattr(topDict</span><span class="s0">, </span><span class="s1">key):</span>
				<span class="s1">delattr(topDict</span><span class="s0">, </span><span class="s1">key)</span>

	<span class="s2"># At this point, the Subrs and Charstrings are all still T2Charstring class</span>
	<span class="s2"># easiest to fix this by compiling, then decompiling again</span>
	<span class="s1">cff.major = </span><span class="s4">2</span>
	<span class="s1">file = BytesIO()</span>
	<span class="s1">cff.compile(file</span><span class="s0">, </span><span class="s1">otFont</span><span class="s0">, </span><span class="s1">isCFF2=</span><span class="s0">True</span><span class="s1">)</span>
	<span class="s1">file.seek(</span><span class="s4">0</span><span class="s1">)</span>
	<span class="s1">cff.decompile(file</span><span class="s0">, </span><span class="s1">otFont</span><span class="s0">, </span><span class="s1">isCFF2=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">convertCFFtoCFF2(varFont):</span>
	<span class="s2"># Convert base font to a single master CFF2 font.</span>
	<span class="s1">cffTable = varFont[</span><span class="s3">'CFF '</span><span class="s1">]</span>
	<span class="s1">lib_convertCFFToCFF2(cffTable.cff</span><span class="s0">, </span><span class="s1">varFont)</span>
	<span class="s1">newCFF2 = newTable(</span><span class="s3">&quot;CFF2&quot;</span><span class="s1">)</span>
	<span class="s1">newCFF2.cff = cffTable.cff</span>
	<span class="s1">varFont[</span><span class="s3">'CFF2'</span><span class="s1">] = newCFF2</span>
	<span class="s0">del </span><span class="s1">varFont[</span><span class="s3">'CFF '</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">conv_to_int(num):</span>
	<span class="s0">if </span><span class="s1">isinstance(num</span><span class="s0">, </span><span class="s1">float) </span><span class="s0">and </span><span class="s1">num.is_integer():</span>
		<span class="s0">return </span><span class="s1">int(num)</span>
	<span class="s0">return </span><span class="s1">num</span>


<span class="s1">pd_blend_fields = (</span><span class="s3">&quot;BlueValues&quot;</span><span class="s0">, </span><span class="s3">&quot;OtherBlues&quot;</span><span class="s0">, </span><span class="s3">&quot;FamilyBlues&quot;</span><span class="s0">,</span>
				   <span class="s3">&quot;FamilyOtherBlues&quot;</span><span class="s0">, </span><span class="s3">&quot;BlueScale&quot;</span><span class="s0">, </span><span class="s3">&quot;BlueShift&quot;</span><span class="s0">,</span>
				   <span class="s3">&quot;BlueFuzz&quot;</span><span class="s0">, </span><span class="s3">&quot;StdHW&quot;</span><span class="s0">, </span><span class="s3">&quot;StdVW&quot;</span><span class="s0">, </span><span class="s3">&quot;StemSnapH&quot;</span><span class="s0">,</span>
				   <span class="s3">&quot;StemSnapV&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">get_private(regionFDArrays</span><span class="s0">, </span><span class="s1">fd_index</span><span class="s0">, </span><span class="s1">ri</span><span class="s0">, </span><span class="s1">fd_map):</span>
	<span class="s1">region_fdArray = regionFDArrays[ri]</span>
	<span class="s1">region_fd_map = fd_map[fd_index]</span>
	<span class="s0">if </span><span class="s1">ri </span><span class="s0">in </span><span class="s1">region_fd_map:</span>
		<span class="s1">region_fdIndex = region_fd_map[ri]</span>
		<span class="s1">private = region_fdArray[region_fdIndex].Private</span>
	<span class="s0">else</span><span class="s1">:</span>
		<span class="s1">private = </span><span class="s0">None</span>
	<span class="s0">return </span><span class="s1">private</span>


<span class="s0">def </span><span class="s1">merge_PrivateDicts(top_dicts</span><span class="s0">, </span><span class="s1">vsindex_dict</span><span class="s0">, </span><span class="s1">var_model</span><span class="s0">, </span><span class="s1">fd_map):</span>
	<span class="s5">&quot;&quot;&quot; 
    I step through the FontDicts in the FDArray of the varfont TopDict. 
    For each varfont FontDict: 
     
    * step through each key in FontDict.Private. 
    * For each key, step through each relevant source font Private dict, and 
        build a list of values to blend. 
 
    The 'relevant' source fonts are selected by first getting the right 
    submodel using ``vsindex_dict[vsindex]``. The indices of the 
    ``subModel.locations`` are mapped to source font list indices by 
    assuming the latter order is the same as the order of the 
    ``var_model.locations``. I can then get the index of each subModel 
    location in the list of ``var_model.locations``. 
    &quot;&quot;&quot;</span>

	<span class="s1">topDict = top_dicts[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s1">region_top_dicts = top_dicts[</span><span class="s4">1</span><span class="s1">:]</span>
	<span class="s0">if </span><span class="s1">hasattr(region_top_dicts[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">'FDArray'</span><span class="s1">):</span>
		<span class="s1">regionFDArrays = [fdTopDict.FDArray </span><span class="s0">for </span><span class="s1">fdTopDict </span><span class="s0">in </span><span class="s1">region_top_dicts]</span>
	<span class="s0">else</span><span class="s1">:</span>
		<span class="s1">regionFDArrays = [[fdTopDict] </span><span class="s0">for </span><span class="s1">fdTopDict </span><span class="s0">in </span><span class="s1">region_top_dicts]</span>
	<span class="s0">for </span><span class="s1">fd_index</span><span class="s0">, </span><span class="s1">font_dict </span><span class="s0">in </span><span class="s1">enumerate(topDict.FDArray):</span>
		<span class="s1">private_dict = font_dict.Private</span>
		<span class="s1">vsindex = getattr(private_dict</span><span class="s0">, </span><span class="s3">'vsindex'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
		<span class="s2"># At the moment, no PrivateDict has a vsindex key, but let's support</span>
		<span class="s2"># how it should work. See comment at end of</span>
		<span class="s2"># merge_charstrings() - still need to optimize use of vsindex.</span>
		<span class="s1">sub_model</span><span class="s0">, </span><span class="s1">_ = vsindex_dict[vsindex]</span>
		<span class="s1">master_indices = []</span>
		<span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">sub_model.locations[</span><span class="s4">1</span><span class="s1">:]:</span>
			<span class="s1">i = var_model.locations.index(loc) - </span><span class="s4">1</span>
			<span class="s1">master_indices.append(i)</span>
		<span class="s1">pds = [private_dict]</span>
		<span class="s1">last_pd = private_dict</span>
		<span class="s0">for </span><span class="s1">ri </span><span class="s0">in </span><span class="s1">master_indices:</span>
			<span class="s1">pd = get_private(regionFDArrays</span><span class="s0">, </span><span class="s1">fd_index</span><span class="s0">, </span><span class="s1">ri</span><span class="s0">, </span><span class="s1">fd_map)</span>
			<span class="s2"># If the region font doesn't have this FontDict, just reference</span>
			<span class="s2"># the last one used.</span>
			<span class="s0">if </span><span class="s1">pd </span><span class="s0">is None</span><span class="s1">:</span>
				<span class="s1">pd = last_pd</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">last_pd = pd</span>
			<span class="s1">pds.append(pd)</span>
		<span class="s1">num_masters = len(pds)</span>
		<span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">private_dict.rawDict.items():</span>
			<span class="s1">dataList = []</span>
			<span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">pd_blend_fields:</span>
				<span class="s0">continue</span>
			<span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">list):</span>
				<span class="s0">try</span><span class="s1">:</span>
					<span class="s1">values = [pd.rawDict[key] </span><span class="s0">for </span><span class="s1">pd </span><span class="s0">in </span><span class="s1">pds]</span>
				<span class="s0">except </span><span class="s1">KeyError:</span>
					<span class="s1">print(</span>
						<span class="s3">&quot;Warning: {key} in default font Private dict is &quot;</span>
						<span class="s3">&quot;missing from another font, and was &quot;</span>
						<span class="s3">&quot;discarded.&quot;</span><span class="s1">.format(key=key))</span>
					<span class="s0">continue</span>
				<span class="s0">try</span><span class="s1">:</span>
					<span class="s1">values = zip(*values)</span>
				<span class="s0">except </span><span class="s1">IndexError:</span>
					<span class="s0">raise </span><span class="s1">VarLibCFFDictMergeError(key</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">values)</span>
				<span class="s3">&quot;&quot;&quot; 
                Row 0 contains the first  value from each master. 
                Convert each row from absolute values to relative 
                values from the previous row. 
                e.g for three masters,  a list of values was: 
                master 0 OtherBlues = [-217,-205] 
                master 1 OtherBlues = [-234,-222] 
                master 1 OtherBlues = [-188,-176] 
                The call to zip() converts this to: 
                [(-217, -234, -188), (-205, -222, -176)] 
                and is converted finally to: 
                OtherBlues = [[-217, 17.0, 46.0], [-205, 0.0, 0.0]] 
                &quot;&quot;&quot;</span>
				<span class="s1">prev_val_list = [</span><span class="s4">0</span><span class="s1">] * num_masters</span>
				<span class="s1">any_points_differ = </span><span class="s0">False</span>
				<span class="s0">for </span><span class="s1">val_list </span><span class="s0">in </span><span class="s1">values:</span>
					<span class="s1">rel_list = [(val - prev_val_list[i]) </span><span class="s0">for </span><span class="s1">(</span>
							<span class="s1">i</span><span class="s0">, </span><span class="s1">val) </span><span class="s0">in </span><span class="s1">enumerate(val_list)]</span>
					<span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">any_points_differ) </span><span class="s0">and not </span><span class="s1">allEqual(rel_list):</span>
						<span class="s1">any_points_differ = </span><span class="s0">True</span>
					<span class="s1">prev_val_list = val_list</span>
					<span class="s1">deltas = sub_model.getDeltas(rel_list)</span>
					<span class="s2"># For PrivateDict BlueValues, the default font</span>
					<span class="s2"># values are absolute, not relative to the prior value.</span>
					<span class="s1">deltas[</span><span class="s4">0</span><span class="s1">] = val_list[</span><span class="s4">0</span><span class="s1">]</span>
					<span class="s1">dataList.append(deltas)</span>
				<span class="s2"># If there are no blend values,then</span>
				<span class="s2"># we can collapse the blend lists.</span>
				<span class="s0">if not </span><span class="s1">any_points_differ:</span>
					<span class="s1">dataList = [data[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">dataList]</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">values = [pd.rawDict[key] </span><span class="s0">for </span><span class="s1">pd </span><span class="s0">in </span><span class="s1">pds]</span>
				<span class="s0">if not </span><span class="s1">allEqual(values):</span>
					<span class="s1">dataList = sub_model.getDeltas(values)</span>
				<span class="s0">else</span><span class="s1">:</span>
					<span class="s1">dataList = values[</span><span class="s4">0</span><span class="s1">]</span>

			<span class="s2"># Convert numbers with no decimal part to an int</span>
			<span class="s0">if </span><span class="s1">isinstance(dataList</span><span class="s0">, </span><span class="s1">list):</span>
				<span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">item </span><span class="s0">in </span><span class="s1">enumerate(dataList):</span>
					<span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">list):</span>
						<span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">jtem </span><span class="s0">in </span><span class="s1">enumerate(item):</span>
							<span class="s1">dataList[i][j] = conv_to_int(jtem)</span>
					<span class="s0">else</span><span class="s1">:</span>
						<span class="s1">dataList[i] = conv_to_int(item)</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">dataList = conv_to_int(dataList)</span>

			<span class="s1">private_dict.rawDict[key] = dataList</span>


<span class="s0">def </span><span class="s1">_cff_or_cff2(font):</span>
	<span class="s0">if </span><span class="s3">&quot;CFF &quot; </span><span class="s0">in </span><span class="s1">font:</span>
		<span class="s0">return </span><span class="s1">font[</span><span class="s3">&quot;CFF &quot;</span><span class="s1">]</span>
	<span class="s0">return </span><span class="s1">font[</span><span class="s3">&quot;CFF2&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">getfd_map(varFont</span><span class="s0">, </span><span class="s1">fonts_list):</span>
	<span class="s5">&quot;&quot;&quot; Since a subset source font may have fewer FontDicts in their 
    FDArray than the default font, we have to match up the FontDicts in 
    the different fonts . We do this with the FDSelect array, and by 
    assuming that the same glyph will reference  matching FontDicts in 
    each source font. We return a mapping from fdIndex in the default 
    font to a dictionary which maps each master list index of each 
    region font to the equivalent fdIndex in the region font.&quot;&quot;&quot;</span>
	<span class="s1">fd_map = {}</span>
	<span class="s1">default_font = fonts_list[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s1">region_fonts = fonts_list[</span><span class="s4">1</span><span class="s1">:]</span>
	<span class="s1">num_regions = len(region_fonts)</span>
	<span class="s1">topDict = _cff_or_cff2(default_font).cff.topDictIndex[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s0">if not </span><span class="s1">hasattr(topDict</span><span class="s0">, </span><span class="s3">'FDSelect'</span><span class="s1">):</span>
		<span class="s2"># All glyphs reference only one FontDict.</span>
		<span class="s2"># Map the FD index for regions to index 0.</span>
		<span class="s1">fd_map[</span><span class="s4">0</span><span class="s1">] = {ri:</span><span class="s4">0 </span><span class="s0">for </span><span class="s1">ri </span><span class="s0">in </span><span class="s1">range(num_regions)}</span>
		<span class="s0">return </span><span class="s1">fd_map</span>

	<span class="s1">gname_mapping = {}</span>
	<span class="s1">default_fdSelect = topDict.FDSelect</span>
	<span class="s1">glyphOrder = default_font.getGlyphOrder()</span>
	<span class="s0">for </span><span class="s1">gid</span><span class="s0">, </span><span class="s1">fdIndex </span><span class="s0">in </span><span class="s1">enumerate(default_fdSelect):</span>
		<span class="s1">gname_mapping[glyphOrder[gid]] = fdIndex</span>
		<span class="s0">if </span><span class="s1">fdIndex </span><span class="s0">not in </span><span class="s1">fd_map:</span>
			<span class="s1">fd_map[fdIndex] = {}</span>
	<span class="s0">for </span><span class="s1">ri</span><span class="s0">, </span><span class="s1">region_font </span><span class="s0">in </span><span class="s1">enumerate(region_fonts):</span>
		<span class="s1">region_glyphOrder = region_font.getGlyphOrder()</span>
		<span class="s1">region_topDict = _cff_or_cff2(region_font).cff.topDictIndex[</span><span class="s4">0</span><span class="s1">]</span>
		<span class="s0">if not </span><span class="s1">hasattr(region_topDict</span><span class="s0">, </span><span class="s3">'FDSelect'</span><span class="s1">):</span>
			<span class="s2"># All the glyphs share the same FontDict. Pick any glyph.</span>
			<span class="s1">default_fdIndex = gname_mapping[region_glyphOrder[</span><span class="s4">0</span><span class="s1">]]</span>
			<span class="s1">fd_map[default_fdIndex][ri] = </span><span class="s4">0</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">region_fdSelect = region_topDict.FDSelect</span>
			<span class="s0">for </span><span class="s1">gid</span><span class="s0">, </span><span class="s1">fdIndex </span><span class="s0">in </span><span class="s1">enumerate(region_fdSelect):</span>
				<span class="s1">default_fdIndex = gname_mapping[region_glyphOrder[gid]]</span>
				<span class="s1">region_map = fd_map[default_fdIndex]</span>
				<span class="s0">if </span><span class="s1">ri </span><span class="s0">not in </span><span class="s1">region_map:</span>
					<span class="s1">region_map[ri] = fdIndex</span>
	<span class="s0">return </span><span class="s1">fd_map</span>


<span class="s1">CVarData = namedtuple(</span><span class="s3">'CVarData'</span><span class="s0">, </span><span class="s3">'varDataList masterSupports vsindex_dict'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">merge_region_fonts(varFont</span><span class="s0">, </span><span class="s1">model</span><span class="s0">, </span><span class="s1">ordered_fonts_list</span><span class="s0">, </span><span class="s1">glyphOrder):</span>
	<span class="s1">topDict = varFont[</span><span class="s3">'CFF2'</span><span class="s1">].cff.topDictIndex[</span><span class="s4">0</span><span class="s1">]</span>
	<span class="s1">top_dicts = [topDict] + [</span>
					<span class="s1">_cff_or_cff2(ttFont).cff.topDictIndex[</span><span class="s4">0</span><span class="s1">]</span>
					<span class="s0">for </span><span class="s1">ttFont </span><span class="s0">in </span><span class="s1">ordered_fonts_list[</span><span class="s4">1</span><span class="s1">:]</span>
					<span class="s1">]</span>
	<span class="s1">num_masters = len(model.mapping)</span>
	<span class="s1">cvData = merge_charstrings(glyphOrder</span><span class="s0">, </span><span class="s1">num_masters</span><span class="s0">, </span><span class="s1">top_dicts</span><span class="s0">, </span><span class="s1">model)</span>
	<span class="s1">fd_map = getfd_map(varFont</span><span class="s0">, </span><span class="s1">ordered_fonts_list)</span>
	<span class="s1">merge_PrivateDicts(top_dicts</span><span class="s0">, </span><span class="s1">cvData.vsindex_dict</span><span class="s0">, </span><span class="s1">model</span><span class="s0">, </span><span class="s1">fd_map)</span>
	<span class="s1">addCFFVarStore(varFont</span><span class="s0">, </span><span class="s1">model</span><span class="s0">, </span><span class="s1">cvData.varDataList</span><span class="s0">,</span>
		<span class="s1">cvData.masterSupports)</span>


<span class="s0">def </span><span class="s1">_get_cs(charstrings</span><span class="s0">, </span><span class="s1">glyphName):</span>
	<span class="s0">if </span><span class="s1">glyphName </span><span class="s0">not in </span><span class="s1">charstrings:</span>
		<span class="s0">return None</span>
	<span class="s0">return </span><span class="s1">charstrings[glyphName]</span>

<span class="s0">def </span><span class="s1">_add_new_vsindex(model</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">masterSupports</span><span class="s0">, </span><span class="s1">vsindex_dict</span><span class="s0">,</span>
		<span class="s1">vsindex_by_key</span><span class="s0">, </span><span class="s1">varDataList):</span>
	<span class="s1">varTupleIndexes = []</span>
	<span class="s0">for </span><span class="s1">support </span><span class="s0">in </span><span class="s1">model.supports[</span><span class="s4">1</span><span class="s1">:]:</span>
		<span class="s0">if </span><span class="s1">support </span><span class="s0">not in </span><span class="s1">masterSupports:</span>
			<span class="s1">masterSupports.append(support)</span>
		<span class="s1">varTupleIndexes.append(masterSupports.index(support))</span>
	<span class="s1">var_data = varLib.builder.buildVarData(varTupleIndexes</span><span class="s0">, None, False</span><span class="s1">)</span>
	<span class="s1">vsindex = len(vsindex_dict)</span>
	<span class="s1">vsindex_by_key[key] = vsindex</span>
	<span class="s1">vsindex_dict[vsindex] = (model</span><span class="s0">, </span><span class="s1">[key])</span>
	<span class="s1">varDataList.append(var_data)</span>
	<span class="s0">return </span><span class="s1">vsindex</span>

<span class="s0">def </span><span class="s1">merge_charstrings(glyphOrder</span><span class="s0">, </span><span class="s1">num_masters</span><span class="s0">, </span><span class="s1">top_dicts</span><span class="s0">, </span><span class="s1">masterModel):</span>

	<span class="s1">vsindex_dict = {}</span>
	<span class="s1">vsindex_by_key = {}</span>
	<span class="s1">varDataList = []</span>
	<span class="s1">masterSupports = []</span>
	<span class="s1">default_charstrings = top_dicts[</span><span class="s4">0</span><span class="s1">].CharStrings</span>
	<span class="s0">for </span><span class="s1">gid</span><span class="s0">, </span><span class="s1">gname </span><span class="s0">in </span><span class="s1">enumerate(glyphOrder):</span>
		<span class="s1">all_cs = [</span>
				<span class="s1">_get_cs(td.CharStrings</span><span class="s0">, </span><span class="s1">gname)</span>
				<span class="s0">for </span><span class="s1">td </span><span class="s0">in </span><span class="s1">top_dicts]</span>
		<span class="s0">if </span><span class="s1">len([gs </span><span class="s0">for </span><span class="s1">gs </span><span class="s0">in </span><span class="s1">all_cs </span><span class="s0">if </span><span class="s1">gs </span><span class="s0">is not None</span><span class="s1">]) == </span><span class="s4">1</span><span class="s1">:</span>
			<span class="s0">continue</span>
		<span class="s1">model</span><span class="s0">, </span><span class="s1">model_cs = masterModel.getSubModel(all_cs)</span>
		<span class="s2"># create the first pass CFF2 charstring, from</span>
		<span class="s2"># the default charstring.</span>
		<span class="s1">default_charstring = model_cs[</span><span class="s4">0</span><span class="s1">]</span>
		<span class="s1">var_pen = CFF2CharStringMergePen([]</span><span class="s0">, </span><span class="s1">gname</span><span class="s0">, </span><span class="s1">num_masters</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
		<span class="s2"># We need to override outlineExtractor because these</span>
		<span class="s2"># charstrings do have widths in the 'program'; we need to drop these</span>
		<span class="s2"># values rather than post assertion error for them.</span>
		<span class="s1">default_charstring.outlineExtractor = MergeOutlineExtractor</span>
		<span class="s1">default_charstring.draw(var_pen)</span>

		<span class="s2"># Add the coordinates from all the other regions to the</span>
		<span class="s2"># blend lists in the CFF2 charstring.</span>
		<span class="s1">region_cs = model_cs[</span><span class="s4">1</span><span class="s1">:]</span>
		<span class="s0">for </span><span class="s1">region_idx</span><span class="s0">, </span><span class="s1">region_charstring </span><span class="s0">in </span><span class="s1">enumerate(region_cs</span><span class="s0">, </span><span class="s1">start=</span><span class="s4">1</span><span class="s1">):</span>
			<span class="s1">var_pen.restart(region_idx)</span>
			<span class="s1">region_charstring.outlineExtractor = MergeOutlineExtractor</span>
			<span class="s1">region_charstring.draw(var_pen)</span>

		<span class="s2"># Collapse each coordinate list to a blend operator and its args.</span>
		<span class="s1">new_cs = var_pen.getCharString(</span>
			<span class="s1">private=default_charstring.private</span><span class="s0">,</span>
			<span class="s1">globalSubrs=default_charstring.globalSubrs</span><span class="s0">,</span>
			<span class="s1">var_model=model</span><span class="s0">, </span><span class="s1">optimize=</span><span class="s0">True</span><span class="s1">)</span>
		<span class="s1">default_charstrings[gname] = new_cs</span>

		<span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">var_pen.seen_moveto) </span><span class="s0">or </span><span class="s1">(</span><span class="s3">'blend' </span><span class="s0">not in </span><span class="s1">new_cs.program):</span>
			<span class="s2"># If this is not a marking glyph, or if there are no blend</span>
			<span class="s2"># arguments, then we can use vsindex 0. No need to</span>
			<span class="s2"># check if we need a new vsindex.</span>
			<span class="s0">continue</span>

		<span class="s2"># If the charstring required a new model, create</span>
		<span class="s2"># a VarData table to go with, and set vsindex.</span>
		<span class="s1">key = tuple(v </span><span class="s0">is not None for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">all_cs)</span>
		<span class="s0">try</span><span class="s1">:</span>
			<span class="s1">vsindex = vsindex_by_key[key]</span>
		<span class="s0">except </span><span class="s1">KeyError:</span>
			<span class="s1">vsindex = _add_new_vsindex(model</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">masterSupports</span><span class="s0">, </span><span class="s1">vsindex_dict</span><span class="s0">,</span>
				<span class="s1">vsindex_by_key</span><span class="s0">, </span><span class="s1">varDataList)</span>
		<span class="s2"># We do not need to check for an existing new_cs.private.vsindex,</span>
		<span class="s2"># as we know it doesn't exist yet.</span>
		<span class="s0">if </span><span class="s1">vsindex != </span><span class="s4">0</span><span class="s1">:</span>
			<span class="s1">new_cs.program[:</span><span class="s4">0</span><span class="s1">] = [vsindex</span><span class="s0">, </span><span class="s3">'vsindex'</span><span class="s1">]</span>

	<span class="s2"># If there is no variation in any of the charstrings, then vsindex_dict</span>
	<span class="s2"># never gets built. This could still be needed if there is variation</span>
	<span class="s2"># in the PrivatDict, so we will build the default data for vsindex = 0.</span>
	<span class="s0">if not </span><span class="s1">vsindex_dict:</span>
		<span class="s1">key = (</span><span class="s0">True,</span><span class="s1">) * num_masters</span>
		<span class="s1">_add_new_vsindex(masterModel</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">masterSupports</span><span class="s0">, </span><span class="s1">vsindex_dict</span><span class="s0">,</span>
			<span class="s1">vsindex_by_key</span><span class="s0">, </span><span class="s1">varDataList)</span>
	<span class="s1">cvData = CVarData(varDataList=varDataList</span><span class="s0">, </span><span class="s1">masterSupports=masterSupports</span><span class="s0">,</span>
						<span class="s1">vsindex_dict=vsindex_dict)</span>
	<span class="s2"># XXX To do: optimize use of vsindex between the PrivateDicts and</span>
	<span class="s2"># charstrings</span>
	<span class="s0">return </span><span class="s1">cvData</span>


<span class="s0">class </span><span class="s1">CFFToCFF2OutlineExtractor(T2OutlineExtractor):</span>
	<span class="s5">&quot;&quot;&quot; This class is used to remove the initial width from the CFF 
    charstring without trying to add the width to self.nominalWidthX, 
    which is None. &quot;&quot;&quot;</span>
	<span class="s0">def </span><span class="s1">popallWidth(self</span><span class="s0">, </span><span class="s1">evenOdd=</span><span class="s4">0</span><span class="s1">):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s0">if not </span><span class="s1">self.gotWidth:</span>
			<span class="s0">if </span><span class="s1">evenOdd ^ (len(args) % </span><span class="s4">2</span><span class="s1">):</span>
				<span class="s1">args = args[</span><span class="s4">1</span><span class="s1">:]</span>
			<span class="s1">self.width = self.defaultWidthX</span>
			<span class="s1">self.gotWidth = </span><span class="s4">1</span>
		<span class="s0">return </span><span class="s1">args</span>


<span class="s0">class </span><span class="s1">MergeOutlineExtractor(CFFToCFF2OutlineExtractor):</span>
	<span class="s5">&quot;&quot;&quot; Used to extract the charstring commands - including hints - from a 
    CFF charstring in order to merge it as another set of region data 
    into a CFF2 variable font charstring.&quot;&quot;&quot;</span>

	<span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">pen</span><span class="s0">, </span><span class="s1">localSubrs</span><span class="s0">, </span><span class="s1">globalSubrs</span><span class="s0">,</span>
			<span class="s1">nominalWidthX</span><span class="s0">, </span><span class="s1">defaultWidthX</span><span class="s0">, </span><span class="s1">private=</span><span class="s0">None, </span><span class="s1">blender=</span><span class="s0">None</span><span class="s1">):</span>
		<span class="s1">super().__init__(pen</span><span class="s0">, </span><span class="s1">localSubrs</span><span class="s0">,</span>
			<span class="s1">globalSubrs</span><span class="s0">, </span><span class="s1">nominalWidthX</span><span class="s0">, </span><span class="s1">defaultWidthX</span><span class="s0">, </span><span class="s1">private</span><span class="s0">, </span><span class="s1">blender)</span>

	<span class="s0">def </span><span class="s1">countHints(self):</span>
		<span class="s1">args = self.popallWidth()</span>
		<span class="s1">self.hintCount = self.hintCount + len(args) // </span><span class="s4">2</span>
		<span class="s0">return </span><span class="s1">args</span>

	<span class="s0">def </span><span class="s1">_hint_op(self</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">args):</span>
		<span class="s1">self.pen.add_hint(type</span><span class="s0">, </span><span class="s1">args)</span>

	<span class="s0">def </span><span class="s1">op_hstem(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">args = self.countHints()</span>
		<span class="s1">self._hint_op(</span><span class="s3">'hstem'</span><span class="s0">, </span><span class="s1">args)</span>

	<span class="s0">def </span><span class="s1">op_vstem(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">args = self.countHints()</span>
		<span class="s1">self._hint_op(</span><span class="s3">'vstem'</span><span class="s0">, </span><span class="s1">args)</span>

	<span class="s0">def </span><span class="s1">op_hstemhm(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">args = self.countHints()</span>
		<span class="s1">self._hint_op(</span><span class="s3">'hstemhm'</span><span class="s0">, </span><span class="s1">args)</span>

	<span class="s0">def </span><span class="s1">op_vstemhm(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">args = self.countHints()</span>
		<span class="s1">self._hint_op(</span><span class="s3">'vstemhm'</span><span class="s0">, </span><span class="s1">args)</span>

	<span class="s0">def </span><span class="s1">_get_hintmask(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s0">if not </span><span class="s1">self.hintMaskBytes:</span>
			<span class="s1">args = self.countHints()</span>
			<span class="s0">if </span><span class="s1">args:</span>
				<span class="s1">self._hint_op(</span><span class="s3">'vstemhm'</span><span class="s0">, </span><span class="s1">args)</span>
			<span class="s1">self.hintMaskBytes = (self.hintCount + </span><span class="s4">7</span><span class="s1">) // </span><span class="s4">8</span>
		<span class="s1">hintMaskBytes</span><span class="s0">, </span><span class="s1">index = self.callingStack[-</span><span class="s4">1</span><span class="s1">].getBytes(index</span><span class="s0">,</span>
			<span class="s1">self.hintMaskBytes)</span>
		<span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">hintMaskBytes</span>

	<span class="s0">def </span><span class="s1">op_hintmask(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">index</span><span class="s0">, </span><span class="s1">hintMaskBytes = self._get_hintmask(index)</span>
		<span class="s1">self.pen.add_hintmask(</span><span class="s3">'hintmask'</span><span class="s0">, </span><span class="s1">[hintMaskBytes])</span>
		<span class="s0">return </span><span class="s1">hintMaskBytes</span><span class="s0">, </span><span class="s1">index</span>

	<span class="s0">def </span><span class="s1">op_cntrmask(self</span><span class="s0">, </span><span class="s1">index):</span>
		<span class="s1">index</span><span class="s0">, </span><span class="s1">hintMaskBytes = self._get_hintmask(index)</span>
		<span class="s1">self.pen.add_hintmask(</span><span class="s3">'cntrmask'</span><span class="s0">, </span><span class="s1">[hintMaskBytes])</span>
		<span class="s0">return </span><span class="s1">hintMaskBytes</span><span class="s0">, </span><span class="s1">index</span>


<span class="s0">class </span><span class="s1">CFF2CharStringMergePen(T2CharStringPen):</span>
	<span class="s5">&quot;&quot;&quot;Pen to merge Type 2 CharStrings. 
    &quot;&quot;&quot;</span>
	<span class="s0">def </span><span class="s1">__init__(</span>
				<span class="s1">self</span><span class="s0">, </span><span class="s1">default_commands</span><span class="s0">, </span><span class="s1">glyphName</span><span class="s0">, </span><span class="s1">num_masters</span><span class="s0">, </span><span class="s1">master_idx</span><span class="s0">,</span>
				<span class="s1">roundTolerance=</span><span class="s4">0.01</span><span class="s1">):</span>
		<span class="s2"># For roundTolerance see https://github.com/fonttools/fonttools/issues/2838</span>
		<span class="s1">super().__init__(</span>
							<span class="s1">width=</span><span class="s0">None,</span>
							<span class="s1">glyphSet=</span><span class="s0">None, </span><span class="s1">CFF2=</span><span class="s0">True,</span>
							<span class="s1">roundTolerance=roundTolerance)</span>
		<span class="s1">self.pt_index = </span><span class="s4">0</span>
		<span class="s1">self._commands = default_commands</span>
		<span class="s1">self.m_index = master_idx</span>
		<span class="s1">self.num_masters = num_masters</span>
		<span class="s1">self.prev_move_idx = </span><span class="s4">0</span>
		<span class="s1">self.seen_moveto = </span><span class="s0">False</span>
		<span class="s1">self.glyphName = glyphName</span>
		<span class="s1">self.round = roundFunc(roundTolerance</span><span class="s0">, </span><span class="s1">round=round)</span>

	<span class="s0">def </span><span class="s1">add_point(self</span><span class="s0">, </span><span class="s1">point_type</span><span class="s0">, </span><span class="s1">pt_coords):</span>
		<span class="s0">if </span><span class="s1">self.m_index == </span><span class="s4">0</span><span class="s1">:</span>
			<span class="s1">self._commands.append([point_type</span><span class="s0">, </span><span class="s1">[pt_coords]])</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">cmd = self._commands[self.pt_index]</span>
			<span class="s0">if </span><span class="s1">cmd[</span><span class="s4">0</span><span class="s1">] != point_type:</span>
				<span class="s0">raise </span><span class="s1">VarLibCFFPointTypeMergeError(</span>
									<span class="s1">point_type</span><span class="s0">,</span>
									<span class="s1">self.pt_index</span><span class="s0">, </span><span class="s1">len(cmd[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
									<span class="s1">cmd[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.glyphName)</span>
			<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">].append(pt_coords)</span>
		<span class="s1">self.pt_index += </span><span class="s4">1</span>

	<span class="s0">def </span><span class="s1">add_hint(self</span><span class="s0">, </span><span class="s1">hint_type</span><span class="s0">, </span><span class="s1">args):</span>
		<span class="s0">if </span><span class="s1">self.m_index == </span><span class="s4">0</span><span class="s1">:</span>
			<span class="s1">self._commands.append([hint_type</span><span class="s0">, </span><span class="s1">[args]])</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">cmd = self._commands[self.pt_index]</span>
			<span class="s0">if </span><span class="s1">cmd[</span><span class="s4">0</span><span class="s1">] != hint_type:</span>
				<span class="s0">raise </span><span class="s1">VarLibCFFHintTypeMergeError(hint_type</span><span class="s0">, </span><span class="s1">self.pt_index</span><span class="s0">, </span><span class="s1">len(cmd[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
					<span class="s1">cmd[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.glyphName)</span>
			<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">].append(args)</span>
		<span class="s1">self.pt_index += </span><span class="s4">1</span>

	<span class="s0">def </span><span class="s1">add_hintmask(self</span><span class="s0">, </span><span class="s1">hint_type</span><span class="s0">, </span><span class="s1">abs_args):</span>
		<span class="s2"># For hintmask, fonttools.cffLib.specializer.py expects</span>
		<span class="s2"># each of these to be represented by two sequential commands:</span>
		<span class="s2"># first holding only the operator name, with an empty arg list,</span>
		<span class="s2"># second with an empty string as the op name, and the mask arg list.</span>
		<span class="s0">if </span><span class="s1">self.m_index == </span><span class="s4">0</span><span class="s1">:</span>
			<span class="s1">self._commands.append([hint_type</span><span class="s0">, </span><span class="s1">[]])</span>
			<span class="s1">self._commands.append([</span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s1">[abs_args]])</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">cmd = self._commands[self.pt_index]</span>
			<span class="s0">if </span><span class="s1">cmd[</span><span class="s4">0</span><span class="s1">] != hint_type:</span>
				<span class="s0">raise </span><span class="s1">VarLibCFFHintTypeMergeError(hint_type</span><span class="s0">, </span><span class="s1">self.pt_index</span><span class="s0">, </span><span class="s1">len(cmd[</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
					<span class="s1">cmd[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.glyphName)</span>
			<span class="s1">self.pt_index += </span><span class="s4">1</span>
			<span class="s1">cmd = self._commands[self.pt_index]</span>
			<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">].append(abs_args)</span>
		<span class="s1">self.pt_index += </span><span class="s4">1</span>

	<span class="s0">def </span><span class="s1">_moveTo(self</span><span class="s0">, </span><span class="s1">pt):</span>
		<span class="s0">if not </span><span class="s1">self.seen_moveto:</span>
			<span class="s1">self.seen_moveto = </span><span class="s0">True</span>
		<span class="s1">pt_coords = self._p(pt)</span>
		<span class="s1">self.add_point(</span><span class="s3">'rmoveto'</span><span class="s0">, </span><span class="s1">pt_coords)</span>
		<span class="s2"># I set prev_move_idx here because add_point()</span>
		<span class="s2"># can change self.pt_index.</span>
		<span class="s1">self.prev_move_idx = self.pt_index - </span><span class="s4">1</span>

	<span class="s0">def </span><span class="s1">_lineTo(self</span><span class="s0">, </span><span class="s1">pt):</span>
		<span class="s1">pt_coords = self._p(pt)</span>
		<span class="s1">self.add_point(</span><span class="s3">'rlineto'</span><span class="s0">, </span><span class="s1">pt_coords)</span>

	<span class="s0">def </span><span class="s1">_curveToOne(self</span><span class="s0">, </span><span class="s1">pt1</span><span class="s0">, </span><span class="s1">pt2</span><span class="s0">, </span><span class="s1">pt3):</span>
		<span class="s1">_p = self._p</span>
		<span class="s1">pt_coords = _p(pt1)+_p(pt2)+_p(pt3)</span>
		<span class="s1">self.add_point(</span><span class="s3">'rrcurveto'</span><span class="s0">, </span><span class="s1">pt_coords)</span>

	<span class="s0">def </span><span class="s1">_closePath(self):</span>
		<span class="s0">pass</span>

	<span class="s0">def </span><span class="s1">_endPath(self):</span>
		<span class="s0">pass</span>

	<span class="s0">def </span><span class="s1">restart(self</span><span class="s0">, </span><span class="s1">region_idx):</span>
		<span class="s1">self.pt_index = </span><span class="s4">0</span>
		<span class="s1">self.m_index = region_idx</span>
		<span class="s1">self._p0 = (</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

	<span class="s0">def </span><span class="s1">getCommands(self):</span>
		<span class="s0">return </span><span class="s1">self._commands</span>

	<span class="s0">def </span><span class="s1">reorder_blend_args(self</span><span class="s0">, </span><span class="s1">commands</span><span class="s0">, </span><span class="s1">get_delta_func):</span>
		<span class="s5">&quot;&quot;&quot; 
        We first re-order the master coordinate values. 
        For a moveto to lineto, the args are now arranged as:: 
 
            [ [master_0 x,y], [master_1 x,y], [master_2 x,y] ] 
 
        We re-arrange this to:: 
 
            [   [master_0 x, master_1 x, master_2 x], 
                [master_0 y, master_1 y, master_2 y] 
            ] 
 
        If the master values are all the same, we collapse the list to 
        as single value instead of a list. 
 
        We then convert this to:: 
 
            [ [master_0 x] + [x delta tuple] + [numBlends=1] 
              [master_0 y] + [y delta tuple] + [numBlends=1] 
            ] 
        &quot;&quot;&quot;</span>
		<span class="s0">for </span><span class="s1">cmd </span><span class="s0">in </span><span class="s1">commands:</span>
			<span class="s2"># arg[i] is the set of arguments for this operator from master i.</span>
			<span class="s1">args = cmd[</span><span class="s4">1</span><span class="s1">]</span>
			<span class="s1">m_args = zip(*args)</span>
			<span class="s2"># m_args[n] is now all num_master args for the i'th argument</span>
			<span class="s2"># for this operation.</span>
			<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">] = list(m_args)</span>
		<span class="s1">lastOp = </span><span class="s0">None</span>
		<span class="s0">for </span><span class="s1">cmd </span><span class="s0">in </span><span class="s1">commands:</span>
			<span class="s1">op = cmd[</span><span class="s4">0</span><span class="s1">]</span>
			<span class="s2"># masks are represented by two cmd's: first has only op names,</span>
			<span class="s2"># second has only args.</span>
			<span class="s0">if </span><span class="s1">lastOp </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'hintmask'</span><span class="s0">, </span><span class="s3">'cntrmask'</span><span class="s1">]:</span>
				<span class="s1">coord = list(cmd[</span><span class="s4">1</span><span class="s1">])</span>
				<span class="s0">if not </span><span class="s1">allEqual(coord):</span>
					<span class="s0">raise </span><span class="s1">VarLibMergeError(</span><span class="s3">&quot;Hintmask values cannot differ between source fonts.&quot;</span><span class="s1">)</span>
				<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">] = [coord[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]]</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">coords = cmd[</span><span class="s4">1</span><span class="s1">]</span>
				<span class="s1">new_coords = []</span>
				<span class="s0">for </span><span class="s1">coord </span><span class="s0">in </span><span class="s1">coords:</span>
					<span class="s0">if </span><span class="s1">allEqual(coord):</span>
						<span class="s1">new_coords.append(coord[</span><span class="s4">0</span><span class="s1">])</span>
					<span class="s0">else</span><span class="s1">:</span>
						<span class="s2"># convert to deltas</span>
						<span class="s1">deltas = get_delta_func(coord)[</span><span class="s4">1</span><span class="s1">:]</span>
						<span class="s1">coord = [coord[</span><span class="s4">0</span><span class="s1">]] + deltas</span>
						<span class="s1">coord.append(</span><span class="s4">1</span><span class="s1">)</span>
						<span class="s1">new_coords.append(coord)</span>
				<span class="s1">cmd[</span><span class="s4">1</span><span class="s1">] = new_coords</span>
			<span class="s1">lastOp = op</span>
		<span class="s0">return </span><span class="s1">commands</span>

	<span class="s0">def </span><span class="s1">getCharString(</span>
					<span class="s1">self</span><span class="s0">, </span><span class="s1">private=</span><span class="s0">None, </span><span class="s1">globalSubrs=</span><span class="s0">None,</span>
					<span class="s1">var_model=</span><span class="s0">None, </span><span class="s1">optimize=</span><span class="s0">True</span><span class="s1">):</span>
		<span class="s1">commands = self._commands</span>
		<span class="s1">commands = self.reorder_blend_args(commands</span><span class="s0">, </span><span class="s1">partial (var_model.getDeltas</span><span class="s0">, </span><span class="s1">round=self.round))</span>
		<span class="s0">if </span><span class="s1">optimize:</span>
			<span class="s1">commands = specializeCommands(</span>
						<span class="s1">commands</span><span class="s0">, </span><span class="s1">generalizeFirst=</span><span class="s0">False,</span>
						<span class="s1">maxstack=maxStackLimit)</span>
		<span class="s1">program = commandsToProgram(commands)</span>
		<span class="s1">charString = T2CharString(</span>
						<span class="s1">program=program</span><span class="s0">, </span><span class="s1">private=private</span><span class="s0">,</span>
						<span class="s1">globalSubrs=globalSubrs)</span>
		<span class="s0">return </span><span class="s1">charString</span>
</pre>
</body>
</html>