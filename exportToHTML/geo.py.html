<html>
<head>
<title>geo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
geo.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span>
<span class="s0">from </span><span class="s1">matplotlib.axes </span><span class="s0">import </span><span class="s1">Axes</span>
<span class="s0">import </span><span class="s1">matplotlib.axis </span><span class="s0">as </span><span class="s1">maxis</span>
<span class="s0">from </span><span class="s1">matplotlib.patches </span><span class="s0">import </span><span class="s1">Circle</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">import </span><span class="s1">matplotlib.spines </span><span class="s0">as </span><span class="s1">mspines</span>
<span class="s0">from </span><span class="s1">matplotlib.ticker </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Formatter</span><span class="s0">, </span><span class="s1">NullLocator</span><span class="s0">, </span><span class="s1">FixedLocator</span><span class="s0">, </span><span class="s1">NullFormatter)</span>
<span class="s0">from </span><span class="s1">matplotlib.transforms </span><span class="s0">import </span><span class="s1">Affine2D</span><span class="s0">, </span><span class="s1">BboxTransformTo</span><span class="s0">, </span><span class="s1">Transform</span>


<span class="s0">class </span><span class="s1">GeoAxes(Axes):</span>
    <span class="s2">&quot;&quot;&quot;An abstract base class for geographic projections.&quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">ThetaFormatter(Formatter):</span>
        <span class="s2">&quot;&quot;&quot; 
        Used to format the theta tick labels.  Converts the native 
        unit of radians into degrees and adds a degree symbol. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">round_to=</span><span class="s3">1.0</span><span class="s1">):</span>
            <span class="s1">self._round_to = round_to</span>

        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">pos=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s1">degrees = round(np.rad2deg(x) / self._round_to) * self._round_to</span>
            <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">degrees</span><span class="s0">:</span><span class="s4">0.0f</span><span class="s0">}\N{DEGREE SIGN}</span><span class="s4">&quot;</span>

    <span class="s1">RESOLUTION = </span><span class="s3">75</span>

    <span class="s0">def </span><span class="s1">_init_axis(self):</span>
        <span class="s1">self.xaxis = maxis.XAxis(self)</span>
        <span class="s1">self.yaxis = maxis.YAxis(self)</span>
        <span class="s5"># Do not register xaxis or yaxis with spines -- as done in</span>
        <span class="s5"># Axes._init_axis() -- until GeoAxes.xaxis.clear() works.</span>
        <span class="s5"># self.spines['geo'].register_axis(self.yaxis)</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().clear()</span>

        <span class="s1">self.set_longitude_grid(</span><span class="s3">30</span><span class="s1">)</span>
        <span class="s1">self.set_latitude_grid(</span><span class="s3">15</span><span class="s1">)</span>
        <span class="s1">self.set_longitude_grid_ends(</span><span class="s3">75</span><span class="s1">)</span>
        <span class="s1">self.xaxis.set_minor_locator(NullLocator())</span>
        <span class="s1">self.yaxis.set_minor_locator(NullLocator())</span>
        <span class="s1">self.xaxis.set_ticks_position(</span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">self.yaxis.set_ticks_position(</span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">self.yaxis.set_tick_params(label1On=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s5"># Why do we need to turn on yaxis tick labels, but</span>
        <span class="s5"># xaxis tick labels are already on?</span>

        <span class="s1">self.grid(mpl.rcParams[</span><span class="s4">'axes.grid'</span><span class="s1">])</span>

        <span class="s1">Axes.set_xlim(self</span><span class="s0">, </span><span class="s1">-np.pi</span><span class="s0">, </span><span class="s1">np.pi)</span>
        <span class="s1">Axes.set_ylim(self</span><span class="s0">, </span><span class="s1">-np.pi / </span><span class="s3">2.0</span><span class="s0">, </span><span class="s1">np.pi / </span><span class="s3">2.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_set_lim_and_transforms(self):</span>
        <span class="s5"># A (possibly non-linear) projection on the (already scaled) data</span>
        <span class="s1">self.transProjection = self._get_core_transform(self.RESOLUTION)</span>

        <span class="s1">self.transAffine = self._get_affine_transform()</span>

        <span class="s1">self.transAxes = BboxTransformTo(self.bbox)</span>

        <span class="s5"># The complete data transformation stack -- from data all the</span>
        <span class="s5"># way to display coordinates</span>
        <span class="s1">self.transData = \</span>
            <span class="s1">self.transProjection + \</span>
            <span class="s1">self.transAffine + \</span>
            <span class="s1">self.transAxes</span>

        <span class="s5"># This is the transform for longitude ticks.</span>
        <span class="s1">self._xaxis_pretransform = \</span>
            <span class="s1">Affine2D() \</span>
            <span class="s1">.scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">self._longitude_cap * </span><span class="s3">2</span><span class="s1">) \</span>
            <span class="s1">.translate(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-self._longitude_cap)</span>
        <span class="s1">self._xaxis_transform = \</span>
            <span class="s1">self._xaxis_pretransform + \</span>
            <span class="s1">self.transData</span>
        <span class="s1">self._xaxis_text1_transform = \</span>
            <span class="s1">Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) + \</span>
            <span class="s1">self.transData + \</span>
            <span class="s1">Affine2D().translate(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">self._xaxis_text2_transform = \</span>
            <span class="s1">Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) + \</span>
            <span class="s1">self.transData + \</span>
            <span class="s1">Affine2D().translate(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s5"># This is the transform for latitude ticks.</span>
        <span class="s1">yaxis_stretch = Affine2D().scale(np.pi * </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).translate(-np.pi</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">yaxis_space = Affine2D().scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.1</span><span class="s1">)</span>
        <span class="s1">self._yaxis_transform = \</span>
            <span class="s1">yaxis_stretch + \</span>
            <span class="s1">self.transData</span>
        <span class="s1">yaxis_text_base = \</span>
            <span class="s1">yaxis_stretch + \</span>
            <span class="s1">self.transProjection + \</span>
            <span class="s1">(yaxis_space +</span>
             <span class="s1">self.transAffine +</span>
             <span class="s1">self.transAxes)</span>
        <span class="s1">self._yaxis_text1_transform = \</span>
            <span class="s1">yaxis_text_base + \</span>
            <span class="s1">Affine2D().translate(-</span><span class="s3">8</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self._yaxis_text2_transform = \</span>
            <span class="s1">yaxis_text_base + \</span>
            <span class="s1">Affine2D().translate(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_affine_transform(self):</span>
        <span class="s1">transform = self._get_core_transform(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">xscale</span><span class="s0">, </span><span class="s1">_ = transform.transform((np.pi</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">yscale = transform.transform((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.pi/</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">Affine2D() \</span>
            <span class="s1">.scale(</span><span class="s3">0.5 </span><span class="s1">/ xscale</span><span class="s0">, </span><span class="s3">0.5 </span><span class="s1">/ yscale) \</span>
            <span class="s1">.translate(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'tick1'</span><span class="s0">, </span><span class="s4">'tick2'</span><span class="s0">, </span><span class="s4">'grid'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">which=which)</span>
        <span class="s0">return </span><span class="s1">self._xaxis_transform</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._xaxis_text1_transform</span><span class="s0">, </span><span class="s4">'bottom'</span><span class="s0">, </span><span class="s4">'center'</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._xaxis_text2_transform</span><span class="s0">, </span><span class="s4">'top'</span><span class="s0">, </span><span class="s4">'center'</span>

    <span class="s0">def </span><span class="s1">get_yaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'tick1'</span><span class="s0">, </span><span class="s4">'tick2'</span><span class="s0">, </span><span class="s4">'grid'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">which=which)</span>
        <span class="s0">return </span><span class="s1">self._yaxis_transform</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._yaxis_text1_transform</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'right'</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad):</span>
        <span class="s0">return </span><span class="s1">self._yaxis_text2_transform</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'left'</span>

    <span class="s0">def </span><span class="s1">_gen_axes_patch(self):</span>
        <span class="s0">return </span><span class="s1">Circle((</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_spines(self):</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s4">'geo'</span><span class="s1">: mspines.Spine.circular_spine(self</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)}</span>

    <span class="s0">def </span><span class="s1">set_yscale(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">args[</span><span class="s3">0</span><span class="s1">] != </span><span class="s4">'linear'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">set_xscale = set_yscale</span>

    <span class="s0">def </span><span class="s1">set_xlim(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Not supported. Please consider using Cartopy.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Changing axes limits of a geographic projection is &quot;</span>
                        <span class="s4">&quot;not supported.  Please consider using Cartopy.&quot;</span><span class="s1">)</span>

    <span class="s1">set_ylim = set_xlim</span>

    <span class="s0">def </span><span class="s1">format_coord(self</span><span class="s0">, </span><span class="s1">lon</span><span class="s0">, </span><span class="s1">lat):</span>
        <span class="s2">&quot;&quot;&quot;Return a format string formatting the coordinate.&quot;&quot;&quot;</span>
        <span class="s1">lon</span><span class="s0">, </span><span class="s1">lat = np.rad2deg([lon</span><span class="s0">, </span><span class="s1">lat])</span>
        <span class="s1">ns = </span><span class="s4">'N' </span><span class="s0">if </span><span class="s1">lat &gt;= </span><span class="s3">0.0 </span><span class="s0">else </span><span class="s4">'S'</span>
        <span class="s1">ew = </span><span class="s4">'E' </span><span class="s0">if </span><span class="s1">lon &gt;= </span><span class="s3">0.0 </span><span class="s0">else </span><span class="s4">'W'</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s4">'%f</span><span class="s0">\N{DEGREE SIGN}</span><span class="s4">%s, %f</span><span class="s0">\N{DEGREE SIGN}</span><span class="s4">%s'</span>
                <span class="s1">% (abs(lat)</span><span class="s0">, </span><span class="s1">ns</span><span class="s0">, </span><span class="s1">abs(lon)</span><span class="s0">, </span><span class="s1">ew))</span>

    <span class="s0">def </span><span class="s1">set_longitude_grid(self</span><span class="s0">, </span><span class="s1">degrees):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the number of degrees between each longitude grid. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Skip -180 and 180, which are the fixed limits.</span>
        <span class="s1">grid = np.arange(-</span><span class="s3">180 </span><span class="s1">+ degrees</span><span class="s0">, </span><span class="s3">180</span><span class="s0">, </span><span class="s1">degrees)</span>
        <span class="s1">self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))</span>
        <span class="s1">self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))</span>

    <span class="s0">def </span><span class="s1">set_latitude_grid(self</span><span class="s0">, </span><span class="s1">degrees):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the number of degrees between each latitude grid. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Skip -90 and 90, which are the fixed limits.</span>
        <span class="s1">grid = np.arange(-</span><span class="s3">90 </span><span class="s1">+ degrees</span><span class="s0">, </span><span class="s3">90</span><span class="s0">, </span><span class="s1">degrees)</span>
        <span class="s1">self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))</span>
        <span class="s1">self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))</span>

    <span class="s0">def </span><span class="s1">set_longitude_grid_ends(self</span><span class="s0">, </span><span class="s1">degrees):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the latitude(s) at which to stop drawing the longitude grids. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._longitude_cap = np.deg2rad(degrees)</span>
        <span class="s1">self._xaxis_pretransform \</span>
            <span class="s1">.clear() \</span>
            <span class="s1">.scale(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">self._longitude_cap * </span><span class="s3">2.0</span><span class="s1">) \</span>
            <span class="s1">.translate(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">-self._longitude_cap)</span>

    <span class="s0">def </span><span class="s1">get_data_ratio(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the aspect ratio of the data itself.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s3">1.0</span>

    <span class="s5">### Interactive panning</span>

    <span class="s0">def </span><span class="s1">can_zoom(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports the zoom box button functionality. 
 
        This Axes object does not support interactive zoom box. 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">can_pan(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports the pan/zoom button functionality. 
 
        This Axes object does not support interactive pan/zoom. 
        &quot;&quot;&quot;</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">start_pan(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">button):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">end_pan(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">drag_pan(self</span><span class="s0">, </span><span class="s1">button</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">_GeoTransform(Transform):</span>
    <span class="s5"># Factoring out some common functionality.</span>
    <span class="s1">input_dims = output_dims = </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">resolution):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a new geographical transform. 
 
        Resolution is the number of steps to interpolate between each input 
        line segment to approximate its path in curved space. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._resolution = resolution</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s4">&quot;{}({})&quot;</span><span class="s1">.format(type(self).__name__</span><span class="s0">, </span><span class="s1">self._resolution)</span>

    <span class="s0">def </span><span class="s1">transform_path_non_affine(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">ipath = path.interpolated(self._resolution)</span>
        <span class="s0">return </span><span class="s1">Path(self.transform(ipath.vertices)</span><span class="s0">, </span><span class="s1">ipath.codes)</span>


<span class="s0">class </span><span class="s1">AitoffAxes(GeoAxes):</span>
    <span class="s1">name = </span><span class="s4">'aitoff'</span>

    <span class="s0">class </span><span class="s1">AitoffTransform(_GeoTransform):</span>
        <span class="s2">&quot;&quot;&quot;The base Aitoff transform.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">ll):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s0">, </span><span class="s1">latitude = ll.T</span>

            <span class="s5"># Pre-compute some values</span>
            <span class="s1">half_long = longitude / </span><span class="s3">2.0</span>
            <span class="s1">cos_latitude = np.cos(latitude)</span>

            <span class="s1">alpha = np.arccos(cos_latitude * np.cos(half_long))</span>
            <span class="s1">sinc_alpha = np.sinc(alpha / np.pi)  </span><span class="s5"># np.sinc is sin(pi*x)/(pi*x).</span>

            <span class="s1">x = (cos_latitude * np.sin(half_long)) / sinc_alpha</span>
            <span class="s1">y = np.sin(latitude) / sinc_alpha</span>
            <span class="s0">return </span><span class="s1">np.column_stack([x</span><span class="s0">, </span><span class="s1">y])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">AitoffAxes.InvertedAitoffTransform(self._resolution)</span>

    <span class="s0">class </span><span class="s1">InvertedAitoffTransform(_GeoTransform):</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">xy):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s5"># MGDTODO: Math is hard ;(</span>
            <span class="s0">return </span><span class="s1">np.full_like(xy</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">AitoffAxes.AitoffTransform(self._resolution)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._longitude_cap = np.pi / </span><span class="s3">2.0</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_aspect(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">self.clear()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform(self</span><span class="s0">, </span><span class="s1">resolution):</span>
        <span class="s0">return </span><span class="s1">self.AitoffTransform(resolution)</span>


<span class="s0">class </span><span class="s1">HammerAxes(GeoAxes):</span>
    <span class="s1">name = </span><span class="s4">'hammer'</span>

    <span class="s0">class </span><span class="s1">HammerTransform(_GeoTransform):</span>
        <span class="s2">&quot;&quot;&quot;The base Hammer transform.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">ll):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s0">, </span><span class="s1">latitude = ll.T</span>
            <span class="s1">half_long = longitude / </span><span class="s3">2.0</span>
            <span class="s1">cos_latitude = np.cos(latitude)</span>
            <span class="s1">sqrt2 = np.sqrt(</span><span class="s3">2.0</span><span class="s1">)</span>
            <span class="s1">alpha = np.sqrt(</span><span class="s3">1.0 </span><span class="s1">+ cos_latitude * np.cos(half_long))</span>
            <span class="s1">x = (</span><span class="s3">2.0 </span><span class="s1">* sqrt2) * (cos_latitude * np.sin(half_long)) / alpha</span>
            <span class="s1">y = (sqrt2 * np.sin(latitude)) / alpha</span>
            <span class="s0">return </span><span class="s1">np.column_stack([x</span><span class="s0">, </span><span class="s1">y])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">HammerAxes.InvertedHammerTransform(self._resolution)</span>

    <span class="s0">class </span><span class="s1">InvertedHammerTransform(_GeoTransform):</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">xy):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = xy.T</span>
            <span class="s1">z = np.sqrt(</span><span class="s3">1 </span><span class="s1">- (x / </span><span class="s3">4</span><span class="s1">) ** </span><span class="s3">2 </span><span class="s1">- (y / </span><span class="s3">2</span><span class="s1">) ** </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">longitude = </span><span class="s3">2 </span><span class="s1">* np.arctan((z * x) / (</span><span class="s3">2 </span><span class="s1">* (</span><span class="s3">2 </span><span class="s1">* z ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">)))</span>
            <span class="s1">latitude = np.arcsin(y*z)</span>
            <span class="s0">return </span><span class="s1">np.column_stack([longitude</span><span class="s0">, </span><span class="s1">latitude])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">HammerAxes.HammerTransform(self._resolution)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._longitude_cap = np.pi / </span><span class="s3">2.0</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_aspect(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">self.clear()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform(self</span><span class="s0">, </span><span class="s1">resolution):</span>
        <span class="s0">return </span><span class="s1">self.HammerTransform(resolution)</span>


<span class="s0">class </span><span class="s1">MollweideAxes(GeoAxes):</span>
    <span class="s1">name = </span><span class="s4">'mollweide'</span>

    <span class="s0">class </span><span class="s1">MollweideTransform(_GeoTransform):</span>
        <span class="s2">&quot;&quot;&quot;The base Mollweide transform.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">ll):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">def </span><span class="s1">d(theta):</span>
                <span class="s1">delta = (-(theta + np.sin(theta) - pi_sin_l)</span>
                         <span class="s1">/ (</span><span class="s3">1 </span><span class="s1">+ np.cos(theta)))</span>
                <span class="s0">return </span><span class="s1">delta</span><span class="s0">, </span><span class="s1">np.abs(delta) &gt; </span><span class="s3">0.001</span>

            <span class="s1">longitude</span><span class="s0">, </span><span class="s1">latitude = ll.T</span>

            <span class="s1">clat = np.pi/</span><span class="s3">2 </span><span class="s1">- np.abs(latitude)</span>
            <span class="s1">ihigh = clat &lt; </span><span class="s3">0.087  </span><span class="s5"># within 5 degrees of the poles</span>
            <span class="s1">ilow = ~ihigh</span>
            <span class="s1">aux = np.empty(latitude.shape</span><span class="s0">, </span><span class="s1">dtype=float)</span>

            <span class="s0">if </span><span class="s1">ilow.any():  </span><span class="s5"># Newton-Raphson iteration</span>
                <span class="s1">pi_sin_l = np.pi * np.sin(latitude[ilow])</span>
                <span class="s1">theta = </span><span class="s3">2.0 </span><span class="s1">* latitude[ilow]</span>
                <span class="s1">delta</span><span class="s0">, </span><span class="s1">large_delta = d(theta)</span>
                <span class="s0">while </span><span class="s1">np.any(large_delta):</span>
                    <span class="s1">theta[large_delta] += delta[large_delta]</span>
                    <span class="s1">delta</span><span class="s0">, </span><span class="s1">large_delta = d(theta)</span>
                <span class="s1">aux[ilow] = theta / </span><span class="s3">2</span>

            <span class="s0">if </span><span class="s1">ihigh.any():  </span><span class="s5"># Taylor series-based approx. solution</span>
                <span class="s1">e = clat[ihigh]</span>
                <span class="s1">d = </span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">3 </span><span class="s1">* np.pi * e**</span><span class="s3">2</span><span class="s1">) ** (</span><span class="s3">1.0</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)</span>
                <span class="s1">aux[ihigh] = (np.pi/</span><span class="s3">2 </span><span class="s1">- d) * np.sign(latitude[ihigh])</span>

            <span class="s1">xy = np.empty(ll.shape</span><span class="s0">, </span><span class="s1">dtype=float)</span>
            <span class="s1">xy[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = (</span><span class="s3">2.0 </span><span class="s1">* np.sqrt(</span><span class="s3">2.0</span><span class="s1">) / np.pi) * longitude * np.cos(aux)</span>
            <span class="s1">xy[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] = np.sqrt(</span><span class="s3">2.0</span><span class="s1">) * np.sin(aux)</span>

            <span class="s0">return </span><span class="s1">xy</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">MollweideAxes.InvertedMollweideTransform(self._resolution)</span>

    <span class="s0">class </span><span class="s1">InvertedMollweideTransform(_GeoTransform):</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">xy):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = xy.T</span>
            <span class="s5"># from Equations (7, 8) of</span>
            <span class="s5"># https://mathworld.wolfram.com/MollweideProjection.html</span>
            <span class="s1">theta = np.arcsin(y / np.sqrt(</span><span class="s3">2</span><span class="s1">))</span>
            <span class="s1">longitude = (np.pi / (</span><span class="s3">2 </span><span class="s1">* np.sqrt(</span><span class="s3">2</span><span class="s1">))) * x / np.cos(theta)</span>
            <span class="s1">latitude = np.arcsin((</span><span class="s3">2 </span><span class="s1">* theta + np.sin(</span><span class="s3">2 </span><span class="s1">* theta)) / np.pi)</span>
            <span class="s0">return </span><span class="s1">np.column_stack([longitude</span><span class="s0">, </span><span class="s1">latitude])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">MollweideAxes.MollweideTransform(self._resolution)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._longitude_cap = np.pi / </span><span class="s3">2.0</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_aspect(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">self.clear()</span>

    <span class="s0">def </span><span class="s1">_get_core_transform(self</span><span class="s0">, </span><span class="s1">resolution):</span>
        <span class="s0">return </span><span class="s1">self.MollweideTransform(resolution)</span>


<span class="s0">class </span><span class="s1">LambertAxes(GeoAxes):</span>
    <span class="s1">name = </span><span class="s4">'lambert'</span>

    <span class="s0">class </span><span class="s1">LambertTransform(_GeoTransform):</span>
        <span class="s2">&quot;&quot;&quot;The base Lambert transform.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">center_longitude</span><span class="s0">, </span><span class="s1">center_latitude</span><span class="s0">, </span><span class="s1">resolution):</span>
            <span class="s2">&quot;&quot;&quot; 
            Create a new Lambert transform.  Resolution is the number of steps 
            to interpolate between each input line segment to approximate its 
            path in curved Lambert space. 
            &quot;&quot;&quot;</span>
            <span class="s1">_GeoTransform.__init__(self</span><span class="s0">, </span><span class="s1">resolution)</span>
            <span class="s1">self._center_longitude = center_longitude</span>
            <span class="s1">self._center_latitude = center_latitude</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">ll):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">longitude</span><span class="s0">, </span><span class="s1">latitude = ll.T</span>
            <span class="s1">clong = self._center_longitude</span>
            <span class="s1">clat = self._center_latitude</span>
            <span class="s1">cos_lat = np.cos(latitude)</span>
            <span class="s1">sin_lat = np.sin(latitude)</span>
            <span class="s1">diff_long = longitude - clong</span>
            <span class="s1">cos_diff_long = np.cos(diff_long)</span>

            <span class="s1">inner_k = np.maximum(  </span><span class="s5"># Prevent divide-by-zero problems</span>
                <span class="s3">1 </span><span class="s1">+ np.sin(clat)*sin_lat + np.cos(clat)*cos_lat*cos_diff_long</span><span class="s0">,</span>
                <span class="s3">1e-15</span><span class="s1">)</span>
            <span class="s1">k = np.sqrt(</span><span class="s3">2 </span><span class="s1">/ inner_k)</span>
            <span class="s1">x = k * cos_lat*np.sin(diff_long)</span>
            <span class="s1">y = k * (np.cos(clat)*sin_lat - np.sin(clat)*cos_lat*cos_diff_long)</span>

            <span class="s0">return </span><span class="s1">np.column_stack([x</span><span class="s0">, </span><span class="s1">y])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">LambertAxes.InvertedLambertTransform(</span>
                <span class="s1">self._center_longitude</span><span class="s0">,</span>
                <span class="s1">self._center_latitude</span><span class="s0">,</span>
                <span class="s1">self._resolution)</span>

    <span class="s0">class </span><span class="s1">InvertedLambertTransform(_GeoTransform):</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">center_longitude</span><span class="s0">, </span><span class="s1">center_latitude</span><span class="s0">, </span><span class="s1">resolution):</span>
            <span class="s1">_GeoTransform.__init__(self</span><span class="s0">, </span><span class="s1">resolution)</span>
            <span class="s1">self._center_longitude = center_longitude</span>
            <span class="s1">self._center_latitude = center_latitude</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">xy):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = xy.T</span>
            <span class="s1">clong = self._center_longitude</span>
            <span class="s1">clat = self._center_latitude</span>
            <span class="s1">p = np.maximum(np.hypot(x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s3">1e-9</span><span class="s1">)</span>
            <span class="s1">c = </span><span class="s3">2 </span><span class="s1">* np.arcsin(</span><span class="s3">0.5 </span><span class="s1">* p)</span>
            <span class="s1">sin_c = np.sin(c)</span>
            <span class="s1">cos_c = np.cos(c)</span>

            <span class="s1">latitude = np.arcsin(cos_c*np.sin(clat) +</span>
                                 <span class="s1">((y*sin_c*np.cos(clat)) / p))</span>
            <span class="s1">longitude = clong + np.arctan(</span>
                <span class="s1">(x*sin_c) / (p*np.cos(clat)*cos_c - y*np.sin(clat)*sin_c))</span>

            <span class="s0">return </span><span class="s1">np.column_stack([longitude</span><span class="s0">, </span><span class="s1">latitude])</span>

        <span class="s0">def </span><span class="s1">inverted(self):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s0">return </span><span class="s1">LambertAxes.LambertTransform(</span>
                <span class="s1">self._center_longitude</span><span class="s0">,</span>
                <span class="s1">self._center_latitude</span><span class="s0">,</span>
                <span class="s1">self._resolution)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">center_longitude=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">center_latitude=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._longitude_cap = np.pi / </span><span class="s3">2</span>
        <span class="s1">self._center_longitude = center_longitude</span>
        <span class="s1">self._center_latitude = center_latitude</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
        <span class="s1">self.clear()</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().clear()</span>
        <span class="s1">self.yaxis.set_major_formatter(NullFormatter())</span>

    <span class="s0">def </span><span class="s1">_get_core_transform(self</span><span class="s0">, </span><span class="s1">resolution):</span>
        <span class="s0">return </span><span class="s1">self.LambertTransform(</span>
            <span class="s1">self._center_longitude</span><span class="s0">,</span>
            <span class="s1">self._center_latitude</span><span class="s0">,</span>
            <span class="s1">resolution)</span>

    <span class="s0">def </span><span class="s1">_get_affine_transform(self):</span>
        <span class="s0">return </span><span class="s1">Affine2D() \</span>
            <span class="s1">.scale(</span><span class="s3">0.25</span><span class="s1">) \</span>
            <span class="s1">.translate(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">)</span>
</pre>
</body>
</html>