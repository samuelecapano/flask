<html>
<head>
<title>ticker.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ticker.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tick locating and formatting 
============================ 
 
This module contains classes for configuring tick locating and formatting. 
Generic tick locators and formatters are provided, as well as domain specific 
custom ones. 
 
Although the locators know nothing about major or minor ticks, they are used 
by the Axis class to support major and minor tick locating and formatting. 
 
Tick locating 
------------- 
 
The Locator class is the base class for all tick locators. The locators 
handle autoscaling of the view limits based on the data limits, and the 
choosing of tick locations. A useful semi-automatic tick locator is 
`MultipleLocator`. It is initialized with a base, e.g., 10, and it picks 
axis limits and ticks that are multiples of that base. 
 
The Locator subclasses defined here are: 
 
======================= ======================================================= 
`AutoLocator`           `MaxNLocator` with simple defaults. This is the default 
                        tick locator for most plotting. 
`MaxNLocator`           Finds up to a max number of intervals with ticks at 
                        nice locations. 
`LinearLocator`         Space ticks evenly from min to max. 
`LogLocator`            Space ticks logarithmically from min to max. 
`MultipleLocator`       Ticks and range are a multiple of base; either integer 
                        or float. 
`FixedLocator`          Tick locations are fixed. 
`IndexLocator`          Locator for index plots (e.g., where 
                        ``x = range(len(y))``). 
`NullLocator`           No ticks. 
`SymmetricalLogLocator` Locator for use with the symlog norm; works like 
                        `LogLocator` for the part outside of the threshold and 
                        adds 0 if inside the limits. 
`AsinhLocator`          Locator for use with the asinh norm, attempting to 
                        space ticks approximately uniformly. 
`LogitLocator`          Locator for logit scaling. 
`AutoMinorLocator`      Locator for minor ticks when the axis is linear and the 
                        major ticks are uniformly spaced. Subdivides the major 
                        tick interval into a specified number of minor 
                        intervals, defaulting to 4 or 5 depending on the major 
                        interval. 
======================= ======================================================= 
 
There are a number of locators specialized for date locations - see 
the :mod:`.dates` module. 
 
You can define your own locator by deriving from Locator. You must 
override the ``__call__`` method, which returns a sequence of locations, 
and you will probably want to override the autoscale method to set the 
view limits from the data limits. 
 
If you want to override the default locator, use one of the above or a custom 
locator and pass it to the x- or y-axis instance. The relevant methods are:: 
 
  ax.xaxis.set_major_locator(xmajor_locator) 
  ax.xaxis.set_minor_locator(xminor_locator) 
  ax.yaxis.set_major_locator(ymajor_locator) 
  ax.yaxis.set_minor_locator(yminor_locator) 
 
The default minor locator is `NullLocator`, i.e., no minor ticks on by default. 
 
.. note:: 
    `Locator` instances should not be used with more than one 
    `~matplotlib.axis.Axis` or `~matplotlib.axes.Axes`. So instead of:: 
 
        locator = MultipleLocator(5) 
        ax.xaxis.set_major_locator(locator) 
        ax2.xaxis.set_major_locator(locator) 
 
    do the following instead:: 
 
        ax.xaxis.set_major_locator(MultipleLocator(5)) 
        ax2.xaxis.set_major_locator(MultipleLocator(5)) 
 
Tick formatting 
--------------- 
 
Tick formatting is controlled by classes derived from Formatter. The formatter 
operates on a single tick value and returns a string to the axis. 
 
========================= ===================================================== 
`NullFormatter`           No labels on the ticks. 
`FixedFormatter`          Set the strings manually for the labels. 
`FuncFormatter`           User defined function sets the labels. 
`StrMethodFormatter`      Use string `format` method. 
`FormatStrFormatter`      Use an old-style sprintf format string. 
`ScalarFormatter`         Default formatter for scalars: autopick the format 
                          string. 
`LogFormatter`            Formatter for log axes. 
`LogFormatterExponent`    Format values for log axis using 
                          ``exponent = log_base(value)``. 
`LogFormatterMathtext`    Format values for log axis using 
                          ``exponent = log_base(value)`` using Math text. 
`LogFormatterSciNotation` Format values for log axis using scientific notation. 
`LogitFormatter`          Probability formatter. 
`EngFormatter`            Format labels in engineering notation. 
`PercentFormatter`        Format labels as a percentage. 
========================= ===================================================== 
 
You can derive your own formatter from the Formatter base class by 
simply overriding the ``__call__`` method. The formatter class has 
access to the axis view and data limits. 
 
To control the major and minor tick label formats, use one of the 
following methods:: 
 
  ax.xaxis.set_major_formatter(xmajor_formatter) 
  ax.xaxis.set_minor_formatter(xminor_formatter) 
  ax.yaxis.set_major_formatter(ymajor_formatter) 
  ax.yaxis.set_minor_formatter(yminor_formatter) 
 
In addition to a `.Formatter` instance, `~.Axis.set_major_formatter` and 
`~.Axis.set_minor_formatter` also accept a ``str`` or function.  ``str`` input 
will be internally replaced with an autogenerated `.StrMethodFormatter` with 
the input ``str``. For function input, a `.FuncFormatter` with the input 
function will be generated and used. 
 
See :doc:`/gallery/ticks/major_minor_demo` for an example of setting major 
and minor ticks. See the :mod:`matplotlib.dates` module for more information 
and examples of using date locators and formatters. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">locale</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s1">__all__ = (</span><span class="s3">'TickHelper'</span><span class="s2">, </span><span class="s3">'Formatter'</span><span class="s2">, </span><span class="s3">'FixedFormatter'</span><span class="s2">,</span>
           <span class="s3">'NullFormatter'</span><span class="s2">, </span><span class="s3">'FuncFormatter'</span><span class="s2">, </span><span class="s3">'FormatStrFormatter'</span><span class="s2">,</span>
           <span class="s3">'StrMethodFormatter'</span><span class="s2">, </span><span class="s3">'ScalarFormatter'</span><span class="s2">, </span><span class="s3">'LogFormatter'</span><span class="s2">,</span>
           <span class="s3">'LogFormatterExponent'</span><span class="s2">, </span><span class="s3">'LogFormatterMathtext'</span><span class="s2">,</span>
           <span class="s3">'LogFormatterSciNotation'</span><span class="s2">,</span>
           <span class="s3">'LogitFormatter'</span><span class="s2">, </span><span class="s3">'EngFormatter'</span><span class="s2">, </span><span class="s3">'PercentFormatter'</span><span class="s2">,</span>
           <span class="s3">'Locator'</span><span class="s2">, </span><span class="s3">'IndexLocator'</span><span class="s2">, </span><span class="s3">'FixedLocator'</span><span class="s2">, </span><span class="s3">'NullLocator'</span><span class="s2">,</span>
           <span class="s3">'LinearLocator'</span><span class="s2">, </span><span class="s3">'LogLocator'</span><span class="s2">, </span><span class="s3">'AutoLocator'</span><span class="s2">,</span>
           <span class="s3">'MultipleLocator'</span><span class="s2">, </span><span class="s3">'MaxNLocator'</span><span class="s2">, </span><span class="s3">'AutoMinorLocator'</span><span class="s2">,</span>
           <span class="s3">'SymmetricalLogLocator'</span><span class="s2">, </span><span class="s3">'AsinhLocator'</span><span class="s2">, </span><span class="s3">'LogitLocator'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_DummyAxis:</span>
    <span class="s1">__name__ = </span><span class="s3">&quot;dummy&quot;</span>

    <span class="s4"># Once the deprecation elapses, replace dataLim and viewLim by plain</span>
    <span class="s4"># _view_interval and _data_interval private tuples.</span>
    <span class="s1">dataLim = _api.deprecate_privatize_attribute(</span>
        <span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_data_interval() and set_data_interval()&quot;</span><span class="s1">)</span>
    <span class="s1">viewLim = _api.deprecate_privatize_attribute(</span>
        <span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_view_interval() and set_view_interval()&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">minpos=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">self._dataLim = mtransforms.Bbox.unit()</span>
        <span class="s1">self._viewLim = mtransforms.Bbox.unit()</span>
        <span class="s1">self._minpos = minpos</span>

    <span class="s2">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s2">return </span><span class="s1">self._viewLim.intervalx</span>

    <span class="s2">def </span><span class="s1">set_view_interval(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">self._viewLim.intervalx = vmin</span><span class="s2">, </span><span class="s1">vmax</span>

    <span class="s2">def </span><span class="s1">get_minpos(self):</span>
        <span class="s2">return </span><span class="s1">self._minpos</span>

    <span class="s2">def </span><span class="s1">get_data_interval(self):</span>
        <span class="s2">return </span><span class="s1">self._dataLim.intervalx</span>

    <span class="s2">def </span><span class="s1">set_data_interval(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">self._dataLim.intervalx = vmin</span><span class="s2">, </span><span class="s1">vmax</span>

    <span class="s2">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s4"># Just use the long-standing default of nbins==9</span>
        <span class="s2">return </span><span class="s5">9</span>


<span class="s2">class </span><span class="s1">TickHelper:</span>
    <span class="s1">axis = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">set_axis(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s1">self.axis = axis</span>

    <span class="s2">def </span><span class="s1">create_dummy_axis(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.axis = _DummyAxis(**kwargs)</span>


<span class="s2">class </span><span class="s1">Formatter(TickHelper):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a string based on a tick value and location. 
    &quot;&quot;&quot;</span>
    <span class="s4"># some classes want to see all the locs to help format</span>
    <span class="s4"># individual ones</span>
    <span class="s1">locs = []</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the format for tick value *x* at position pos. 
        ``pos=None`` indicates an unspecified location. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">format_ticks(self</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot;Return the tick labels for all the ticks at once.&quot;&quot;&quot;</span>
        <span class="s1">self.set_locs(values)</span>
        <span class="s2">return </span><span class="s1">[self(value</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">enumerate(values)]</span>

    <span class="s2">def </span><span class="s1">format_data(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the full string representation of the value with the 
        position unspecified. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__call__(value)</span>

    <span class="s2">def </span><span class="s1">format_data_short(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a short string version of the tick value. 
 
        Defaults to the position-independent long value. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.format_data(value)</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s2">return </span><span class="s3">''</span>

    <span class="s2">def </span><span class="s1">set_locs(self</span><span class="s2">, </span><span class="s1">locs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the locations of the ticks. 
 
        This method is called before computing the tick labels because some 
        formatters need to know all tick locations to do so. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.locs = locs</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">fix_minus(s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Some classes may want to replace a hyphen for minus with the proper 
        Unicode symbol (U+2212) for typographical correctness.  This is a 
        helper method to perform such a replacement when it is enabled via 
        :rc:`axes.unicode_minus`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(s.replace(</span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\N{MINUS SIGN}</span><span class="s3">'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.unicode_minus'</span><span class="s1">]</span>
                <span class="s2">else </span><span class="s1">s)</span>

    <span class="s2">def </span><span class="s1">_set_locator(self</span><span class="s2">, </span><span class="s1">locator):</span>
        <span class="s0">&quot;&quot;&quot;Subclasses may want to override this to set a locator.&quot;&quot;&quot;</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">NullFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot;Always return the empty string.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">return </span><span class="s3">''</span>


<span class="s2">class </span><span class="s1">FixedFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return fixed strings for tick labels based only on position, not value. 
 
    .. note:: 
        `.FixedFormatter` should only be used together with `.FixedLocator`. 
        Otherwise, the labels may end up in unexpected positions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">seq):</span>
        <span class="s0">&quot;&quot;&quot;Set the sequence *seq* of strings that will be used for labels.&quot;&quot;&quot;</span>
        <span class="s1">self.seq = seq</span>
        <span class="s1">self.offset_string = </span><span class="s3">''</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the label that matches the position, regardless of the value. 
 
        For positions ``pos &lt; len(seq)``, return ``seq[i]`` regardless of 
        *x*. Otherwise return empty string. ``seq`` is the sequence of 
        strings that this object was initialized with. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">pos </span><span class="s2">is None or </span><span class="s1">pos &gt;= len(self.seq):</span>
            <span class="s2">return </span><span class="s3">''</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.seq[pos]</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s2">return </span><span class="s1">self.offset_string</span>

    <span class="s2">def </span><span class="s1">set_offset_string(self</span><span class="s2">, </span><span class="s1">ofs):</span>
        <span class="s1">self.offset_string = ofs</span>


<span class="s2">class </span><span class="s1">FuncFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Use a user-defined function for formatting. 
 
    The function should take in two inputs (a tick value ``x`` and a 
    position ``pos``), and return a string containing the corresponding 
    tick label. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.offset_string = </span><span class="s3">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the value of the user defined function. 
 
        *x* and *pos* are passed through as-is. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.func(x</span><span class="s2">, </span><span class="s1">pos)</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s2">return </span><span class="s1">self.offset_string</span>

    <span class="s2">def </span><span class="s1">set_offset_string(self</span><span class="s2">, </span><span class="s1">ofs):</span>
        <span class="s1">self.offset_string = ofs</span>


<span class="s2">class </span><span class="s1">FormatStrFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Use an old-style ('%' operator) format string to format the tick. 
 
    The format string should have a single variable format (%) in it. 
    It will be applied to the value (not the position) of the tick. 
 
    Negative numeric values will use a dash, not a Unicode minus; use mathtext 
    to get a Unicode minus by wrapping the format specifier with $ (e.g. 
    &quot;$%g$&quot;). 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s1">self.fmt = fmt</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the formatted label string. 
 
        Only the value *x* is formatted. The position is ignored. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fmt % x</span>


<span class="s2">class </span><span class="s1">StrMethodFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Use a new-style format string (as used by `str.format`) to format the tick. 
 
    The field used for the tick value must be labeled *x* and the field used 
    for the tick position must be labeled *pos*. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s1">self.fmt = fmt</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the formatted label string. 
 
        *x* and *pos* are passed to `str.format` as keyword arguments 
        with those exact names. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fmt.format(x=x</span><span class="s2">, </span><span class="s1">pos=pos)</span>


<span class="s2">class </span><span class="s1">ScalarFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format tick values as a number. 
 
    Parameters 
    ---------- 
    useOffset : bool or float, default: :rc:`axes.formatter.useoffset` 
        Whether to use offset notation. See `.set_useOffset`. 
    useMathText : bool, default: :rc:`axes.formatter.use_mathtext` 
        Whether to use fancy math formatting. See `.set_useMathText`. 
    useLocale : bool, default: :rc:`axes.formatter.use_locale`. 
        Whether to use locale settings for decimal sign and positive sign. 
        See `.set_useLocale`. 
 
    Notes 
    ----- 
    In addition to the parameters above, the formatting of scientific vs. 
    floating point representation can be configured via `.set_scientific` 
    and `.set_powerlimits`). 
 
    **Offset notation and scientific notation** 
 
    Offset notation and scientific notation look quite similar at first sight. 
    Both split some information from the formatted tick values and display it 
    at the end of the axis. 
 
    - The scientific notation splits up the order of magnitude, i.e. a 
      multiplicative scaling factor, e.g. ``1e6``. 
 
    - The offset notation separates an additive constant, e.g. ``+1e6``. The 
      offset notation label is always prefixed with a ``+`` or ``-`` sign 
      and is thus distinguishable from the order of magnitude label. 
 
    The following plot with x limits ``1_000_000`` to ``1_000_010`` illustrates 
    the different formatting. Note the labels at the right edge of the x axis. 
 
    .. plot:: 
 
        lim = (1_000_000, 1_000_010) 
 
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, gridspec_kw={'hspace': 2}) 
        ax1.set(title='offset_notation', xlim=lim) 
        ax2.set(title='scientific notation', xlim=lim) 
        ax2.xaxis.get_major_formatter().set_useOffset(False) 
        ax3.set(title='floating point notation', xlim=lim) 
        ax3.xaxis.get_major_formatter().set_useOffset(False) 
        ax3.xaxis.get_major_formatter().set_scientific(False) 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">useOffset=</span><span class="s2">None, </span><span class="s1">useMathText=</span><span class="s2">None, </span><span class="s1">useLocale=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">useOffset </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">useOffset = mpl.rcParams[</span><span class="s3">'axes.formatter.useoffset'</span><span class="s1">]</span>
        <span class="s1">self._offset_threshold = \</span>
            <span class="s1">mpl.rcParams[</span><span class="s3">'axes.formatter.offset_threshold'</span><span class="s1">]</span>
        <span class="s1">self.set_useOffset(useOffset)</span>
        <span class="s1">self._usetex = mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">]</span>
        <span class="s1">self.set_useMathText(useMathText)</span>
        <span class="s1">self.orderOfMagnitude = </span><span class="s5">0</span>
        <span class="s1">self.format = </span><span class="s3">''</span>
        <span class="s1">self._scientific = </span><span class="s2">True</span>
        <span class="s1">self._powerlimits = mpl.rcParams[</span><span class="s3">'axes.formatter.limits'</span><span class="s1">]</span>
        <span class="s1">self.set_useLocale(useLocale)</span>

    <span class="s2">def </span><span class="s1">get_useOffset(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether automatic mode for offset notation is active. 
 
        This returns True if ``set_useOffset(True)``; it returns False if an 
        explicit offset was set, e.g. ``set_useOffset(1000)``. 
 
        See Also 
        -------- 
        ScalarFormatter.set_useOffset 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._useOffset</span>

    <span class="s2">def </span><span class="s1">set_useOffset(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether to use offset notation. 
 
        When formatting a set numbers whose value is large compared to their 
        range, the formatter can separate an additive constant. This can 
        shorten the formatted numbers so that they are less likely to overlap 
        when drawn on an axis. 
 
        Parameters 
        ---------- 
        val : bool or float 
            - If False, do not use offset notation. 
            - If True (=automatic mode), use offset notation if it can make 
              the residual numbers significantly shorter. The exact behavior 
              is controlled by :rc:`axes.formatter.offset_threshold`. 
            - If a number, force an offset of the given value. 
 
        Examples 
        -------- 
        With active offset notation, the values 
 
        ``100_000, 100_002, 100_004, 100_006, 100_008`` 
 
        will be formatted as ``0, 2, 4, 6, 8`` plus an offset ``+1e5``, which 
        is written to the edge of the axis. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">in </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">]:</span>
            <span class="s1">self.offset = </span><span class="s5">0</span>
            <span class="s1">self._useOffset = val</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._useOffset = </span><span class="s2">False</span>
            <span class="s1">self.offset = val</span>

    <span class="s1">useOffset = property(fget=get_useOffset</span><span class="s2">, </span><span class="s1">fset=set_useOffset)</span>

    <span class="s2">def </span><span class="s1">get_useLocale(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether locale settings are used for formatting. 
 
        See Also 
        -------- 
        ScalarFormatter.set_useLocale 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._useLocale</span>

    <span class="s2">def </span><span class="s1">set_useLocale(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether to use locale settings for decimal sign and positive sign. 
 
        Parameters 
        ---------- 
        val : bool or None 
            *None* resets to :rc:`axes.formatter.use_locale`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._useLocale = mpl.rcParams[</span><span class="s3">'axes.formatter.use_locale'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._useLocale = val</span>

    <span class="s1">useLocale = property(fget=get_useLocale</span><span class="s2">, </span><span class="s1">fset=set_useLocale)</span>

    <span class="s2">def </span><span class="s1">_format_maybe_minus_and_locale(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s0">&quot;&quot;&quot; 
        Format *arg* with *fmt*, applying Unicode minus and locale if desired. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fix_minus(locale.format_string(fmt</span><span class="s2">, </span><span class="s1">(arg</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)</span>
                              <span class="s2">if </span><span class="s1">self._useLocale </span><span class="s2">else </span><span class="s1">fmt % arg)</span>

    <span class="s2">def </span><span class="s1">get_useMathText(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether to use fancy math formatting. 
 
        See Also 
        -------- 
        ScalarFormatter.set_useMathText 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._useMathText</span>

    <span class="s2">def </span><span class="s1">set_useMathText(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set whether to use fancy math formatting. 
 
        If active, scientific notation is formatted as :math:`1.2 \times 10^3`. 
 
        Parameters 
        ---------- 
        val : bool or None 
            *None* resets to :rc:`axes.formatter.use_mathtext`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._useMathText = mpl.rcParams[</span><span class="s3">'axes.formatter.use_mathtext'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self._useMathText </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">font_manager</span>
                    <span class="s1">ufont = font_manager.findfont(</span>
                        <span class="s1">font_manager.FontProperties(</span>
                            <span class="s1">mpl.rcParams[</span><span class="s3">&quot;font.family&quot;</span><span class="s1">]</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">fallback_to_default=</span><span class="s2">False,</span>
                    <span class="s1">)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s1">ufont = </span><span class="s2">None</span>

                <span class="s2">if </span><span class="s1">ufont == str(cbook._get_data_path(</span><span class="s3">&quot;fonts/ttf/cmr10.ttf&quot;</span><span class="s1">)):</span>
                    <span class="s1">_api.warn_external(</span>
                        <span class="s3">&quot;cmr10 font should ideally be used with &quot;</span>
                        <span class="s3">&quot;mathtext, set axes.formatter.use_mathtext to True&quot;</span>
                    <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._useMathText = val</span>

    <span class="s1">useMathText = property(fget=get_useMathText</span><span class="s2">, </span><span class="s1">fset=set_useMathText)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the format for tick value *x* at position *pos*. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.locs) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">''</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xp = (x - self.offset) / (</span><span class="s5">10. </span><span class="s1">** self.orderOfMagnitude)</span>
            <span class="s2">if </span><span class="s1">abs(xp) &lt; </span><span class="s5">1e-8</span><span class="s1">:</span>
                <span class="s1">xp = </span><span class="s5">0</span>
            <span class="s2">return </span><span class="s1">self._format_maybe_minus_and_locale(self.format</span><span class="s2">, </span><span class="s1">xp)</span>

    <span class="s2">def </span><span class="s1">set_scientific(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Turn scientific notation on or off. 
 
        See Also 
        -------- 
        ScalarFormatter.set_powerlimits 
        &quot;&quot;&quot;</span>
        <span class="s1">self._scientific = bool(b)</span>

    <span class="s2">def </span><span class="s1">set_powerlimits(self</span><span class="s2">, </span><span class="s1">lims):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set size thresholds for scientific notation. 
 
        Parameters 
        ---------- 
        lims : (int, int) 
            A tuple *(min_exp, max_exp)* containing the powers of 10 that 
            determine the switchover threshold. For a number representable as 
            :math:`a \times 10^\mathrm{exp}` with :math:`1 &lt;= |a| &lt; 10`, 
            scientific notation will be used if ``exp &lt;= min_exp`` or 
            ``exp &gt;= max_exp``. 
 
            The default limits are controlled by :rc:`axes.formatter.limits`. 
 
            In particular numbers with *exp* equal to the thresholds are 
            written in scientific notation. 
 
            Typically, *min_exp* will be negative and *max_exp* will be 
            positive. 
 
            For example, ``formatter.set_powerlimits((-3, 4))`` will provide 
            the following formatting: 
            :math:`1 \times 10^{-3}, 9.9 \times 10^{-3}, 0.01,` 
            :math:`9999, 1 \times 10^4`. 
 
        See Also 
        -------- 
        ScalarFormatter.set_scientific 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(lims) != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'lims' must be a sequence of length 2&quot;</span><span class="s1">)</span>
        <span class="s1">self._powerlimits = lims</span>

    <span class="s2">def </span><span class="s1">format_data_short(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">is </span><span class="s1">np.ma.masked:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Integral):</span>
            <span class="s1">fmt = </span><span class="s3">&quot;%d&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">getattr(self.axis</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">) </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;xaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;yaxis&quot;</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">self.axis.__name__ == </span><span class="s3">&quot;xaxis&quot;</span><span class="s1">:</span>
                    <span class="s1">axis_trf = self.axis.axes.get_xaxis_transform()</span>
                    <span class="s1">axis_inv_trf = axis_trf.inverted()</span>
                    <span class="s1">screen_xy = axis_trf.transform((value</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
                    <span class="s1">neighbor_values = axis_inv_trf.transform(</span>
                        <span class="s1">screen_xy + [[-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[+</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:  </span><span class="s4"># yaxis:</span>
                    <span class="s1">axis_trf = self.axis.axes.get_yaxis_transform()</span>
                    <span class="s1">axis_inv_trf = axis_trf.inverted()</span>
                    <span class="s1">screen_xy = axis_trf.transform((</span><span class="s5">0</span><span class="s2">, </span><span class="s1">value))</span>
                    <span class="s1">neighbor_values = axis_inv_trf.transform(</span>
                        <span class="s1">screen_xy + [[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">+</span><span class="s5">1</span><span class="s1">]])[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">delta = abs(neighbor_values - value).max()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Rough approximation: no more than 1e4 divisions.</span>
                <span class="s1">a</span><span class="s2">, </span><span class="s1">b = self.axis.get_view_interval()</span>
                <span class="s1">delta = (b - a) / </span><span class="s5">1e4</span>
            <span class="s1">fmt = </span><span class="s3">&quot;%-#.{}g&quot;</span><span class="s1">.format(cbook._g_sig_digits(value</span><span class="s2">, </span><span class="s1">delta))</span>
        <span class="s2">return </span><span class="s1">self._format_maybe_minus_and_locale(fmt</span><span class="s2">, </span><span class="s1">value)</span>

    <span class="s2">def </span><span class="s1">format_data(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">e = math.floor(math.log10(abs(value)))</span>
        <span class="s1">s = round(value / </span><span class="s5">10</span><span class="s1">**e</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">exponent = self._format_maybe_minus_and_locale(</span><span class="s3">&quot;%d&quot;</span><span class="s2">, </span><span class="s1">e)</span>
        <span class="s1">significand = self._format_maybe_minus_and_locale(</span>
            <span class="s3">&quot;%d&quot; </span><span class="s2">if </span><span class="s1">s % </span><span class="s5">1 </span><span class="s1">== </span><span class="s5">0 </span><span class="s2">else </span><span class="s3">&quot;%1.10g&quot;</span><span class="s2">, </span><span class="s1">s)</span>
        <span class="s2">if </span><span class="s1">e == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">significand</span>
        <span class="s2">elif </span><span class="s1">self._useMathText </span><span class="s2">or </span><span class="s1">self._usetex:</span>
            <span class="s1">exponent = </span><span class="s3">&quot;10^{%s}&quot; </span><span class="s1">% exponent</span>
            <span class="s2">return </span><span class="s1">(exponent </span><span class="s2">if </span><span class="s1">s == </span><span class="s5">1  </span><span class="s4"># reformat 1x10^y as 10^y</span>
                    <span class="s2">else </span><span class="s3">rf&quot;</span><span class="s2">{</span><span class="s1">significand</span><span class="s2">} </span><span class="s3">\times </span><span class="s2">{</span><span class="s1">exponent</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">significand</span><span class="s2">}</span><span class="s3">e</span><span class="s2">{</span><span class="s1">exponent</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return scientific notation, plus offset. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.locs) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">''</span>
        <span class="s1">s = </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">self.orderOfMagnitude </span><span class="s2">or </span><span class="s1">self.offset:</span>
            <span class="s1">offsetStr = </span><span class="s3">''</span>
            <span class="s1">sciNotStr = </span><span class="s3">''</span>
            <span class="s2">if </span><span class="s1">self.offset:</span>
                <span class="s1">offsetStr = self.format_data(self.offset)</span>
                <span class="s2">if </span><span class="s1">self.offset &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">offsetStr = </span><span class="s3">'+' </span><span class="s1">+ offsetStr</span>
            <span class="s2">if </span><span class="s1">self.orderOfMagnitude:</span>
                <span class="s2">if </span><span class="s1">self._usetex </span><span class="s2">or </span><span class="s1">self._useMathText:</span>
                    <span class="s1">sciNotStr = self.format_data(</span><span class="s5">10 </span><span class="s1">** self.orderOfMagnitude)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sciNotStr = </span><span class="s3">'1e%d' </span><span class="s1">% self.orderOfMagnitude</span>
            <span class="s2">if </span><span class="s1">self._useMathText </span><span class="s2">or </span><span class="s1">self._usetex:</span>
                <span class="s2">if </span><span class="s1">sciNotStr != </span><span class="s3">''</span><span class="s1">:</span>
                    <span class="s1">sciNotStr = </span><span class="s3">r'\times\mathdefault{%s}' </span><span class="s1">% sciNotStr</span>
                <span class="s1">s = </span><span class="s3">r'$%s\mathdefault{%s}$' </span><span class="s1">% (sciNotStr</span><span class="s2">, </span><span class="s1">offsetStr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s = </span><span class="s3">''</span><span class="s1">.join((sciNotStr</span><span class="s2">, </span><span class="s1">offsetStr))</span>

        <span class="s2">return </span><span class="s1">self.fix_minus(s)</span>

    <span class="s2">def </span><span class="s1">set_locs(self</span><span class="s2">, </span><span class="s1">locs):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">self.locs = locs</span>
        <span class="s2">if </span><span class="s1">len(self.locs) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._useOffset:</span>
                <span class="s1">self._compute_offset()</span>
            <span class="s1">self._set_order_of_magnitude()</span>
            <span class="s1">self._set_format()</span>

    <span class="s2">def </span><span class="s1">_compute_offset(self):</span>
        <span class="s1">locs = self.locs</span>
        <span class="s4"># Restrict to visible ticks.</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = sorted(self.axis.get_view_interval())</span>
        <span class="s1">locs = np.asarray(locs)</span>
        <span class="s1">locs = locs[(vmin &lt;= locs) &amp; (locs &lt;= vmax)]</span>
        <span class="s2">if not </span><span class="s1">len(locs):</span>
            <span class="s1">self.offset = </span><span class="s5">0</span>
            <span class="s2">return</span>
        <span class="s1">lmin</span><span class="s2">, </span><span class="s1">lmax = locs.min()</span><span class="s2">, </span><span class="s1">locs.max()</span>
        <span class="s4"># Only use offset if there are at least two ticks and every tick has</span>
        <span class="s4"># the same sign.</span>
        <span class="s2">if </span><span class="s1">lmin == lmax </span><span class="s2">or </span><span class="s1">lmin &lt;= </span><span class="s5">0 </span><span class="s1">&lt;= lmax:</span>
            <span class="s1">self.offset = </span><span class="s5">0</span>
            <span class="s2">return</span>
        <span class="s4"># min, max comparing absolute values (we want division to round towards</span>
        <span class="s4"># zero so we work on absolute values).</span>
        <span class="s1">abs_min</span><span class="s2">, </span><span class="s1">abs_max = sorted([abs(float(lmin))</span><span class="s2">, </span><span class="s1">abs(float(lmax))])</span>
        <span class="s1">sign = math.copysign(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">lmin)</span>
        <span class="s4"># What is the smallest power of ten such that abs_min and abs_max are</span>
        <span class="s4"># equal up to that precision?</span>
        <span class="s4"># Note: Internally using oom instead of 10 ** oom avoids some numerical</span>
        <span class="s4"># accuracy issues.</span>
        <span class="s1">oom_max = np.ceil(math.log10(abs_max))</span>
        <span class="s1">oom = </span><span class="s5">1 </span><span class="s1">+ next(oom </span><span class="s2">for </span><span class="s1">oom </span><span class="s2">in </span><span class="s1">itertools.count(oom_max</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
                       <span class="s2">if </span><span class="s1">abs_min // </span><span class="s5">10 </span><span class="s1">** oom != abs_max // </span><span class="s5">10 </span><span class="s1">** oom)</span>
        <span class="s2">if </span><span class="s1">(abs_max - abs_min) / </span><span class="s5">10 </span><span class="s1">** oom &lt;= </span><span class="s5">1e-2</span><span class="s1">:</span>
            <span class="s4"># Handle the case of straddling a multiple of a large power of ten</span>
            <span class="s4"># (relative to the span).</span>
            <span class="s4"># What is the smallest power of ten such that abs_min and abs_max</span>
            <span class="s4"># are no more than 1 apart at that precision?</span>
            <span class="s1">oom = </span><span class="s5">1 </span><span class="s1">+ next(oom </span><span class="s2">for </span><span class="s1">oom </span><span class="s2">in </span><span class="s1">itertools.count(oom_max</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
                           <span class="s2">if </span><span class="s1">abs_max // </span><span class="s5">10 </span><span class="s1">** oom - abs_min // </span><span class="s5">10 </span><span class="s1">** oom &gt; </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s4"># Only use offset if it saves at least _offset_threshold digits.</span>
        <span class="s1">n = self._offset_threshold - </span><span class="s5">1</span>
        <span class="s1">self.offset = (sign * (abs_max // </span><span class="s5">10 </span><span class="s1">** oom) * </span><span class="s5">10 </span><span class="s1">** oom</span>
                       <span class="s2">if </span><span class="s1">abs_max // </span><span class="s5">10 </span><span class="s1">** oom &gt;= </span><span class="s5">10</span><span class="s1">**n</span>
                       <span class="s2">else </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_set_order_of_magnitude(self):</span>
        <span class="s4"># if scientific notation is to be used, find the appropriate exponent</span>
        <span class="s4"># if using a numerical offset, find the exponent after applying the</span>
        <span class="s4"># offset. When lower power limit = upper &lt;&gt; 0, use provided exponent.</span>
        <span class="s2">if not </span><span class="s1">self._scientific:</span>
            <span class="s1">self.orderOfMagnitude = </span><span class="s5">0</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self._powerlimits[</span><span class="s5">0</span><span class="s1">] == self._powerlimits[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># fixed scaling when lower power limit = upper &lt;&gt; 0.</span>
            <span class="s1">self.orderOfMagnitude = self._powerlimits[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">return</span>
        <span class="s4"># restrict to visible ticks</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = sorted(self.axis.get_view_interval())</span>
        <span class="s1">locs = np.asarray(self.locs)</span>
        <span class="s1">locs = locs[(vmin &lt;= locs) &amp; (locs &lt;= vmax)]</span>
        <span class="s1">locs = np.abs(locs)</span>
        <span class="s2">if not </span><span class="s1">len(locs):</span>
            <span class="s1">self.orderOfMagnitude = </span><span class="s5">0</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self.offset:</span>
            <span class="s1">oom = math.floor(math.log10(vmax - vmin))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">val = locs.max()</span>
            <span class="s2">if </span><span class="s1">val == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">oom = </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">oom = math.floor(math.log10(val))</span>
        <span class="s2">if </span><span class="s1">oom &lt;= self._powerlimits[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">self.orderOfMagnitude = oom</span>
        <span class="s2">elif </span><span class="s1">oom &gt;= self._powerlimits[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">self.orderOfMagnitude = oom</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.orderOfMagnitude = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">_set_format(self):</span>
        <span class="s4"># set the format string to format all the ticklabels</span>
        <span class="s2">if </span><span class="s1">len(self.locs) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4"># Temporarily augment the locations with the axis end points.</span>
            <span class="s1">_locs = [*self.locs</span><span class="s2">, </span><span class="s1">*self.axis.get_view_interval()]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_locs = self.locs</span>
        <span class="s1">locs = (np.asarray(_locs) - self.offset) / </span><span class="s5">10. </span><span class="s1">** self.orderOfMagnitude</span>
        <span class="s1">loc_range = np.ptp(locs)</span>
        <span class="s4"># Curvilinear coordinates can yield two identical points.</span>
        <span class="s2">if </span><span class="s1">loc_range == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">loc_range = np.max(np.abs(locs))</span>
        <span class="s4"># Both points might be zero.</span>
        <span class="s2">if </span><span class="s1">loc_range == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">loc_range = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">len(self.locs) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4"># We needed the end points only for the loc_range calculation.</span>
            <span class="s1">locs = locs[:-</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">loc_range_oom = int(math.floor(math.log10(loc_range)))</span>
        <span class="s4"># first estimate:</span>
        <span class="s1">sigfigs = max(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3 </span><span class="s1">- loc_range_oom)</span>
        <span class="s4"># refined estimate:</span>
        <span class="s1">thresh = </span><span class="s5">1e-3 </span><span class="s1">* </span><span class="s5">10 </span><span class="s1">** loc_range_oom</span>
        <span class="s2">while </span><span class="s1">sigfigs &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">np.abs(locs - np.round(locs</span><span class="s2">, </span><span class="s1">decimals=sigfigs)).max() &lt; thresh:</span>
                <span class="s1">sigfigs -= </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s1">sigfigs += </span><span class="s5">1</span>
        <span class="s1">self.format = </span><span class="s3">f'%1.</span><span class="s2">{</span><span class="s1">sigfigs</span><span class="s2">}</span><span class="s3">f'</span>
        <span class="s2">if </span><span class="s1">self._usetex </span><span class="s2">or </span><span class="s1">self._useMathText:</span>
            <span class="s1">self.format = </span><span class="s3">r'$\mathdefault{%s}$' </span><span class="s1">% self.format</span>


<span class="s2">class </span><span class="s1">LogFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for formatting ticks on a log or symlog scale. 
 
    It may be instantiated directly, or subclassed. 
 
    Parameters 
    ---------- 
    base : float, default: 10. 
        Base of the logarithm used in all calculations. 
 
    labelOnlyBase : bool, default: False 
        If True, label ticks only at integer powers of base. 
        This is normally True for major ticks and False for 
        minor ticks. 
 
    minor_thresholds : (subset, all), default: (1, 0.4) 
        If labelOnlyBase is False, these two numbers control 
        the labeling of ticks that are not at integer powers of 
        base; normally these are the minor ticks. The controlling 
        parameter is the log of the axis data range.  In the typical 
        case where base is 10 it is the number of decades spanned 
        by the axis, so we can call it 'numdec'. If ``numdec &lt;= all``, 
        all minor ticks will be labeled.  If ``all &lt; numdec &lt;= subset``, 
        then only a subset of minor ticks will be labeled, so as to 
        avoid crowding. If ``numdec &gt; subset`` then no minor ticks will 
        be labeled. 
 
    linthresh : None or float, default: None 
        If a symmetric log scale is in use, its ``linthresh`` 
        parameter must be supplied here. 
 
    Notes 
    ----- 
    The `set_locs` method must be called to enable the subsetting 
    logic controlled by the ``minor_thresholds`` parameter. 
 
    In some cases such as the colorbar, there is no distinction between 
    major and minor ticks; the tick locations might be set manually, 
    or by a locator that puts ticks at integer powers of base and 
    at intermediate locations.  For this situation, disable the 
    minor_thresholds logic by using ``minor_thresholds=(np.inf, np.inf)``, 
    so that all ticks will be labeled. 
 
    To disable labeling of minor ticks when 'labelOnlyBase' is False, 
    use ``minor_thresholds=(0, 0)``.  This is the default for the 
    &quot;classic&quot; style. 
 
    Examples 
    -------- 
    To label a subset of minor ticks when the view limits span up 
    to 2 decades, and all of the ticks when zoomed in to 0.5 decades 
    or less, use ``minor_thresholds=(2, 0.5)``. 
 
    To label all minor ticks when the view limits span up to 1.5 
    decades, use ``minor_thresholds=(1.5, 1.5)``. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10.0</span><span class="s2">, </span><span class="s1">labelOnlyBase=</span><span class="s2">False,</span>
                 <span class="s1">minor_thresholds=</span><span class="s2">None,</span>
                 <span class="s1">linthresh=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">self.set_base(base)</span>
        <span class="s1">self.set_label_minor(labelOnlyBase)</span>
        <span class="s2">if </span><span class="s1">minor_thresholds </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
                <span class="s1">minor_thresholds = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">minor_thresholds = (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.4</span><span class="s1">)</span>
        <span class="s1">self.minor_thresholds = minor_thresholds</span>
        <span class="s1">self._sublabels = </span><span class="s2">None</span>
        <span class="s1">self._linthresh = linthresh</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'set_base()'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">base(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change the *base* for labeling. 
 
        .. warning:: 
           Should always match the base used for :class:`LogLocator` 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_base(base)</span>

    <span class="s2">def </span><span class="s1">set_base(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change the *base* for labeling. 
 
        .. warning:: 
           Should always match the base used for :class:`LogLocator` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._base = float(base)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'set_label_minor()'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">label_minor(self</span><span class="s2">, </span><span class="s1">labelOnlyBase):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch minor tick labeling on or off. 
 
        Parameters 
        ---------- 
        labelOnlyBase : bool 
            If True, label ticks only at integer powers of base. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_label_minor(labelOnlyBase)</span>

    <span class="s2">def </span><span class="s1">set_label_minor(self</span><span class="s2">, </span><span class="s1">labelOnlyBase):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch minor tick labeling on or off. 
 
        Parameters 
        ---------- 
        labelOnlyBase : bool 
            If True, label ticks only at integer powers of base. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.labelOnlyBase = labelOnlyBase</span>

    <span class="s2">def </span><span class="s1">set_locs(self</span><span class="s2">, </span><span class="s1">locs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Use axis view limits to control which ticks are labeled. 
 
        The *locs* parameter is ignored in the present algorithm. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">np.isinf(self.minor_thresholds[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">self._sublabels = </span><span class="s2">None</span>
            <span class="s2">return</span>

        <span class="s4"># Handle symlog case:</span>
        <span class="s1">linthresh = self._linthresh</span>
        <span class="s2">if </span><span class="s1">linthresh </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">linthresh = self.axis.get_transform().linthresh</span>
            <span class="s2">except </span><span class="s1">AttributeError:</span>
                <span class="s2">pass</span>

        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s2">if </span><span class="s1">linthresh </span><span class="s2">is None and </span><span class="s1">vmin &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># It's probably a colorbar with</span>
            <span class="s4"># a format kwarg setting a LogFormatter in the manner</span>
            <span class="s4"># that worked with 1.5.x, but that doesn't work now.</span>
            <span class="s1">self._sublabels = {</span><span class="s5">1</span><span class="s1">}  </span><span class="s4"># label powers of base</span>
            <span class="s2">return</span>

        <span class="s1">b = self._base</span>
        <span class="s2">if </span><span class="s1">linthresh </span><span class="s2">is not None</span><span class="s1">:  </span><span class="s4"># symlog</span>
            <span class="s4"># Only compute the number of decades in the logarithmic part of the</span>
            <span class="s4"># axis</span>
            <span class="s1">numdec = </span><span class="s5">0</span>
            <span class="s2">if </span><span class="s1">vmin &lt; -linthresh:</span>
                <span class="s1">rhs = min(vmax</span><span class="s2">, </span><span class="s1">-linthresh)</span>
                <span class="s1">numdec += math.log(vmin / rhs) / math.log(b)</span>
            <span class="s2">if </span><span class="s1">vmax &gt; linthresh:</span>
                <span class="s1">lhs = max(vmin</span><span class="s2">, </span><span class="s1">linthresh)</span>
                <span class="s1">numdec += math.log(vmax / lhs) / math.log(b)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vmin = math.log(vmin) / math.log(b)</span>
            <span class="s1">vmax = math.log(vmax) / math.log(b)</span>
            <span class="s1">numdec = abs(vmax - vmin)</span>

        <span class="s2">if </span><span class="s1">numdec &gt; self.minor_thresholds[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s4"># Label only bases</span>
            <span class="s1">self._sublabels = {</span><span class="s5">1</span><span class="s1">}</span>
        <span class="s2">elif </span><span class="s1">numdec &gt; self.minor_thresholds[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s4"># Add labels between bases at log-spaced coefficients;</span>
            <span class="s4"># include base powers in case the locations include</span>
            <span class="s4"># &quot;major&quot; and &quot;minor&quot; points, as in colorbar.</span>
            <span class="s1">c = np.geomspace(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">int(b)//</span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self._sublabels = set(np.round(c))</span>
            <span class="s4"># For base 10, this yields (1, 2, 3, 4, 6, 10).</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Label all integer multiples of base**n.</span>
            <span class="s1">self._sublabels = set(np.arange(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">b + </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_num_to_string(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">if </span><span class="s1">x &gt; </span><span class="s5">10000</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s3">'%1.0e' </span><span class="s1">% x</span>
        <span class="s2">elif </span><span class="s1">x &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s3">'%1.0e' </span><span class="s1">% x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = self._pprint_val(x</span><span class="s2">, </span><span class="s1">vmax - vmin)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">x == </span><span class="s5">0.0</span><span class="s1">:  </span><span class="s4"># Symlog</span>
            <span class="s2">return </span><span class="s3">'0'</span>

        <span class="s1">x = abs(x)</span>
        <span class="s1">b = self._base</span>
        <span class="s4"># only label the decades</span>
        <span class="s1">fx = math.log(x) / math.log(b)</span>
        <span class="s1">is_x_decade = _is_close_to_int(fx)</span>
        <span class="s1">exponent = round(fx) </span><span class="s2">if </span><span class="s1">is_x_decade </span><span class="s2">else </span><span class="s1">np.floor(fx)</span>
        <span class="s1">coeff = round(b ** (fx - exponent))</span>

        <span class="s2">if </span><span class="s1">self.labelOnlyBase </span><span class="s2">and not </span><span class="s1">is_x_decade:</span>
            <span class="s2">return </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">self._sublabels </span><span class="s2">is not None and </span><span class="s1">coeff </span><span class="s2">not in </span><span class="s1">self._sublabels:</span>
            <span class="s2">return </span><span class="s3">''</span>

        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">0.05</span><span class="s1">)</span>
        <span class="s1">s = self._num_to_string(x</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s2">return </span><span class="s1">self.fix_minus(s)</span>

    <span class="s2">def </span><span class="s1">format_data(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s2">, </span><span class="s1">labelOnlyBase=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">cbook.strip_math(self.__call__(value))</span>

    <span class="s2">def </span><span class="s1">format_data_short(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">return </span><span class="s3">'%-12g' </span><span class="s1">% value</span>

    <span class="s2">def </span><span class="s1">_pprint_val(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d):</span>
        <span class="s4"># If the number is not too big and it's an int, format it as an int.</span>
        <span class="s2">if </span><span class="s1">abs(x) &lt; </span><span class="s5">1e4 </span><span class="s2">and </span><span class="s1">x == int(x):</span>
            <span class="s2">return </span><span class="s3">'%d' </span><span class="s1">% x</span>
        <span class="s1">fmt = (</span><span class="s3">'%1.3e' </span><span class="s2">if </span><span class="s1">d &lt; </span><span class="s5">1e-2 </span><span class="s2">else</span>
               <span class="s3">'%1.3f' </span><span class="s2">if </span><span class="s1">d &lt;= </span><span class="s5">1 </span><span class="s2">else</span>
               <span class="s3">'%1.2f' </span><span class="s2">if </span><span class="s1">d &lt;= </span><span class="s5">10 </span><span class="s2">else</span>
               <span class="s3">'%1.1f' </span><span class="s2">if </span><span class="s1">d &lt;= </span><span class="s5">1e5 </span><span class="s2">else</span>
               <span class="s3">'%1.1e'</span><span class="s1">)</span>
        <span class="s1">s = fmt % x</span>
        <span class="s1">tup = s.split(</span><span class="s3">'e'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(tup) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">mantissa = tup[</span><span class="s5">0</span><span class="s1">].rstrip(</span><span class="s3">'0'</span><span class="s1">).rstrip(</span><span class="s3">'.'</span><span class="s1">)</span>
            <span class="s1">exponent = int(tup[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">exponent:</span>
                <span class="s1">s = </span><span class="s3">'%se%d' </span><span class="s1">% (mantissa</span><span class="s2">, </span><span class="s1">exponent)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s = mantissa</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = s.rstrip(</span><span class="s3">'0'</span><span class="s1">).rstrip(</span><span class="s3">'.'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">s</span>


<span class="s2">class </span><span class="s1">LogFormatterExponent(LogFormatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format values for log axis using ``exponent = log_base(value)``. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_num_to_string(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">fx = math.log(x) / math.log(self._base)</span>
        <span class="s2">if </span><span class="s1">abs(fx) &gt; </span><span class="s5">10000</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s3">'%1.0g' </span><span class="s1">% fx</span>
        <span class="s2">elif </span><span class="s1">abs(fx) &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s3">'%1.0g' </span><span class="s1">% fx</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fd = math.log(vmax - vmin) / math.log(self._base)</span>
            <span class="s1">s = self._pprint_val(fx</span><span class="s2">, </span><span class="s1">fd)</span>
        <span class="s2">return </span><span class="s1">s</span>


<span class="s2">class </span><span class="s1">LogFormatterMathtext(LogFormatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format values for log axis using ``exponent = log_base(value)``. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_non_decade_format(self</span><span class="s2">, </span><span class="s1">sign_string</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">usetex):</span>
        <span class="s0">&quot;&quot;&quot;Return string for non-decade locations.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">r'$\mathdefault{%s%s^{%.2f}}$' </span><span class="s1">% (sign_string</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fx)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">usetex = mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">]</span>
        <span class="s1">min_exp = mpl.rcParams[</span><span class="s3">'axes.formatter.min_exponent'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">x == </span><span class="s5">0</span><span class="s1">:  </span><span class="s4"># Symlog</span>
            <span class="s2">return </span><span class="s3">r'$\mathdefault{0}$'</span>

        <span class="s1">sign_string = </span><span class="s3">'-' </span><span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s3">''</span>
        <span class="s1">x = abs(x)</span>
        <span class="s1">b = self._base</span>

        <span class="s4"># only label the decades</span>
        <span class="s1">fx = math.log(x) / math.log(b)</span>
        <span class="s1">is_x_decade = _is_close_to_int(fx)</span>
        <span class="s1">exponent = round(fx) </span><span class="s2">if </span><span class="s1">is_x_decade </span><span class="s2">else </span><span class="s1">np.floor(fx)</span>
        <span class="s1">coeff = round(b ** (fx - exponent))</span>
        <span class="s2">if </span><span class="s1">is_x_decade:</span>
            <span class="s1">fx = round(fx)</span>

        <span class="s2">if </span><span class="s1">self.labelOnlyBase </span><span class="s2">and not </span><span class="s1">is_x_decade:</span>
            <span class="s2">return </span><span class="s3">''</span>
        <span class="s2">if </span><span class="s1">self._sublabels </span><span class="s2">is not None and </span><span class="s1">coeff </span><span class="s2">not in </span><span class="s1">self._sublabels:</span>
            <span class="s2">return </span><span class="s3">''</span>

        <span class="s4"># use string formatting of the base if it is not an integer</span>
        <span class="s2">if </span><span class="s1">b % </span><span class="s5">1 </span><span class="s1">== </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s1">base = </span><span class="s3">'%d' </span><span class="s1">% b</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">base = </span><span class="s3">'%s' </span><span class="s1">% b</span>

        <span class="s2">if </span><span class="s1">abs(fx) &lt; min_exp:</span>
            <span class="s2">return </span><span class="s3">r'$\mathdefault{%s%g}$' </span><span class="s1">% (sign_string</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">elif not </span><span class="s1">is_x_decade:</span>
            <span class="s2">return </span><span class="s1">self._non_decade_format(sign_string</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">usetex)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">r'$\mathdefault{%s%s^{%d}}$' </span><span class="s1">% (sign_string</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fx)</span>


<span class="s2">class </span><span class="s1">LogFormatterSciNotation(LogFormatterMathtext):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format values following scientific notation in a logarithmic axis. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_non_decade_format(self</span><span class="s2">, </span><span class="s1">sign_string</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">usetex):</span>
        <span class="s0">&quot;&quot;&quot;Return string for non-decade locations.&quot;&quot;&quot;</span>
        <span class="s1">b = float(base)</span>
        <span class="s1">exponent = math.floor(fx)</span>
        <span class="s1">coeff = b ** (fx - exponent)</span>
        <span class="s2">if </span><span class="s1">_is_close_to_int(coeff):</span>
            <span class="s1">coeff = round(coeff)</span>
        <span class="s2">return </span><span class="s3">r'$\mathdefault{%s%g\times%s^{%d}}$' </span><span class="s1">\</span>
            <span class="s1">% (sign_string</span><span class="s2">, </span><span class="s1">coeff</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">exponent)</span>


<span class="s2">class </span><span class="s1">LogitFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Probability formatter (using Math text). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">use_overline=</span><span class="s2">False,</span>
        <span class="s1">one_half=</span><span class="s3">r&quot;\frac{1}{2}&quot;</span><span class="s2">,</span>
        <span class="s1">minor=</span><span class="s2">False,</span>
        <span class="s1">minor_threshold=</span><span class="s5">25</span><span class="s2">,</span>
        <span class="s1">minor_number=</span><span class="s5">6</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Parameters 
        ---------- 
        use_overline : bool, default: False 
            If x &gt; 1/2, with x = 1-v, indicate if x should be displayed as 
            $\overline{v}$. The default is to display $1-v$. 
 
        one_half : str, default: r&quot;\frac{1}{2}&quot; 
            The string used to represent 1/2. 
 
        minor : bool, default: False 
            Indicate if the formatter is formatting minor ticks or not. 
            Basically minor ticks are not labelled, except when only few ticks 
            are provided, ticks with most space with neighbor ticks are 
            labelled. See other parameters to change the default behavior. 
 
        minor_threshold : int, default: 25 
            Maximum number of locs for labelling some minor ticks. This 
            parameter have no effect if minor is False. 
 
        minor_number : int, default: 6 
            Number of ticks which are labelled when the number of ticks is 
            below the threshold. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._use_overline = use_overline</span>
        <span class="s1">self._one_half = one_half</span>
        <span class="s1">self._minor = minor</span>
        <span class="s1">self._labelled = set()</span>
        <span class="s1">self._minor_threshold = minor_threshold</span>
        <span class="s1">self._minor_number = minor_number</span>

    <span class="s2">def </span><span class="s1">use_overline(self</span><span class="s2">, </span><span class="s1">use_overline):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Switch display mode with overline for labelling p&gt;1/2. 
 
        Parameters 
        ---------- 
        use_overline : bool, default: False 
            If x &gt; 1/2, with x = 1-v, indicate if x should be displayed as 
            $\overline{v}$. The default is to display $1-v$. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._use_overline = use_overline</span>

    <span class="s2">def </span><span class="s1">set_one_half(self</span><span class="s2">, </span><span class="s1">one_half):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set the way one half is displayed. 
 
        one_half : str, default: r&quot;\frac{1}{2}&quot; 
            The string used to represent 1/2. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._one_half = one_half</span>

    <span class="s2">def </span><span class="s1">set_minor_threshold(self</span><span class="s2">, </span><span class="s1">minor_threshold):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the threshold for labelling minors ticks. 
 
        Parameters 
        ---------- 
        minor_threshold : int 
            Maximum number of locations for labelling some minor ticks. This 
            parameter have no effect if minor is False. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._minor_threshold = minor_threshold</span>

    <span class="s2">def </span><span class="s1">set_minor_number(self</span><span class="s2">, </span><span class="s1">minor_number):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the number of minor ticks to label when some minor ticks are 
        labelled. 
 
        Parameters 
        ---------- 
        minor_number : int 
            Number of ticks which are labelled when the number of ticks is 
            below the threshold. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._minor_number = minor_number</span>

    <span class="s2">def </span><span class="s1">set_locs(self</span><span class="s2">, </span><span class="s1">locs):</span>
        <span class="s1">self.locs = np.array(locs)</span>
        <span class="s1">self._labelled.clear()</span>

        <span class="s2">if not </span><span class="s1">self._minor:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">all(</span>
            <span class="s1">_is_decade(x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">_is_decade(</span><span class="s5">1 </span><span class="s1">- x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s2">or </span><span class="s1">(_is_close_to_int(</span><span class="s5">2 </span><span class="s1">* x) </span><span class="s2">and</span>
                <span class="s1">int(np.round(</span><span class="s5">2 </span><span class="s1">* x)) == </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">locs</span>
        <span class="s1">):</span>
            <span class="s4"># minor ticks are subsample from ideal, so no label</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">len(locs) &lt; self._minor_threshold:</span>
            <span class="s2">if </span><span class="s1">len(locs) &lt; self._minor_number:</span>
                <span class="s1">self._labelled.update(locs)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># we do not have a lot of minor ticks, so only few decades are</span>
                <span class="s4"># displayed, then we choose some (spaced) minor ticks to label.</span>
                <span class="s4"># Only minor ticks are known, we assume it is sufficient to</span>
                <span class="s4"># choice which ticks are displayed.</span>
                <span class="s4"># For each ticks we compute the distance between the ticks and</span>
                <span class="s4"># the previous, and between the ticks and the next one. Ticks</span>
                <span class="s4"># with smallest minimum are chosen. As tiebreak, the ticks</span>
                <span class="s4"># with smallest sum is chosen.</span>
                <span class="s1">diff = np.diff(-np.log(</span><span class="s5">1 </span><span class="s1">/ self.locs - </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s1">space_pessimistic = np.minimum(</span>
                    <span class="s1">np.concatenate(((np.inf</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">diff))</span><span class="s2">,</span>
                    <span class="s1">np.concatenate((diff</span><span class="s2">, </span><span class="s1">(np.inf</span><span class="s2">,</span><span class="s1">)))</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">space_sum = (</span>
                    <span class="s1">np.concatenate(((</span><span class="s5">0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">diff))</span>
                    <span class="s1">+ np.concatenate((diff</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">)))</span>
                <span class="s1">)</span>
                <span class="s1">good_minor = sorted(</span>
                    <span class="s1">range(len(self.locs))</span><span class="s2">,</span>
                    <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">i: (space_pessimistic[i]</span><span class="s2">, </span><span class="s1">space_sum[i])</span><span class="s2">,</span>
                <span class="s1">)[-self._minor_number:]</span>
                <span class="s1">self._labelled.update(locs[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">good_minor)</span>

    <span class="s2">def </span><span class="s1">_format_value(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">locs</span><span class="s2">, </span><span class="s1">sci_notation=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">sci_notation:</span>
            <span class="s1">exponent = math.floor(np.log10(x))</span>
            <span class="s1">min_precision = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exponent = </span><span class="s5">0</span>
            <span class="s1">min_precision = </span><span class="s5">1</span>
        <span class="s1">value = x * </span><span class="s5">10 </span><span class="s1">** (-exponent)</span>
        <span class="s2">if </span><span class="s1">len(locs) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">precision = min_precision</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">diff = np.sort(np.abs(locs - x))[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">precision = -np.log10(diff) + exponent</span>
            <span class="s1">precision = (</span>
                <span class="s1">int(np.round(precision))</span>
                <span class="s2">if </span><span class="s1">_is_close_to_int(precision)</span>
                <span class="s2">else </span><span class="s1">math.ceil(precision)</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">precision &lt; min_precision:</span>
                <span class="s1">precision = min_precision</span>
        <span class="s1">mantissa = </span><span class="s3">r&quot;%.*f&quot; </span><span class="s1">% (precision</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">if not </span><span class="s1">sci_notation:</span>
            <span class="s2">return </span><span class="s1">mantissa</span>
        <span class="s1">s = </span><span class="s3">r&quot;%s\cdot10^{%d}&quot; </span><span class="s1">% (mantissa</span><span class="s2">, </span><span class="s1">exponent)</span>
        <span class="s2">return </span><span class="s1">s</span>

    <span class="s2">def </span><span class="s1">_one_minus(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s2">if </span><span class="s1">self._use_overline:</span>
            <span class="s2">return </span><span class="s3">r&quot;\overline{%s}&quot; </span><span class="s1">% s</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;1-{}&quot;</span><span class="s1">.format(s)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">self._minor </span><span class="s2">and </span><span class="s1">x </span><span class="s2">not in </span><span class="s1">self._labelled:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">x &lt;= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">x &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">_is_close_to_int(</span><span class="s5">2 </span><span class="s1">* x) </span><span class="s2">and </span><span class="s1">round(</span><span class="s5">2 </span><span class="s1">* x) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">s = self._one_half</span>
        <span class="s2">elif </span><span class="s1">x &lt; </span><span class="s5">0.5 </span><span class="s2">and </span><span class="s1">_is_decade(x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">):</span>
            <span class="s1">exponent = round(math.log10(x))</span>
            <span class="s1">s = </span><span class="s3">&quot;10^{%d}&quot; </span><span class="s1">% exponent</span>
        <span class="s2">elif </span><span class="s1">x &gt; </span><span class="s5">0.5 </span><span class="s2">and </span><span class="s1">_is_decade(</span><span class="s5">1 </span><span class="s1">- x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-7</span><span class="s1">):</span>
            <span class="s1">exponent = round(math.log10(</span><span class="s5">1 </span><span class="s1">- x))</span>
            <span class="s1">s = self._one_minus(</span><span class="s3">&quot;10^{%d}&quot; </span><span class="s1">% exponent)</span>
        <span class="s2">elif </span><span class="s1">x &lt; </span><span class="s5">0.1</span><span class="s1">:</span>
            <span class="s1">s = self._format_value(x</span><span class="s2">, </span><span class="s1">self.locs)</span>
        <span class="s2">elif </span><span class="s1">x &gt; </span><span class="s5">0.9</span><span class="s1">:</span>
            <span class="s1">s = self._one_minus(self._format_value(</span><span class="s5">1</span><span class="s1">-x</span><span class="s2">, </span><span class="s5">1</span><span class="s1">-self.locs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s = self._format_value(x</span><span class="s2">, </span><span class="s1">self.locs</span><span class="s2">, </span><span class="s1">sci_notation=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s3">r&quot;$\mathdefault{%s}$&quot; </span><span class="s1">% s</span>

    <span class="s2">def </span><span class="s1">format_data_short(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># Thresholds chosen to use scientific notation iff exponent &lt;= -2.</span>
        <span class="s2">if </span><span class="s1">value &lt; </span><span class="s5">0.1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;{:e}&quot;</span><span class="s1">.format(value)</span>
        <span class="s2">if </span><span class="s1">value &lt; </span><span class="s5">0.9</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;{:f}&quot;</span><span class="s1">.format(value)</span>
        <span class="s2">return </span><span class="s3">&quot;1-{:e}&quot;</span><span class="s1">.format(</span><span class="s5">1 </span><span class="s1">- value)</span>


<span class="s2">class </span><span class="s1">EngFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format axis values using engineering prefixes to represent powers 
    of 1000, plus a specified unit, e.g., 10 MHz instead of 1e7. 
    &quot;&quot;&quot;</span>

    <span class="s4"># The SI engineering prefixes</span>
    <span class="s1">ENG_PREFIXES = {</span>
        <span class="s1">-</span><span class="s5">24</span><span class="s1">: </span><span class="s3">&quot;y&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">21</span><span class="s1">: </span><span class="s3">&quot;z&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">18</span><span class="s1">: </span><span class="s3">&quot;a&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">15</span><span class="s1">: </span><span class="s3">&quot;f&quot;</span><span class="s2">,</span>
        <span class="s1">-</span><span class="s5">12</span><span class="s1">: </span><span class="s3">&quot;p&quot;</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s5">9</span><span class="s1">: </span><span class="s3">&quot;n&quot;</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s5">6</span><span class="s1">: </span><span class="s3">&quot;</span><span class="s2">\N{MICRO SIGN}</span><span class="s3">&quot;</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s5">3</span><span class="s1">: </span><span class="s3">&quot;m&quot;</span><span class="s2">,</span>
          <span class="s5">0</span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
          <span class="s5">3</span><span class="s1">: </span><span class="s3">&quot;k&quot;</span><span class="s2">,</span>
          <span class="s5">6</span><span class="s1">: </span><span class="s3">&quot;M&quot;</span><span class="s2">,</span>
          <span class="s5">9</span><span class="s1">: </span><span class="s3">&quot;G&quot;</span><span class="s2">,</span>
         <span class="s5">12</span><span class="s1">: </span><span class="s3">&quot;T&quot;</span><span class="s2">,</span>
         <span class="s5">15</span><span class="s1">: </span><span class="s3">&quot;P&quot;</span><span class="s2">,</span>
         <span class="s5">18</span><span class="s1">: </span><span class="s3">&quot;E&quot;</span><span class="s2">,</span>
         <span class="s5">21</span><span class="s1">: </span><span class="s3">&quot;Z&quot;</span><span class="s2">,</span>
         <span class="s5">24</span><span class="s1">: </span><span class="s3">&quot;Y&quot;</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">places=</span><span class="s2">None, </span><span class="s1">sep=</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">usetex=</span><span class="s2">None,</span>
                 <span class="s1">useMathText=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Parameters 
        ---------- 
        unit : str, default: &quot;&quot; 
            Unit symbol to use, suitable for use with single-letter 
            representations of powers of 1000. For example, 'Hz' or 'm'. 
 
        places : int, default: None 
            Precision with which to display the number, specified in 
            digits after the decimal point (there will be between one 
            and three digits before the decimal point). If it is None, 
            the formatting falls back to the floating point format '%g', 
            which displays up to 6 *significant* digits, i.e. the equivalent 
            value for *places* varies between 0 and 5 (inclusive). 
 
        sep : str, default: &quot; &quot; 
            Separator used between the value and the prefix/unit. For 
            example, one get '3.14 mV' if ``sep`` is &quot; &quot; (default) and 
            '3.14mV' if ``sep`` is &quot;&quot;. Besides the default behavior, some 
            other useful options may be: 
 
            * ``sep=&quot;&quot;`` to append directly the prefix/unit to the value; 
            * ``sep=&quot;\N{THIN SPACE}&quot;`` (``U+2009``); 
            * ``sep=&quot;\N{NARROW NO-BREAK SPACE}&quot;`` (``U+202F``); 
            * ``sep=&quot;\N{NO-BREAK SPACE}&quot;`` (``U+00A0``). 
 
        usetex : bool, default: :rc:`text.usetex` 
            To enable/disable the use of TeX's math mode for rendering the 
            numbers in the formatter. 
 
        useMathText : bool, default: :rc:`axes.formatter.use_mathtext` 
            To enable/disable the use mathtext for rendering the numbers in 
            the formatter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.unit = unit</span>
        <span class="s1">self.places = places</span>
        <span class="s1">self.sep = sep</span>
        <span class="s1">self.set_usetex(usetex)</span>
        <span class="s1">self.set_useMathText(useMathText)</span>

    <span class="s2">def </span><span class="s1">get_usetex(self):</span>
        <span class="s2">return </span><span class="s1">self._usetex</span>

    <span class="s2">def </span><span class="s1">set_usetex(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._usetex = mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._usetex = val</span>

    <span class="s1">usetex = property(fget=get_usetex</span><span class="s2">, </span><span class="s1">fset=set_usetex)</span>

    <span class="s2">def </span><span class="s1">get_useMathText(self):</span>
        <span class="s2">return </span><span class="s1">self._useMathText</span>

    <span class="s2">def </span><span class="s1">set_useMathText(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._useMathText = mpl.rcParams[</span><span class="s3">'axes.formatter.use_mathtext'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._useMathText = val</span>

    <span class="s1">useMathText = property(fget=get_useMathText</span><span class="s2">, </span><span class="s1">fset=set_useMathText)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">s = </span><span class="s3">&quot;%s%s&quot; </span><span class="s1">% (self.format_eng(x)</span><span class="s2">, </span><span class="s1">self.unit)</span>
        <span class="s4"># Remove the trailing separator when there is neither prefix nor unit</span>
        <span class="s2">if </span><span class="s1">self.sep </span><span class="s2">and </span><span class="s1">s.endswith(self.sep):</span>
            <span class="s1">s = s[:-len(self.sep)]</span>
        <span class="s2">return </span><span class="s1">self.fix_minus(s)</span>

    <span class="s2">def </span><span class="s1">format_eng(self</span><span class="s2">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot; 
        Format a number in engineering notation, appending a letter 
        representing the power of 1000 of the original number. 
        Some examples: 
 
        &gt;&gt;&gt; format_eng(0)        # for self.places = 0 
        '0' 
 
        &gt;&gt;&gt; format_eng(1000000)  # for self.places = 1 
        '1.0 M' 
 
        &gt;&gt;&gt; format_eng(-1e-6)  # for self.places = 2 
        '-1.00 \N{MICRO SIGN}' 
        &quot;&quot;&quot;</span>
        <span class="s1">sign = </span><span class="s5">1</span>
        <span class="s1">fmt = </span><span class="s3">&quot;g&quot; </span><span class="s2">if </span><span class="s1">self.places </span><span class="s2">is None else </span><span class="s3">&quot;.{:d}f&quot;</span><span class="s1">.format(self.places)</span>

        <span class="s2">if </span><span class="s1">num &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">sign = -</span><span class="s5">1</span>
            <span class="s1">num = -num</span>

        <span class="s2">if </span><span class="s1">num != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pow10 = int(math.floor(math.log10(num) / </span><span class="s5">3</span><span class="s1">) * </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pow10 = </span><span class="s5">0</span>
            <span class="s4"># Force num to zero, to avoid inconsistencies like</span>
            <span class="s4"># format_eng(-0) = &quot;0&quot; and format_eng(0.0) = &quot;0&quot;</span>
            <span class="s4"># but format_eng(-0.0) = &quot;-0.0&quot;</span>
            <span class="s1">num = </span><span class="s5">0.0</span>

        <span class="s1">pow10 = np.clip(pow10</span><span class="s2">, </span><span class="s1">min(self.ENG_PREFIXES)</span><span class="s2">, </span><span class="s1">max(self.ENG_PREFIXES))</span>

        <span class="s1">mant = sign * num / (</span><span class="s5">10.0 </span><span class="s1">** pow10)</span>
        <span class="s4"># Taking care of the cases like 999.9..., which may be rounded to 1000</span>
        <span class="s4"># instead of 1 k.  Beware of the corner case of values that are beyond</span>
        <span class="s4"># the range of SI prefixes (i.e. &gt; 'Y').</span>
        <span class="s2">if </span><span class="s1">(abs(float(format(mant</span><span class="s2">, </span><span class="s1">fmt))) &gt;= </span><span class="s5">1000</span>
                <span class="s2">and </span><span class="s1">pow10 &lt; max(self.ENG_PREFIXES)):</span>
            <span class="s1">mant /= </span><span class="s5">1000</span>
            <span class="s1">pow10 += </span><span class="s5">3</span>

        <span class="s1">prefix = self.ENG_PREFIXES[int(pow10)]</span>
        <span class="s2">if </span><span class="s1">self._usetex </span><span class="s2">or </span><span class="s1">self._useMathText:</span>
            <span class="s1">formatted = </span><span class="s3">&quot;${mant:{fmt}}${sep}{prefix}&quot;</span><span class="s1">.format(</span>
                <span class="s1">mant=mant</span><span class="s2">, </span><span class="s1">sep=self.sep</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">fmt=fmt)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">formatted = </span><span class="s3">&quot;{mant:{fmt}}{sep}{prefix}&quot;</span><span class="s1">.format(</span>
                <span class="s1">mant=mant</span><span class="s2">, </span><span class="s1">sep=self.sep</span><span class="s2">, </span><span class="s1">prefix=prefix</span><span class="s2">, </span><span class="s1">fmt=fmt)</span>

        <span class="s2">return </span><span class="s1">formatted</span>


<span class="s2">class </span><span class="s1">PercentFormatter(Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format numbers as a percentage. 
 
    Parameters 
    ---------- 
    xmax : float 
        Determines how the number is converted into a percentage. 
        *xmax* is the data value that corresponds to 100%. 
        Percentages are computed as ``x / xmax * 100``. So if the data is 
        already scaled to be percentages, *xmax* will be 100. Another common 
        situation is where *xmax* is 1.0. 
 
    decimals : None or int 
        The number of decimal places to place after the point. 
        If *None* (the default), the number will be computed automatically. 
 
    symbol : str or None 
        A string that will be appended to the label. It may be 
        *None* or empty to indicate that no symbol should be used. LaTeX 
        special characters are escaped in *symbol* whenever latex mode is 
        enabled, unless *is_latex* is *True*. 
 
    is_latex : bool 
        If *False*, reserved LaTeX characters in *symbol* will be escaped. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xmax=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">decimals=</span><span class="s2">None, </span><span class="s1">symbol=</span><span class="s3">'%'</span><span class="s2">, </span><span class="s1">is_latex=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.xmax = xmax + </span><span class="s5">0.0</span>
        <span class="s1">self.decimals = decimals</span>
        <span class="s1">self._symbol = symbol</span>
        <span class="s1">self._is_latex = is_latex</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Format the tick as a percentage with the appropriate scaling.&quot;&quot;&quot;</span>
        <span class="s1">ax_min</span><span class="s2">, </span><span class="s1">ax_max = self.axis.get_view_interval()</span>
        <span class="s1">display_range = abs(ax_max - ax_min)</span>
        <span class="s2">return </span><span class="s1">self.fix_minus(self.format_pct(x</span><span class="s2">, </span><span class="s1">display_range))</span>

    <span class="s2">def </span><span class="s1">format_pct(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">display_range):</span>
        <span class="s0">&quot;&quot;&quot; 
        Format the number as a percentage number with the correct 
        number of decimals and adds the percent symbol, if any. 
 
        If ``self.decimals`` is `None`, the number of digits after the 
        decimal point is set based on the *display_range* of the axis 
        as follows: 
 
        ============= ======== ======================= 
        display_range decimals sample 
        ============= ======== ======================= 
        &gt;50           0        ``x = 34.5`` =&gt; 35% 
        &gt;5            1        ``x = 34.5`` =&gt; 34.5% 
        &gt;0.5          2        ``x = 34.5`` =&gt; 34.50% 
        ...           ...      ... 
        ============= ======== ======================= 
 
        This method will not be very good for tiny axis ranges or 
        extremely large ones. It assumes that the values on the chart 
        are percentages displayed on a reasonable scale. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = self.convert_to_pct(x)</span>
        <span class="s2">if </span><span class="s1">self.decimals </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># conversion works because display_range is a difference</span>
            <span class="s1">scaled_range = self.convert_to_pct(display_range)</span>
            <span class="s2">if </span><span class="s1">scaled_range &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">decimals = </span><span class="s5">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Luckily Python's built-in ceil rounds to +inf, not away from</span>
                <span class="s4"># zero. This is very important since the equation for decimals</span>
                <span class="s4"># starts out as `scaled_range &gt; 0.5 * 10**(2 - decimals)`</span>
                <span class="s4"># and ends up with `decimals &gt; 2 - log10(2 * scaled_range)`.</span>
                <span class="s1">decimals = math.ceil(</span><span class="s5">2.0 </span><span class="s1">- math.log10(</span><span class="s5">2.0 </span><span class="s1">* scaled_range))</span>
                <span class="s2">if </span><span class="s1">decimals &gt; </span><span class="s5">5</span><span class="s1">:</span>
                    <span class="s1">decimals = </span><span class="s5">5</span>
                <span class="s2">elif </span><span class="s1">decimals &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">decimals = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">decimals = self.decimals</span>
        <span class="s1">s = </span><span class="s3">'{x:0.{decimals}f}'</span><span class="s1">.format(x=x</span><span class="s2">, </span><span class="s1">decimals=int(decimals))</span>

        <span class="s2">return </span><span class="s1">s + self.symbol</span>

    <span class="s2">def </span><span class="s1">convert_to_pct(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s5">100.0 </span><span class="s1">* (x / self.xmax)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">symbol(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The configured percent symbol as a string. 
 
        If LaTeX is enabled via :rc:`text.usetex`, the special characters 
        ``{'#', '$', '%', '&amp;', '~', '_', '^', '\', '{', '}'}`` are 
        automatically escaped in the string. 
        &quot;&quot;&quot;</span>
        <span class="s1">symbol = self._symbol</span>
        <span class="s2">if not </span><span class="s1">symbol:</span>
            <span class="s1">symbol = </span><span class="s3">''</span>
        <span class="s2">elif </span><span class="s1">mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">] </span><span class="s2">and not </span><span class="s1">self._is_latex:</span>
            <span class="s4"># Source: http://www.personal.ceu.hu/tex/specchar.htm</span>
            <span class="s4"># Backslash must be first for this to work correctly since</span>
            <span class="s4"># it keeps getting added in</span>
            <span class="s2">for </span><span class="s1">spec </span><span class="s2">in </span><span class="s3">r'\#$%&amp;~_^{}'</span><span class="s1">:</span>
                <span class="s1">symbol = symbol.replace(spec</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">+ spec)</span>
        <span class="s2">return </span><span class="s1">symbol</span>

    <span class="s1">@symbol.setter</span>
    <span class="s2">def </span><span class="s1">symbol(self</span><span class="s2">, </span><span class="s1">symbol):</span>
        <span class="s1">self._symbol = symbol</span>


<span class="s2">class </span><span class="s1">Locator(TickHelper):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine the tick locations; 
 
    Note that the same locator should not be used across multiple 
    `~matplotlib.axis.Axis` because the locator stores references to the Axis 
    data and view limits. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Some automatic tick locators can generate so many ticks they</span>
    <span class="s4"># kill the machine when you try and render them.</span>
    <span class="s4"># This parameter is set to cause locators to raise an error if too</span>
    <span class="s4"># many ticks are generated.</span>
    <span class="s1">MAXTICKS = </span><span class="s5">1000</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the values of the located ticks given **vmin** and **vmax**. 
 
        .. note:: 
            To get tick locations with the vmin and vmax values defined 
            automatically for the associated ``axis`` simply call 
            the Locator instance:: 
 
                &gt;&gt;&gt; print(type(loc)) 
                &lt;type 'Locator'&gt; 
                &gt;&gt;&gt; print(loc()) 
                [1, 2, 3, 4] 
 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Do nothing, and raise a warning. Any locator class not supporting the 
        set_params() function will call this. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.warn_external(</span>
            <span class="s3">&quot;'set_params()' not defined for locator of type &quot; </span><span class="s1">+</span>
            <span class="s1">str(type(self)))</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s4"># note: some locators return data limits, other return view limits,</span>
        <span class="s4"># hence there is no *one* interface to call self.tick_values.</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">raise_if_exceeds(self</span><span class="s2">, </span><span class="s1">locs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Log at WARNING level if *locs* is longer than `Locator.MAXTICKS`. 
 
        This is intended to be called immediately before returning *locs* from 
        ``__call__`` to inform users in case their Locator returns a huge 
        number of ticks, causing Matplotlib to run out of memory. 
 
        The &quot;strange&quot; name of this method dates back to when it would raise an 
        exception instead of emitting a log. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(locs) &gt;= self.MAXTICKS:</span>
            <span class="s1">_log.warning(</span>
                <span class="s3">&quot;Locator attempting to generate %s ticks ([%s, ..., %s]), &quot;</span>
                <span class="s3">&quot;which exceeds Locator.MAXTICKS (%s).&quot;</span><span class="s2">,</span>
                <span class="s1">len(locs)</span><span class="s2">, </span><span class="s1">locs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">locs[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.MAXTICKS)</span>
        <span class="s2">return </span><span class="s1">locs</span>

    <span class="s2">def </span><span class="s1">nonsingular(self</span><span class="s2">, </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust a range as needed to avoid singularities. 
 
        This method gets called during autoscaling, with ``(v0, v1)`` set to 
        the data limits on the axes if the axes contains any data, or 
        ``(-inf, +inf)`` if not. 
 
        - If ``v0 == v1`` (possibly up to some floating point slop), this 
          method returns an expanded interval around this value. 
        - If ``(v0, v1) == (-inf, +inf)``, this method returns appropriate 
          default view limits. 
        - Otherwise, ``(v0, v1)`` is returned without modification. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">mtransforms.nonsingular(v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">.05</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select a scale for the range from vmin to vmax. 
 
        Subclasses should override this method to change locator behaviour. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>


<span class="s2">class </span><span class="s1">IndexLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Place a tick on every multiple of some base number of points 
    plotted, e.g., on every 5th point.  It is assumed that you are doing 
    index plotting; i.e., the axis is 0, len(data).  This is mainly 
    useful for x ticks. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s0">&quot;&quot;&quot;Place ticks every *base* data point, starting at *offset*.&quot;&quot;&quot;</span>
        <span class="s1">self._base = base</span>
        <span class="s1">self.offset = offset</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s2">None, </span><span class="s1">offset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._base = base</span>
        <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.offset = offset</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks&quot;&quot;&quot;</span>
        <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = self.axis.get_data_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(dmin</span><span class="s2">, </span><span class="s1">dmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(</span>
            <span class="s1">np.arange(vmin + self.offset</span><span class="s2">, </span><span class="s1">vmax + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">self._base))</span>


<span class="s2">class </span><span class="s1">FixedLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tick locations are fixed at *locs*.  If *nbins* is not None, 
    the *locs* array of possible positions will be subsampled to 
    keep the number of ticks &lt;= *nbins* +1. 
    The subsampling will be done to include the smallest 
    absolute value; for example, if zero is included in the 
    array of possibilities, then it is guaranteed to be one of 
    the chosen ticks. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">locs</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.locs = np.asarray(locs)</span>
        <span class="s1">_api.check_shape((</span><span class="s2">None,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">locs=self.locs)</span>
        <span class="s1">self.nbins = max(nbins</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) </span><span class="s2">if </span><span class="s1">nbins </span><span class="s2">is not None else None</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">nbins </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.nbins = nbins</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s2">return </span><span class="s1">self.tick_values(</span><span class="s2">None, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the locations of the ticks. 
 
        .. note:: 
 
            Because the values are fixed, vmin and vmax are not used in this 
            method. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.nbins </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.locs</span>
        <span class="s1">step = max(int(np.ceil(len(self.locs) / self.nbins))</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">ticks = self.locs[::step]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">step):</span>
            <span class="s1">ticks1 = self.locs[i::step]</span>
            <span class="s2">if </span><span class="s1">np.abs(ticks1).min() &lt; np.abs(ticks).min():</span>
                <span class="s1">ticks = ticks1</span>
        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(ticks)</span>


<span class="s2">class </span><span class="s1">NullLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    No ticks 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s2">return </span><span class="s1">self.tick_values(</span><span class="s2">None, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the locations of the ticks. 
 
        .. note:: 
 
            Because the values are Null, vmin and vmax are not used in this 
            method. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">LinearLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine the tick locations 
 
    The first time this function is called it will try to set the 
    number of ticks to make a nice tick partitioning.  Thereafter, the 
    number of ticks will be fixed so that interactive navigation will 
    be nice 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None, </span><span class="s1">presets=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        numticks : int or None, default None 
            Number of ticks. If None, *numticks* = 11. 
        presets : dict or None, default: None 
            Dictionary mapping ``(vmin, vmax)`` to an array of locations. 
            Overrides *numticks* if there is an entry for the current 
            ``(vmin, vmax)``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.numticks = numticks</span>
        <span class="s2">if </span><span class="s1">presets </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.presets = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.presets = presets</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">numticks(self):</span>
        <span class="s4"># Old hard-coded default.</span>
        <span class="s2">return </span><span class="s1">self._numticks </span><span class="s2">if </span><span class="s1">self._numticks </span><span class="s2">is not None else </span><span class="s5">11</span>

    <span class="s1">@numticks.setter</span>
    <span class="s2">def </span><span class="s1">numticks(self</span><span class="s2">, </span><span class="s1">numticks):</span>
        <span class="s1">self._numticks = numticks</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None, </span><span class="s1">presets=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">presets </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.presets = presets</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.numticks = numticks</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">0.05</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s2">if </span><span class="s1">(vmin</span><span class="s2">, </span><span class="s1">vmax) </span><span class="s2">in </span><span class="s1">self.presets:</span>
            <span class="s2">return </span><span class="s1">self.presets[(vmin</span><span class="s2">, </span><span class="s1">vmax)]</span>

        <span class="s2">if </span><span class="s1">self.numticks == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s1">ticklocs = np.linspace(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">self.numticks)</span>

        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(ticklocs)</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot;Try to choose the view limits intelligently.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s2">if </span><span class="s1">vmin == vmax:</span>
            <span class="s1">vmin -= </span><span class="s5">1</span>
            <span class="s1">vmax += </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s1">exponent</span><span class="s2">, </span><span class="s1">remainder = divmod(</span>
                <span class="s1">math.log10(vmax - vmin)</span><span class="s2">, </span><span class="s1">math.log10(max(self.numticks - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>
            <span class="s1">exponent -= (remainder &lt; </span><span class="s5">.5</span><span class="s1">)</span>
            <span class="s1">scale = max(self.numticks - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) ** (-exponent)</span>
            <span class="s1">vmin = math.floor(scale * vmin) / scale</span>
            <span class="s1">vmax = math.ceil(scale * vmax) / scale</span>

        <span class="s2">return </span><span class="s1">mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>


<span class="s2">class </span><span class="s1">MultipleLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set a tick on each integer multiple of the *base* within the view 
    interval. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s1">self._edge = _Edge_integer(base</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._edge = _Edge_integer(base</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s1">step = self._edge.step</span>
        <span class="s1">vmin = self._edge.ge(vmin) * step</span>
        <span class="s1">n = (vmax - vmin + </span><span class="s5">0.001 </span><span class="s1">* step) // step</span>
        <span class="s1">locs = vmin - step + np.arange(n + </span><span class="s5">3</span><span class="s1">) * step</span>
        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(locs)</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the view limits to the nearest multiples of *base* that 
        contain the data. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s1">vmin = self._edge.le(dmin) * self._edge.step</span>
            <span class="s1">vmax = self._edge.ge(dmax) * self._edge.step</span>
            <span class="s2">if </span><span class="s1">vmin == vmax:</span>
                <span class="s1">vmin -= </span><span class="s5">1</span>
                <span class="s1">vmax += </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vmin = dmin</span>
            <span class="s1">vmax = dmax</span>

        <span class="s2">return </span><span class="s1">mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>


<span class="s2">def </span><span class="s1">scale_range(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">n=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">threshold=</span><span class="s5">100</span><span class="s1">):</span>
    <span class="s1">dv = abs(vmax - vmin)  </span><span class="s4"># &gt; 0 as nonsingular is called before.</span>
    <span class="s1">meanv = (vmax + vmin) / </span><span class="s5">2</span>
    <span class="s2">if </span><span class="s1">abs(meanv) / dv &lt; threshold:</span>
        <span class="s1">offset = </span><span class="s5">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">offset = math.copysign(</span><span class="s5">10 </span><span class="s1">** (math.log10(abs(meanv)) // </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">meanv)</span>
    <span class="s1">scale = </span><span class="s5">10 </span><span class="s1">** (math.log10(dv / n) // </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">offset</span>


<span class="s2">class </span><span class="s1">_Edge_integer:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper for `.MaxNLocator`, `.MultipleLocator`, etc. 
 
    Take floating-point precision limitations into account when calculating 
    tick locations as integer multiples of a step. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        step : float &gt; 0 
            Interval between ticks. 
        offset : float 
            Offset subtracted from the data limits prior to calculating tick 
            locations. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">step &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'step' must be positive&quot;</span><span class="s1">)</span>
        <span class="s1">self.step = step</span>
        <span class="s1">self._offset = abs(offset)</span>

    <span class="s2">def </span><span class="s1">closeto(self</span><span class="s2">, </span><span class="s1">ms</span><span class="s2">, </span><span class="s1">edge):</span>
        <span class="s4"># Allow more slop when the offset is large compared to the step.</span>
        <span class="s2">if </span><span class="s1">self._offset &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">digits = np.log10(self._offset / self.step)</span>
            <span class="s1">tol = max(</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s5">10 </span><span class="s1">** (digits - </span><span class="s5">12</span><span class="s1">))</span>
            <span class="s1">tol = min(</span><span class="s5">0.4999</span><span class="s2">, </span><span class="s1">tol)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tol = </span><span class="s5">1e-10</span>
        <span class="s2">return </span><span class="s1">abs(ms - edge) &lt; tol</span>

    <span class="s2">def </span><span class="s1">le(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Return the largest n: n*step &lt;= x.&quot;&quot;&quot;</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">m = divmod(x</span><span class="s2">, </span><span class="s1">self.step)</span>
        <span class="s2">if </span><span class="s1">self.closeto(m / self.step</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">d + </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">d</span>

    <span class="s2">def </span><span class="s1">ge(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Return the smallest n: n*step &gt;= x.&quot;&quot;&quot;</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">m = divmod(x</span><span class="s2">, </span><span class="s1">self.step)</span>
        <span class="s2">if </span><span class="s1">self.closeto(m / self.step</span><span class="s2">, </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">d</span>
        <span class="s2">return </span><span class="s1">d + </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">MaxNLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find nice tick locations with no more than *nbins* + 1 being within the 
    view limits. Locations beyond the limits are added to support autoscaling. 
    &quot;&quot;&quot;</span>
    <span class="s1">default_params = dict(nbins=</span><span class="s5">10</span><span class="s2">,</span>
                          <span class="s1">steps=</span><span class="s2">None,</span>
                          <span class="s1">integer=</span><span class="s2">False,</span>
                          <span class="s1">symmetric=</span><span class="s2">False,</span>
                          <span class="s1">prune=</span><span class="s2">None,</span>
                          <span class="s1">min_n_ticks=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        nbins : int or 'auto', default: 10 
            Maximum number of intervals; one less than max number of 
            ticks.  If the string 'auto', the number of bins will be 
            automatically determined based on the length of the axis. 
 
        steps : array-like, optional 
            Sequence of nice numbers starting with 1 and ending with 10; 
            e.g., [1, 2, 4, 5, 10], where the values are acceptable 
            tick multiples.  i.e. for the example, 20, 40, 60 would be 
            an acceptable set of ticks, as would 0.4, 0.6, 0.8, because 
            they are multiples of 2.  However, 30, 60, 90 would not 
            be allowed because 3 does not appear in the list of steps. 
 
        integer : bool, default: False 
            If True, ticks will take only integer values, provided at least 
            *min_n_ticks* integers are found within the view limits. 
 
        symmetric : bool, default: False 
            If True, autoscaling will result in a range symmetric about zero. 
 
        prune : {'lower', 'upper', 'both', None}, default: None 
            Remove edge ticks -- useful for stacked or ganged plots where 
            the upper tick of one axes overlaps with the lower tick of the 
            axes above it, primarily when :rc:`axes.autolimit_mode` is 
            ``'round_numbers'``.  If ``prune=='lower'``, the smallest tick will 
            be removed.  If ``prune == 'upper'``, the largest tick will be 
            removed.  If ``prune == 'both'``, the largest and smallest ticks 
            will be removed.  If *prune* is *None*, no ticks will be removed. 
 
        min_n_ticks : int, default: 2 
            Relax *nbins* and *integer* constraints if necessary to obtain 
            this minimum number of ticks. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">nbins </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s3">'nbins'</span><span class="s1">] = nbins</span>
        <span class="s1">self.set_params(**{**self.default_params</span><span class="s2">, </span><span class="s1">**kwargs})</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_validate_steps(steps):</span>
        <span class="s2">if not </span><span class="s1">np.iterable(steps):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'steps argument must be an increasing sequence '</span>
                             <span class="s3">'of numbers between 1 and 10 inclusive'</span><span class="s1">)</span>
        <span class="s1">steps = np.asarray(steps)</span>
        <span class="s2">if </span><span class="s1">np.any(np.diff(steps) &lt;= </span><span class="s5">0</span><span class="s1">) </span><span class="s2">or </span><span class="s1">steps[-</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">10 </span><span class="s2">or </span><span class="s1">steps[</span><span class="s5">0</span><span class="s1">] &lt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'steps argument must be an increasing sequence '</span>
                             <span class="s3">'of numbers between 1 and 10 inclusive'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">steps[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">steps = np.concatenate([[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps])</span>
        <span class="s2">if </span><span class="s1">steps[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">10</span><span class="s1">:</span>
            <span class="s1">steps = np.concatenate([steps</span><span class="s2">, </span><span class="s1">[</span><span class="s5">10</span><span class="s1">]])</span>
        <span class="s2">return </span><span class="s1">steps</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_staircase(steps):</span>
        <span class="s4"># Make an extended staircase within which the needed step will be</span>
        <span class="s4"># found.  This is probably much larger than necessary.</span>
        <span class="s2">return </span><span class="s1">np.concatenate([</span><span class="s5">0.1 </span><span class="s1">* steps[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">steps</span><span class="s2">, </span><span class="s1">[</span><span class="s5">10 </span><span class="s1">* steps[</span><span class="s5">1</span><span class="s1">]]])</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set parameters for this locator. 
 
        Parameters 
        ---------- 
        nbins : int or 'auto', optional 
            see `.MaxNLocator` 
        steps : array-like, optional 
            see `.MaxNLocator` 
        integer : bool, optional 
            see `.MaxNLocator` 
        symmetric : bool, optional 
            see `.MaxNLocator` 
        prune : {'lower', 'upper', 'both', None}, optional 
            see `.MaxNLocator` 
        min_n_ticks : int, optional 
            see `.MaxNLocator` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s3">'nbins' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self._nbins = kwargs.pop(</span><span class="s3">'nbins'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self._nbins != </span><span class="s3">'auto'</span><span class="s1">:</span>
                <span class="s1">self._nbins = int(self._nbins)</span>
        <span class="s2">if </span><span class="s3">'symmetric' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self._symmetric = kwargs.pop(</span><span class="s3">'symmetric'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s3">'prune' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">prune = kwargs.pop(</span><span class="s3">'prune'</span><span class="s1">)</span>
            <span class="s1">_api.check_in_list([</span><span class="s3">'upper'</span><span class="s2">, </span><span class="s3">'lower'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prune=prune)</span>
            <span class="s1">self._prune = prune</span>
        <span class="s2">if </span><span class="s3">'min_n_ticks' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self._min_n_ticks = max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s3">'min_n_ticks'</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s3">'steps' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">steps = kwargs.pop(</span><span class="s3">'steps'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">steps </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._steps = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._steps = self._validate_steps(steps)</span>
            <span class="s1">self._extended_steps = self._staircase(self._steps)</span>
        <span class="s2">if </span><span class="s3">'integer' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self._integer = kwargs.pop(</span><span class="s3">'integer'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">_api.kwarg_error(</span><span class="s3">&quot;set_params&quot;</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">def </span><span class="s1">_raw_ticks(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate a list of tick locations including the range *vmin* to 
        *vmax*.  In some applications, one or both of the end locations 
        will not be needed, in which case they are trimmed off 
        elsewhere. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._nbins == </span><span class="s3">'auto'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">nbins = np.clip(self.axis.get_tick_space()</span><span class="s2">,</span>
                                <span class="s1">max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">self._min_n_ticks - </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nbins = </span><span class="s5">9</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nbins = self._nbins</span>

        <span class="s1">scale</span><span class="s2">, </span><span class="s1">offset = scale_range(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">nbins)</span>
        <span class="s1">_vmin = vmin - offset</span>
        <span class="s1">_vmax = vmax - offset</span>
        <span class="s1">raw_step = (_vmax - _vmin) / nbins</span>
        <span class="s1">steps = self._extended_steps * scale</span>
        <span class="s2">if </span><span class="s1">self._integer:</span>
            <span class="s4"># For steps &gt; 1, keep only integer values.</span>
            <span class="s1">igood = (steps &lt; </span><span class="s5">1</span><span class="s1">) | (np.abs(steps - np.round(steps)) &lt; </span><span class="s5">0.001</span><span class="s1">)</span>
            <span class="s1">steps = steps[igood]</span>

        <span class="s1">istep = np.nonzero(steps &gt;= raw_step)[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s4"># Classic round_numbers mode may require a larger step.</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">istep </span><span class="s2">in </span><span class="s1">range(istep</span><span class="s2">, </span><span class="s1">len(steps)):</span>
                <span class="s1">step = steps[istep]</span>
                <span class="s1">best_vmin = (_vmin // step) * step</span>
                <span class="s1">best_vmax = best_vmin + step * nbins</span>
                <span class="s2">if </span><span class="s1">best_vmax &gt;= _vmax:</span>
                    <span class="s2">break</span>

        <span class="s4"># This is an upper limit; move to smaller steps if necessary.</span>
        <span class="s2">for </span><span class="s1">istep </span><span class="s2">in </span><span class="s1">reversed(range(istep + </span><span class="s5">1</span><span class="s1">)):</span>
            <span class="s1">step = steps[istep]</span>

            <span class="s2">if </span><span class="s1">(self._integer </span><span class="s2">and</span>
                    <span class="s1">np.floor(_vmax) - np.ceil(_vmin) &gt;= self._min_n_ticks - </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">step = max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">step)</span>
            <span class="s1">best_vmin = (_vmin // step) * step</span>

            <span class="s4"># Find tick locations spanning the vmin-vmax range, taking into</span>
            <span class="s4"># account degradation of precision when there is a large offset.</span>
            <span class="s4"># The edge ticks beyond vmin and/or vmax are needed for the</span>
            <span class="s4"># &quot;round_numbers&quot; autolimit mode.</span>
            <span class="s1">edge = _Edge_integer(step</span><span class="s2">, </span><span class="s1">offset)</span>
            <span class="s1">low = edge.le(_vmin - best_vmin)</span>
            <span class="s1">high = edge.ge(_vmax - best_vmin)</span>
            <span class="s1">ticks = np.arange(low</span><span class="s2">, </span><span class="s1">high + </span><span class="s5">1</span><span class="s1">) * step + best_vmin</span>
            <span class="s4"># Count only the ticks that will be displayed.</span>
            <span class="s1">nticks = ((ticks &lt;= _vmax) &amp; (ticks &gt;= _vmin)).sum()</span>
            <span class="s2">if </span><span class="s1">nticks &gt;= self._min_n_ticks:</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">ticks + offset</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">if </span><span class="s1">self._symmetric:</span>
            <span class="s1">vmax = max(abs(vmin)</span><span class="s2">, </span><span class="s1">abs(vmax))</span>
            <span class="s1">vmin = -vmax</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = mtransforms.nonsingular(</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">1e-13</span><span class="s2">, </span><span class="s1">tiny=</span><span class="s5">1e-14</span><span class="s1">)</span>
        <span class="s1">locs = self._raw_ticks(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

        <span class="s1">prune = self._prune</span>
        <span class="s2">if </span><span class="s1">prune == </span><span class="s3">'lower'</span><span class="s1">:</span>
            <span class="s1">locs = locs[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">elif </span><span class="s1">prune == </span><span class="s3">'upper'</span><span class="s1">:</span>
            <span class="s1">locs = locs[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">prune == </span><span class="s3">'both'</span><span class="s1">:</span>
            <span class="s1">locs = locs[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(locs)</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax):</span>
        <span class="s2">if </span><span class="s1">self._symmetric:</span>
            <span class="s1">dmax = max(abs(dmin)</span><span class="s2">, </span><span class="s1">abs(dmax))</span>
            <span class="s1">dmin = -dmax</span>

        <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = mtransforms.nonsingular(</span>
            <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">1e-12</span><span class="s2">, </span><span class="s1">tiny=</span><span class="s5">1e-13</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._raw_ticks(dmin</span><span class="s2">, </span><span class="s1">dmax)[[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">is_decade(x</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">):</span>
    <span class="s2">if not </span><span class="s1">np.isfinite(x):</span>
        <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">x == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s2">return True</span>
    <span class="s1">lx = np.log(abs(x)) / np.log(base)</span>
    <span class="s2">return </span><span class="s1">is_close_to_int(lx</span><span class="s2">, </span><span class="s1">atol=rtol)</span>


<span class="s2">def </span><span class="s1">_is_decade(x</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return True if *x* is an integer power of *base*.&quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">np.isfinite(x):</span>
        <span class="s2">return False</span>
    <span class="s2">if </span><span class="s1">x == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s2">return True</span>
    <span class="s1">lx = np.log(abs(x)) / np.log(base)</span>
    <span class="s2">if </span><span class="s1">rtol </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.isclose(lx</span><span class="s2">, </span><span class="s1">np.round(lx))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.isclose(lx</span><span class="s2">, </span><span class="s1">np.round(lx)</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">def </span><span class="s1">_decade_less_equal(x</span><span class="s2">, </span><span class="s1">base):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the largest integer power of *base* that's less or equal to *x*. 
 
    If *x* is negative, the exponent will be *greater*. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(x </span><span class="s2">if </span><span class="s1">x == </span><span class="s5">0 </span><span class="s2">else</span>
            <span class="s1">-_decade_greater_equal(-x</span><span class="s2">, </span><span class="s1">base) </span><span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0 </span><span class="s2">else</span>
            <span class="s1">base ** np.floor(np.log(x) / np.log(base)))</span>


<span class="s2">def </span><span class="s1">_decade_greater_equal(x</span><span class="s2">, </span><span class="s1">base):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the smallest integer power of *base* that's greater or equal to *x*. 
 
    If *x* is negative, the exponent will be *smaller*. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(x </span><span class="s2">if </span><span class="s1">x == </span><span class="s5">0 </span><span class="s2">else</span>
            <span class="s1">-_decade_less_equal(-x</span><span class="s2">, </span><span class="s1">base) </span><span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0 </span><span class="s2">else</span>
            <span class="s1">base ** np.ceil(np.log(x) / np.log(base)))</span>


<span class="s2">def </span><span class="s1">_decade_less(x</span><span class="s2">, </span><span class="s1">base):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the largest integer power of *base* that's less than *x*. 
 
    If *x* is negative, the exponent will be *greater*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">-_decade_greater(-x</span><span class="s2">, </span><span class="s1">base)</span>
    <span class="s1">less = _decade_less_equal(x</span><span class="s2">, </span><span class="s1">base)</span>
    <span class="s2">if </span><span class="s1">less == x:</span>
        <span class="s1">less /= base</span>
    <span class="s2">return </span><span class="s1">less</span>


<span class="s2">def </span><span class="s1">_decade_greater(x</span><span class="s2">, </span><span class="s1">base):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the smallest integer power of *base* that's greater than *x*. 
 
    If *x* is negative, the exponent will be *smaller*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">-_decade_less(-x</span><span class="s2">, </span><span class="s1">base)</span>
    <span class="s1">greater = _decade_greater_equal(x</span><span class="s2">, </span><span class="s1">base)</span>
    <span class="s2">if </span><span class="s1">greater == x:</span>
        <span class="s1">greater *= base</span>
    <span class="s2">return </span><span class="s1">greater</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">is_close_to_int(x</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">abs(x - np.round(x)) &lt; atol</span>


<span class="s2">def </span><span class="s1">_is_close_to_int(x):</span>
    <span class="s2">return </span><span class="s1">math.isclose(x</span><span class="s2">, </span><span class="s1">round(x))</span>


<span class="s2">class </span><span class="s1">LogLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
 
    Determine the tick locations for log axes. 
 
    Place ticks on the locations : ``subs[j] * base**i`` 
 
    Parameters 
    ---------- 
    base : float, default: 10.0 
        The base of the log used, so major ticks are placed at 
        ``base**n``, where ``n`` is an integer. 
    subs : None or {'auto', 'all'} or sequence of float, default: (1.0,) 
        Gives the multiples of integer powers of the base at which 
        to place ticks.  The default of ``(1.0, )`` places ticks only at 
        integer powers of the base. 
        Permitted string values are ``'auto'`` and ``'all'``. 
        Both of these use an algorithm based on the axis view 
        limits to determine whether and how to put ticks between 
        integer powers of the base.  With ``'auto'``, ticks are 
        placed only between integer powers; with ``'all'``, the 
        integer powers are included.  A value of None is 
        equivalent to ``'auto'``. 
    numticks : None or int, default: None 
        The maximum number of ticks to allow on a given axis. The default 
        of ``None`` will try to choose intelligently as long as this 
        Locator has already been assigned to an axis using 
        `~.axis.Axis.get_tick_space`, but otherwise falls back to 9. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s5">10.0</span><span class="s2">, </span><span class="s1">subs=(</span><span class="s5">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">numdecs=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Place ticks on the locations : subs[j] * base**i.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
                <span class="s1">numticks = </span><span class="s5">15</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">numticks = </span><span class="s3">'auto'</span>
        <span class="s1">self._base = float(base)</span>
        <span class="s1">self._set_subs(subs)</span>
        <span class="s1">self.numdecs = numdecs</span>
        <span class="s1">self.numticks = numticks</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s2">None, </span><span class="s1">subs=</span><span class="s2">None, </span><span class="s1">numdecs=</span><span class="s2">None, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._base = float(base)</span>
        <span class="s2">if </span><span class="s1">subs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._set_subs(subs)</span>
        <span class="s2">if </span><span class="s1">numdecs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.numdecs = numdecs</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.numticks = numticks</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'set_params(base=...)'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">base(self</span><span class="s2">, </span><span class="s1">base):</span>
        <span class="s0">&quot;&quot;&quot;Set the log base (major tick every ``base**i``, i integer).&quot;&quot;&quot;</span>
        <span class="s1">self._base = float(base)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'set_params(subs=...)'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">subs(self</span><span class="s2">, </span><span class="s1">subs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the minor ticks for the log scaling every ``base**i*subs[j]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_subs(subs)</span>

    <span class="s2">def </span><span class="s1">_set_subs(self</span><span class="s2">, </span><span class="s1">subs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the minor ticks for the log scaling every ``base**i*subs[j]``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">subs </span><span class="s2">is None</span><span class="s1">:  </span><span class="s4"># consistency with previous bad API</span>
            <span class="s1">self._subs = </span><span class="s3">'auto'</span>
        <span class="s2">elif </span><span class="s1">isinstance(subs</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">_api.check_in_list((</span><span class="s3">'all'</span><span class="s2">, </span><span class="s3">'auto'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">subs=subs)</span>
            <span class="s1">self._subs = subs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._subs = np.asarray(subs</span><span class="s2">, </span><span class="s1">dtype=float)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;subs must be None, 'all', 'auto' or &quot;</span>
                                 <span class="s3">&quot;a sequence of floats, not &quot;</span>
                                 <span class="s3">&quot;{}.&quot;</span><span class="s1">.format(subs)) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s2">if </span><span class="s1">self._subs.ndim != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;A sequence passed to subs must be &quot;</span>
                                 <span class="s3">&quot;1-dimensional, not &quot;</span>
                                 <span class="s3">&quot;{}-dimensional.&quot;</span><span class="s1">.format(self._subs.ndim))</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">if </span><span class="s1">self.numticks == </span><span class="s3">'auto'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">numticks = np.clip(self.axis.get_tick_space()</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">9</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">numticks = </span><span class="s5">9</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">numticks = self.numticks</span>

        <span class="s1">b = self._base</span>
        <span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">vmin = self.axis.get_minpos()</span>

            <span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0.0 </span><span class="s2">or not </span><span class="s1">np.isfinite(vmin):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Data has no positive values, and therefore can not be &quot;</span>
                    <span class="s3">&quot;log-scaled.&quot;</span><span class="s1">)</span>

        <span class="s1">_log.debug(</span><span class="s3">'vmin %s vmax %s'</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s1">log_vmin = math.log(vmin) / math.log(b)</span>
        <span class="s1">log_vmax = math.log(vmax) / math.log(b)</span>

        <span class="s1">numdec = math.floor(log_vmax) - math.ceil(log_vmin)</span>

        <span class="s2">if </span><span class="s1">isinstance(self._subs</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">_first = </span><span class="s5">2.0 </span><span class="s2">if </span><span class="s1">self._subs == </span><span class="s3">'auto' </span><span class="s2">else </span><span class="s5">1.0</span>
            <span class="s2">if </span><span class="s1">numdec &gt; </span><span class="s5">10 </span><span class="s2">or </span><span class="s1">b &lt; </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._subs == </span><span class="s3">'auto'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">np.array([])  </span><span class="s4"># no minor or major ticks</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">subs = np.array([</span><span class="s5">1.0</span><span class="s1">])  </span><span class="s4"># major ticks</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">subs = np.arange(_first</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subs = self._subs</span>

        <span class="s4"># Get decades between major ticks.</span>
        <span class="s1">stride = (max(math.ceil(numdec / (numticks - </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
                  <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">] </span><span class="s2">else</span>
                  <span class="s1">(numdec + </span><span class="s5">1</span><span class="s1">) // numticks + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># if we have decided that the stride is as big or bigger than</span>
        <span class="s4"># the range, clip the stride back to the available range - 1</span>
        <span class="s4"># with a floor of 1.  This prevents getting axis with only 1 tick</span>
        <span class="s4"># visible.</span>
        <span class="s2">if </span><span class="s1">stride &gt;= numdec:</span>
            <span class="s1">stride = max(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">numdec - </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># Does subs include anything other than 1?  Essentially a hack to know</span>
        <span class="s4"># whether we're a major or a minor locator.</span>
        <span class="s1">have_subs = len(subs) &gt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">(len(subs) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">subs[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1.0</span><span class="s1">)</span>

        <span class="s1">decades = np.arange(math.floor(log_vmin) - stride</span><span class="s2">,</span>
                            <span class="s1">math.ceil(log_vmax) + </span><span class="s5">2 </span><span class="s1">* stride</span><span class="s2">, </span><span class="s1">stride)</span>

        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'_transform'</span><span class="s1">):</span>
            <span class="s1">ticklocs = self._transform.inverted().transform(decades)</span>
            <span class="s2">if </span><span class="s1">have_subs:</span>
                <span class="s2">if </span><span class="s1">stride == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">ticklocs = np.ravel(np.outer(subs</span><span class="s2">, </span><span class="s1">ticklocs))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># No ticklocs if we have &gt;1 decade between major ticks.</span>
                    <span class="s1">ticklocs = np.array([])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">have_subs:</span>
                <span class="s2">if </span><span class="s1">stride == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">ticklocs = np.concatenate(</span>
                        <span class="s1">[subs * decade_start </span><span class="s2">for </span><span class="s1">decade_start </span><span class="s2">in </span><span class="s1">b ** decades])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ticklocs = np.array([])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ticklocs = b ** decades</span>

        <span class="s1">_log.debug(</span><span class="s3">'ticklocs %r'</span><span class="s2">, </span><span class="s1">ticklocs)</span>
        <span class="s2">if </span><span class="s1">(len(subs) &gt; </span><span class="s5">1</span>
                <span class="s2">and </span><span class="s1">stride == </span><span class="s5">1</span>
                <span class="s2">and </span><span class="s1">((vmin &lt;= ticklocs) &amp; (ticklocs &lt;= vmax)).sum() &lt;= </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s4"># If we're a minor locator *that expects at least two ticks per</span>
            <span class="s4"># decade* and the major locator stride is 1 and there's no more</span>
            <span class="s4"># than one minor tick, switch to AutoLocator.</span>
            <span class="s2">return </span><span class="s1">AutoLocator().tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.raise_if_exceeds(ticklocs)</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot;Try to choose the view limits intelligently.&quot;&quot;&quot;</span>
        <span class="s1">b = self._base</span>

        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s1">vmin = _decade_less_equal(vmin</span><span class="s2">, </span><span class="s1">self._base)</span>
            <span class="s1">vmax = _decade_greater_equal(vmax</span><span class="s2">, </span><span class="s1">self._base)</span>

        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>

    <span class="s2">def </span><span class="s1">nonsingular(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(vmin) </span><span class="s2">or not </span><span class="s1">np.isfinite(vmax):</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10  </span><span class="s4"># Initial range, no data plotted yet.</span>
        <span class="s2">elif </span><span class="s1">vmax &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s3">&quot;Data has no positive values, and therefore cannot be &quot;</span>
                <span class="s3">&quot;log-scaled.&quot;</span><span class="s1">)</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">minpos = self.axis.get_minpos()</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(minpos):</span>
                <span class="s1">minpos = </span><span class="s5">1e-300  </span><span class="s4"># This should never take effect.</span>
            <span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">vmin = minpos</span>
            <span class="s2">if </span><span class="s1">vmin == vmax:</span>
                <span class="s1">vmin = _decade_less(vmin</span><span class="s2">, </span><span class="s1">self._base)</span>
                <span class="s1">vmax = _decade_greater(vmax</span><span class="s2">, </span><span class="s1">self._base)</span>
        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>


<span class="s2">class </span><span class="s1">SymmetricalLogLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine the tick locations for symmetric log axes. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None, </span><span class="s1">subs=</span><span class="s2">None, </span><span class="s1">linthresh=</span><span class="s2">None, </span><span class="s1">base=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        transform : `~.scale.SymmetricalLogTransform`, optional 
            If set, defines the *base* and *linthresh* of the symlog transform. 
        base, linthresh : float, optional 
            The *base* and *linthresh* of the symlog transform, as documented 
            for `.SymmetricalLogScale`.  These parameters are only used if 
            *transform* is not set. 
        subs : sequence of float, default: [1] 
            The multiples of integer powers of the base where ticks are placed, 
            i.e., ticks are placed at 
            ``[sub * base**i for i in ... for sub in subs]``. 
 
        Notes 
        ----- 
        Either *transform*, or both *base* and *linthresh*, must be given. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">transform </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._base = transform.base</span>
            <span class="s1">self._linthresh = transform.linthresh</span>
        <span class="s2">elif </span><span class="s1">linthresh </span><span class="s2">is not None and </span><span class="s1">base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._base = base</span>
            <span class="s1">self._linthresh = linthresh</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Either transform, or both linthresh &quot;</span>
                             <span class="s3">&quot;and base, must be provided.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">subs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._subs = [</span><span class="s5">1.0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._subs = subs</span>
        <span class="s1">self.numticks = </span><span class="s5">15</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">subs=</span><span class="s2">None, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.numticks = numticks</span>
        <span class="s2">if </span><span class="s1">subs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._subs = subs</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s4"># Note, these are untransformed coordinates</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">base = self._base</span>
        <span class="s1">linthresh = self._linthresh</span>

        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s4"># The domain is divided into three sections, only some of</span>
        <span class="s4"># which may actually be present.</span>
        <span class="s4">#</span>
        <span class="s4"># &lt;======== -t ==0== t ========&gt;</span>
        <span class="s4"># aaaaaaaaa    bbbbb   ccccccccc</span>
        <span class="s4">#</span>
        <span class="s4"># a) and c) will have ticks at integral log positions.  The</span>
        <span class="s4"># number of ticks needs to be reduced if there are more</span>
        <span class="s4"># than self.numticks of them.</span>
        <span class="s4">#</span>
        <span class="s4"># b) has a tick at 0 and only 0 (we assume t is a small</span>
        <span class="s4"># number, and the linear segment is just an implementation</span>
        <span class="s4"># detail and not interesting.)</span>
        <span class="s4">#</span>
        <span class="s4"># We could also add ticks at t, but that seems to usually be</span>
        <span class="s4"># uninteresting.</span>
        <span class="s4">#</span>
        <span class="s4"># &quot;simple&quot; mode is when the range falls entirely within (-t,</span>
        <span class="s4"># t) -- it should just display (vmin, 0, vmax)</span>
        <span class="s2">if </span><span class="s1">-linthresh &lt; vmin &lt; vmax &lt; linthresh:</span>
            <span class="s4"># only the linear range is present</span>
            <span class="s2">return </span><span class="s1">[vmin</span><span class="s2">, </span><span class="s1">vmax]</span>

        <span class="s4"># Lower log range is present</span>
        <span class="s1">has_a = (vmin &lt; -linthresh)</span>
        <span class="s4"># Upper log range is present</span>
        <span class="s1">has_c = (vmax &gt; linthresh)</span>

        <span class="s4"># Check if linear range is present</span>
        <span class="s1">has_b = (has_a </span><span class="s2">and </span><span class="s1">vmax &gt; -linthresh) </span><span class="s2">or </span><span class="s1">(has_c </span><span class="s2">and </span><span class="s1">vmin &lt; linthresh)</span>

        <span class="s2">def </span><span class="s1">get_log_range(lo</span><span class="s2">, </span><span class="s1">hi):</span>
            <span class="s1">lo = np.floor(np.log(lo) / np.log(base))</span>
            <span class="s1">hi = np.ceil(np.log(hi) / np.log(base))</span>
            <span class="s2">return </span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span>

        <span class="s4"># Calculate all the ranges, so we can determine striding</span>
        <span class="s1">a_lo</span><span class="s2">, </span><span class="s1">a_hi = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">has_a:</span>
            <span class="s1">a_upper_lim = min(-linthresh</span><span class="s2">, </span><span class="s1">vmax)</span>
            <span class="s1">a_lo</span><span class="s2">, </span><span class="s1">a_hi = get_log_range(abs(a_upper_lim)</span><span class="s2">, </span><span class="s1">abs(vmin) + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">c_lo</span><span class="s2">, </span><span class="s1">c_hi = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">has_c:</span>
            <span class="s1">c_lower_lim = max(linthresh</span><span class="s2">, </span><span class="s1">vmin)</span>
            <span class="s1">c_lo</span><span class="s2">, </span><span class="s1">c_hi = get_log_range(c_lower_lim</span><span class="s2">, </span><span class="s1">vmax + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s4"># Calculate the total number of integer exponents in a and c ranges</span>
        <span class="s1">total_ticks = (a_hi - a_lo) + (c_hi - c_lo)</span>
        <span class="s2">if </span><span class="s1">has_b:</span>
            <span class="s1">total_ticks += </span><span class="s5">1</span>
        <span class="s1">stride = max(total_ticks // (self.numticks - </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">decades = []</span>
        <span class="s2">if </span><span class="s1">has_a:</span>
            <span class="s1">decades.extend(-</span><span class="s5">1 </span><span class="s1">* (base ** (np.arange(a_lo</span><span class="s2">, </span><span class="s1">a_hi</span><span class="s2">,</span>
                                                    <span class="s1">stride)[::-</span><span class="s5">1</span><span class="s1">])))</span>

        <span class="s2">if </span><span class="s1">has_b:</span>
            <span class="s1">decades.append(</span><span class="s5">0.0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">has_c:</span>
            <span class="s1">decades.extend(base ** (np.arange(c_lo</span><span class="s2">, </span><span class="s1">c_hi</span><span class="s2">, </span><span class="s1">stride)))</span>

        <span class="s4"># Add the subticks if requested</span>
        <span class="s2">if </span><span class="s1">self._subs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subs = np.arange(</span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">base)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subs = np.asarray(self._subs)</span>

        <span class="s2">if </span><span class="s1">len(subs) &gt; </span><span class="s5">1 </span><span class="s2">or </span><span class="s1">subs[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">1.0</span><span class="s1">:</span>
            <span class="s1">ticklocs = []</span>
            <span class="s2">for </span><span class="s1">decade </span><span class="s2">in </span><span class="s1">decades:</span>
                <span class="s2">if </span><span class="s1">decade == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">ticklocs.append(decade)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ticklocs.extend(subs * decade)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ticklocs = decades</span>

        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(np.array(ticklocs))</span>

    <span class="s2">def </span><span class="s1">view_limits(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot;Try to choose the view limits intelligently.&quot;&quot;&quot;</span>
        <span class="s1">b = self._base</span>
        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'axes.autolimit_mode'</span><span class="s1">] == </span><span class="s3">'round_numbers'</span><span class="s1">:</span>
            <span class="s1">vmin = _decade_less_equal(vmin</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s1">vmax = _decade_greater_equal(vmax</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s2">if </span><span class="s1">vmin == vmax:</span>
                <span class="s1">vmin = _decade_less(vmin</span><span class="s2">, </span><span class="s1">b)</span>
                <span class="s1">vmax = _decade_greater(vmax</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s1">result = mtransforms.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">AsinhLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    An axis tick locator specialized for the inverse-sinh scale 
 
    This is very unlikely to have any use beyond 
    the `~.scale.AsinhScale` class. 
 
    .. note:: 
 
       This API is provisional and may be revised in the future 
       based on early user feedback. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">linear_width</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s5">11</span><span class="s2">, </span><span class="s1">symthresh=</span><span class="s5">0.2</span><span class="s2">,</span>
                 <span class="s1">base=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">subs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        linear_width : float 
            The scale parameter defining the extent 
            of the quasi-linear region. 
        numticks : int, default: 11 
            The approximate number of major ticks that will fit 
            along the entire axis 
        symthresh : float, default: 0.2 
            The fractional threshold beneath which data which covers 
            a range that is approximately symmetric about zero 
            will have ticks that are exactly symmetric. 
        base : int, default: 10 
            The number base used for rounding tick locations 
            on a logarithmic scale. If this is less than one, 
            then rounding is to the nearest integer multiple 
            of powers of ten. 
        subs : tuple, default: None 
            Multiples of the number base, typically used 
            for the minor ticks, e.g. (2, 5) when base=10. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.linear_width = linear_width</span>
        <span class="s1">self.numticks = numticks</span>
        <span class="s1">self.symthresh = symthresh</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.subs = subs</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None, </span><span class="s1">symthresh=</span><span class="s2">None,</span>
                   <span class="s1">base=</span><span class="s2">None, </span><span class="s1">subs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.numticks = numticks</span>
        <span class="s2">if </span><span class="s1">symthresh </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.symthresh = symthresh</span>
        <span class="s2">if </span><span class="s1">base </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.base = base</span>
        <span class="s2">if </span><span class="s1">subs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.subs = subs </span><span class="s2">if </span><span class="s1">len(subs) &gt; </span><span class="s5">0 </span><span class="s2">else None</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">(vmin * vmax) &lt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">abs(</span><span class="s5">1 </span><span class="s1">+ vmax / vmin) &lt; self.symthresh:</span>
            <span class="s4"># Data-range appears to be almost symmetric, so round up:</span>
            <span class="s1">bound = max(abs(vmin)</span><span class="s2">, </span><span class="s1">abs(vmax))</span>
            <span class="s2">return </span><span class="s1">self.tick_values(-bound</span><span class="s2">, </span><span class="s1">bound)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s4"># Construct a set of &quot;on-screen&quot; locations</span>
        <span class="s4"># that are uniformly spaced:</span>
        <span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = self.linear_width * np.arcsinh(np.array([vmin</span><span class="s2">, </span><span class="s1">vmax])</span>
                                                        <span class="s1">/ self.linear_width)</span>
        <span class="s1">ys = np.linspace(ymin</span><span class="s2">, </span><span class="s1">ymax</span><span class="s2">, </span><span class="s1">self.numticks)</span>
        <span class="s1">zero_dev = np.abs(ys / (ymax - ymin))</span>
        <span class="s2">if </span><span class="s1">(ymin * ymax) &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># Ensure that the zero tick-mark is included,</span>
            <span class="s4"># if the axis straddles zero</span>
            <span class="s1">ys = np.hstack([ys[(zero_dev &gt; </span><span class="s5">0.5 </span><span class="s1">/ self.numticks)]</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">])</span>

        <span class="s4"># Transform the &quot;on-screen&quot; grid to the data space:</span>
        <span class="s1">xs = self.linear_width * np.sinh(ys / self.linear_width)</span>
        <span class="s1">zero_xs = (ys == </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s4"># Round the data-space values to be intuitive base-n numbers,</span>
        <span class="s4"># keeping track of positive and negative values separately,</span>
        <span class="s4"># but giving careful treatment to the zero value:</span>
        <span class="s2">if </span><span class="s1">self.base &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">log_base = math.log(self.base)</span>
            <span class="s1">powers = (</span>
                <span class="s1">np.where(zero_xs</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.sign(xs)) *</span>
                <span class="s1">np.power(self.base</span><span class="s2">,</span>
                         <span class="s1">np.where(zero_xs</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">,</span>
                                  <span class="s1">np.floor(np.log(np.abs(xs) + zero_xs*</span><span class="s5">1e-6</span><span class="s1">)</span>
                                                <span class="s1">/ log_base)))</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.subs:</span>
                <span class="s1">qs = np.outer(powers</span><span class="s2">, </span><span class="s1">self.subs).flatten()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">qs = powers</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">powers = (</span>
                <span class="s1">np.where(xs &gt;= </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) *</span>
                <span class="s1">np.power(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">np.where(zero_xs</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">,</span>
                                      <span class="s1">np.floor(np.log10(np.abs(xs)</span>
                                                        <span class="s1">+ zero_xs*</span><span class="s5">1e-6</span><span class="s1">))))</span>
            <span class="s1">)</span>
            <span class="s1">qs = powers * np.round(xs / powers)</span>
        <span class="s1">ticks = np.array(sorted(set(qs)))</span>

        <span class="s2">if </span><span class="s1">len(ticks) &gt;= </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ticks</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.linspace(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">self.numticks)</span>


<span class="s2">class </span><span class="s1">LogitLocator(MaxNLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine the tick locations for logit axes 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s3">&quot;auto&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Place ticks on the logit locations 
 
        Parameters 
        ---------- 
        nbins : int or 'auto', optional 
            Number of ticks. Only used if minor is False. 
        minor : bool, default: False 
            Indicate if this locator is for minor ticks or not. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._minor = minor</span>
        <span class="s1">super().__init__(nbins=nbins</span><span class="s2">, </span><span class="s1">steps=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">set_params(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters within this locator.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">minor </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._minor = minor</span>
        <span class="s1">super().set_params(**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">minor(self):</span>
        <span class="s2">return </span><span class="s1">self._minor</span>

    <span class="s1">@minor.setter</span>
    <span class="s2">def </span><span class="s1">minor(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.set_params(minor=value)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s4"># dummy axis has no axes attribute</span>
        <span class="s2">if </span><span class="s1">hasattr(self.axis</span><span class="s2">, </span><span class="s3">&quot;axes&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self.axis.axes.name == </span><span class="s3">&quot;polar&quot;</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;Polar axis cannot be logit scaled yet&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._nbins == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">nbins = self.axis.get_tick_space()</span>
                <span class="s2">if </span><span class="s1">nbins &lt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s1">nbins = </span><span class="s5">2</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nbins = </span><span class="s5">9</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nbins = self._nbins</span>

        <span class="s4"># We define ideal ticks with their index:</span>
        <span class="s4"># linscale: ... 1e-3 1e-2 1e-1 1/2 1-1e-1 1-1e-2 1-1e-3 ...</span>
        <span class="s4"># b-scale : ... -3   -2   -1   0   1      2      3      ...</span>
        <span class="s2">def </span><span class="s1">ideal_ticks(x):</span>
            <span class="s2">return </span><span class="s5">10 </span><span class="s1">** x </span><span class="s2">if </span><span class="s1">x &lt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">1 </span><span class="s1">- (</span><span class="s5">10 </span><span class="s1">** (-x)) </span><span class="s2">if </span><span class="s1">x &gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">2</span>

        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.nonsingular(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s1">binf = int(</span>
            <span class="s1">np.floor(np.log10(vmin))</span>
            <span class="s2">if </span><span class="s1">vmin &lt; </span><span class="s5">0.5</span>
            <span class="s2">else </span><span class="s5">0</span>
            <span class="s2">if </span><span class="s1">vmin &lt; </span><span class="s5">0.9</span>
            <span class="s2">else </span><span class="s1">-np.ceil(np.log10(</span><span class="s5">1 </span><span class="s1">- vmin))</span>
        <span class="s1">)</span>
        <span class="s1">bsup = int(</span>
            <span class="s1">np.ceil(np.log10(vmax))</span>
            <span class="s2">if </span><span class="s1">vmax &lt;= </span><span class="s5">0.5</span>
            <span class="s2">else </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">vmax &lt;= </span><span class="s5">0.9</span>
            <span class="s2">else </span><span class="s1">-np.floor(np.log10(</span><span class="s5">1 </span><span class="s1">- vmax))</span>
        <span class="s1">)</span>
        <span class="s1">numideal = bsup - binf - </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">numideal &gt;= </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4"># have 2 or more wanted ideal ticks, so use them as major ticks</span>
            <span class="s2">if </span><span class="s1">numideal &gt; nbins:</span>
                <span class="s4"># to many ideal ticks, subsampling ideals for major ticks, and</span>
                <span class="s4"># take others for minor ticks</span>
                <span class="s1">subsampling_factor = math.ceil(numideal / nbins)</span>
                <span class="s2">if </span><span class="s1">self._minor:</span>
                    <span class="s1">ticklocs = [</span>
                        <span class="s1">ideal_ticks(b)</span>
                        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">range(binf</span><span class="s2">, </span><span class="s1">bsup + </span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">(b % subsampling_factor) != </span><span class="s5">0</span>
                    <span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">ticklocs = [</span>
                        <span class="s1">ideal_ticks(b)</span>
                        <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">range(binf</span><span class="s2">, </span><span class="s1">bsup + </span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">(b % subsampling_factor) == </span><span class="s5">0</span>
                    <span class="s1">]</span>
                <span class="s2">return </span><span class="s1">self.raise_if_exceeds(np.array(ticklocs))</span>
            <span class="s2">if </span><span class="s1">self._minor:</span>
                <span class="s1">ticklocs = []</span>
                <span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">range(binf</span><span class="s2">, </span><span class="s1">bsup):</span>
                    <span class="s2">if </span><span class="s1">b &lt; -</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">ticklocs.extend(np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">) * </span><span class="s5">10 </span><span class="s1">** b)</span>
                    <span class="s2">elif </span><span class="s1">b == -</span><span class="s5">1</span><span class="s1">:</span>
                        <span class="s1">ticklocs.extend(np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">) / </span><span class="s5">10</span><span class="s1">)</span>
                    <span class="s2">elif </span><span class="s1">b == </span><span class="s5">0</span><span class="s1">:</span>
                        <span class="s1">ticklocs.extend(np.arange(</span><span class="s5">6</span><span class="s2">, </span><span class="s5">9</span><span class="s1">) / </span><span class="s5">10</span><span class="s1">)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">ticklocs.extend(</span>
                            <span class="s5">1 </span><span class="s1">- np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">10 </span><span class="s1">** (-b - </span><span class="s5">1</span><span class="s1">)</span>
                        <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self.raise_if_exceeds(np.array(ticklocs))</span>
            <span class="s1">ticklocs = [ideal_ticks(b) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">range(binf</span><span class="s2">, </span><span class="s1">bsup + </span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s2">return </span><span class="s1">self.raise_if_exceeds(np.array(ticklocs))</span>
        <span class="s4"># the scale is zoomed so same ticks as linear scale can be used</span>
        <span class="s2">if </span><span class="s1">self._minor:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">return </span><span class="s1">super().tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">nonsingular(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">standard_minpos = </span><span class="s5">1e-7</span>
        <span class="s1">initial_range = (standard_minpos</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- standard_minpos)</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(vmin) </span><span class="s2">or not </span><span class="s1">np.isfinite(vmax):</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = initial_range  </span><span class="s4"># Initial range, no data plotted yet.</span>
        <span class="s2">elif </span><span class="s1">vmax &lt;= </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">vmin &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s4"># vmax &lt;= 0 occurs when all values are negative</span>
            <span class="s4"># vmin &gt;= 1 occurs when all values are greater than one</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s3">&quot;Data has no values between 0 and 1, and therefore cannot be &quot;</span>
                <span class="s3">&quot;logit-scaled.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = initial_range</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">minpos = (</span>
                <span class="s1">self.axis.get_minpos()</span>
                <span class="s2">if </span><span class="s1">self.axis </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s1">standard_minpos</span>
            <span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(minpos):</span>
                <span class="s1">minpos = standard_minpos  </span><span class="s4"># This should never take effect.</span>
            <span class="s2">if </span><span class="s1">vmin &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">vmin = minpos</span>
            <span class="s4"># NOTE: for vmax, we should query a property similar to get_minpos,</span>
            <span class="s4"># but related to the maximal, less-than-one data point.</span>
            <span class="s4"># Unfortunately, Bbox._minpos is defined very deep in the BBox and</span>
            <span class="s4"># updated with data, so for now we use 1 - minpos as a substitute.</span>
            <span class="s2">if </span><span class="s1">vmax &gt;= </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">vmax = </span><span class="s5">1 </span><span class="s1">- minpos</span>
            <span class="s2">if </span><span class="s1">vmin == vmax:</span>
                <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = </span><span class="s5">0.1 </span><span class="s1">* vmin</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- </span><span class="s5">0.1 </span><span class="s1">* vmin</span>

        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>


<span class="s2">class </span><span class="s1">AutoLocator(MaxNLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Dynamically find major tick positions. This is actually a subclass 
    of `~matplotlib.ticker.MaxNLocator`, with parameters *nbins = 'auto'* 
    and *steps = [1, 2, 2.5, 5, 10]*. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        To know the values of the non-public parameters, please have a 
        look to the defaults of `~matplotlib.ticker.MaxNLocator`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s1">nbins = </span><span class="s5">9</span>
            <span class="s1">steps = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nbins = </span><span class="s3">'auto'</span>
            <span class="s1">steps = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">]</span>
        <span class="s1">super().__init__(nbins=nbins</span><span class="s2">, </span><span class="s1">steps=steps)</span>


<span class="s2">class </span><span class="s1">AutoMinorLocator(Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Dynamically find minor tick positions based on the positions of 
    major ticks. The scale must be linear with major ticks evenly spaced. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">n=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        *n* is the number of subdivisions of the interval between 
        major ticks; e.g., n=2 will place a single minor tick midway 
        between major ticks. 
 
        If *n* is omitted or None, it will be set to 5 or 4. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ndivs = n</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the locations of the ticks.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.axis.get_scale() == </span><span class="s3">'log'</span><span class="s1">:</span>
            <span class="s1">_api.warn_external(</span><span class="s3">'AutoMinorLocator does not work with '</span>
                               <span class="s3">'logarithmic scale'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">majorlocs = self.axis.get_majorticklocs()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">majorstep = majorlocs[</span><span class="s5">1</span><span class="s1">] - majorlocs[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s4"># Need at least two major ticks to find minor tick locations</span>
            <span class="s4"># TODO: Figure out a way to still be able to display minor</span>
            <span class="s4"># ticks without two major ticks visible. For now, just display</span>
            <span class="s4"># no ticks at all.</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s2">if </span><span class="s1">self.ndivs </span><span class="s2">is None</span><span class="s1">:</span>

            <span class="s1">majorstep_no_exponent = </span><span class="s5">10 </span><span class="s1">** (np.log10(majorstep) % </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">np.isclose(majorstep_no_exponent</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">5.0</span><span class="s2">, </span><span class="s5">10.0</span><span class="s1">]).any():</span>
                <span class="s1">ndivs = </span><span class="s5">5</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ndivs = </span><span class="s5">4</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ndivs = self.ndivs</span>

        <span class="s1">minorstep = majorstep / ndivs</span>

        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>

        <span class="s1">t0 = majorlocs[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">tmin = ((vmin - t0) // minorstep + </span><span class="s5">1</span><span class="s1">) * minorstep</span>
        <span class="s1">tmax = ((vmax - t0) // minorstep + </span><span class="s5">1</span><span class="s1">) * minorstep</span>
        <span class="s1">locs = np.arange(tmin</span><span class="s2">, </span><span class="s1">tmax</span><span class="s2">, </span><span class="s1">minorstep) + t0</span>

        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(locs)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Cannot get tick locations for a '</span>
                                  <span class="s3">'%s type.' </span><span class="s1">% type(self))</span>
</pre>
</body>
</html>