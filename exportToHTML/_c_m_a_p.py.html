<html>
<head>
<title>_c_m_a_p.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_c_m_a_p.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools.misc.textTools </span><span class="s0">import </span><span class="s1">bytesjoin</span><span class="s0">, </span><span class="s1">safeEval</span><span class="s0">, </span><span class="s1">readHex</span>
<span class="s0">from </span><span class="s1">fontTools.misc.encodingTools </span><span class="s0">import </span><span class="s1">getEncoding</span>
<span class="s0">from </span><span class="s1">fontTools.ttLib </span><span class="s0">import </span><span class="s1">getSearchRange</span>
<span class="s0">from </span><span class="s1">fontTools.unicode </span><span class="s0">import </span><span class="s1">Unicode</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">DefaultTable</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">struct</span>
<span class="s0">import </span><span class="s1">array</span>
<span class="s0">import </span><span class="s1">logging</span>


<span class="s1">log = logging.getLogger(__name__)</span>


<span class="s0">def </span><span class="s1">_make_map(font</span><span class="s0">, </span><span class="s1">chars</span><span class="s0">, </span><span class="s1">gids):</span>
	<span class="s0">assert </span><span class="s1">len(chars) == len(gids)</span>
	<span class="s1">glyphNames = font.getGlyphNameMany(gids)</span>
	<span class="s1">cmap = {}</span>
	<span class="s0">for </span><span class="s1">char</span><span class="s0">,</span><span class="s1">gid</span><span class="s0">,</span><span class="s1">name </span><span class="s0">in </span><span class="s1">zip(chars</span><span class="s0">,</span><span class="s1">gids</span><span class="s0">,</span><span class="s1">glyphNames):</span>
		<span class="s0">if </span><span class="s1">gid == </span><span class="s2">0</span><span class="s1">:</span>
			<span class="s0">continue</span>
		<span class="s1">cmap[char] = name</span>
	<span class="s0">return </span><span class="s1">cmap</span>

<span class="s0">class </span><span class="s1">table__c_m_a_p(DefaultTable.DefaultTable):</span>
	<span class="s3">&quot;&quot;&quot;Character to Glyph Index Mapping Table 
 
    This class represents the `cmap &lt;https://docs.microsoft.com/en-us/typography/opentype/spec/cmap&gt;`_ 
    table, which maps between input characters (in Unicode or other system encodings) 
    and glyphs within the font. The ``cmap`` table contains one or more subtables 
    which determine the mapping of of characters to glyphs across different platforms 
    and encoding systems. 
 
    ``table__c_m_a_p`` objects expose an accessor ``.tables`` which provides access 
    to the subtables, although it is normally easier to retrieve individual subtables 
    through the utility methods described below. To add new subtables to a font, 
    first determine the subtable format (if in doubt use format 4 for glyphs within 
    the BMP, format 12 for glyphs outside the BMP, and format 14 for Unicode Variation 
    Sequences) construct subtable objects with ``CmapSubtable.newSubtable(format)``, 
    and append them to the ``.tables`` list. 
 
    Within a subtable, the mapping of characters to glyphs is provided by the ``.cmap`` 
    attribute. 
 
    Example:: 
 
        cmap4_0_3 = CmapSubtable.newSubtable(4) 
        cmap4_0_3.platformID = 0 
        cmap4_0_3.platEncID = 3 
        cmap4_0_3.language = 0 
        cmap4_0_3.cmap = { 0xC1: &quot;Aacute&quot; } 
 
        cmap = newTable(&quot;cmap&quot;) 
        cmap.tableVersion = 0 
        cmap.tables = [cmap4_0_3] 
    &quot;&quot;&quot;</span>

	<span class="s0">def </span><span class="s1">getcmap(self</span><span class="s0">, </span><span class="s1">platformID</span><span class="s0">, </span><span class="s1">platEncID):</span>
		<span class="s3">&quot;&quot;&quot;Returns the first subtable which matches the given platform and encoding. 
 
        Args: 
            platformID (int): The platform ID. Use 0 for Unicode, 1 for Macintosh 
                (deprecated for new fonts), 2 for ISO (deprecated) and 3 for Windows. 
            encodingID (int): Encoding ID. Interpretation depends on the platform ID. 
                See the OpenType specification for details. 
 
        Returns: 
            An object which is a subclass of :py:class:`CmapSubtable` if a matching 
            subtable is found within the font, or ``None`` otherwise. 
        &quot;&quot;&quot;</span>

		<span class="s0">for </span><span class="s1">subtable </span><span class="s0">in </span><span class="s1">self.tables:</span>
			<span class="s0">if </span><span class="s1">(subtable.platformID == platformID </span><span class="s0">and</span>
					<span class="s1">subtable.platEncID == platEncID):</span>
				<span class="s0">return </span><span class="s1">subtable</span>
		<span class="s0">return None </span><span class="s4"># not found</span>

	<span class="s0">def </span><span class="s1">getBestCmap(self</span><span class="s0">, </span><span class="s1">cmapPreferences=((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))):</span>
		<span class="s3">&quot;&quot;&quot;Returns the 'best' Unicode cmap dictionary available in the font 
        or ``None``, if no Unicode cmap subtable is available. 
 
        By default it will search for the following (platformID, platEncID) 
        pairs in order:: 
 
                (3, 10), # Windows Unicode full repertoire 
                (0, 6),  # Unicode full repertoire (format 13 subtable) 
                (0, 4),  # Unicode 2.0 full repertoire 
                (3, 1),  # Windows Unicode BMP 
                (0, 3),  # Unicode 2.0 BMP 
                (0, 2),  # Unicode ISO/IEC 10646 
                (0, 1),  # Unicode 1.1 
                (0, 0)   # Unicode 1.0 
 
        This particular order matches what HarfBuzz uses to choose what 
        subtable to use by default. This order prefers the largest-repertoire 
        subtable, and among those, prefers the Windows-platform over the 
        Unicode-platform as the former has wider support. 
 
        This order can be customized via the ``cmapPreferences`` argument. 
        &quot;&quot;&quot;</span>
		<span class="s0">for </span><span class="s1">platformID</span><span class="s0">, </span><span class="s1">platEncID </span><span class="s0">in </span><span class="s1">cmapPreferences:</span>
			<span class="s1">cmapSubtable = self.getcmap(platformID</span><span class="s0">, </span><span class="s1">platEncID)</span>
			<span class="s0">if </span><span class="s1">cmapSubtable </span><span class="s0">is not None</span><span class="s1">:</span>
				<span class="s0">return </span><span class="s1">cmapSubtable.cmap</span>
		<span class="s0">return None  </span><span class="s4"># None of the requested cmap subtables were found</span>

	<span class="s0">def </span><span class="s1">buildReversed(self):</span>
		<span class="s3">&quot;&quot;&quot;Builds a reverse mapping dictionary 
 
        Iterates over all Unicode cmap tables and returns a dictionary mapping 
        glyphs to sets of codepoints, such as:: 
 
            { 
                'one': {0x31} 
                'A': {0x41,0x391} 
            } 
 
        The values are sets of Unicode codepoints because 
        some fonts map different codepoints to the same glyph. 
        For example, ``U+0041 LATIN CAPITAL LETTER A`` and ``U+0391 
        GREEK CAPITAL LETTER ALPHA`` are sometimes the same glyph. 
        &quot;&quot;&quot;</span>
		<span class="s1">result = {}</span>
		<span class="s0">for </span><span class="s1">subtable </span><span class="s0">in </span><span class="s1">self.tables:</span>
			<span class="s0">if </span><span class="s1">subtable.isUnicode():</span>
				<span class="s0">for </span><span class="s1">codepoint</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">subtable.cmap.items():</span>
					<span class="s1">result.setdefault(name</span><span class="s0">, </span><span class="s1">set()).add(codepoint)</span>
		<span class="s0">return </span><span class="s1">result</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">tableVersion</span><span class="s0">, </span><span class="s1">numSubTables = struct.unpack(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">4</span><span class="s1">])</span>
		<span class="s1">self.tableVersion = int(tableVersion)</span>
		<span class="s1">self.tables = tables = []</span>
		<span class="s1">seenOffsets = {}</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(numSubTables):</span>
			<span class="s1">platformID</span><span class="s0">, </span><span class="s1">platEncID</span><span class="s0">, </span><span class="s1">offset = struct.unpack(</span>
					<span class="s5">&quot;&gt;HHl&quot;</span><span class="s0">, </span><span class="s1">data[</span><span class="s2">4</span><span class="s1">+i*</span><span class="s2">8</span><span class="s1">:</span><span class="s2">4</span><span class="s1">+(i+</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">8</span><span class="s1">])</span>
			<span class="s1">platformID</span><span class="s0">, </span><span class="s1">platEncID = int(platformID)</span><span class="s0">, </span><span class="s1">int(platEncID)</span>
			<span class="s1">format</span><span class="s0">, </span><span class="s1">length = struct.unpack(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">data[offset:offset+</span><span class="s2">4</span><span class="s1">])</span>
			<span class="s0">if </span><span class="s1">format </span><span class="s0">in </span><span class="s1">[</span><span class="s2">8</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">13</span><span class="s1">]:</span>
				<span class="s1">format</span><span class="s0">, </span><span class="s1">reserved</span><span class="s0">, </span><span class="s1">length = struct.unpack(</span><span class="s5">&quot;&gt;HHL&quot;</span><span class="s0">, </span><span class="s1">data[offset:offset+</span><span class="s2">8</span><span class="s1">])</span>
			<span class="s0">elif </span><span class="s1">format </span><span class="s0">in </span><span class="s1">[</span><span class="s2">14</span><span class="s1">]:</span>
				<span class="s1">format</span><span class="s0">, </span><span class="s1">length = struct.unpack(</span><span class="s5">&quot;&gt;HL&quot;</span><span class="s0">, </span><span class="s1">data[offset:offset+</span><span class="s2">6</span><span class="s1">])</span>

			<span class="s0">if not </span><span class="s1">length:</span>
				<span class="s1">log.error(</span>
					<span class="s5">&quot;cmap subtable is reported as having zero length: platformID %s, &quot;</span>
					<span class="s5">&quot;platEncID %s, format %s offset %s. Skipping table.&quot;</span><span class="s0">,</span>
					<span class="s1">platformID</span><span class="s0">, </span><span class="s1">platEncID</span><span class="s0">, </span><span class="s1">format</span><span class="s0">, </span><span class="s1">offset)</span>
				<span class="s0">continue</span>
			<span class="s1">table = CmapSubtable.newSubtable(format)</span>
			<span class="s1">table.platformID = platformID</span>
			<span class="s1">table.platEncID = platEncID</span>
			<span class="s4"># Note that by default we decompile only the subtable header info;</span>
			<span class="s4"># any other data gets decompiled only when an attribute of the</span>
			<span class="s4"># subtable is referenced.</span>
			<span class="s1">table.decompileHeader(data[offset:offset+int(length)]</span><span class="s0">, </span><span class="s1">ttFont)</span>
			<span class="s0">if </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">seenOffsets:</span>
				<span class="s1">table.data = </span><span class="s0">None </span><span class="s4"># Mark as decompiled</span>
				<span class="s1">table.cmap = tables[seenOffsets[offset]].cmap</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">seenOffsets[offset] = i</span>
			<span class="s1">tables.append(table)</span>
		<span class="s0">if </span><span class="s1">ttFont.lazy </span><span class="s0">is False</span><span class="s1">:  </span><span class="s4"># Be lazy for None and True</span>
			<span class="s1">self.ensureDecompiled()</span>

	<span class="s0">def </span><span class="s1">ensureDecompiled(self</span><span class="s0">, </span><span class="s1">recurse=</span><span class="s0">False</span><span class="s1">):</span>
		<span class="s4"># The recurse argument is unused, but part of the signature of</span>
		<span class="s4"># ensureDecompiled across the library.</span>
		<span class="s0">for </span><span class="s1">st </span><span class="s0">in </span><span class="s1">self.tables:</span>
			<span class="s1">st.ensureDecompiled()</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.tables.sort()  </span><span class="s4"># sort according to the spec; see CmapSubtable.__lt__()</span>
		<span class="s1">numSubTables = len(self.tables)</span>
		<span class="s1">totalOffset = </span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">8 </span><span class="s1">* numSubTables</span>
		<span class="s1">data = struct.pack(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">self.tableVersion</span><span class="s0">, </span><span class="s1">numSubTables)</span>
		<span class="s1">tableData = </span><span class="s6">b&quot;&quot;</span>
		<span class="s1">seen = {}  </span><span class="s4"># Some tables are the same object reference. Don't compile them twice.</span>
		<span class="s1">done = {}  </span><span class="s4"># Some tables are different objects, but compile to the same data chunk</span>
		<span class="s0">for </span><span class="s1">table </span><span class="s0">in </span><span class="s1">self.tables:</span>
			<span class="s1">offset = seen.get(id(table.cmap))</span>
			<span class="s0">if </span><span class="s1">offset </span><span class="s0">is None</span><span class="s1">:</span>
				<span class="s1">chunk = table.compile(ttFont)</span>
				<span class="s1">offset = done.get(chunk)</span>
				<span class="s0">if </span><span class="s1">offset </span><span class="s0">is None</span><span class="s1">:</span>
					<span class="s1">offset = seen[id(table.cmap)] = done[chunk] = totalOffset + len(tableData)</span>
					<span class="s1">tableData = tableData + chunk</span>
			<span class="s1">data = data + struct.pack(</span><span class="s5">&quot;&gt;HHl&quot;</span><span class="s0">, </span><span class="s1">table.platformID</span><span class="s0">, </span><span class="s1">table.platEncID</span><span class="s0">, </span><span class="s1">offset)</span>
		<span class="s0">return </span><span class="s1">data + tableData</span>

	<span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">writer.simpletag(</span><span class="s5">&quot;tableVersion&quot;</span><span class="s0">, </span><span class="s1">version=self.tableVersion)</span>
		<span class="s1">writer.newline()</span>
		<span class="s0">for </span><span class="s1">table </span><span class="s0">in </span><span class="s1">self.tables:</span>
			<span class="s1">table.toXML(writer</span><span class="s0">, </span><span class="s1">ttFont)</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">name == </span><span class="s5">&quot;tableVersion&quot;</span><span class="s1">:</span>
			<span class="s1">self.tableVersion = safeEval(attrs[</span><span class="s5">&quot;version&quot;</span><span class="s1">])</span>
			<span class="s0">return</span>
		<span class="s0">if </span><span class="s1">name[:</span><span class="s2">12</span><span class="s1">] != </span><span class="s5">&quot;cmap_format_&quot;</span><span class="s1">:</span>
			<span class="s0">return</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;tables&quot;</span><span class="s1">):</span>
			<span class="s1">self.tables = []</span>
		<span class="s1">format = safeEval(name[</span><span class="s2">12</span><span class="s1">:])</span>
		<span class="s1">table = CmapSubtable.newSubtable(format)</span>
		<span class="s1">table.platformID = safeEval(attrs[</span><span class="s5">&quot;platformID&quot;</span><span class="s1">])</span>
		<span class="s1">table.platEncID = safeEval(attrs[</span><span class="s5">&quot;platEncID&quot;</span><span class="s1">])</span>
		<span class="s1">table.fromXML(name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s1">self.tables.append(table)</span>


<span class="s0">class </span><span class="s1">CmapSubtable(object):</span>
	<span class="s3">&quot;&quot;&quot;Base class for all cmap subtable formats. 
 
    Subclasses which handle the individual subtable formats are named 
    ``cmap_format_0``, ``cmap_format_2`` etc. Use :py:meth:`getSubtableClass` 
    to retrieve the concrete subclass, or :py:meth:`newSubtable` to get a 
    new subtable object for a given format. 
 
    The object exposes a ``.cmap`` attribute, which contains a dictionary mapping 
    character codepoints to glyph names. 
    &quot;&quot;&quot;</span>

	<span class="s1">@staticmethod</span>
	<span class="s0">def </span><span class="s1">getSubtableClass(format):</span>
		<span class="s3">&quot;&quot;&quot;Return the subtable class for a format.&quot;&quot;&quot;</span>
		<span class="s0">return </span><span class="s1">cmap_classes.get(format</span><span class="s0">, </span><span class="s1">cmap_format_unknown)</span>

	<span class="s1">@staticmethod</span>
	<span class="s0">def </span><span class="s1">newSubtable(format):</span>
		<span class="s3">&quot;&quot;&quot;Return a new instance of a subtable for the given format 
        .&quot;&quot;&quot;</span>
		<span class="s1">subtableClass = CmapSubtable.getSubtableClass(format)</span>
		<span class="s0">return </span><span class="s1">subtableClass(format)</span>

	<span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">format):</span>
		<span class="s1">self.format = format</span>
		<span class="s1">self.data = </span><span class="s0">None</span>
		<span class="s1">self.ttFont = </span><span class="s0">None</span>
		<span class="s1">self.platformID = </span><span class="s0">None  </span><span class="s4">#: The platform ID of this subtable</span>
		<span class="s1">self.platEncID = </span><span class="s0">None   </span><span class="s4">#: The encoding ID of this subtable (interpretation depends on ``platformID``)</span>
		<span class="s1">self.language = </span><span class="s0">None    </span><span class="s4">#: The language ID of this subtable (Macintosh platform only)</span>

	<span class="s0">def </span><span class="s1">ensureDecompiled(self</span><span class="s0">, </span><span class="s1">recurse=</span><span class="s0">False</span><span class="s1">):</span>
		<span class="s4"># The recurse argument is unused, but part of the signature of</span>
		<span class="s4"># ensureDecompiled across the library.</span>
		<span class="s0">if </span><span class="s1">self.data </span><span class="s0">is None</span><span class="s1">:</span>
			<span class="s0">return</span>
		<span class="s1">self.decompile(</span><span class="s0">None, None</span><span class="s1">) </span><span class="s4"># use saved data.</span>
		<span class="s1">self.data = </span><span class="s0">None	</span><span class="s4"># Once this table has been decompiled, make sure we don't</span>
							<span class="s4"># just return the original data. Also avoids recursion when</span>
							<span class="s4"># called with an attribute that the cmap subtable doesn't have.</span>

	<span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">attr):</span>
		<span class="s4"># allow lazy decompilation of subtables.</span>
		<span class="s0">if </span><span class="s1">attr[:</span><span class="s2">2</span><span class="s1">] == </span><span class="s5">'__'</span><span class="s1">: </span><span class="s4"># don't handle requests for member functions like '__lt__'</span>
			<span class="s0">raise </span><span class="s1">AttributeError(attr)</span>
		<span class="s0">if </span><span class="s1">self.data </span><span class="s0">is None</span><span class="s1">:</span>
			<span class="s0">raise </span><span class="s1">AttributeError(attr)</span>
		<span class="s1">self.ensureDecompiled()</span>
		<span class="s0">return </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">attr)</span>

	<span class="s0">def </span><span class="s1">decompileHeader(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">format</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">language = struct.unpack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">6</span><span class="s1">])</span>
		<span class="s0">assert </span><span class="s1">len(data) == length</span><span class="s0">, </span><span class="s5">&quot;corrupt cmap table format %d (data length: %d, header length: %d)&quot; </span><span class="s1">% (format</span><span class="s0">, </span><span class="s1">len(data)</span><span class="s0">, </span><span class="s1">length)</span>
		<span class="s1">self.format = int(format)</span>
		<span class="s1">self.length = int(length)</span>
		<span class="s1">self.language = int(language)</span>
		<span class="s1">self.data = data[</span><span class="s2">6</span><span class="s1">:]</span>
		<span class="s1">self.ttFont = ttFont</span>

	<span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">writer.begintag(self.__class__.__name__</span><span class="s0">, </span><span class="s1">[</span>
				<span class="s1">(</span><span class="s5">&quot;platformID&quot;</span><span class="s0">, </span><span class="s1">self.platformID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, </span><span class="s1">self.platEncID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;language&quot;</span><span class="s0">, </span><span class="s1">self.language)</span><span class="s0">,</span>
				<span class="s1">])</span>
		<span class="s1">writer.newline()</span>
		<span class="s1">codes = sorted(self.cmap.items())</span>
		<span class="s1">self._writeCodes(codes</span><span class="s0">, </span><span class="s1">writer)</span>
		<span class="s1">writer.endtag(self.__class__.__name__)</span>
		<span class="s1">writer.newline()</span>

	<span class="s0">def </span><span class="s1">getEncoding(self</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
		<span class="s3">&quot;&quot;&quot;Returns the Python encoding name for this cmap subtable based on its platformID, 
        platEncID, and language.  If encoding for these values is not known, by default 
        ``None`` is returned.  That can be overridden by passing a value to the ``default`` 
        argument. 
 
        Note that if you want to choose a &quot;preferred&quot; cmap subtable, most of the time 
        ``self.isUnicode()`` is what you want as that one only returns true for the modern, 
        commonly used, Unicode-compatible triplets, not the legacy ones. 
        &quot;&quot;&quot;</span>
		<span class="s0">return </span><span class="s1">getEncoding(self.platformID</span><span class="s0">, </span><span class="s1">self.platEncID</span><span class="s0">, </span><span class="s1">self.language</span><span class="s0">, </span><span class="s1">default)</span>

	<span class="s0">def </span><span class="s1">isUnicode(self):</span>
		<span class="s3">&quot;&quot;&quot;Returns true if the characters are interpreted as Unicode codepoints.&quot;&quot;&quot;</span>
		<span class="s0">return </span><span class="s1">(self.platformID == </span><span class="s2">0 </span><span class="s0">or</span>
			<span class="s1">(self.platformID == </span><span class="s2">3 </span><span class="s0">and </span><span class="s1">self.platEncID </span><span class="s0">in </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]))</span>

	<span class="s0">def </span><span class="s1">isSymbol(self):</span>
		<span class="s3">&quot;&quot;&quot;Returns true if the subtable is for the Symbol encoding (3,0)&quot;&quot;&quot;</span>
		<span class="s0">return </span><span class="s1">self.platformID == </span><span class="s2">3 </span><span class="s0">and </span><span class="s1">self.platEncID == </span><span class="s2">0</span>

	<span class="s0">def </span><span class="s1">_writeCodes(self</span><span class="s0">, </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">writer):</span>
		<span class="s1">isUnicode = self.isUnicode()</span>
		<span class="s0">for </span><span class="s1">code</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">codes:</span>
			<span class="s1">writer.simpletag(</span><span class="s5">&quot;map&quot;</span><span class="s0">, </span><span class="s1">code=hex(code)</span><span class="s0">, </span><span class="s1">name=name)</span>
			<span class="s0">if </span><span class="s1">isUnicode:</span>
				<span class="s1">writer.comment(Unicode[code])</span>
			<span class="s1">writer.newline()</span>

	<span class="s0">def </span><span class="s1">__lt__(self</span><span class="s0">, </span><span class="s1">other):</span>
		<span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">CmapSubtable):</span>
			<span class="s0">return </span><span class="s1">NotImplemented</span>

		<span class="s4"># implemented so that list.sort() sorts according to the spec.</span>
		<span class="s1">selfTuple = (</span>
			<span class="s1">getattr(self</span><span class="s0">, </span><span class="s5">&quot;platformID&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">getattr(self</span><span class="s0">, </span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">getattr(self</span><span class="s0">, </span><span class="s5">&quot;language&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">self.__dict__)</span>
		<span class="s1">otherTuple = (</span>
			<span class="s1">getattr(other</span><span class="s0">, </span><span class="s5">&quot;platformID&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">getattr(other</span><span class="s0">, </span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">getattr(other</span><span class="s0">, </span><span class="s5">&quot;language&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
			<span class="s1">other.__dict__)</span>
		<span class="s0">return </span><span class="s1">selfTuple &lt; otherTuple</span>


<span class="s0">class </span><span class="s1">cmap_format_0(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>
		<span class="s1">data = self.data </span><span class="s4"># decompileHeader assigns the data after the header to self.data</span>
		<span class="s0">assert </span><span class="s2">262 </span><span class="s1">== self.length</span><span class="s0">, </span><span class="s5">&quot;Format 0 cmap subtable not 262 bytes&quot;</span>
		<span class="s1">gids = array.array(</span><span class="s5">&quot;B&quot;</span><span class="s1">)</span>
		<span class="s1">gids.frombytes(self.data)</span>
		<span class="s1">charCodes = list(range(len(gids)))</span>
		<span class="s1">self.cmap = _make_map(self.ttFont</span><span class="s0">, </span><span class="s1">charCodes</span><span class="s0">, </span><span class="s1">gids)</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">262</span><span class="s0">, </span><span class="s1">self.language) + self.data</span>

		<span class="s1">cmap = self.cmap</span>
		<span class="s0">assert </span><span class="s1">set(cmap.keys()).issubset(range(</span><span class="s2">256</span><span class="s1">))</span>
		<span class="s1">getGlyphID = ttFont.getGlyphID</span>
		<span class="s1">valueList = [getGlyphID(cmap[i]) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">cmap </span><span class="s0">else </span><span class="s2">0 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">256</span><span class="s1">)]</span>

		<span class="s1">gids = array.array(</span><span class="s5">&quot;B&quot;</span><span class="s0">, </span><span class="s1">valueList)</span>
		<span class="s1">data = struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">262</span><span class="s0">, </span><span class="s1">self.language) + gids.tobytes()</span>
		<span class="s0">assert </span><span class="s1">len(data) == </span><span class="s2">262</span>
		<span class="s0">return </span><span class="s1">data</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = safeEval(attrs[</span><span class="s5">&quot;language&quot;</span><span class="s1">])</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {}</span>
		<span class="s1">cmap = self.cmap</span>
		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content = element</span>
			<span class="s0">if </span><span class="s1">name != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">cmap[safeEval(attrs[</span><span class="s5">&quot;code&quot;</span><span class="s1">])] = attrs[</span><span class="s5">&quot;name&quot;</span><span class="s1">]</span>


<span class="s1">subHeaderFormat = </span><span class="s5">&quot;&gt;HHhH&quot;</span>
<span class="s0">class </span><span class="s1">SubHeader(object):</span>
	<span class="s0">def </span><span class="s1">__init__(self):</span>
		<span class="s1">self.firstCode = </span><span class="s0">None</span>
		<span class="s1">self.entryCount = </span><span class="s0">None</span>
		<span class="s1">self.idDelta = </span><span class="s0">None</span>
		<span class="s1">self.idRangeOffset = </span><span class="s0">None</span>
		<span class="s1">self.glyphIndexArray = []</span>

<span class="s0">class </span><span class="s1">cmap_format_2(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">setIDDelta(self</span><span class="s0">, </span><span class="s1">subHeader):</span>
		<span class="s1">subHeader.idDelta = </span><span class="s2">0</span>
		<span class="s4"># find the minGI which is not zero.</span>
		<span class="s1">minGI = subHeader.glyphIndexArray[</span><span class="s2">0</span><span class="s1">]</span>
		<span class="s0">for </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">subHeader.glyphIndexArray:</span>
			<span class="s0">if </span><span class="s1">(gid != </span><span class="s2">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(gid &lt; minGI):</span>
				<span class="s1">minGI = gid</span>
		<span class="s4"># The lowest gid in glyphIndexArray, after subtracting idDelta, must be 1.</span>
		<span class="s4"># idDelta is a short, and must be between -32K and 32K. minGI can be between 1 and 64K.</span>
		<span class="s4"># We would like to pick an idDelta such that the first glyphArray GID is 1,</span>
		<span class="s4"># so that we are more likely to be able to combine glypharray GID subranges.</span>
		<span class="s4"># This means that we have a problem when minGI is &gt; 32K</span>
		<span class="s4"># Since the final gi is reconstructed from the glyphArray GID by:</span>
		<span class="s4">#    (short)finalGID = (gid + idDelta) % 0x10000),</span>
		<span class="s4"># we can get from a glypharray GID of 1 to a final GID of 65K by subtracting 2, and casting the</span>
		<span class="s4"># negative number to an unsigned short.</span>

		<span class="s0">if </span><span class="s1">(minGI &gt; </span><span class="s2">1</span><span class="s1">):</span>
			<span class="s0">if </span><span class="s1">minGI &gt; </span><span class="s2">0x7FFF</span><span class="s1">:</span>
				<span class="s1">subHeader.idDelta = -(</span><span class="s2">0x10000 </span><span class="s1">- minGI) -</span><span class="s2">1</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">subHeader.idDelta = minGI -</span><span class="s2">1</span>
			<span class="s1">idDelta = subHeader.idDelta</span>
			<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(subHeader.entryCount):</span>
				<span class="s1">gid = subHeader.glyphIndexArray[i]</span>
				<span class="s0">if </span><span class="s1">gid &gt; </span><span class="s2">0</span><span class="s1">:</span>
					<span class="s1">subHeader.glyphIndexArray[i] = gid - idDelta</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>

		<span class="s1">data = self.data </span><span class="s4"># decompileHeader assigns the data after the header to self.data</span>
		<span class="s1">subHeaderKeys = []</span>
		<span class="s1">maxSubHeaderindex = </span><span class="s2">0</span>
		<span class="s4"># get the key array, and determine the number of subHeaders.</span>
		<span class="s1">allKeys = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s1">)</span>
		<span class="s1">allKeys.frombytes(data[:</span><span class="s2">512</span><span class="s1">])</span>
		<span class="s1">data = data[</span><span class="s2">512</span><span class="s1">:]</span>
		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: allKeys.byteswap()</span>
		<span class="s1">subHeaderKeys = [ key//</span><span class="s2">8 </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">allKeys]</span>
		<span class="s1">maxSubHeaderindex = max(subHeaderKeys)</span>

		<span class="s4">#Load subHeaders</span>
		<span class="s1">subHeaderList = []</span>
		<span class="s1">pos = </span><span class="s2">0</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(maxSubHeaderindex + </span><span class="s2">1</span><span class="s1">):</span>
			<span class="s1">subHeader = SubHeader()</span>
			<span class="s1">(subHeader.firstCode</span><span class="s0">, </span><span class="s1">subHeader.entryCount</span><span class="s0">, </span><span class="s1">subHeader.idDelta</span><span class="s0">, </span><span class="s1">\</span>
				<span class="s1">subHeader.idRangeOffset) = struct.unpack(subHeaderFormat</span><span class="s0">, </span><span class="s1">data[pos:pos + </span><span class="s2">8</span><span class="s1">])</span>
			<span class="s1">pos += </span><span class="s2">8</span>
			<span class="s1">giDataPos = pos + subHeader.idRangeOffset-</span><span class="s2">2</span>
			<span class="s1">giList = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s1">)</span>
			<span class="s1">giList.frombytes(data[giDataPos:giDataPos + subHeader.entryCount*</span><span class="s2">2</span><span class="s1">])</span>
			<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: giList.byteswap()</span>
			<span class="s1">subHeader.glyphIndexArray = giList</span>
			<span class="s1">subHeaderList.append(subHeader)</span>
		<span class="s4"># How this gets processed.</span>
		<span class="s4"># Charcodes may be one or two bytes.</span>
		<span class="s4"># The first byte of a charcode is mapped through the subHeaderKeys, to select</span>
		<span class="s4"># a subHeader. For any subheader but 0, the next byte is then mapped through the</span>
		<span class="s4"># selected subheader. If subheader Index 0 is selected, then the byte itself is</span>
		<span class="s4"># mapped through the subheader, and there is no second byte.</span>
		<span class="s4"># Then assume that the subsequent byte is the first byte of the next charcode,and repeat.</span>
		<span class="s4">#</span>
		<span class="s4"># Each subheader references a range in the glyphIndexArray whose length is entryCount.</span>
		<span class="s4"># The range in glyphIndexArray referenced by a sunheader may overlap with the range in glyphIndexArray</span>
		<span class="s4"># referenced by another subheader.</span>
		<span class="s4"># The only subheader that will be referenced by more than one first-byte value is the subheader</span>
		<span class="s4"># that maps the entire range of glyphID values to glyphIndex 0, e.g notdef:</span>
		<span class="s4">#    {firstChar 0, EntryCount 0,idDelta 0,idRangeOffset xx}</span>
		<span class="s4"># A byte being mapped though a subheader is treated as in index into a mapping of array index to font glyphIndex.</span>
		<span class="s4"># A subheader specifies a subrange within (0...256) by the</span>
		<span class="s4"># firstChar and EntryCount values. If the byte value is outside the subrange, then the glyphIndex is zero</span>
		<span class="s4"># (e.g. glyph not in font).</span>
		<span class="s4"># If the byte index is in the subrange, then an offset index is calculated as (byteIndex - firstChar).</span>
		<span class="s4"># The index to glyphIndex mapping is a subrange of the glyphIndexArray. You find the start of the subrange by</span>
		<span class="s4"># counting idRangeOffset bytes from the idRangeOffset word. The first value in this subrange is the</span>
		<span class="s4"># glyphIndex for the index firstChar. The offset index should then be used in this array to get the glyphIndex.</span>
		<span class="s4"># Example for Logocut-Medium</span>
		<span class="s4"># first byte of charcode = 129; selects subheader 1.</span>
		<span class="s4"># subheader 1 = {firstChar 64, EntryCount 108,idDelta 42,idRangeOffset 0252}</span>
		<span class="s4"># second byte of charCode = 66</span>
		<span class="s4"># the index offset = 66-64 = 2.</span>
		<span class="s4"># The subrange of the glyphIndexArray starting at 0x0252 bytes from the idRangeOffset word is:</span>
		<span class="s4"># [glyphIndexArray index], [subrange array index] = glyphIndex</span>
		<span class="s4"># [256], [0]=1  from charcode [129, 64]</span>
		<span class="s4"># [257], [1]=2      from charcode [129, 65]</span>
		<span class="s4"># [258], [2]=3      from charcode [129, 66]</span>
		<span class="s4"># [259], [3]=4      from charcode [129, 67]</span>
		<span class="s4"># So, the glyphIndex = 3 from the array. Then if idDelta is not zero and the glyph ID is not zero,</span>
		<span class="s4"># add it to the glyphID to get the final glyphIndex</span>
		<span class="s4"># value. In this case the final glyph index = 3+ 42 -&gt; 45 for the final glyphIndex. Whew!</span>

		<span class="s1">self.data = </span><span class="s6">b&quot;&quot;</span>
		<span class="s1">cmap = {}</span>
		<span class="s1">notdefGI = </span><span class="s2">0</span>
		<span class="s0">for </span><span class="s1">firstByte </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">256</span><span class="s1">):</span>
			<span class="s1">subHeadindex = subHeaderKeys[firstByte]</span>
			<span class="s1">subHeader = subHeaderList[subHeadindex]</span>
			<span class="s0">if </span><span class="s1">subHeadindex == </span><span class="s2">0</span><span class="s1">:</span>
				<span class="s0">if </span><span class="s1">(firstByte &lt; subHeader.firstCode) </span><span class="s0">or </span><span class="s1">(firstByte &gt;= subHeader.firstCode + subHeader.entryCount):</span>
					<span class="s0">continue </span><span class="s4"># gi is notdef.</span>
				<span class="s0">else</span><span class="s1">:</span>
					<span class="s1">charCode = firstByte</span>
					<span class="s1">offsetIndex = firstByte - subHeader.firstCode</span>
					<span class="s1">gi = subHeader.glyphIndexArray[offsetIndex]</span>
					<span class="s0">if </span><span class="s1">gi != </span><span class="s2">0</span><span class="s1">:</span>
						<span class="s1">gi = (gi + subHeader.idDelta) % </span><span class="s2">0x10000</span>
					<span class="s0">else</span><span class="s1">:</span>
						<span class="s0">continue </span><span class="s4"># gi is notdef.</span>
				<span class="s1">cmap[charCode] = gi</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s0">if </span><span class="s1">subHeader.entryCount:</span>
					<span class="s1">charCodeOffset = firstByte * </span><span class="s2">256 </span><span class="s1">+ subHeader.firstCode</span>
					<span class="s0">for </span><span class="s1">offsetIndex </span><span class="s0">in </span><span class="s1">range(subHeader.entryCount):</span>
						<span class="s1">charCode = charCodeOffset + offsetIndex</span>
						<span class="s1">gi = subHeader.glyphIndexArray[offsetIndex]</span>
						<span class="s0">if </span><span class="s1">gi != </span><span class="s2">0</span><span class="s1">:</span>
							<span class="s1">gi = (gi + subHeader.idDelta) % </span><span class="s2">0x10000</span>
						<span class="s0">else</span><span class="s1">:</span>
							<span class="s0">continue</span>
						<span class="s1">cmap[charCode] = gi</span>
				<span class="s4"># If not subHeader.entryCount, then all char codes with this first byte are</span>
				<span class="s4"># mapped to .notdef. We can skip this subtable, and leave the glyphs un-encoded, which is the</span>
				<span class="s4"># same as mapping it to .notdef.</span>

		<span class="s1">gids = list(cmap.values())</span>
		<span class="s1">charCodes = list(cmap.keys())</span>
		<span class="s1">self.cmap = _make_map(self.ttFont</span><span class="s0">, </span><span class="s1">charCodes</span><span class="s0">, </span><span class="s1">gids)</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.language) + self.data</span>
		<span class="s1">kEmptyTwoCharCodeRange = -</span><span class="s2">1</span>
		<span class="s1">notdefGI = </span><span class="s2">0</span>

		<span class="s1">items = sorted(self.cmap.items())</span>
		<span class="s1">charCodes = [item[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items]</span>
		<span class="s1">names = [item[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">items]</span>
		<span class="s1">nameMap = ttFont.getReverseGlyphMap()</span>
		<span class="s0">try</span><span class="s1">:</span>
			<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
		<span class="s0">except </span><span class="s1">KeyError:</span>
			<span class="s1">nameMap = ttFont.getReverseGlyphMap(rebuild=</span><span class="s0">True</span><span class="s1">)</span>
			<span class="s0">try</span><span class="s1">:</span>
				<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
			<span class="s0">except </span><span class="s1">KeyError:</span>
				<span class="s4"># allow virtual GIDs in format 2 tables</span>
				<span class="s1">gids = []</span>
				<span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
					<span class="s0">try</span><span class="s1">:</span>
						<span class="s1">gid = nameMap[name]</span>
					<span class="s0">except </span><span class="s1">KeyError:</span>
						<span class="s0">try</span><span class="s1">:</span>
							<span class="s0">if </span><span class="s1">(name[:</span><span class="s2">3</span><span class="s1">] == </span><span class="s5">'gid'</span><span class="s1">):</span>
								<span class="s1">gid = int(name[</span><span class="s2">3</span><span class="s1">:])</span>
							<span class="s0">else</span><span class="s1">:</span>
								<span class="s1">gid = ttFont.getGlyphID(name)</span>
						<span class="s0">except</span><span class="s1">:</span>
							<span class="s0">raise </span><span class="s1">KeyError(name)</span>

					<span class="s1">gids.append(gid)</span>

		<span class="s4"># Process the (char code to gid) item list in char code order.</span>
		<span class="s4"># By definition, all one byte char codes map to subheader 0.</span>
		<span class="s4"># For all the two byte char codes, we assume that the first byte maps maps to the empty subhead (with an entry count of 0,</span>
		<span class="s4"># which defines all char codes in its range to map to notdef) unless proven otherwise.</span>
		<span class="s4"># Note that since the char code items are processed in char code order, all the char codes with the</span>
		<span class="s4"># same first byte are in sequential order.</span>

		<span class="s1">subHeaderKeys = [kEmptyTwoCharCodeRange </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">256</span><span class="s1">)] </span><span class="s4"># list of indices into subHeaderList.</span>
		<span class="s1">subHeaderList = []</span>

		<span class="s4"># We force this subheader entry 0 to exist in the subHeaderList in the case where some one comes up</span>
		<span class="s4"># with a cmap where all the one byte char codes map to notdef,</span>
		<span class="s4"># with the result that the subhead 0 would not get created just by processing the item list.</span>
		<span class="s1">charCode = charCodes[</span><span class="s2">0</span><span class="s1">]</span>
		<span class="s0">if </span><span class="s1">charCode &gt; </span><span class="s2">255</span><span class="s1">:</span>
			<span class="s1">subHeader = SubHeader()</span>
			<span class="s1">subHeader.firstCode = </span><span class="s2">0</span>
			<span class="s1">subHeader.entryCount = </span><span class="s2">0</span>
			<span class="s1">subHeader.idDelta = </span><span class="s2">0</span>
			<span class="s1">subHeader.idRangeOffset = </span><span class="s2">0</span>
			<span class="s1">subHeaderList.append(subHeader)</span>

		<span class="s1">lastFirstByte = -</span><span class="s2">1</span>
		<span class="s1">items = zip(charCodes</span><span class="s0">, </span><span class="s1">gids)</span>
		<span class="s0">for </span><span class="s1">charCode</span><span class="s0">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">items:</span>
			<span class="s0">if </span><span class="s1">gid == </span><span class="s2">0</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">firstbyte = charCode &gt;&gt; </span><span class="s2">8</span>
			<span class="s1">secondByte = charCode &amp; </span><span class="s2">0x00FF</span>

			<span class="s0">if </span><span class="s1">firstbyte != lastFirstByte: </span><span class="s4"># Need to update the current subhead, and start a new one.</span>
				<span class="s0">if </span><span class="s1">lastFirstByte &gt; -</span><span class="s2">1</span><span class="s1">:</span>
					<span class="s4"># fix GI's and iDelta of current subheader.</span>
					<span class="s1">self.setIDDelta(subHeader)</span>

					<span class="s4"># If it was sunheader 0 for one-byte charCodes, then we need to set the subHeaderKeys value to zero</span>
					<span class="s4"># for the indices matching the char codes.</span>
					<span class="s0">if </span><span class="s1">lastFirstByte == </span><span class="s2">0</span><span class="s1">:</span>
						<span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(subHeader.entryCount):</span>
							<span class="s1">charCode = subHeader.firstCode + index</span>
							<span class="s1">subHeaderKeys[charCode] = </span><span class="s2">0</span>

					<span class="s0">assert </span><span class="s1">(subHeader.entryCount == len(subHeader.glyphIndexArray))</span><span class="s0">, </span><span class="s5">&quot;Error - subhead entry count does not match len of glyphID subrange.&quot;</span>
				<span class="s4"># init new subheader</span>
				<span class="s1">subHeader = SubHeader()</span>
				<span class="s1">subHeader.firstCode = secondByte</span>
				<span class="s1">subHeader.entryCount = </span><span class="s2">1</span>
				<span class="s1">subHeader.glyphIndexArray.append(gid)</span>
				<span class="s1">subHeaderList.append(subHeader)</span>
				<span class="s1">subHeaderKeys[firstbyte] = len(subHeaderList) -</span><span class="s2">1</span>
				<span class="s1">lastFirstByte = firstbyte</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s4"># need to fill in with notdefs all the code points between the last charCode and the current charCode.</span>
				<span class="s1">codeDiff = secondByte - (subHeader.firstCode + subHeader.entryCount)</span>
				<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(codeDiff):</span>
					<span class="s1">subHeader.glyphIndexArray.append(notdefGI)</span>
				<span class="s1">subHeader.glyphIndexArray.append(gid)</span>
				<span class="s1">subHeader.entryCount = subHeader.entryCount + codeDiff + </span><span class="s2">1</span>

		<span class="s4"># fix GI's and iDelta of last subheader that we we added to the subheader array.</span>
		<span class="s1">self.setIDDelta(subHeader)</span>

		<span class="s4"># Now we add a final subheader for the subHeaderKeys which maps to empty two byte charcode ranges.</span>
		<span class="s1">subHeader = SubHeader()</span>
		<span class="s1">subHeader.firstCode = </span><span class="s2">0</span>
		<span class="s1">subHeader.entryCount = </span><span class="s2">0</span>
		<span class="s1">subHeader.idDelta = </span><span class="s2">0</span>
		<span class="s1">subHeader.idRangeOffset = </span><span class="s2">2</span>
		<span class="s1">subHeaderList.append(subHeader)</span>
		<span class="s1">emptySubheadIndex = len(subHeaderList) - </span><span class="s2">1</span>
		<span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">256</span><span class="s1">):</span>
			<span class="s0">if </span><span class="s1">subHeaderKeys[index] == kEmptyTwoCharCodeRange:</span>
				<span class="s1">subHeaderKeys[index] = emptySubheadIndex</span>
		<span class="s4"># Since this is the last subheader, the GlyphIndex Array starts two bytes after the start of the</span>
		<span class="s4"># idRangeOffset word of this subHeader. We can safely point to the first entry in the GlyphIndexArray,</span>
		<span class="s4"># since the first subrange of the GlyphIndexArray is for subHeader 0, which always starts with</span>
		<span class="s4"># charcode 0 and GID 0.</span>

		<span class="s1">idRangeOffset = (len(subHeaderList)-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">8 </span><span class="s1">+ </span><span class="s2">2 </span><span class="s4"># offset to beginning of glyphIDArray from first subheader idRangeOffset.</span>
		<span class="s1">subheadRangeLen = len(subHeaderList) -</span><span class="s2">1 </span><span class="s4"># skip last special empty-set subheader; we've already hardocodes its idRangeOffset to 2.</span>
		<span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(subheadRangeLen):</span>
			<span class="s1">subHeader = subHeaderList[index]</span>
			<span class="s1">subHeader.idRangeOffset = </span><span class="s2">0</span>
			<span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(index):</span>
				<span class="s1">prevSubhead = subHeaderList[j]</span>
				<span class="s0">if </span><span class="s1">prevSubhead.glyphIndexArray == subHeader.glyphIndexArray: </span><span class="s4"># use the glyphIndexArray subarray</span>
					<span class="s1">subHeader.idRangeOffset = prevSubhead.idRangeOffset - (index-j)*</span><span class="s2">8</span>
					<span class="s1">subHeader.glyphIndexArray = []</span>
					<span class="s0">break</span>
			<span class="s0">if </span><span class="s1">subHeader.idRangeOffset == </span><span class="s2">0</span><span class="s1">: </span><span class="s4"># didn't find one.</span>
				<span class="s1">subHeader.idRangeOffset = idRangeOffset</span>
				<span class="s1">idRangeOffset = (idRangeOffset - </span><span class="s2">8</span><span class="s1">) + subHeader.entryCount*</span><span class="s2">2 </span><span class="s4"># one less subheader, one more subArray.</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">idRangeOffset = idRangeOffset - </span><span class="s2">8  </span><span class="s4"># one less subheader</span>

		<span class="s4"># Now we can write out the data!</span>
		<span class="s1">length = </span><span class="s2">6 </span><span class="s1">+ </span><span class="s2">512 </span><span class="s1">+ </span><span class="s2">8</span><span class="s1">*len(subHeaderList) </span><span class="s4"># header, 256 subHeaderKeys, and subheader array.</span>
		<span class="s0">for </span><span class="s1">subhead </span><span class="s0">in 	</span><span class="s1">subHeaderList[:-</span><span class="s2">1</span><span class="s1">]:</span>
			<span class="s1">length = length + len(subhead.glyphIndexArray)*</span><span class="s2">2  </span><span class="s4"># We can't use subhead.entryCount, as some of the subhead may share subArrays.</span>
		<span class="s1">dataList = [struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">self.language)]</span>
		<span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">subHeaderKeys:</span>
			<span class="s1">dataList.append(struct.pack(</span><span class="s5">&quot;&gt;H&quot;</span><span class="s0">, </span><span class="s1">index*</span><span class="s2">8</span><span class="s1">))</span>
		<span class="s0">for </span><span class="s1">subhead </span><span class="s0">in 	</span><span class="s1">subHeaderList:</span>
			<span class="s1">dataList.append(struct.pack(subHeaderFormat</span><span class="s0">, </span><span class="s1">subhead.firstCode</span><span class="s0">, </span><span class="s1">subhead.entryCount</span><span class="s0">, </span><span class="s1">subhead.idDelta</span><span class="s0">, </span><span class="s1">subhead.idRangeOffset))</span>
		<span class="s0">for </span><span class="s1">subhead </span><span class="s0">in 	</span><span class="s1">subHeaderList[:-</span><span class="s2">1</span><span class="s1">]:</span>
			<span class="s0">for </span><span class="s1">gi </span><span class="s0">in </span><span class="s1">subhead.glyphIndexArray:</span>
				<span class="s1">dataList.append(struct.pack(</span><span class="s5">&quot;&gt;H&quot;</span><span class="s0">, </span><span class="s1">gi))</span>
		<span class="s1">data = bytesjoin(dataList)</span>
		<span class="s0">assert </span><span class="s1">(len(data) == length)</span><span class="s0">, </span><span class="s5">&quot;Error: cmap format 2 is not same length as calculated! actual: &quot; </span><span class="s1">+ str(len(data))+ </span><span class="s5">&quot; calc : &quot; </span><span class="s1">+ str(length)</span>
		<span class="s0">return </span><span class="s1">data</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = safeEval(attrs[</span><span class="s5">&quot;language&quot;</span><span class="s1">])</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {}</span>
		<span class="s1">cmap = self.cmap</span>

		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content = element</span>
			<span class="s0">if </span><span class="s1">name != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">cmap[safeEval(attrs[</span><span class="s5">&quot;code&quot;</span><span class="s1">])] = attrs[</span><span class="s5">&quot;name&quot;</span><span class="s1">]</span>


<span class="s1">cmap_format_4_format = </span><span class="s5">&quot;&gt;7H&quot;</span>

<span class="s4">#uint16  endCode[segCount]          # Ending character code for each segment, last = 0xFFFF.</span>
<span class="s4">#uint16  reservedPad                # This value should be zero</span>
<span class="s4">#uint16  startCode[segCount]        # Starting character code for each segment</span>
<span class="s4">#uint16  idDelta[segCount]          # Delta for all character codes in segment</span>
<span class="s4">#uint16  idRangeOffset[segCount]    # Offset in bytes to glyph indexArray, or 0</span>
<span class="s4">#uint16  glyphIndexArray[variable]  # Glyph index array</span>

<span class="s0">def </span><span class="s1">splitRange(startCode</span><span class="s0">, </span><span class="s1">endCode</span><span class="s0">, </span><span class="s1">cmap):</span>
	<span class="s4"># Try to split a range of character codes into subranges with consecutive</span>
	<span class="s4"># glyph IDs in such a way that the cmap4 subtable can be stored &quot;most&quot;</span>
	<span class="s4"># efficiently. I can't prove I've got the optimal solution, but it seems</span>
	<span class="s4"># to do well with the fonts I tested: none became bigger, many became smaller.</span>
	<span class="s0">if </span><span class="s1">startCode == endCode:</span>
		<span class="s0">return </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[endCode]</span>

	<span class="s1">lastID = cmap[startCode]</span>
	<span class="s1">lastCode = startCode</span>
	<span class="s1">inOrder = </span><span class="s0">None</span>
	<span class="s1">orderedBegin = </span><span class="s0">None</span>
	<span class="s1">subRanges = []</span>

	<span class="s4"># Gather subranges in which the glyph IDs are consecutive.</span>
	<span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">range(startCode + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">endCode + </span><span class="s2">1</span><span class="s1">):</span>
		<span class="s1">glyphID = cmap[code]</span>

		<span class="s0">if </span><span class="s1">glyphID - </span><span class="s2">1 </span><span class="s1">== lastID:</span>
			<span class="s0">if </span><span class="s1">inOrder </span><span class="s0">is None or not </span><span class="s1">inOrder:</span>
				<span class="s1">inOrder = </span><span class="s2">1</span>
				<span class="s1">orderedBegin = lastCode</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">if </span><span class="s1">inOrder:</span>
				<span class="s1">inOrder = </span><span class="s2">0</span>
				<span class="s1">subRanges.append((orderedBegin</span><span class="s0">, </span><span class="s1">lastCode))</span>
				<span class="s1">orderedBegin = </span><span class="s0">None</span>

		<span class="s1">lastID = glyphID</span>
		<span class="s1">lastCode = code</span>

	<span class="s0">if </span><span class="s1">inOrder:</span>
		<span class="s1">subRanges.append((orderedBegin</span><span class="s0">, </span><span class="s1">lastCode))</span>
	<span class="s0">assert </span><span class="s1">lastCode == endCode</span>

	<span class="s4"># Now filter out those new subranges that would only make the data bigger.</span>
	<span class="s4"># A new segment cost 8 bytes, not using a new segment costs 2 bytes per</span>
	<span class="s4"># character.</span>
	<span class="s1">newRanges = []</span>
	<span class="s0">for </span><span class="s1">b</span><span class="s0">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subRanges:</span>
		<span class="s0">if </span><span class="s1">b == startCode </span><span class="s0">and </span><span class="s1">e == endCode:</span>
			<span class="s0">break  </span><span class="s4"># the whole range, we're fine</span>
		<span class="s0">if </span><span class="s1">b == startCode </span><span class="s0">or </span><span class="s1">e == endCode:</span>
			<span class="s1">threshold = </span><span class="s2">4  </span><span class="s4"># split costs one more segment</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">threshold = </span><span class="s2">8  </span><span class="s4"># split costs two more segments</span>
		<span class="s0">if </span><span class="s1">(e - b + </span><span class="s2">1</span><span class="s1">) &gt; threshold:</span>
			<span class="s1">newRanges.append((b</span><span class="s0">, </span><span class="s1">e))</span>
	<span class="s1">subRanges = newRanges</span>

	<span class="s0">if not </span><span class="s1">subRanges:</span>
		<span class="s0">return </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[endCode]</span>

	<span class="s0">if </span><span class="s1">subRanges[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">] != startCode:</span>
		<span class="s1">subRanges.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">(startCode</span><span class="s0">, </span><span class="s1">subRanges[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">0</span><span class="s1">] - </span><span class="s2">1</span><span class="s1">))</span>
	<span class="s0">if </span><span class="s1">subRanges[-</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">] != endCode:</span>
		<span class="s1">subRanges.append((subRanges[-</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">endCode))</span>

	<span class="s4"># Fill the &quot;holes&quot; in the segments list -- those are the segments in which</span>
	<span class="s4"># the glyph IDs are _not_ consecutive.</span>
	<span class="s1">i = </span><span class="s2">1</span>
	<span class="s0">while </span><span class="s1">i &lt; len(subRanges):</span>
		<span class="s0">if </span><span class="s1">subRanges[i-</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">1 </span><span class="s1">!= subRanges[i][</span><span class="s2">0</span><span class="s1">]:</span>
			<span class="s1">subRanges.insert(i</span><span class="s0">, </span><span class="s1">(subRanges[i-</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">subRanges[i][</span><span class="s2">0</span><span class="s1">] - </span><span class="s2">1</span><span class="s1">))</span>
			<span class="s1">i = i + </span><span class="s2">1</span>
		<span class="s1">i = i + </span><span class="s2">1</span>

	<span class="s4"># Transform the ranges into startCode/endCode lists.</span>
	<span class="s1">start = []</span>
	<span class="s1">end = []</span>
	<span class="s0">for </span><span class="s1">b</span><span class="s0">, </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subRanges:</span>
		<span class="s1">start.append(b)</span>
		<span class="s1">end.append(e)</span>
	<span class="s1">start.pop(</span><span class="s2">0</span><span class="s1">)</span>

	<span class="s0">assert </span><span class="s1">len(start) + </span><span class="s2">1 </span><span class="s1">== len(end)</span>
	<span class="s0">return </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end</span>


<span class="s0">class </span><span class="s1">cmap_format_4(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>

		<span class="s1">data = self.data </span><span class="s4"># decompileHeader assigns the data after the header to self.data</span>
		<span class="s1">(segCountX2</span><span class="s0">, </span><span class="s1">searchRange</span><span class="s0">, </span><span class="s1">entrySelector</span><span class="s0">, </span><span class="s1">rangeShift) = \</span>
					<span class="s1">struct.unpack(</span><span class="s5">&quot;&gt;4H&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">8</span><span class="s1">])</span>
		<span class="s1">data = data[</span><span class="s2">8</span><span class="s1">:]</span>
		<span class="s1">segCount = segCountX2 // </span><span class="s2">2</span>

		<span class="s1">allCodes = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s1">)</span>
		<span class="s1">allCodes.frombytes(data)</span>
		<span class="s1">self.data = data = </span><span class="s0">None</span>

		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: allCodes.byteswap()</span>

		<span class="s4"># divide the data</span>
		<span class="s1">endCode = allCodes[:segCount]</span>
		<span class="s1">allCodes = allCodes[segCount+</span><span class="s2">1</span><span class="s1">:]  </span><span class="s4"># the +1 is skipping the reservedPad field</span>
		<span class="s1">startCode = allCodes[:segCount]</span>
		<span class="s1">allCodes = allCodes[segCount:]</span>
		<span class="s1">idDelta = allCodes[:segCount]</span>
		<span class="s1">allCodes = allCodes[segCount:]</span>
		<span class="s1">idRangeOffset = allCodes[:segCount]</span>
		<span class="s1">glyphIndexArray = allCodes[segCount:]</span>
		<span class="s1">lenGIArray = len(glyphIndexArray)</span>

		<span class="s4"># build 2-byte character mapping</span>
		<span class="s1">charCodes = []</span>
		<span class="s1">gids = []</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(startCode) - </span><span class="s2">1</span><span class="s1">):	</span><span class="s4"># don't do 0xffff!</span>
			<span class="s1">start = startCode[i]</span>
			<span class="s1">delta = idDelta[i]</span>
			<span class="s1">rangeOffset = idRangeOffset[i]</span>
			<span class="s1">partial = rangeOffset // </span><span class="s2">2 </span><span class="s1">- start + i - len(idRangeOffset)</span>

			<span class="s1">rangeCharCodes = list(range(startCode[i]</span><span class="s0">, </span><span class="s1">endCode[i] + </span><span class="s2">1</span><span class="s1">))</span>
			<span class="s1">charCodes.extend(rangeCharCodes)</span>
			<span class="s0">if </span><span class="s1">rangeOffset == </span><span class="s2">0</span><span class="s1">:</span>
				<span class="s1">gids.extend([(charCode + delta) &amp; </span><span class="s2">0xFFFF </span><span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">rangeCharCodes])</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">rangeCharCodes:</span>
					<span class="s1">index = charCode + partial</span>
					<span class="s0">assert </span><span class="s1">(index &lt; lenGIArray)</span><span class="s0">, </span><span class="s5">&quot;In format 4 cmap, range (%d), the calculated index (%d) into the glyph index array is not less than the length of the array (%d) !&quot; </span><span class="s1">% (i</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">lenGIArray)</span>
					<span class="s0">if </span><span class="s1">glyphIndexArray[index] != </span><span class="s2">0</span><span class="s1">:  </span><span class="s4"># if not missing glyph</span>
						<span class="s1">glyphID = glyphIndexArray[index] + delta</span>
					<span class="s0">else</span><span class="s1">:</span>
						<span class="s1">glyphID = </span><span class="s2">0  </span><span class="s4"># missing glyph</span>
					<span class="s1">gids.append(glyphID &amp; </span><span class="s2">0xFFFF</span><span class="s1">)</span>

		<span class="s1">self.cmap = _make_map(self.ttFont</span><span class="s0">, </span><span class="s1">charCodes</span><span class="s0">, </span><span class="s1">gids)</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.language) + self.data</span>

		<span class="s1">charCodes = list(self.cmap.keys())</span>
		<span class="s0">if not </span><span class="s1">charCodes:</span>
			<span class="s1">startCode = [</span><span class="s2">0xffff</span><span class="s1">]</span>
			<span class="s1">endCode = [</span><span class="s2">0xffff</span><span class="s1">]</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">charCodes.sort()</span>
			<span class="s1">names = [self.cmap[code] </span><span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">charCodes]</span>
			<span class="s1">nameMap = ttFont.getReverseGlyphMap()</span>
			<span class="s0">try</span><span class="s1">:</span>
				<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
			<span class="s0">except </span><span class="s1">KeyError:</span>
				<span class="s1">nameMap = ttFont.getReverseGlyphMap(rebuild=</span><span class="s0">True</span><span class="s1">)</span>
				<span class="s0">try</span><span class="s1">:</span>
					<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
				<span class="s0">except </span><span class="s1">KeyError:</span>
					<span class="s4"># allow virtual GIDs in format 4 tables</span>
					<span class="s1">gids = []</span>
					<span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
						<span class="s0">try</span><span class="s1">:</span>
							<span class="s1">gid = nameMap[name]</span>
						<span class="s0">except </span><span class="s1">KeyError:</span>
							<span class="s0">try</span><span class="s1">:</span>
								<span class="s0">if </span><span class="s1">(name[:</span><span class="s2">3</span><span class="s1">] == </span><span class="s5">'gid'</span><span class="s1">):</span>
									<span class="s1">gid = int(name[</span><span class="s2">3</span><span class="s1">:])</span>
								<span class="s0">else</span><span class="s1">:</span>
									<span class="s1">gid = ttFont.getGlyphID(name)</span>
							<span class="s0">except</span><span class="s1">:</span>
								<span class="s0">raise </span><span class="s1">KeyError(name)</span>

						<span class="s1">gids.append(gid)</span>
			<span class="s1">cmap = {}  </span><span class="s4"># code:glyphID mapping</span>
			<span class="s0">for </span><span class="s1">code</span><span class="s0">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">zip(charCodes</span><span class="s0">, </span><span class="s1">gids):</span>
				<span class="s1">cmap[code] = gid</span>

			<span class="s4"># Build startCode and endCode lists.</span>
			<span class="s4"># Split the char codes in ranges of consecutive char codes, then split</span>
			<span class="s4"># each range in more ranges of consecutive/not consecutive glyph IDs.</span>
			<span class="s4"># See splitRange().</span>
			<span class="s1">lastCode = charCodes[</span><span class="s2">0</span><span class="s1">]</span>
			<span class="s1">endCode = []</span>
			<span class="s1">startCode = [lastCode]</span>
			<span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">charCodes[</span><span class="s2">1</span><span class="s1">:]:  </span><span class="s4"># skip the first code, it's the first start code</span>
				<span class="s0">if </span><span class="s1">charCode == lastCode + </span><span class="s2">1</span><span class="s1">:</span>
					<span class="s1">lastCode = charCode</span>
					<span class="s0">continue</span>
				<span class="s1">start</span><span class="s0">, </span><span class="s1">end = splitRange(startCode[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lastCode</span><span class="s0">, </span><span class="s1">cmap)</span>
				<span class="s1">startCode.extend(start)</span>
				<span class="s1">endCode.extend(end)</span>
				<span class="s1">startCode.append(charCode)</span>
				<span class="s1">lastCode = charCode</span>
			<span class="s1">start</span><span class="s0">, </span><span class="s1">end = splitRange(startCode[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">lastCode</span><span class="s0">, </span><span class="s1">cmap)</span>
			<span class="s1">startCode.extend(start)</span>
			<span class="s1">endCode.extend(end)</span>
			<span class="s1">startCode.append(</span><span class="s2">0xffff</span><span class="s1">)</span>
			<span class="s1">endCode.append(</span><span class="s2">0xffff</span><span class="s1">)</span>

		<span class="s4"># build up rest of cruft</span>
		<span class="s1">idDelta = []</span>
		<span class="s1">idRangeOffset = []</span>
		<span class="s1">glyphIndexArray = []</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(endCode)-</span><span class="s2">1</span><span class="s1">):  </span><span class="s4"># skip the closing codes (0xffff)</span>
			<span class="s1">indices = []</span>
			<span class="s0">for </span><span class="s1">charCode </span><span class="s0">in </span><span class="s1">range(startCode[i]</span><span class="s0">, </span><span class="s1">endCode[i] + </span><span class="s2">1</span><span class="s1">):</span>
				<span class="s1">indices.append(cmap[charCode])</span>
			<span class="s0">if </span><span class="s1">(indices == list(range(indices[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">indices[</span><span class="s2">0</span><span class="s1">] + len(indices)))):</span>
				<span class="s1">idDelta.append((indices[</span><span class="s2">0</span><span class="s1">] - startCode[i]) % </span><span class="s2">0x10000</span><span class="s1">)</span>
				<span class="s1">idRangeOffset.append(</span><span class="s2">0</span><span class="s1">)</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">idDelta.append(</span><span class="s2">0</span><span class="s1">)</span>
				<span class="s1">idRangeOffset.append(</span><span class="s2">2 </span><span class="s1">* (len(endCode) + len(glyphIndexArray) - i))</span>
				<span class="s1">glyphIndexArray.extend(indices)</span>
		<span class="s1">idDelta.append(</span><span class="s2">1</span><span class="s1">)  </span><span class="s4"># 0xffff + 1 == (tadaa!) 0. So this end code maps to .notdef</span>
		<span class="s1">idRangeOffset.append(</span><span class="s2">0</span><span class="s1">)</span>

		<span class="s4"># Insane.</span>
		<span class="s1">segCount = len(endCode)</span>
		<span class="s1">segCountX2 = segCount * </span><span class="s2">2</span>
		<span class="s1">searchRange</span><span class="s0">, </span><span class="s1">entrySelector</span><span class="s0">, </span><span class="s1">rangeShift = getSearchRange(segCount</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

		<span class="s1">charCodeArray = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s0">, </span><span class="s1">endCode + [</span><span class="s2">0</span><span class="s1">] + startCode)</span>
		<span class="s1">idDeltaArray = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s0">, </span><span class="s1">idDelta)</span>
		<span class="s1">restArray = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s0">, </span><span class="s1">idRangeOffset + glyphIndexArray)</span>
		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: charCodeArray.byteswap()</span>
		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: idDeltaArray.byteswap()</span>
		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: restArray.byteswap()</span>
		<span class="s1">data = charCodeArray.tobytes() + idDeltaArray.tobytes() + restArray.tobytes()</span>

		<span class="s1">length = struct.calcsize(cmap_format_4_format) + len(data)</span>
		<span class="s1">header = struct.pack(cmap_format_4_format</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">self.language</span><span class="s0">,</span>
				<span class="s1">segCountX2</span><span class="s0">, </span><span class="s1">searchRange</span><span class="s0">, </span><span class="s1">entrySelector</span><span class="s0">, </span><span class="s1">rangeShift)</span>
		<span class="s0">return </span><span class="s1">header + data</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = safeEval(attrs[</span><span class="s5">&quot;language&quot;</span><span class="s1">])</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {}</span>
		<span class="s1">cmap = self.cmap</span>

		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">nameMap</span><span class="s0">, </span><span class="s1">attrsMap</span><span class="s0">, </span><span class="s1">dummyContent = element</span>
			<span class="s0">if </span><span class="s1">nameMap != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">assert </span><span class="s2">0</span><span class="s0">, </span><span class="s5">&quot;Unrecognized keyword in cmap subtable&quot;</span>
			<span class="s1">cmap[safeEval(attrsMap[</span><span class="s5">&quot;code&quot;</span><span class="s1">])] = attrsMap[</span><span class="s5">&quot;name&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">cmap_format_6(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>

		<span class="s1">data = self.data </span><span class="s4"># decompileHeader assigns the data after the header to self.data</span>
		<span class="s1">firstCode</span><span class="s0">, </span><span class="s1">entryCount = struct.unpack(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">4</span><span class="s1">])</span>
		<span class="s1">firstCode = int(firstCode)</span>
		<span class="s1">data = data[</span><span class="s2">4</span><span class="s1">:]</span>
		<span class="s4">#assert len(data) == 2 * entryCount  # XXX not true in Apple's Helvetica!!!</span>
		<span class="s1">gids = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s1">)</span>
		<span class="s1">gids.frombytes(data[:</span><span class="s2">2 </span><span class="s1">* int(entryCount)])</span>
		<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: gids.byteswap()</span>
		<span class="s1">self.data = data = </span><span class="s0">None</span>

		<span class="s1">charCodes = list(range(firstCode</span><span class="s0">, </span><span class="s1">firstCode + len(gids)))</span>
		<span class="s1">self.cmap = _make_map(self.ttFont</span><span class="s0">, </span><span class="s1">charCodes</span><span class="s0">, </span><span class="s1">gids)</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHH&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.language) + self.data</span>
		<span class="s1">cmap = self.cmap</span>
		<span class="s1">codes = sorted(cmap.keys())</span>
		<span class="s0">if </span><span class="s1">codes: </span><span class="s4"># yes, there are empty cmap tables.</span>
			<span class="s1">codes = list(range(codes[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">codes[-</span><span class="s2">1</span><span class="s1">] + </span><span class="s2">1</span><span class="s1">))</span>
			<span class="s1">firstCode = codes[</span><span class="s2">0</span><span class="s1">]</span>
			<span class="s1">valueList = [</span>
				<span class="s1">ttFont.getGlyphID(cmap[code]) </span><span class="s0">if </span><span class="s1">code </span><span class="s0">in </span><span class="s1">cmap </span><span class="s0">else </span><span class="s2">0</span>
				<span class="s0">for </span><span class="s1">code </span><span class="s0">in </span><span class="s1">codes</span>
			<span class="s1">]</span>
			<span class="s1">gids = array.array(</span><span class="s5">&quot;H&quot;</span><span class="s0">, </span><span class="s1">valueList)</span>
			<span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s5">&quot;big&quot;</span><span class="s1">: gids.byteswap()</span>
			<span class="s1">data = gids.tobytes()</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s1">data = </span><span class="s6">b&quot;&quot;</span>
			<span class="s1">firstCode = </span><span class="s2">0</span>
		<span class="s1">header = struct.pack(</span><span class="s5">&quot;&gt;HHHHH&quot;</span><span class="s0">,</span>
				<span class="s2">6</span><span class="s0">, </span><span class="s1">len(data) + </span><span class="s2">10</span><span class="s0">, </span><span class="s1">self.language</span><span class="s0">, </span><span class="s1">firstCode</span><span class="s0">, </span><span class="s1">len(codes))</span>
		<span class="s0">return </span><span class="s1">header + data</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = safeEval(attrs[</span><span class="s5">&quot;language&quot;</span><span class="s1">])</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {}</span>
		<span class="s1">cmap = self.cmap</span>

		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content = element</span>
			<span class="s0">if </span><span class="s1">name != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">cmap[safeEval(attrs[</span><span class="s5">&quot;code&quot;</span><span class="s1">])] = attrs[</span><span class="s5">&quot;name&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">cmap_format_12_or_13(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">format):</span>
		<span class="s1">self.format = format</span>
		<span class="s1">self.reserved = </span><span class="s2">0</span>
		<span class="s1">self.data = </span><span class="s0">None</span>
		<span class="s1">self.ttFont = </span><span class="s0">None</span>

	<span class="s0">def </span><span class="s1">decompileHeader(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">format</span><span class="s0">, </span><span class="s1">reserved</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">language</span><span class="s0">, </span><span class="s1">nGroups = struct.unpack(</span><span class="s5">&quot;&gt;HHLLL&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">16</span><span class="s1">])</span>
		<span class="s0">assert </span><span class="s1">len(data) == (</span><span class="s2">16 </span><span class="s1">+ nGroups*</span><span class="s2">12</span><span class="s1">) == (length)</span><span class="s0">, </span><span class="s5">&quot;corrupt cmap table format %d (data length: %d, header length: %d)&quot; </span><span class="s1">% (self.format</span><span class="s0">, </span><span class="s1">len(data)</span><span class="s0">, </span><span class="s1">length)</span>
		<span class="s1">self.format = format</span>
		<span class="s1">self.reserved = reserved</span>
		<span class="s1">self.length = length</span>
		<span class="s1">self.language = language</span>
		<span class="s1">self.nGroups = nGroups</span>
		<span class="s1">self.data = data[</span><span class="s2">16</span><span class="s1">:]</span>
		<span class="s1">self.ttFont = ttFont</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>

		<span class="s1">data = self.data </span><span class="s4"># decompileHeader assigns the data after the header to self.data</span>
		<span class="s1">charCodes = []</span>
		<span class="s1">gids = []</span>
		<span class="s1">pos = </span><span class="s2">0</span>
		<span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.nGroups):</span>
			<span class="s1">startCharCode</span><span class="s0">, </span><span class="s1">endCharCode</span><span class="s0">, </span><span class="s1">glyphID = struct.unpack(</span><span class="s5">&quot;&gt;LLL&quot;</span><span class="s0">,</span><span class="s1">data[pos:pos+</span><span class="s2">12</span><span class="s1">] )</span>
			<span class="s1">pos += </span><span class="s2">12</span>
			<span class="s1">lenGroup = </span><span class="s2">1 </span><span class="s1">+ endCharCode - startCharCode</span>
			<span class="s1">charCodes.extend(list(range(startCharCode</span><span class="s0">, </span><span class="s1">endCharCode +</span><span class="s2">1</span><span class="s1">)))</span>
			<span class="s1">gids.extend(self._computeGIDs(glyphID</span><span class="s0">, </span><span class="s1">lenGroup))</span>
		<span class="s1">self.data = data = </span><span class="s0">None</span>
		<span class="s1">self.cmap = _make_map(self.ttFont</span><span class="s0">, </span><span class="s1">charCodes</span><span class="s0">, </span><span class="s1">gids)</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHLLL&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.reserved</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.language</span><span class="s0">, </span><span class="s1">self.nGroups) + self.data</span>
		<span class="s1">charCodes = list(self.cmap.keys())</span>
		<span class="s1">names = list(self.cmap.values())</span>
		<span class="s1">nameMap = ttFont.getReverseGlyphMap()</span>
		<span class="s0">try</span><span class="s1">:</span>
			<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
		<span class="s0">except </span><span class="s1">KeyError:</span>
			<span class="s1">nameMap = ttFont.getReverseGlyphMap(rebuild=</span><span class="s0">True</span><span class="s1">)</span>
			<span class="s0">try</span><span class="s1">:</span>
				<span class="s1">gids = [nameMap[name] </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names]</span>
			<span class="s0">except </span><span class="s1">KeyError:</span>
				<span class="s4"># allow virtual GIDs in format 12 tables</span>
				<span class="s1">gids = []</span>
				<span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
					<span class="s0">try</span><span class="s1">:</span>
						<span class="s1">gid = nameMap[name]</span>
					<span class="s0">except </span><span class="s1">KeyError:</span>
						<span class="s0">try</span><span class="s1">:</span>
							<span class="s0">if </span><span class="s1">(name[:</span><span class="s2">3</span><span class="s1">] == </span><span class="s5">'gid'</span><span class="s1">):</span>
								<span class="s1">gid = int(name[</span><span class="s2">3</span><span class="s1">:])</span>
							<span class="s0">else</span><span class="s1">:</span>
								<span class="s1">gid = ttFont.getGlyphID(name)</span>
						<span class="s0">except</span><span class="s1">:</span>
							<span class="s0">raise </span><span class="s1">KeyError(name)</span>

					<span class="s1">gids.append(gid)</span>

		<span class="s1">cmap = {}  </span><span class="s4"># code:glyphID mapping</span>
		<span class="s0">for </span><span class="s1">code</span><span class="s0">, </span><span class="s1">gid </span><span class="s0">in </span><span class="s1">zip(charCodes</span><span class="s0">, </span><span class="s1">gids):</span>
			<span class="s1">cmap[code] = gid</span>

		<span class="s1">charCodes.sort()</span>
		<span class="s1">index = </span><span class="s2">0</span>
		<span class="s1">startCharCode = charCodes[</span><span class="s2">0</span><span class="s1">]</span>
		<span class="s1">startGlyphID = cmap[startCharCode]</span>
		<span class="s1">lastGlyphID = startGlyphID - self._format_step</span>
		<span class="s1">lastCharCode = startCharCode - </span><span class="s2">1</span>
		<span class="s1">nGroups = </span><span class="s2">0</span>
		<span class="s1">dataList = []</span>
		<span class="s1">maxIndex = len(charCodes)</span>
		<span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(maxIndex):</span>
			<span class="s1">charCode = charCodes[index]</span>
			<span class="s1">glyphID = cmap[charCode]</span>
			<span class="s0">if not </span><span class="s1">self._IsInSameRun(glyphID</span><span class="s0">, </span><span class="s1">lastGlyphID</span><span class="s0">, </span><span class="s1">charCode</span><span class="s0">, </span><span class="s1">lastCharCode):</span>
				<span class="s1">dataList.append(struct.pack(</span><span class="s5">&quot;&gt;LLL&quot;</span><span class="s0">, </span><span class="s1">startCharCode</span><span class="s0">, </span><span class="s1">lastCharCode</span><span class="s0">, </span><span class="s1">startGlyphID))</span>
				<span class="s1">startCharCode = charCode</span>
				<span class="s1">startGlyphID = glyphID</span>
				<span class="s1">nGroups = nGroups + </span><span class="s2">1</span>
			<span class="s1">lastGlyphID = glyphID</span>
			<span class="s1">lastCharCode = charCode</span>
		<span class="s1">dataList.append(struct.pack(</span><span class="s5">&quot;&gt;LLL&quot;</span><span class="s0">, </span><span class="s1">startCharCode</span><span class="s0">, </span><span class="s1">lastCharCode</span><span class="s0">, </span><span class="s1">startGlyphID))</span>
		<span class="s1">nGroups = nGroups + </span><span class="s2">1</span>
		<span class="s1">data = bytesjoin(dataList)</span>
		<span class="s1">lengthSubtable = len(data) +</span><span class="s2">16</span>
		<span class="s0">assert </span><span class="s1">len(data) == (nGroups*</span><span class="s2">12</span><span class="s1">) == (lengthSubtable-</span><span class="s2">16</span><span class="s1">)</span>
		<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HHLLL&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.reserved</span><span class="s0">, </span><span class="s1">lengthSubtable</span><span class="s0">, </span><span class="s1">self.language</span><span class="s0">, </span><span class="s1">nGroups) + data</span>

	<span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">writer.begintag(self.__class__.__name__</span><span class="s0">, </span><span class="s1">[</span>
				<span class="s1">(</span><span class="s5">&quot;platformID&quot;</span><span class="s0">, </span><span class="s1">self.platformID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, </span><span class="s1">self.platEncID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;format&quot;</span><span class="s0">, </span><span class="s1">self.format)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;reserved&quot;</span><span class="s0">, </span><span class="s1">self.reserved)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;length&quot;</span><span class="s0">, </span><span class="s1">self.length)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;language&quot;</span><span class="s0">, </span><span class="s1">self.language)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;nGroups&quot;</span><span class="s0">, </span><span class="s1">self.nGroups)</span><span class="s0">,</span>
				<span class="s1">])</span>
		<span class="s1">writer.newline()</span>
		<span class="s1">codes = sorted(self.cmap.items())</span>
		<span class="s1">self._writeCodes(codes</span><span class="s0">, </span><span class="s1">writer)</span>
		<span class="s1">writer.endtag(self.__class__.__name__)</span>
		<span class="s1">writer.newline()</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.format = safeEval(attrs[</span><span class="s5">&quot;format&quot;</span><span class="s1">])</span>
		<span class="s1">self.reserved = safeEval(attrs[</span><span class="s5">&quot;reserved&quot;</span><span class="s1">])</span>
		<span class="s1">self.length = safeEval(attrs[</span><span class="s5">&quot;length&quot;</span><span class="s1">])</span>
		<span class="s1">self.language = safeEval(attrs[</span><span class="s5">&quot;language&quot;</span><span class="s1">])</span>
		<span class="s1">self.nGroups = safeEval(attrs[</span><span class="s5">&quot;nGroups&quot;</span><span class="s1">])</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {}</span>
		<span class="s1">cmap = self.cmap</span>

		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content = element</span>
			<span class="s0">if </span><span class="s1">name != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">cmap[safeEval(attrs[</span><span class="s5">&quot;code&quot;</span><span class="s1">])] = attrs[</span><span class="s5">&quot;name&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">cmap_format_12(cmap_format_12_or_13):</span>

	<span class="s1">_format_step = </span><span class="s2">1</span>

	<span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">12</span><span class="s1">):</span>
		<span class="s1">cmap_format_12_or_13.__init__(self</span><span class="s0">, </span><span class="s1">format)</span>

	<span class="s0">def </span><span class="s1">_computeGIDs(self</span><span class="s0">, </span><span class="s1">startingGlyph</span><span class="s0">, </span><span class="s1">numberOfGlyphs):</span>
		<span class="s0">return </span><span class="s1">list(range(startingGlyph</span><span class="s0">, </span><span class="s1">startingGlyph + numberOfGlyphs))</span>

	<span class="s0">def </span><span class="s1">_IsInSameRun(self</span><span class="s0">, </span><span class="s1">glyphID</span><span class="s0">, </span><span class="s1">lastGlyphID</span><span class="s0">, </span><span class="s1">charCode</span><span class="s0">, </span><span class="s1">lastCharCode):</span>
		<span class="s0">return </span><span class="s1">(glyphID == </span><span class="s2">1 </span><span class="s1">+ lastGlyphID) </span><span class="s0">and </span><span class="s1">(charCode == </span><span class="s2">1 </span><span class="s1">+ lastCharCode)</span>


<span class="s0">class </span><span class="s1">cmap_format_13(cmap_format_12_or_13):</span>

	<span class="s1">_format_step = </span><span class="s2">0</span>

	<span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">format=</span><span class="s2">13</span><span class="s1">):</span>
		<span class="s1">cmap_format_12_or_13.__init__(self</span><span class="s0">, </span><span class="s1">format)</span>

	<span class="s0">def </span><span class="s1">_computeGIDs(self</span><span class="s0">, </span><span class="s1">startingGlyph</span><span class="s0">, </span><span class="s1">numberOfGlyphs):</span>
		<span class="s0">return </span><span class="s1">[startingGlyph] * numberOfGlyphs</span>

	<span class="s0">def </span><span class="s1">_IsInSameRun(self</span><span class="s0">, </span><span class="s1">glyphID</span><span class="s0">, </span><span class="s1">lastGlyphID</span><span class="s0">, </span><span class="s1">charCode</span><span class="s0">, </span><span class="s1">lastCharCode):</span>
		<span class="s0">return </span><span class="s1">(glyphID == lastGlyphID) </span><span class="s0">and </span><span class="s1">(charCode == </span><span class="s2">1 </span><span class="s1">+ lastCharCode)</span>


<span class="s0">def </span><span class="s1">cvtToUVS(threeByteString):</span>
	<span class="s1">data = </span><span class="s6">b&quot;</span><span class="s0">\0</span><span class="s6">&quot; </span><span class="s1">+ threeByteString</span>
	<span class="s1">val</span><span class="s0">, </span><span class="s1">= struct.unpack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">data)</span>
	<span class="s0">return </span><span class="s1">val</span>

<span class="s0">def </span><span class="s1">cvtFromUVS(val):</span>
	<span class="s0">assert </span><span class="s2">0 </span><span class="s1">&lt;= val &lt; </span><span class="s2">0x1000000</span>
	<span class="s1">fourByteString = struct.pack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">val)</span>
	<span class="s0">return </span><span class="s1">fourByteString[</span><span class="s2">1</span><span class="s1">:]</span>


<span class="s0">class </span><span class="s1">cmap_format_14(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">decompileHeader(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">format</span><span class="s0">, </span><span class="s1">length</span><span class="s0">, </span><span class="s1">numVarSelectorRecords = struct.unpack(</span><span class="s5">&quot;&gt;HLL&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s2">10</span><span class="s1">])</span>
		<span class="s1">self.data = data[</span><span class="s2">10</span><span class="s1">:]</span>
		<span class="s1">self.length = length</span>
		<span class="s1">self.numVarSelectorRecords = numVarSelectorRecords</span>
		<span class="s1">self.ttFont = ttFont</span>
		<span class="s1">self.language = </span><span class="s2">0xFF </span><span class="s4"># has no language.</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>
		<span class="s1">data = self.data</span>

		<span class="s1">self.cmap = {} </span><span class="s4"># so that clients that expect this to exist in a cmap table won't fail.</span>
		<span class="s1">uvsDict = {}</span>
		<span class="s1">recOffset = </span><span class="s2">0</span>
		<span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(self.numVarSelectorRecords):</span>
			<span class="s1">uvs</span><span class="s0">, </span><span class="s1">defOVSOffset</span><span class="s0">, </span><span class="s1">nonDefUVSOffset = struct.unpack(</span><span class="s5">&quot;&gt;3sLL&quot;</span><span class="s0">, </span><span class="s1">data[recOffset:recOffset +</span><span class="s2">11</span><span class="s1">])</span>
			<span class="s1">recOffset += </span><span class="s2">11</span>
			<span class="s1">varUVS = cvtToUVS(uvs)</span>
			<span class="s0">if </span><span class="s1">defOVSOffset:</span>
				<span class="s1">startOffset = defOVSOffset - </span><span class="s2">10</span>
				<span class="s1">numValues</span><span class="s0">, </span><span class="s1">= struct.unpack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">data[startOffset:startOffset+</span><span class="s2">4</span><span class="s1">])</span>
				<span class="s1">startOffset +=</span><span class="s2">4</span>
				<span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range(numValues):</span>
					<span class="s1">uv</span><span class="s0">, </span><span class="s1">addtlCnt = struct.unpack(</span><span class="s5">&quot;&gt;3sB&quot;</span><span class="s0">, </span><span class="s1">data[startOffset:startOffset+</span><span class="s2">4</span><span class="s1">])</span>
					<span class="s1">startOffset += </span><span class="s2">4</span>
					<span class="s1">firstBaseUV = cvtToUVS(uv)</span>
					<span class="s1">cnt = addtlCnt+</span><span class="s2">1</span>
					<span class="s1">baseUVList = list(range(firstBaseUV</span><span class="s0">, </span><span class="s1">firstBaseUV+cnt))</span>
					<span class="s1">glyphList = [</span><span class="s0">None</span><span class="s1">]*cnt</span>
					<span class="s1">localUVList = zip(baseUVList</span><span class="s0">, </span><span class="s1">glyphList)</span>
					<span class="s0">try</span><span class="s1">:</span>
						<span class="s1">uvsDict[varUVS].extend(localUVList)</span>
					<span class="s0">except </span><span class="s1">KeyError:</span>
						<span class="s1">uvsDict[varUVS] = list(localUVList)</span>

			<span class="s0">if </span><span class="s1">nonDefUVSOffset:</span>
				<span class="s1">startOffset = nonDefUVSOffset - </span><span class="s2">10</span>
				<span class="s1">numRecs</span><span class="s0">, </span><span class="s1">= struct.unpack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">data[startOffset:startOffset+</span><span class="s2">4</span><span class="s1">])</span>
				<span class="s1">startOffset +=</span><span class="s2">4</span>
				<span class="s1">localUVList = []</span>
				<span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range(numRecs):</span>
					<span class="s1">uv</span><span class="s0">, </span><span class="s1">gid = struct.unpack(</span><span class="s5">&quot;&gt;3sH&quot;</span><span class="s0">, </span><span class="s1">data[startOffset:startOffset+</span><span class="s2">5</span><span class="s1">])</span>
					<span class="s1">startOffset += </span><span class="s2">5</span>
					<span class="s1">uv = cvtToUVS(uv)</span>
					<span class="s1">glyphName = self.ttFont.getGlyphName(gid)</span>
					<span class="s1">localUVList.append((uv</span><span class="s0">, </span><span class="s1">glyphName))</span>
				<span class="s0">try</span><span class="s1">:</span>
					<span class="s1">uvsDict[varUVS].extend(localUVList)</span>
				<span class="s0">except </span><span class="s1">KeyError:</span>
					<span class="s1">uvsDict[varUVS] = localUVList</span>

		<span class="s1">self.uvsDict = uvsDict</span>

	<span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">writer.begintag(self.__class__.__name__</span><span class="s0">, </span><span class="s1">[</span>
				<span class="s1">(</span><span class="s5">&quot;platformID&quot;</span><span class="s0">, </span><span class="s1">self.platformID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, </span><span class="s1">self.platEncID)</span><span class="s0">,</span>
				<span class="s1">])</span>
		<span class="s1">writer.newline()</span>
		<span class="s1">uvsDict = self.uvsDict</span>
		<span class="s1">uvsList = sorted(uvsDict.keys())</span>
		<span class="s0">for </span><span class="s1">uvs </span><span class="s0">in </span><span class="s1">uvsList:</span>
			<span class="s1">uvList = uvsDict[uvs]</span>
			<span class="s1">uvList.sort(key=</span><span class="s0">lambda </span><span class="s1">item: (item[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">is not None, </span><span class="s1">item[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">item[</span><span class="s2">1</span><span class="s1">]))</span>
			<span class="s0">for </span><span class="s1">uv</span><span class="s0">, </span><span class="s1">gname </span><span class="s0">in </span><span class="s1">uvList:</span>
				<span class="s1">attrs = [(</span><span class="s5">&quot;uv&quot;</span><span class="s0">, </span><span class="s1">hex(uv))</span><span class="s0">, </span><span class="s1">(</span><span class="s5">&quot;uvs&quot;</span><span class="s0">, </span><span class="s1">hex(uvs))]</span>
				<span class="s0">if </span><span class="s1">gname </span><span class="s0">is not None</span><span class="s1">:</span>
					<span class="s1">attrs.append((</span><span class="s5">&quot;name&quot;</span><span class="s0">, </span><span class="s1">gname))</span>
				<span class="s1">writer.simpletag(</span><span class="s5">&quot;map&quot;</span><span class="s0">, </span><span class="s1">attrs)</span>
				<span class="s1">writer.newline()</span>
		<span class="s1">writer.endtag(self.__class__.__name__)</span>
		<span class="s1">writer.newline()</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = </span><span class="s2">0xFF </span><span class="s4"># provide a value so that CmapSubtable.__lt__() won't fail</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;cmap&quot;</span><span class="s1">):</span>
			<span class="s1">self.cmap = {} </span><span class="s4"># so that clients that expect this to exist in a cmap table won't fail.</span>
		<span class="s0">if not </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">&quot;uvsDict&quot;</span><span class="s1">):</span>
			<span class="s1">self.uvsDict = {}</span>
			<span class="s1">uvsDict = self.uvsDict</span>

		<span class="s4"># For backwards compatibility reasons we accept &quot;None&quot; as an indicator</span>
		<span class="s4"># for &quot;default mapping&quot;, unless the font actually has a glyph named</span>
		<span class="s4"># &quot;None&quot;.</span>
		<span class="s1">_hasGlyphNamedNone = </span><span class="s0">None</span>

		<span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
			<span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple):</span>
				<span class="s0">continue</span>
			<span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content = element</span>
			<span class="s0">if </span><span class="s1">name != </span><span class="s5">&quot;map&quot;</span><span class="s1">:</span>
				<span class="s0">continue</span>
			<span class="s1">uvs = safeEval(attrs[</span><span class="s5">&quot;uvs&quot;</span><span class="s1">])</span>
			<span class="s1">uv = safeEval(attrs[</span><span class="s5">&quot;uv&quot;</span><span class="s1">])</span>
			<span class="s1">gname = attrs.get(</span><span class="s5">&quot;name&quot;</span><span class="s1">)</span>
			<span class="s0">if </span><span class="s1">gname == </span><span class="s5">&quot;None&quot;</span><span class="s1">:</span>
				<span class="s0">if </span><span class="s1">_hasGlyphNamedNone </span><span class="s0">is None</span><span class="s1">:</span>
					<span class="s1">_hasGlyphNamedNone = </span><span class="s5">&quot;None&quot; </span><span class="s0">in </span><span class="s1">ttFont.getGlyphOrder()</span>
				<span class="s0">if not </span><span class="s1">_hasGlyphNamedNone:</span>
					<span class="s1">gname = </span><span class="s0">None</span>
			<span class="s0">try</span><span class="s1">:</span>
				<span class="s1">uvsDict[uvs].append((uv</span><span class="s0">, </span><span class="s1">gname))</span>
			<span class="s0">except </span><span class="s1">KeyError:</span>
				<span class="s1">uvsDict[uvs] = [(uv</span><span class="s0">, </span><span class="s1">gname)]</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">struct.pack(</span><span class="s5">&quot;&gt;HLL&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.numVarSelectorRecords) + self.data</span>

		<span class="s1">uvsDict = self.uvsDict</span>
		<span class="s1">uvsList = sorted(uvsDict.keys())</span>
		<span class="s1">self.numVarSelectorRecords = len(uvsList)</span>
		<span class="s1">offset = </span><span class="s2">10 </span><span class="s1">+ self.numVarSelectorRecords*</span><span class="s2">11 </span><span class="s4"># current value is end of VarSelectorRecords block.</span>
		<span class="s1">data = []</span>
		<span class="s1">varSelectorRecords =[]</span>
		<span class="s0">for </span><span class="s1">uvs </span><span class="s0">in </span><span class="s1">uvsList:</span>
			<span class="s1">entryList = uvsDict[uvs]</span>

			<span class="s1">defList = [entry </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">entryList </span><span class="s0">if </span><span class="s1">entry[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">]</span>
			<span class="s0">if </span><span class="s1">defList:</span>
				<span class="s1">defList = [entry[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">defList]</span>
				<span class="s1">defOVSOffset = offset</span>
				<span class="s1">defList.sort()</span>

				<span class="s1">lastUV = defList[</span><span class="s2">0</span><span class="s1">]</span>
				<span class="s1">cnt = -</span><span class="s2">1</span>
				<span class="s1">defRecs = []</span>
				<span class="s0">for </span><span class="s1">defEntry </span><span class="s0">in </span><span class="s1">defList:</span>
					<span class="s1">cnt +=</span><span class="s2">1</span>
					<span class="s0">if </span><span class="s1">(lastUV+cnt) != defEntry:</span>
						<span class="s1">rec = struct.pack(</span><span class="s5">&quot;&gt;3sB&quot;</span><span class="s0">, </span><span class="s1">cvtFromUVS(lastUV)</span><span class="s0">, </span><span class="s1">cnt-</span><span class="s2">1</span><span class="s1">)</span>
						<span class="s1">lastUV = defEntry</span>
						<span class="s1">defRecs.append(rec)</span>
						<span class="s1">cnt = </span><span class="s2">0</span>

				<span class="s1">rec = struct.pack(</span><span class="s5">&quot;&gt;3sB&quot;</span><span class="s0">, </span><span class="s1">cvtFromUVS(lastUV)</span><span class="s0">, </span><span class="s1">cnt)</span>
				<span class="s1">defRecs.append(rec)</span>

				<span class="s1">numDefRecs = len(defRecs)</span>
				<span class="s1">data.append(struct.pack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">numDefRecs))</span>
				<span class="s1">data.extend(defRecs)</span>
				<span class="s1">offset += </span><span class="s2">4 </span><span class="s1">+ numDefRecs*</span><span class="s2">4</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">defOVSOffset = </span><span class="s2">0</span>

			<span class="s1">ndefList = [entry </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">entryList </span><span class="s0">if </span><span class="s1">entry[</span><span class="s2">1</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">]</span>
			<span class="s0">if </span><span class="s1">ndefList:</span>
				<span class="s1">nonDefUVSOffset = offset</span>
				<span class="s1">ndefList.sort()</span>
				<span class="s1">numNonDefRecs = len(ndefList)</span>
				<span class="s1">data.append(struct.pack(</span><span class="s5">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">numNonDefRecs))</span>
				<span class="s1">offset += </span><span class="s2">4 </span><span class="s1">+ numNonDefRecs*</span><span class="s2">5</span>

				<span class="s0">for </span><span class="s1">uv</span><span class="s0">, </span><span class="s1">gname </span><span class="s0">in </span><span class="s1">ndefList:</span>
					<span class="s1">gid = ttFont.getGlyphID(gname)</span>
					<span class="s1">ndrec = struct.pack(</span><span class="s5">&quot;&gt;3sH&quot;</span><span class="s0">, </span><span class="s1">cvtFromUVS(uv)</span><span class="s0">, </span><span class="s1">gid)</span>
					<span class="s1">data.append(ndrec)</span>
			<span class="s0">else</span><span class="s1">:</span>
				<span class="s1">nonDefUVSOffset = </span><span class="s2">0</span>

			<span class="s1">vrec = struct.pack(</span><span class="s5">&quot;&gt;3sLL&quot;</span><span class="s0">, </span><span class="s1">cvtFromUVS(uvs)</span><span class="s0">, </span><span class="s1">defOVSOffset</span><span class="s0">, </span><span class="s1">nonDefUVSOffset)</span>
			<span class="s1">varSelectorRecords.append(vrec)</span>

		<span class="s1">data = bytesjoin(varSelectorRecords) + bytesjoin(data)</span>
		<span class="s1">self.length = </span><span class="s2">10 </span><span class="s1">+ len(data)</span>
		<span class="s1">headerdata = struct.pack(</span><span class="s5">&quot;&gt;HLL&quot;</span><span class="s0">, </span><span class="s1">self.format</span><span class="s0">, </span><span class="s1">self.length</span><span class="s0">, </span><span class="s1">self.numVarSelectorRecords)</span>

		<span class="s0">return </span><span class="s1">headerdata + data</span>


<span class="s0">class </span><span class="s1">cmap_format_unknown(CmapSubtable):</span>

	<span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">cmapName = self.__class__.__name__[:</span><span class="s2">12</span><span class="s1">] + str(self.format)</span>
		<span class="s1">writer.begintag(cmapName</span><span class="s0">, </span><span class="s1">[</span>
				<span class="s1">(</span><span class="s5">&quot;platformID&quot;</span><span class="s0">, </span><span class="s1">self.platformID)</span><span class="s0">,</span>
				<span class="s1">(</span><span class="s5">&quot;platEncID&quot;</span><span class="s0">, </span><span class="s1">self.platEncID)</span><span class="s0">,</span>
				<span class="s1">])</span>
		<span class="s1">writer.newline()</span>
		<span class="s1">writer.dumphex(self.data)</span>
		<span class="s1">writer.endtag(cmapName)</span>
		<span class="s1">writer.newline()</span>

	<span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.data = readHex(content)</span>
		<span class="s1">self.cmap = {}</span>

	<span class="s0">def </span><span class="s1">decompileHeader(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s1">self.language = </span><span class="s2">0  </span><span class="s4"># dummy value</span>
		<span class="s1">self.data = data</span>

	<span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s4"># we usually get here indirectly from the subtable __getattr__ function, in which case both args must be None.</span>
		<span class="s4"># If not, someone is calling the subtable decompile() directly, and must provide both args.</span>
		<span class="s0">if </span><span class="s1">data </span><span class="s0">is not None and </span><span class="s1">ttFont </span><span class="s0">is not None</span><span class="s1">:</span>
			<span class="s1">self.decompileHeader(data</span><span class="s0">, </span><span class="s1">ttFont)</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">assert </span><span class="s1">(data </span><span class="s0">is None and </span><span class="s1">ttFont </span><span class="s0">is None</span><span class="s1">)</span><span class="s0">, </span><span class="s5">&quot;Need both data and ttFont arguments&quot;</span>

	<span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
		<span class="s0">if </span><span class="s1">self.data:</span>
			<span class="s0">return </span><span class="s1">self.data</span>
		<span class="s0">else</span><span class="s1">:</span>
			<span class="s0">return None</span>

<span class="s1">cmap_classes = {</span>
		<span class="s2">0</span><span class="s1">: cmap_format_0</span><span class="s0">,</span>
		<span class="s2">2</span><span class="s1">: cmap_format_2</span><span class="s0">,</span>
		<span class="s2">4</span><span class="s1">: cmap_format_4</span><span class="s0">,</span>
		<span class="s2">6</span><span class="s1">: cmap_format_6</span><span class="s0">,</span>
		<span class="s2">12</span><span class="s1">: cmap_format_12</span><span class="s0">,</span>
		<span class="s2">13</span><span class="s1">: cmap_format_13</span><span class="s0">,</span>
		<span class="s2">14</span><span class="s1">: cmap_format_14</span><span class="s0">,</span>
<span class="s1">}</span>
</pre>
</body>
</html>