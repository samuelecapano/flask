<html>
<head>
<title>backend_svg.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
backend_svg.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">codecs</span>
<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">gzip</span>
<span class="s0">import </span><span class="s1">hashlib</span>
<span class="s0">from </span><span class="s1">io </span><span class="s0">import </span><span class="s1">BytesIO</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">uuid</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">PIL </span><span class="s0">import </span><span class="s1">Image</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">cbook</span><span class="s0">, </span><span class="s1">font_manager </span><span class="s0">as </span><span class="s1">fm</span>
<span class="s0">from </span><span class="s1">matplotlib.backend_bases </span><span class="s0">import </span><span class="s1">(</span>
     <span class="s1">_Backend</span><span class="s0">, </span><span class="s1">FigureCanvasBase</span><span class="s0">, </span><span class="s1">FigureManagerBase</span><span class="s0">, </span><span class="s1">RendererBase)</span>
<span class="s0">from </span><span class="s1">matplotlib.backends.backend_mixed </span><span class="s0">import </span><span class="s1">MixedModeRenderer</span>
<span class="s0">from </span><span class="s1">matplotlib.colors </span><span class="s0">import </span><span class="s1">rgb2hex</span>
<span class="s0">from </span><span class="s1">matplotlib.dates </span><span class="s0">import </span><span class="s1">UTC</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_path</span>
<span class="s0">from </span><span class="s1">matplotlib.transforms </span><span class="s0">import </span><span class="s1">Affine2D</span><span class="s0">, </span><span class="s1">Affine2DBase</span>


<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s2"># ----------------------------------------------------------------------</span>
<span class="s2"># SimpleXMLWriter class</span>
<span class="s2">#</span>
<span class="s2"># Based on an original by Fredrik Lundh, but modified here to:</span>
<span class="s2">#   1. Support modern Python idioms</span>
<span class="s2">#   2. Remove encoding support (it's handled by the file writer instead)</span>
<span class="s2">#   3. Support proper indentation</span>
<span class="s2">#   4. Minify things a little bit</span>

<span class="s2"># --------------------------------------------------------------------</span>
<span class="s2"># The SimpleXMLWriter module is</span>
<span class="s2">#</span>
<span class="s2"># Copyright (c) 2001-2004 by Fredrik Lundh</span>
<span class="s2">#</span>
<span class="s2"># By obtaining, using, and/or copying this software and/or its</span>
<span class="s2"># associated documentation, you agree that you have read, understood,</span>
<span class="s2"># and will comply with the following terms and conditions:</span>
<span class="s2">#</span>
<span class="s2"># Permission to use, copy, modify, and distribute this software and</span>
<span class="s2"># its associated documentation for any purpose and without fee is</span>
<span class="s2"># hereby granted, provided that the above copyright notice appears in</span>
<span class="s2"># all copies, and that both that copyright notice and this permission</span>
<span class="s2"># notice appear in supporting documentation, and that the name of</span>
<span class="s2"># Secret Labs AB or the author not be used in advertising or publicity</span>
<span class="s2"># pertaining to distribution of the software without specific, written</span>
<span class="s2"># prior permission.</span>
<span class="s2">#</span>
<span class="s2"># SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD</span>
<span class="s2"># TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-</span>
<span class="s2"># ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR</span>
<span class="s2"># BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY</span>
<span class="s2"># DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,</span>
<span class="s2"># WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</span>
<span class="s2"># ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE</span>
<span class="s2"># OF THIS SOFTWARE.</span>
<span class="s2"># --------------------------------------------------------------------</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _escape_cdata&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">escape_cdata(s):</span>
    <span class="s0">return </span><span class="s1">_escape_cdata(s)</span>


<span class="s0">def </span><span class="s1">_escape_cdata(s):</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;amp;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;lt;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;gt;&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">s</span>


<span class="s1">_escape_xml_comment = re.compile(</span><span class="s3">r'-(?=-)'</span><span class="s1">)</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _escape_comment&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">escape_comment(s):</span>
    <span class="s0">return </span><span class="s1">_escape_comment.sub(s)</span>


<span class="s0">def </span><span class="s1">_escape_comment(s):</span>
    <span class="s1">s = _escape_cdata(s)</span>
    <span class="s0">return </span><span class="s1">_escape_xml_comment.sub(</span><span class="s3">'- '</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _escape_attrib&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">escape_attrib(s):</span>
    <span class="s0">return </span><span class="s1">_escape_attrib(s)</span>


<span class="s0">def </span><span class="s1">_escape_attrib(s):</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&amp;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;amp;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;'&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;apos;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">'&quot;'</span><span class="s0">, </span><span class="s3">&quot;&amp;quot;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&lt;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;lt;&quot;</span><span class="s1">)</span>
    <span class="s1">s = s.replace(</span><span class="s3">&quot;&gt;&quot;</span><span class="s0">, </span><span class="s3">&quot;&amp;gt;&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">_quote_escape_attrib(s):</span>
    <span class="s0">return </span><span class="s1">(</span><span class="s3">'&quot;' </span><span class="s1">+ _escape_cdata(s) + </span><span class="s3">'&quot;' </span><span class="s0">if </span><span class="s3">'&quot;' </span><span class="s0">not in </span><span class="s1">s </span><span class="s0">else</span>
            <span class="s3">&quot;'&quot; </span><span class="s1">+ _escape_cdata(s) + </span><span class="s3">&quot;'&quot; </span><span class="s0">if </span><span class="s3">&quot;'&quot; </span><span class="s0">not in </span><span class="s1">s </span><span class="s0">else</span>
            <span class="s3">'&quot;' </span><span class="s1">+ _escape_attrib(s) + </span><span class="s3">'&quot;'</span><span class="s1">)</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _short_float_fmt&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">short_float_fmt(x):</span>
    <span class="s0">return </span><span class="s1">_short_float_fmt(x)</span>


<span class="s0">def </span><span class="s1">_short_float_fmt(x):</span>
    <span class="s4">&quot;&quot;&quot; 
    Create a short string representation of a float, which is %f 
    formatting with trailing zeros and the decimal point removed. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s3">'{0:f}'</span><span class="s1">.format(x).rstrip(</span><span class="s3">'0'</span><span class="s1">).rstrip(</span><span class="s3">'.'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">XMLWriter:</span>
    <span class="s4">&quot;&quot;&quot; 
    Parameters 
    ---------- 
    file : writable text file-like object 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">file):</span>
        <span class="s1">self.__write = file.write</span>
        <span class="s0">if </span><span class="s1">hasattr(file</span><span class="s0">, </span><span class="s3">&quot;flush&quot;</span><span class="s1">):</span>
            <span class="s1">self.flush = file.flush</span>
        <span class="s1">self.__open = </span><span class="s5">0  </span><span class="s2"># true if start tag is open</span>
        <span class="s1">self.__tags = []</span>
        <span class="s1">self.__data = []</span>
        <span class="s1">self.__indentation = </span><span class="s3">&quot; &quot; </span><span class="s1">* </span><span class="s5">64</span>

    <span class="s0">def </span><span class="s1">__flush(self</span><span class="s0">, </span><span class="s1">indent=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2"># flush internal buffers</span>
        <span class="s0">if </span><span class="s1">self.__open:</span>
            <span class="s0">if </span><span class="s1">indent:</span>
                <span class="s1">self.__write(</span><span class="s3">&quot;&gt;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.__write(</span><span class="s3">&quot;&gt;&quot;</span><span class="s1">)</span>
            <span class="s1">self.__open = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">self.__data:</span>
            <span class="s1">data = </span><span class="s3">''</span><span class="s1">.join(self.__data)</span>
            <span class="s1">self.__write(_escape_cdata(data))</span>
            <span class="s1">self.__data = []</span>

    <span class="s0">def </span><span class="s1">start(self</span><span class="s0">, </span><span class="s1">tag</span><span class="s0">, </span><span class="s1">attrib={}</span><span class="s0">, </span><span class="s1">**extra):</span>
        <span class="s4">&quot;&quot;&quot; 
        Open a new element.  Attributes can be given as keyword 
        arguments, or as a string/string dictionary. The method returns 
        an opaque identifier that can be passed to the :meth:`close` 
        method, to close all open elements up to and including this one. 
 
        Parameters 
        ---------- 
        tag 
            Element tag. 
        attrib 
            Attribute dictionary.  Alternatively, attributes can be given as 
            keyword arguments. 
 
        Returns 
        ------- 
        An element identifier. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__flush()</span>
        <span class="s1">tag = _escape_cdata(tag)</span>
        <span class="s1">self.__data = []</span>
        <span class="s1">self.__tags.append(tag)</span>
        <span class="s1">self.__write(self.__indentation[:len(self.__tags) - </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.__write(</span><span class="s3">&quot;&lt;%s&quot; </span><span class="s1">% tag)</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">{**attrib</span><span class="s0">, </span><span class="s1">**extra}.items():</span>
            <span class="s0">if </span><span class="s1">v:</span>
                <span class="s1">k = _escape_cdata(k)</span>
                <span class="s1">v = _quote_escape_attrib(v)</span>
                <span class="s1">self.__write(</span><span class="s3">' %s=%s' </span><span class="s1">% (k</span><span class="s0">, </span><span class="s1">v))</span>
        <span class="s1">self.__open = </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s1">len(self.__tags) - </span><span class="s5">1</span>

    <span class="s0">def </span><span class="s1">comment(self</span><span class="s0">, </span><span class="s1">comment):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add a comment to the output stream. 
 
        Parameters 
        ---------- 
        comment : str 
            Comment text. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__flush()</span>
        <span class="s1">self.__write(self.__indentation[:len(self.__tags)])</span>
        <span class="s1">self.__write(</span><span class="s3">&quot;&lt;!-- %s --&gt;</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s1">% _escape_comment(comment))</span>

    <span class="s0">def </span><span class="s1">data(self</span><span class="s0">, </span><span class="s1">text):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add character data to the output stream. 
 
        Parameters 
        ---------- 
        text : str 
            Character data. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.__data.append(text)</span>

    <span class="s0">def </span><span class="s1">end(self</span><span class="s0">, </span><span class="s1">tag=</span><span class="s0">None, </span><span class="s1">indent=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Close the current element (opened by the most recent call to 
        :meth:`start`). 
 
        Parameters 
        ---------- 
        tag 
            Element tag.  If given, the tag must match the start tag.  If 
            omitted, the current element is closed. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">tag:</span>
            <span class="s0">assert </span><span class="s1">self.__tags</span><span class="s0">, </span><span class="s3">&quot;unbalanced end(%s)&quot; </span><span class="s1">% tag</span>
            <span class="s0">assert </span><span class="s1">_escape_cdata(tag) == self.__tags[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s3">&quot;expected end(%s), got %s&quot; </span><span class="s1">% (self.__tags[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tag)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">self.__tags</span><span class="s0">, </span><span class="s3">&quot;unbalanced end()&quot;</span>
        <span class="s1">tag = self.__tags.pop()</span>
        <span class="s0">if </span><span class="s1">self.__data:</span>
            <span class="s1">self.__flush(indent)</span>
        <span class="s0">elif </span><span class="s1">self.__open:</span>
            <span class="s1">self.__open = </span><span class="s5">0</span>
            <span class="s1">self.__write(</span><span class="s3">&quot;/&gt;</span><span class="s0">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">indent:</span>
            <span class="s1">self.__write(self.__indentation[:len(self.__tags)])</span>
        <span class="s1">self.__write(</span><span class="s3">&quot;&lt;/%s&gt;</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s1">% tag)</span>

    <span class="s0">def </span><span class="s1">close(self</span><span class="s0">, </span><span class="s1">id):</span>
        <span class="s4">&quot;&quot;&quot; 
        Close open elements, up to (and including) the element identified 
        by the given identifier. 
 
        Parameters 
        ---------- 
        id 
            Element identifier, as returned by the :meth:`start` method. 
        &quot;&quot;&quot;</span>
        <span class="s0">while </span><span class="s1">len(self.__tags) &gt; id:</span>
            <span class="s1">self.end()</span>

    <span class="s0">def </span><span class="s1">element(self</span><span class="s0">, </span><span class="s1">tag</span><span class="s0">, </span><span class="s1">text=</span><span class="s0">None, </span><span class="s1">attrib={}</span><span class="s0">, </span><span class="s1">**extra):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add an entire element.  This is the same as calling :meth:`start`, 
        :meth:`data`, and :meth:`end` in sequence. The *text* argument can be 
        omitted. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.start(tag</span><span class="s0">, </span><span class="s1">attrib</span><span class="s0">, </span><span class="s1">**extra)</span>
        <span class="s0">if </span><span class="s1">text:</span>
            <span class="s1">self.data(text)</span>
        <span class="s1">self.end(indent=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">flush(self):</span>
        <span class="s4">&quot;&quot;&quot;Flush the output stream.&quot;&quot;&quot;</span>
        <span class="s0">pass  </span><span class="s2"># replaced by the constructor</span>


<span class="s0">def </span><span class="s1">_generate_transform(transform_list):</span>
    <span class="s1">parts = []</span>
    <span class="s0">for </span><span class="s1">type</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">transform_list:</span>
        <span class="s0">if </span><span class="s1">(type == </span><span class="s3">'scale' </span><span class="s0">and </span><span class="s1">(value == (</span><span class="s5">1</span><span class="s0">,</span><span class="s1">) </span><span class="s0">or </span><span class="s1">value == (</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
                <span class="s0">or </span><span class="s1">type == </span><span class="s3">'translate' </span><span class="s0">and </span><span class="s1">value == (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s0">or </span><span class="s1">type == </span><span class="s3">'rotate' </span><span class="s0">and </span><span class="s1">value == (</span><span class="s5">0</span><span class="s0">,</span><span class="s1">)):</span>
            <span class="s0">continue</span>
        <span class="s0">if </span><span class="s1">type == </span><span class="s3">'matrix' </span><span class="s0">and </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">Affine2DBase):</span>
            <span class="s1">value = value.to_values()</span>
        <span class="s1">parts.append(</span><span class="s3">'%s(%s)' </span><span class="s1">% (</span>
            <span class="s1">type</span><span class="s0">, </span><span class="s3">' '</span><span class="s1">.join(_short_float_fmt(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">value)))</span>
    <span class="s0">return </span><span class="s3">' '</span><span class="s1">.join(parts)</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">generate_transform(transform_list=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">_generate_transform(transform_list </span><span class="s0">or </span><span class="s1">[])</span>


<span class="s0">def </span><span class="s1">_generate_css(attrib):</span>
    <span class="s0">return </span><span class="s3">&quot;; &quot;</span><span class="s1">.join(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s3">: </span><span class="s0">{</span><span class="s1">v</span><span class="s0">}</span><span class="s3">&quot; </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">attrib.items())</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">generate_css(attrib=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">_generate_css(attrib </span><span class="s0">or </span><span class="s1">{})</span>


<span class="s1">_capstyle_d = {</span><span class="s3">'projecting'</span><span class="s1">: </span><span class="s3">'square'</span><span class="s0">, </span><span class="s3">'butt'</span><span class="s1">: </span><span class="s3">'butt'</span><span class="s0">, </span><span class="s3">'round'</span><span class="s1">: </span><span class="s3">'round'</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">_check_is_str(info</span><span class="s0">, </span><span class="s1">key):</span>
    <span class="s0">if not </span><span class="s1">isinstance(info</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f'Invalid type for </span><span class="s0">{</span><span class="s1">key</span><span class="s0">} </span><span class="s3">metadata. Expected str, not '</span>
                        <span class="s3">f'</span><span class="s0">{</span><span class="s1">type(info)</span><span class="s0">}</span><span class="s3">.'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_check_is_iterable_of_str(infos</span><span class="s0">, </span><span class="s1">key):</span>
    <span class="s0">if </span><span class="s1">np.iterable(infos):</span>
        <span class="s0">for </span><span class="s1">info </span><span class="s0">in </span><span class="s1">infos:</span>
            <span class="s0">if not </span><span class="s1">isinstance(info</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f'Invalid type for </span><span class="s0">{</span><span class="s1">key</span><span class="s0">} </span><span class="s3">metadata. Expected '</span>
                                <span class="s3">f'iterable of str, not </span><span class="s0">{</span><span class="s1">type(info)</span><span class="s0">}</span><span class="s3">.'</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f'Invalid type for </span><span class="s0">{</span><span class="s1">key</span><span class="s0">} </span><span class="s3">metadata. Expected str or '</span>
                        <span class="s3">f'iterable of str, not </span><span class="s0">{</span><span class="s1">type(infos)</span><span class="s0">}</span><span class="s3">.'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">RendererSVG(RendererBase):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">svgwriter</span><span class="s0">, </span><span class="s1">basename=</span><span class="s0">None, </span><span class="s1">image_dpi=</span><span class="s5">72</span><span class="s0">,</span>
                 <span class="s1">*</span><span class="s0">, </span><span class="s1">metadata=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.writer = XMLWriter(svgwriter)</span>
        <span class="s1">self.image_dpi = image_dpi  </span><span class="s2"># actual dpi at which we rasterize stuff</span>

        <span class="s0">if </span><span class="s1">basename </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">basename = getattr(svgwriter</span><span class="s0">, </span><span class="s3">&quot;name&quot;</span><span class="s0">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">isinstance(basename</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">basename = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self.basename = basename</span>

        <span class="s1">self._groupd = {}</span>
        <span class="s1">self._image_counter = itertools.count()</span>
        <span class="s1">self._clipd = {}</span>
        <span class="s1">self._markers = {}</span>
        <span class="s1">self._path_collection_id = </span><span class="s5">0</span>
        <span class="s1">self._hatchd = {}</span>
        <span class="s1">self._has_gouraud = </span><span class="s0">False</span>
        <span class="s1">self._n_gradients = </span><span class="s5">0</span>

        <span class="s1">super().__init__()</span>
        <span class="s1">self._glyph_map = dict()</span>
        <span class="s1">str_height = _short_float_fmt(height)</span>
        <span class="s1">str_width = _short_float_fmt(width)</span>
        <span class="s1">svgwriter.write(svgProlog)</span>
        <span class="s1">self._start_id = self.writer.start(</span>
            <span class="s3">'svg'</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s3">'%spt' </span><span class="s1">% str_width</span><span class="s0">,</span>
            <span class="s1">height=</span><span class="s3">'%spt' </span><span class="s1">% str_height</span><span class="s0">,</span>
            <span class="s1">viewBox=</span><span class="s3">'0 0 %s %s' </span><span class="s1">% (str_width</span><span class="s0">, </span><span class="s1">str_height)</span><span class="s0">,</span>
            <span class="s1">xmlns=</span><span class="s3">&quot;http://www.w3.org/2000/svg&quot;</span><span class="s0">,</span>
            <span class="s1">version=</span><span class="s3">&quot;1.1&quot;</span><span class="s0">,</span>
            <span class="s1">attrib={</span><span class="s3">'xmlns:xlink'</span><span class="s1">: </span><span class="s3">&quot;http://www.w3.org/1999/xlink&quot;</span><span class="s1">})</span>
        <span class="s1">self._write_metadata(metadata)</span>
        <span class="s1">self._write_default_style()</span>

    <span class="s0">def </span><span class="s1">finalize(self):</span>
        <span class="s1">self._write_clips()</span>
        <span class="s1">self._write_hatches()</span>
        <span class="s1">self.writer.close(self._start_id)</span>
        <span class="s1">self.writer.flush()</span>

    <span class="s0">def </span><span class="s1">_write_metadata(self</span><span class="s0">, </span><span class="s1">metadata):</span>
        <span class="s2"># Add metadata following the Dublin Core Metadata Initiative, and the</span>
        <span class="s2"># Creative Commons Rights Expression Language. This is mainly for</span>
        <span class="s2"># compatibility with Inkscape.</span>
        <span class="s0">if </span><span class="s1">metadata </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">metadata = {}</span>
        <span class="s1">metadata = {</span>
            <span class="s3">'Format'</span><span class="s1">: </span><span class="s3">'image/svg+xml'</span><span class="s0">,</span>
            <span class="s3">'Type'</span><span class="s1">: </span><span class="s3">'http://purl.org/dc/dcmitype/StillImage'</span><span class="s0">,</span>
            <span class="s3">'Creator'</span><span class="s1">:</span>
                <span class="s3">f'Matplotlib v</span><span class="s0">{</span><span class="s1">mpl.__version__</span><span class="s0">}</span><span class="s3">, https://matplotlib.org/'</span><span class="s0">,</span>
            <span class="s1">**metadata</span>
        <span class="s1">}</span>
        <span class="s1">writer = self.writer</span>

        <span class="s0">if </span><span class="s3">'Title' </span><span class="s0">in </span><span class="s1">metadata:</span>
            <span class="s1">title = metadata[</span><span class="s3">'Title'</span><span class="s1">]</span>
            <span class="s1">_check_is_str(title</span><span class="s0">, </span><span class="s3">'Title'</span><span class="s1">)</span>
            <span class="s1">writer.element(</span><span class="s3">'title'</span><span class="s0">, </span><span class="s1">text=title)</span>

        <span class="s2"># Special handling.</span>
        <span class="s1">date = metadata.get(</span><span class="s3">'Date'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">date </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(date</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">dates = [date]</span>
            <span class="s0">elif </span><span class="s1">isinstance(date</span><span class="s0">, </span><span class="s1">(datetime.datetime</span><span class="s0">, </span><span class="s1">datetime.date)):</span>
                <span class="s1">dates = [date.isoformat()]</span>
            <span class="s0">elif </span><span class="s1">np.iterable(date):</span>
                <span class="s1">dates = []</span>
                <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">date:</span>
                    <span class="s0">if </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">str):</span>
                        <span class="s1">dates.append(d)</span>
                    <span class="s0">elif </span><span class="s1">isinstance(d</span><span class="s0">, </span><span class="s1">(datetime.datetime</span><span class="s0">, </span><span class="s1">datetime.date)):</span>
                        <span class="s1">dates.append(d.isoformat())</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">raise </span><span class="s1">TypeError(</span>
                            <span class="s3">f'Invalid type for Date metadata. '</span>
                            <span class="s3">f'Expected iterable of str, date, or datetime, '</span>
                            <span class="s3">f'not </span><span class="s0">{</span><span class="s1">type(d)</span><span class="s0">}</span><span class="s3">.'</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">f'Invalid type for Date metadata. '</span>
                                <span class="s3">f'Expected str, date, datetime, or iterable '</span>
                                <span class="s3">f'of the same, not </span><span class="s0">{</span><span class="s1">type(date)</span><span class="s0">}</span><span class="s3">.'</span><span class="s1">)</span>
            <span class="s1">metadata[</span><span class="s3">'Date'</span><span class="s1">] = </span><span class="s3">'/'</span><span class="s1">.join(dates)</span>
        <span class="s0">elif </span><span class="s3">'Date' </span><span class="s0">not in </span><span class="s1">metadata:</span>
            <span class="s2"># Do not add `Date` if the user explicitly set `Date` to `None`</span>
            <span class="s2"># Get source date from SOURCE_DATE_EPOCH, if set.</span>
            <span class="s2"># See https://reproducible-builds.org/specs/source-date-epoch/</span>
            <span class="s1">date = os.getenv(</span><span class="s3">&quot;SOURCE_DATE_EPOCH&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">date:</span>
                <span class="s1">date = datetime.datetime.utcfromtimestamp(int(date))</span>
                <span class="s1">metadata[</span><span class="s3">'Date'</span><span class="s1">] = date.replace(tzinfo=UTC).isoformat()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">metadata[</span><span class="s3">'Date'</span><span class="s1">] = datetime.datetime.today().isoformat()</span>

        <span class="s1">mid = </span><span class="s0">None</span>
        <span class="s0">def </span><span class="s1">ensure_metadata(mid):</span>
            <span class="s0">if </span><span class="s1">mid </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">mid</span>
            <span class="s1">mid = writer.start(</span><span class="s3">'metadata'</span><span class="s1">)</span>
            <span class="s1">writer.start(</span><span class="s3">'rdf:RDF'</span><span class="s0">, </span><span class="s1">attrib={</span>
                <span class="s3">'xmlns:dc'</span><span class="s1">: </span><span class="s3">&quot;http://purl.org/dc/elements/1.1/&quot;</span><span class="s0">,</span>
                <span class="s3">'xmlns:cc'</span><span class="s1">: </span><span class="s3">&quot;http://creativecommons.org/ns#&quot;</span><span class="s0">,</span>
                <span class="s3">'xmlns:rdf'</span><span class="s1">: </span><span class="s3">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span><span class="s0">,</span>
            <span class="s1">})</span>
            <span class="s1">writer.start(</span><span class="s3">'cc:Work'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">mid</span>

        <span class="s1">uri = metadata.pop(</span><span class="s3">'Type'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">uri </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">mid = ensure_metadata(mid)</span>
            <span class="s1">writer.element(</span><span class="s3">'dc:type'</span><span class="s0">, </span><span class="s1">attrib={</span><span class="s3">'rdf:resource'</span><span class="s1">: uri})</span>

        <span class="s2"># Single value only.</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'Title'</span><span class="s0">, </span><span class="s3">'Coverage'</span><span class="s0">, </span><span class="s3">'Date'</span><span class="s0">, </span><span class="s3">'Description'</span><span class="s0">, </span><span class="s3">'Format'</span><span class="s0">,</span>
                    <span class="s3">'Identifier'</span><span class="s0">, </span><span class="s3">'Language'</span><span class="s0">, </span><span class="s3">'Relation'</span><span class="s0">, </span><span class="s3">'Source'</span><span class="s1">]:</span>
            <span class="s1">info = metadata.pop(key</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">info </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mid = ensure_metadata(mid)</span>
                <span class="s1">_check_is_str(info</span><span class="s0">, </span><span class="s1">key)</span>
                <span class="s1">writer.element(</span><span class="s3">f'dc:</span><span class="s0">{</span><span class="s1">key.lower()</span><span class="s0">}</span><span class="s3">'</span><span class="s0">, </span><span class="s1">text=info)</span>

        <span class="s2"># Multiple Agent values.</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'Creator'</span><span class="s0">, </span><span class="s3">'Contributor'</span><span class="s0">, </span><span class="s3">'Publisher'</span><span class="s0">, </span><span class="s3">'Rights'</span><span class="s1">]:</span>
            <span class="s1">agents = metadata.pop(key</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">agents </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>

            <span class="s0">if </span><span class="s1">isinstance(agents</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">agents = [agents]</span>

            <span class="s1">_check_is_iterable_of_str(agents</span><span class="s0">, </span><span class="s1">key)</span>
            <span class="s2"># Now we know that we have an iterable of str</span>
            <span class="s1">mid = ensure_metadata(mid)</span>
            <span class="s1">writer.start(</span><span class="s3">f'dc:</span><span class="s0">{</span><span class="s1">key.lower()</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">agent </span><span class="s0">in </span><span class="s1">agents:</span>
                <span class="s1">writer.start(</span><span class="s3">'cc:Agent'</span><span class="s1">)</span>
                <span class="s1">writer.element(</span><span class="s3">'dc:title'</span><span class="s0">, </span><span class="s1">text=agent)</span>
                <span class="s1">writer.end(</span><span class="s3">'cc:Agent'</span><span class="s1">)</span>
            <span class="s1">writer.end(</span><span class="s3">f'dc:</span><span class="s0">{</span><span class="s1">key.lower()</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s2"># Multiple values.</span>
        <span class="s1">keywords = metadata.pop(</span><span class="s3">'Keywords'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">keywords </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(keywords</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">keywords = [keywords]</span>
            <span class="s1">_check_is_iterable_of_str(keywords</span><span class="s0">, </span><span class="s3">'Keywords'</span><span class="s1">)</span>
            <span class="s2"># Now we know that we have an iterable of str</span>
            <span class="s1">mid = ensure_metadata(mid)</span>
            <span class="s1">writer.start(</span><span class="s3">'dc:subject'</span><span class="s1">)</span>
            <span class="s1">writer.start(</span><span class="s3">'rdf:Bag'</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">keyword </span><span class="s0">in </span><span class="s1">keywords:</span>
                <span class="s1">writer.element(</span><span class="s3">'rdf:li'</span><span class="s0">, </span><span class="s1">text=keyword)</span>
            <span class="s1">writer.end(</span><span class="s3">'rdf:Bag'</span><span class="s1">)</span>
            <span class="s1">writer.end(</span><span class="s3">'dc:subject'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">mid </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">writer.close(mid)</span>

        <span class="s0">if </span><span class="s1">metadata:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">'Unknown metadata key(s) passed to SVG writer: ' </span><span class="s1">+</span>
                             <span class="s3">','</span><span class="s1">.join(metadata))</span>

    <span class="s0">def </span><span class="s1">_write_default_style(self):</span>
        <span class="s1">writer = self.writer</span>
        <span class="s1">default_style = _generate_css({</span>
            <span class="s3">'stroke-linejoin'</span><span class="s1">: </span><span class="s3">'round'</span><span class="s0">,</span>
            <span class="s3">'stroke-linecap'</span><span class="s1">: </span><span class="s3">'butt'</span><span class="s1">})</span>
        <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
        <span class="s1">writer.element(</span><span class="s3">'style'</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">'text/css'</span><span class="s0">, </span><span class="s1">text=</span><span class="s3">'*{%s}' </span><span class="s1">% default_style)</span>
        <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_make_id(self</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">content):</span>
        <span class="s1">salt = mpl.rcParams[</span><span class="s3">'svg.hashsalt'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">salt </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">salt = str(uuid.uuid4())</span>
        <span class="s1">m = hashlib.sha256()</span>
        <span class="s1">m.update(salt.encode(</span><span class="s3">'utf8'</span><span class="s1">))</span>
        <span class="s1">m.update(str(content).encode(</span><span class="s3">'utf8'</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s3">'%s%s' </span><span class="s1">% (type</span><span class="s0">, </span><span class="s1">m.hexdigest()[:</span><span class="s5">10</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">_make_flip_transform(self</span><span class="s0">, </span><span class="s1">transform):</span>
        <span class="s0">return </span><span class="s1">transform + Affine2D().scale(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">).translate(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">self.height)</span>

    <span class="s0">def </span><span class="s1">_get_hatch(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">rgbFace):</span>
        <span class="s4">&quot;&quot;&quot; 
        Create a new hatch pattern 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">rgbFace </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">rgbFace = tuple(rgbFace)</span>
        <span class="s1">edge = gc.get_hatch_color()</span>
        <span class="s0">if </span><span class="s1">edge </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">edge = tuple(edge)</span>
        <span class="s1">dictkey = (gc.get_hatch()</span><span class="s0">, </span><span class="s1">rgbFace</span><span class="s0">, </span><span class="s1">edge)</span>
        <span class="s1">oid = self._hatchd.get(dictkey)</span>
        <span class="s0">if </span><span class="s1">oid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">oid = self._make_id(</span><span class="s3">'h'</span><span class="s0">, </span><span class="s1">dictkey)</span>
            <span class="s1">self._hatchd[dictkey] = ((gc.get_hatch_path()</span><span class="s0">, </span><span class="s1">rgbFace</span><span class="s0">, </span><span class="s1">edge)</span><span class="s0">, </span><span class="s1">oid)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">oid = oid</span>
        <span class="s0">return </span><span class="s1">oid</span>

    <span class="s0">def </span><span class="s1">_write_hatches(self):</span>
        <span class="s0">if not </span><span class="s1">len(self._hatchd):</span>
            <span class="s0">return</span>
        <span class="s1">HATCH_SIZE = </span><span class="s5">72</span>
        <span class="s1">writer = self.writer</span>
        <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">(path</span><span class="s0">, </span><span class="s1">face</span><span class="s0">, </span><span class="s1">stroke)</span><span class="s0">, </span><span class="s1">oid </span><span class="s0">in </span><span class="s1">self._hatchd.values():</span>
            <span class="s1">writer.start(</span>
                <span class="s3">'pattern'</span><span class="s0">,</span>
                <span class="s1">id=oid</span><span class="s0">,</span>
                <span class="s1">patternUnits=</span><span class="s3">&quot;userSpaceOnUse&quot;</span><span class="s0">,</span>
                <span class="s1">x=</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s1">width=str(HATCH_SIZE)</span><span class="s0">,</span>
                <span class="s1">height=str(HATCH_SIZE))</span>
            <span class="s1">path_data = self._convert_path(</span>
                <span class="s1">path</span><span class="s0">,</span>
                <span class="s1">Affine2D()</span>
                <span class="s1">.scale(HATCH_SIZE).scale(</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">).translate(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">HATCH_SIZE)</span><span class="s0">,</span>
                <span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">face </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">fill = </span><span class="s3">'none'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">fill = rgb2hex(face)</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'rect'</span><span class="s0">,</span>
                <span class="s1">x=</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s1">width=str(HATCH_SIZE+</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">height=str(HATCH_SIZE+</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">fill=fill)</span>
            <span class="s1">hatch_style = {</span>
                    <span class="s3">'fill'</span><span class="s1">: rgb2hex(stroke)</span><span class="s0">,</span>
                    <span class="s3">'stroke'</span><span class="s1">: rgb2hex(stroke)</span><span class="s0">,</span>
                    <span class="s3">'stroke-width'</span><span class="s1">: str(mpl.rcParams[</span><span class="s3">'hatch.linewidth'</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s3">'stroke-linecap'</span><span class="s1">: </span><span class="s3">'butt'</span><span class="s0">,</span>
                    <span class="s3">'stroke-linejoin'</span><span class="s1">: </span><span class="s3">'miter'</span>
                    <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">stroke[</span><span class="s5">3</span><span class="s1">] &lt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">hatch_style[</span><span class="s3">'stroke-opacity'</span><span class="s1">] = str(stroke[</span><span class="s5">3</span><span class="s1">])</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'path'</span><span class="s0">,</span>
                <span class="s1">d=path_data</span><span class="s0">,</span>
                <span class="s1">style=_generate_css(hatch_style)</span>
                <span class="s1">)</span>
            <span class="s1">writer.end(</span><span class="s3">'pattern'</span><span class="s1">)</span>
        <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_get_style_dict(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">rgbFace):</span>
        <span class="s4">&quot;&quot;&quot;Generate a style string from the GraphicsContext and rgbFace.&quot;&quot;&quot;</span>
        <span class="s1">attrib = {}</span>

        <span class="s1">forced_alpha = gc.get_forced_alpha()</span>

        <span class="s0">if </span><span class="s1">gc.get_hatch() </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">attrib[</span><span class="s3">'fill'</span><span class="s1">] = </span><span class="s3">&quot;url(#%s)&quot; </span><span class="s1">% self._get_hatch(gc</span><span class="s0">, </span><span class="s1">rgbFace)</span>
            <span class="s0">if </span><span class="s1">(rgbFace </span><span class="s0">is not None and </span><span class="s1">len(rgbFace) == </span><span class="s5">4 </span><span class="s0">and </span><span class="s1">rgbFace[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">1.0</span>
                    <span class="s0">and not </span><span class="s1">forced_alpha):</span>
                <span class="s1">attrib[</span><span class="s3">'fill-opacity'</span><span class="s1">] = _short_float_fmt(rgbFace[</span><span class="s5">3</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">rgbFace </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'fill'</span><span class="s1">] = </span><span class="s3">'none'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">tuple(rgbFace[:</span><span class="s5">3</span><span class="s1">]) != (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">):</span>
                    <span class="s1">attrib[</span><span class="s3">'fill'</span><span class="s1">] = rgb2hex(rgbFace)</span>
                <span class="s0">if </span><span class="s1">(len(rgbFace) == </span><span class="s5">4 </span><span class="s0">and </span><span class="s1">rgbFace[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">1.0</span>
                        <span class="s0">and not </span><span class="s1">forced_alpha):</span>
                    <span class="s1">attrib[</span><span class="s3">'fill-opacity'</span><span class="s1">] = _short_float_fmt(rgbFace[</span><span class="s5">3</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">forced_alpha </span><span class="s0">and </span><span class="s1">gc.get_alpha() != </span><span class="s5">1.0</span><span class="s1">:</span>
            <span class="s1">attrib[</span><span class="s3">'opacity'</span><span class="s1">] = _short_float_fmt(gc.get_alpha())</span>

        <span class="s1">offset</span><span class="s0">, </span><span class="s1">seq = gc.get_dashes()</span>
        <span class="s0">if </span><span class="s1">seq </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">attrib[</span><span class="s3">'stroke-dasharray'</span><span class="s1">] = </span><span class="s3">','</span><span class="s1">.join(</span>
                <span class="s1">_short_float_fmt(val) </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">seq)</span>
            <span class="s1">attrib[</span><span class="s3">'stroke-dashoffset'</span><span class="s1">] = _short_float_fmt(float(offset))</span>

        <span class="s1">linewidth = gc.get_linewidth()</span>
        <span class="s0">if </span><span class="s1">linewidth:</span>
            <span class="s1">rgb = gc.get_rgb()</span>
            <span class="s1">attrib[</span><span class="s3">'stroke'</span><span class="s1">] = rgb2hex(rgb)</span>
            <span class="s0">if not </span><span class="s1">forced_alpha </span><span class="s0">and </span><span class="s1">rgb[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">1.0</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'stroke-opacity'</span><span class="s1">] = _short_float_fmt(rgb[</span><span class="s5">3</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">linewidth != </span><span class="s5">1.0</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'stroke-width'</span><span class="s1">] = _short_float_fmt(linewidth)</span>
            <span class="s0">if </span><span class="s1">gc.get_joinstyle() != </span><span class="s3">'round'</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'stroke-linejoin'</span><span class="s1">] = gc.get_joinstyle()</span>
            <span class="s0">if </span><span class="s1">gc.get_capstyle() != </span><span class="s3">'butt'</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'stroke-linecap'</span><span class="s1">] = _capstyle_d[gc.get_capstyle()]</span>

        <span class="s0">return </span><span class="s1">attrib</span>

    <span class="s0">def </span><span class="s1">_get_style(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">rgbFace):</span>
        <span class="s0">return </span><span class="s1">_generate_css(self._get_style_dict(gc</span><span class="s0">, </span><span class="s1">rgbFace))</span>

    <span class="s0">def </span><span class="s1">_get_clip_attrs(self</span><span class="s0">, </span><span class="s1">gc):</span>
        <span class="s1">cliprect = gc.get_clip_rectangle()</span>
        <span class="s1">clippath</span><span class="s0">, </span><span class="s1">clippath_trans = gc.get_clip_path()</span>
        <span class="s0">if </span><span class="s1">clippath </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">clippath_trans = self._make_flip_transform(clippath_trans)</span>
            <span class="s1">dictkey = (id(clippath)</span><span class="s0">, </span><span class="s1">str(clippath_trans))</span>
        <span class="s0">elif </span><span class="s1">cliprect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h = cliprect.bounds</span>
            <span class="s1">y = self.height-(y+h)</span>
            <span class="s1">dictkey = (x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">{}</span>
        <span class="s1">clip = self._clipd.get(dictkey)</span>
        <span class="s0">if </span><span class="s1">clip </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">oid = self._make_id(</span><span class="s3">'p'</span><span class="s0">, </span><span class="s1">dictkey)</span>
            <span class="s0">if </span><span class="s1">clippath </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self._clipd[dictkey] = ((clippath</span><span class="s0">, </span><span class="s1">clippath_trans)</span><span class="s0">, </span><span class="s1">oid)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._clipd[dictkey] = (dictkey</span><span class="s0">, </span><span class="s1">oid)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">clip</span><span class="s0">, </span><span class="s1">oid = clip</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s3">'clip-path'</span><span class="s1">: </span><span class="s3">f'url(#</span><span class="s0">{</span><span class="s1">oid</span><span class="s0">}</span><span class="s3">)'</span><span class="s1">}</span>

    <span class="s0">def </span><span class="s1">_write_clips(self):</span>
        <span class="s0">if not </span><span class="s1">len(self._clipd):</span>
            <span class="s0">return</span>
        <span class="s1">writer = self.writer</span>
        <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">clip</span><span class="s0">, </span><span class="s1">oid </span><span class="s0">in </span><span class="s1">self._clipd.values():</span>
            <span class="s1">writer.start(</span><span class="s3">'clipPath'</span><span class="s0">, </span><span class="s1">id=oid)</span>
            <span class="s0">if </span><span class="s1">len(clip) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">clippath</span><span class="s0">, </span><span class="s1">clippath_trans = clip</span>
                <span class="s1">path_data = self._convert_path(</span>
                    <span class="s1">clippath</span><span class="s0">, </span><span class="s1">clippath_trans</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">writer.element(</span><span class="s3">'path'</span><span class="s0">, </span><span class="s1">d=path_data)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">h = clip</span>
                <span class="s1">writer.element(</span>
                    <span class="s3">'rect'</span><span class="s0">,</span>
                    <span class="s1">x=_short_float_fmt(x)</span><span class="s0">,</span>
                    <span class="s1">y=_short_float_fmt(y)</span><span class="s0">,</span>
                    <span class="s1">width=_short_float_fmt(w)</span><span class="s0">,</span>
                    <span class="s1">height=_short_float_fmt(h))</span>
            <span class="s1">writer.end(</span><span class="s3">'clipPath'</span><span class="s1">)</span>
        <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">open_group(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">gid=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">gid:</span>
            <span class="s1">self.writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">id=gid)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._groupd[s] = self._groupd.get(s</span><span class="s0">, </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span>
            <span class="s1">self.writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">id=</span><span class="s3">&quot;%s_%d&quot; </span><span class="s1">% (s</span><span class="s0">, </span><span class="s1">self._groupd[s]))</span>

    <span class="s0">def </span><span class="s1">close_group(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">self.writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">option_image_nocomposite(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">return not </span><span class="s1">mpl.rcParams[</span><span class="s3">'image.composite_image'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_convert_path(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">transform=</span><span class="s0">None, </span><span class="s1">clip=</span><span class="s0">None, </span><span class="s1">simplify=</span><span class="s0">None,</span>
                      <span class="s1">sketch=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">clip:</span>
            <span class="s1">clip = (</span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s0">, </span><span class="s1">self.width</span><span class="s0">, </span><span class="s1">self.height)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">clip = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">_path.convert_to_string(</span>
            <span class="s1">path</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">clip</span><span class="s0">, </span><span class="s1">simplify</span><span class="s0">, </span><span class="s1">sketch</span><span class="s0">, </span><span class="s5">6</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s6">b'M'</span><span class="s0">, </span><span class="s6">b'L'</span><span class="s0">, </span><span class="s6">b'Q'</span><span class="s0">, </span><span class="s6">b'C'</span><span class="s0">, </span><span class="s6">b'z'</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">).decode(</span><span class="s3">'ascii'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_path(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">rgbFace=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">trans_and_flip = self._make_flip_transform(transform)</span>
        <span class="s1">clip = (rgbFace </span><span class="s0">is None and </span><span class="s1">gc.get_hatch_path() </span><span class="s0">is None</span><span class="s1">)</span>
        <span class="s1">simplify = path.should_simplify </span><span class="s0">and </span><span class="s1">clip</span>
        <span class="s1">path_data = self._convert_path(</span>
            <span class="s1">path</span><span class="s0">, </span><span class="s1">trans_and_flip</span><span class="s0">, </span><span class="s1">clip=clip</span><span class="s0">, </span><span class="s1">simplify=simplify</span><span class="s0">,</span>
            <span class="s1">sketch=gc.get_sketch_params())</span>

        <span class="s0">if </span><span class="s1">gc.get_url() </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.start(</span><span class="s3">'a'</span><span class="s0">, </span><span class="s1">{</span><span class="s3">'xlink:href'</span><span class="s1">: gc.get_url()})</span>
        <span class="s1">self.writer.element(</span><span class="s3">'path'</span><span class="s0">, </span><span class="s1">d=path_data</span><span class="s0">, </span><span class="s1">**self._get_clip_attrs(gc)</span><span class="s0">,</span>
                            <span class="s1">style=self._get_style(gc</span><span class="s0">, </span><span class="s1">rgbFace))</span>
        <span class="s0">if </span><span class="s1">gc.get_url() </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.end(</span><span class="s3">'a'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_markers(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">marker_path</span><span class="s0">, </span><span class="s1">marker_trans</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">trans</span><span class="s0">, </span><span class="s1">rgbFace=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>

        <span class="s0">if not </span><span class="s1">len(path.vertices):</span>
            <span class="s0">return</span>

        <span class="s1">writer = self.writer</span>
        <span class="s1">path_data = self._convert_path(</span>
            <span class="s1">marker_path</span><span class="s0">,</span>
            <span class="s1">marker_trans + Affine2D().scale(</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">style = self._get_style_dict(gc</span><span class="s0">, </span><span class="s1">rgbFace)</span>
        <span class="s1">dictkey = (path_data</span><span class="s0">, </span><span class="s1">_generate_css(style))</span>
        <span class="s1">oid = self._markers.get(dictkey)</span>
        <span class="s1">style = _generate_css({k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">style.items()</span>
                              <span class="s0">if </span><span class="s1">k.startswith(</span><span class="s3">'stroke'</span><span class="s1">)})</span>

        <span class="s0">if </span><span class="s1">oid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">oid = self._make_id(</span><span class="s3">'m'</span><span class="s0">, </span><span class="s1">dictkey)</span>
            <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
            <span class="s1">writer.element(</span><span class="s3">'path'</span><span class="s0">, </span><span class="s1">id=oid</span><span class="s0">, </span><span class="s1">d=path_data</span><span class="s0">, </span><span class="s1">style=style)</span>
            <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>
            <span class="s1">self._markers[dictkey] = oid</span>

        <span class="s1">writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">**self._get_clip_attrs(gc))</span>
        <span class="s1">trans_and_flip = self._make_flip_transform(trans)</span>
        <span class="s1">attrib = {</span><span class="s3">'xlink:href'</span><span class="s1">: </span><span class="s3">'#%s' </span><span class="s1">% oid}</span>
        <span class="s1">clip = (</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">self.width*</span><span class="s5">72</span><span class="s0">, </span><span class="s1">self.height*</span><span class="s5">72</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">vertices</span><span class="s0">, </span><span class="s1">code </span><span class="s0">in </span><span class="s1">path.iter_segments(</span>
                <span class="s1">trans_and_flip</span><span class="s0">, </span><span class="s1">clip=clip</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">len(vertices):</span>
                <span class="s1">x</span><span class="s0">, </span><span class="s1">y = vertices[-</span><span class="s5">2</span><span class="s1">:]</span>
                <span class="s1">attrib[</span><span class="s3">'x'</span><span class="s1">] = _short_float_fmt(x)</span>
                <span class="s1">attrib[</span><span class="s3">'y'</span><span class="s1">] = _short_float_fmt(y)</span>
                <span class="s1">attrib[</span><span class="s3">'style'</span><span class="s1">] = self._get_style(gc</span><span class="s0">, </span><span class="s1">rgbFace)</span>
                <span class="s1">writer.element(</span><span class="s3">'use'</span><span class="s0">, </span><span class="s1">attrib=attrib)</span>
        <span class="s1">writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_path_collection(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">master_transform</span><span class="s0">, </span><span class="s1">paths</span><span class="s0">, </span><span class="s1">all_transforms</span><span class="s0">,</span>
                             <span class="s1">offsets</span><span class="s0">, </span><span class="s1">offset_trans</span><span class="s0">, </span><span class="s1">facecolors</span><span class="s0">, </span><span class="s1">edgecolors</span><span class="s0">,</span>
                             <span class="s1">linewidths</span><span class="s0">, </span><span class="s1">linestyles</span><span class="s0">, </span><span class="s1">antialiaseds</span><span class="s0">, </span><span class="s1">urls</span><span class="s0">,</span>
                             <span class="s1">offset_position):</span>
        <span class="s2"># Is the optimization worth it? Rough calculation:</span>
        <span class="s2"># cost of emitting a path in-line is</span>
        <span class="s2">#    (len_path + 5) * uses_per_path</span>
        <span class="s2"># cost of definition+use is</span>
        <span class="s2">#    (len_path + 3) + 9 * uses_per_path</span>
        <span class="s1">len_path = len(paths[</span><span class="s5">0</span><span class="s1">].vertices) </span><span class="s0">if </span><span class="s1">len(paths) &gt; </span><span class="s5">0 </span><span class="s0">else </span><span class="s5">0</span>
        <span class="s1">uses_per_path = self._iter_collection_uses_per_path(</span>
            <span class="s1">paths</span><span class="s0">, </span><span class="s1">all_transforms</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">facecolors</span><span class="s0">, </span><span class="s1">edgecolors)</span>
        <span class="s1">should_do_optimization = \</span>
            <span class="s1">len_path + </span><span class="s5">9 </span><span class="s1">* uses_per_path + </span><span class="s5">3 </span><span class="s1">&lt; (len_path + </span><span class="s5">5</span><span class="s1">) * uses_per_path</span>
        <span class="s0">if not </span><span class="s1">should_do_optimization:</span>
            <span class="s0">return </span><span class="s1">super().draw_path_collection(</span>
                <span class="s1">gc</span><span class="s0">, </span><span class="s1">master_transform</span><span class="s0">, </span><span class="s1">paths</span><span class="s0">, </span><span class="s1">all_transforms</span><span class="s0">,</span>
                <span class="s1">offsets</span><span class="s0">, </span><span class="s1">offset_trans</span><span class="s0">, </span><span class="s1">facecolors</span><span class="s0">, </span><span class="s1">edgecolors</span><span class="s0">,</span>
                <span class="s1">linewidths</span><span class="s0">, </span><span class="s1">linestyles</span><span class="s0">, </span><span class="s1">antialiaseds</span><span class="s0">, </span><span class="s1">urls</span><span class="s0">,</span>
                <span class="s1">offset_position)</span>

        <span class="s1">writer = self.writer</span>
        <span class="s1">path_codes = []</span>
        <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(path</span><span class="s0">, </span><span class="s1">transform) </span><span class="s0">in </span><span class="s1">enumerate(self._iter_collection_raw_paths(</span>
                <span class="s1">master_transform</span><span class="s0">, </span><span class="s1">paths</span><span class="s0">, </span><span class="s1">all_transforms)):</span>
            <span class="s1">transform = Affine2D(transform.get_matrix()).scale(</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span>
            <span class="s1">d = self._convert_path(path</span><span class="s0">, </span><span class="s1">transform</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">oid = </span><span class="s3">'C%x_%x_%s' </span><span class="s1">% (</span>
                <span class="s1">self._path_collection_id</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">self._make_id(</span><span class="s3">''</span><span class="s0">, </span><span class="s1">d))</span>
            <span class="s1">writer.element(</span><span class="s3">'path'</span><span class="s0">, </span><span class="s1">id=oid</span><span class="s0">, </span><span class="s1">d=d)</span>
            <span class="s1">path_codes.append(oid)</span>
        <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">xo</span><span class="s0">, </span><span class="s1">yo</span><span class="s0">, </span><span class="s1">path_id</span><span class="s0">, </span><span class="s1">gc0</span><span class="s0">, </span><span class="s1">rgbFace </span><span class="s0">in </span><span class="s1">self._iter_collection(</span>
                <span class="s1">gc</span><span class="s0">, </span><span class="s1">path_codes</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">offset_trans</span><span class="s0">,</span>
                <span class="s1">facecolors</span><span class="s0">, </span><span class="s1">edgecolors</span><span class="s0">, </span><span class="s1">linewidths</span><span class="s0">, </span><span class="s1">linestyles</span><span class="s0">,</span>
                <span class="s1">antialiaseds</span><span class="s0">, </span><span class="s1">urls</span><span class="s0">, </span><span class="s1">offset_position):</span>
            <span class="s1">url = gc0.get_url()</span>
            <span class="s0">if </span><span class="s1">url </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">writer.start(</span><span class="s3">'a'</span><span class="s0">, </span><span class="s1">attrib={</span><span class="s3">'xlink:href'</span><span class="s1">: url})</span>
            <span class="s1">clip_attrs = self._get_clip_attrs(gc0)</span>
            <span class="s0">if </span><span class="s1">clip_attrs:</span>
                <span class="s1">writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">**clip_attrs)</span>
            <span class="s1">attrib = {</span>
                <span class="s3">'xlink:href'</span><span class="s1">: </span><span class="s3">'#%s' </span><span class="s1">% path_id</span><span class="s0">,</span>
                <span class="s3">'x'</span><span class="s1">: _short_float_fmt(xo)</span><span class="s0">,</span>
                <span class="s3">'y'</span><span class="s1">: _short_float_fmt(self.height - yo)</span><span class="s0">,</span>
                <span class="s3">'style'</span><span class="s1">: self._get_style(gc0</span><span class="s0">, </span><span class="s1">rgbFace)</span>
                <span class="s1">}</span>
            <span class="s1">writer.element(</span><span class="s3">'use'</span><span class="s0">, </span><span class="s1">attrib=attrib)</span>
            <span class="s0">if </span><span class="s1">clip_attrs:</span>
                <span class="s1">writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">url </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">writer.end(</span><span class="s3">'a'</span><span class="s1">)</span>

        <span class="s1">self._path_collection_id += </span><span class="s5">1</span>

    <span class="s0">def </span><span class="s1">draw_gouraud_triangle(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">colors</span><span class="s0">, </span><span class="s1">trans):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">self._draw_gouraud_triangle(gc</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">colors</span><span class="s0">, </span><span class="s1">trans)</span>

    <span class="s0">def </span><span class="s1">_draw_gouraud_triangle(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">points</span><span class="s0">, </span><span class="s1">colors</span><span class="s0">, </span><span class="s1">trans):</span>
        <span class="s2"># This uses a method described here:</span>
        <span class="s2">#</span>
        <span class="s2">#   http://www.svgopen.org/2005/papers/Converting3DFaceToSVG/index.html</span>
        <span class="s2">#</span>
        <span class="s2"># that uses three overlapping linear gradients to simulate a</span>
        <span class="s2"># Gouraud triangle.  Each gradient goes from fully opaque in</span>
        <span class="s2"># one corner to fully transparent along the opposite edge.</span>
        <span class="s2"># The line between the stop points is perpendicular to the</span>
        <span class="s2"># opposite edge.  Underlying these three gradients is a solid</span>
        <span class="s2"># triangle whose color is the average of all three points.</span>

        <span class="s1">writer = self.writer</span>
        <span class="s0">if not </span><span class="s1">self._has_gouraud:</span>
            <span class="s1">self._has_gouraud = </span><span class="s0">True</span>
            <span class="s1">writer.start(</span>
                <span class="s3">'filter'</span><span class="s0">,</span>
                <span class="s1">id=</span><span class="s3">'colorAdd'</span><span class="s1">)</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'feComposite'</span><span class="s0">,</span>
                <span class="s1">attrib={</span><span class="s3">'in'</span><span class="s1">: </span><span class="s3">'SourceGraphic'</span><span class="s1">}</span><span class="s0">,</span>
                <span class="s1">in2=</span><span class="s3">'BackgroundImage'</span><span class="s0">,</span>
                <span class="s1">operator=</span><span class="s3">'arithmetic'</span><span class="s0">,</span>
                <span class="s1">k2=</span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s1">k3=</span><span class="s3">&quot;1&quot;</span><span class="s1">)</span>
            <span class="s1">writer.end(</span><span class="s3">'filter'</span><span class="s1">)</span>
            <span class="s2"># feColorMatrix filter to correct opacity</span>
            <span class="s1">writer.start(</span>
                <span class="s3">'filter'</span><span class="s0">,</span>
                <span class="s1">id=</span><span class="s3">'colorMat'</span><span class="s1">)</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'feColorMatrix'</span><span class="s0">,</span>
                <span class="s1">attrib={</span><span class="s3">'type'</span><span class="s1">: </span><span class="s3">'matrix'</span><span class="s1">}</span><span class="s0">,</span>
                <span class="s1">values=</span><span class="s3">'1 0 0 0 0 </span><span class="s0">\n</span><span class="s3">0 1 0 0 0 </span><span class="s0">\n</span><span class="s3">0 0 1 0 0' </span><span class="s1">+</span>
                       <span class="s3">' </span><span class="s0">\n</span><span class="s3">1 1 1 1 0 </span><span class="s0">\n</span><span class="s3">0 0 0 0 1 '</span><span class="s1">)</span>
            <span class="s1">writer.end(</span><span class="s3">'filter'</span><span class="s1">)</span>

        <span class="s1">avg_color = np.average(colors</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">avg_color[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># Skip fully-transparent triangles</span>
            <span class="s0">return</span>

        <span class="s1">trans_and_flip = self._make_flip_transform(trans)</span>
        <span class="s1">tpoints = trans_and_flip.transform(points)</span>

        <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
            <span class="s1">x1</span><span class="s0">, </span><span class="s1">y1 = tpoints[i]</span>
            <span class="s1">x2</span><span class="s0">, </span><span class="s1">y2 = tpoints[(i + </span><span class="s5">1</span><span class="s1">) % </span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">x3</span><span class="s0">, </span><span class="s1">y3 = tpoints[(i + </span><span class="s5">2</span><span class="s1">) % </span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">rgba_color = colors[i]</span>

            <span class="s0">if </span><span class="s1">x2 == x3:</span>
                <span class="s1">xb = x2</span>
                <span class="s1">yb = y1</span>
            <span class="s0">elif </span><span class="s1">y2 == y3:</span>
                <span class="s1">xb = x1</span>
                <span class="s1">yb = y2</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">m1 = (y2 - y3) / (x2 - x3)</span>
                <span class="s1">b1 = y2 - (m1 * x2)</span>
                <span class="s1">m2 = -(</span><span class="s5">1.0 </span><span class="s1">/ m1)</span>
                <span class="s1">b2 = y1 - (m2 * x1)</span>
                <span class="s1">xb = (-b1 + b2) / (m1 - m2)</span>
                <span class="s1">yb = m2 * xb + b2</span>

            <span class="s1">writer.start(</span>
                <span class="s3">'linearGradient'</span><span class="s0">,</span>
                <span class="s1">id=</span><span class="s3">&quot;GR%x_%d&quot; </span><span class="s1">% (self._n_gradients</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">,</span>
                <span class="s1">gradientUnits=</span><span class="s3">&quot;userSpaceOnUse&quot;</span><span class="s0">,</span>
                <span class="s1">x1=_short_float_fmt(x1)</span><span class="s0">, </span><span class="s1">y1=_short_float_fmt(y1)</span><span class="s0">,</span>
                <span class="s1">x2=_short_float_fmt(xb)</span><span class="s0">, </span><span class="s1">y2=_short_float_fmt(yb))</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'stop'</span><span class="s0">,</span>
                <span class="s1">offset=</span><span class="s3">'1'</span><span class="s0">,</span>
                <span class="s1">style=_generate_css({</span>
                    <span class="s3">'stop-color'</span><span class="s1">: rgb2hex(avg_color)</span><span class="s0">,</span>
                    <span class="s3">'stop-opacity'</span><span class="s1">: _short_float_fmt(rgba_color[-</span><span class="s5">1</span><span class="s1">])}))</span>
            <span class="s1">writer.element(</span>
                <span class="s3">'stop'</span><span class="s0">,</span>
                <span class="s1">offset=</span><span class="s3">'0'</span><span class="s0">,</span>
                <span class="s1">style=_generate_css({</span><span class="s3">'stop-color'</span><span class="s1">: rgb2hex(rgba_color)</span><span class="s0">,</span>
                                    <span class="s3">'stop-opacity'</span><span class="s1">: </span><span class="s3">&quot;0&quot;</span><span class="s1">}))</span>

            <span class="s1">writer.end(</span><span class="s3">'linearGradient'</span><span class="s1">)</span>

        <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>

        <span class="s2"># triangle formation using &quot;path&quot;</span>
        <span class="s1">dpath = </span><span class="s3">&quot;M &quot; </span><span class="s1">+ _short_float_fmt(x1)+</span><span class="s3">',' </span><span class="s1">+ _short_float_fmt(y1)</span>
        <span class="s1">dpath += </span><span class="s3">&quot; L &quot; </span><span class="s1">+ _short_float_fmt(x2) + </span><span class="s3">',' </span><span class="s1">+ _short_float_fmt(y2)</span>
        <span class="s1">dpath += </span><span class="s3">&quot; &quot; </span><span class="s1">+ _short_float_fmt(x3) + </span><span class="s3">',' </span><span class="s1">+ _short_float_fmt(y3) + </span><span class="s3">&quot; Z&quot;</span>

        <span class="s1">writer.element(</span>
            <span class="s3">'path'</span><span class="s0">,</span>
            <span class="s1">attrib={</span><span class="s3">'d'</span><span class="s1">: dpath</span><span class="s0">,</span>
                    <span class="s3">'fill'</span><span class="s1">: rgb2hex(avg_color)</span><span class="s0">,</span>
                    <span class="s3">'fill-opacity'</span><span class="s1">: </span><span class="s3">'1'</span><span class="s0">,</span>
                    <span class="s3">'shape-rendering'</span><span class="s1">: </span><span class="s3">&quot;crispEdges&quot;</span><span class="s1">})</span>

        <span class="s1">writer.start(</span>
                <span class="s3">'g'</span><span class="s0">,</span>
                <span class="s1">attrib={</span><span class="s3">'stroke'</span><span class="s1">: </span><span class="s3">&quot;none&quot;</span><span class="s0">,</span>
                        <span class="s3">'stroke-width'</span><span class="s1">: </span><span class="s3">&quot;0&quot;</span><span class="s0">,</span>
                        <span class="s3">'shape-rendering'</span><span class="s1">: </span><span class="s3">&quot;crispEdges&quot;</span><span class="s0">,</span>
                        <span class="s3">'filter'</span><span class="s1">: </span><span class="s3">&quot;url(#colorMat)&quot;</span><span class="s1">})</span>

        <span class="s1">writer.element(</span>
            <span class="s3">'path'</span><span class="s0">,</span>
            <span class="s1">attrib={</span><span class="s3">'d'</span><span class="s1">: dpath</span><span class="s0">,</span>
                    <span class="s3">'fill'</span><span class="s1">: </span><span class="s3">'url(#GR%x_0)' </span><span class="s1">% self._n_gradients</span><span class="s0">,</span>
                    <span class="s3">'shape-rendering'</span><span class="s1">: </span><span class="s3">&quot;crispEdges&quot;</span><span class="s1">})</span>

        <span class="s1">writer.element(</span>
            <span class="s3">'path'</span><span class="s0">,</span>
            <span class="s1">attrib={</span><span class="s3">'d'</span><span class="s1">: dpath</span><span class="s0">,</span>
                    <span class="s3">'fill'</span><span class="s1">: </span><span class="s3">'url(#GR%x_1)' </span><span class="s1">% self._n_gradients</span><span class="s0">,</span>
                    <span class="s3">'filter'</span><span class="s1">: </span><span class="s3">'url(#colorAdd)'</span><span class="s0">,</span>
                    <span class="s3">'shape-rendering'</span><span class="s1">: </span><span class="s3">&quot;crispEdges&quot;</span><span class="s1">})</span>

        <span class="s1">writer.element(</span>
            <span class="s3">'path'</span><span class="s0">,</span>
            <span class="s1">attrib={</span><span class="s3">'d'</span><span class="s1">: dpath</span><span class="s0">,</span>
                    <span class="s3">'fill'</span><span class="s1">: </span><span class="s3">'url(#GR%x_2)' </span><span class="s1">% self._n_gradients</span><span class="s0">,</span>
                    <span class="s3">'filter'</span><span class="s1">: </span><span class="s3">'url(#colorAdd)'</span><span class="s0">,</span>
                    <span class="s3">'shape-rendering'</span><span class="s1">: </span><span class="s3">&quot;crispEdges&quot;</span><span class="s1">})</span>

        <span class="s1">writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

        <span class="s1">self._n_gradients += </span><span class="s5">1</span>

    <span class="s0">def </span><span class="s1">draw_gouraud_triangles(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">triangles_array</span><span class="s0">, </span><span class="s1">colors_array</span><span class="s0">,</span>
                               <span class="s1">transform):</span>
        <span class="s1">self.writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">**self._get_clip_attrs(gc))</span>
        <span class="s1">transform = transform.frozen()</span>
        <span class="s0">for </span><span class="s1">tri</span><span class="s0">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">zip(triangles_array</span><span class="s0">, </span><span class="s1">colors_array):</span>
            <span class="s1">self._draw_gouraud_triangle(gc</span><span class="s0">, </span><span class="s1">tri</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">transform)</span>
        <span class="s1">self.writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">option_scale_image(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">get_image_magnification(self):</span>
        <span class="s0">return </span><span class="s1">self.image_dpi / </span><span class="s5">72.0</span>

    <span class="s0">def </span><span class="s1">draw_image(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">im</span><span class="s0">, </span><span class="s1">transform=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>

        <span class="s1">h</span><span class="s0">, </span><span class="s1">w = im.shape[:</span><span class="s5">2</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">w == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">h == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">clip_attrs = self._get_clip_attrs(gc)</span>
        <span class="s0">if </span><span class="s1">clip_attrs:</span>
            <span class="s2"># Can't apply clip-path directly to the image because the image has</span>
            <span class="s2"># a transformation, which would also be applied to the clip-path.</span>
            <span class="s1">self.writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">**clip_attrs)</span>

        <span class="s1">url = gc.get_url()</span>
        <span class="s0">if </span><span class="s1">url </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.start(</span><span class="s3">'a'</span><span class="s0">, </span><span class="s1">attrib={</span><span class="s3">'xlink:href'</span><span class="s1">: url})</span>

        <span class="s1">attrib = {}</span>
        <span class="s1">oid = gc.get_gid()</span>
        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'svg.image_inline'</span><span class="s1">]:</span>
            <span class="s1">buf = BytesIO()</span>
            <span class="s1">Image.fromarray(im).save(buf</span><span class="s0">, </span><span class="s1">format=</span><span class="s3">&quot;png&quot;</span><span class="s1">)</span>
            <span class="s1">oid = oid </span><span class="s0">or </span><span class="s1">self._make_id(</span><span class="s3">'image'</span><span class="s0">, </span><span class="s1">buf.getvalue())</span>
            <span class="s1">attrib[</span><span class="s3">'xlink:href'</span><span class="s1">] = (</span>
                <span class="s3">&quot;data:image/png;base64,</span><span class="s0">\n</span><span class="s3">&quot; </span><span class="s1">+</span>
                <span class="s1">base64.b64encode(buf.getvalue()).decode(</span><span class="s3">'ascii'</span><span class="s1">))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.basename </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot save image data to filesystem when &quot;</span>
                                 <span class="s3">&quot;writing SVG to an in-memory buffer&quot;</span><span class="s1">)</span>
            <span class="s1">filename = </span><span class="s3">'{}.image{}.png'</span><span class="s1">.format(</span>
                <span class="s1">self.basename</span><span class="s0">, </span><span class="s1">next(self._image_counter))</span>
            <span class="s1">_log.info(</span><span class="s3">'Writing image file for inclusion: %s'</span><span class="s0">, </span><span class="s1">filename)</span>
            <span class="s1">Image.fromarray(im).save(filename)</span>
            <span class="s1">oid = oid </span><span class="s0">or </span><span class="s3">'Im_' </span><span class="s1">+ self._make_id(</span><span class="s3">'image'</span><span class="s0">, </span><span class="s1">filename)</span>
            <span class="s1">attrib[</span><span class="s3">'xlink:href'</span><span class="s1">] = filename</span>
        <span class="s1">attrib[</span><span class="s3">'id'</span><span class="s1">] = oid</span>

        <span class="s0">if </span><span class="s1">transform </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">w = </span><span class="s5">72.0 </span><span class="s1">* w / self.image_dpi</span>
            <span class="s1">h = </span><span class="s5">72.0 </span><span class="s1">* h / self.image_dpi</span>

            <span class="s1">self.writer.element(</span>
                <span class="s3">'image'</span><span class="s0">,</span>
                <span class="s1">transform=_generate_transform([</span>
                    <span class="s1">(</span><span class="s3">'scale'</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s3">'translate'</span><span class="s0">, </span><span class="s1">(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-h))])</span><span class="s0">,</span>
                <span class="s1">x=_short_float_fmt(x)</span><span class="s0">,</span>
                <span class="s1">y=_short_float_fmt(-(self.height - y - h))</span><span class="s0">,</span>
                <span class="s1">width=_short_float_fmt(w)</span><span class="s0">, </span><span class="s1">height=_short_float_fmt(h)</span><span class="s0">,</span>
                <span class="s1">attrib=attrib)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">alpha = gc.get_alpha()</span>
            <span class="s0">if </span><span class="s1">alpha != </span><span class="s5">1.0</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'opacity'</span><span class="s1">] = _short_float_fmt(alpha)</span>

            <span class="s1">flipped = (</span>
                <span class="s1">Affine2D().scale(</span><span class="s5">1.0 </span><span class="s1">/ w</span><span class="s0">, </span><span class="s5">1.0 </span><span class="s1">/ h) +</span>
                <span class="s1">transform +</span>
                <span class="s1">Affine2D()</span>
                <span class="s1">.translate(x</span><span class="s0">, </span><span class="s1">y)</span>
                <span class="s1">.scale(</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">)</span>
                <span class="s1">.translate(</span><span class="s5">0.0</span><span class="s0">, </span><span class="s1">self.height))</span>

            <span class="s1">attrib[</span><span class="s3">'transform'</span><span class="s1">] = _generate_transform(</span>
                <span class="s1">[(</span><span class="s3">'matrix'</span><span class="s0">, </span><span class="s1">flipped.frozen())])</span>
            <span class="s1">attrib[</span><span class="s3">'style'</span><span class="s1">] = (</span>
                <span class="s3">'image-rendering:crisp-edges;'</span>
                <span class="s3">'image-rendering:pixelated'</span><span class="s1">)</span>
            <span class="s1">self.writer.element(</span>
                <span class="s3">'image'</span><span class="s0">,</span>
                <span class="s1">width=_short_float_fmt(w)</span><span class="s0">, </span><span class="s1">height=_short_float_fmt(h)</span><span class="s0">,</span>
                <span class="s1">attrib=attrib)</span>

        <span class="s0">if </span><span class="s1">url </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.end(</span><span class="s3">'a'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">clip_attrs:</span>
            <span class="s1">self.writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_update_glyph_map_defs(self</span><span class="s0">, </span><span class="s1">glyph_map_new):</span>
        <span class="s4">&quot;&quot;&quot; 
        Emit definitions for not-yet-defined glyphs, and record them as having 
        been defined. 
        &quot;&quot;&quot;</span>
        <span class="s1">writer = self.writer</span>
        <span class="s0">if </span><span class="s1">glyph_map_new:</span>
            <span class="s1">writer.start(</span><span class="s3">'defs'</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">char_id</span><span class="s0">, </span><span class="s1">(vertices</span><span class="s0">, </span><span class="s1">codes) </span><span class="s0">in </span><span class="s1">glyph_map_new.items():</span>
                <span class="s1">char_id = self._adjust_char_id(char_id)</span>
                <span class="s2"># x64 to go back to FreeType's internal (integral) units.</span>
                <span class="s1">path_data = self._convert_path(</span>
                    <span class="s1">Path(vertices * </span><span class="s5">64</span><span class="s0">, </span><span class="s1">codes)</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">writer.element(</span>
                    <span class="s3">'path'</span><span class="s0">, </span><span class="s1">id=char_id</span><span class="s0">, </span><span class="s1">d=path_data</span><span class="s0">,</span>
                    <span class="s1">transform=_generate_transform([(</span><span class="s3">'scale'</span><span class="s0">, </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">64</span><span class="s0">,</span><span class="s1">))]))</span>
            <span class="s1">writer.end(</span><span class="s3">'defs'</span><span class="s1">)</span>
            <span class="s1">self._glyph_map.update(glyph_map_new)</span>

    <span class="s0">def </span><span class="s1">_adjust_char_id(self</span><span class="s0">, </span><span class="s1">char_id):</span>
        <span class="s0">return </span><span class="s1">char_id.replace(</span><span class="s3">&quot;%20&quot;</span><span class="s0">, </span><span class="s3">&quot;_&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_draw_text_as_path(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">ismath</span><span class="s0">, </span><span class="s1">mtext=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">writer = self.writer</span>

        <span class="s1">writer.comment(s)</span>

        <span class="s1">glyph_map = self._glyph_map</span>

        <span class="s1">text2path = self._text2path</span>
        <span class="s1">color = rgb2hex(gc.get_rgb())</span>
        <span class="s1">fontsize = prop.get_size_in_points()</span>

        <span class="s1">style = {}</span>
        <span class="s0">if </span><span class="s1">color != </span><span class="s3">'#000000'</span><span class="s1">:</span>
            <span class="s1">style[</span><span class="s3">'fill'</span><span class="s1">] = color</span>
        <span class="s1">alpha = gc.get_alpha() </span><span class="s0">if </span><span class="s1">gc.get_forced_alpha() </span><span class="s0">else </span><span class="s1">gc.get_rgb()[</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">alpha != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">style[</span><span class="s3">'opacity'</span><span class="s1">] = _short_float_fmt(alpha)</span>
        <span class="s1">font_scale = fontsize / text2path.FONT_SCALE</span>
        <span class="s1">attrib = {</span>
            <span class="s3">'style'</span><span class="s1">: _generate_css(style)</span><span class="s0">,</span>
            <span class="s3">'transform'</span><span class="s1">: _generate_transform([</span>
                <span class="s1">(</span><span class="s3">'translate'</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s3">'rotate'</span><span class="s0">, </span><span class="s1">(-angle</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s3">'scale'</span><span class="s0">, </span><span class="s1">(font_scale</span><span class="s0">, </span><span class="s1">-font_scale))])</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">attrib=attrib)</span>

        <span class="s0">if not </span><span class="s1">ismath:</span>
            <span class="s1">font = text2path._get_font(prop)</span>
            <span class="s1">_glyphs = text2path.get_glyphs_with_font(</span>
                <span class="s1">font</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">glyph_map=glyph_map</span><span class="s0">, </span><span class="s1">return_new_glyphs_only=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">glyph_info</span><span class="s0">, </span><span class="s1">glyph_map_new</span><span class="s0">, </span><span class="s1">rects = _glyphs</span>
            <span class="s1">self._update_glyph_map_defs(glyph_map_new)</span>

            <span class="s0">for </span><span class="s1">glyph_id</span><span class="s0">, </span><span class="s1">xposition</span><span class="s0">, </span><span class="s1">yposition</span><span class="s0">, </span><span class="s1">scale </span><span class="s0">in </span><span class="s1">glyph_info:</span>
                <span class="s1">attrib = {</span><span class="s3">'xlink:href'</span><span class="s1">: </span><span class="s3">'#%s' </span><span class="s1">% glyph_id}</span>
                <span class="s0">if </span><span class="s1">xposition != </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s1">attrib[</span><span class="s3">'x'</span><span class="s1">] = _short_float_fmt(xposition)</span>
                <span class="s0">if </span><span class="s1">yposition != </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s1">attrib[</span><span class="s3">'y'</span><span class="s1">] = _short_float_fmt(yposition)</span>
                <span class="s1">writer.element(</span><span class="s3">'use'</span><span class="s0">, </span><span class="s1">attrib=attrib)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">ismath == </span><span class="s3">&quot;TeX&quot;</span><span class="s1">:</span>
                <span class="s1">_glyphs = text2path.get_glyphs_tex(</span>
                    <span class="s1">prop</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">glyph_map=glyph_map</span><span class="s0">, </span><span class="s1">return_new_glyphs_only=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">_glyphs = text2path.get_glyphs_mathtext(</span>
                    <span class="s1">prop</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">glyph_map=glyph_map</span><span class="s0">, </span><span class="s1">return_new_glyphs_only=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">glyph_info</span><span class="s0">, </span><span class="s1">glyph_map_new</span><span class="s0">, </span><span class="s1">rects = _glyphs</span>
            <span class="s1">self._update_glyph_map_defs(glyph_map_new)</span>

            <span class="s0">for </span><span class="s1">char_id</span><span class="s0">, </span><span class="s1">xposition</span><span class="s0">, </span><span class="s1">yposition</span><span class="s0">, </span><span class="s1">scale </span><span class="s0">in </span><span class="s1">glyph_info:</span>
                <span class="s1">char_id = self._adjust_char_id(char_id)</span>
                <span class="s1">writer.element(</span>
                    <span class="s3">'use'</span><span class="s0">,</span>
                    <span class="s1">transform=_generate_transform([</span>
                        <span class="s1">(</span><span class="s3">'translate'</span><span class="s0">, </span><span class="s1">(xposition</span><span class="s0">, </span><span class="s1">yposition))</span><span class="s0">,</span>
                        <span class="s1">(</span><span class="s3">'scale'</span><span class="s0">, </span><span class="s1">(scale</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
                        <span class="s1">])</span><span class="s0">,</span>
                    <span class="s1">attrib={</span><span class="s3">'xlink:href'</span><span class="s1">: </span><span class="s3">'#%s' </span><span class="s1">% char_id})</span>

            <span class="s0">for </span><span class="s1">verts</span><span class="s0">, </span><span class="s1">codes </span><span class="s0">in </span><span class="s1">rects:</span>
                <span class="s1">path = Path(verts</span><span class="s0">, </span><span class="s1">codes)</span>
                <span class="s1">path_data = self._convert_path(path</span><span class="s0">, </span><span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s1">writer.element(</span><span class="s3">'path'</span><span class="s0">, </span><span class="s1">d=path_data)</span>

        <span class="s1">writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_draw_text_as_text(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">ismath</span><span class="s0">, </span><span class="s1">mtext=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">writer = self.writer</span>

        <span class="s1">color = rgb2hex(gc.get_rgb())</span>
        <span class="s1">style = {}</span>
        <span class="s0">if </span><span class="s1">color != </span><span class="s3">'#000000'</span><span class="s1">:</span>
            <span class="s1">style[</span><span class="s3">'fill'</span><span class="s1">] = color</span>

        <span class="s1">alpha = gc.get_alpha() </span><span class="s0">if </span><span class="s1">gc.get_forced_alpha() </span><span class="s0">else </span><span class="s1">gc.get_rgb()[</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">alpha != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">style[</span><span class="s3">'opacity'</span><span class="s1">] = _short_float_fmt(alpha)</span>

        <span class="s0">if not </span><span class="s1">ismath:</span>
            <span class="s1">attrib = {}</span>

            <span class="s1">font_parts = []</span>
            <span class="s0">if </span><span class="s1">prop.get_style() != </span><span class="s3">'normal'</span><span class="s1">:</span>
                <span class="s1">font_parts.append(prop.get_style())</span>
            <span class="s0">if </span><span class="s1">prop.get_variant() != </span><span class="s3">'normal'</span><span class="s1">:</span>
                <span class="s1">font_parts.append(prop.get_variant())</span>
            <span class="s1">weight = fm.weight_dict[prop.get_weight()]</span>
            <span class="s0">if </span><span class="s1">weight != </span><span class="s5">400</span><span class="s1">:</span>
                <span class="s1">font_parts.append(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">weight</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

            <span class="s0">def </span><span class="s1">_normalize_sans(name):</span>
                <span class="s0">return </span><span class="s3">'sans-serif' </span><span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'sans'</span><span class="s0">, </span><span class="s3">'sans serif'</span><span class="s1">] </span><span class="s0">else </span><span class="s1">name</span>

            <span class="s0">def </span><span class="s1">_expand_family_entry(fn):</span>
                <span class="s1">fn = _normalize_sans(fn)</span>
                <span class="s2"># prepend generic font families with all configured font names</span>
                <span class="s0">if </span><span class="s1">fn </span><span class="s0">in </span><span class="s1">fm.font_family_aliases:</span>
                    <span class="s2"># get all of the font names and fix spelling of sans-serif</span>
                    <span class="s2"># (we accept 3 ways CSS only supports 1)</span>
                    <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">fm.FontManager._expand_aliases(fn):</span>
                        <span class="s0">yield </span><span class="s1">_normalize_sans(name)</span>
                <span class="s2"># whether a generic name or a family name, it must appear at</span>
                <span class="s2"># least once</span>
                <span class="s0">yield </span><span class="s1">fn</span>

            <span class="s0">def </span><span class="s1">_get_all_quoted_names(prop):</span>
                <span class="s2"># only quote specific names, not generic names</span>
                <span class="s0">return </span><span class="s1">[name </span><span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">fm.font_family_aliases </span><span class="s0">else </span><span class="s1">repr(name)</span>
                        <span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">prop.get_family()</span>
                        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_expand_family_entry(entry)]</span>

            <span class="s1">font_parts.extend([</span>
                <span class="s3">f'</span><span class="s0">{</span><span class="s1">_short_float_fmt(prop.get_size())</span><span class="s0">}</span><span class="s3">px'</span><span class="s0">,</span>
                <span class="s2"># ensure expansion, quoting, and dedupe of font names</span>
                <span class="s3">&quot;, &quot;</span><span class="s1">.join(dict.fromkeys(_get_all_quoted_names(prop)))</span>
            <span class="s1">])</span>
            <span class="s1">style[</span><span class="s3">'font'</span><span class="s1">] = </span><span class="s3">' '</span><span class="s1">.join(font_parts)</span>
            <span class="s0">if </span><span class="s1">prop.get_stretch() != </span><span class="s3">'normal'</span><span class="s1">:</span>
                <span class="s1">style[</span><span class="s3">'font-stretch'</span><span class="s1">] = prop.get_stretch()</span>
            <span class="s1">attrib[</span><span class="s3">'style'</span><span class="s1">] = _generate_css(style)</span>

            <span class="s0">if </span><span class="s1">mtext </span><span class="s0">and </span><span class="s1">(angle == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">mtext.get_rotation_mode() == </span><span class="s3">&quot;anchor&quot;</span><span class="s1">):</span>
                <span class="s2"># If text anchoring can be supported, get the original</span>
                <span class="s2"># coordinates and add alignment information.</span>

                <span class="s2"># Get anchor coordinates.</span>
                <span class="s1">transform = mtext.get_transform()</span>
                <span class="s1">ax</span><span class="s0">, </span><span class="s1">ay = transform.transform(mtext.get_unitless_position())</span>
                <span class="s1">ay = self.height - ay</span>

                <span class="s2"># Don't do vertical anchor alignment. Most applications do not</span>
                <span class="s2"># support 'alignment-baseline' yet. Apply the vertical layout</span>
                <span class="s2"># to the anchor point manually for now.</span>
                <span class="s1">angle_rad = np.deg2rad(angle)</span>
                <span class="s1">dir_vert = np.array([np.sin(angle_rad)</span><span class="s0">, </span><span class="s1">np.cos(angle_rad)])</span>
                <span class="s1">v_offset = np.dot(dir_vert</span><span class="s0">, </span><span class="s1">[(x - ax)</span><span class="s0">, </span><span class="s1">(y - ay)])</span>
                <span class="s1">ax = ax + v_offset * dir_vert[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">ay = ay + v_offset * dir_vert[</span><span class="s5">1</span><span class="s1">]</span>

                <span class="s1">ha_mpl_to_svg = {</span><span class="s3">'left'</span><span class="s1">: </span><span class="s3">'start'</span><span class="s0">, </span><span class="s3">'right'</span><span class="s1">: </span><span class="s3">'end'</span><span class="s0">,</span>
                                 <span class="s3">'center'</span><span class="s1">: </span><span class="s3">'middle'</span><span class="s1">}</span>
                <span class="s1">style[</span><span class="s3">'text-anchor'</span><span class="s1">] = ha_mpl_to_svg[mtext.get_ha()]</span>

                <span class="s1">attrib[</span><span class="s3">'x'</span><span class="s1">] = _short_float_fmt(ax)</span>
                <span class="s1">attrib[</span><span class="s3">'y'</span><span class="s1">] = _short_float_fmt(ay)</span>
                <span class="s1">attrib[</span><span class="s3">'style'</span><span class="s1">] = _generate_css(style)</span>
                <span class="s1">attrib[</span><span class="s3">'transform'</span><span class="s1">] = _generate_transform([</span>
                    <span class="s1">(</span><span class="s3">&quot;rotate&quot;</span><span class="s0">, </span><span class="s1">(-angle</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">ay))])</span>

            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">attrib[</span><span class="s3">'transform'</span><span class="s1">] = _generate_transform([</span>
                    <span class="s1">(</span><span class="s3">'translate'</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                    <span class="s1">(</span><span class="s3">'rotate'</span><span class="s0">, </span><span class="s1">(-angle</span><span class="s0">,</span><span class="s1">))])</span>

            <span class="s1">writer.element(</span><span class="s3">'text'</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">attrib=attrib)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">writer.comment(s)</span>

            <span class="s1">width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">descent</span><span class="s0">, </span><span class="s1">glyphs</span><span class="s0">, </span><span class="s1">rects = \</span>
                <span class="s1">self._text2path.mathtext_parser.parse(s</span><span class="s0">, </span><span class="s5">72</span><span class="s0">, </span><span class="s1">prop)</span>

            <span class="s2"># Apply attributes to 'g', not 'text', because we likely have some</span>
            <span class="s2"># rectangles as well with the same style and transformation.</span>
            <span class="s1">writer.start(</span><span class="s3">'g'</span><span class="s0">,</span>
                         <span class="s1">style=_generate_css(style)</span><span class="s0">,</span>
                         <span class="s1">transform=_generate_transform([</span>
                             <span class="s1">(</span><span class="s3">'translate'</span><span class="s0">, </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                             <span class="s1">(</span><span class="s3">'rotate'</span><span class="s0">, </span><span class="s1">(-angle</span><span class="s0">,</span><span class="s1">))])</span><span class="s0">,</span>
                         <span class="s1">)</span>

            <span class="s1">writer.start(</span><span class="s3">'text'</span><span class="s1">)</span>

            <span class="s2"># Sort the characters by font, and output one tspan for each.</span>
            <span class="s1">spans = {}</span>
            <span class="s0">for </span><span class="s1">font</span><span class="s0">, </span><span class="s1">fontsize</span><span class="s0">, </span><span class="s1">thetext</span><span class="s0">, </span><span class="s1">new_x</span><span class="s0">, </span><span class="s1">new_y </span><span class="s0">in </span><span class="s1">glyphs:</span>
                <span class="s1">entry = fm.ttfFontProperty(font)</span>
                <span class="s1">font_parts = []</span>
                <span class="s0">if </span><span class="s1">entry.style != </span><span class="s3">'normal'</span><span class="s1">:</span>
                    <span class="s1">font_parts.append(entry.style)</span>
                <span class="s0">if </span><span class="s1">entry.variant != </span><span class="s3">'normal'</span><span class="s1">:</span>
                    <span class="s1">font_parts.append(entry.variant)</span>
                <span class="s0">if </span><span class="s1">entry.weight != </span><span class="s5">400</span><span class="s1">:</span>
                    <span class="s1">font_parts.append(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">entry.weight</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>
                <span class="s1">font_parts.extend([</span>
                    <span class="s3">f'</span><span class="s0">{</span><span class="s1">_short_float_fmt(fontsize)</span><span class="s0">}</span><span class="s3">px'</span><span class="s0">,</span>
                    <span class="s3">f'</span><span class="s0">{</span><span class="s1">entry.name</span><span class="s0">!r}</span><span class="s3">'</span><span class="s0">,  </span><span class="s2"># ensure quoting</span>
                <span class="s1">])</span>
                <span class="s1">style = {</span><span class="s3">'font'</span><span class="s1">: </span><span class="s3">' '</span><span class="s1">.join(font_parts)}</span>
                <span class="s0">if </span><span class="s1">entry.stretch != </span><span class="s3">'normal'</span><span class="s1">:</span>
                    <span class="s1">style[</span><span class="s3">'font-stretch'</span><span class="s1">] = entry.stretch</span>
                <span class="s1">style = _generate_css(style)</span>
                <span class="s0">if </span><span class="s1">thetext == </span><span class="s5">32</span><span class="s1">:</span>
                    <span class="s1">thetext = </span><span class="s5">0xa0  </span><span class="s2"># non-breaking space</span>
                <span class="s1">spans.setdefault(style</span><span class="s0">, </span><span class="s1">[]).append((new_x</span><span class="s0">, </span><span class="s1">-new_y</span><span class="s0">, </span><span class="s1">thetext))</span>

            <span class="s0">for </span><span class="s1">style</span><span class="s0">, </span><span class="s1">chars </span><span class="s0">in </span><span class="s1">spans.items():</span>
                <span class="s1">chars.sort()</span>

                <span class="s0">if </span><span class="s1">len({y </span><span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">t </span><span class="s0">in </span><span class="s1">chars}) == </span><span class="s5">1</span><span class="s1">:  </span><span class="s2"># Are all y's the same?</span>
                    <span class="s1">ys = str(chars[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ys = </span><span class="s3">' '</span><span class="s1">.join(str(c[</span><span class="s5">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chars)</span>

                <span class="s1">attrib = {</span>
                    <span class="s3">'style'</span><span class="s1">: style</span><span class="s0">,</span>
                    <span class="s3">'x'</span><span class="s1">: </span><span class="s3">' '</span><span class="s1">.join(_short_float_fmt(c[</span><span class="s5">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chars)</span><span class="s0">,</span>
                    <span class="s3">'y'</span><span class="s1">: ys</span>
                    <span class="s1">}</span>

                <span class="s1">writer.element(</span>
                    <span class="s3">'tspan'</span><span class="s0">,</span>
                    <span class="s3">''</span><span class="s1">.join(chr(c[</span><span class="s5">2</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">chars)</span><span class="s0">,</span>
                    <span class="s1">attrib=attrib)</span>

            <span class="s1">writer.end(</span><span class="s3">'text'</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height </span><span class="s0">in </span><span class="s1">rects:</span>
                <span class="s1">writer.element(</span>
                    <span class="s3">'rect'</span><span class="s0">,</span>
                    <span class="s1">x=_short_float_fmt(x)</span><span class="s0">,</span>
                    <span class="s1">y=_short_float_fmt(-y-</span><span class="s5">1</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">width=_short_float_fmt(width)</span><span class="s0">,</span>
                    <span class="s1">height=_short_float_fmt(height)</span>
                    <span class="s1">)</span>

            <span class="s1">writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">draw_text(self</span><span class="s0">, </span><span class="s1">gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">ismath=</span><span class="s0">False, </span><span class="s1">mtext=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2"># docstring inherited</span>

        <span class="s1">clip_attrs = self._get_clip_attrs(gc)</span>
        <span class="s0">if </span><span class="s1">clip_attrs:</span>
            <span class="s2"># Cannot apply clip-path directly to the text, because</span>
            <span class="s2"># it has a transformation</span>
            <span class="s1">self.writer.start(</span><span class="s3">'g'</span><span class="s0">, </span><span class="s1">**clip_attrs)</span>

        <span class="s0">if </span><span class="s1">gc.get_url() </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.start(</span><span class="s3">'a'</span><span class="s0">, </span><span class="s1">{</span><span class="s3">'xlink:href'</span><span class="s1">: gc.get_url()})</span>

        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'svg.fonttype'</span><span class="s1">] == </span><span class="s3">'path'</span><span class="s1">:</span>
            <span class="s1">self._draw_text_as_path(gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">ismath</span><span class="s0">, </span><span class="s1">mtext)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._draw_text_as_text(gc</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">angle</span><span class="s0">, </span><span class="s1">ismath</span><span class="s0">, </span><span class="s1">mtext)</span>

        <span class="s0">if </span><span class="s1">gc.get_url() </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.writer.end(</span><span class="s3">'a'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">clip_attrs:</span>
            <span class="s1">self.writer.end(</span><span class="s3">'g'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">flipy(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">get_canvas_width_height(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">return </span><span class="s1">self.width</span><span class="s0">, </span><span class="s1">self.height</span>

    <span class="s0">def </span><span class="s1">get_text_width_height_descent(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">ismath):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s0">return </span><span class="s1">self._text2path.get_text_width_height_descent(s</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">ismath)</span>


<span class="s0">class </span><span class="s1">FigureCanvasSVG(FigureCanvasBase):</span>
    <span class="s1">filetypes = {</span><span class="s3">'svg'</span><span class="s1">: </span><span class="s3">'Scalable Vector Graphics'</span><span class="s0">,</span>
                 <span class="s3">'svgz'</span><span class="s1">: </span><span class="s3">'Scalable Vector Graphics'</span><span class="s1">}</span>

    <span class="s1">fixed_dpi = </span><span class="s5">72</span>

    <span class="s0">def </span><span class="s1">print_svg(self</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">bbox_inches_restore=</span><span class="s0">None, </span><span class="s1">metadata=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        filename : str or path-like or file-like 
            Output target; if a string, a file will be opened for writing. 
 
        metadata : dict[str, Any], optional 
            Metadata in the SVG file defined as key-value pairs of strings, 
            datetimes, or lists of strings, e.g., ``{'Creator': 'My software', 
            'Contributor': ['Me', 'My Friend'], 'Title': 'Awesome'}``. 
 
            The standard keys and their value types are: 
 
            * *str*: ``'Coverage'``, ``'Description'``, ``'Format'``, 
              ``'Identifier'``, ``'Language'``, ``'Relation'``, ``'Source'``, 
              ``'Title'``, and ``'Type'``. 
            * *str* or *list of str*: ``'Contributor'``, ``'Creator'``, 
              ``'Keywords'``, ``'Publisher'``, and ``'Rights'``. 
            * *str*, *date*, *datetime*, or *tuple* of same: ``'Date'``. If a 
              non-*str*, then it will be formatted as ISO 8601. 
 
            Values have been predefined for ``'Creator'``, ``'Date'``, 
            ``'Format'``, and ``'Type'``. They can be removed by setting them 
            to `None`. 
 
            Information is encoded as `Dublin Core Metadata`__. 
 
            .. _DC: https://www.dublincore.org/specifications/dublin-core/ 
 
            __ DC_ 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">cbook.open_file_cm(filename</span><span class="s0">, </span><span class="s3">&quot;w&quot;</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">fh:</span>
            <span class="s0">if not </span><span class="s1">cbook.file_requires_unicode(fh):</span>
                <span class="s1">fh = codecs.getwriter(</span><span class="s3">'utf-8'</span><span class="s1">)(fh)</span>
            <span class="s1">dpi = self.figure.dpi</span>
            <span class="s1">self.figure.dpi = </span><span class="s5">72</span>
            <span class="s1">width</span><span class="s0">, </span><span class="s1">height = self.figure.get_size_inches()</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">h = width * </span><span class="s5">72</span><span class="s0">, </span><span class="s1">height * </span><span class="s5">72</span>
            <span class="s1">renderer = MixedModeRenderer(</span>
                <span class="s1">self.figure</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height</span><span class="s0">, </span><span class="s1">dpi</span><span class="s0">,</span>
                <span class="s1">RendererSVG(w</span><span class="s0">, </span><span class="s1">h</span><span class="s0">, </span><span class="s1">fh</span><span class="s0">, </span><span class="s1">image_dpi=dpi</span><span class="s0">, </span><span class="s1">metadata=metadata)</span><span class="s0">,</span>
                <span class="s1">bbox_inches_restore=bbox_inches_restore)</span>
            <span class="s1">self.figure.draw(renderer)</span>
            <span class="s1">renderer.finalize()</span>

    <span class="s0">def </span><span class="s1">print_svgz(self</span><span class="s0">, </span><span class="s1">filename</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">with </span><span class="s1">cbook.open_file_cm(filename</span><span class="s0">, </span><span class="s3">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">fh</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s1">gzip.GzipFile(mode=</span><span class="s3">'w'</span><span class="s0">, </span><span class="s1">fileobj=fh) </span><span class="s0">as </span><span class="s1">gzipwriter:</span>
            <span class="s0">return </span><span class="s1">self.print_svg(gzipwriter</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">get_default_filetype(self):</span>
        <span class="s0">return </span><span class="s3">'svg'</span>

    <span class="s0">def </span><span class="s1">draw(self):</span>
        <span class="s1">self.figure.draw_without_rendering()</span>
        <span class="s0">return </span><span class="s1">super().draw()</span>


<span class="s1">FigureManagerSVG = FigureManagerBase</span>


<span class="s1">svgProlog = </span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s3">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt; 
&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; 
  &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 
&quot;&quot;&quot;</span>


<span class="s1">@_Backend.export</span>
<span class="s0">class </span><span class="s1">_BackendSVG(_Backend):</span>
    <span class="s1">backend_version = mpl.__version__</span>
    <span class="s1">FigureCanvas = FigureCanvasSVG</span>
</pre>
</body>
</html>