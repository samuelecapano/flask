<html>
<head>
<title>colors.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
colors.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A module for converting numbers or color arguments to *RGB* or *RGBA*. 
 
*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the 
range 0-1. 
 
This module includes functions and classes for color specification conversions, 
and for mapping numbers to colors in a 1-D array of colors called a colormap. 
 
Mapping data onto colors using a colormap typically involves two steps: a data 
array is first mapped onto the range 0-1 using a subclass of `Normalize`, 
then this number is mapped to a color using a subclass of `Colormap`.  Two 
subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses 
piecewise-linear interpolation to define colormaps, and `ListedColormap`, which 
makes a colormap from a list of colors. 
 
.. seealso:: 
 
  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to 
  make colormaps and 
 
  :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps. 
 
  :doc:`/tutorials/colors/colormapnorms` for more details about data 
  normalization 
 
  More colormaps are available at palettable_. 
 
The module also provides functions for checking whether an object can be 
interpreted as a color (`is_color_like`), for converting such an object 
to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the 
&quot;#rrggbb&quot; format (`to_hex`), and a sequence of colors to an (n, 4) 
RGBA array (`to_rgba_array`).  Caching is used for efficiency. 
 
Colors that Matplotlib recognizes are listed at 
:doc:`/tutorials/colors/colors`. 
 
.. _palettable: https://jiffyclub.github.io/palettable/ 
.. _xkcd color survey: https://xkcd.com/color/rgb/ 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">base64</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Sized</span><span class="s2">, </span><span class="s1">Sequence</span><span class="s2">, </span><span class="s1">Mapping</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">PIL </span><span class="s2">import </span><span class="s1">Image</span>
<span class="s2">from </span><span class="s1">PIL.PngImagePlugin </span><span class="s2">import </span><span class="s1">PngInfo</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_cm</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">scale</span>
<span class="s2">from </span><span class="s1">._color_data </span><span class="s2">import </span><span class="s1">BASE_COLORS</span><span class="s2">, </span><span class="s1">TABLEAU_COLORS</span><span class="s2">, </span><span class="s1">CSS4_COLORS</span><span class="s2">, </span><span class="s1">XKCD_COLORS</span>


<span class="s2">class </span><span class="s1">_ColorMapping(dict):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">mapping):</span>
        <span class="s1">super().__init__(mapping)</span>
        <span class="s1">self.cache = {}</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">super().__setitem__(key</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s1">self.cache.clear()</span>

    <span class="s2">def </span><span class="s1">__delitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">super().__delitem__(key)</span>
        <span class="s1">self.cache.clear()</span>


<span class="s1">_colors_full_map = {}</span>
<span class="s3"># Set by reverse priority order.</span>
<span class="s1">_colors_full_map.update(XKCD_COLORS)</span>
<span class="s1">_colors_full_map.update({k.replace(</span><span class="s4">'grey'</span><span class="s2">, </span><span class="s4">'gray'</span><span class="s1">): v</span>
                         <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">XKCD_COLORS.items()</span>
                         <span class="s2">if </span><span class="s4">'grey' </span><span class="s2">in </span><span class="s1">k})</span>
<span class="s1">_colors_full_map.update(CSS4_COLORS)</span>
<span class="s1">_colors_full_map.update(TABLEAU_COLORS)</span>
<span class="s1">_colors_full_map.update({k.replace(</span><span class="s4">'gray'</span><span class="s2">, </span><span class="s4">'grey'</span><span class="s1">): v</span>
                         <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">TABLEAU_COLORS.items()</span>
                         <span class="s2">if </span><span class="s4">'gray' </span><span class="s2">in </span><span class="s1">k})</span>
<span class="s1">_colors_full_map.update(BASE_COLORS)</span>
<span class="s1">_colors_full_map = _ColorMapping(_colors_full_map)</span>

<span class="s1">_REPR_PNG_SIZE = (</span><span class="s5">512</span><span class="s2">, </span><span class="s5">64</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_named_colors_mapping():</span>
    <span class="s0">&quot;&quot;&quot;Return the global mapping of names to named colors.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_colors_full_map</span>


<span class="s2">class </span><span class="s1">ColorSequenceRegistry(Mapping):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Container for sequences of colors that are known to Matplotlib by name. 
 
    The universal registry instance is `matplotlib.color_sequences`. There 
    should be no need for users to instantiate `.ColorSequenceRegistry` 
    themselves. 
 
    Read access uses a dict-like interface mapping names to lists of colors:: 
 
        import matplotlib as mpl 
        cmap = mpl.color_sequences['tab10'] 
 
    The returned lists are copies, so that their modification does not change 
    the global definition of the color sequence. 
 
    Additional color sequences can be added via 
    `.ColorSequenceRegistry.register`:: 
 
        mpl.color_sequences.register('rgb', ['r', 'g', 'b']) 
    &quot;&quot;&quot;</span>

    <span class="s1">_BUILTIN_COLOR_SEQUENCES = {</span>
        <span class="s4">'tab10'</span><span class="s1">: _cm._tab10_data</span><span class="s2">,</span>
        <span class="s4">'tab20'</span><span class="s1">: _cm._tab20_data</span><span class="s2">,</span>
        <span class="s4">'tab20b'</span><span class="s1">: _cm._tab20b_data</span><span class="s2">,</span>
        <span class="s4">'tab20c'</span><span class="s1">: _cm._tab20c_data</span><span class="s2">,</span>
        <span class="s4">'Pastel1'</span><span class="s1">: _cm._Pastel1_data</span><span class="s2">,</span>
        <span class="s4">'Pastel2'</span><span class="s1">: _cm._Pastel2_data</span><span class="s2">,</span>
        <span class="s4">'Paired'</span><span class="s1">: _cm._Paired_data</span><span class="s2">,</span>
        <span class="s4">'Accent'</span><span class="s1">: _cm._Accent_data</span><span class="s2">,</span>
        <span class="s4">'Dark2'</span><span class="s1">: _cm._Dark2_data</span><span class="s2">,</span>
        <span class="s4">'Set1'</span><span class="s1">: _cm._Set1_data</span><span class="s2">,</span>
        <span class="s4">'Set2'</span><span class="s1">: _cm._Set1_data</span><span class="s2">,</span>
        <span class="s4">'Set3'</span><span class="s1">: _cm._Set1_data</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._color_sequences = {**self._BUILTIN_COLOR_SEQUENCES}</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">list(self._color_sequences[item])</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">raise </span><span class="s1">KeyError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">item</span><span class="s2">!r} </span><span class="s4">is not a known color sequence name&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self._color_sequences)</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self._color_sequences)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">'ColorSequenceRegistry; available colormaps:</span><span class="s2">\n</span><span class="s4">' </span><span class="s1">+</span>
                <span class="s4">', '</span><span class="s1">.join(</span><span class="s4">f&quot;'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'&quot; </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self))</span>

    <span class="s2">def </span><span class="s1">register(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">color_list):</span>
        <span class="s0">&quot;&quot;&quot; 
        Register a new color sequence. 
 
        The color sequence registry stores a copy of the given *color_list*, so 
        that future changes to the original list do not affect the registered 
        color sequence. Think of this as the registry taking a snapshot 
        of *color_list* at registration. 
 
        Parameters 
        ---------- 
        name : str 
            The name for the color sequence. 
 
        color_list : list of colors 
            An iterable returning valid Matplotlib colors when iterating over. 
            Note however that the returned color sequence will always be a 
            list regardless of the input type. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._BUILTIN_COLOR_SEQUENCES:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s4">is a reserved name for a builtin &quot;</span>
                             <span class="s4">&quot;color sequence&quot;</span><span class="s1">)</span>

        <span class="s1">color_list = list(color_list)  </span><span class="s3"># force copy and coerce type to list</span>
        <span class="s2">for </span><span class="s1">color </span><span class="s2">in </span><span class="s1">color_list:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">to_rgba(color)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">color</span><span class="s2">!r} </span><span class="s4">is not a valid color specification&quot;</span><span class="s1">)</span>

        <span class="s1">self._color_sequences[name] = color_list</span>

    <span class="s2">def </span><span class="s1">unregister(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove a sequence from the registry. 
 
        You cannot remove built-in color sequences. 
 
        If the name is not registered, returns with no error. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._BUILTIN_COLOR_SEQUENCES:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Cannot unregister builtin color sequence </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">self._color_sequences.pop(name</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s1">_color_sequences = ColorSequenceRegistry()</span>


<span class="s2">def </span><span class="s1">_sanitize_extrema(ex):</span>
    <span class="s2">if </span><span class="s1">ex </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">ex</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">ret = ex.item()</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s1">ret = float(ex)</span>
    <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">def </span><span class="s1">_is_nth_color(c):</span>
    <span class="s0">&quot;&quot;&quot;Return whether *c* can be interpreted as an item in the color cycle.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">re.match(</span><span class="s4">r&quot;\AC[0-9]+\Z&quot;</span><span class="s2">, </span><span class="s1">c)</span>


<span class="s2">def </span><span class="s1">is_color_like(c):</span>
    <span class="s0">&quot;&quot;&quot;Return whether *c* can be interpreted as an RGB(A) color.&quot;&quot;&quot;</span>
    <span class="s3"># Special-case nth color syntax because it cannot be parsed during setup.</span>
    <span class="s2">if </span><span class="s1">_is_nth_color(c):</span>
        <span class="s2">return True</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">to_rgba(c)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">_has_alpha_channel(c):</span>
    <span class="s0">&quot;&quot;&quot;Return whether *c* is a color with an alpha channel.&quot;&quot;&quot;</span>
    <span class="s3"># 4-element sequences are interpreted as r, g, b, a</span>
    <span class="s2">return not </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">len(c) == </span><span class="s5">4</span>


<span class="s2">def </span><span class="s1">_check_color_like(**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    For each *key, value* pair in *kwargs*, check that *value* is color-like. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
        <span class="s2">if not </span><span class="s1">is_color_like(v):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">v</span><span class="s2">!r} </span><span class="s4">is not a valid value for </span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">same_color(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether the colors *c1* and *c2* are the same. 
 
    *c1*, *c2* can be single colors or lists/arrays of colors. 
    &quot;&quot;&quot;</span>
    <span class="s1">c1 = to_rgba_array(c1)</span>
    <span class="s1">c2 = to_rgba_array(c2)</span>
    <span class="s1">n1 = max(c1.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)  </span><span class="s3"># 'none' results in shape (0, 4), but is 1-elem</span>
    <span class="s1">n2 = max(c2.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)  </span><span class="s3"># 'none' results in shape (0, 4), but is 1-elem</span>

    <span class="s2">if </span><span class="s1">n1 != n2:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Different number of elements passed.'</span><span class="s1">)</span>
    <span class="s3"># The following shape test is needed to correctly handle comparisons with</span>
    <span class="s3"># 'none', which results in a shape (0, 4) array and thus cannot be tested</span>
    <span class="s3"># via value comparison.</span>
    <span class="s2">return </span><span class="s1">c1.shape == c2.shape </span><span class="s2">and </span><span class="s1">(c1 == c2).all()</span>


<span class="s2">def </span><span class="s1">to_rgba(c</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert *c* to an RGBA color. 
 
    Parameters 
    ---------- 
    c : Matplotlib color or ``np.ma.masked`` 
 
    alpha : float, optional 
        If *alpha* is given, force the alpha value of the returned RGBA tuple 
        to *alpha*. 
 
        If None, the alpha value from *c* is used. If *c* does not have an 
        alpha channel, then alpha defaults to 1. 
 
        *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive), 
        which always maps to ``(0, 0, 0, 0)``. 
 
    Returns 
    ------- 
    tuple 
        Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue, 
        alpha) can assume values between 0 and 1. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Special-case nth color syntax because it should not be cached.</span>
    <span class="s2">if </span><span class="s1">_is_nth_color(c):</span>
        <span class="s1">prop_cycler = mpl.rcParams[</span><span class="s4">'axes.prop_cycle'</span><span class="s1">]</span>
        <span class="s1">colors = prop_cycler.by_key().get(</span><span class="s4">'color'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">'k'</span><span class="s1">])</span>
        <span class="s1">c = colors[int(c[</span><span class="s5">1</span><span class="s1">:]) % len(colors)]</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">rgba = _colors_full_map.cache[c</span><span class="s2">, </span><span class="s1">alpha]</span>
    <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">TypeError):  </span><span class="s3"># Not in cache, or unhashable.</span>
        <span class="s1">rgba = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">rgba </span><span class="s2">is None</span><span class="s1">:  </span><span class="s3"># Suppress exception chaining of cache lookup failure.</span>
        <span class="s1">rgba = _to_rgba_no_colorcycle(c</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">_colors_full_map.cache[c</span><span class="s2">, </span><span class="s1">alpha] = rgba</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s1">rgba</span>


<span class="s2">def </span><span class="s1">_to_rgba_no_colorcycle(c</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert *c* to an RGBA color, with no support for color-cycle syntax. 
 
    If *alpha* is given, force the alpha value of the returned RGBA tuple 
    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha 
    information, or defaults to 1. 
 
    *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive), 
    which always maps to ``(0, 0, 0, 0)``. 
    &quot;&quot;&quot;</span>
    <span class="s1">orig_c = c</span>
    <span class="s2">if </span><span class="s1">c </span><span class="s2">is </span><span class="s1">np.ma.masked:</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">c.lower() == </span><span class="s4">&quot;none&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">)</span>
        <span class="s3"># Named color.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s3"># This may turn c into a non-string, so we check again below.</span>
            <span class="s1">c = _colors_full_map[c]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">if </span><span class="s1">len(orig_c) != </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">c = _colors_full_map[c.lower()]</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s3"># hex color in #rrggbb format.</span>
        <span class="s1">match = re.match(</span><span class="s4">r&quot;\A#[a-fA-F0-9]{6}\Z&quot;</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s2">return </span><span class="s1">(tuple(int(n</span><span class="s2">, </span><span class="s5">16</span><span class="s1">) / </span><span class="s5">255</span>
                          <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[c[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">5</span><span class="s1">:</span><span class="s5">7</span><span class="s1">]])</span>
                    <span class="s1">+ (alpha </span><span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None else </span><span class="s5">1.</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s3"># hex color in #rgb format, shorthand for #rrggbb.</span>
        <span class="s1">match = re.match(</span><span class="s4">r&quot;\A#[a-fA-F0-9]{3}\Z&quot;</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s2">return </span><span class="s1">(tuple(int(n</span><span class="s2">, </span><span class="s5">16</span><span class="s1">) / </span><span class="s5">255</span>
                          <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[c[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">2</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">2</span><span class="s1">]*</span><span class="s5">2</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">3</span><span class="s1">]*</span><span class="s5">2</span><span class="s1">])</span>
                    <span class="s1">+ (alpha </span><span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None else </span><span class="s5">1.</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s3"># hex color with alpha in #rrggbbaa format.</span>
        <span class="s1">match = re.match(</span><span class="s4">r&quot;\A#[a-fA-F0-9]{8}\Z&quot;</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">color = [int(n</span><span class="s2">, </span><span class="s5">16</span><span class="s1">) / </span><span class="s5">255</span>
                     <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[c[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">5</span><span class="s1">:</span><span class="s5">7</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">7</span><span class="s1">:</span><span class="s5">9</span><span class="s1">]]]</span>
            <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">color[-</span><span class="s5">1</span><span class="s1">] = alpha</span>
            <span class="s2">return </span><span class="s1">tuple(color)</span>
        <span class="s3"># hex color with alpha in #rgba format, shorthand for #rrggbbaa.</span>
        <span class="s1">match = re.match(</span><span class="s4">r&quot;\A#[a-fA-F0-9]{4}\Z&quot;</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">color = [int(n</span><span class="s2">, </span><span class="s5">16</span><span class="s1">) / </span><span class="s5">255</span>
                     <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[c[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">2</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">2</span><span class="s1">]*</span><span class="s5">2</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">3</span><span class="s1">]*</span><span class="s5">2</span><span class="s2">, </span><span class="s1">c[</span><span class="s5">4</span><span class="s1">]*</span><span class="s5">2</span><span class="s1">]]</span>
            <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">color[-</span><span class="s5">1</span><span class="s1">] = alpha</span>
            <span class="s2">return </span><span class="s1">tuple(color)</span>
        <span class="s3"># string gray.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">c = float(c)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= c &lt;= </span><span class="s5">1</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Invalid string grayscale value </span><span class="s2">{</span><span class="s1">orig_c</span><span class="s2">!r}</span><span class="s4">. &quot;</span>
                    <span class="s4">f&quot;Value must be within 0-1 range&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">c</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">alpha </span><span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None else </span><span class="s5">1.</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid RGBA argument: </span><span class="s2">{</span><span class="s1">orig_c</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3"># turn 2-D array into 1-D array</span>
    <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">c.ndim == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">c = c.reshape(-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3"># tuple color.</span>
    <span class="s2">if not </span><span class="s1">np.iterable(c):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid RGBA argument: </span><span class="s2">{</span><span class="s1">orig_c</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(c) </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;RGBA sequence should have length 3 or 4&quot;</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">c):</span>
        <span class="s3"># Checks that don't work: `map(float, ...)`, `np.array(..., float)` and</span>
        <span class="s3"># `np.array(...).astype(float)` would all convert &quot;0.5&quot; to 0.5.</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid RGBA argument: </span><span class="s2">{</span><span class="s1">orig_c</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s3"># Return a tuple to prevent the cached value from being modified.</span>
    <span class="s1">c = tuple(map(float</span><span class="s2">, </span><span class="s1">c))</span>
    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">alpha </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">alpha = </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">c = c[:</span><span class="s5">3</span><span class="s1">] + (alpha</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">any(elem &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">elem &gt; </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">c):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;RGBA values should be within 0-1 range&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">c</span>


<span class="s2">def </span><span class="s1">to_rgba_array(c</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert *c* to a (n, 4) array of RGBA colors. 
 
    Parameters 
    ---------- 
    c : Matplotlib color or array of colors 
        If *c* is a masked array, an `~numpy.ndarray` is returned with a 
        (0, 0, 0, 0) row for each masked value or row in *c*. 
 
    alpha : float or sequence of floats, optional 
        If *alpha* is given, force the alpha value of the returned RGBA tuple 
        to *alpha*. 
 
        If None, the alpha value from *c* is used. If *c* does not have an 
        alpha channel, then alpha defaults to 1. 
 
        *alpha* is ignored for the color value ``&quot;none&quot;`` (case-insensitive), 
        which always maps to ``(0, 0, 0, 0)``. 
 
        If *alpha* is a sequence and *c* is a single color, *c* will be 
        repeated to match the length of *alpha*. 
 
    Returns 
    ------- 
    array 
        (n, 4) array of RGBA colors,  where each channel (red, green, blue, 
        alpha) can assume values between 0 and 1. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Special-case inputs that are already arrays, for performance.  (If the</span>
    <span class="s3"># array has the wrong kind or shape, raise the error during one-at-a-time</span>
    <span class="s3"># conversion.)</span>
    <span class="s2">if </span><span class="s1">np.iterable(alpha):</span>
        <span class="s1">alpha = np.asarray(alpha).ravel()</span>
    <span class="s2">if </span><span class="s1">(isinstance(c</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">c.dtype.kind </span><span class="s2">in </span><span class="s4">&quot;if&quot;</span>
            <span class="s2">and </span><span class="s1">c.ndim == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">c.shape[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]):</span>
        <span class="s1">mask = c.mask.any(axis=</span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">np.ma.is_masked(c) </span><span class="s2">else None</span>
        <span class="s1">c = np.ma.getdata(c)</span>
        <span class="s2">if </span><span class="s1">np.iterable(alpha):</span>
            <span class="s2">if </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">alpha.shape[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">c = np.tile(c</span><span class="s2">, </span><span class="s1">(alpha.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s2">elif </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">] != alpha.shape[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The number of colors must match the number&quot;</span>
                                 <span class="s4">&quot; of alpha values if there are more than one&quot;</span>
                                 <span class="s4">&quot; of each.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">c.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">result = np.column_stack([c</span><span class="s2">, </span><span class="s1">np.zeros(len(c))])</span>
            <span class="s1">result[:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] = alpha </span><span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None else </span><span class="s5">1.</span>
        <span class="s2">elif </span><span class="s1">c.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">result = c.copy()</span>
            <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">result[:</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] = alpha</span>
        <span class="s2">if </span><span class="s1">mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">result[mask] = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">np.any((result &lt; </span><span class="s5">0</span><span class="s1">) | (result &gt; </span><span class="s5">1</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;RGBA values should be within 0-1 range&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span>
    <span class="s3"># Handle single values.</span>
    <span class="s3"># Note that this occurs *after* handling inputs that are already arrays, as</span>
    <span class="s3"># `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need</span>
    <span class="s3"># to format the array in the ValueError message(!).</span>
    <span class="s2">if </span><span class="s1">cbook._str_lower_equal(c</span><span class="s2">, </span><span class="s4">&quot;none&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.iterable(alpha):</span>
            <span class="s2">return </span><span class="s1">np.array([to_rgba(c</span><span class="s2">, </span><span class="s1">a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">alpha]</span><span class="s2">, </span><span class="s1">float)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.array([to_rgba(c</span><span class="s2">, </span><span class="s1">alpha)]</span><span class="s2">, </span><span class="s1">float)</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
        <span class="s2">pass</span>

    <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">c</span><span class="s2">!r} </span><span class="s4">is not a valid color value.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">len(c) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float)</span>

    <span class="s3"># Quick path if the whole sequence can be directly converted to a numpy</span>
    <span class="s3"># array in one shot.</span>
    <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">Sequence):</span>
        <span class="s1">lens = {len(cc) </span><span class="s2">if </span><span class="s1">isinstance(cc</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)) </span><span class="s2">else </span><span class="s1">-</span><span class="s5">1 </span><span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">c}</span>
        <span class="s2">if </span><span class="s1">lens == {</span><span class="s5">3</span><span class="s1">}:</span>
            <span class="s1">rgba = np.column_stack([c</span><span class="s2">, </span><span class="s1">np.ones(len(c))])</span>
        <span class="s2">elif </span><span class="s1">lens == {</span><span class="s5">4</span><span class="s1">}:</span>
            <span class="s1">rgba = np.array(c)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rgba = np.array([to_rgba(cc) </span><span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">c])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">rgba = np.array([to_rgba(cc) </span><span class="s2">for </span><span class="s1">cc </span><span class="s2">in </span><span class="s1">c])</span>

    <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">rgba[:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = alpha</span>
    <span class="s2">return </span><span class="s1">rgba</span>


<span class="s2">def </span><span class="s1">to_rgb(c):</span>
    <span class="s0">&quot;&quot;&quot;Convert *c* to an RGB color, silently dropping the alpha channel.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">to_rgba(c)[:</span><span class="s5">3</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">to_hex(c</span><span class="s2">, </span><span class="s1">keep_alpha=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert *c* to a hex color. 
 
    Parameters 
    ---------- 
    c : :doc:`color &lt;/tutorials/colors/colors&gt;` or `numpy.ma.masked` 
 
    keep_alpha : bool, default: False 
      If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``. 
 
    Returns 
    ------- 
    str 
      ``#rrggbb`` or ``#rrggbbaa`` hex color string 
    &quot;&quot;&quot;</span>
    <span class="s1">c = to_rgba(c)</span>
    <span class="s2">if not </span><span class="s1">keep_alpha:</span>
        <span class="s1">c = c[:</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s4">&quot;#&quot; </span><span class="s1">+ </span><span class="s4">&quot;&quot;</span><span class="s1">.join(format(round(val * </span><span class="s5">255</span><span class="s1">)</span><span class="s2">, </span><span class="s4">&quot;02x&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">c)</span>


<span class="s3">### Backwards-compatible color-conversion API</span>


<span class="s1">cnames = CSS4_COLORS</span>
<span class="s1">hexColorPattern = re.compile(</span><span class="s4">r&quot;\A#[a-fA-F0-9]{6}\Z&quot;</span><span class="s1">)</span>
<span class="s1">rgb2hex = to_hex</span>
<span class="s1">hex2color = to_rgb</span>


<span class="s2">class </span><span class="s1">ColorConverter:</span>
    <span class="s0">&quot;&quot;&quot; 
    A class only kept for backwards compatibility. 
 
    Its functionality is entirely provided by module-level functions. 
    &quot;&quot;&quot;</span>
    <span class="s1">colors = _colors_full_map</span>
    <span class="s1">cache = _colors_full_map.cache</span>
    <span class="s1">to_rgb = staticmethod(to_rgb)</span>
    <span class="s1">to_rgba = staticmethod(to_rgba)</span>
    <span class="s1">to_rgba_array = staticmethod(to_rgba_array)</span>


<span class="s1">colorConverter = ColorConverter()</span>


<span class="s3">### End of backwards-compatible color-conversion API</span>


<span class="s2">def </span><span class="s1">_create_lookup_table(N</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">gamma=</span><span class="s5">1.0</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Create an *N* -element 1D lookup table. 
 
    This assumes a mapping :math:`f : [0, 1] \rightarrow [0, 1]`. The returned 
    data is an array of N values :math:`y = f(x)` where x is sampled from 
    [0, 1]. 
 
    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The 
    *gamma* correction factor :math:`\gamma` distorts this equidistant 
    sampling by :math:`x \rightarrow x^\gamma`. 
 
    Parameters 
    ---------- 
    N : int 
        The number of elements of the created lookup table; at least 1. 
 
    data : (M, 3) array-like or callable 
        Defines the mapping :math:`f`. 
 
        If a (M, 3) array-like, the rows define values (x, y0, y1).  The x 
        values must start with x=0, end with x=1, and all x values be in 
        increasing order. 
 
        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range 
        :math:`y^1_{i-1} \ldots y^0_i` by linear interpolation. 
 
        For the simple case of a y-continuous mapping, y0 and y1 are identical. 
 
        The two values of y are to allow for discontinuous mapping functions. 
        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be:: 
 
            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)] 
 
        In the special case of ``N == 1``, by convention the returned value 
        is y0 for x == 1. 
 
        If *data* is a callable, it must accept and return numpy arrays:: 
 
           data(x : ndarray) -&gt; ndarray 
 
        and map values between 0 - 1 to 0 - 1. 
 
    gamma : float 
        Gamma correction factor for input distribution x of the mapping. 
 
        See also https://en.wikipedia.org/wiki/Gamma_correction. 
 
    Returns 
    ------- 
    array 
        The lookup table where ``lut[x * (N-1)]`` gives the closest value 
        for values of x between 0 and 1. 
 
    Notes 
    ----- 
    This function is internally used for `.LinearSegmentedColormap`. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">callable(data):</span>
        <span class="s1">xind = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">N) ** gamma</span>
        <span class="s1">lut = np.clip(np.array(data(xind)</span><span class="s2">, </span><span class="s1">dtype=float)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">lut</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">adata = np.array(data)</span>
    <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;data must be convertible to an array&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
    <span class="s1">_api.check_shape((</span><span class="s2">None, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">data=adata)</span>

    <span class="s1">x = adata[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">y0 = adata[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">y1 = adata[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">x[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0. </span><span class="s2">or </span><span class="s1">x[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">1.0</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;data mapping points must start with x=0 and end with x=1&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">(np.diff(x) &lt; </span><span class="s5">0</span><span class="s1">).any():</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;data mapping points must have x in increasing order&quot;</span><span class="s1">)</span>
    <span class="s3"># begin generation of lookup table</span>
    <span class="s2">if </span><span class="s1">N == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3"># convention: use the y = f(x=1) value for a 1-element lookup table</span>
        <span class="s1">lut = np.array(y0[-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x = x * (N - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">xind = (N - </span><span class="s5">1</span><span class="s1">) * np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">N) ** gamma</span>
        <span class="s1">ind = np.searchsorted(x</span><span class="s2">, </span><span class="s1">xind)[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">distance = (xind[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] - x[ind - </span><span class="s5">1</span><span class="s1">]) / (x[ind] - x[ind - </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">lut = np.concatenate([</span>
            <span class="s1">[y1[</span><span class="s5">0</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">distance * (y0[ind] - y1[ind - </span><span class="s5">1</span><span class="s1">]) + y1[ind - </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[y0[-</span><span class="s5">1</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">])</span>
    <span class="s3"># ensure that the lut is confined to values between 0 and 1 by clipping it</span>
    <span class="s2">return </span><span class="s1">np.clip(lut</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Colormap:</span>
    <span class="s0">&quot;&quot;&quot; 
    Baseclass for all scalar to RGBA mappings. 
 
    Typically, Colormap instances are used to convert data values (floats) 
    from the interval ``[0, 1]`` to the RGBA color that the respective 
    Colormap represents. For scaling of data into the ``[0, 1]`` interval see 
    `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable` 
    make heavy use of this ``data -&gt; normalize -&gt; map-to-color`` processing 
    chain. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">N=</span><span class="s5">256</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        name : str 
            The name of the colormap. 
        N : int 
            The number of RGB quantization levels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.N = int(N)  </span><span class="s3"># ensure that N is always int</span>
        <span class="s1">self._rgba_bad = (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)  </span><span class="s3"># If bad, don't paint anything.</span>
        <span class="s1">self._rgba_under = </span><span class="s2">None</span>
        <span class="s1">self._rgba_over = </span><span class="s2">None</span>
        <span class="s1">self._i_under = self.N</span>
        <span class="s1">self._i_over = self.N + </span><span class="s5">1</span>
        <span class="s1">self._i_bad = self.N + </span><span class="s5">2</span>
        <span class="s1">self._isinit = </span><span class="s2">False</span>
        <span class="s3">#: When this colormap exists on a scalar mappable and colorbar_extend</span>
        <span class="s3">#: is not False, colorbar creation will pick up ``colorbar_extend`` as</span>
        <span class="s3">#: the default value for the ``extend`` keyword in the</span>
        <span class="s3">#: `matplotlib.colorbar.Colorbar` constructor.</span>
        <span class="s1">self.colorbar_extend = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">bytes=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        X : float or int, `~numpy.ndarray` or scalar 
            The data value(s) to convert to RGBA. 
            For floats, *X* should be in the interval ``[0.0, 1.0]`` to 
            return the RGBA values ``X*100`` percent along the Colormap line. 
            For integers, *X* should be in the interval ``[0, Colormap.N)`` to 
            return RGBA values *indexed* from the Colormap with index ``X``. 
        alpha : float or array-like or None 
            Alpha must be a scalar between 0 and 1, a sequence of such 
            floats with shape matching X, or None. 
        bytes : bool 
            If False (default), the returned RGBA values will be floats in the 
            interval ``[0, 1]`` otherwise they will be uint8s in the interval 
            ``[0, 255]``. 
 
        Returns 
        ------- 
        Tuple of RGBA values if X is scalar, otherwise an array of 
        RGBA values with a shape of ``X.shape + (4, )``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>

        <span class="s3"># Take the bad mask from a masked array, or in all other cases defer</span>
        <span class="s3"># np.isnan() to after we have converted to an array.</span>
        <span class="s1">mask_bad = X.mask </span><span class="s2">if </span><span class="s1">np.ma.is_masked(X) </span><span class="s2">else None</span>
        <span class="s1">xa = np.array(X</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">mask_bad </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">mask_bad = np.isnan(xa)</span>
        <span class="s2">if not </span><span class="s1">xa.dtype.isnative:</span>
            <span class="s1">xa = xa.byteswap().newbyteorder()  </span><span class="s3"># Native byteorder is faster.</span>
        <span class="s2">if </span><span class="s1">xa.dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">xa *= self.N</span>
            <span class="s3"># Negative values are out of range, but astype(int) would</span>
            <span class="s3"># truncate them towards zero.</span>
            <span class="s1">xa[xa &lt; </span><span class="s5">0</span><span class="s1">] = -</span><span class="s5">1</span>
            <span class="s3"># xa == 1 (== N after multiplication) is not out of range.</span>
            <span class="s1">xa[xa == self.N] = self.N - </span><span class="s5">1</span>
            <span class="s3"># Avoid converting large positive values to negative integers.</span>
            <span class="s1">np.clip(xa</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">self.N</span><span class="s2">, </span><span class="s1">out=xa)</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s3"># We need this cast for unsigned ints as well as floats</span>
            <span class="s1">xa = xa.astype(int)</span>
        <span class="s3"># Set the over-range indices before the under-range;</span>
        <span class="s3"># otherwise the under-range values get converted to over-range.</span>
        <span class="s1">xa[xa &gt; self.N - </span><span class="s5">1</span><span class="s1">] = self._i_over</span>
        <span class="s1">xa[xa &lt; </span><span class="s5">0</span><span class="s1">] = self._i_under</span>
        <span class="s1">xa[mask_bad] = self._i_bad</span>

        <span class="s1">lut = self._lut</span>
        <span class="s2">if </span><span class="s1">bytes:</span>
            <span class="s1">lut = (lut * </span><span class="s5">255</span><span class="s1">).astype(np.uint8)</span>

        <span class="s1">rgba = lut.take(xa</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">'clip'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">alpha = np.clip(alpha</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">bytes:</span>
                <span class="s1">alpha *= </span><span class="s5">255  </span><span class="s3"># Will be cast to uint8 upon assignment.</span>
            <span class="s2">if </span><span class="s1">alpha.shape </span><span class="s2">not in </span><span class="s1">[()</span><span class="s2">, </span><span class="s1">xa.shape]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;alpha is array-like but its shape </span><span class="s2">{</span><span class="s1">alpha.shape</span><span class="s2">} </span><span class="s4">does &quot;</span>
                    <span class="s4">f&quot;not match that of X </span><span class="s2">{</span><span class="s1">xa.shape</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">rgba[...</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] = alpha</span>

            <span class="s3"># If the &quot;bad&quot; color is all zeros, then ignore alpha input.</span>
            <span class="s2">if </span><span class="s1">(lut[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">).all() </span><span class="s2">and </span><span class="s1">np.any(mask_bad):</span>
                <span class="s2">if </span><span class="s1">np.iterable(mask_bad) </span><span class="s2">and </span><span class="s1">mask_bad.shape == xa.shape:</span>
                    <span class="s1">rgba[mask_bad] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">rgba[...</span><span class="s2">, </span><span class="s1">:] = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">np.iterable(X):</span>
            <span class="s1">rgba = tuple(rgba)</span>
        <span class="s2">return </span><span class="s1">rgba</span>

    <span class="s2">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">cls = self.__class__</span>
        <span class="s1">cmapobject = cls.__new__(cls)</span>
        <span class="s1">cmapobject.__dict__.update(self.__dict__)</span>
        <span class="s2">if </span><span class="s1">self._isinit:</span>
            <span class="s1">cmapobject._lut = np.copy(self._lut)</span>
        <span class="s2">return </span><span class="s1">cmapobject</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Colormap) </span><span class="s2">or </span><span class="s1">self.name != other.name </span><span class="s2">or</span>
                <span class="s1">self.colorbar_extend != other.colorbar_extend):</span>
            <span class="s2">return False</span>
        <span class="s3"># To compare lookup tables the Colormaps have to be initialized</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>
        <span class="s2">if not </span><span class="s1">other._isinit:</span>
            <span class="s1">other._init()</span>
        <span class="s2">return </span><span class="s1">np.array_equal(self._lut</span><span class="s2">, </span><span class="s1">other._lut)</span>

    <span class="s2">def </span><span class="s1">get_bad(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the color for masked values.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>
        <span class="s2">return </span><span class="s1">np.array(self._lut[self._i_bad])</span>

    <span class="s2">def </span><span class="s1">set_bad(self</span><span class="s2">, </span><span class="s1">color=</span><span class="s4">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the color for masked values.&quot;&quot;&quot;</span>
        <span class="s1">self._rgba_bad = to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">if </span><span class="s1">self._isinit:</span>
            <span class="s1">self._set_extremes()</span>

    <span class="s2">def </span><span class="s1">get_under(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the color for low out-of-range values.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>
        <span class="s2">return </span><span class="s1">np.array(self._lut[self._i_under])</span>

    <span class="s2">def </span><span class="s1">set_under(self</span><span class="s2">, </span><span class="s1">color=</span><span class="s4">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the color for low out-of-range values.&quot;&quot;&quot;</span>
        <span class="s1">self._rgba_under = to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">if </span><span class="s1">self._isinit:</span>
            <span class="s1">self._set_extremes()</span>

    <span class="s2">def </span><span class="s1">get_over(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the color for high out-of-range values.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>
        <span class="s2">return </span><span class="s1">np.array(self._lut[self._i_over])</span>

    <span class="s2">def </span><span class="s1">set_over(self</span><span class="s2">, </span><span class="s1">color=</span><span class="s4">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the color for high out-of-range values.&quot;&quot;&quot;</span>
        <span class="s1">self._rgba_over = to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">if </span><span class="s1">self._isinit:</span>
            <span class="s1">self._set_extremes()</span>

    <span class="s2">def </span><span class="s1">set_extremes(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">bad=</span><span class="s2">None, </span><span class="s1">under=</span><span class="s2">None, </span><span class="s1">over=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the colors for masked (*bad*) values and, when ``norm.clip = 
        False``, low (*under*) and high (*over*) out-of-range values. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bad </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_bad(bad)</span>
        <span class="s2">if </span><span class="s1">under </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_under(under)</span>
        <span class="s2">if </span><span class="s1">over </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_over(over)</span>

    <span class="s2">def </span><span class="s1">with_extremes(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">bad=</span><span class="s2">None, </span><span class="s1">under=</span><span class="s2">None, </span><span class="s1">over=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the colormap, for which the colors for masked (*bad*) 
        values and, when ``norm.clip = False``, low (*under*) and high (*over*) 
        out-of-range values, have been set accordingly. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_cm = self.copy()</span>
        <span class="s1">new_cm.set_extremes(bad=bad</span><span class="s2">, </span><span class="s1">under=under</span><span class="s2">, </span><span class="s1">over=over)</span>
        <span class="s2">return </span><span class="s1">new_cm</span>

    <span class="s2">def </span><span class="s1">_set_extremes(self):</span>
        <span class="s2">if </span><span class="s1">self._rgba_under:</span>
            <span class="s1">self._lut[self._i_under] = self._rgba_under</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._lut[self._i_under] = self._lut[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._rgba_over:</span>
            <span class="s1">self._lut[self._i_over] = self._rgba_over</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._lut[self._i_over] = self._lut[self.N - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self._lut[self._i_bad] = self._rgba_bad</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s0">&quot;&quot;&quot;Generate the lookup table, ``self._lut``.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Abstract class only&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">is_gray(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the colormap is grayscale.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._isinit:</span>
            <span class="s1">self._init()</span>
        <span class="s2">return </span><span class="s1">(np.all(self._lut[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] == self._lut[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]) </span><span class="s2">and</span>
                <span class="s1">np.all(self._lut[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] == self._lut[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">resampled(self</span><span class="s2">, </span><span class="s1">lutsize):</span>
        <span class="s0">&quot;&quot;&quot;Return a new colormap with *lutsize* entries.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s4">'_resample'</span><span class="s1">):</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s4">&quot;The ability to resample a color map is now public API &quot;</span>
                <span class="s4">f&quot;However the class </span><span class="s2">{</span><span class="s1">type(self)</span><span class="s2">} </span><span class="s4">still only implements &quot;</span>
                <span class="s4">&quot;the previous private _resample method.  Please update &quot;</span>
                <span class="s4">&quot;your class.&quot;</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._resample(lutsize)</span>

        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">reversed(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a reversed instance of the Colormap. 
 
        .. note:: This function is not implemented for the base class. 
 
        Parameters 
        ---------- 
        name : str, optional 
            The name for the reversed colormap. If None, the 
            name is set to ``self.name + &quot;_r&quot;``. 
 
        See Also 
        -------- 
        LinearSegmentedColormap.reversed 
        ListedColormap.reversed 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">_repr_png_(self):</span>
        <span class="s0">&quot;&quot;&quot;Generate a PNG representation of the Colormap.&quot;&quot;&quot;</span>
        <span class="s1">X = np.tile(np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">_REPR_PNG_SIZE[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">(_REPR_PNG_SIZE[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">pixels = self(X</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">png_bytes = io.BytesIO()</span>
        <span class="s1">title = self.name + </span><span class="s4">' colormap'</span>
        <span class="s1">author = </span><span class="s4">f'Matplotlib v</span><span class="s2">{</span><span class="s1">mpl.__version__</span><span class="s2">}</span><span class="s4">, https://matplotlib.org'</span>
        <span class="s1">pnginfo = PngInfo()</span>
        <span class="s1">pnginfo.add_text(</span><span class="s4">'Title'</span><span class="s2">, </span><span class="s1">title)</span>
        <span class="s1">pnginfo.add_text(</span><span class="s4">'Description'</span><span class="s2">, </span><span class="s1">title)</span>
        <span class="s1">pnginfo.add_text(</span><span class="s4">'Author'</span><span class="s2">, </span><span class="s1">author)</span>
        <span class="s1">pnginfo.add_text(</span><span class="s4">'Software'</span><span class="s2">, </span><span class="s1">author)</span>
        <span class="s1">Image.fromarray(pixels).save(png_bytes</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">'png'</span><span class="s2">, </span><span class="s1">pnginfo=pnginfo)</span>
        <span class="s2">return </span><span class="s1">png_bytes.getvalue()</span>

    <span class="s2">def </span><span class="s1">_repr_html_(self):</span>
        <span class="s0">&quot;&quot;&quot;Generate an HTML representation of the Colormap.&quot;&quot;&quot;</span>
        <span class="s1">png_bytes = self._repr_png_()</span>
        <span class="s1">png_base64 = base64.b64encode(png_bytes).decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
        <span class="s2">def </span><span class="s1">color_block(color):</span>
            <span class="s1">hex_color = to_hex(color</span><span class="s2">, </span><span class="s1">keep_alpha=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s4">f'&lt;div title=&quot;</span><span class="s2">{</span><span class="s1">hex_color</span><span class="s2">}</span><span class="s4">&quot; '</span>
                    <span class="s4">'style=&quot;display: inline-block; '</span>
                    <span class="s4">'width: 1em; height: 1em; '</span>
                    <span class="s4">'margin: 0; '</span>
                    <span class="s4">'vertical-align: middle; '</span>
                    <span class="s4">'border: 1px solid #555; '</span>
                    <span class="s4">f'background-color: </span><span class="s2">{</span><span class="s1">hex_color</span><span class="s2">}</span><span class="s4">;&quot;&gt;&lt;/div&gt;'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">(</span><span class="s4">'&lt;div style=&quot;vertical-align: middle;&quot;&gt;'</span>
                <span class="s4">f'&lt;strong&gt;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s4">&lt;/strong&gt; '</span>
                <span class="s4">'&lt;/div&gt;'</span>
                <span class="s4">'&lt;div class=&quot;cmap&quot;&gt;&lt;img '</span>
                <span class="s4">f'alt=&quot;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">} </span><span class="s4">colormap&quot; '</span>
                <span class="s4">f'title=&quot;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s4">&quot; '</span>
                <span class="s4">'style=&quot;border: 1px solid #555;&quot; '</span>
                <span class="s4">f'src=&quot;data:image/png;base64,</span><span class="s2">{</span><span class="s1">png_base64</span><span class="s2">}</span><span class="s4">&quot;&gt;&lt;/div&gt;'</span>
                <span class="s4">'&lt;div style=&quot;vertical-align: middle; '</span>
                <span class="s4">f'max-width: </span><span class="s2">{</span><span class="s1">_REPR_PNG_SIZE[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">2</span><span class="s2">}</span><span class="s4">px; '</span>
                <span class="s4">'display: flex; justify-content: space-between;&quot;&gt;'</span>
                <span class="s4">'&lt;div style=&quot;float: left;&quot;&gt;'</span>
                <span class="s4">f'</span><span class="s2">{</span><span class="s1">color_block(self.get_under())</span><span class="s2">} </span><span class="s4">under'</span>
                <span class="s4">'&lt;/div&gt;'</span>
                <span class="s4">'&lt;div style=&quot;margin: 0 auto; display: inline-block;&quot;&gt;'</span>
                <span class="s4">f'bad </span><span class="s2">{</span><span class="s1">color_block(self.get_bad())</span><span class="s2">}</span><span class="s4">'</span>
                <span class="s4">'&lt;/div&gt;'</span>
                <span class="s4">'&lt;div style=&quot;float: right;&quot;&gt;'</span>
                <span class="s4">f'over </span><span class="s2">{</span><span class="s1">color_block(self.get_over())</span><span class="s2">}</span><span class="s4">'</span>
                <span class="s4">'&lt;/div&gt;'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">copy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a copy of the colormap.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__copy__()</span>


<span class="s2">class </span><span class="s1">LinearSegmentedColormap(Colormap):</span>
    <span class="s0">&quot;&quot;&quot; 
    Colormap objects based on lookup tables using linear segments. 
 
    The lookup table is generated using linear interpolation for each 
    primary color, with the 0-1 domain divided into any number of 
    segments. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">segmentdata</span><span class="s2">, </span><span class="s1">N=</span><span class="s5">256</span><span class="s2">, </span><span class="s1">gamma=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create colormap from linear mapping segments 
 
        segmentdata argument is a dictionary with a red, green and blue 
        entries. Each entry should be a list of *x*, *y0*, *y1* tuples, 
        forming rows in a table. Entries for alpha are optional. 
 
        Example: suppose you want red to increase from 0 to 1 over 
        the bottom half, green to do the same over the middle half, 
        and blue over the top half.  Then you would use:: 
 
            cdict = {'red':   [(0.0,  0.0, 0.0), 
                               (0.5,  1.0, 1.0), 
                               (1.0,  1.0, 1.0)], 
 
                     'green': [(0.0,  0.0, 0.0), 
                               (0.25, 0.0, 0.0), 
                               (0.75, 1.0, 1.0), 
                               (1.0,  1.0, 1.0)], 
 
                     'blue':  [(0.0,  0.0, 0.0), 
                               (0.5,  0.0, 0.0), 
                               (1.0,  1.0, 1.0)]} 
 
        Each row in the table for a given color is a sequence of 
        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase 
        monotonically from 0 to 1.  For any input value *z* falling 
        between *x[i]* and *x[i+1]*, the output value of a given color 
        will be linearly interpolated between *y1[i]* and *y0[i+1]*:: 
 
            row i:   x  y0  y1 
                           / 
                          / 
            row i+1: x  y0  y1 
 
        Hence y0 in the first row and y1 in the last row are never used. 
 
        See Also 
        -------- 
        LinearSegmentedColormap.from_list 
            Static method; factory function for generating a smoothly-varying 
            LinearSegmentedColormap. 
        &quot;&quot;&quot;</span>
        <span class="s3"># True only if all colors in map are identical; needed for contouring.</span>
        <span class="s1">self.monochrome = </span><span class="s2">False</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">self._segmentdata = segmentdata</span>
        <span class="s1">self._gamma = gamma</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s1">self._lut = np.ones((self.N + </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float)</span>
        <span class="s1">self._lut[:-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = _create_lookup_table(</span>
            <span class="s1">self.N</span><span class="s2">, </span><span class="s1">self._segmentdata[</span><span class="s4">'red'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._gamma)</span>
        <span class="s1">self._lut[:-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = _create_lookup_table(</span>
            <span class="s1">self.N</span><span class="s2">, </span><span class="s1">self._segmentdata[</span><span class="s4">'green'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._gamma)</span>
        <span class="s1">self._lut[:-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = _create_lookup_table(</span>
            <span class="s1">self.N</span><span class="s2">, </span><span class="s1">self._segmentdata[</span><span class="s4">'blue'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._gamma)</span>
        <span class="s2">if </span><span class="s4">'alpha' </span><span class="s2">in </span><span class="s1">self._segmentdata:</span>
            <span class="s1">self._lut[:-</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = _create_lookup_table(</span>
                <span class="s1">self.N</span><span class="s2">, </span><span class="s1">self._segmentdata[</span><span class="s4">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self._isinit = </span><span class="s2">True</span>
        <span class="s1">self._set_extremes()</span>

    <span class="s2">def </span><span class="s1">set_gamma(self</span><span class="s2">, </span><span class="s1">gamma):</span>
        <span class="s0">&quot;&quot;&quot;Set a new gamma value and regenerate colormap.&quot;&quot;&quot;</span>
        <span class="s1">self._gamma = gamma</span>
        <span class="s1">self._init()</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">from_list(name</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">N=</span><span class="s5">256</span><span class="s2">, </span><span class="s1">gamma=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a `LinearSegmentedColormap` from a list of colors. 
 
        Parameters 
        ---------- 
        name : str 
            The name of the colormap. 
        colors : array-like of colors or array-like of (value, color) 
            If only colors are given, they are equidistantly mapped from the 
            range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to 
            ``colors[-1]``. 
            If (value, color) pairs are given, the mapping is from *value* 
            to *color*. This can be used to divide the range unevenly. 
        N : int 
            The number of RGB quantization levels. 
        gamma : float 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.iterable(colors):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'colors must be iterable'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(isinstance(colors[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Sized) </span><span class="s2">and </span><span class="s1">len(colors[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">2</span>
                <span class="s2">and not </span><span class="s1">isinstance(colors[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str)):</span>
            <span class="s3"># List of value, color pairs</span>
            <span class="s1">vals</span><span class="s2">, </span><span class="s1">colors = zip(*colors)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vals = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(colors))</span>

        <span class="s1">r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">a = to_rgba_array(colors).T</span>
        <span class="s1">cdict = {</span>
            <span class="s4">&quot;red&quot;</span><span class="s1">: np.column_stack([vals</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">r])</span><span class="s2">,</span>
            <span class="s4">&quot;green&quot;</span><span class="s1">: np.column_stack([vals</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">g])</span><span class="s2">,</span>
            <span class="s4">&quot;blue&quot;</span><span class="s1">: np.column_stack([vals</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">b])</span><span class="s2">,</span>
            <span class="s4">&quot;alpha&quot;</span><span class="s1">: np.column_stack([vals</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">a])</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">LinearSegmentedColormap(name</span><span class="s2">, </span><span class="s1">cdict</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">gamma)</span>

    <span class="s2">def </span><span class="s1">resampled(self</span><span class="s2">, </span><span class="s1">lutsize):</span>
        <span class="s0">&quot;&quot;&quot;Return a new colormap with *lutsize* entries.&quot;&quot;&quot;</span>
        <span class="s1">new_cmap = LinearSegmentedColormap(self.name</span><span class="s2">, </span><span class="s1">self._segmentdata</span><span class="s2">,</span>
                                           <span class="s1">lutsize)</span>
        <span class="s1">new_cmap._rgba_over = self._rgba_over</span>
        <span class="s1">new_cmap._rgba_under = self._rgba_under</span>
        <span class="s1">new_cmap._rgba_bad = self._rgba_bad</span>
        <span class="s2">return </span><span class="s1">new_cmap</span>

    <span class="s3"># Helper ensuring picklability of the reversed cmap.</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_reverser(func</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">func(</span><span class="s5">1 </span><span class="s1">- x)</span>

    <span class="s2">def </span><span class="s1">reversed(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a reversed instance of the Colormap. 
 
        Parameters 
        ---------- 
        name : str, optional 
            The name for the reversed colormap. If None, the 
            name is set to ``self.name + &quot;_r&quot;``. 
 
        Returns 
        ------- 
        LinearSegmentedColormap 
            The reversed colormap. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = self.name + </span><span class="s4">&quot;_r&quot;</span>

        <span class="s3"># Using a partial object keeps the cmap picklable.</span>
        <span class="s1">data_r = {key: (functools.partial(self._reverser</span><span class="s2">, </span><span class="s1">data)</span>
                        <span class="s2">if </span><span class="s1">callable(data) </span><span class="s2">else</span>
                        <span class="s1">[(</span><span class="s5">1.0 </span><span class="s1">- x</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">y0) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">reversed(data)])</span>
                  <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self._segmentdata.items()}</span>

        <span class="s1">new_cmap = LinearSegmentedColormap(name</span><span class="s2">, </span><span class="s1">data_r</span><span class="s2">, </span><span class="s1">self.N</span><span class="s2">, </span><span class="s1">self._gamma)</span>
        <span class="s3"># Reverse the over/under values too</span>
        <span class="s1">new_cmap._rgba_over = self._rgba_under</span>
        <span class="s1">new_cmap._rgba_under = self._rgba_over</span>
        <span class="s1">new_cmap._rgba_bad = self._rgba_bad</span>
        <span class="s2">return </span><span class="s1">new_cmap</span>


<span class="s2">class </span><span class="s1">ListedColormap(Colormap):</span>
    <span class="s0">&quot;&quot;&quot; 
    Colormap object generated from a list of colors. 
 
    This may be most useful when indexing directly into a colormap, 
    but it can also be used to generate special colormaps for ordinary 
    mapping. 
 
    Parameters 
    ---------- 
    colors : list, array 
        List of Matplotlib color specifications, or an equivalent Nx3 or Nx4 
        floating point array (*N* RGB or RGBA values). 
    name : str, optional 
        String to identify the colormap. 
    N : int, optional 
        Number of entries in the map. The default is *None*, in which case 
        there is one colormap entry for each element in the list of colors. 
        If :: 
 
            N &lt; len(colors) 
 
        the list will be truncated at *N*. If :: 
 
            N &gt; len(colors) 
 
        the list will be extended by repetition. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'from_list'</span><span class="s2">, </span><span class="s1">N=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.monochrome = </span><span class="s2">False  </span><span class="s3"># Are all colors identical? (for contour.py)</span>
        <span class="s2">if </span><span class="s1">N </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.colors = colors</span>
            <span class="s1">N = len(colors)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(colors</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">self.colors = [colors] * N</span>
                <span class="s1">self.monochrome = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">np.iterable(colors):</span>
                <span class="s2">if </span><span class="s1">len(colors) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">self.monochrome = </span><span class="s2">True</span>
                <span class="s1">self.colors = list(</span>
                    <span class="s1">itertools.islice(itertools.cycle(colors)</span><span class="s2">, </span><span class="s1">N))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">gray = float(colors)</span>
                <span class="s2">except </span><span class="s1">TypeError:</span>
                    <span class="s2">pass</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.colors = [gray] * N</span>
                <span class="s1">self.monochrome = </span><span class="s2">True</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">N)</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s1">self._lut = np.zeros((self.N + </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float)</span>
        <span class="s1">self._lut[:-</span><span class="s5">3</span><span class="s1">] = to_rgba_array(self.colors)</span>
        <span class="s1">self._isinit = </span><span class="s2">True</span>
        <span class="s1">self._set_extremes()</span>

    <span class="s2">def </span><span class="s1">resampled(self</span><span class="s2">, </span><span class="s1">lutsize):</span>
        <span class="s0">&quot;&quot;&quot;Return a new colormap with *lutsize* entries.&quot;&quot;&quot;</span>
        <span class="s1">colors = self(np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">lutsize))</span>
        <span class="s1">new_cmap = ListedColormap(colors</span><span class="s2">, </span><span class="s1">name=self.name)</span>
        <span class="s3"># Keep the over/under values too</span>
        <span class="s1">new_cmap._rgba_over = self._rgba_over</span>
        <span class="s1">new_cmap._rgba_under = self._rgba_under</span>
        <span class="s1">new_cmap._rgba_bad = self._rgba_bad</span>
        <span class="s2">return </span><span class="s1">new_cmap</span>

    <span class="s2">def </span><span class="s1">reversed(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a reversed instance of the Colormap. 
 
        Parameters 
        ---------- 
        name : str, optional 
            The name for the reversed colormap. If None, the 
            name is set to ``self.name + &quot;_r&quot;``. 
 
        Returns 
        ------- 
        ListedColormap 
            A reversed instance of the colormap. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = self.name + </span><span class="s4">&quot;_r&quot;</span>

        <span class="s1">colors_r = list(reversed(self.colors))</span>
        <span class="s1">new_cmap = ListedColormap(colors_r</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">N=self.N)</span>
        <span class="s3"># Reverse the over/under values too</span>
        <span class="s1">new_cmap._rgba_over = self._rgba_under</span>
        <span class="s1">new_cmap._rgba_under = self._rgba_over</span>
        <span class="s1">new_cmap._rgba_bad = self._rgba_bad</span>
        <span class="s2">return </span><span class="s1">new_cmap</span>


<span class="s2">class </span><span class="s1">Normalize:</span>
    <span class="s0">&quot;&quot;&quot; 
    A class which, when called, linearly normalizes data into the 
    ``[0.0, 1.0]`` interval. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        vmin, vmax : float or None 
            If *vmin* and/or *vmax* is not given, they are initialized from the 
            minimum and maximum value, respectively, of the first input 
            processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``. 
 
        clip : bool, default: False 
            If ``True`` values falling outside the range ``[vmin, vmax]``, 
            are mapped to 0 or 1, whichever is closer, and masked values are 
            set to 1.  If ``False`` masked values remain masked. 
 
            Clipping silently defeats the purpose of setting the over, under, 
            and masked colors in a colormap, so it is likely to lead to 
            surprises; therefore the default is ``clip=False``. 
 
        Notes 
        ----- 
        Returns 0 if ``vmin == vmax``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._vmin = _sanitize_extrema(vmin)</span>
        <span class="s1">self._vmax = _sanitize_extrema(vmax)</span>
        <span class="s1">self._clip = clip</span>
        <span class="s1">self._scale = </span><span class="s2">None</span>
        <span class="s1">self.callbacks = cbook.CallbackRegistry(signals=[</span><span class="s4">&quot;changed&quot;</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vmin(self):</span>
        <span class="s2">return </span><span class="s1">self._vmin</span>

    <span class="s1">@vmin.setter</span>
    <span class="s2">def </span><span class="s1">vmin(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = _sanitize_extrema(value)</span>
        <span class="s2">if </span><span class="s1">value != self._vmin:</span>
            <span class="s1">self._vmin = value</span>
            <span class="s1">self._changed()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vmax(self):</span>
        <span class="s2">return </span><span class="s1">self._vmax</span>

    <span class="s1">@vmax.setter</span>
    <span class="s2">def </span><span class="s1">vmax(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = _sanitize_extrema(value)</span>
        <span class="s2">if </span><span class="s1">value != self._vmax:</span>
            <span class="s1">self._vmax = value</span>
            <span class="s1">self._changed()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">clip(self):</span>
        <span class="s2">return </span><span class="s1">self._clip</span>

    <span class="s1">@clip.setter</span>
    <span class="s2">def </span><span class="s1">clip(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">value != self._clip:</span>
            <span class="s1">self._clip = value</span>
            <span class="s1">self._changed()</span>

    <span class="s2">def </span><span class="s1">_changed(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call this whenever the norm is changed to notify all the 
        callback listeners to the 'changed' signal. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.callbacks.process(</span><span class="s4">'changed'</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">process_value(value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Homogenize the input *value* for easy and efficient normalization. 
 
        *value* can be a scalar or sequence. 
 
        Returns 
        ------- 
        result : masked array 
            Masked array with the same shape as *value*. 
        is_scalar : bool 
            Whether *value* is a scalar. 
 
        Notes 
        ----- 
        Float dtypes are preserved; integer types with two bytes or smaller are 
        converted to np.float32, and larger types are converted to np.float64. 
        Preserving float32 when possible, and using in-place operations, 
        greatly improves speed for large arrays. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_scalar = </span><span class="s2">not </span><span class="s1">np.iterable(value)</span>
        <span class="s2">if </span><span class="s1">is_scalar:</span>
            <span class="s1">value = [value]</span>
        <span class="s1">dtype = np.min_scalar_type(value)</span>
        <span class="s2">if </span><span class="s1">np.issubdtype(dtype</span><span class="s2">, </span><span class="s1">np.integer) </span><span class="s2">or </span><span class="s1">dtype.type </span><span class="s2">is </span><span class="s1">np.bool_:</span>
            <span class="s3"># bool_/int8/int16 -&gt; float32; int32/int64 -&gt; float64</span>
            <span class="s1">dtype = np.promote_types(dtype</span><span class="s2">, </span><span class="s1">np.float32)</span>
        <span class="s3"># ensure data passed in as an ndarray subclass are interpreted as</span>
        <span class="s3"># an ndarray. See issue #6622.</span>
        <span class="s1">mask = np.ma.getmask(value)</span>
        <span class="s1">data = np.asarray(value)</span>
        <span class="s1">result = np.ma.array(data</span><span class="s2">, </span><span class="s1">mask=mask</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">is_scalar</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize *value* data in the ``[vmin, vmax]`` interval into the 
        ``[0.0, 1.0]`` interval and return it. 
 
        Parameters 
        ---------- 
        value 
            Data to normalize. 
        clip : bool 
            If ``None``, defaults to ``self.clip`` (which defaults to 
            ``False``). 
 
        Notes 
        ----- 
        If not already initialized, ``self.vmin`` and ``self.vmax`` are 
        initialized using ``self.autoscale_None(value)``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">clip </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">clip = self.clip</span>

        <span class="s1">result</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>

        <span class="s2">if </span><span class="s1">self.vmin </span><span class="s2">is None or </span><span class="s1">self.vmax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.autoscale_None(result)</span>
        <span class="s3"># Convert at least to float, without losing precision.</span>
        <span class="s1">(vmin</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmin)</span>
        <span class="s1">(vmax</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmax)</span>
        <span class="s2">if </span><span class="s1">vmin == vmax:</span>
            <span class="s1">result.fill(</span><span class="s5">0</span><span class="s1">)  </span><span class="s3"># Or should it be all masked?  Or 0.5?</span>
        <span class="s2">elif </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;minvalue must be less than or equal to maxvalue&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">clip:</span>
                <span class="s1">mask = np.ma.getmask(result)</span>
                <span class="s1">result = np.ma.array(np.clip(result.filled(vmax)</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax)</span><span class="s2">,</span>
                                     <span class="s1">mask=mask)</span>
            <span class="s3"># ma division is very slow; we can take a shortcut</span>
            <span class="s1">resdat = result.data</span>
            <span class="s1">resdat -= vmin</span>
            <span class="s1">resdat /= (vmax - vmin)</span>
            <span class="s1">result = np.ma.array(resdat</span><span class="s2">, </span><span class="s1">mask=result.mask</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_scalar:</span>
            <span class="s1">result = result[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if not </span><span class="s1">self.scaled():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Not invertible until both vmin and vmax are set&quot;</span><span class="s1">)</span>
        <span class="s1">(vmin</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmin)</span>
        <span class="s1">(vmax</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmax)</span>

        <span class="s2">if </span><span class="s1">np.iterable(value):</span>
            <span class="s1">val = np.ma.asarray(value)</span>
            <span class="s2">return </span><span class="s1">vmin + val * (vmax - vmin)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">vmin + value * (vmax - vmin)</span>

    <span class="s2">def </span><span class="s1">autoscale(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot;Set *vmin*, *vmax* to min, max of *A*.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self.callbacks.blocked():</span>
            <span class="s3"># Pause callbacks while we are updating so we only get</span>
            <span class="s3"># a single update signal at the end</span>
            <span class="s1">self.vmin = self.vmax = </span><span class="s2">None</span>
            <span class="s1">self.autoscale_None(A)</span>
        <span class="s1">self._changed()</span>

    <span class="s2">def </span><span class="s1">autoscale_None(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot;If vmin or vmax are not set, use the min/max of *A* to set them.&quot;&quot;&quot;</span>
        <span class="s1">A = np.asanyarray(A)</span>
        <span class="s2">if </span><span class="s1">self.vmin </span><span class="s2">is None and </span><span class="s1">A.size:</span>
            <span class="s1">self.vmin = A.min()</span>
        <span class="s2">if </span><span class="s1">self.vmax </span><span class="s2">is None and </span><span class="s1">A.size:</span>
            <span class="s1">self.vmax = A.max()</span>

    <span class="s2">def </span><span class="s1">scaled(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether vmin and vmax are set.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.vmin </span><span class="s2">is not None and </span><span class="s1">self.vmax </span><span class="s2">is not None</span>


<span class="s2">class </span><span class="s1">TwoSlopeNorm(Normalize):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">vcenter</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize data with a set center. 
 
        Useful when mapping data with an unequal rates of change around a 
        conceptual center, e.g., data that range from -2 to 4, with 0 as 
        the midpoint. 
 
        Parameters 
        ---------- 
        vcenter : float 
            The data value that defines ``0.5`` in the normalization. 
        vmin : float, optional 
            The data value that defines ``0.0`` in the normalization. 
            Defaults to the min value of the dataset. 
        vmax : float, optional 
            The data value that defines ``1.0`` in the normalization. 
            Defaults to the max value of the dataset. 
 
        Examples 
        -------- 
        This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data 
        between is linearly interpolated:: 
 
            &gt;&gt;&gt; import matplotlib.colors as mcolors 
            &gt;&gt;&gt; offset = mcolors.TwoSlopeNorm(vmin=-4000., 
                                              vcenter=0., vmax=10000) 
            &gt;&gt;&gt; data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.] 
            &gt;&gt;&gt; offset(data) 
            array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0]) 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(vmin=vmin</span><span class="s2">, </span><span class="s1">vmax=vmax)</span>
        <span class="s1">self._vcenter = vcenter</span>
        <span class="s2">if </span><span class="s1">vcenter </span><span class="s2">is not None and </span><span class="s1">vmax </span><span class="s2">is not None and </span><span class="s1">vcenter &gt;= vmax:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'vmin, vcenter, and vmax must be in '</span>
                             <span class="s4">'ascending order'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">vcenter </span><span class="s2">is not None and </span><span class="s1">vmin </span><span class="s2">is not None and </span><span class="s1">vcenter &lt;= vmin:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'vmin, vcenter, and vmax must be in '</span>
                             <span class="s4">'ascending order'</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vcenter(self):</span>
        <span class="s2">return </span><span class="s1">self._vcenter</span>

    <span class="s1">@vcenter.setter</span>
    <span class="s2">def </span><span class="s1">vcenter(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">value != self._vcenter:</span>
            <span class="s1">self._vcenter = value</span>
            <span class="s1">self._changed()</span>

    <span class="s2">def </span><span class="s1">autoscale_None(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get vmin and vmax, and then clip at vcenter 
        &quot;&quot;&quot;</span>
        <span class="s1">super().autoscale_None(A)</span>
        <span class="s2">if </span><span class="s1">self.vmin &gt; self.vcenter:</span>
            <span class="s1">self.vmin = self.vcenter</span>
        <span class="s2">if </span><span class="s1">self.vmax &lt; self.vcenter:</span>
            <span class="s1">self.vmax = self.vcenter</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Map value to the interval [0, 1]. The clip argument is unused. 
        &quot;&quot;&quot;</span>
        <span class="s1">result</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>
        <span class="s1">self.autoscale_None(result)  </span><span class="s3"># sets self.vmin, self.vmax if None</span>

        <span class="s2">if not </span><span class="s1">self.vmin &lt;= self.vcenter &lt;= self.vmax:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;vmin, vcenter, vmax must increase monotonically&quot;</span><span class="s1">)</span>
        <span class="s3"># note that we must extrapolate for tick locators:</span>
        <span class="s1">result = np.ma.masked_array(</span>
            <span class="s1">np.interp(result</span><span class="s2">, </span><span class="s1">[self.vmin</span><span class="s2">, </span><span class="s1">self.vcenter</span><span class="s2">, </span><span class="s1">self.vmax]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">left=-np.inf</span><span class="s2">, </span><span class="s1">right=np.inf)</span><span class="s2">,</span>
            <span class="s1">mask=np.ma.getmask(result))</span>
        <span class="s2">if </span><span class="s1">is_scalar:</span>
            <span class="s1">result = np.atleast_1d(result)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if not </span><span class="s1">self.scaled():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Not invertible until both vmin and vmax are set&quot;</span><span class="s1">)</span>
        <span class="s1">(vmin</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmin)</span>
        <span class="s1">(vmax</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vmax)</span>
        <span class="s1">(vcenter</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_ = self.process_value(self.vcenter)</span>
        <span class="s1">result = np.interp(value</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[vmin</span><span class="s2">, </span><span class="s1">vcenter</span><span class="s2">, </span><span class="s1">vmax]</span><span class="s2">,</span>
                           <span class="s1">left=-np.inf</span><span class="s2">, </span><span class="s1">right=np.inf)</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">CenteredNorm(Normalize):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">vcenter=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">halfrange=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize symmetrical data around a center (0 by default). 
 
        Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change 
        around the center. 
 
        Useful when mapping symmetrical data around a conceptual center 
        e.g., data that range from -2 to 4, with 0 as the midpoint, and 
        with equal rates of change around that midpoint. 
 
        Parameters 
        ---------- 
        vcenter : float, default: 0 
            The data value that defines ``0.5`` in the normalization. 
        halfrange : float, optional 
            The range of data values that defines a range of ``0.5`` in the 
            normalization, so that *vcenter* - *halfrange* is ``0.0`` and 
            *vcenter* + *halfrange* is ``1.0`` in the normalization. 
            Defaults to the largest absolute difference to *vcenter* for 
            the values in the dataset. 
 
        Examples 
        -------- 
        This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0 
        (assuming equal rates of change above and below 0.0): 
 
            &gt;&gt;&gt; import matplotlib.colors as mcolors 
            &gt;&gt;&gt; norm = mcolors.CenteredNorm(halfrange=4.0) 
            &gt;&gt;&gt; data = [-2., 0., 4.] 
            &gt;&gt;&gt; norm(data) 
            array([0.25, 0.5 , 1.  ]) 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=clip)</span>
        <span class="s1">self._vcenter = vcenter</span>
        <span class="s3"># calling the halfrange setter to set vmin and vmax</span>
        <span class="s1">self.halfrange = halfrange</span>

    <span class="s2">def </span><span class="s1">autoscale(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*. 
        &quot;&quot;&quot;</span>
        <span class="s1">A = np.asanyarray(A)</span>
        <span class="s1">self.halfrange = max(self._vcenter-A.min()</span><span class="s2">,</span>
                             <span class="s1">A.max()-self._vcenter)</span>

    <span class="s2">def </span><span class="s1">autoscale_None(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot;Set *vmin* and *vmax*.&quot;&quot;&quot;</span>
        <span class="s1">A = np.asanyarray(A)</span>
        <span class="s2">if </span><span class="s1">self.halfrange </span><span class="s2">is None and </span><span class="s1">A.size:</span>
            <span class="s1">self.autoscale(A)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vmin(self):</span>
        <span class="s2">return </span><span class="s1">self._vmin</span>

    <span class="s1">@vmin.setter</span>
    <span class="s2">def </span><span class="s1">vmin(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = _sanitize_extrema(value)</span>
        <span class="s2">if </span><span class="s1">value != self._vmin:</span>
            <span class="s1">self._vmin = value</span>
            <span class="s1">self._vmax = </span><span class="s5">2</span><span class="s1">*self.vcenter - value</span>
            <span class="s1">self._changed()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vmax(self):</span>
        <span class="s2">return </span><span class="s1">self._vmax</span>

    <span class="s1">@vmax.setter</span>
    <span class="s2">def </span><span class="s1">vmax(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">value = _sanitize_extrema(value)</span>
        <span class="s2">if </span><span class="s1">value != self._vmax:</span>
            <span class="s1">self._vmax = value</span>
            <span class="s1">self._vmin = </span><span class="s5">2</span><span class="s1">*self.vcenter - value</span>
            <span class="s1">self._changed()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">vcenter(self):</span>
        <span class="s2">return </span><span class="s1">self._vcenter</span>

    <span class="s1">@vcenter.setter</span>
    <span class="s2">def </span><span class="s1">vcenter(self</span><span class="s2">, </span><span class="s1">vcenter):</span>
        <span class="s2">if </span><span class="s1">vcenter != self._vcenter:</span>
            <span class="s1">self._vcenter = vcenter</span>
            <span class="s3"># Trigger an update of the vmin/vmax values through the setter</span>
            <span class="s1">self.halfrange = self.halfrange</span>
            <span class="s1">self._changed()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">halfrange(self):</span>
        <span class="s2">if </span><span class="s1">self.vmin </span><span class="s2">is None or </span><span class="s1">self.vmax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">(self.vmax - self.vmin) / </span><span class="s5">2</span>

    <span class="s1">@halfrange.setter</span>
    <span class="s2">def </span><span class="s1">halfrange(self</span><span class="s2">, </span><span class="s1">halfrange):</span>
        <span class="s2">if </span><span class="s1">halfrange </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.vmin = </span><span class="s2">None</span>
            <span class="s1">self.vmax = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.vmin = self.vcenter - abs(halfrange)</span>
            <span class="s1">self.vmax = self.vcenter + abs(halfrange)</span>


<span class="s2">def </span><span class="s1">make_norm_from_scale(scale_cls</span><span class="s2">, </span><span class="s1">base_norm_cls=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">init=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase` 
    subclass. 
 
    After :: 
 
        @make_norm_from_scale(scale_cls) 
        class norm_cls(Normalize): 
            ... 
 
    *norm_cls* is filled with methods so that normalization computations are 
    forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used 
    for the colorbar of a mappable normalized with *norm_cls*). 
 
    If *init* is not passed, then the constructor signature of *norm_cls* 
    will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three 
    parameters will be forwarded to the base class (``Normalize.__init__``), 
    and a *scale_cls* object will be initialized with no arguments (other than 
    a dummy axis). 
 
    If the *scale_cls* constructor takes additional parameters, then *init* 
    should be passed to `make_norm_from_scale`.  It is a callable which is 
    *only* used for its signature.  First, this signature will become the 
    signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the 
    parameters passed to it using this signature, extract the bound *vmin*, 
    *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and 
    forward the remaining bound values (including any defaults defined by the 
    signature) to the *scale_cls* constructor. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">base_norm_cls </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">functools.partial(make_norm_from_scale</span><span class="s2">, </span><span class="s1">scale_cls</span><span class="s2">, </span><span class="s1">init=init)</span>

    <span class="s2">if </span><span class="s1">isinstance(scale_cls</span><span class="s2">, </span><span class="s1">functools.partial):</span>
        <span class="s1">scale_args = scale_cls.args</span>
        <span class="s1">scale_kwargs_items = tuple(scale_cls.keywords.items())</span>
        <span class="s1">scale_cls = scale_cls.func</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">scale_args = scale_kwargs_items = ()</span>

    <span class="s2">if </span><span class="s1">init </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">init(vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">): </span><span class="s2">pass</span>

    <span class="s2">return </span><span class="s1">_make_norm_from_scale(</span>
        <span class="s1">scale_cls</span><span class="s2">, </span><span class="s1">scale_args</span><span class="s2">, </span><span class="s1">scale_kwargs_items</span><span class="s2">,</span>
        <span class="s1">base_norm_cls</span><span class="s2">, </span><span class="s1">inspect.signature(init))</span>


<span class="s1">@functools.lru_cache(</span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_make_norm_from_scale(</span>
    <span class="s1">scale_cls</span><span class="s2">, </span><span class="s1">scale_args</span><span class="s2">, </span><span class="s1">scale_kwargs_items</span><span class="s2">,</span>
    <span class="s1">base_norm_cls</span><span class="s2">, </span><span class="s1">bound_init_signature</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper for `make_norm_from_scale`. 
 
    This function is split out to enable caching (in particular so that 
    different unpickles reuse the same class).  In order to do so, 
 
    - ``functools.partial`` *scale_cls* is expanded into ``func, args, kwargs`` 
      to allow memoizing returned norms (partial instances always compare 
      unequal, but we can check identity based on ``func, args, kwargs``; 
    - *init* is replaced by *init_signature*, as signatures are picklable, 
      unlike to arbitrary lambdas. 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">Norm(base_norm_cls):</span>
        <span class="s2">def </span><span class="s1">__reduce__(self):</span>
            <span class="s1">cls = type(self)</span>
            <span class="s3"># If the class is toplevel-accessible, it is possible to directly</span>
            <span class="s3"># pickle it &quot;by name&quot;.  This is required to support norm classes</span>
            <span class="s3"># defined at a module's toplevel, as the inner base_norm_cls is</span>
            <span class="s3"># otherwise unpicklable (as it gets shadowed by the generated norm</span>
            <span class="s3"># class).  If either import or attribute access fails, fall back to</span>
            <span class="s3"># the general path.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">cls </span><span class="s2">is </span><span class="s1">getattr(importlib.import_module(cls.__module__)</span><span class="s2">,</span>
                                  <span class="s1">cls.__qualname__):</span>
                    <span class="s2">return </span><span class="s1">(_create_empty_object_of_class</span><span class="s2">, </span><span class="s1">(cls</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">vars(self))</span>
            <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
                <span class="s2">pass</span>
            <span class="s2">return </span><span class="s1">(_picklable_norm_constructor</span><span class="s2">,</span>
                    <span class="s1">(scale_cls</span><span class="s2">, </span><span class="s1">scale_args</span><span class="s2">, </span><span class="s1">scale_kwargs_items</span><span class="s2">,</span>
                     <span class="s1">base_norm_cls</span><span class="s2">, </span><span class="s1">bound_init_signature)</span><span class="s2">,</span>
                    <span class="s1">vars(self))</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">ba = bound_init_signature.bind(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">ba.apply_defaults()</span>
            <span class="s1">super().__init__(</span>
                <span class="s1">**{k: ba.arguments.pop(k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;vmin&quot;</span><span class="s2">, </span><span class="s4">&quot;vmax&quot;</span><span class="s2">, </span><span class="s4">&quot;clip&quot;</span><span class="s1">]})</span>
            <span class="s1">self._scale = functools.partial(</span>
                <span class="s1">scale_cls</span><span class="s2">, </span><span class="s1">*scale_args</span><span class="s2">, </span><span class="s1">**dict(scale_kwargs_items))(</span>
                    <span class="s1">axis=</span><span class="s2">None, </span><span class="s1">**ba.arguments)</span>
            <span class="s1">self._trf = self._scale.get_transform()</span>

        <span class="s1">__init__.__signature__ = bound_init_signature.replace(parameters=[</span>
            <span class="s1">inspect.Parameter(</span><span class="s4">&quot;self&quot;</span><span class="s2">, </span><span class="s1">inspect.Parameter.POSITIONAL_OR_KEYWORD)</span><span class="s2">,</span>
            <span class="s1">*bound_init_signature.parameters.values()])</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>
            <span class="s2">if </span><span class="s1">self.vmin </span><span class="s2">is None or </span><span class="s1">self.vmax </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.autoscale_None(value)</span>
            <span class="s2">if </span><span class="s1">self.vmin &gt; self.vmax:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;vmin must be less or equal to vmax&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.vmin == self.vmax:</span>
                <span class="s2">return </span><span class="s1">np.full_like(value</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">clip </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">clip = self.clip</span>
            <span class="s2">if </span><span class="s1">clip:</span>
                <span class="s1">value = np.clip(value</span><span class="s2">, </span><span class="s1">self.vmin</span><span class="s2">, </span><span class="s1">self.vmax)</span>
            <span class="s1">t_value = self._trf.transform(value).reshape(np.shape(value))</span>
            <span class="s1">t_vmin</span><span class="s2">, </span><span class="s1">t_vmax = self._trf.transform([self.vmin</span><span class="s2">, </span><span class="s1">self.vmax])</span>
            <span class="s2">if not </span><span class="s1">np.isfinite([t_vmin</span><span class="s2">, </span><span class="s1">t_vmax]).all():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid vmin or vmax&quot;</span><span class="s1">)</span>
            <span class="s1">t_value -= t_vmin</span>
            <span class="s1">t_value /= (t_vmax - t_vmin)</span>
            <span class="s1">t_value = np.ma.masked_invalid(t_value</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">t_value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">is_scalar </span><span class="s2">else </span><span class="s1">t_value</span>

        <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
            <span class="s2">if not </span><span class="s1">self.scaled():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Not invertible until scaled&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.vmin &gt; self.vmax:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;vmin must be less or equal to vmax&quot;</span><span class="s1">)</span>
            <span class="s1">t_vmin</span><span class="s2">, </span><span class="s1">t_vmax = self._trf.transform([self.vmin</span><span class="s2">, </span><span class="s1">self.vmax])</span>
            <span class="s2">if not </span><span class="s1">np.isfinite([t_vmin</span><span class="s2">, </span><span class="s1">t_vmax]).all():</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid vmin or vmax&quot;</span><span class="s1">)</span>
            <span class="s1">value</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>
            <span class="s1">rescaled = value * (t_vmax - t_vmin)</span>
            <span class="s1">rescaled += t_vmin</span>
            <span class="s1">value = (self._trf</span>
                     <span class="s1">.inverted()</span>
                     <span class="s1">.transform(rescaled)</span>
                     <span class="s1">.reshape(np.shape(value)))</span>
            <span class="s2">return </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">is_scalar </span><span class="s2">else </span><span class="s1">value</span>

        <span class="s2">def </span><span class="s1">autoscale_None(self</span><span class="s2">, </span><span class="s1">A):</span>
            <span class="s3"># i.e. A[np.isfinite(...)], but also for non-array A's</span>
            <span class="s1">in_trf_domain = np.extract(np.isfinite(self._trf.transform(A))</span><span class="s2">, </span><span class="s1">A)</span>
            <span class="s2">if </span><span class="s1">in_trf_domain.size == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">in_trf_domain = np.ma.masked</span>
            <span class="s2">return </span><span class="s1">super().autoscale_None(in_trf_domain)</span>

    <span class="s2">if </span><span class="s1">base_norm_cls </span><span class="s2">is </span><span class="s1">Normalize:</span>
        <span class="s1">Norm.__name__ = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">scale_cls.__name__</span><span class="s2">}</span><span class="s4">Norm&quot;</span>
        <span class="s1">Norm.__qualname__ = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">scale_cls.__qualname__</span><span class="s2">}</span><span class="s4">Norm&quot;</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">Norm.__name__ = base_norm_cls.__name__</span>
        <span class="s1">Norm.__qualname__ = base_norm_cls.__qualname__</span>
    <span class="s1">Norm.__module__ = base_norm_cls.__module__</span>
    <span class="s1">Norm.__doc__ = base_norm_cls.__doc__</span>

    <span class="s2">return </span><span class="s1">Norm</span>


<span class="s2">def </span><span class="s1">_create_empty_object_of_class(cls):</span>
    <span class="s2">return </span><span class="s1">cls.__new__(cls)</span>


<span class="s2">def </span><span class="s1">_picklable_norm_constructor(*args):</span>
    <span class="s2">return </span><span class="s1">_create_empty_object_of_class(_make_norm_from_scale(*args))</span>


<span class="s1">@make_norm_from_scale(</span>
    <span class="s1">scale.FuncScale</span><span class="s2">,</span>
    <span class="s1">init=</span><span class="s2">lambda </span><span class="s1">functions</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">FuncNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    Arbitrary normalization using functions for the forward and inverse. 
 
    Parameters 
    ---------- 
    functions : (callable, callable) 
        two-tuple of the forward and inverse functions for the normalization. 
        The forward function must be monotonic. 
 
        Both functions must have the signature :: 
 
           def forward(values: array-like) -&gt; array-like 
 
    vmin, vmax : float or None 
        If *vmin* and/or *vmax* is not given, they are initialized from the 
        minimum and maximum value, respectively, of the first input 
        processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``. 
 
    clip : bool, default: False 
        If ``True`` values falling outside the range ``[vmin, vmax]``, 
        are mapped to 0 or 1, whichever is closer, and masked values are 
        set to 1.  If ``False`` masked values remain masked. 
 
        Clipping silently defeats the purpose of setting the over, under, 
        and masked colors in a colormap, so it is likely to lead to 
        surprises; therefore the default is ``clip=False``. 
    &quot;&quot;&quot;</span>


<span class="s1">LogNorm = make_norm_from_scale(</span>
    <span class="s1">functools.partial(scale.LogScale</span><span class="s2">, </span><span class="s1">nonpositive=</span><span class="s4">&quot;mask&quot;</span><span class="s1">))(Normalize)</span>
<span class="s1">LogNorm.__name__ = LogNorm.__qualname__ = </span><span class="s4">&quot;LogNorm&quot;</span>
<span class="s1">LogNorm.__doc__ = </span><span class="s4">&quot;Normalize a given value to the 0-1 range on a log scale.&quot;</span>


<span class="s1">@make_norm_from_scale(</span>
    <span class="s1">scale.SymmetricalLogScale</span><span class="s2">,</span>
    <span class="s1">init=</span><span class="s2">lambda </span><span class="s1">linthresh</span><span class="s2">, </span><span class="s1">linscale=</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False, </span><span class="s1">*</span><span class="s2">,</span>
                <span class="s1">base=</span><span class="s5">10</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">SymLogNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    The symmetrical logarithmic scale is logarithmic in both the 
    positive and negative directions from the origin. 
 
    Since the values close to zero tend toward infinity, there is a 
    need to have a range around zero that is linear.  The parameter 
    *linthresh* allows the user to specify the size of this range 
    (-*linthresh*, *linthresh*). 
 
    Parameters 
    ---------- 
    linthresh : float 
        The range within which the plot is linear (to avoid having the plot 
        go to infinity around zero). 
    linscale : float, default: 1 
        This allows the linear range (-*linthresh* to *linthresh*) to be 
        stretched relative to the logarithmic range. Its value is the 
        number of decades to use for each half of the linear range. For 
        example, when *linscale* == 1.0 (the default), the space used for 
        the positive and negative halves of the linear range will be equal 
        to one decade in the logarithmic range. 
    base : float, default: 10 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">linthresh(self):</span>
        <span class="s2">return </span><span class="s1">self._scale.linthresh</span>

    <span class="s1">@linthresh.setter</span>
    <span class="s2">def </span><span class="s1">linthresh(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._scale.linthresh = value</span>


<span class="s1">@make_norm_from_scale(</span>
    <span class="s1">scale.AsinhScale</span><span class="s2">,</span>
    <span class="s1">init=</span><span class="s2">lambda </span><span class="s1">linear_width=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">AsinhNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    The inverse hyperbolic sine scale is approximately linear near 
    the origin, but becomes logarithmic for larger positive 
    or negative values. Unlike the `SymLogNorm`, the transition between 
    these linear and logarithmic regions is smooth, which may reduce 
    the risk of visual artifacts. 
 
    .. note:: 
 
       This API is provisional and may be revised in the future 
       based on early user feedback. 
 
    Parameters 
    ---------- 
    linear_width : float, default: 1 
        The effective width of the linear region, beyond which 
        the transformation becomes asymptotically logarithmic 
    &quot;&quot;&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">linear_width(self):</span>
        <span class="s2">return </span><span class="s1">self._scale.linear_width</span>

    <span class="s1">@linear_width.setter</span>
    <span class="s2">def </span><span class="s1">linear_width(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._scale.linear_width = value</span>


<span class="s2">class </span><span class="s1">PowerNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    Linearly map a given value to the 0-1 range and then apply 
    a power-law normalization over that range. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">clip)</span>
        <span class="s1">self.gamma = gamma</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">clip </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">clip = self.clip</span>

        <span class="s1">result</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>

        <span class="s1">self.autoscale_None(result)</span>
        <span class="s1">gamma = self.gamma</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.vmin</span><span class="s2">, </span><span class="s1">self.vmax</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;minvalue must be less than or equal to maxvalue&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">vmin == vmax:</span>
            <span class="s1">result.fill(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">clip:</span>
                <span class="s1">mask = np.ma.getmask(result)</span>
                <span class="s1">result = np.ma.array(np.clip(result.filled(vmax)</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax)</span><span class="s2">,</span>
                                     <span class="s1">mask=mask)</span>
            <span class="s1">resdat = result.data</span>
            <span class="s1">resdat -= vmin</span>
            <span class="s1">resdat[resdat &lt; </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
            <span class="s1">np.power(resdat</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">resdat)</span>
            <span class="s1">resdat /= (vmax - vmin) ** gamma</span>

            <span class="s1">result = np.ma.array(resdat</span><span class="s2">, </span><span class="s1">mask=result.mask</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_scalar:</span>
            <span class="s1">result = result[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if not </span><span class="s1">self.scaled():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Not invertible until scaled&quot;</span><span class="s1">)</span>
        <span class="s1">gamma = self.gamma</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.vmin</span><span class="s2">, </span><span class="s1">self.vmax</span>

        <span class="s2">if </span><span class="s1">np.iterable(value):</span>
            <span class="s1">val = np.ma.asarray(value)</span>
            <span class="s2">return </span><span class="s1">np.ma.power(val</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ gamma) * (vmax - vmin) + vmin</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">pow(value</span><span class="s2">, </span><span class="s5">1. </span><span class="s1">/ gamma) * (vmax - vmin) + vmin</span>


<span class="s2">class </span><span class="s1">BoundaryNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a colormap index based on discrete intervals. 
 
    Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers 
    instead of to the interval 0-1. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Mapping to the 0-1 interval could have been done via piece-wise linear</span>
    <span class="s3"># interpolation, but using integers seems simpler, and reduces the number</span>
    <span class="s3"># of conversions back and forth between int and float.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">boundaries</span><span class="s2">, </span><span class="s1">ncolors</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">extend=</span><span class="s4">'neither'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        boundaries : array-like 
            Monotonically increasing sequence of at least 2 bin edges:  data 
            falling in the n-th bin will be mapped to the n-th color. 
 
        ncolors : int 
            Number of colors in the colormap to be used. 
 
        clip : bool, optional 
            If clip is ``True``, out of range values are mapped to 0 if they 
            are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they 
            are above ``boundaries[-1]``. 
 
            If clip is ``False``, out of range values are mapped to -1 if 
            they are below ``boundaries[0]`` or mapped to *ncolors* if they are 
            above ``boundaries[-1]``. These are then converted to valid indices 
            by `Colormap.__call__`. 
 
        extend : {'neither', 'both', 'min', 'max'}, default: 'neither' 
            Extend the number of bins to include one or both of the 
            regions beyond the boundaries.  For example, if ``extend`` 
            is 'min', then the color to which the region between the first 
            pair of boundaries is mapped will be distinct from the first 
            color in the colormap, and by default a 
            `~matplotlib.colorbar.Colorbar` will be drawn with 
            the triangle extension on the left or lower end. 
 
        Notes 
        ----- 
        If there are fewer bins (including extensions) than colors, then the 
        color index is chosen by linearly interpolating the ``[0, nbins - 1]`` 
        range onto the ``[0, ncolors - 1]`` range, effectively skipping some 
        colors in the middle of the colormap. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">clip </span><span class="s2">and </span><span class="s1">extend != </span><span class="s4">'neither'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'clip=True' is not compatible with 'extend'&quot;</span><span class="s1">)</span>
        <span class="s1">super().__init__(vmin=boundaries[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">vmax=boundaries[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">clip=clip)</span>
        <span class="s1">self.boundaries = np.asarray(boundaries)</span>
        <span class="s1">self.N = len(self.boundaries)</span>
        <span class="s2">if </span><span class="s1">self.N &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;You must provide at least 2 boundaries &quot;</span>
                             <span class="s4">f&quot;(1 region) but you passed in </span><span class="s2">{</span><span class="s1">boundaries</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">self.Ncmap = ncolors</span>
        <span class="s1">self.extend = extend</span>

        <span class="s1">self._scale = </span><span class="s2">None  </span><span class="s3"># don't use the default scale.</span>

        <span class="s1">self._n_regions = self.N - </span><span class="s5">1  </span><span class="s3"># number of colors needed</span>
        <span class="s1">self._offset = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">extend </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'min'</span><span class="s2">, </span><span class="s4">'both'</span><span class="s1">):</span>
            <span class="s1">self._n_regions += </span><span class="s5">1</span>
            <span class="s1">self._offset = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">extend </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'max'</span><span class="s2">, </span><span class="s4">'both'</span><span class="s1">):</span>
            <span class="s1">self._n_regions += </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">self._n_regions &gt; self.Ncmap:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;There are </span><span class="s2">{</span><span class="s1">self._n_regions</span><span class="s2">} </span><span class="s4">color bins &quot;</span>
                             <span class="s4">&quot;including extensions, but ncolors = &quot;</span>
                             <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">ncolors</span><span class="s2">}</span><span class="s4">; ncolors must equal or exceed the &quot;</span>
                             <span class="s4">&quot;number of bins&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This method behaves similarly to `.Normalize.__call__`, except that it 
        returns integers or arrays of int16. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">clip </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">clip = self.clip</span>

        <span class="s1">xx</span><span class="s2">, </span><span class="s1">is_scalar = self.process_value(value)</span>
        <span class="s1">mask = np.ma.getmaskarray(xx)</span>
        <span class="s3"># Fill masked values a value above the upper boundary</span>
        <span class="s1">xx = np.atleast_1d(xx.filled(self.vmax + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">clip:</span>
            <span class="s1">np.clip(xx</span><span class="s2">, </span><span class="s1">self.vmin</span><span class="s2">, </span><span class="s1">self.vmax</span><span class="s2">, </span><span class="s1">out=xx)</span>
            <span class="s1">max_col = self.Ncmap - </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">max_col = self.Ncmap</span>
        <span class="s3"># this gives us the bins in the lookup table in the range</span>
        <span class="s3"># [0, _n_regions - 1]  (the offset is set in the init)</span>
        <span class="s1">iret = np.digitize(xx</span><span class="s2">, </span><span class="s1">self.boundaries) - </span><span class="s5">1 </span><span class="s1">+ self._offset</span>
        <span class="s3"># if we have more colors than regions, stretch the region</span>
        <span class="s3"># index computed above to full range of the color bins.  This</span>
        <span class="s3"># will make use of the full range (but skip some of the colors</span>
        <span class="s3"># in the middle) such that the first region is mapped to the</span>
        <span class="s3"># first color and the last region is mapped to the last color.</span>
        <span class="s2">if </span><span class="s1">self.Ncmap &gt; self._n_regions:</span>
            <span class="s2">if </span><span class="s1">self._n_regions == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s3"># special case the 1 region case, pick the middle color</span>
                <span class="s1">iret[iret == </span><span class="s5">0</span><span class="s1">] = (self.Ncmap - </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># otherwise linearly remap the values from the region index</span>
                <span class="s3"># to the color index spaces</span>
                <span class="s1">iret = (self.Ncmap - </span><span class="s5">1</span><span class="s1">) / (self._n_regions - </span><span class="s5">1</span><span class="s1">) * iret</span>
        <span class="s3"># cast to 16bit integers in all cases</span>
        <span class="s1">iret = iret.astype(np.int16)</span>
        <span class="s1">iret[xx &lt; self.vmin] = -</span><span class="s5">1</span>
        <span class="s1">iret[xx &gt;= self.vmax] = max_col</span>
        <span class="s1">ret = np.ma.array(iret</span><span class="s2">, </span><span class="s1">mask=mask)</span>
        <span class="s2">if </span><span class="s1">is_scalar:</span>
            <span class="s1">ret = int(ret[</span><span class="s5">0</span><span class="s1">])  </span><span class="s3"># assume python scalar</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Raises 
        ------ 
        ValueError 
            BoundaryNorm is not invertible, so calling this method will always 
            raise an error 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;BoundaryNorm is not invertible&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">NoNorm(Normalize):</span>
    <span class="s0">&quot;&quot;&quot; 
    Dummy replacement for `Normalize`, for the case where we want to use 
    indices directly in a `~matplotlib.cm.ScalarMappable`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">inverse(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">return </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">rgb_to_hsv(arr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert float RGB values (in the range [0, 1]), in a numpy array to HSV 
    values. 
 
    Parameters 
    ---------- 
    arr : (..., 3) array-like 
       All values must be in the range [0, 1] 
 
    Returns 
    ------- 
    (..., 3) `~numpy.ndarray` 
       Colors converted to HSV values in range [0, 1] 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = np.asarray(arr)</span>

    <span class="s3"># check length of the last dimension, should be _some_ sort of rgb</span>
    <span class="s2">if </span><span class="s1">arr.shape[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Last dimension of input array must be 3; &quot;</span>
                         <span class="s4">&quot;shape {} was found.&quot;</span><span class="s1">.format(arr.shape))</span>

    <span class="s1">in_shape = arr.shape</span>
    <span class="s1">arr = np.array(</span>
        <span class="s1">arr</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False,</span>
        <span class="s1">dtype=np.promote_types(arr.dtype</span><span class="s2">, </span><span class="s1">np.float32)</span><span class="s2">,  </span><span class="s3"># Don't work on ints.</span>
        <span class="s1">ndmin=</span><span class="s5">2</span><span class="s2">,  </span><span class="s3"># In case input was 1D.</span>
    <span class="s1">)</span>
    <span class="s1">out = np.zeros_like(arr)</span>
    <span class="s1">arr_max = arr.max(-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">ipos = arr_max &gt; </span><span class="s5">0</span>
    <span class="s1">delta = arr.ptp(-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">s = np.zeros_like(delta)</span>
    <span class="s1">s[ipos] = delta[ipos] / arr_max[ipos]</span>
    <span class="s1">ipos = delta &gt; </span><span class="s5">0</span>
    <span class="s3"># red is max</span>
    <span class="s1">idx = (arr[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] == arr_max) &amp; ipos</span>
    <span class="s1">out[idx</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = (arr[idx</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] - arr[idx</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]) / delta[idx]</span>
    <span class="s3"># green is max</span>
    <span class="s1">idx = (arr[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] == arr_max) &amp; ipos</span>
    <span class="s1">out[idx</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">2. </span><span class="s1">+ (arr[idx</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] - arr[idx</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]) / delta[idx]</span>
    <span class="s3"># blue is max</span>
    <span class="s1">idx = (arr[...</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] == arr_max) &amp; ipos</span>
    <span class="s1">out[idx</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">4. </span><span class="s1">+ (arr[idx</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] - arr[idx</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]) / delta[idx]</span>

    <span class="s1">out[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = (out[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] / </span><span class="s5">6.0</span><span class="s1">) % </span><span class="s5">1.0</span>
    <span class="s1">out[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = s</span>
    <span class="s1">out[...</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = arr_max</span>

    <span class="s2">return </span><span class="s1">out.reshape(in_shape)</span>


<span class="s2">def </span><span class="s1">hsv_to_rgb(hsv):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert HSV values to RGB. 
 
    Parameters 
    ---------- 
    hsv : (..., 3) array-like 
       All values assumed to be in range [0, 1] 
 
    Returns 
    ------- 
    (..., 3) `~numpy.ndarray` 
       Colors converted to RGB values in range [0, 1] 
    &quot;&quot;&quot;</span>
    <span class="s1">hsv = np.asarray(hsv)</span>

    <span class="s3"># check length of the last dimension, should be _some_ sort of rgb</span>
    <span class="s2">if </span><span class="s1">hsv.shape[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Last dimension of input array must be 3; &quot;</span>
                         <span class="s4">&quot;shape {shp} was found.&quot;</span><span class="s1">.format(shp=hsv.shape))</span>

    <span class="s1">in_shape = hsv.shape</span>
    <span class="s1">hsv = np.array(</span>
        <span class="s1">hsv</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False,</span>
        <span class="s1">dtype=np.promote_types(hsv.dtype</span><span class="s2">, </span><span class="s1">np.float32)</span><span class="s2">,  </span><span class="s3"># Don't work on ints.</span>
        <span class="s1">ndmin=</span><span class="s5">2</span><span class="s2">,  </span><span class="s3"># In case input was 1D.</span>
    <span class="s1">)</span>

    <span class="s1">h = hsv[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">s = hsv[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">v = hsv[...</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>

    <span class="s1">r = np.empty_like(h)</span>
    <span class="s1">g = np.empty_like(h)</span>
    <span class="s1">b = np.empty_like(h)</span>

    <span class="s1">i = (h * </span><span class="s5">6.0</span><span class="s1">).astype(int)</span>
    <span class="s1">f = (h * </span><span class="s5">6.0</span><span class="s1">) - i</span>
    <span class="s1">p = v * (</span><span class="s5">1.0 </span><span class="s1">- s)</span>
    <span class="s1">q = v * (</span><span class="s5">1.0 </span><span class="s1">- s * f)</span>
    <span class="s1">t = v * (</span><span class="s5">1.0 </span><span class="s1">- s * (</span><span class="s5">1.0 </span><span class="s1">- f))</span>

    <span class="s1">idx = i % </span><span class="s5">6 </span><span class="s1">== </span><span class="s5">0</span>
    <span class="s1">r[idx] = v[idx]</span>
    <span class="s1">g[idx] = t[idx]</span>
    <span class="s1">b[idx] = p[idx]</span>

    <span class="s1">idx = i == </span><span class="s5">1</span>
    <span class="s1">r[idx] = q[idx]</span>
    <span class="s1">g[idx] = v[idx]</span>
    <span class="s1">b[idx] = p[idx]</span>

    <span class="s1">idx = i == </span><span class="s5">2</span>
    <span class="s1">r[idx] = p[idx]</span>
    <span class="s1">g[idx] = v[idx]</span>
    <span class="s1">b[idx] = t[idx]</span>

    <span class="s1">idx = i == </span><span class="s5">3</span>
    <span class="s1">r[idx] = p[idx]</span>
    <span class="s1">g[idx] = q[idx]</span>
    <span class="s1">b[idx] = v[idx]</span>

    <span class="s1">idx = i == </span><span class="s5">4</span>
    <span class="s1">r[idx] = t[idx]</span>
    <span class="s1">g[idx] = p[idx]</span>
    <span class="s1">b[idx] = v[idx]</span>

    <span class="s1">idx = i == </span><span class="s5">5</span>
    <span class="s1">r[idx] = v[idx]</span>
    <span class="s1">g[idx] = p[idx]</span>
    <span class="s1">b[idx] = q[idx]</span>

    <span class="s1">idx = s == </span><span class="s5">0</span>
    <span class="s1">r[idx] = v[idx]</span>
    <span class="s1">g[idx] = v[idx]</span>
    <span class="s1">b[idx] = v[idx]</span>

    <span class="s1">rgb = np.stack([r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">rgb.reshape(in_shape)</span>


<span class="s2">def </span><span class="s1">_vector_magnitude(arr):</span>
    <span class="s3"># things that don't work here:</span>
    <span class="s3">#  * np.linalg.norm: drops mask from ma.array</span>
    <span class="s3">#  * np.sum: drops mask from ma.array unless entire vector is masked</span>
    <span class="s1">sum_sq = </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(arr.shape[-</span><span class="s5">1</span><span class="s1">]):</span>
        <span class="s1">sum_sq += arr[...</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">np.newaxis] ** </span><span class="s5">2</span>
    <span class="s2">return </span><span class="s1">np.sqrt(sum_sq)</span>


<span class="s2">class </span><span class="s1">LightSource:</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a light source coming from the specified azimuth and elevation. 
    Angles are in degrees, with the azimuth measured 
    clockwise from north and elevation up from the zero plane of the surface. 
 
    `shade` is used to produce &quot;shaded&quot; RGB values for a data array. 
    `shade_rgb` can be used to combine an RGB image with an elevation map. 
    `hillshade` produces an illumination map of a surface. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">azdeg=</span><span class="s5">315</span><span class="s2">, </span><span class="s1">altdeg=</span><span class="s5">45</span><span class="s2">, </span><span class="s1">hsv_min_val=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">hsv_max_val=</span><span class="s5">1</span><span class="s2">,</span>
                 <span class="s1">hsv_min_sat=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">hsv_max_sat=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Specify the azimuth (measured clockwise from south) and altitude 
        (measured up from the plane of the surface) of the light source 
        in degrees. 
 
        Parameters 
        ---------- 
        azdeg : float, default: 315 degrees (from the northwest) 
            The azimuth (0-360, degrees clockwise from North) of the light 
            source. 
        altdeg : float, default: 45 degrees 
            The altitude (0-90, degrees up from horizontal) of the light 
            source. 
 
        Notes 
        ----- 
        For backwards compatibility, the parameters *hsv_min_val*, 
        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at 
        initialization as well.  However, these parameters will only be used if 
        &quot;blend_mode='hsv'&quot; is passed into `shade` or `shade_rgb`. 
        See the documentation for `blend_hsv` for more details. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.azdeg = azdeg</span>
        <span class="s1">self.altdeg = altdeg</span>
        <span class="s1">self.hsv_min_val = hsv_min_val</span>
        <span class="s1">self.hsv_max_val = hsv_max_val</span>
        <span class="s1">self.hsv_min_sat = hsv_min_sat</span>
        <span class="s1">self.hsv_max_sat = hsv_max_sat</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">direction(self):</span>
        <span class="s0">&quot;&quot;&quot;The unit vector direction towards the light source.&quot;&quot;&quot;</span>
        <span class="s3"># Azimuth is in degrees clockwise from North. Convert to radians</span>
        <span class="s3"># counterclockwise from East (mathematical notation).</span>
        <span class="s1">az = np.radians(</span><span class="s5">90 </span><span class="s1">- self.azdeg)</span>
        <span class="s1">alt = np.radians(self.altdeg)</span>
        <span class="s2">return </span><span class="s1">np.array([</span>
            <span class="s1">np.cos(az) * np.cos(alt)</span><span class="s2">,</span>
            <span class="s1">np.sin(az) * np.cos(alt)</span><span class="s2">,</span>
            <span class="s1">np.sin(alt)</span>
        <span class="s1">])</span>

    <span class="s2">def </span><span class="s1">hillshade(self</span><span class="s2">, </span><span class="s1">elevation</span><span class="s2">, </span><span class="s1">vert_exag=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dx=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dy=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">fraction=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the illumination intensity for a surface using the defined 
        azimuth and elevation for the light source. 
 
        This computes the normal vectors for the surface, and then passes them 
        on to `shade_normals` 
 
        Parameters 
        ---------- 
        elevation : 2D array-like 
            The height values used to generate an illumination map 
        vert_exag : number, optional 
            The amount to exaggerate the elevation values by when calculating 
            illumination. This can be used either to correct for differences in 
            units between the x-y coordinate system and the elevation 
            coordinate system (e.g. decimal degrees vs. meters) or to 
            exaggerate or de-emphasize topographic effects. 
        dx : number, optional 
            The x-spacing (columns) of the input *elevation* grid. 
        dy : number, optional 
            The y-spacing (rows) of the input *elevation* grid. 
        fraction : number, optional 
            Increases or decreases the contrast of the hillshade.  Values 
            greater than one will cause intermediate values to move closer to 
            full illumination or shadow (and clipping any values that move 
            beyond 0 or 1). Note that this is not visually or mathematically 
            the same as vertical exaggeration. 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            A 2D array of illumination values between 0-1, where 0 is 
            completely in shadow and 1 is completely illuminated. 
        &quot;&quot;&quot;</span>

        <span class="s3"># Because most image and raster GIS data has the first row in the array</span>
        <span class="s3"># as the &quot;top&quot; of the image, dy is implicitly negative.  This is</span>
        <span class="s3"># consistent to what `imshow` assumes, as well.</span>
        <span class="s1">dy = -dy</span>

        <span class="s3"># compute the normal vectors from the partial derivatives</span>
        <span class="s1">e_dy</span><span class="s2">, </span><span class="s1">e_dx = np.gradient(vert_exag * elevation</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">dx)</span>

        <span class="s3"># .view is to keep subclasses</span>
        <span class="s1">normal = np.empty(elevation.shape + (</span><span class="s5">3</span><span class="s2">,</span><span class="s1">)).view(type(elevation))</span>
        <span class="s1">normal[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = -e_dx</span>
        <span class="s1">normal[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = -e_dy</span>
        <span class="s1">normal[...</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">normal /= _vector_magnitude(normal)</span>

        <span class="s2">return </span><span class="s1">self.shade_normals(normal</span><span class="s2">, </span><span class="s1">fraction)</span>

    <span class="s2">def </span><span class="s1">shade_normals(self</span><span class="s2">, </span><span class="s1">normals</span><span class="s2">, </span><span class="s1">fraction=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the illumination intensity for the normal vectors of a 
        surface using the defined azimuth and elevation for the light source. 
 
        Imagine an artificial sun placed at infinity in some azimuth and 
        elevation position illuminating our surface. The parts of the surface 
        that slope toward the sun should brighten while those sides facing away 
        should become darker. 
 
        Parameters 
        ---------- 
        fraction : number, optional 
            Increases or decreases the contrast of the hillshade.  Values 
            greater than one will cause intermediate values to move closer to 
            full illumination or shadow (and clipping any values that move 
            beyond 0 or 1). Note that this is not visually or mathematically 
            the same as vertical exaggeration. 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            A 2D array of illumination values between 0-1, where 0 is 
            completely in shadow and 1 is completely illuminated. 
        &quot;&quot;&quot;</span>

        <span class="s1">intensity = normals.dot(self.direction)</span>

        <span class="s3"># Apply contrast stretch</span>
        <span class="s1">imin</span><span class="s2">, </span><span class="s1">imax = intensity.min()</span><span class="s2">, </span><span class="s1">intensity.max()</span>
        <span class="s1">intensity *= fraction</span>

        <span class="s3"># Rescale to 0-1, keeping range before contrast stretch</span>
        <span class="s3"># If constant slope, keep relative scaling (i.e. flat should be 0.5,</span>
        <span class="s3"># fully occluded 0, etc.)</span>
        <span class="s2">if </span><span class="s1">(imax - imin) &gt; </span><span class="s5">1e-6</span><span class="s1">:</span>
            <span class="s3"># Strictly speaking, this is incorrect. Negative values should be</span>
            <span class="s3"># clipped to 0 because they're fully occluded. However, rescaling</span>
            <span class="s3"># in this manner is consistent with the previous implementation and</span>
            <span class="s3"># visually appears better than a &quot;hard&quot; clip.</span>
            <span class="s1">intensity -= imin</span>
            <span class="s1">intensity /= (imax - imin)</span>
        <span class="s1">intensity = np.clip(intensity</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">intensity</span>

    <span class="s2">def </span><span class="s1">shade(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">cmap</span><span class="s2">, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">blend_mode=</span><span class="s4">'overlay'</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None,</span>
              <span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">vert_exag=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dx=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dy=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">fraction=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Combine colormapped data values with an illumination intensity map 
        (a.k.a.  &quot;hillshade&quot;) of the values. 
 
        Parameters 
        ---------- 
        data : 2D array-like 
            The height values used to generate a shaded map. 
        cmap : `~matplotlib.colors.Colormap` 
            The colormap used to color the *data* array. Note that this must be 
            a `~matplotlib.colors.Colormap` instance.  For example, rather than 
            passing in ``cmap='gist_earth'``, use 
            ``cmap=plt.get_cmap('gist_earth')`` instead. 
        norm : `~matplotlib.colors.Normalize` instance, optional 
            The normalization used to scale values before colormapping. If 
            None, the input will be linearly scaled between its min and max. 
        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional 
            The type of blending used to combine the colormapped data 
            values with the illumination intensity.  Default is 
            &quot;overlay&quot;.  Note that for most topographic surfaces, 
            &quot;overlay&quot; or &quot;soft&quot; appear more visually realistic. If a 
            user-defined function is supplied, it is expected to 
            combine an MxNx3 RGB array of floats (ranging 0 to 1) with 
            an MxNx1 hillshade array (also 0 to 1).  (Call signature 
            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied 
            to this function will be passed on to the *blend_mode* 
            function. 
        vmin : float or None, optional 
            The minimum value used in colormapping *data*. If *None* the 
            minimum value in *data* is used. If *norm* is specified, then this 
            argument will be ignored. 
        vmax : float or None, optional 
            The maximum value used in colormapping *data*. If *None* the 
            maximum value in *data* is used. If *norm* is specified, then this 
            argument will be ignored. 
        vert_exag : number, optional 
            The amount to exaggerate the elevation values by when calculating 
            illumination. This can be used either to correct for differences in 
            units between the x-y coordinate system and the elevation 
            coordinate system (e.g. decimal degrees vs. meters) or to 
            exaggerate or de-emphasize topography. 
        dx : number, optional 
            The x-spacing (columns) of the input *elevation* grid. 
        dy : number, optional 
            The y-spacing (rows) of the input *elevation* grid. 
        fraction : number, optional 
            Increases or decreases the contrast of the hillshade.  Values 
            greater than one will cause intermediate values to move closer to 
            full illumination or shadow (and clipping any values that move 
            beyond 0 or 1). Note that this is not visually or mathematically 
            the same as vertical exaggeration. 
        Additional kwargs are passed on to the *blend_mode* function. 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            An MxNx4 array of floats ranging between 0-1. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">vmin = data.min()</span>
        <span class="s2">if </span><span class="s1">vmax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">vmax = data.max()</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">norm = Normalize(vmin=vmin</span><span class="s2">, </span><span class="s1">vmax=vmax)</span>

        <span class="s1">rgb0 = cmap(norm(data))</span>
        <span class="s1">rgb1 = self.shade_rgb(rgb0</span><span class="s2">, </span><span class="s1">elevation=data</span><span class="s2">, </span><span class="s1">blend_mode=blend_mode</span><span class="s2">,</span>
                              <span class="s1">vert_exag=vert_exag</span><span class="s2">, </span><span class="s1">dx=dx</span><span class="s2">, </span><span class="s1">dy=dy</span><span class="s2">,</span>
                              <span class="s1">fraction=fraction</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s3"># Don't overwrite the alpha channel, if present.</span>
        <span class="s1">rgb0[...</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">] = rgb1[...</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">rgb0</span>

    <span class="s2">def </span><span class="s1">shade_rgb(self</span><span class="s2">, </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">elevation</span><span class="s2">, </span><span class="s1">fraction=</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">blend_mode=</span><span class="s4">'hsv'</span><span class="s2">,</span>
                  <span class="s1">vert_exag=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dx=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dy=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Use this light source to adjust the colors of the *rgb* input array to 
        give the impression of a shaded relief map with the given *elevation*. 
 
        Parameters 
        ---------- 
        rgb : array-like 
            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1. 
        elevation : array-like 
            An (M, N) array of the height values used to generate a shaded map. 
        fraction : number 
            Increases or decreases the contrast of the hillshade.  Values 
            greater than one will cause intermediate values to move closer to 
            full illumination or shadow (and clipping any values that move 
            beyond 0 or 1). Note that this is not visually or mathematically 
            the same as vertical exaggeration. 
        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional 
            The type of blending used to combine the colormapped data values 
            with the illumination intensity.  For backwards compatibility, this 
            defaults to &quot;hsv&quot;. Note that for most topographic surfaces, 
            &quot;overlay&quot; or &quot;soft&quot; appear more visually realistic. If a 
            user-defined function is supplied, it is expected to combine an 
            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade 
            array (also 0 to 1).  (Call signature 
            ``func(rgb, illum, **kwargs)``) 
            Additional kwargs supplied to this function will be passed on to 
            the *blend_mode* function. 
        vert_exag : number, optional 
            The amount to exaggerate the elevation values by when calculating 
            illumination. This can be used either to correct for differences in 
            units between the x-y coordinate system and the elevation 
            coordinate system (e.g. decimal degrees vs. meters) or to 
            exaggerate or de-emphasize topography. 
        dx : number, optional 
            The x-spacing (columns) of the input *elevation* grid. 
        dy : number, optional 
            The y-spacing (rows) of the input *elevation* grid. 
        Additional kwargs are passed on to the *blend_mode* function. 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            An (m, n, 3) array of floats ranging between 0-1. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Calculate the &quot;hillshade&quot; intensity.</span>
        <span class="s1">intensity = self.hillshade(elevation</span><span class="s2">, </span><span class="s1">vert_exag</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">fraction)</span>
        <span class="s1">intensity = intensity[...</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s3"># Blend the hillshade and rgb data using the specified mode</span>
        <span class="s1">lookup = {</span>
                <span class="s4">'hsv'</span><span class="s1">: self.blend_hsv</span><span class="s2">,</span>
                <span class="s4">'soft'</span><span class="s1">: self.blend_soft_light</span><span class="s2">,</span>
                <span class="s4">'overlay'</span><span class="s1">: self.blend_overlay</span><span class="s2">,</span>
                <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">blend_mode </span><span class="s2">in </span><span class="s1">lookup:</span>
            <span class="s1">blend = lookup[blend_mode](rgb</span><span class="s2">, </span><span class="s1">intensity</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">blend = blend_mode(rgb</span><span class="s2">, </span><span class="s1">intensity</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'&quot;blend_mode&quot; must be callable or one of {}'</span>
                                 <span class="s1">.format(lookup.keys)) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s3"># Only apply result where hillshade intensity isn't masked</span>
        <span class="s2">if </span><span class="s1">np.ma.is_masked(intensity):</span>
            <span class="s1">mask = intensity.mask[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
                <span class="s1">blend[...</span><span class="s2">, </span><span class="s1">i][mask] = rgb[...</span><span class="s2">, </span><span class="s1">i][mask]</span>

        <span class="s2">return </span><span class="s1">blend</span>

    <span class="s2">def </span><span class="s1">blend_hsv(self</span><span class="s2">, </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">intensity</span><span class="s2">, </span><span class="s1">hsv_max_sat=</span><span class="s2">None, </span><span class="s1">hsv_max_val=</span><span class="s2">None,</span>
                  <span class="s1">hsv_min_val=</span><span class="s2">None, </span><span class="s1">hsv_min_sat=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Take the input data array, convert to HSV values in the given colormap, 
        then adjust those color values to give the impression of a shaded 
        relief map with a specified light source.  RGBA values are returned, 
        which can then be used to plot the shaded image with imshow. 
 
        The color of the resulting image will be darkened by moving the (s, v) 
        values (in HSV colorspace) toward (hsv_min_sat, hsv_min_val) in the 
        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat, 
        hsv_max_val) in regions that are illuminated.  The default extremes are 
        chose so that completely shaded points are nearly black (s = 1, v = 0) 
        and completely illuminated points are nearly white (s = 0, v = 1). 
 
        Parameters 
        ---------- 
        rgb : `~numpy.ndarray` 
            An MxNx3 RGB array of floats ranging from 0 to 1 (color image). 
        intensity : `~numpy.ndarray` 
            An MxNx1 array of floats ranging from 0 to 1 (grayscale image). 
        hsv_max_sat : number, default: 1 
            The maximum saturation value that the *intensity* map can shift the 
            output image to. 
        hsv_min_sat : number, optional 
            The minimum saturation value that the *intensity* map can shift the 
            output image to. Defaults to 0. 
        hsv_max_val : number, optional 
            The maximum value (&quot;v&quot; in &quot;hsv&quot;) that the *intensity* map can shift 
            the output image to. Defaults to 1. 
        hsv_min_val : number, optional 
            The minimum value (&quot;v&quot; in &quot;hsv&quot;) that the *intensity* map can shift 
            the output image to. Defaults to 0. 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            An MxNx3 RGB array representing the combined images. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Backward compatibility...</span>
        <span class="s2">if </span><span class="s1">hsv_max_sat </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">hsv_max_sat = self.hsv_max_sat</span>
        <span class="s2">if </span><span class="s1">hsv_max_val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">hsv_max_val = self.hsv_max_val</span>
        <span class="s2">if </span><span class="s1">hsv_min_sat </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">hsv_min_sat = self.hsv_min_sat</span>
        <span class="s2">if </span><span class="s1">hsv_min_val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">hsv_min_val = self.hsv_min_val</span>

        <span class="s3"># Expects a 2D intensity array scaled between -1 to 1...</span>
        <span class="s1">intensity = intensity[...</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">intensity = </span><span class="s5">2 </span><span class="s1">* intensity - </span><span class="s5">1</span>

        <span class="s3"># Convert to rgb, then rgb to hsv</span>
        <span class="s1">hsv = rgb_to_hsv(rgb[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">hue</span><span class="s2">, </span><span class="s1">sat</span><span class="s2">, </span><span class="s1">val = np.moveaxis(hsv</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s3"># Modify hsv values (in place) to simulate illumination.</span>
        <span class="s3"># putmask(A, mask, B) &lt;=&gt; A[mask] = B[mask]</span>
        <span class="s1">np.putmask(sat</span><span class="s2">, </span><span class="s1">(np.abs(sat) &gt; </span><span class="s5">1.e-10</span><span class="s1">) &amp; (intensity &gt; </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s1">(</span><span class="s5">1 </span><span class="s1">- intensity) * sat + intensity * hsv_max_sat)</span>
        <span class="s1">np.putmask(sat</span><span class="s2">, </span><span class="s1">(np.abs(sat) &gt; </span><span class="s5">1.e-10</span><span class="s1">) &amp; (intensity &lt; </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ intensity) * sat - intensity * hsv_min_sat)</span>
        <span class="s1">np.putmask(val</span><span class="s2">, </span><span class="s1">intensity &gt; </span><span class="s5">0</span><span class="s2">,</span>
                   <span class="s1">(</span><span class="s5">1 </span><span class="s1">- intensity) * val + intensity * hsv_max_val)</span>
        <span class="s1">np.putmask(val</span><span class="s2">, </span><span class="s1">intensity &lt; </span><span class="s5">0</span><span class="s2">,</span>
                   <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ intensity) * val - intensity * hsv_min_val)</span>
        <span class="s1">np.clip(hsv[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">out=hsv[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:])</span>

        <span class="s3"># Convert modified hsv back to rgb.</span>
        <span class="s2">return </span><span class="s1">hsv_to_rgb(hsv)</span>

    <span class="s2">def </span><span class="s1">blend_soft_light(self</span><span class="s2">, </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">intensity):</span>
        <span class="s0">&quot;&quot;&quot; 
        Combine an RGB image with an intensity map using &quot;soft light&quot; blending, 
        using the &quot;pegtop&quot; formula. 
 
        Parameters 
        ---------- 
        rgb : `~numpy.ndarray` 
            An MxNx3 RGB array of floats ranging from 0 to 1 (color image). 
        intensity : `~numpy.ndarray` 
            An MxNx1 array of floats ranging from 0 to 1 (grayscale image). 
 
        Returns 
        ------- 
        `~numpy.ndarray` 
            An MxNx3 RGB array representing the combined images. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">2 </span><span class="s1">* intensity * rgb + (</span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* intensity) * rgb**</span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">blend_overlay(self</span><span class="s2">, </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">intensity):</span>
        <span class="s0">&quot;&quot;&quot; 
        Combine an RGB image with an intensity map using &quot;overlay&quot; blending. 
 
        Parameters 
        ---------- 
        rgb : `~numpy.ndarray` 
            An MxNx3 RGB array of floats ranging from 0 to 1 (color image). 
        intensity : `~numpy.ndarray` 
            An MxNx1 array of floats ranging from 0 to 1 (grayscale image). 
 
        Returns 
        ------- 
        ndarray 
            An MxNx3 RGB array representing the combined images. 
        &quot;&quot;&quot;</span>
        <span class="s1">low = </span><span class="s5">2 </span><span class="s1">* intensity * rgb</span>
        <span class="s1">high = </span><span class="s5">1 </span><span class="s1">- </span><span class="s5">2 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- intensity) * (</span><span class="s5">1 </span><span class="s1">- rgb)</span>
        <span class="s2">return </span><span class="s1">np.where(rgb &lt;= </span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>


<span class="s2">def </span><span class="s1">from_levels_and_colors(levels</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">extend=</span><span class="s4">'neither'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper routine to generate a cmap and a norm instance which 
    behave similar to contourf's levels and colors arguments. 
 
    Parameters 
    ---------- 
    levels : sequence of numbers 
        The quantization levels used to construct the `BoundaryNorm`. 
        Value ``v`` is quantized to level ``i`` if ``lev[i] &lt;= v &lt; lev[i+1]``. 
    colors : sequence of colors 
        The fill color to use for each level. If *extend* is &quot;neither&quot; there 
        must be ``n_level - 1`` colors. For an *extend* of &quot;min&quot; or &quot;max&quot; add 
        one extra color, and for an *extend* of &quot;both&quot; add two colors. 
    extend : {'neither', 'min', 'max', 'both'}, optional 
        The behaviour when a value falls out of range of the given levels. 
        See `~.Axes.contourf` for details. 
 
    Returns 
    ------- 
    cmap : `~matplotlib.colors.Normalize` 
    norm : `~matplotlib.colors.Colormap` 
    &quot;&quot;&quot;</span>
    <span class="s1">slice_map = {</span>
        <span class="s4">'both'</span><span class="s1">: slice(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">'min'</span><span class="s1">: slice(</span><span class="s5">1</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">'max'</span><span class="s1">: slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">'neither'</span><span class="s1">: slice(</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">_api.check_in_list(slice_map</span><span class="s2">, </span><span class="s1">extend=extend)</span>
    <span class="s1">color_slice = slice_map[extend]</span>

    <span class="s1">n_data_colors = len(levels) - </span><span class="s5">1</span>
    <span class="s1">n_expected = n_data_colors + color_slice.start - (color_slice.stop </span><span class="s2">or </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(colors) != n_expected:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f'With extend == </span><span class="s2">{</span><span class="s1">extend</span><span class="s2">!r} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">len(levels)</span><span class="s2">} </span><span class="s4">levels, '</span>
            <span class="s4">f'expected </span><span class="s2">{</span><span class="s1">n_expected</span><span class="s2">} </span><span class="s4">colors, but got </span><span class="s2">{</span><span class="s1">len(colors)</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s1">cmap = ListedColormap(colors[color_slice]</span><span class="s2">, </span><span class="s1">N=n_data_colors)</span>

    <span class="s2">if </span><span class="s1">extend </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'min'</span><span class="s2">, </span><span class="s4">'both'</span><span class="s1">]:</span>
        <span class="s1">cmap.set_under(colors[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cmap.set_under(</span><span class="s4">'none'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">extend </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'max'</span><span class="s2">, </span><span class="s4">'both'</span><span class="s1">]:</span>
        <span class="s1">cmap.set_over(colors[-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cmap.set_over(</span><span class="s4">'none'</span><span class="s1">)</span>

    <span class="s1">cmap.colorbar_extend = extend</span>

    <span class="s1">norm = BoundaryNorm(levels</span><span class="s2">, </span><span class="s1">ncolors=n_data_colors)</span>
    <span class="s2">return </span><span class="s1">cmap</span><span class="s2">, </span><span class="s1">norm</span>
</pre>
</body>
</html>