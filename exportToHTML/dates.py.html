<html>
<head>
<title>dates.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dates.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Matplotlib provides sophisticated date plotting capabilities, standing on the 
shoulders of python :mod:`datetime` and the add-on module dateutil_. 
 
By default, Matplotlib uses the units machinery described in 
`~matplotlib.units` to convert `datetime.datetime`, and `numpy.datetime64` 
objects when plotted on an x- or y-axis. The user does not 
need to do anything for dates to be formatted, but dates often have strict 
formatting needs, so this module provides many axis locators and formatters. 
A basic example using `numpy.datetime64` is:: 
 
    import numpy as np 
 
    times = np.arange(np.datetime64('2001-01-02'), 
                      np.datetime64('2002-02-03'), np.timedelta64(75, 'm')) 
    y = np.random.randn(len(times)) 
 
    fig, ax = plt.subplots() 
    ax.plot(times, y) 
 
.. seealso:: 
 
    - :doc:`/gallery/text_labels_and_annotations/date` 
    - :doc:`/gallery/ticks/date_concise_formatter` 
    - :doc:`/gallery/ticks/date_demo_convert` 
 
.. _date-format: 
 
Matplotlib date format 
---------------------- 
 
Matplotlib represents dates using floating point numbers specifying the number 
of days since a default epoch of 1970-01-01 UTC; for example, 
1970-01-01, 06:00 is the floating point number 0.25. The formatters and 
locators require the use of `datetime.datetime` objects, so only dates between 
year 0001 and 9999 can be represented.  Microsecond precision 
is achievable for (approximately) 70 years on either side of the epoch, and 
20 microseconds for the rest of the allowable range of dates (year 0001 to 
9999). The epoch can be changed at import time via `.dates.set_epoch` or 
:rc:`dates.epoch` to other dates if necessary; see 
:doc:`/gallery/ticks/date_precision_and_epochs` for a discussion. 
 
.. note:: 
 
   Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern 
   microsecond precision and also made the default axis limit of 0 an invalid 
   datetime.  In 3.3 the epoch was changed as above.  To convert old 
   ordinal floats to the new epoch, users can do:: 
 
     new_ordinal = old_ordinal + mdates.date2num(np.datetime64('0000-12-31')) 
 
 
There are a number of helper functions to convert between :mod:`datetime` 
objects and Matplotlib dates: 
 
.. currentmodule:: matplotlib.dates 
 
.. autosummary:: 
   :nosignatures: 
 
   datestr2num 
   date2num 
   num2date 
   num2timedelta 
   drange 
   set_epoch 
   get_epoch 
 
.. note:: 
 
   Like Python's `datetime.datetime`, Matplotlib uses the Gregorian calendar 
   for all conversions between dates and floating point numbers. This practice 
   is not universal, and calendar differences can cause confusing 
   differences between what Python and Matplotlib give as the number of days 
   since 0001-01-01 and what other software and databases yield.  For 
   example, the US Naval Observatory uses a calendar that switches 
   from Julian to Gregorian in October, 1582.  Hence, using their 
   calculator, the number of days between 0001-01-01 and 2006-04-01 is 
   732403, whereas using the Gregorian calendar via the datetime 
   module we find:: 
 
     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal() 
     Out[1]: 732401 
 
All the Matplotlib date converters, tickers and formatters are timezone aware. 
If no explicit timezone is provided, :rc:`timezone` is assumed, provided as a 
string.  If you want to use a different timezone, pass the *tz* keyword 
argument of `num2date` to any date tickers or locators you create.  This can 
be either a `datetime.tzinfo` instance or a string with the timezone name that 
can be parsed by `~dateutil.tz.gettz`. 
 
A wide range of specific and general purpose date tick locators and 
formatters are provided in this module.  See 
:mod:`matplotlib.ticker` for general information on tick locators 
and formatters.  These are described below. 
 
The dateutil_ module provides additional code to handle date ticking, making it 
easy to place ticks on any kinds of dates.  See examples below. 
 
.. _dateutil: https://dateutil.readthedocs.io 
 
Date tickers 
------------ 
 
Most of the date tickers can locate single or multiple values.  For example:: 
 
    # import constants for the days of the week 
    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU 
 
    # tick on Mondays every week 
    loc = WeekdayLocator(byweekday=MO, tz=tz) 
 
    # tick on Mondays and Saturdays 
    loc = WeekdayLocator(byweekday=(MO, SA)) 
 
In addition, most of the constructors take an interval argument:: 
 
    # tick on Mondays every second week 
    loc = WeekdayLocator(byweekday=MO, interval=2) 
 
The rrule locator allows completely general date ticking:: 
 
    # tick every 5th easter 
    rule = rrulewrapper(YEARLY, byeaster=1, interval=5) 
    loc = RRuleLocator(rule) 
 
The available date tickers are: 
 
* `MicrosecondLocator`: Locate microseconds. 
 
* `SecondLocator`: Locate seconds. 
 
* `MinuteLocator`: Locate minutes. 
 
* `HourLocator`: Locate hours. 
 
* `DayLocator`: Locate specified days of the month. 
 
* `WeekdayLocator`: Locate days of the week, e.g., MO, TU. 
 
* `MonthLocator`: Locate months, e.g., 7 for July. 
 
* `YearLocator`: Locate years that are multiples of base. 
 
* `RRuleLocator`: Locate using a `rrulewrapper`. 
  `rrulewrapper` is a simple wrapper around dateutil_'s `dateutil.rrule` 
  which allow almost arbitrary date tick specifications. 
  See :doc:`rrule example &lt;/gallery/ticks/date_demo_rrule&gt;`. 
 
* `AutoDateLocator`: On autoscale, this class picks the best `DateLocator` 
  (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If 
  called with ``interval_multiples=True`` it will make ticks line up with 
  sensible multiples of the tick intervals.  For example, if the interval is 
  4 hours, it will pick hours 0, 4, 8, etc. as ticks.  This behaviour is not 
  guaranteed by default. 
 
Date formatters 
--------------- 
 
The available date formatters are: 
 
* `AutoDateFormatter`: attempts to figure out the best format to use.  This is 
  most useful when used with the `AutoDateLocator`. 
 
* `ConciseDateFormatter`: also attempts to figure out the best format to use, 
  and to make the format as compact as possible while still having complete 
  date information.  This is most useful when used with the `AutoDateLocator`. 
 
* `DateFormatter`: use `~datetime.datetime.strftime` format strings. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">re</span>

<span class="s2">from </span><span class="s1">dateutil.rrule </span><span class="s2">import </span><span class="s1">(rrule</span><span class="s2">, </span><span class="s1">MO</span><span class="s2">, </span><span class="s1">TU</span><span class="s2">, </span><span class="s1">WE</span><span class="s2">, </span><span class="s1">TH</span><span class="s2">, </span><span class="s1">FR</span><span class="s2">, </span><span class="s1">SA</span><span class="s2">, </span><span class="s1">SU</span><span class="s2">, </span><span class="s1">YEARLY</span><span class="s2">,</span>
                            <span class="s1">MONTHLY</span><span class="s2">, </span><span class="s1">WEEKLY</span><span class="s2">, </span><span class="s1">DAILY</span><span class="s2">, </span><span class="s1">HOURLY</span><span class="s2">, </span><span class="s1">MINUTELY</span><span class="s2">,</span>
                            <span class="s1">SECONDLY)</span>
<span class="s2">from </span><span class="s1">dateutil.relativedelta </span><span class="s2">import </span><span class="s1">relativedelta</span>
<span class="s2">import </span><span class="s1">dateutil.parser</span>
<span class="s2">import </span><span class="s1">dateutil.tz</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">ticker</span><span class="s2">, </span><span class="s1">units</span>

<span class="s1">__all__ = (</span><span class="s3">'datestr2num'</span><span class="s2">, </span><span class="s3">'date2num'</span><span class="s2">, </span><span class="s3">'num2date'</span><span class="s2">, </span><span class="s3">'num2timedelta'</span><span class="s2">, </span><span class="s3">'drange'</span><span class="s2">,</span>
           <span class="s3">'set_epoch'</span><span class="s2">, </span><span class="s3">'get_epoch'</span><span class="s2">, </span><span class="s3">'DateFormatter'</span><span class="s2">, </span><span class="s3">'ConciseDateFormatter'</span><span class="s2">,</span>
           <span class="s3">'AutoDateFormatter'</span><span class="s2">, </span><span class="s3">'DateLocator'</span><span class="s2">, </span><span class="s3">'RRuleLocator'</span><span class="s2">,</span>
           <span class="s3">'AutoDateLocator'</span><span class="s2">, </span><span class="s3">'YearLocator'</span><span class="s2">, </span><span class="s3">'MonthLocator'</span><span class="s2">, </span><span class="s3">'WeekdayLocator'</span><span class="s2">,</span>
           <span class="s3">'DayLocator'</span><span class="s2">, </span><span class="s3">'HourLocator'</span><span class="s2">, </span><span class="s3">'MinuteLocator'</span><span class="s2">,</span>
           <span class="s3">'SecondLocator'</span><span class="s2">, </span><span class="s3">'MicrosecondLocator'</span><span class="s2">,</span>
           <span class="s3">'rrule'</span><span class="s2">, </span><span class="s3">'MO'</span><span class="s2">, </span><span class="s3">'TU'</span><span class="s2">, </span><span class="s3">'WE'</span><span class="s2">, </span><span class="s3">'TH'</span><span class="s2">, </span><span class="s3">'FR'</span><span class="s2">, </span><span class="s3">'SA'</span><span class="s2">, </span><span class="s3">'SU'</span><span class="s2">,</span>
           <span class="s3">'YEARLY'</span><span class="s2">, </span><span class="s3">'MONTHLY'</span><span class="s2">, </span><span class="s3">'WEEKLY'</span><span class="s2">, </span><span class="s3">'DAILY'</span><span class="s2">,</span>
           <span class="s3">'HOURLY'</span><span class="s2">, </span><span class="s3">'MINUTELY'</span><span class="s2">, </span><span class="s3">'SECONDLY'</span><span class="s2">, </span><span class="s3">'MICROSECONDLY'</span><span class="s2">, </span><span class="s3">'relativedelta'</span><span class="s2">,</span>
           <span class="s3">'DateConverter'</span><span class="s2">, </span><span class="s3">'ConciseDateConverter'</span><span class="s2">, </span><span class="s3">'rrulewrapper'</span><span class="s1">)</span>


<span class="s1">_log = logging.getLogger(__name__)</span>
<span class="s1">UTC = datetime.timezone.utc</span>


<span class="s1">@_api.caching_module_getattr</span>
<span class="s2">class </span><span class="s1">__getattr__:</span>
    <span class="s1">JULIAN_OFFSET = _api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: </span><span class="s4">1721424.5</span><span class="s1">))</span>
    <span class="s5"># Julian date at 0000-12-31</span>
    <span class="s5"># note that the Julian day epoch is achievable w/</span>
    <span class="s5"># np.datetime64('-4713-11-24T12:00:00'); datetime64 is proleptic</span>
    <span class="s5"># Gregorian and BC has a one-year offset.  So</span>
    <span class="s5"># np.datetime64('0000-12-31') - np.datetime64('-4713-11-24T12:00') =</span>
    <span class="s5"># 1721424.5</span>
    <span class="s5"># Ref: https://en.wikipedia.org/wiki/Julian_day</span>


<span class="s2">def </span><span class="s1">_get_tzinfo(tz=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate `~datetime.tzinfo` from a string or return `~datetime.tzinfo`. 
    If None, retrieve the preferred timezone from the rcParams dictionary. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">tz = mpl.rcParams[</span><span class="s3">'timezone'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">tz == </span><span class="s3">'UTC'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">UTC</span>
    <span class="s2">if </span><span class="s1">isinstance(tz</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">tzinfo = dateutil.tz.gettz(tz)</span>
        <span class="s2">if </span><span class="s1">tzinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">tz</span><span class="s2">} </span><span class="s3">is not a valid timezone as parsed by&quot;</span>
                             <span class="s3">&quot; dateutil.tz.gettz.&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">tzinfo</span>
    <span class="s2">if </span><span class="s1">isinstance(tz</span><span class="s2">, </span><span class="s1">datetime.tzinfo):</span>
        <span class="s2">return </span><span class="s1">tz</span>
    <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;tz must be string or tzinfo subclass.&quot;</span><span class="s1">)</span>


<span class="s5"># Time-related constants.</span>
<span class="s1">EPOCH_OFFSET = float(datetime.datetime(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">).toordinal())</span>
<span class="s5"># EPOCH_OFFSET is not used by matplotlib</span>
<span class="s1">MICROSECONDLY = SECONDLY + </span><span class="s4">1</span>
<span class="s1">HOURS_PER_DAY = </span><span class="s4">24.</span>
<span class="s1">MIN_PER_HOUR = </span><span class="s4">60.</span>
<span class="s1">SEC_PER_MIN = </span><span class="s4">60.</span>
<span class="s1">MONTHS_PER_YEAR = </span><span class="s4">12.</span>

<span class="s1">DAYS_PER_WEEK = </span><span class="s4">7.</span>
<span class="s1">DAYS_PER_MONTH = </span><span class="s4">30.</span>
<span class="s1">DAYS_PER_YEAR = </span><span class="s4">365.0</span>

<span class="s1">MINUTES_PER_DAY = MIN_PER_HOUR * HOURS_PER_DAY</span>

<span class="s1">SEC_PER_HOUR = SEC_PER_MIN * MIN_PER_HOUR</span>
<span class="s1">SEC_PER_DAY = SEC_PER_HOUR * HOURS_PER_DAY</span>
<span class="s1">SEC_PER_WEEK = SEC_PER_DAY * DAYS_PER_WEEK</span>

<span class="s1">MUSECONDS_PER_DAY = </span><span class="s4">1e6 </span><span class="s1">* SEC_PER_DAY</span>

<span class="s1">MONDAY</span><span class="s2">, </span><span class="s1">TUESDAY</span><span class="s2">, </span><span class="s1">WEDNESDAY</span><span class="s2">, </span><span class="s1">THURSDAY</span><span class="s2">, </span><span class="s1">FRIDAY</span><span class="s2">, </span><span class="s1">SATURDAY</span><span class="s2">, </span><span class="s1">SUNDAY = (</span>
    <span class="s1">MO</span><span class="s2">, </span><span class="s1">TU</span><span class="s2">, </span><span class="s1">WE</span><span class="s2">, </span><span class="s1">TH</span><span class="s2">, </span><span class="s1">FR</span><span class="s2">, </span><span class="s1">SA</span><span class="s2">, </span><span class="s1">SU)</span>
<span class="s1">WEEKDAYS = (MONDAY</span><span class="s2">, </span><span class="s1">TUESDAY</span><span class="s2">, </span><span class="s1">WEDNESDAY</span><span class="s2">, </span><span class="s1">THURSDAY</span><span class="s2">, </span><span class="s1">FRIDAY</span><span class="s2">, </span><span class="s1">SATURDAY</span><span class="s2">, </span><span class="s1">SUNDAY)</span>

<span class="s5"># default epoch: passed to np.datetime64...</span>
<span class="s1">_epoch = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_reset_epoch_test_example():</span>
    <span class="s0">&quot;&quot;&quot; 
    Reset the Matplotlib date epoch so it can be set again. 
 
    Only for use in tests and examples. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_epoch</span>
    <span class="s1">_epoch = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">set_epoch(epoch):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set the epoch (origin for dates) for datetime calculations. 
 
    The default epoch is :rc:`dates.epoch` (by default 1970-01-01T00:00). 
 
    If microsecond accuracy is desired, the date being plotted needs to be 
    within approximately 70 years of the epoch. Matplotlib internally 
    represents dates as days since the epoch, so floating point dynamic 
    range needs to be within a factor of 2^52. 
 
    `~.dates.set_epoch` must be called before any dates are converted 
    (i.e. near the import section) or a RuntimeError will be raised. 
 
    See also :doc:`/gallery/ticks/date_precision_and_epochs`. 
 
    Parameters 
    ---------- 
    epoch : str 
        valid UTC date parsable by `numpy.datetime64` (do not include 
        timezone). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_epoch</span>
    <span class="s2">if </span><span class="s1">_epoch </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">'set_epoch must be called before dates plotted.'</span><span class="s1">)</span>
    <span class="s1">_epoch = epoch</span>


<span class="s2">def </span><span class="s1">get_epoch():</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the epoch used by `.dates`. 
 
    Returns 
    ------- 
    epoch : str 
        String for the epoch (parsable by `numpy.datetime64`). 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_epoch</span>

    <span class="s2">if </span><span class="s1">_epoch </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">_epoch = mpl.rcParams[</span><span class="s3">'date.epoch'</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">_epoch</span>


<span class="s2">def </span><span class="s1">_dt64_to_ordinalf(d):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert `numpy.datetime64` or an `numpy.ndarray` of those types to 
    Gregorian date as UTC float relative to the epoch (see `.get_epoch`). 
    Roundoff is float64 precision.  Practically: microseconds for dates 
    between 290301 BC, 294241 AD, milliseconds for larger dates 
    (see `numpy.datetime64`). 
    &quot;&quot;&quot;</span>

    <span class="s5"># the &quot;extra&quot; ensures that we at least allow the dynamic range out to</span>
    <span class="s5"># seconds.  That should get out to +/-2e11 years.</span>
    <span class="s1">dseconds = d.astype(</span><span class="s3">'datetime64[s]'</span><span class="s1">)</span>
    <span class="s1">extra = (d - dseconds).astype(</span><span class="s3">'timedelta64[ns]'</span><span class="s1">)</span>
    <span class="s1">t0 = np.datetime64(get_epoch()</span><span class="s2">, </span><span class="s3">'s'</span><span class="s1">)</span>
    <span class="s1">dt = (dseconds - t0).astype(np.float64)</span>
    <span class="s1">dt += extra.astype(np.float64) / </span><span class="s4">1.0e9</span>
    <span class="s1">dt = dt / SEC_PER_DAY</span>

    <span class="s1">NaT_int = np.datetime64(</span><span class="s3">'NaT'</span><span class="s1">).astype(np.int64)</span>
    <span class="s1">d_int = d.astype(np.int64)</span>
    <span class="s1">dt[d_int == NaT_int] = np.nan</span>
    <span class="s2">return </span><span class="s1">dt</span>


<span class="s2">def </span><span class="s1">_from_ordinalf(x</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert Gregorian float of the date, preserving hours, minutes, 
    seconds and microseconds.  Return value is a `.datetime`. 
 
    The input date *x* is a float in ordinal days at UTC, and the output will 
    be the specified `.datetime` object corresponding to that time in 
    timezone *tz*, or if *tz* is ``None``, in the timezone specified in 
    :rc:`timezone`. 
    &quot;&quot;&quot;</span>

    <span class="s1">tz = _get_tzinfo(tz)</span>

    <span class="s1">dt = (np.datetime64(get_epoch()) +</span>
          <span class="s1">np.timedelta64(int(np.round(x * MUSECONDS_PER_DAY))</span><span class="s2">, </span><span class="s3">'us'</span><span class="s1">))</span>
    <span class="s2">if </span><span class="s1">dt &lt; np.datetime64(</span><span class="s3">'0001-01-01'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">dt &gt;= np.datetime64(</span><span class="s3">'10000-01-01'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Date ordinal </span><span class="s2">{</span><span class="s1">x</span><span class="s2">} </span><span class="s3">converts to </span><span class="s2">{</span><span class="s1">dt</span><span class="s2">} </span><span class="s3">(using '</span>
                         <span class="s3">f'epoch </span><span class="s2">{</span><span class="s1">get_epoch()</span><span class="s2">}</span><span class="s3">), but Matplotlib dates must be '</span>
                          <span class="s3">'between year 0001 and 9999.'</span><span class="s1">)</span>
    <span class="s5"># convert from datetime64 to datetime:</span>
    <span class="s1">dt = dt.tolist()</span>

    <span class="s5"># datetime64 is always UTC:</span>
    <span class="s1">dt = dt.replace(tzinfo=dateutil.tz.gettz(</span><span class="s3">'UTC'</span><span class="s1">))</span>
    <span class="s5"># but maybe we are working in a different timezone so move.</span>
    <span class="s1">dt = dt.astimezone(tz)</span>
    <span class="s5"># fix round off errors</span>
    <span class="s2">if </span><span class="s1">np.abs(x) &gt; </span><span class="s4">70 </span><span class="s1">* </span><span class="s4">365</span><span class="s1">:</span>
        <span class="s5"># if x is big, round off to nearest twenty microseconds.</span>
        <span class="s5"># This avoids floating point roundoff error</span>
        <span class="s1">ms = round(dt.microsecond / </span><span class="s4">20</span><span class="s1">) * </span><span class="s4">20</span>
        <span class="s2">if </span><span class="s1">ms == </span><span class="s4">1000000</span><span class="s1">:</span>
            <span class="s1">dt = dt.replace(microsecond=</span><span class="s4">0</span><span class="s1">) + datetime.timedelta(seconds=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dt = dt.replace(microsecond=ms)</span>

    <span class="s2">return </span><span class="s1">dt</span>


<span class="s5"># a version of _from_ordinalf that can operate on numpy arrays</span>
<span class="s1">_from_ordinalf_np_vectorized = np.vectorize(_from_ordinalf</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>


<span class="s5"># a version of dateutil.parser.parse that can operate on numpy arrays</span>
<span class="s1">_dateutil_parser_parse_np_vectorized = np.vectorize(dateutil.parser.parse)</span>


<span class="s2">def </span><span class="s1">datestr2num(d</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a date string to a datenum using `dateutil.parser.parse`. 
 
    Parameters 
    ---------- 
    d : str or sequence of str 
        The dates to convert. 
 
    default : datetime.datetime, optional 
        The default date to use when fields are missing in *d*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(d</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">dt = dateutil.parser.parse(d</span><span class="s2">, </span><span class="s1">default=default)</span>
        <span class="s2">return </span><span class="s1">date2num(dt)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">d = [date2num(dateutil.parser.parse(s</span><span class="s2">, </span><span class="s1">default=default))</span>
                 <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">d]</span>
            <span class="s2">return </span><span class="s1">np.asarray(d)</span>
        <span class="s1">d = np.asarray(d)</span>
        <span class="s2">if not </span><span class="s1">d.size:</span>
            <span class="s2">return </span><span class="s1">d</span>
        <span class="s2">return </span><span class="s1">date2num(_dateutil_parser_parse_np_vectorized(d))</span>


<span class="s2">def </span><span class="s1">date2num(d):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert datetime objects to Matplotlib dates. 
 
    Parameters 
    ---------- 
    d : `datetime.datetime` or `numpy.datetime64` or sequences of these 
 
    Returns 
    ------- 
    float or sequence of floats 
        Number of days since the epoch.  See `.get_epoch` for the 
        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If 
        the epoch is &quot;1970-01-01T00:00:00&quot; (default) then noon Jan 1 1970 
        (&quot;1970-01-01T12:00:00&quot;) returns 0.5. 
 
    Notes 
    ----- 
    The Gregorian calendar is assumed; this is not universal practice. 
    For details see the module docstring. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Unpack in case of e.g. Pandas or xarray object</span>
    <span class="s1">d = cbook._unpack_to_numpy(d)</span>

    <span class="s5"># make an iterable, but save state to unpack later:</span>
    <span class="s1">iterable = np.iterable(d)</span>
    <span class="s2">if not </span><span class="s1">iterable:</span>
        <span class="s1">d = [d]</span>

    <span class="s1">masked = np.ma.is_masked(d)</span>
    <span class="s1">mask = np.ma.getmask(d)</span>
    <span class="s1">d = np.asarray(d)</span>

    <span class="s5"># convert to datetime64 arrays, if not already:</span>
    <span class="s2">if not </span><span class="s1">np.issubdtype(d.dtype</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
        <span class="s5"># datetime arrays</span>
        <span class="s2">if not </span><span class="s1">d.size:</span>
            <span class="s5"># deals with an empty array...</span>
            <span class="s2">return </span><span class="s1">d</span>
        <span class="s1">tzi = getattr(d[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'tzinfo'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">tzi </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># make datetime naive:</span>
            <span class="s1">d = [dt.astimezone(UTC).replace(tzinfo=</span><span class="s2">None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">d]</span>
            <span class="s1">d = np.asarray(d)</span>
        <span class="s1">d = d.astype(</span><span class="s3">'datetime64[us]'</span><span class="s1">)</span>

    <span class="s1">d = np.ma.masked_array(d</span><span class="s2">, </span><span class="s1">mask=mask) </span><span class="s2">if </span><span class="s1">masked </span><span class="s2">else </span><span class="s1">d</span>
    <span class="s1">d = _dt64_to_ordinalf(d)</span>

    <span class="s2">return </span><span class="s1">d </span><span class="s2">if </span><span class="s1">iterable </span><span class="s2">else </span><span class="s1">d[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">julian2num(j):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Julian date (or sequence) to a Matplotlib date (or sequence). 
 
    Parameters 
    ---------- 
    j : float or sequence of floats 
        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian 
        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar). 
 
    Returns 
    ------- 
    float or sequence of floats 
        Matplotlib dates (days relative to `.get_epoch`). 
    &quot;&quot;&quot;</span>
    <span class="s1">ep = np.datetime64(get_epoch()</span><span class="s2">, </span><span class="s3">'h'</span><span class="s1">).astype(float) / </span><span class="s4">24.</span>
    <span class="s1">ep0 = np.datetime64(</span><span class="s3">'0000-12-31T00:00:00'</span><span class="s2">, </span><span class="s3">'h'</span><span class="s1">).astype(float) / </span><span class="s4">24.</span>
    <span class="s5"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="s5"># relative to our current epoch:</span>
    <span class="s1">dt = __getattr__(</span><span class="s3">&quot;JULIAN_OFFSET&quot;</span><span class="s1">) - ep0 + ep</span>
    <span class="s2">return </span><span class="s1">np.subtract(j</span><span class="s2">, </span><span class="s1">dt)  </span><span class="s5"># Handles both scalar &amp; nonscalar j.</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">num2julian(n):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Matplotlib date (or sequence) to a Julian date (or sequence). 
 
    Parameters 
    ---------- 
    n : float or sequence of floats 
        Matplotlib dates (days relative to `.get_epoch`). 
 
    Returns 
    ------- 
    float or sequence of floats 
        Julian dates (days relative to 4713 BC Jan 1, 12:00:00). 
    &quot;&quot;&quot;</span>
    <span class="s1">ep = np.datetime64(get_epoch()</span><span class="s2">, </span><span class="s3">'h'</span><span class="s1">).astype(float) / </span><span class="s4">24.</span>
    <span class="s1">ep0 = np.datetime64(</span><span class="s3">'0000-12-31T00:00:00'</span><span class="s2">, </span><span class="s3">'h'</span><span class="s1">).astype(float) / </span><span class="s4">24.</span>
    <span class="s5"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="s5"># relative to our current epoch:</span>
    <span class="s1">dt = __getattr__(</span><span class="s3">&quot;JULIAN_OFFSET&quot;</span><span class="s1">) - ep0 + ep</span>
    <span class="s2">return </span><span class="s1">np.add(n</span><span class="s2">, </span><span class="s1">dt)  </span><span class="s5"># Handles both scalar &amp; nonscalar j.</span>


<span class="s2">def </span><span class="s1">num2date(x</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert Matplotlib dates to `~datetime.datetime` objects. 
 
    Parameters 
    ---------- 
    x : float or sequence of floats 
        Number of days (fraction part represents hours, minutes, seconds) 
        since the epoch.  See `.get_epoch` for the 
        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`. 
    tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
        Timezone of *x*. If a string, *tz* is passed to `dateutil.tz`. 
 
    Returns 
    ------- 
    `~datetime.datetime` or sequence of `~datetime.datetime` 
        Dates are returned in timezone *tz*. 
 
        If *x* is a sequence, a sequence of `~datetime.datetime` objects will 
        be returned. 
 
    Notes 
    ----- 
    The Gregorian calendar is assumed; this is not universal practice. 
    For details, see the module docstring. 
    &quot;&quot;&quot;</span>
    <span class="s1">tz = _get_tzinfo(tz)</span>
    <span class="s2">return </span><span class="s1">_from_ordinalf_np_vectorized(x</span><span class="s2">, </span><span class="s1">tz).tolist()</span>


<span class="s1">_ordinalf_to_timedelta_np_vectorized = np.vectorize(</span>
    <span class="s2">lambda </span><span class="s1">x: datetime.timedelta(days=x)</span><span class="s2">, </span><span class="s1">otypes=</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">num2timedelta(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert number of days to a `~datetime.timedelta` object. 
 
    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will 
    be returned. 
 
    Parameters 
    ---------- 
    x : float, sequence of floats 
        Number of days. The fraction part represents hours, minutes, seconds. 
 
    Returns 
    ------- 
    `datetime.timedelta` or list[`datetime.timedelta`] 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_ordinalf_to_timedelta_np_vectorized(x).tolist()</span>


<span class="s2">def </span><span class="s1">drange(dstart</span><span class="s2">, </span><span class="s1">dend</span><span class="s2">, </span><span class="s1">delta):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a sequence of equally spaced Matplotlib dates. 
 
    The dates start at *dstart* and reach up to, but not including *dend*. 
    They are spaced by *delta*. 
 
    Parameters 
    ---------- 
    dstart, dend : `~datetime.datetime` 
        The date limits. 
    delta : `datetime.timedelta` 
        Spacing of the dates. 
 
    Returns 
    ------- 
    `numpy.array` 
        A list floats representing Matplotlib dates. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">f1 = date2num(dstart)</span>
    <span class="s1">f2 = date2num(dend)</span>
    <span class="s1">step = delta.total_seconds() / SEC_PER_DAY</span>

    <span class="s5"># calculate the difference between dend and dstart in times of delta</span>
    <span class="s1">num = int(np.ceil((f2 - f1) / step))</span>

    <span class="s5"># calculate end of the interval which will be generated</span>
    <span class="s1">dinterval_end = dstart + num * delta</span>

    <span class="s5"># ensure, that an half open interval will be generated [dstart, dend)</span>
    <span class="s2">if </span><span class="s1">dinterval_end &gt;= dend:</span>
        <span class="s5"># if the endpoint is greater than or equal to dend,</span>
        <span class="s5"># just subtract one delta</span>
        <span class="s1">dinterval_end -= delta</span>
        <span class="s1">num -= </span><span class="s4">1</span>

    <span class="s1">f2 = date2num(dinterval_end)  </span><span class="s5"># new float-endpoint</span>
    <span class="s2">return </span><span class="s1">np.linspace(f1</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">num + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_wrap_in_tex(text):</span>
    <span class="s1">p = </span><span class="s3">r'([a-zA-Z]+)'</span>
    <span class="s1">ret_text = re.sub(p</span><span class="s2">, </span><span class="s3">r'}$\1$\\mathdefault{'</span><span class="s2">, </span><span class="s1">text)</span>

    <span class="s5"># Braces ensure symbols are not spaced like binary operators.</span>
    <span class="s1">ret_text = ret_text.replace(</span><span class="s3">'-'</span><span class="s2">, </span><span class="s3">'{-}'</span><span class="s1">).replace(</span><span class="s3">':'</span><span class="s2">, </span><span class="s3">'{:}'</span><span class="s1">)</span>
    <span class="s5"># To not concatenate space between numbers.</span>
    <span class="s1">ret_text = ret_text.replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">r'\;'</span><span class="s1">)</span>
    <span class="s1">ret_text = </span><span class="s3">'$</span><span class="s2">\\</span><span class="s3">mathdefault{' </span><span class="s1">+ ret_text + </span><span class="s3">'}$'</span>
    <span class="s1">ret_text = ret_text.replace(</span><span class="s3">'$</span><span class="s2">\\</span><span class="s3">mathdefault{}$'</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">ret_text</span>


<span class="s5">## date tickers and formatters ###</span>


<span class="s2">class </span><span class="s1">DateFormatter(ticker.Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format a tick (in days since the epoch) with a 
    `~datetime.datetime.strftime` format string. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">usetex=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        fmt : str 
            `~datetime.datetime.strftime` format string 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        usetex : bool, default: :rc:`text.usetex` 
            To enable/disable the use of TeX's math mode for rendering the 
            results of the formatter. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.tz = _get_tzinfo(tz)</span>
        <span class="s1">self.fmt = fmt</span>
        <span class="s1">self._usetex = (usetex </span><span class="s2">if </span><span class="s1">usetex </span><span class="s2">is not None else</span>
                        <span class="s1">mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s1">result = num2date(x</span><span class="s2">, </span><span class="s1">self.tz).strftime(self.fmt)</span>
        <span class="s2">return </span><span class="s1">_wrap_in_tex(result) </span><span class="s2">if </span><span class="s1">self._usetex </span><span class="s2">else </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">set_tzinfo(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s1">self.tz = _get_tzinfo(tz)</span>


<span class="s2">class </span><span class="s1">ConciseDateFormatter(ticker.Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `.Formatter` which attempts to figure out the best format to use for the 
    date, and to make it as compact as possible, but still be complete. This is 
    most useful when used with the `AutoDateLocator`:: 
 
    &gt;&gt;&gt; locator = AutoDateLocator() 
    &gt;&gt;&gt; formatter = ConciseDateFormatter(locator) 
 
    Parameters 
    ---------- 
    locator : `.ticker.Locator` 
        Locator that this axis is using. 
 
    tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
        Ticks timezone, passed to `.dates.num2date`. 
 
    formats : list of 6 strings, optional 
        Format strings for 6 levels of tick labelling: mostly years, 
        months, days, hours, minutes, and seconds.  Strings use 
        the same format codes as `~datetime.datetime.strftime`.  Default is 
        ``['%Y', '%b', '%d', '%H:%M', '%H:%M', '%S.%f']`` 
 
    zero_formats : list of 6 strings, optional 
        Format strings for tick labels that are &quot;zeros&quot; for a given tick 
        level.  For instance, if most ticks are months, ticks around 1 Jan 2005 
        will be labeled &quot;Dec&quot;, &quot;2005&quot;, &quot;Feb&quot;.  The default is 
        ``['', '%Y', '%b', '%b-%d', '%H:%M', '%H:%M']`` 
 
    offset_formats : list of 6 strings, optional 
        Format strings for the 6 levels that is applied to the &quot;offset&quot; 
        string found on the right side of an x-axis, or top of a y-axis. 
        Combined with the tick labels this should completely specify the 
        date.  The default is:: 
 
            ['', '%Y', '%Y-%b', '%Y-%b-%d', '%Y-%b-%d', '%Y-%b-%d %H:%M'] 
 
    show_offset : bool, default: True 
        Whether to show the offset or not. 
 
    usetex : bool, default: :rc:`text.usetex` 
        To enable/disable the use of TeX's math mode for rendering the results 
        of the formatter. 
 
    Examples 
    -------- 
    See :doc:`/gallery/ticks/date_concise_formatter` 
 
    .. plot:: 
 
        import datetime 
        import matplotlib.dates as mdates 
 
        base = datetime.datetime(2005, 2, 1) 
        dates = np.array([base + datetime.timedelta(hours=(2 * i)) 
                          for i in range(732)]) 
        N = len(dates) 
        np.random.seed(19680801) 
        y = np.cumsum(np.random.randn(N)) 
 
        fig, ax = plt.subplots(constrained_layout=True) 
        locator = mdates.AutoDateLocator() 
        formatter = mdates.ConciseDateFormatter(locator) 
        ax.xaxis.set_major_locator(locator) 
        ax.xaxis.set_major_formatter(formatter) 
 
        ax.plot(dates, y) 
        ax.set_title('Concise Date Formatter') 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">locator</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None, </span><span class="s1">formats=</span><span class="s2">None, </span><span class="s1">offset_formats=</span><span class="s2">None,</span>
                 <span class="s1">zero_formats=</span><span class="s2">None, </span><span class="s1">show_offset=</span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">usetex=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Autoformat the date labels.  The default format is used to form an 
        initial string, and then redundant elements are removed. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._locator = locator</span>
        <span class="s1">self._tz = tz</span>
        <span class="s1">self.defaultfmt = </span><span class="s3">'%Y'</span>
        <span class="s5"># there are 6 levels with each level getting a specific format</span>
        <span class="s5"># 0: mostly years,  1: months,  2: days,</span>
        <span class="s5"># 3: hours, 4: minutes, 5: seconds</span>
        <span class="s2">if </span><span class="s1">formats:</span>
            <span class="s2">if </span><span class="s1">len(formats) != </span><span class="s4">6</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'formats argument must be a list of '</span>
                                 <span class="s3">'6 format strings (or None)'</span><span class="s1">)</span>
            <span class="s1">self.formats = formats</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.formats = [</span><span class="s3">'%Y'</span><span class="s2">,  </span><span class="s5"># ticks are mostly years</span>
                            <span class="s3">'%b'</span><span class="s2">,          </span><span class="s5"># ticks are mostly months</span>
                            <span class="s3">'%d'</span><span class="s2">,          </span><span class="s5"># ticks are mostly days</span>
                            <span class="s3">'%H:%M'</span><span class="s2">,       </span><span class="s5"># hrs</span>
                            <span class="s3">'%H:%M'</span><span class="s2">,       </span><span class="s5"># min</span>
                            <span class="s3">'%S.%f'</span><span class="s2">,       </span><span class="s5"># secs</span>
                            <span class="s1">]</span>
        <span class="s5"># fmt for zeros ticks at this level.  These are</span>
        <span class="s5"># ticks that should be labeled w/ info the level above.</span>
        <span class="s5"># like 1 Jan can just be labelled &quot;Jan&quot;.  02:02:00 can</span>
        <span class="s5"># just be labeled 02:02.</span>
        <span class="s2">if </span><span class="s1">zero_formats:</span>
            <span class="s2">if </span><span class="s1">len(zero_formats) != </span><span class="s4">6</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'zero_formats argument must be a list of '</span>
                                 <span class="s3">'6 format strings (or None)'</span><span class="s1">)</span>
            <span class="s1">self.zero_formats = zero_formats</span>
        <span class="s2">elif </span><span class="s1">formats:</span>
            <span class="s5"># use the users formats for the zero tick formats</span>
            <span class="s1">self.zero_formats = [</span><span class="s3">''</span><span class="s1">] + self.formats[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># make the defaults a bit nicer:</span>
            <span class="s1">self.zero_formats = [</span><span class="s3">''</span><span class="s1">] + self.formats[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">self.zero_formats[</span><span class="s4">3</span><span class="s1">] = </span><span class="s3">'%b-%d'</span>

        <span class="s2">if </span><span class="s1">offset_formats:</span>
            <span class="s2">if </span><span class="s1">len(offset_formats) != </span><span class="s4">6</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'offset_formats argument must be a list of '</span>
                                 <span class="s3">'6 format strings (or None)'</span><span class="s1">)</span>
            <span class="s1">self.offset_formats = offset_formats</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.offset_formats = [</span><span class="s3">''</span><span class="s2">,</span>
                                   <span class="s3">'%Y'</span><span class="s2">,</span>
                                   <span class="s3">'%Y-%b'</span><span class="s2">,</span>
                                   <span class="s3">'%Y-%b-%d'</span><span class="s2">,</span>
                                   <span class="s3">'%Y-%b-%d'</span><span class="s2">,</span>
                                   <span class="s3">'%Y-%b-%d %H:%M'</span><span class="s1">]</span>
        <span class="s1">self.offset_string = </span><span class="s3">''</span>
        <span class="s1">self.show_offset = show_offset</span>
        <span class="s1">self._usetex = (usetex </span><span class="s2">if </span><span class="s1">usetex </span><span class="s2">is not None else</span>
                        <span class="s1">mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">formatter = DateFormatter(self.defaultfmt</span><span class="s2">, </span><span class="s1">self._tz</span><span class="s2">,</span>
                                  <span class="s1">usetex=self._usetex)</span>
        <span class="s2">return </span><span class="s1">formatter(x</span><span class="s2">, </span><span class="s1">pos=pos)</span>

    <span class="s2">def </span><span class="s1">format_ticks(self</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s1">tickdatetime = [num2date(value</span><span class="s2">, </span><span class="s1">tz=self._tz) </span><span class="s2">for </span><span class="s1">value </span><span class="s2">in </span><span class="s1">values]</span>
        <span class="s1">tickdate = np.array([tdt.timetuple()[:</span><span class="s4">6</span><span class="s1">] </span><span class="s2">for </span><span class="s1">tdt </span><span class="s2">in </span><span class="s1">tickdatetime])</span>

        <span class="s5"># basic algorithm:</span>
        <span class="s5"># 1) only display a part of the date if it changes over the ticks.</span>
        <span class="s5"># 2) don't display the smaller part of the date if:</span>
        <span class="s5">#    it is always the same or if it is the start of the</span>
        <span class="s5">#    year, month, day etc.</span>
        <span class="s5"># fmt for most ticks at this level</span>
        <span class="s1">fmts = self.formats</span>
        <span class="s5"># format beginnings of days, months, years, etc.</span>
        <span class="s1">zerofmts = self.zero_formats</span>
        <span class="s5"># offset fmt are for the offset in the upper left of the</span>
        <span class="s5"># or lower right of the axis.</span>
        <span class="s1">offsetfmts = self.offset_formats</span>
        <span class="s1">show_offset = self.show_offset</span>

        <span class="s5"># determine the level we will label at:</span>
        <span class="s5"># mostly 0: years,  1: months,  2: days,</span>
        <span class="s5"># 3: hours, 4: minutes, 5: seconds, 6: microseconds</span>
        <span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">unique = np.unique(tickdate[:</span><span class="s2">, </span><span class="s1">level])</span>
            <span class="s2">if </span><span class="s1">len(unique) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s5"># if 1 is included in unique, the year is shown in ticks</span>
                <span class="s2">if </span><span class="s1">level &lt; </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">np.any(unique == </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s1">show_offset = </span><span class="s2">False</span>
                <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">level == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s5"># all tickdate are the same, so only micros might be different</span>
                <span class="s5"># set to the most precise (6: microseconds doesn't exist...)</span>
                <span class="s1">level = </span><span class="s4">5</span>

        <span class="s5"># level is the basic level we will label at.</span>
        <span class="s5"># now loop through and decide the actual ticklabels</span>
        <span class="s1">zerovals = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">labels = [</span><span class="s3">''</span><span class="s1">] * len(tickdate)</span>
        <span class="s2">for </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">range(len(tickdate)):</span>
            <span class="s2">if </span><span class="s1">level &lt; </span><span class="s4">5</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">tickdate[nn][level] == zerovals[level]:</span>
                    <span class="s1">fmt = zerofmts[level]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fmt = fmts[level]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># special handling for seconds + microseconds</span>
                <span class="s2">if </span><span class="s1">(tickdatetime[nn].second == tickdatetime[nn].microsecond</span>
                        <span class="s1">== </span><span class="s4">0</span><span class="s1">):</span>
                    <span class="s1">fmt = zerofmts[level]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fmt = fmts[level]</span>
            <span class="s1">labels[nn] = tickdatetime[nn].strftime(fmt)</span>

        <span class="s5"># special handling of seconds and microseconds:</span>
        <span class="s5"># strip extra zeros and decimal if possible.</span>
        <span class="s5"># this is complicated by two factors.  1) we have some level-4 strings</span>
        <span class="s5"># here (i.e. 03:00, '0.50000', '1.000') 2) we would like to have the</span>
        <span class="s5"># same number of decimals for each string (i.e. 0.5 and 1.0).</span>
        <span class="s2">if </span><span class="s1">level &gt;= </span><span class="s4">5</span><span class="s1">:</span>
            <span class="s1">trailing_zeros = min(</span>
                <span class="s1">(len(s) - len(s.rstrip(</span><span class="s3">'0'</span><span class="s1">)) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">labels </span><span class="s2">if </span><span class="s3">'.' </span><span class="s2">in </span><span class="s1">s)</span><span class="s2">,</span>
                <span class="s1">default=</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">trailing_zeros:</span>
                <span class="s2">for </span><span class="s1">nn </span><span class="s2">in </span><span class="s1">range(len(labels)):</span>
                    <span class="s2">if </span><span class="s3">'.' </span><span class="s2">in </span><span class="s1">labels[nn]:</span>
                        <span class="s1">labels[nn] = labels[nn][:-trailing_zeros].rstrip(</span><span class="s3">'.'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">show_offset:</span>
            <span class="s5"># set the offset string:</span>
            <span class="s1">self.offset_string = tickdatetime[-</span><span class="s4">1</span><span class="s1">].strftime(offsetfmts[level])</span>
            <span class="s2">if </span><span class="s1">self._usetex:</span>
                <span class="s1">self.offset_string = _wrap_in_tex(self.offset_string)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.offset_string = </span><span class="s3">''</span>

        <span class="s2">if </span><span class="s1">self._usetex:</span>
            <span class="s2">return </span><span class="s1">[_wrap_in_tex(l) </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">labels]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">labels</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s2">return </span><span class="s1">self.offset_string</span>

    <span class="s2">def </span><span class="s1">format_data_short(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">return </span><span class="s1">num2date(value</span><span class="s2">, </span><span class="s1">tz=self._tz).strftime(</span><span class="s3">'%Y-%m-%d %H:%M:%S'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">AutoDateFormatter(ticker.Formatter):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `.Formatter` which attempts to figure out the best format to use.  This 
    is most useful when used with the `AutoDateLocator`. 
 
    `.AutoDateFormatter` has a ``.scale`` dictionary that maps tick scales (the 
    interval in days between one major tick) to format strings; this dictionary 
    defaults to :: 
 
        self.scaled = { 
            DAYS_PER_YEAR: rcParams['date.autoformatter.year'], 
            DAYS_PER_MONTH: rcParams['date.autoformatter.month'], 
            1: rcParams['date.autoformatter.day'], 
            1 / HOURS_PER_DAY: rcParams['date.autoformatter.hour'], 
            1 / MINUTES_PER_DAY: rcParams['date.autoformatter.minute'], 
            1 / SEC_PER_DAY: rcParams['date.autoformatter.second'], 
            1 / MUSECONDS_PER_DAY: rcParams['date.autoformatter.microsecond'], 
        } 
 
    The formatter uses the format string corresponding to the lowest key in 
    the dictionary that is greater or equal to the current scale.  Dictionary 
    entries can be customized:: 
 
        locator = AutoDateLocator() 
        formatter = AutoDateFormatter(locator) 
        formatter.scaled[1/(24*60)] = '%M:%S' # only show min and sec 
 
    Custom callables can also be used instead of format strings.  The following 
    example shows how to use a custom format function to strip trailing zeros 
    from decimal seconds and adds the date to the first ticklabel:: 
 
        def my_format_function(x, pos=None): 
            x = matplotlib.dates.num2date(x) 
            if pos == 0: 
                fmt = '%D %H:%M:%S.%f' 
            else: 
                fmt = '%H:%M:%S.%f' 
            label = x.strftime(fmt) 
            label = label.rstrip(&quot;0&quot;) 
            label = label.rstrip(&quot;.&quot;) 
            return label 
 
        formatter.scaled[1/(24*60)] = my_format_function 
    &quot;&quot;&quot;</span>

    <span class="s5"># This can be improved by providing some user-level direction on</span>
    <span class="s5"># how to choose the best format (precedence, etc.).</span>

    <span class="s5"># Perhaps a 'struct' that has a field for each time-type where a</span>
    <span class="s5"># zero would indicate &quot;don't show&quot; and a number would indicate</span>
    <span class="s5"># &quot;show&quot; with some sort of priority.  Same priorities could mean</span>
    <span class="s5"># show all with the same priority.</span>

    <span class="s5"># Or more simply, perhaps just a format string for each</span>
    <span class="s5"># possibility...</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">locator</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None, </span><span class="s1">defaultfmt=</span><span class="s3">'%Y-%m-%d'</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">usetex=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Autoformat the date labels. 
 
        Parameters 
        ---------- 
        locator : `.ticker.Locator` 
            Locator that this axis is using. 
 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
 
        defaultfmt : str 
            The default format to use if none of the values in ``self.scaled`` 
            are greater than the unit returned by ``locator._get_unit()``. 
 
        usetex : bool, default: :rc:`text.usetex` 
            To enable/disable the use of TeX's math mode for rendering the 
            results of the formatter. If any entries in ``self.scaled`` are set 
            as functions, then it is up to the customized function to enable or 
            disable TeX's math mode itself. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._locator = locator</span>
        <span class="s1">self._tz = tz</span>
        <span class="s1">self.defaultfmt = defaultfmt</span>
        <span class="s1">self._formatter = DateFormatter(self.defaultfmt</span><span class="s2">, </span><span class="s1">tz)</span>
        <span class="s1">rcParams = mpl.rcParams</span>
        <span class="s1">self._usetex = (usetex </span><span class="s2">if </span><span class="s1">usetex </span><span class="s2">is not None else</span>
                        <span class="s1">mpl.rcParams[</span><span class="s3">'text.usetex'</span><span class="s1">])</span>
        <span class="s1">self.scaled = {</span>
            <span class="s1">DAYS_PER_YEAR: rcParams[</span><span class="s3">'date.autoformatter.year'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">DAYS_PER_MONTH: rcParams[</span><span class="s3">'date.autoformatter.month'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">1</span><span class="s1">: rcParams[</span><span class="s3">'date.autoformatter.day'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">1 </span><span class="s1">/ HOURS_PER_DAY: rcParams[</span><span class="s3">'date.autoformatter.hour'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">1 </span><span class="s1">/ MINUTES_PER_DAY: rcParams[</span><span class="s3">'date.autoformatter.minute'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">1 </span><span class="s1">/ SEC_PER_DAY: rcParams[</span><span class="s3">'date.autoformatter.second'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">1 </span><span class="s1">/ MUSECONDS_PER_DAY: rcParams[</span><span class="s3">'date.autoformatter.microsecond'</span><span class="s1">]</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_set_locator(self</span><span class="s2">, </span><span class="s1">locator):</span>
        <span class="s1">self._locator = locator</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">locator_unit_scale = float(self._locator._get_unit())</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">locator_unit_scale = </span><span class="s4">1</span>
        <span class="s5"># Pick the first scale which is greater than the locator unit.</span>
        <span class="s1">fmt = next((fmt </span><span class="s2">for </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">sorted(self.scaled.items())</span>
                    <span class="s2">if </span><span class="s1">scale &gt;= locator_unit_scale)</span><span class="s2">,</span>
                   <span class="s1">self.defaultfmt)</span>

        <span class="s2">if </span><span class="s1">isinstance(fmt</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self._formatter = DateFormatter(fmt</span><span class="s2">, </span><span class="s1">self._tz</span><span class="s2">, </span><span class="s1">usetex=self._usetex)</span>
            <span class="s1">result = self._formatter(x</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s2">elif </span><span class="s1">callable(fmt):</span>
            <span class="s1">result = fmt(x</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Unexpected type passed to {0!r}.'</span><span class="s1">.format(self))</span>

        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">rrulewrapper:</span>
    <span class="s0">&quot;&quot;&quot; 
    A simple wrapper around a `dateutil.rrule` allowing flexible 
    date tick specifications. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">tzinfo=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        freq : {YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, SECONDLY} 
            Tick frequency. These constants are defined in `dateutil.rrule`, 
            but they are accessible from `matplotlib.dates` as well. 
        tzinfo : `datetime.tzinfo`, optional 
            Time zone information. The default is None. 
        **kwargs 
            Additional keyword arguments are passed to the `dateutil.rrule`. 
        &quot;&quot;&quot;</span>
        <span class="s1">kwargs[</span><span class="s3">'freq'</span><span class="s1">] = freq</span>
        <span class="s1">self._base_tzinfo = tzinfo</span>

        <span class="s1">self._update_rrule(**kwargs)</span>

    <span class="s2">def </span><span class="s1">set(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Set parameters for an existing wrapper.&quot;&quot;&quot;</span>
        <span class="s1">self._construct.update(kwargs)</span>

        <span class="s1">self._update_rrule(**self._construct)</span>

    <span class="s2">def </span><span class="s1">_update_rrule(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">tzinfo = self._base_tzinfo</span>

        <span class="s5"># rrule does not play nicely with timezones - especially pytz time</span>
        <span class="s5"># zones, it's best to use naive zones and attach timezones once the</span>
        <span class="s5"># datetimes are returned</span>
        <span class="s2">if </span><span class="s3">'dtstart' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">dtstart = kwargs[</span><span class="s3">'dtstart'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">dtstart.tzinfo </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">tzinfo </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">tzinfo = dtstart.tzinfo</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">dtstart = dtstart.astimezone(tzinfo)</span>

                <span class="s1">kwargs[</span><span class="s3">'dtstart'</span><span class="s1">] = dtstart.replace(tzinfo=</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s3">'until' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">until = kwargs[</span><span class="s3">'until'</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">until.tzinfo </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">tzinfo </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">until = until.astimezone(tzinfo)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'until cannot be aware if dtstart '</span>
                                     <span class="s3">'is naive and tzinfo is None'</span><span class="s1">)</span>

                <span class="s1">kwargs[</span><span class="s3">'until'</span><span class="s1">] = until.replace(tzinfo=</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s1">self._construct = kwargs.copy()</span>
        <span class="s1">self._tzinfo = tzinfo</span>
        <span class="s1">self._rrule = rrule(**self._construct)</span>

    <span class="s2">def </span><span class="s1">_attach_tzinfo(self</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">tzinfo):</span>
        <span class="s5"># pytz zones are attached by &quot;localizing&quot; the datetime</span>
        <span class="s2">if </span><span class="s1">hasattr(tzinfo</span><span class="s2">, </span><span class="s3">'localize'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">tzinfo.localize(dt</span><span class="s2">, </span><span class="s1">is_dst=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">dt.replace(tzinfo=tzinfo)</span>

    <span class="s2">def </span><span class="s1">_aware_return_wrapper(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">returns_list=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Decorator function that allows rrule methods to handle tzinfo.&quot;&quot;&quot;</span>
        <span class="s5"># This is only necessary if we're actually attaching a tzinfo</span>
        <span class="s2">if </span><span class="s1">self._tzinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">f</span>

        <span class="s5"># All datetime arguments must be naive. If they are not naive, they are</span>
        <span class="s5"># converted to the _tzinfo zone before dropping the zone.</span>
        <span class="s2">def </span><span class="s1">normalize_arg(arg):</span>
            <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">datetime.datetime) </span><span class="s2">and </span><span class="s1">arg.tzinfo </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">arg.tzinfo </span><span class="s2">is not </span><span class="s1">self._tzinfo:</span>
                    <span class="s1">arg = arg.astimezone(self._tzinfo)</span>

                <span class="s2">return </span><span class="s1">arg.replace(tzinfo=</span><span class="s2">None</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">arg</span>

        <span class="s2">def </span><span class="s1">normalize_args(args</span><span class="s2">, </span><span class="s1">kwargs):</span>
            <span class="s1">args = tuple(normalize_arg(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args)</span>
            <span class="s1">kwargs = {kw: normalize_arg(arg) </span><span class="s2">for </span><span class="s1">kw</span><span class="s2">, </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">kwargs.items()}</span>

            <span class="s2">return </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span>

        <span class="s5"># There are two kinds of functions we care about - ones that return</span>
        <span class="s5"># dates and ones that return lists of dates.</span>
        <span class="s2">if not </span><span class="s1">returns_list:</span>
            <span class="s2">def </span><span class="s1">inner_func(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = normalize_args(args</span><span class="s2">, </span><span class="s1">kwargs)</span>
                <span class="s1">dt = f(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                <span class="s2">return </span><span class="s1">self._attach_tzinfo(dt</span><span class="s2">, </span><span class="s1">self._tzinfo)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">inner_func(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = normalize_args(args</span><span class="s2">, </span><span class="s1">kwargs)</span>
                <span class="s1">dts = f(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                <span class="s2">return </span><span class="s1">[self._attach_tzinfo(dt</span><span class="s2">, </span><span class="s1">self._tzinfo) </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">dts]</span>

        <span class="s2">return </span><span class="s1">functools.wraps(f)(inner_func)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.__dict__:</span>
            <span class="s2">return </span><span class="s1">self.__dict__[name]</span>

        <span class="s1">f = getattr(self._rrule</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'after'</span><span class="s2">, </span><span class="s3">'before'</span><span class="s1">}:</span>
            <span class="s2">return </span><span class="s1">self._aware_return_wrapper(f)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">{</span><span class="s3">'xafter'</span><span class="s2">, </span><span class="s3">'xbefore'</span><span class="s2">, </span><span class="s3">'between'</span><span class="s1">}:</span>
            <span class="s2">return </span><span class="s1">self._aware_return_wrapper(f</span><span class="s2">, </span><span class="s1">returns_list=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s1">self.__dict__.update(state)</span>


<span class="s2">class </span><span class="s1">DateLocator(ticker.Locator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determines the tick locations when plotting dates. 
 
    This class is subclassed by other Locators and 
    is not meant to be used on its own. 
    &quot;&quot;&quot;</span>
    <span class="s1">hms0d = {</span><span class="s3">'byhour'</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'byminute'</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'bysecond'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.tz = _get_tzinfo(tz)</span>

    <span class="s2">def </span><span class="s1">set_tzinfo(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set timezone info. 
 
        Parameters 
        ---------- 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.tz = _get_tzinfo(tz)</span>

    <span class="s2">def </span><span class="s1">datalim_to_dt(self):</span>
        <span class="s0">&quot;&quot;&quot;Convert axis data interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = self.axis.get_data_interval()</span>
        <span class="s2">if </span><span class="s1">dmin &gt; dmax:</span>
            <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = dmax</span><span class="s2">, </span><span class="s1">dmin</span>

        <span class="s2">return </span><span class="s1">num2date(dmin</span><span class="s2">, </span><span class="s1">self.tz)</span><span class="s2">, </span><span class="s1">num2date(dmax</span><span class="s2">, </span><span class="s1">self.tz)</span>

    <span class="s2">def </span><span class="s1">viewlim_to_dt(self):</span>
        <span class="s0">&quot;&quot;&quot;Convert the view interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.axis.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">vmin &gt; vmax:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s2">return </span><span class="s1">num2date(vmin</span><span class="s2">, </span><span class="s1">self.tz)</span><span class="s2">, </span><span class="s1">num2date(vmax</span><span class="s2">, </span><span class="s1">self.tz)</span>

    <span class="s2">def </span><span class="s1">_get_unit(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return how many days a unit of the locator is; used for 
        intelligent autoscaling. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">_get_interval(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of units for each tick. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">1</span>

    <span class="s2">def </span><span class="s1">nonsingular(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given the proposed upper and lower extent, adjust the range 
        if it is too close to being singular (i.e. a range of ~0). 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(vmin) </span><span class="s2">or not </span><span class="s1">np.isfinite(vmax):</span>
            <span class="s5"># Except if there is no data, then use 1970 as default.</span>
            <span class="s2">return </span><span class="s1">(date2num(datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">date2num(datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s1">unit = self._get_unit()</span>
        <span class="s1">interval = self._get_interval()</span>
        <span class="s2">if </span><span class="s1">abs(vmax - vmin) &lt; </span><span class="s4">1e-6</span><span class="s1">:</span>
            <span class="s1">vmin -= </span><span class="s4">2 </span><span class="s1">* unit * interval</span>
            <span class="s1">vmax += </span><span class="s4">2 </span><span class="s1">* unit * interval</span>
        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>


<span class="s2">class </span><span class="s1">RRuleLocator(DateLocator):</span>
    <span class="s5"># use the dateutil rrule instance</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(tz)</span>
        <span class="s1">self.rule = o</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s5"># if no data have been set, this will tank with a ValueError</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = self.viewlim_to_dt()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s2">return </span><span class="s1">self.tick_values(dmin</span><span class="s2">, </span><span class="s1">dmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop = self._create_rrule(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
        <span class="s1">dates = self.rule.between(start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(dates) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">date2num([vmin</span><span class="s2">, </span><span class="s1">vmax])</span>
        <span class="s2">return </span><span class="s1">self.raise_if_exceeds(date2num(dates))</span>

    <span class="s2">def </span><span class="s1">_create_rrule(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s5"># set appropriate rrule dtstart and until and return</span>
        <span class="s5"># start and end</span>
        <span class="s1">delta = relativedelta(vmax</span><span class="s2">, </span><span class="s1">vmin)</span>

        <span class="s5"># We need to cap at the endpoints of valid datetime</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">start = vmin - delta</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s5"># cap</span>
            <span class="s1">start = datetime.datetime(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
                                      <span class="s1">tzinfo=datetime.timezone.utc)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">stop = vmax + delta</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
            <span class="s5"># cap</span>
            <span class="s1">stop = datetime.datetime(</span><span class="s4">9999</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">31</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">59</span><span class="s2">, </span><span class="s4">59</span><span class="s2">,</span>
                                     <span class="s1">tzinfo=datetime.timezone.utc)</span>

        <span class="s1">self.rule.set(dtstart=start</span><span class="s2">, </span><span class="s1">until=stop)</span>

        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>

    <span class="s2">def </span><span class="s1">_get_unit(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">freq = self.rule._rrule._freq</span>
        <span class="s2">return </span><span class="s1">self.get_unit_generic(freq)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">get_unit_generic(freq):</span>
        <span class="s2">if </span><span class="s1">freq == YEARLY:</span>
            <span class="s2">return </span><span class="s1">DAYS_PER_YEAR</span>
        <span class="s2">elif </span><span class="s1">freq == MONTHLY:</span>
            <span class="s2">return </span><span class="s1">DAYS_PER_MONTH</span>
        <span class="s2">elif </span><span class="s1">freq == WEEKLY:</span>
            <span class="s2">return </span><span class="s1">DAYS_PER_WEEK</span>
        <span class="s2">elif </span><span class="s1">freq == DAILY:</span>
            <span class="s2">return </span><span class="s4">1.0</span>
        <span class="s2">elif </span><span class="s1">freq == HOURLY:</span>
            <span class="s2">return </span><span class="s4">1.0 </span><span class="s1">/ HOURS_PER_DAY</span>
        <span class="s2">elif </span><span class="s1">freq == MINUTELY:</span>
            <span class="s2">return </span><span class="s4">1.0 </span><span class="s1">/ MINUTES_PER_DAY</span>
        <span class="s2">elif </span><span class="s1">freq == SECONDLY:</span>
            <span class="s2">return </span><span class="s4">1.0 </span><span class="s1">/ SEC_PER_DAY</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># error</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s4">1  </span><span class="s5"># or should this just return '1'?</span>

    <span class="s2">def </span><span class="s1">_get_interval(self):</span>
        <span class="s2">return </span><span class="s1">self.rule._rrule._interval</span>


<span class="s2">class </span><span class="s1">AutoDateLocator(DateLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    On autoscale, this class picks the best `DateLocator` to set the view 
    limits and the tick locations. 
 
    Attributes 
    ---------- 
    intervald : dict 
 
        Mapping of tick frequencies to multiples allowed for that ticking. 
        The default is :: 
 
            self.intervald = { 
                YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500, 
                           1000, 2000, 4000, 5000, 10000], 
                MONTHLY : [1, 2, 3, 4, 6], 
                DAILY   : [1, 2, 3, 7, 14, 21], 
                HOURLY  : [1, 2, 3, 4, 6, 12], 
                MINUTELY: [1, 5, 10, 15, 30], 
                SECONDLY: [1, 5, 10, 15, 30], 
                MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 
                                1000, 2000, 5000, 10000, 20000, 50000, 
                                100000, 200000, 500000, 1000000], 
            } 
 
        where the keys are defined in `dateutil.rrule`. 
 
        The interval is used to specify multiples that are appropriate for 
        the frequency of ticking. For instance, every 7 days is sensible 
        for daily ticks, but for minutes/seconds, 15 or 30 make sense. 
 
        When customizing, you should only modify the values for the existing 
        keys. You should not add or delete entries. 
 
        Example for forcing ticks every 3 hours:: 
 
            locator = AutoDateLocator() 
            locator.intervald[HOURLY] = [3]  # only show every 3 hours 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None, </span><span class="s1">minticks=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">maxticks=</span><span class="s2">None,</span>
                 <span class="s1">interval_multiples=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        minticks : int 
            The minimum number of ticks desired; controls whether ticks occur 
            yearly, monthly, etc. 
        maxticks : int 
            The maximum number of ticks desired; controls the interval between 
            ticks (ticking every other, every 3, etc.).  For fine-grained 
            control, this can be a dictionary mapping individual rrule 
            frequency constants (YEARLY, MONTHLY, etc.) to their own maximum 
            number of ticks.  This can be used to keep the number of ticks 
            appropriate to the format chosen in `AutoDateFormatter`. Any 
            frequency not specified in this dictionary is given a default 
            value. 
        interval_multiples : bool, default: True 
            Whether ticks should be chosen to be multiple of the interval, 
            locking them to 'nicer' locations.  For example, this will force 
            the ticks to be at hours 0, 6, 12, 18 when hourly ticking is done 
            at 6 hour intervals. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(tz=tz)</span>
        <span class="s1">self._freq = YEARLY</span>
        <span class="s1">self._freqs = [YEARLY</span><span class="s2">, </span><span class="s1">MONTHLY</span><span class="s2">, </span><span class="s1">DAILY</span><span class="s2">, </span><span class="s1">HOURLY</span><span class="s2">, </span><span class="s1">MINUTELY</span><span class="s2">,</span>
                       <span class="s1">SECONDLY</span><span class="s2">, </span><span class="s1">MICROSECONDLY]</span>
        <span class="s1">self.minticks = minticks</span>

        <span class="s1">self.maxticks = {YEARLY: </span><span class="s4">11</span><span class="s2">, </span><span class="s1">MONTHLY: </span><span class="s4">12</span><span class="s2">, </span><span class="s1">DAILY: </span><span class="s4">11</span><span class="s2">, </span><span class="s1">HOURLY: </span><span class="s4">12</span><span class="s2">,</span>
                         <span class="s1">MINUTELY: </span><span class="s4">11</span><span class="s2">, </span><span class="s1">SECONDLY: </span><span class="s4">11</span><span class="s2">, </span><span class="s1">MICROSECONDLY: </span><span class="s4">8</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">maxticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.maxticks.update(maxticks)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s5"># Assume we were given an integer. Use this as the maximum</span>
                <span class="s5"># number of ticks for every frequency and create a</span>
                <span class="s5"># dictionary for this</span>
                <span class="s1">self.maxticks = dict.fromkeys(self._freqs</span><span class="s2">, </span><span class="s1">maxticks)</span>
        <span class="s1">self.interval_multiples = interval_multiples</span>
        <span class="s1">self.intervald = {</span>
            <span class="s1">YEARLY:   [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">400</span><span class="s2">, </span><span class="s4">500</span><span class="s2">,</span>
                       <span class="s4">1000</span><span class="s2">, </span><span class="s4">2000</span><span class="s2">, </span><span class="s4">4000</span><span class="s2">, </span><span class="s4">5000</span><span class="s2">, </span><span class="s4">10000</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">MONTHLY:  [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">DAILY:    [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">21</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">HOURLY:   [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">12</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">MINUTELY: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">SECONDLY: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">MICROSECONDLY: [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">500</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2000</span><span class="s2">,</span>
                            <span class="s4">5000</span><span class="s2">, </span><span class="s4">10000</span><span class="s2">, </span><span class="s4">20000</span><span class="s2">, </span><span class="s4">50000</span><span class="s2">, </span><span class="s4">100000</span><span class="s2">, </span><span class="s4">200000</span><span class="s2">, </span><span class="s4">500000</span><span class="s2">,</span>
                            <span class="s4">1000000</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">interval_multiples:</span>
            <span class="s5"># Swap &quot;3&quot; for &quot;4&quot; in the DAILY list; If we use 3 we get bad</span>
            <span class="s5"># tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1</span>
            <span class="s5"># If we use 4 then we get: 1, 5, ... 25, 29, 1</span>
            <span class="s1">self.intervald[DAILY] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">14</span><span class="s1">]</span>

        <span class="s1">self._byranges = [</span><span class="s2">None, </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">13</span><span class="s1">)</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">24</span><span class="s1">)</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">60</span><span class="s1">)</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">60</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = self.viewlim_to_dt()</span>
        <span class="s1">locator = self.get_locator(dmin</span><span class="s2">, </span><span class="s1">dmax)</span>
        <span class="s2">return </span><span class="s1">locator()</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">return </span><span class="s1">self.get_locator(vmin</span><span class="s2">, </span><span class="s1">vmax).tick_values(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>

    <span class="s2">def </span><span class="s1">nonsingular(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s5"># whatever is thrown at us, we can scale the unit.</span>
        <span class="s5"># But default nonsingular date plots at an ~4 year period.</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(vmin) </span><span class="s2">or not </span><span class="s1">np.isfinite(vmax):</span>
            <span class="s5"># Except if there is no data, then use 1970 as default.</span>
            <span class="s2">return </span><span class="s1">(date2num(datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">date2num(datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s1">vmax &lt; vmin:</span>
            <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = vmax</span><span class="s2">, </span><span class="s1">vmin</span>
        <span class="s2">if </span><span class="s1">vmin == vmax:</span>
            <span class="s1">vmin = vmin - DAYS_PER_YEAR * </span><span class="s4">2</span>
            <span class="s1">vmax = vmax + DAYS_PER_YEAR * </span><span class="s4">2</span>
        <span class="s2">return </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span>

    <span class="s2">def </span><span class="s1">_get_unit(self):</span>
        <span class="s2">if </span><span class="s1">self._freq </span><span class="s2">in </span><span class="s1">[MICROSECONDLY]:</span>
            <span class="s2">return </span><span class="s4">1. </span><span class="s1">/ MUSECONDS_PER_DAY</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">RRuleLocator.get_unit_generic(self._freq)</span>

    <span class="s2">def </span><span class="s1">get_locator(self</span><span class="s2">, </span><span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax):</span>
        <span class="s0">&quot;&quot;&quot;Pick the best locator based on a distance.&quot;&quot;&quot;</span>
        <span class="s1">delta = relativedelta(dmax</span><span class="s2">, </span><span class="s1">dmin)</span>
        <span class="s1">tdelta = dmax - dmin</span>

        <span class="s5"># take absolute difference</span>
        <span class="s2">if </span><span class="s1">dmin &gt; dmax:</span>
            <span class="s1">delta = -delta</span>
            <span class="s1">tdelta = -tdelta</span>
        <span class="s5"># The following uses a mix of calls to relativedelta and timedelta</span>
        <span class="s5"># methods because there is incomplete overlap in the functionality of</span>
        <span class="s5"># these similar functions, and it's best to avoid doing our own math</span>
        <span class="s5"># whenever possible.</span>
        <span class="s1">numYears = float(delta.years)</span>
        <span class="s1">numMonths = numYears * MONTHS_PER_YEAR + delta.months</span>
        <span class="s1">numDays = tdelta.days  </span><span class="s5"># Avoids estimates of days/month, days/year.</span>
        <span class="s1">numHours = numDays * HOURS_PER_DAY + delta.hours</span>
        <span class="s1">numMinutes = numHours * MIN_PER_HOUR + delta.minutes</span>
        <span class="s1">numSeconds = np.floor(tdelta.total_seconds())</span>
        <span class="s1">numMicroseconds = np.floor(tdelta.total_seconds() * </span><span class="s4">1e6</span><span class="s1">)</span>

        <span class="s1">nums = [numYears</span><span class="s2">, </span><span class="s1">numMonths</span><span class="s2">, </span><span class="s1">numDays</span><span class="s2">, </span><span class="s1">numHours</span><span class="s2">, </span><span class="s1">numMinutes</span><span class="s2">,</span>
                <span class="s1">numSeconds</span><span class="s2">, </span><span class="s1">numMicroseconds]</span>

        <span class="s1">use_rrule_locator = [</span><span class="s2">True</span><span class="s1">] * </span><span class="s4">6 </span><span class="s1">+ [</span><span class="s2">False</span><span class="s1">]</span>

        <span class="s5"># Default setting of bymonth, etc. to pass to rrule</span>
        <span class="s5"># [unused (for year), bymonth, bymonthday, byhour, byminute,</span>
        <span class="s5">#  bysecond, unused (for microseconds)]</span>
        <span class="s1">byranges = [</span><span class="s2">None, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None</span><span class="s1">]</span>

        <span class="s5"># Loop over all the frequencies and try to find one that gives at</span>
        <span class="s5"># least a minticks tick positions.  Once this is found, look for</span>
        <span class="s5"># an interval from a list specific to that frequency that gives no</span>
        <span class="s5"># more than maxticks tick positions. Also, set up some ranges</span>
        <span class="s5"># (bymonth, etc.) as appropriate to be passed to rrulewrapper.</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(freq</span><span class="s2">, </span><span class="s1">num) </span><span class="s2">in </span><span class="s1">enumerate(zip(self._freqs</span><span class="s2">, </span><span class="s1">nums)):</span>
            <span class="s5"># If this particular frequency doesn't give enough ticks, continue</span>
            <span class="s2">if </span><span class="s1">num &lt; self.minticks:</span>
                <span class="s5"># Since we're not using this particular frequency, set</span>
                <span class="s5"># the corresponding by_ to None so the rrule can act as</span>
                <span class="s5"># appropriate</span>
                <span class="s1">byranges[i] = </span><span class="s2">None</span>
                <span class="s2">continue</span>

            <span class="s5"># Find the first available interval that doesn't give too many</span>
            <span class="s5"># ticks</span>
            <span class="s2">for </span><span class="s1">interval </span><span class="s2">in </span><span class="s1">self.intervald[freq]:</span>
                <span class="s2">if </span><span class="s1">num &lt;= interval * (self.maxticks[freq] - </span><span class="s4">1</span><span class="s1">):</span>
                    <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">(self.interval_multiples </span><span class="s2">and </span><span class="s1">freq == DAILY):</span>
                    <span class="s1">_api.warn_external(</span>
                        <span class="s3">f&quot;AutoDateLocator was unable to pick an appropriate &quot;</span>
                        <span class="s3">f&quot;interval for this date range. It may be necessary &quot;</span>
                        <span class="s3">f&quot;to add an interval value to the AutoDateLocator's &quot;</span>
                        <span class="s3">f&quot;intervald dictionary. Defaulting to </span><span class="s2">{</span><span class="s1">interval</span><span class="s2">}</span><span class="s3">.&quot;</span><span class="s1">)</span>

            <span class="s5"># Set some parameters as appropriate</span>
            <span class="s1">self._freq = freq</span>

            <span class="s2">if </span><span class="s1">self._byranges[i] </span><span class="s2">and </span><span class="s1">self.interval_multiples:</span>
                <span class="s1">byranges[i] = self._byranges[i][::interval]</span>
                <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">(DAILY</span><span class="s2">, </span><span class="s1">WEEKLY):</span>
                    <span class="s2">if </span><span class="s1">interval == </span><span class="s4">14</span><span class="s1">:</span>
                        <span class="s5"># just make first and 15th.  Avoids 30th.</span>
                        <span class="s1">byranges[i] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">15</span><span class="s1">]</span>
                    <span class="s2">elif </span><span class="s1">interval == </span><span class="s4">7</span><span class="s1">:</span>
                        <span class="s1">byranges[i] = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">22</span><span class="s1">]</span>

                <span class="s1">interval = </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">byranges[i] = self._byranges[i]</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">interval = </span><span class="s4">1</span>

        <span class="s2">if </span><span class="s1">(freq == YEARLY) </span><span class="s2">and </span><span class="s1">self.interval_multiples:</span>
            <span class="s1">locator = YearLocator(interval</span><span class="s2">, </span><span class="s1">tz=self.tz)</span>
        <span class="s2">elif </span><span class="s1">use_rrule_locator[i]:</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">bymonth</span><span class="s2">, </span><span class="s1">bymonthday</span><span class="s2">, </span><span class="s1">byhour</span><span class="s2">, </span><span class="s1">byminute</span><span class="s2">, </span><span class="s1">bysecond</span><span class="s2">, </span><span class="s1">_ = byranges</span>
            <span class="s1">rrule = rrulewrapper(self._freq</span><span class="s2">, </span><span class="s1">interval=interval</span><span class="s2">,</span>
                                 <span class="s1">dtstart=dmin</span><span class="s2">, </span><span class="s1">until=dmax</span><span class="s2">,</span>
                                 <span class="s1">bymonth=bymonth</span><span class="s2">, </span><span class="s1">bymonthday=bymonthday</span><span class="s2">,</span>
                                 <span class="s1">byhour=byhour</span><span class="s2">, </span><span class="s1">byminute=byminute</span><span class="s2">,</span>
                                 <span class="s1">bysecond=bysecond)</span>

            <span class="s1">locator = RRuleLocator(rrule</span><span class="s2">, </span><span class="s1">tz=self.tz)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">locator = MicrosecondLocator(interval</span><span class="s2">, </span><span class="s1">tz=self.tz)</span>
            <span class="s2">if </span><span class="s1">date2num(dmin) &gt; </span><span class="s4">70 </span><span class="s1">* </span><span class="s4">365 </span><span class="s2">and </span><span class="s1">interval &lt; </span><span class="s4">1000</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s3">'Plotting microsecond time intervals for dates far from '</span>
                    <span class="s3">f'the epoch (time origin: </span><span class="s2">{</span><span class="s1">get_epoch()</span><span class="s2">}</span><span class="s3">) is not well-'</span>
                    <span class="s3">'supported. See matplotlib.dates.set_epoch to change the '</span>
                    <span class="s3">'epoch.'</span><span class="s1">)</span>

        <span class="s1">locator.set_axis(self.axis)</span>
        <span class="s2">return </span><span class="s1">locator</span>


<span class="s2">class </span><span class="s1">YearLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on a given day of each year that is a multiple of base. 
 
    Examples:: 
 
      # Tick every year on Jan 1st 
      locator = YearLocator() 
 
      # Tick every 5 years on July 4th 
      locator = YearLocator(5, month=7, day=4) 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">month=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        base : int, default: 1 
            Mark ticks every *base* years. 
        month : int, default: 1 
            The month on which to place the ticks, starting from 1. Default is 
            January. 
        day : int, default: 1 
            The day on which to place the ticks. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s1">rule = rrulewrapper(YEARLY</span><span class="s2">, </span><span class="s1">interval=base</span><span class="s2">, </span><span class="s1">bymonth=month</span><span class="s2">,</span>
                            <span class="s1">bymonthday=day</span><span class="s2">, </span><span class="s1">**self.hms0d)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">self.base = ticker._Edge_integer(base</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_rrule(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s5"># 'start' needs to be a multiple of the interval to create ticks on</span>
        <span class="s5"># interval multiples when the tick frequency is YEARLY</span>
        <span class="s1">ymin = max(self.base.le(vmin.year) * self.base.step</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">ymax = min(self.base.ge(vmax.year) * self.base.step</span><span class="s2">, </span><span class="s4">9999</span><span class="s1">)</span>

        <span class="s1">c = self.rule._construct</span>
        <span class="s1">replace = {</span><span class="s3">'year'</span><span class="s1">: ymin</span><span class="s2">,</span>
                   <span class="s3">'month'</span><span class="s1">: c.get(</span><span class="s3">'bymonth'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">'day'</span><span class="s1">: c.get(</span><span class="s3">'bymonthday'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">'hour'</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'minute'</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'second'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span>

        <span class="s1">start = vmin.replace(**replace)</span>
        <span class="s1">stop = start.replace(year=ymax)</span>
        <span class="s1">self.rule.set(dtstart=start</span><span class="s2">, </span><span class="s1">until=stop)</span>

        <span class="s2">return </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span>


<span class="s2">class </span><span class="s1">MonthLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each month, e.g., 1, 3, 12. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bymonth=</span><span class="s2">None, </span><span class="s1">bymonthday=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        bymonth : int or list of int, default: all months 
            Ticks will be placed on every month in *bymonth*. Default is 
            ``range(1, 13)``, i.e. every month. 
        bymonthday : int, default: 1 
            The day on which to place the ticks. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bymonth </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bymonth = range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">13</span><span class="s1">)</span>

        <span class="s1">rule = rrulewrapper(MONTHLY</span><span class="s2">, </span><span class="s1">bymonth=bymonth</span><span class="s2">, </span><span class="s1">bymonthday=bymonthday</span><span class="s2">,</span>
                            <span class="s1">interval=interval</span><span class="s2">, </span><span class="s1">**self.hms0d)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">WeekdayLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each weekday. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">byweekday=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        byweekday : int or list of int, default: all days 
            Ticks will be placed on every weekday in *byweekday*. Default is 
            every day. 
 
            Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA, 
            SU, the constants from :mod:`dateutil.rrule`, which have been 
            imported into the :mod:`matplotlib.dates` namespace. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s1">rule = rrulewrapper(DAILY</span><span class="s2">, </span><span class="s1">byweekday=byweekday</span><span class="s2">,</span>
                            <span class="s1">interval=interval</span><span class="s2">, </span><span class="s1">**self.hms0d)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">DayLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each day of the month.  For example, 
    1, 15, 30. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bymonthday=</span><span class="s2">None, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        bymonthday : int or list of int, default: all days 
            Ticks will be placed on every day in *bymonthday*. Default is 
            ``bymonthday=range(1, 32)``, i.e., every day of the month. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">interval != int(interval) </span><span class="s2">or </span><span class="s1">interval &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;interval must be an integer greater than 0&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">bymonthday </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bymonthday = range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">32</span><span class="s1">)</span>

        <span class="s1">rule = rrulewrapper(DAILY</span><span class="s2">, </span><span class="s1">bymonthday=bymonthday</span><span class="s2">,</span>
                            <span class="s1">interval=interval</span><span class="s2">, </span><span class="s1">**self.hms0d)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">HourLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each hour. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">byhour=</span><span class="s2">None, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        byhour : int or list of int, default: all hours 
            Ticks will be placed on every hour in *byhour*. Default is 
            ``byhour=range(24)``, i.e., every hour. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">byhour </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">byhour = range(</span><span class="s4">24</span><span class="s1">)</span>

        <span class="s1">rule = rrulewrapper(HOURLY</span><span class="s2">, </span><span class="s1">byhour=byhour</span><span class="s2">, </span><span class="s1">interval=interval</span><span class="s2">,</span>
                            <span class="s1">byminute=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">bysecond=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">MinuteLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each minute. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">byminute=</span><span class="s2">None, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        byminute : int or list of int, default: all minutes 
            Ticks will be placed on every minute in *byminute*. Default is 
            ``byminute=range(60)``, i.e., every minute. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">byminute </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">byminute = range(</span><span class="s4">60</span><span class="s1">)</span>

        <span class="s1">rule = rrulewrapper(MINUTELY</span><span class="s2">, </span><span class="s1">byminute=byminute</span><span class="s2">, </span><span class="s1">interval=interval</span><span class="s2">,</span>
                            <span class="s1">bysecond=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">SecondLocator(RRuleLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on occurrences of each second. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bysecond=</span><span class="s2">None, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        bysecond : int or list of int, default: all seconds 
            Ticks will be placed on every second in *bysecond*. Default is 
            ``bysecond = range(60)``, i.e., every second. 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bysecond </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bysecond = range(</span><span class="s4">60</span><span class="s1">)</span>

        <span class="s1">rule = rrulewrapper(SECONDLY</span><span class="s2">, </span><span class="s1">bysecond=bysecond</span><span class="s2">, </span><span class="s1">interval=interval)</span>
        <span class="s1">super().__init__(rule</span><span class="s2">, </span><span class="s1">tz=tz)</span>


<span class="s2">class </span><span class="s1">MicrosecondLocator(DateLocator):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make ticks on regular intervals of one or more microsecond(s). 
 
    .. note:: 
 
        By default, Matplotlib uses a floating point representation of time in 
        days since the epoch, so plotting data with 
        microsecond time resolution does not work well for 
        dates that are far (about 70 years) from the epoch (check with 
        `~.dates.get_epoch`). 
 
        If you want sub-microsecond resolution time plots, it is strongly 
        recommended to use floating point seconds, not datetime-like 
        time representation. 
 
        If you really must use datetime.datetime() or similar and still 
        need microsecond precision, change the time origin via 
        `.dates.set_epoch` to something closer to the dates being plotted. 
        See :doc:`/gallery/ticks/date_precision_and_epochs`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">interval=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        interval : int, default: 1 
            The interval between each iteration. For example, if 
            ``interval=2``, mark every second occurrence. 
        tz : str or `~datetime.tzinfo`, default: :rc:`timezone` 
            Ticks timezone. If a string, *tz* is passed to `dateutil.tz`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(tz=tz)</span>
        <span class="s1">self._interval = interval</span>
        <span class="s1">self._wrapped_locator = ticker.MultipleLocator(interval)</span>

    <span class="s2">def </span><span class="s1">set_axis(self</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s1">self._wrapped_locator.set_axis(axis)</span>
        <span class="s2">return </span><span class="s1">super().set_axis(axis)</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s5"># if no data have been set, this will tank with a ValueError</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dmin</span><span class="s2">, </span><span class="s1">dmax = self.viewlim_to_dt()</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s2">return </span><span class="s1">self.tick_values(dmin</span><span class="s2">, </span><span class="s1">dmax)</span>

    <span class="s2">def </span><span class="s1">tick_values(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s1">nmin</span><span class="s2">, </span><span class="s1">nmax = date2num((vmin</span><span class="s2">, </span><span class="s1">vmax))</span>
        <span class="s1">t0 = np.floor(nmin)</span>
        <span class="s1">nmax = nmax - t0</span>
        <span class="s1">nmin = nmin - t0</span>
        <span class="s1">nmin *= MUSECONDS_PER_DAY</span>
        <span class="s1">nmax *= MUSECONDS_PER_DAY</span>

        <span class="s1">ticks = self._wrapped_locator.tick_values(nmin</span><span class="s2">, </span><span class="s1">nmax)</span>

        <span class="s1">ticks = ticks / MUSECONDS_PER_DAY + t0</span>
        <span class="s2">return </span><span class="s1">ticks</span>

    <span class="s2">def </span><span class="s1">_get_unit(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s4">1. </span><span class="s1">/ MUSECONDS_PER_DAY</span>

    <span class="s2">def </span><span class="s1">_get_interval(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">self._interval</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;`AutoDateLocator` and `AutoDateFormatter`&quot;</span>
                 <span class="s3">&quot; or vendor the code&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">date_ticker_factory(span</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None, </span><span class="s1">numticks=</span><span class="s4">5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a date locator with *numticks* (approx) and a date formatter 
    for *span* in days.  Return value is (locator, formatter). 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">span == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">span = </span><span class="s4">1 </span><span class="s1">/ HOURS_PER_DAY</span>

    <span class="s1">mins = span * MINUTES_PER_DAY</span>
    <span class="s1">hrs = span * HOURS_PER_DAY</span>
    <span class="s1">days = span</span>
    <span class="s1">wks = span / DAYS_PER_WEEK</span>
    <span class="s1">months = span / DAYS_PER_MONTH      </span><span class="s5"># Approx</span>
    <span class="s1">years = span / DAYS_PER_YEAR        </span><span class="s5"># Approx</span>

    <span class="s2">if </span><span class="s1">years &gt; numticks:</span>
        <span class="s1">locator = YearLocator(int(years / numticks)</span><span class="s2">, </span><span class="s1">tz=tz)  </span><span class="s5"># define</span>
        <span class="s1">fmt = </span><span class="s3">'%Y'</span>
    <span class="s2">elif </span><span class="s1">months &gt; numticks:</span>
        <span class="s1">locator = MonthLocator(tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%b %Y'</span>
    <span class="s2">elif </span><span class="s1">wks &gt; numticks:</span>
        <span class="s1">locator = WeekdayLocator(tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%a, %b %d'</span>
    <span class="s2">elif </span><span class="s1">days &gt; numticks:</span>
        <span class="s1">locator = DayLocator(interval=math.ceil(days / numticks)</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%b %d'</span>
    <span class="s2">elif </span><span class="s1">hrs &gt; numticks:</span>
        <span class="s1">locator = HourLocator(interval=math.ceil(hrs / numticks)</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%H:%M</span><span class="s2">\n</span><span class="s3">%b %d'</span>
    <span class="s2">elif </span><span class="s1">mins &gt; numticks:</span>
        <span class="s1">locator = MinuteLocator(interval=math.ceil(mins / numticks)</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%H:%M:%S'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">locator = MinuteLocator(tz=tz)</span>
        <span class="s1">fmt = </span><span class="s3">'%H:%M:%S'</span>

    <span class="s1">formatter = DateFormatter(fmt</span><span class="s2">, </span><span class="s1">tz=tz)</span>
    <span class="s2">return </span><span class="s1">locator</span><span class="s2">, </span><span class="s1">formatter</span>


<span class="s2">class </span><span class="s1">DateConverter(units.ConversionInterface):</span>
    <span class="s0">&quot;&quot;&quot; 
    Converter for `datetime.date` and `datetime.datetime` data, or for 
    date/time data represented as it would be converted by `date2num`. 
 
    The 'unit' tag for such data is None or a `~datetime.tzinfo` instance. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">interval_multiples=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self._interval_multiples = interval_multiples</span>
        <span class="s1">super().__init__()</span>

    <span class="s2">def </span><span class="s1">axisinfo(self</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `~matplotlib.units.AxisInfo` for *unit*. 
 
        *unit* is a `~datetime.tzinfo` instance or None. 
        The *axis* argument is required but not used. 
        &quot;&quot;&quot;</span>
        <span class="s1">tz = unit</span>

        <span class="s1">majloc = AutoDateLocator(tz=tz</span><span class="s2">,</span>
                                 <span class="s1">interval_multiples=self._interval_multiples)</span>
        <span class="s1">majfmt = AutoDateFormatter(majloc</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">datemin = datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">datemax = datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">units.AxisInfo(majloc=majloc</span><span class="s2">, </span><span class="s1">majfmt=majfmt</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">''</span><span class="s2">,</span>
                              <span class="s1">default_limits=(datemin</span><span class="s2">, </span><span class="s1">datemax))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">convert(value</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot; 
        If *value* is not already a number or sequence of numbers, convert it 
        with `date2num`. 
 
        The *unit* and *axis* arguments are not used. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">date2num(value)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">default_units(x</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `~datetime.tzinfo` instance of *x* or of its first element, 
        or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">x = x.ravel()</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">x = cbook._safe_first_finite(x)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">StopIteration):</span>
            <span class="s2">pass</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x.tzinfo</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">ConciseDateConverter(DateConverter):</span>
    <span class="s5"># docstring inherited</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">formats=</span><span class="s2">None, </span><span class="s1">zero_formats=</span><span class="s2">None, </span><span class="s1">offset_formats=</span><span class="s2">None,</span>
                 <span class="s1">show_offset=</span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">interval_multiples=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self._formats = formats</span>
        <span class="s1">self._zero_formats = zero_formats</span>
        <span class="s1">self._offset_formats = offset_formats</span>
        <span class="s1">self._show_offset = show_offset</span>
        <span class="s1">self._interval_multiples = interval_multiples</span>
        <span class="s1">super().__init__()</span>

    <span class="s2">def </span><span class="s1">axisinfo(self</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">axis):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">tz = unit</span>
        <span class="s1">majloc = AutoDateLocator(tz=tz</span><span class="s2">,</span>
                                 <span class="s1">interval_multiples=self._interval_multiples)</span>
        <span class="s1">majfmt = ConciseDateFormatter(majloc</span><span class="s2">, </span><span class="s1">tz=tz</span><span class="s2">, </span><span class="s1">formats=self._formats</span><span class="s2">,</span>
                                      <span class="s1">zero_formats=self._zero_formats</span><span class="s2">,</span>
                                      <span class="s1">offset_formats=self._offset_formats</span><span class="s2">,</span>
                                      <span class="s1">show_offset=self._show_offset)</span>
        <span class="s1">datemin = datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">datemax = datetime.date(</span><span class="s4">1970</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">units.AxisInfo(majloc=majloc</span><span class="s2">, </span><span class="s1">majfmt=majfmt</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">''</span><span class="s2">,</span>
                              <span class="s1">default_limits=(datemin</span><span class="s2">, </span><span class="s1">datemax))</span>


<span class="s2">class </span><span class="s1">_SwitchableDateConverter:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper converter-like object that generates and dispatches to 
    temporary ConciseDateConverter or DateConverter instances based on 
    :rc:`date.converter` and :rc:`date.interval_multiples`. 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_converter():</span>
        <span class="s1">converter_cls = {</span>
            <span class="s3">&quot;concise&quot;</span><span class="s1">: ConciseDateConverter</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">: DateConverter}[</span>
                <span class="s1">mpl.rcParams[</span><span class="s3">&quot;date.converter&quot;</span><span class="s1">]]</span>
        <span class="s1">interval_multiples = mpl.rcParams[</span><span class="s3">&quot;date.interval_multiples&quot;</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">converter_cls(interval_multiples=interval_multiples)</span>

    <span class="s2">def </span><span class="s1">axisinfo(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self._get_converter().axisinfo(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">default_units(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self._get_converter().default_units(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">convert(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self._get_converter().convert(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">units.registry[np.datetime64] = \</span>
    <span class="s1">units.registry[datetime.date] = \</span>
    <span class="s1">units.registry[datetime.datetime] = \</span>
    <span class="s1">_SwitchableDateConverter()</span>
</pre>
</body>
</html>