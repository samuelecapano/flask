<html>
<head>
<title>axes3d.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
axes3d.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
axes3d.py, original mplot3d version by John Porter 
Created: 23 Sep 2005 
 
Parts fixed by Reinier Heeres &lt;reinier@heeres.eu&gt; 
Minor additions by Ben Axelrod &lt;baxelrod@coroware.com&gt; 
Significant updates and revisions by Ben Root &lt;ben.v.root@gmail.com&gt; 
 
Module containing Axes3D, an object which can plot 3D objects on a 
2D matplotlib figure. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">textwrap</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">, </span><span class="s1">_preprocess_data</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">import </span><span class="s1">matplotlib.axes </span><span class="s2">as </span><span class="s1">maxes</span>
<span class="s2">import </span><span class="s1">matplotlib.collections </span><span class="s2">as </span><span class="s1">mcoll</span>
<span class="s2">import </span><span class="s1">matplotlib.colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">import </span><span class="s1">matplotlib.image </span><span class="s2">as </span><span class="s1">mimage</span>
<span class="s2">import </span><span class="s1">matplotlib.lines </span><span class="s2">as </span><span class="s1">mlines</span>
<span class="s2">import </span><span class="s1">matplotlib.patches </span><span class="s2">as </span><span class="s1">mpatches</span>
<span class="s2">import </span><span class="s1">matplotlib.container </span><span class="s2">as </span><span class="s1">mcontainer</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>
<span class="s2">from </span><span class="s1">matplotlib.axes </span><span class="s2">import </span><span class="s1">Axes</span>
<span class="s2">from </span><span class="s1">matplotlib.axes._base </span><span class="s2">import </span><span class="s1">_axis_method_wrapper</span><span class="s2">, </span><span class="s1">_process_plot_format</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Bbox</span>
<span class="s2">from </span><span class="s1">matplotlib.tri._triangulation </span><span class="s2">import </span><span class="s1">Triangulation</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">art3d</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">proj3d</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">axis3d</span>


<span class="s1">@_docstring.interpd</span>
<span class="s1">@_api.define_aliases({</span>
    <span class="s3">&quot;xlim&quot;</span><span class="s1">: [</span><span class="s3">&quot;xlim3d&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;ylim&quot;</span><span class="s1">: [</span><span class="s3">&quot;ylim3d&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;zlim&quot;</span><span class="s1">: [</span><span class="s3">&quot;zlim3d&quot;</span><span class="s1">]})</span>
<span class="s2">class </span><span class="s1">Axes3D(Axes):</span>
    <span class="s0">&quot;&quot;&quot; 
    3D Axes object. 
 
    .. note:: 
 
        As a user, you do not instantiate Axes directly, but use Axes creation 
        methods instead; e.g. from `.pyplot` or `.Figure`: 
        `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`. 
    &quot;&quot;&quot;</span>
    <span class="s1">name = </span><span class="s3">'3d'</span>

    <span class="s1">_axis_names = (</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s3">&quot;z&quot;</span><span class="s1">)</span>
    <span class="s1">Axes._shared_axes[</span><span class="s3">&quot;z&quot;</span><span class="s1">] = cbook.Grouper()</span>

    <span class="s1">dist = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s1">vvec = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s1">eye = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s1">sx = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s1">sy = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">rect=</span><span class="s2">None, </span><span class="s1">*args</span><span class="s2">,</span>
            <span class="s1">elev=</span><span class="s4">30</span><span class="s2">, </span><span class="s1">azim=-</span><span class="s4">60</span><span class="s2">, </span><span class="s1">roll=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">sharez=</span><span class="s2">None, </span><span class="s1">proj_type=</span><span class="s3">'persp'</span><span class="s2">,</span>
            <span class="s1">box_aspect=</span><span class="s2">None, </span><span class="s1">computed_zorder=</span><span class="s2">True, </span><span class="s1">focal_length=</span><span class="s2">None,</span>
            <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        fig : Figure 
            The parent figure. 
        rect : tuple (left, bottom, width, height), default: None. 
            The ``(left, bottom, width, height)`` axes position. 
        elev : float, default: 30 
            The elevation angle in degrees rotates the camera above and below 
            the x-y plane, with a positive angle corresponding to a location 
            above the plane. 
        azim : float, default: -60 
            The azimuthal angle in degrees rotates the camera about the z axis, 
            with a positive angle corresponding to a right-handed rotation. In 
            other words, a positive azimuth rotates the camera about the origin 
            from its location along the +x axis towards the +y axis. 
        roll : float, default: 0 
            The roll angle in degrees rotates the camera about the viewing 
            axis. A positive angle spins the camera clockwise, causing the 
            scene to rotate counter-clockwise. 
        sharez : Axes3D, optional 
            Other Axes to share z-limits with. 
        proj_type : {'persp', 'ortho'} 
            The projection type, default 'persp'. 
        box_aspect : 3-tuple of floats, default: None 
            Changes the physical dimensions of the Axes3D, such that the ratio 
            of the axis lengths in display units is x:y:z. 
            If None, defaults to 4:4:3 
        computed_zorder : bool, default: True 
            If True, the draw order is computed based on the average position 
            of the `.Artist`\\s along the view direction. 
            Set to False if you want to manually control the order in which 
            Artists are drawn on top of each other using their *zorder* 
            attribute. This can be used for fine-tuning if the automatic order 
            does not produce the desired result. Note however, that a manual 
            zorder will only be correct for a limited view angle. If the figure 
            is rotated by the user, it will look wrong from certain angles. 
        focal_length : float, default: None 
            For a projection type of 'persp', the focal length of the virtual 
            camera. Must be &gt; 0. If None, defaults to 1. 
            For a projection type of 'ortho', must be set to either None 
            or infinity (numpy.inf). If None, defaults to infinity. 
            The focal length can be computed from a desired Field Of View via 
            the equation: focal_length = 1/tan(FOV/2) 
 
        **kwargs 
            Other optional keyword arguments: 
 
            %(Axes3D:kwdoc)s 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">rect </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rect = [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span>

        <span class="s1">self.initial_azim = azim</span>
        <span class="s1">self.initial_elev = elev</span>
        <span class="s1">self.initial_roll = roll</span>
        <span class="s1">self.set_proj_type(proj_type</span><span class="s2">, </span><span class="s1">focal_length)</span>
        <span class="s1">self.computed_zorder = computed_zorder</span>

        <span class="s1">self.xy_viewLim = Bbox.unit()</span>
        <span class="s1">self.zz_viewLim = Bbox.unit()</span>
        <span class="s1">self.xy_dataLim = Bbox.unit()</span>
        <span class="s5"># z-limits are encoded in the x-component of the Bbox, y is un-used</span>
        <span class="s1">self.zz_dataLim = Bbox.unit()</span>

        <span class="s5"># inhibit autoscale_view until the axes are defined</span>
        <span class="s5"># they can't be defined until Axes.__init__ has been called</span>
        <span class="s1">self.view_init(self.initial_elev</span><span class="s2">, </span><span class="s1">self.initial_azim</span><span class="s2">, </span><span class="s1">self.initial_roll)</span>

        <span class="s1">self._sharez = sharez</span>
        <span class="s2">if </span><span class="s1">sharez </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._shared_axes[</span><span class="s3">&quot;z&quot;</span><span class="s1">].join(self</span><span class="s2">, </span><span class="s1">sharez)</span>
            <span class="s1">self._adjustable = </span><span class="s3">'datalim'</span>

        <span class="s2">if </span><span class="s1">kwargs.pop(</span><span class="s3">'auto_add_to_figure'</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span>
                <span class="s3">'auto_add_to_figure is no longer supported for Axes3D. '</span>
                <span class="s3">'Use fig.add_axes(ax) instead.'</span>
            <span class="s1">)</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">fig</span><span class="s2">, </span><span class="s1">rect</span><span class="s2">, </span><span class="s1">frameon=</span><span class="s2">True, </span><span class="s1">box_aspect=box_aspect</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s5"># Disable drawing of axes by base class</span>
        <span class="s1">super().set_axis_off()</span>
        <span class="s5"># Enable drawing of axes by Axes3D class</span>
        <span class="s1">self.set_axis_on()</span>
        <span class="s1">self.M = </span><span class="s2">None</span>

        <span class="s5"># func used to format z -- fall back on major formatters</span>
        <span class="s1">self.fmt_zdata = </span><span class="s2">None</span>

        <span class="s1">self.mouse_init()</span>
        <span class="s1">self.figure.canvas.callbacks._connect_picklable(</span>
            <span class="s3">'motion_notify_event'</span><span class="s2">, </span><span class="s1">self._on_move)</span>
        <span class="s1">self.figure.canvas.callbacks._connect_picklable(</span>
            <span class="s3">'button_press_event'</span><span class="s2">, </span><span class="s1">self._button_press)</span>
        <span class="s1">self.figure.canvas.callbacks._connect_picklable(</span>
            <span class="s3">'button_release_event'</span><span class="s2">, </span><span class="s1">self._button_release)</span>
        <span class="s1">self.set_top_view()</span>

        <span class="s1">self.patch.set_linewidth(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s5"># Calculate the pseudo-data width and height</span>
        <span class="s1">pseudo_bbox = self.transLimits.inverted().transform([(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)])</span>
        <span class="s1">self._pseudo_w</span><span class="s2">, </span><span class="s1">self._pseudo_h = pseudo_bbox[</span><span class="s4">1</span><span class="s1">] - pseudo_bbox[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s5"># mplot3d currently manages its own spines and needs these turned off</span>
        <span class="s5"># for bounding box calculations</span>
        <span class="s1">self.spines[:].set_visible(</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_axis_off(self):</span>
        <span class="s1">self._axis3don = </span><span class="s2">False</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_axis_on(self):</span>
        <span class="s1">self._axis3don = </span><span class="s2">True</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">convert_zunits(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        For artists in an Axes, if the zaxis has units support, 
        convert *z* using zaxis unit type 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.zaxis.convert_units(z)</span>

    <span class="s2">def </span><span class="s1">set_top_view(self):</span>
        <span class="s5"># this happens to be the right view for the viewing coordinates</span>
        <span class="s5"># moved up and to the left slightly to fit labels and axes</span>
        <span class="s1">xdwl = </span><span class="s4">0.95 </span><span class="s1">/ self._dist</span>
        <span class="s1">xdw = </span><span class="s4">0.9 </span><span class="s1">/ self._dist</span>
        <span class="s1">ydwl = </span><span class="s4">0.95 </span><span class="s1">/ self._dist</span>
        <span class="s1">ydw = </span><span class="s4">0.9 </span><span class="s1">/ self._dist</span>
        <span class="s5"># Set the viewing pane.</span>
        <span class="s1">self.viewLim.intervalx = (-xdwl</span><span class="s2">, </span><span class="s1">xdw)</span>
        <span class="s1">self.viewLim.intervaly = (-ydwl</span><span class="s2">, </span><span class="s1">ydw)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_init_axis(self):</span>
        <span class="s0">&quot;&quot;&quot;Init 3D axes; overrides creation of regular X/Y axes.&quot;&quot;&quot;</span>
        <span class="s1">self.xaxis = axis3d.XAxis(self)</span>
        <span class="s1">self.yaxis = axis3d.YAxis(self)</span>
        <span class="s1">self.zaxis = axis3d.ZAxis(self)</span>

    <span class="s2">def </span><span class="s1">get_zaxis(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the ``ZAxis`` (`~.axis3d.Axis`) instance.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.zaxis</span>

    <span class="s1">get_zgridlines = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_gridlines&quot;</span><span class="s1">)</span>
    <span class="s1">get_zticklines = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_ticklines&quot;</span><span class="s1">)</span>

    <span class="s1">w_xaxis = _api.deprecated(</span><span class="s3">&quot;3.1&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;xaxis&quot;</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.xaxis))</span>
    <span class="s1">w_yaxis = _api.deprecated(</span><span class="s3">&quot;3.1&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;yaxis&quot;</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.yaxis))</span>
    <span class="s1">w_zaxis = _api.deprecated(</span><span class="s3">&quot;3.1&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">&quot;3.8&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.zaxis))</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">unit_cube(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._unit_cube(vals)</span>

    <span class="s2">def </span><span class="s1">_unit_cube(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz = vals </span><span class="s2">or </span><span class="s1">self.get_w_lims()</span>
        <span class="s2">return </span><span class="s1">[(minx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">minz)</span><span class="s2">,</span>
                <span class="s1">(maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">minz)</span><span class="s2">,</span>
                <span class="s1">(maxx</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz)</span><span class="s2">,</span>
                <span class="s1">(minx</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz)</span><span class="s2">,</span>
                <span class="s1">(minx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxz)</span><span class="s2">,</span>
                <span class="s1">(maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxz)</span><span class="s2">,</span>
                <span class="s1">(maxx</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">maxz)</span><span class="s2">,</span>
                <span class="s1">(minx</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">maxz)]</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">tunit_cube(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None, </span><span class="s1">M=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._tunit_cube(vals</span><span class="s2">, </span><span class="s1">M)</span>

    <span class="s2">def </span><span class="s1">_tunit_cube(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None, </span><span class="s1">M=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">M </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">M = self.M</span>
        <span class="s1">xyzs = self._unit_cube(vals)</span>
        <span class="s1">tcube = proj3d.proj_points(xyzs</span><span class="s2">, </span><span class="s1">M)</span>
        <span class="s2">return </span><span class="s1">tcube</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">tunit_edges(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None, </span><span class="s1">M=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._tunit_edges(vals</span><span class="s2">, </span><span class="s1">M)</span>

    <span class="s2">def </span><span class="s1">_tunit_edges(self</span><span class="s2">, </span><span class="s1">vals=</span><span class="s2">None, </span><span class="s1">M=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">tc = self._tunit_cube(vals</span><span class="s2">, </span><span class="s1">M)</span>
        <span class="s1">edges = [(tc[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">3</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>

                 <span class="s1">(tc[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">4</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">6</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">7</span><span class="s1">])</span><span class="s2">,</span>

                 <span class="s1">(tc[</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">5</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">6</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">7</span><span class="s1">])</span><span class="s2">,</span>
                 <span class="s1">(tc[</span><span class="s4">7</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tc[</span><span class="s4">4</span><span class="s1">])]</span>
        <span class="s2">return </span><span class="s1">edges</span>

    <span class="s2">def </span><span class="s1">set_aspect(self</span><span class="s2">, </span><span class="s1">aspect</span><span class="s2">, </span><span class="s1">adjustable=</span><span class="s2">None, </span><span class="s1">anchor=</span><span class="s2">None, </span><span class="s1">share=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the aspect ratios. 
 
        Parameters 
        ---------- 
        aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'} 
            Possible values: 
 
            =========   ================================================== 
            value       description 
            =========   ================================================== 
            'auto'      automatic; fill the position rectangle with data. 
            'equal'     adapt all the axes to have equal aspect ratios. 
            'equalxy'   adapt the x and y axes to have equal aspect ratios. 
            'equalxz'   adapt the x and z axes to have equal aspect ratios. 
            'equalyz'   adapt the y and z axes to have equal aspect ratios. 
            =========   ================================================== 
 
        adjustable : None or {'box', 'datalim'}, optional 
            If not *None*, this defines which parameter will be adjusted to 
            meet the required aspect. See `.set_adjustable` for further 
            details. 
 
        anchor : None or str or 2-tuple of float, optional 
            If not *None*, this defines where the Axes will be drawn if there 
            is extra space due to aspect constraints. The most common way to 
            specify the anchor are abbreviations of cardinal directions: 
 
            =====   ===================== 
            value   description 
            =====   ===================== 
            'C'     centered 
            'SW'    lower left corner 
            'S'     middle of bottom edge 
            'SE'    lower right corner 
            etc. 
            =====   ===================== 
 
            See `~.Axes.set_anchor` for further details. 
 
        share : bool, default: False 
            If ``True``, apply the settings to all shared Axes. 
 
        See Also 
        -------- 
        mpl_toolkits.mplot3d.axes3d.Axes3D.set_box_aspect 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list((</span><span class="s3">'auto'</span><span class="s2">, </span><span class="s3">'equal'</span><span class="s2">, </span><span class="s3">'equalxy'</span><span class="s2">, </span><span class="s3">'equalyz'</span><span class="s2">, </span><span class="s3">'equalxz'</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">aspect=aspect)</span>
        <span class="s1">super().set_aspect(</span>
            <span class="s1">aspect=</span><span class="s3">'auto'</span><span class="s2">, </span><span class="s1">adjustable=adjustable</span><span class="s2">, </span><span class="s1">anchor=anchor</span><span class="s2">, </span><span class="s1">share=share)</span>
        <span class="s1">self._aspect = aspect</span>

        <span class="s2">if </span><span class="s1">aspect </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'equal'</span><span class="s2">, </span><span class="s3">'equalxy'</span><span class="s2">, </span><span class="s3">'equalxz'</span><span class="s2">, </span><span class="s3">'equalyz'</span><span class="s1">):</span>
            <span class="s1">ax_indices = self._equal_aspect_axis_indices(aspect)</span>

            <span class="s1">view_intervals = np.array([self.xaxis.get_view_interval()</span><span class="s2">,</span>
                                       <span class="s1">self.yaxis.get_view_interval()</span><span class="s2">,</span>
                                       <span class="s1">self.zaxis.get_view_interval()])</span>
            <span class="s1">ptp = np.ptp(view_intervals</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self._adjustable == </span><span class="s3">'datalim'</span><span class="s1">:</span>
                <span class="s1">mean = np.mean(view_intervals</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">delta = max(ptp[ax_indices])</span>
                <span class="s1">scale = self._box_aspect[ptp == delta][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">deltas = delta * self._box_aspect / scale</span>

                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">set_lim </span><span class="s2">in </span><span class="s1">enumerate((self.set_xlim3d</span><span class="s2">,</span>
                                             <span class="s1">self.set_ylim3d</span><span class="s2">,</span>
                                             <span class="s1">self.set_zlim3d)):</span>
                    <span class="s2">if </span><span class="s1">i </span><span class="s2">in </span><span class="s1">ax_indices:</span>
                        <span class="s1">set_lim(mean[i] - deltas[i]/</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">mean[i] + deltas[i]/</span><span class="s4">2.</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s5"># 'box'</span>
                <span class="s5"># Change the box aspect such that the ratio of the length of</span>
                <span class="s5"># the unmodified axis to the length of the diagonal</span>
                <span class="s5"># perpendicular to it remains unchanged.</span>
                <span class="s1">box_aspect = np.array(self._box_aspect)</span>
                <span class="s1">box_aspect[ax_indices] = ptp[ax_indices]</span>
                <span class="s1">remaining_ax_indices = {</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">}.difference(ax_indices)</span>
                <span class="s2">if </span><span class="s1">remaining_ax_indices:</span>
                    <span class="s1">remaining = remaining_ax_indices.pop()</span>
                    <span class="s1">old_diag = np.linalg.norm(self._box_aspect[ax_indices])</span>
                    <span class="s1">new_diag = np.linalg.norm(box_aspect[ax_indices])</span>
                    <span class="s1">box_aspect[remaining] *= new_diag / old_diag</span>
                <span class="s1">self.set_box_aspect(box_aspect)</span>

    <span class="s2">def </span><span class="s1">_equal_aspect_axis_indices(self</span><span class="s2">, </span><span class="s1">aspect):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the indices for which of the x, y, z axes are constrained to have 
        equal aspect ratios. 
 
        Parameters 
        ---------- 
        aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'} 
            See descriptions in docstring for `.set_aspect()`. 
        &quot;&quot;&quot;</span>
        <span class="s1">ax_indices = []  </span><span class="s5"># aspect == 'auto'</span>
        <span class="s2">if </span><span class="s1">aspect == </span><span class="s3">'equal'</span><span class="s1">:</span>
            <span class="s1">ax_indices = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">aspect == </span><span class="s3">'equalxy'</span><span class="s1">:</span>
            <span class="s1">ax_indices = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">aspect == </span><span class="s3">'equalxz'</span><span class="s1">:</span>
            <span class="s1">ax_indices = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">aspect == </span><span class="s3">'equalyz'</span><span class="s1">:</span>
            <span class="s1">ax_indices = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">ax_indices</span>

    <span class="s2">def </span><span class="s1">set_box_aspect(self</span><span class="s2">, </span><span class="s1">aspect</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">zoom=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the Axes box aspect. 
 
        The box aspect is the ratio of height to width in display 
        units for each face of the box when viewed perpendicular to 
        that face.  This is not to be confused with the data aspect (see 
        `~.Axes3D.set_aspect`). The default ratios are 4:4:3 (x:y:z). 
 
        To simulate having equal aspect in data space, set the box 
        aspect to match your data range in each dimension. 
 
        *zoom* controls the overall size of the Axes3D in the figure. 
 
        Parameters 
        ---------- 
        aspect : 3-tuple of floats or None 
            Changes the physical dimensions of the Axes3D, such that the ratio 
            of the axis lengths in display units is x:y:z. 
            If None, defaults to (4, 4, 3). 
 
        zoom : float, default: 1 
            Control overall size of the Axes3D in the figure. Must be &gt; 0. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">zoom &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'Argument zoom = </span><span class="s2">{</span><span class="s1">zoom</span><span class="s2">} </span><span class="s3">must be &gt; 0'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">aspect </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">aspect = np.asarray((</span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">aspect = np.asarray(aspect</span><span class="s2">, </span><span class="s1">dtype=float)</span>
            <span class="s1">_api.check_shape((</span><span class="s4">3</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">aspect=aspect)</span>
        <span class="s5"># default scale tuned to match the mpl32 appearance.</span>
        <span class="s1">aspect *= </span><span class="s4">1.8294640721620434 </span><span class="s1">* zoom / np.linalg.norm(aspect)</span>

        <span class="s1">self._box_aspect = aspect</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">apply_aspect(self</span><span class="s2">, </span><span class="s1">position=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">position </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">position = self.get_position(original=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s5"># in the superclass, we would go through and actually deal with axis</span>
        <span class="s5"># scales and box/datalim. Those are all irrelevant - all we need to do</span>
        <span class="s5"># is make sure our coordinate system is square.</span>
        <span class="s1">trans = self.get_figure().transSubfigure</span>
        <span class="s1">bb = mtransforms.Bbox.unit().transformed(trans)</span>
        <span class="s5"># this is the physical aspect of the panel (or figure):</span>
        <span class="s1">fig_aspect = bb.height / bb.width</span>

        <span class="s1">box_aspect = </span><span class="s4">1</span>
        <span class="s1">pb = position.frozen()</span>
        <span class="s1">pb1 = pb.shrunk_to_aspect(box_aspect</span><span class="s2">, </span><span class="s1">pb</span><span class="s2">, </span><span class="s1">fig_aspect)</span>
        <span class="s1">self._set_position(pb1.anchored(self.get_anchor()</span><span class="s2">, </span><span class="s1">pb)</span><span class="s2">, </span><span class="s3">'active'</span><span class="s1">)</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">self._unstale_viewLim()</span>

        <span class="s5"># draw the background patch</span>
        <span class="s1">self.patch.draw(renderer)</span>
        <span class="s1">self._frameon = </span><span class="s2">False</span>

        <span class="s5"># first, set the aspect</span>
        <span class="s5"># this is duplicated from `axes._base._AxesBase.draw`</span>
        <span class="s5"># but must be called before any of the artist are drawn as</span>
        <span class="s5"># it adjusts the view limits and the size of the bounding box</span>
        <span class="s5"># of the Axes</span>
        <span class="s1">locator = self.get_axes_locator()</span>
        <span class="s1">self.apply_aspect(locator(self</span><span class="s2">, </span><span class="s1">renderer) </span><span class="s2">if </span><span class="s1">locator </span><span class="s2">else None</span><span class="s1">)</span>

        <span class="s5"># add the projection matrix to the renderer</span>
        <span class="s1">self.M = self.get_proj()</span>

        <span class="s1">collections_and_patches = (</span>
            <span class="s1">artist </span><span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">self._children</span>
            <span class="s2">if </span><span class="s1">isinstance(artist</span><span class="s2">, </span><span class="s1">(mcoll.Collection</span><span class="s2">, </span><span class="s1">mpatches.Patch))</span>
            <span class="s2">and </span><span class="s1">artist.get_visible())</span>
        <span class="s2">if </span><span class="s1">self.computed_zorder:</span>
            <span class="s5"># Calculate projection of collections and patches and zorder</span>
            <span class="s5"># them. Make sure they are drawn above the grids.</span>
            <span class="s1">zorder_offset = max(axis.get_zorder()</span>
                                <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self._axis_map.values()) + </span><span class="s4">1</span>
            <span class="s1">collection_zorder = patch_zorder = zorder_offset</span>

            <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">sorted(collections_and_patches</span><span class="s2">,</span>
                                 <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">artist: artist.do_3d_projection()</span><span class="s2">,</span>
                                 <span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>
                <span class="s2">if </span><span class="s1">isinstance(artist</span><span class="s2">, </span><span class="s1">mcoll.Collection):</span>
                    <span class="s1">artist.zorder = collection_zorder</span>
                    <span class="s1">collection_zorder += </span><span class="s4">1</span>
                <span class="s2">elif </span><span class="s1">isinstance(artist</span><span class="s2">, </span><span class="s1">mpatches.Patch):</span>
                    <span class="s1">artist.zorder = patch_zorder</span>
                    <span class="s1">patch_zorder += </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">collections_and_patches:</span>
                <span class="s1">artist.do_3d_projection()</span>

        <span class="s2">if </span><span class="s1">self._axis3don:</span>
            <span class="s5"># Draw panes first</span>
            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self._axis_map.values():</span>
                <span class="s1">axis.draw_pane(renderer)</span>
            <span class="s5"># Then axes</span>
            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self._axis_map.values():</span>
                <span class="s1">axis.draw(renderer)</span>

        <span class="s5"># Then rest</span>
        <span class="s1">super().draw(renderer)</span>

    <span class="s2">def </span><span class="s1">get_axis_position(self):</span>
        <span class="s1">vals = self.get_w_lims()</span>
        <span class="s1">tc = self._tunit_cube(vals</span><span class="s2">, </span><span class="s1">self.M)</span>
        <span class="s1">xhigh = tc[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] &gt; tc[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">yhigh = tc[</span><span class="s4">3</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] &gt; tc[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">zhigh = tc[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] &gt; tc[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">xhigh</span><span class="s2">, </span><span class="s1">yhigh</span><span class="s2">, </span><span class="s1">zhigh</span>

    <span class="s2">def </span><span class="s1">update_datalim(self</span><span class="s2">, </span><span class="s1">xys</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Not implemented in `~mpl_toolkits.mplot3d.axes3d.Axes3D`. 
        &quot;&quot;&quot;</span>
        <span class="s2">pass</span>

    <span class="s1">get_autoscalez_on = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;_get_autoscale_on&quot;</span><span class="s1">)</span>
    <span class="s1">set_autoscalez_on = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;_set_autoscale_on&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_zmargin(self</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set padding of Z data limits prior to autoscaling. 
 
        *m* times the data interval will be added to each end of that interval 
        before it is used in autoscaling.  If *m* is negative, this will clip 
        the data range instead of expanding it. 
 
        For example, if your data is in the range [0, 2], a margin of 0.1 will 
        result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range 
        of [0.2, 1.8]. 
 
        Parameters 
        ---------- 
        m : float greater than -0.5 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">m &lt;= -</span><span class="s4">0.5</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;margin must be greater than -0.5&quot;</span><span class="s1">)</span>
        <span class="s1">self._zmargin = m</span>
        <span class="s1">self._request_autoscale_view(</span><span class="s3">&quot;z&quot;</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">margins(self</span><span class="s2">, </span><span class="s1">*margins</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">z=</span><span class="s2">None, </span><span class="s1">tight=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set or retrieve autoscaling margins. 
 
        See `.Axes.margins` for full documentation.  Because this function 
        applies to 3D Axes, it also takes a *z* argument, and returns 
        ``(xmargin, ymargin, zmargin)``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">margins </span><span class="s2">and </span><span class="s1">(x </span><span class="s2">is not None or </span><span class="s1">y </span><span class="s2">is not None or </span><span class="s1">z </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot pass both positional and keyword '</span>
                            <span class="s3">'arguments for x, y, and/or z.'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">len(margins) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">x = y = z = margins[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">len(margins) == </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = margins</span>
        <span class="s2">elif </span><span class="s1">margins:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Must pass a single positional argument for all '</span>
                            <span class="s3">'margins, or one for each margin (x, y, z).'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None and </span><span class="s1">y </span><span class="s2">is None and </span><span class="s1">z </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">tight </span><span class="s2">is not True</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s3">f'ignoring tight=</span><span class="s2">{</span><span class="s1">tight</span><span class="s2">!r} </span><span class="s3">in get mode'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._xmargin</span><span class="s2">, </span><span class="s1">self._ymargin</span><span class="s2">, </span><span class="s1">self._zmargin</span>

        <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_xmargin(x)</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_ymargin(y)</span>
        <span class="s2">if </span><span class="s1">z </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_zmargin(z)</span>

        <span class="s1">self.autoscale_view(</span>
            <span class="s1">tight=tight</span><span class="s2">, </span><span class="s1">scalex=(x </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">scaley=(y </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">scalez=(z </span><span class="s2">is not None</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">autoscale(self</span><span class="s2">, </span><span class="s1">enable=</span><span class="s2">True, </span><span class="s1">axis=</span><span class="s3">'both'</span><span class="s2">, </span><span class="s1">tight=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convenience method for simple axis view autoscaling. 
 
        See `.Axes.autoscale` for full documentation.  Because this function 
        applies to 3D Axes, *axis* can also be set to 'z', and setting *axis* 
        to 'both' autoscales all three axes. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">enable </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">scalex = </span><span class="s2">True</span>
            <span class="s1">scaley = </span><span class="s2">True</span>
            <span class="s1">scalez = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscalex_on(bool(enable))</span>
                <span class="s1">scalex = self.get_autoscalex_on()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">scalex = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscaley_on(bool(enable))</span>
                <span class="s1">scaley = self.get_autoscaley_on()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">scaley = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'z'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscalez_on(bool(enable))</span>
                <span class="s1">scalez = self.get_autoscalez_on()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">scalez = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">scalex:</span>
            <span class="s1">self._request_autoscale_view(</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">tight=tight)</span>
        <span class="s2">if </span><span class="s1">scaley:</span>
            <span class="s1">self._request_autoscale_view(</span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s1">tight=tight)</span>
        <span class="s2">if </span><span class="s1">scalez:</span>
            <span class="s1">self._request_autoscale_view(</span><span class="s3">&quot;z&quot;</span><span class="s2">, </span><span class="s1">tight=tight)</span>

    <span class="s2">def </span><span class="s1">auto_scale_xyz(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z=</span><span class="s2">None, </span><span class="s1">had_data=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5"># This updates the bounding boxes as to keep a record as to what the</span>
        <span class="s5"># minimum sized rectangular volume holds the data.</span>
        <span class="s2">if </span><span class="s1">np.shape(X) == np.shape(Y):</span>
            <span class="s1">self.xy_dataLim.update_from_data_xy(</span>
                <span class="s1">np.column_stack([np.ravel(X)</span><span class="s2">, </span><span class="s1">np.ravel(Y)])</span><span class="s2">, not </span><span class="s1">had_data)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.xy_dataLim.update_from_data_x(X</span><span class="s2">, not </span><span class="s1">had_data)</span>
            <span class="s1">self.xy_dataLim.update_from_data_y(Y</span><span class="s2">, not </span><span class="s1">had_data)</span>
        <span class="s2">if </span><span class="s1">Z </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.zz_dataLim.update_from_data_x(Z</span><span class="s2">, not </span><span class="s1">had_data)</span>
        <span class="s5"># Let autoscale_view figure out how to use this data.</span>
        <span class="s1">self.autoscale_view()</span>

    <span class="s2">def </span><span class="s1">autoscale_view(self</span><span class="s2">, </span><span class="s1">tight=</span><span class="s2">None, </span><span class="s1">scalex=</span><span class="s2">True, </span><span class="s1">scaley=</span><span class="s2">True,</span>
                       <span class="s1">scalez=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Autoscale the view limits using the data limits. 
 
        See `.Axes.autoscale_view` for full documentation.  Because this 
        function applies to 3D Axes, it also takes a *scalez* argument. 
        &quot;&quot;&quot;</span>
        <span class="s5"># This method looks at the rectangular volume (see above)</span>
        <span class="s5"># of data and decides how to scale the view portal to fit it.</span>
        <span class="s2">if </span><span class="s1">tight </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">_tight = self._tight</span>
            <span class="s2">if not </span><span class="s1">_tight:</span>
                <span class="s5"># if image data only just use the datalim</span>
                <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">self._children:</span>
                    <span class="s2">if </span><span class="s1">isinstance(artist</span><span class="s2">, </span><span class="s1">mimage.AxesImage):</span>
                        <span class="s1">_tight = </span><span class="s2">True</span>
                    <span class="s2">elif </span><span class="s1">isinstance(artist</span><span class="s2">, </span><span class="s1">(mlines.Line2D</span><span class="s2">, </span><span class="s1">mpatches.Patch)):</span>
                        <span class="s1">_tight = </span><span class="s2">False</span>
                        <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_tight = self._tight = bool(tight)</span>

        <span class="s2">if </span><span class="s1">scalex </span><span class="s2">and </span><span class="s1">self.get_autoscalex_on():</span>
            <span class="s1">self._shared_axes[</span><span class="s3">&quot;x&quot;</span><span class="s1">].clean()</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 = self.xy_dataLim.intervalx</span>
            <span class="s1">xlocator = self.xaxis.get_major_locator()</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 = xlocator.nonsingular(x0</span><span class="s2">, </span><span class="s1">x1)</span>
            <span class="s2">if </span><span class="s1">self._xmargin &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">delta = (x1 - x0) * self._xmargin</span>
                <span class="s1">x0 -= delta</span>
                <span class="s1">x1 += delta</span>
            <span class="s2">if not </span><span class="s1">_tight:</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 = xlocator.view_limits(x0</span><span class="s2">, </span><span class="s1">x1)</span>
            <span class="s1">self.set_xbound(x0</span><span class="s2">, </span><span class="s1">x1)</span>

        <span class="s2">if </span><span class="s1">scaley </span><span class="s2">and </span><span class="s1">self.get_autoscaley_on():</span>
            <span class="s1">self._shared_axes[</span><span class="s3">&quot;y&quot;</span><span class="s1">].clean()</span>
            <span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = self.xy_dataLim.intervaly</span>
            <span class="s1">ylocator = self.yaxis.get_major_locator()</span>
            <span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = ylocator.nonsingular(y0</span><span class="s2">, </span><span class="s1">y1)</span>
            <span class="s2">if </span><span class="s1">self._ymargin &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">delta = (y1 - y0) * self._ymargin</span>
                <span class="s1">y0 -= delta</span>
                <span class="s1">y1 += delta</span>
            <span class="s2">if not </span><span class="s1">_tight:</span>
                <span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = ylocator.view_limits(y0</span><span class="s2">, </span><span class="s1">y1)</span>
            <span class="s1">self.set_ybound(y0</span><span class="s2">, </span><span class="s1">y1)</span>

        <span class="s2">if </span><span class="s1">scalez </span><span class="s2">and </span><span class="s1">self.get_autoscalez_on():</span>
            <span class="s1">self._shared_axes[</span><span class="s3">&quot;z&quot;</span><span class="s1">].clean()</span>
            <span class="s1">z0</span><span class="s2">, </span><span class="s1">z1 = self.zz_dataLim.intervalx</span>
            <span class="s1">zlocator = self.zaxis.get_major_locator()</span>
            <span class="s1">z0</span><span class="s2">, </span><span class="s1">z1 = zlocator.nonsingular(z0</span><span class="s2">, </span><span class="s1">z1)</span>
            <span class="s2">if </span><span class="s1">self._zmargin &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">delta = (z1 - z0) * self._zmargin</span>
                <span class="s1">z0 -= delta</span>
                <span class="s1">z1 += delta</span>
            <span class="s2">if not </span><span class="s1">_tight:</span>
                <span class="s1">z0</span><span class="s2">, </span><span class="s1">z1 = zlocator.view_limits(z0</span><span class="s2">, </span><span class="s1">z1)</span>
            <span class="s1">self.set_zbound(z0</span><span class="s2">, </span><span class="s1">z1)</span>

    <span class="s2">def </span><span class="s1">get_w_lims(self):</span>
        <span class="s0">&quot;&quot;&quot;Get 3D world limits.&quot;&quot;&quot;</span>
        <span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx = self.get_xlim3d()</span>
        <span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy = self.get_ylim3d()</span>
        <span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz = self.get_zlim3d()</span>
        <span class="s2">return </span><span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz</span>

    <span class="s5"># set_xlim, set_ylim are directly inherited from base Axes.</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s3">&quot;emit&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_zlim(self</span><span class="s2">, </span><span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">top=</span><span class="s2">None, </span><span class="s1">emit=</span><span class="s2">True, </span><span class="s1">auto=</span><span class="s2">False,</span>
                 <span class="s1">*</span><span class="s2">, </span><span class="s1">zmin=</span><span class="s2">None, </span><span class="s1">zmax=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set 3D z limits. 
 
        See `.Axes.set_ylim` for full documentation 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">top </span><span class="s2">is None and </span><span class="s1">np.iterable(bottom):</span>
            <span class="s1">bottom</span><span class="s2">, </span><span class="s1">top = bottom</span>
        <span class="s2">if </span><span class="s1">zmin </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">bottom </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot pass both 'bottom' and 'zmin'&quot;</span><span class="s1">)</span>
            <span class="s1">bottom = zmin</span>
        <span class="s2">if </span><span class="s1">zmax </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">top </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot pass both 'top' and 'zmax'&quot;</span><span class="s1">)</span>
            <span class="s1">top = zmax</span>
        <span class="s2">return </span><span class="s1">self.zaxis._set_lim(bottom</span><span class="s2">, </span><span class="s1">top</span><span class="s2">, </span><span class="s1">emit=emit</span><span class="s2">, </span><span class="s1">auto=auto)</span>

    <span class="s1">set_xlim3d = maxes.Axes.set_xlim</span>
    <span class="s1">set_ylim3d = maxes.Axes.set_ylim</span>
    <span class="s1">set_zlim3d = set_zlim</span>

    <span class="s2">def </span><span class="s1">get_xlim(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">tuple(self.xy_viewLim.intervalx)</span>

    <span class="s2">def </span><span class="s1">get_ylim(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">tuple(self.xy_viewLim.intervaly)</span>

    <span class="s2">def </span><span class="s1">get_zlim(self):</span>
        <span class="s0">&quot;&quot;&quot;Get 3D z limits.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(self.zz_viewLim.intervalx)</span>

    <span class="s1">get_zscale = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_scale&quot;</span><span class="s1">)</span>

    <span class="s5"># Redefine all three methods to overwrite their docstrings.</span>
    <span class="s1">set_xscale = _axis_method_wrapper(</span><span class="s3">&quot;xaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;_set_axes_scale&quot;</span><span class="s1">)</span>
    <span class="s1">set_yscale = _axis_method_wrapper(</span><span class="s3">&quot;yaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;_set_axes_scale&quot;</span><span class="s1">)</span>
    <span class="s1">set_zscale = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;_set_axes_scale&quot;</span><span class="s1">)</span>
    <span class="s1">set_xscale.__doc__</span><span class="s2">, </span><span class="s1">set_yscale.__doc__</span><span class="s2">, </span><span class="s1">set_zscale.__doc__ = map(</span>
        <span class="s3">&quot;&quot;&quot; 
        Set the {}-axis scale. 
 
        Parameters 
        ---------- 
        value : {{&quot;linear&quot;}} 
            The axis scale type to apply.  3D axes currently only support 
            linear scales; other scales yield nonsensical results. 
 
        **kwargs 
            Keyword arguments are nominally forwarded to the scale class, but 
            none of them is applicable for linear scales. 
        &quot;&quot;&quot;</span><span class="s1">.format</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s3">&quot;z&quot;</span><span class="s1">])</span>

    <span class="s1">get_zticks = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_ticklocs&quot;</span><span class="s1">)</span>
    <span class="s1">set_zticks = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;set_ticks&quot;</span><span class="s1">)</span>
    <span class="s1">get_zmajorticklabels = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_majorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_zminorticklabels = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_minorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_zticklabels = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_ticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">set_zticklabels = _axis_method_wrapper(</span>
        <span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;set_ticklabels&quot;</span><span class="s2">,</span>
        <span class="s1">doc_sub={</span><span class="s3">&quot;Axis.set_ticks&quot;</span><span class="s1">: </span><span class="s3">&quot;Axes3D.set_zticks&quot;</span><span class="s1">})</span>

    <span class="s1">zaxis_date = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;axis_date&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">zaxis_date.__doc__:</span>
        <span class="s1">zaxis_date.__doc__ += textwrap.dedent(</span><span class="s3">&quot;&quot;&quot; 
 
        Notes 
        ----- 
        This function is merely provided for completeness, but 3D axes do not 
        support dates for ticks, and so this may not work as expected. 
        &quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">clabel(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Currently not implemented for 3D axes, and returns *None*.&quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">view_init(self</span><span class="s2">, </span><span class="s1">elev=</span><span class="s2">None, </span><span class="s1">azim=</span><span class="s2">None, </span><span class="s1">roll=</span><span class="s2">None, </span><span class="s1">vertical_axis=</span><span class="s3">&quot;z&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the elevation and azimuth of the axes in degrees (not radians). 
 
        This can be used to rotate the axes programmatically. 
 
        To look normal to the primary planes, the following elevation and 
        azimuth angles can be used. A roll angle of 0, 90, 180, or 270 deg 
        will rotate these views while keeping the axes at right angles. 
 
        ==========   ====  ==== 
        view plane   elev  azim 
        ==========   ====  ==== 
        XY           90    -90 
        XZ           0     -90 
        YZ           0     0 
        -XY          -90   90 
        -XZ          0     90 
        -YZ          0     180 
        ==========   ====  ==== 
 
        Parameters 
        ---------- 
        elev : float, default: None 
            The elevation angle in degrees rotates the camera above the plane 
            pierced by the vertical axis, with a positive angle corresponding 
            to a location above that plane. For example, with the default 
            vertical axis of 'z', the elevation defines the angle of the camera 
            location above the x-y plane. 
            If None, then the initial value as specified in the `Axes3D` 
            constructor is used. 
        azim : float, default: None 
            The azimuthal angle in degrees rotates the camera about the 
            vertical axis, with a positive angle corresponding to a 
            right-handed rotation. For example, with the default vertical axis 
            of 'z', a positive azimuth rotates the camera about the origin from 
            its location along the +x axis towards the +y axis. 
            If None, then the initial value as specified in the `Axes3D` 
            constructor is used. 
        roll : float, default: None 
            The roll angle in degrees rotates the camera about the viewing 
            axis. A positive angle spins the camera clockwise, causing the 
            scene to rotate counter-clockwise. 
            If None, then the initial value as specified in the `Axes3D` 
            constructor is used. 
        vertical_axis : {&quot;z&quot;, &quot;x&quot;, &quot;y&quot;}, default: &quot;z&quot; 
            The axis to align vertically. *azim* rotates about this axis. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._dist = </span><span class="s4">10  </span><span class="s5"># The camera distance from origin. Behaves like zoom</span>

        <span class="s2">if </span><span class="s1">elev </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.elev = self.initial_elev</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.elev = elev</span>

        <span class="s2">if </span><span class="s1">azim </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.azim = self.initial_azim</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.azim = azim</span>

        <span class="s2">if </span><span class="s1">roll </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.roll = self.initial_roll</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.roll = roll</span>

        <span class="s1">self._vertical_axis = _api.check_getitem(</span>
            <span class="s1">dict(x=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">z=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">vertical_axis=vertical_axis</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_proj_type(self</span><span class="s2">, </span><span class="s1">proj_type</span><span class="s2">, </span><span class="s1">focal_length=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the projection type. 
 
        Parameters 
        ---------- 
        proj_type : {'persp', 'ortho'} 
            The projection type. 
        focal_length : float, default: None 
            For a projection type of 'persp', the focal length of the virtual 
            camera. Must be &gt; 0. If None, defaults to 1. 
            The focal length can be computed from a desired Field Of View via 
            the equation: focal_length = 1/tan(FOV/2) 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s3">'persp'</span><span class="s2">, </span><span class="s3">'ortho'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">proj_type=proj_type)</span>
        <span class="s2">if </span><span class="s1">proj_type == </span><span class="s3">'persp'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">focal_length </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">focal_length = </span><span class="s4">1</span>
            <span class="s2">elif </span><span class="s1">focal_length &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;focal_length = </span><span class="s2">{</span><span class="s1">focal_length</span><span class="s2">} </span><span class="s3">must be &quot;</span>
                                 <span class="s3">&quot;greater than 0&quot;</span><span class="s1">)</span>
            <span class="s1">self._focal_length = focal_length</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># 'ortho':</span>
            <span class="s2">if </span><span class="s1">focal_length </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None, </span><span class="s1">np.inf):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;focal_length = </span><span class="s2">{</span><span class="s1">focal_length</span><span class="s2">} </span><span class="s3">must be &quot;</span>
                                 <span class="s3">f&quot;None for proj_type = </span><span class="s2">{</span><span class="s1">proj_type</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">self._focal_length = np.inf</span>

    <span class="s2">def </span><span class="s1">_roll_to_vertical(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s0">&quot;&quot;&quot;Roll arrays to match the different vertical axis.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.roll(arr</span><span class="s2">, </span><span class="s1">self._vertical_axis - </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_proj(self):</span>
        <span class="s0">&quot;&quot;&quot;Create the projection matrix from the current viewing position.&quot;&quot;&quot;</span>

        <span class="s5"># Transform to uniform world coordinates 0-1, 0-1, 0-1</span>
        <span class="s1">box_aspect = self._roll_to_vertical(self._box_aspect)</span>
        <span class="s1">worldM = proj3d.world_transformation(</span>
            <span class="s1">*self.get_xlim3d()</span><span class="s2">,</span>
            <span class="s1">*self.get_ylim3d()</span><span class="s2">,</span>
            <span class="s1">*self.get_zlim3d()</span><span class="s2">,</span>
            <span class="s1">pb_aspect=box_aspect</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s5"># Look into the middle of the world coordinates:</span>
        <span class="s1">R = </span><span class="s4">0.5 </span><span class="s1">* box_aspect</span>

        <span class="s5"># elev stores the elevation angle in the z plane</span>
        <span class="s5"># azim stores the azimuth angle in the x,y plane</span>
        <span class="s1">elev_rad = np.deg2rad(art3d._norm_angle(self.elev))</span>
        <span class="s1">azim_rad = np.deg2rad(art3d._norm_angle(self.azim))</span>

        <span class="s5"># Coordinates for a point that rotates around the box of data.</span>
        <span class="s5"># p0, p1 corresponds to rotating the box only around the</span>
        <span class="s5"># vertical axis.</span>
        <span class="s5"># p2 corresponds to rotating the box only around the horizontal</span>
        <span class="s5"># axis.</span>
        <span class="s1">p0 = np.cos(elev_rad) * np.cos(azim_rad)</span>
        <span class="s1">p1 = np.cos(elev_rad) * np.sin(azim_rad)</span>
        <span class="s1">p2 = np.sin(elev_rad)</span>

        <span class="s5"># When changing vertical axis the coordinates changes as well.</span>
        <span class="s5"># Roll the values to get the same behaviour as the default:</span>
        <span class="s1">ps = self._roll_to_vertical([p0</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2])</span>

        <span class="s5"># The coordinates for the eye viewing point. The eye is looking</span>
        <span class="s5"># towards the middle of the box of data from a distance:</span>
        <span class="s1">eye = R + self._dist * ps</span>

        <span class="s5"># vvec, self._vvec and self._eye are unused, remove when deprecated</span>
        <span class="s1">vvec = R - eye</span>
        <span class="s1">self._eye = eye</span>
        <span class="s1">self._vvec = vvec / np.linalg.norm(vvec)</span>

        <span class="s5"># Calculate the viewing axes for the eye position</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w = self._calc_view_axes(eye)</span>
        <span class="s1">self._view_u = u  </span><span class="s5"># _view_u is towards the right of the screen</span>
        <span class="s1">self._view_v = v  </span><span class="s5"># _view_v is towards the top of the screen</span>
        <span class="s1">self._view_w = w  </span><span class="s5"># _view_w is out of the screen</span>

        <span class="s5"># Generate the view and projection transformation matrices</span>
        <span class="s2">if </span><span class="s1">self._focal_length == np.inf:</span>
            <span class="s5"># Orthographic projection</span>
            <span class="s1">viewM = proj3d._view_transformation_uvw(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">eye)</span>
            <span class="s1">projM = proj3d.ortho_transformation(-self._dist</span><span class="s2">, </span><span class="s1">self._dist)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Perspective projection</span>
            <span class="s5"># Scale the eye dist to compensate for the focal length zoom effect</span>
            <span class="s1">eye_focal = R + self._dist * ps * self._focal_length</span>
            <span class="s1">viewM = proj3d._view_transformation_uvw(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">eye_focal)</span>
            <span class="s1">projM = proj3d.persp_transformation(-self._dist</span><span class="s2">,</span>
                                                <span class="s1">self._dist</span><span class="s2">,</span>
                                                <span class="s1">self._focal_length)</span>

        <span class="s5"># Combine all the transformation matrices to get the final projection</span>
        <span class="s1">M0 = np.dot(viewM</span><span class="s2">, </span><span class="s1">worldM)</span>
        <span class="s1">M = np.dot(projM</span><span class="s2">, </span><span class="s1">M0)</span>
        <span class="s2">return </span><span class="s1">M</span>

    <span class="s2">def </span><span class="s1">mouse_init(self</span><span class="s2">, </span><span class="s1">rotate_btn=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">pan_btn=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">zoom_btn=</span><span class="s4">3</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the mouse buttons for 3D rotation and zooming. 
 
        Parameters 
        ---------- 
        rotate_btn : int or list of int, default: 1 
            The mouse button or buttons to use for 3D rotation of the axes. 
        pan_btn : int or list of int, default: 2 
            The mouse button or buttons to use to pan the 3D axes. 
        zoom_btn : int or list of int, default: 3 
            The mouse button or buttons to use to zoom the 3D axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.button_pressed = </span><span class="s2">None</span>
        <span class="s5"># coerce scalars into array-like, then convert into</span>
        <span class="s5"># a regular list to avoid comparisons against None</span>
        <span class="s5"># which breaks in recent versions of numpy.</span>
        <span class="s1">self._rotate_btn = np.atleast_1d(rotate_btn).tolist()</span>
        <span class="s1">self._pan_btn = np.atleast_1d(pan_btn).tolist()</span>
        <span class="s1">self._zoom_btn = np.atleast_1d(zoom_btn).tolist()</span>

    <span class="s2">def </span><span class="s1">disable_mouse_rotation(self):</span>
        <span class="s0">&quot;&quot;&quot;Disable mouse buttons for 3D rotation, panning, and zooming.&quot;&quot;&quot;</span>
        <span class="s1">self.mouse_init(rotate_btn=[]</span><span class="s2">, </span><span class="s1">pan_btn=[]</span><span class="s2">, </span><span class="s1">zoom_btn=[])</span>

    <span class="s2">def </span><span class="s1">can_zoom(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether this Axes supports the zoom box button functionality. 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">can_pan(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether this Axes supports the pan button functionality. 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">sharez(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Share the z-axis with *other*. 
 
        This is equivalent to passing ``sharez=other`` when constructing the 
        Axes, and cannot be used if the z-axis is already being shared with 
        another Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(maxes._base._AxesBase</span><span class="s2">, </span><span class="s1">other=other)</span>
        <span class="s2">if </span><span class="s1">self._sharez </span><span class="s2">is not None and </span><span class="s1">other </span><span class="s2">is not </span><span class="s1">self._sharez:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;z-axis is already shared&quot;</span><span class="s1">)</span>
        <span class="s1">self._shared_axes[</span><span class="s3">&quot;z&quot;</span><span class="s1">].join(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">self._sharez = other</span>
        <span class="s1">self.zaxis.major = other.zaxis.major  </span><span class="s5"># Ticker instances holding</span>
        <span class="s1">self.zaxis.minor = other.zaxis.minor  </span><span class="s5"># locator and formatter.</span>
        <span class="s1">z0</span><span class="s2">, </span><span class="s1">z1 = other.get_zlim()</span>
        <span class="s1">self.set_zlim(z0</span><span class="s2">, </span><span class="s1">z1</span><span class="s2">, </span><span class="s1">emit=</span><span class="s2">False, </span><span class="s1">auto=other.get_autoscalez_on())</span>
        <span class="s1">self.zaxis._scale = other.zaxis._scale</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s5"># docstring inherited.</span>
        <span class="s1">super().clear()</span>
        <span class="s2">if </span><span class="s1">self._focal_length == np.inf:</span>
            <span class="s1">self._zmargin = mpl.rcParams[</span><span class="s3">'axes.zmargin'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._zmargin = </span><span class="s4">0.</span>
        <span class="s1">self.grid(mpl.rcParams[</span><span class="s3">'axes3d.grid'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_button_press(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s2">if </span><span class="s1">event.inaxes == self:</span>
            <span class="s1">self.button_pressed = event.button</span>
            <span class="s1">self._sx</span><span class="s2">, </span><span class="s1">self._sy = event.xdata</span><span class="s2">, </span><span class="s1">event.ydata</span>
            <span class="s1">toolbar = getattr(self.figure.canvas</span><span class="s2">, </span><span class="s3">&quot;toolbar&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">and </span><span class="s1">toolbar._nav_stack() </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self.figure.canvas.toolbar.push_current()</span>

    <span class="s2">def </span><span class="s1">_button_release(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s1">self.button_pressed = </span><span class="s2">None</span>
        <span class="s1">toolbar = getattr(self.figure.canvas</span><span class="s2">, </span><span class="s3">&quot;toolbar&quot;</span><span class="s1">)</span>
        <span class="s5"># backend_bases.release_zoom and backend_bases.release_pan call</span>
        <span class="s5"># push_current, so check the navigation mode so we don't call it twice</span>
        <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">and </span><span class="s1">self.get_navigate_mode() </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.figure.canvas.toolbar.push_current()</span>

    <span class="s2">def </span><span class="s1">_get_view(self):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">(self.get_xlim()</span><span class="s2">, </span><span class="s1">self.get_ylim()</span><span class="s2">, </span><span class="s1">self.get_zlim()</span><span class="s2">,</span>
                <span class="s1">self.elev</span><span class="s2">, </span><span class="s1">self.azim</span><span class="s2">, </span><span class="s1">self.roll)</span>

    <span class="s2">def </span><span class="s1">_set_view(self</span><span class="s2">, </span><span class="s1">view):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">xlim</span><span class="s2">, </span><span class="s1">ylim</span><span class="s2">, </span><span class="s1">zlim</span><span class="s2">, </span><span class="s1">elev</span><span class="s2">, </span><span class="s1">azim</span><span class="s2">, </span><span class="s1">roll = view</span>
        <span class="s1">self.set(xlim=xlim</span><span class="s2">, </span><span class="s1">ylim=ylim</span><span class="s2">, </span><span class="s1">zlim=zlim)</span>
        <span class="s1">self.elev = elev</span>
        <span class="s1">self.azim = azim</span>
        <span class="s1">self.roll = roll</span>

    <span class="s2">def </span><span class="s1">format_zdata(self</span><span class="s2">, </span><span class="s1">z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return *z* string formatted.  This function will use the 
        :attr:`fmt_zdata` attribute if it is callable, else will fall 
        back on the zaxis major formatter 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fmt_zdata(z)</span>
        <span class="s2">except </span><span class="s1">(AttributeError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s1">func = self.zaxis.get_major_formatter().format_data_short</span>
            <span class="s1">val = func(z)</span>
            <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">format_coord(self</span><span class="s2">, </span><span class="s1">xd</span><span class="s2">, </span><span class="s1">yd):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given the 2D view coordinates attempt to guess a 3D coordinate. 
        Looks for the nearest edge to the point and then assumes that 
        the point is at the same z location as the nearest point on the edge. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.M </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">''</span>

        <span class="s2">if </span><span class="s1">self.button_pressed </span><span class="s2">in </span><span class="s1">self._rotate_btn:</span>
            <span class="s5"># ignore xd and yd and display angles instead</span>
            <span class="s1">norm_elev = art3d._norm_angle(self.elev)</span>
            <span class="s1">norm_azim = art3d._norm_angle(self.azim)</span>
            <span class="s1">norm_roll = art3d._norm_angle(self.roll)</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s3">f&quot;elevation=</span><span class="s2">{</span><span class="s1">norm_elev</span><span class="s2">:</span><span class="s3">.0f</span><span class="s2">}\N{DEGREE SIGN}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;azimuth=</span><span class="s2">{</span><span class="s1">norm_azim</span><span class="s2">:</span><span class="s3">.0f</span><span class="s2">}\N{DEGREE SIGN}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;roll=</span><span class="s2">{</span><span class="s1">norm_roll</span><span class="s2">:</span><span class="s3">.0f</span><span class="s2">}\N{DEGREE SIGN}</span><span class="s3">&quot;</span>
                    <span class="s1">).replace(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\N{MINUS SIGN}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s5"># nearest edge</span>
        <span class="s1">p0</span><span class="s2">, </span><span class="s1">p1 = min(self._tunit_edges()</span><span class="s2">,</span>
                     <span class="s1">key=</span><span class="s2">lambda </span><span class="s1">edge: proj3d._line2d_seg_dist(</span>
                         <span class="s1">(xd</span><span class="s2">, </span><span class="s1">yd)</span><span class="s2">, </span><span class="s1">edge[</span><span class="s4">0</span><span class="s1">][:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">edge[</span><span class="s4">1</span><span class="s1">][:</span><span class="s4">2</span><span class="s1">]))</span>

        <span class="s5"># scale the z value to match</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">z0 = p0</span>
        <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">z1 = p1</span>
        <span class="s1">d0 = np.hypot(x0-xd</span><span class="s2">, </span><span class="s1">y0-yd)</span>
        <span class="s1">d1 = np.hypot(x1-xd</span><span class="s2">, </span><span class="s1">y1-yd)</span>
        <span class="s1">dt = d0+d1</span>
        <span class="s1">z = d1/dt * z0 + d0/dt * z1</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = proj3d.inv_transform(xd</span><span class="s2">, </span><span class="s1">yd</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">self.M)</span>

        <span class="s1">xs = self.format_xdata(x)</span>
        <span class="s1">ys = self.format_ydata(y)</span>
        <span class="s1">zs = self.format_zdata(z)</span>
        <span class="s2">return </span><span class="s3">'x=%s, y=%s, z=%s' </span><span class="s1">% (xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs)</span>

    <span class="s2">def </span><span class="s1">_on_move(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot; 
        Mouse moving. 
 
        By default, button-1 rotates, button-2 pans, and button-3 zooms; 
        these buttons can be modified via `mouse_init`. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">self.button_pressed:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.get_navigate_mode() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># we don't want to rotate if we are zooming/panning</span>
            <span class="s5"># from the toolbar</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.M </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = event.xdata</span><span class="s2">, </span><span class="s1">event.ydata</span>
        <span class="s5"># In case the mouse is out of bounds.</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None or </span><span class="s1">event.inaxes != self:</span>
            <span class="s2">return</span>

        <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x - self._sx</span><span class="s2">, </span><span class="s1">y - self._sy</span>
        <span class="s1">w = self._pseudo_w</span>
        <span class="s1">h = self._pseudo_h</span>

        <span class="s5"># Rotation</span>
        <span class="s2">if </span><span class="s1">self.button_pressed </span><span class="s2">in </span><span class="s1">self._rotate_btn:</span>
            <span class="s5"># rotate viewing point</span>
            <span class="s5"># get the x and y pixel coords</span>
            <span class="s2">if </span><span class="s1">dx == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">dy == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">return</span>

            <span class="s1">roll = np.deg2rad(self.roll)</span>
            <span class="s1">delev = -(dy/h)*</span><span class="s4">180</span><span class="s1">*np.cos(roll) + (dx/w)*</span><span class="s4">180</span><span class="s1">*np.sin(roll)</span>
            <span class="s1">dazim = -(dy/h)*</span><span class="s4">180</span><span class="s1">*np.sin(roll) - (dx/w)*</span><span class="s4">180</span><span class="s1">*np.cos(roll)</span>
            <span class="s1">self.elev = self.elev + delev</span>
            <span class="s1">self.azim = self.azim + dazim</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>

        <span class="s2">elif </span><span class="s1">self.button_pressed </span><span class="s2">in </span><span class="s1">self._pan_btn:</span>
            <span class="s5"># Start the pan event with pixel coordinates</span>
            <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.transData.transform([self._sx</span><span class="s2">, </span><span class="s1">self._sy])</span>
            <span class="s1">self.start_pan(px</span><span class="s2">, </span><span class="s1">py</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s5"># pan view (takes pixel coordinate input)</span>
            <span class="s1">self.drag_pan(</span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">event.x</span><span class="s2">, </span><span class="s1">event.y)</span>
            <span class="s1">self.end_pan()</span>

        <span class="s5"># Zoom</span>
        <span class="s2">elif </span><span class="s1">self.button_pressed </span><span class="s2">in </span><span class="s1">self._zoom_btn:</span>
            <span class="s5"># zoom view (dragging down zooms in)</span>
            <span class="s1">scale = h/(h - dy)</span>
            <span class="s1">self._scale_axis_limits(scale</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">scale)</span>

        <span class="s5"># Store the event coordinates for the next time through.</span>
        <span class="s1">self._sx</span><span class="s2">, </span><span class="s1">self._sy = x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s5"># Always request a draw update at the end of interaction</span>
        <span class="s1">self.figure.canvas.draw_idle()</span>

    <span class="s2">def </span><span class="s1">drag_pan(self</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s5"># docstring inherited</span>

        <span class="s5"># Get the coordinates from the move event</span>
        <span class="s1">p = self._pan_start</span>
        <span class="s1">(xdata</span><span class="s2">, </span><span class="s1">ydata)</span><span class="s2">, </span><span class="s1">(xdata_start</span><span class="s2">, </span><span class="s1">ydata_start) = p.trans_inverse.transform(</span>
            <span class="s1">[(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">(p.x</span><span class="s2">, </span><span class="s1">p.y)])</span>
        <span class="s1">self._sx</span><span class="s2">, </span><span class="s1">self._sy = xdata</span><span class="s2">, </span><span class="s1">ydata</span>
        <span class="s5"># Calling start_pan() to set the x/y of this event as the starting</span>
        <span class="s5"># move location for the next event</span>
        <span class="s1">self.start_pan(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button)</span>
        <span class="s1">du</span><span class="s2">, </span><span class="s1">dv = xdata - xdata_start</span><span class="s2">, </span><span class="s1">ydata - ydata_start</span>
        <span class="s1">dw = </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">key == </span><span class="s3">'x'</span><span class="s1">:</span>
            <span class="s1">dv = </span><span class="s4">0</span>
        <span class="s2">elif </span><span class="s1">key == </span><span class="s3">'y'</span><span class="s1">:</span>
            <span class="s1">du = </span><span class="s4">0</span>
        <span class="s2">if </span><span class="s1">du == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">dv == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s5"># Transform the pan from the view axes to the data axes</span>
        <span class="s1">R = np.array([self._view_u</span><span class="s2">, </span><span class="s1">self._view_v</span><span class="s2">, </span><span class="s1">self._view_w])</span>
        <span class="s1">R = -R / self._box_aspect * self._dist</span>
        <span class="s1">duvw_projected = R.T @ np.array([du</span><span class="s2">, </span><span class="s1">dv</span><span class="s2">, </span><span class="s1">dw])</span>

        <span class="s5"># Calculate pan distance</span>
        <span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz = self.get_w_lims()</span>
        <span class="s1">dx = (maxx - minx) * duvw_projected[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">dy = (maxy - miny) * duvw_projected[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">dz = (maxz - minz) * duvw_projected[</span><span class="s4">2</span><span class="s1">]</span>

        <span class="s5"># Set the new axis limits</span>
        <span class="s1">self.set_xlim3d(minx + dx</span><span class="s2">, </span><span class="s1">maxx + dx)</span>
        <span class="s1">self.set_ylim3d(miny + dy</span><span class="s2">, </span><span class="s1">maxy + dy)</span>
        <span class="s1">self.set_zlim3d(minz + dz</span><span class="s2">, </span><span class="s1">maxz + dz)</span>

    <span class="s2">def </span><span class="s1">_calc_view_axes(self</span><span class="s2">, </span><span class="s1">eye):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the unit vectors for the viewing axes in data coordinates. 
        `u` is towards the right of the screen 
        `v` is towards the top of the screen 
        `w` is out of the screen 
        &quot;&quot;&quot;</span>
        <span class="s1">elev_rad = np.deg2rad(art3d._norm_angle(self.elev))</span>
        <span class="s1">roll_rad = np.deg2rad(art3d._norm_angle(self.roll))</span>

        <span class="s5"># Look into the middle of the world coordinates</span>
        <span class="s1">R = </span><span class="s4">0.5 </span><span class="s1">* self._roll_to_vertical(self._box_aspect)</span>

        <span class="s5"># Define which axis should be vertical. A negative value</span>
        <span class="s5"># indicates the plot is upside down and therefore the values</span>
        <span class="s5"># have been reversed:</span>
        <span class="s1">V = np.zeros(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">V[self._vertical_axis] = -</span><span class="s4">1 </span><span class="s2">if </span><span class="s1">abs(elev_rad) &gt; np.pi/</span><span class="s4">2 </span><span class="s2">else </span><span class="s4">1</span>

        <span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w = proj3d._view_axes(eye</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">roll_rad)</span>
        <span class="s2">return </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w</span>

    <span class="s2">def </span><span class="s1">_set_view_from_bbox(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">direction=</span><span class="s3">'in'</span><span class="s2">,</span>
                            <span class="s1">mode=</span><span class="s2">None, </span><span class="s1">twinx=</span><span class="s2">False, </span><span class="s1">twiny=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Zoom in or out of the bounding box. 
 
        Will center the view in the center of the bounding box, and zoom by 
        the ratio of the size of the bounding box to the size of the Axes3D. 
        &quot;&quot;&quot;</span>
        <span class="s1">(start_x</span><span class="s2">, </span><span class="s1">start_y</span><span class="s2">, </span><span class="s1">stop_x</span><span class="s2">, </span><span class="s1">stop_y) = bbox</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'x'</span><span class="s1">:</span>
            <span class="s1">start_y = self.bbox.min[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">stop_y = self.bbox.max[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'y'</span><span class="s1">:</span>
            <span class="s1">start_x = self.bbox.min[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">stop_x = self.bbox.max[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s5"># Clip to bounding box limits</span>
        <span class="s1">start_x</span><span class="s2">, </span><span class="s1">stop_x = np.clip(sorted([start_x</span><span class="s2">, </span><span class="s1">stop_x])</span><span class="s2">,</span>
                                  <span class="s1">self.bbox.min[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.bbox.max[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">start_y</span><span class="s2">, </span><span class="s1">stop_y = np.clip(sorted([start_y</span><span class="s2">, </span><span class="s1">stop_y])</span><span class="s2">,</span>
                                  <span class="s1">self.bbox.min[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.bbox.max[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s5"># Move the center of the view to the center of the bbox</span>
        <span class="s1">zoom_center_x = (start_x + stop_x)/</span><span class="s4">2</span>
        <span class="s1">zoom_center_y = (start_y + stop_y)/</span><span class="s4">2</span>

        <span class="s1">ax_center_x = (self.bbox.max[</span><span class="s4">0</span><span class="s1">] + self.bbox.min[</span><span class="s4">0</span><span class="s1">])/</span><span class="s4">2</span>
        <span class="s1">ax_center_y = (self.bbox.max[</span><span class="s4">1</span><span class="s1">] + self.bbox.min[</span><span class="s4">1</span><span class="s1">])/</span><span class="s4">2</span>

        <span class="s1">self.start_pan(zoom_center_x</span><span class="s2">, </span><span class="s1">zoom_center_y</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.drag_pan(</span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">ax_center_x</span><span class="s2">, </span><span class="s1">ax_center_y)</span>
        <span class="s1">self.end_pan()</span>

        <span class="s5"># Calculate zoom level</span>
        <span class="s1">dx = abs(start_x - stop_x)</span>
        <span class="s1">dy = abs(start_y - stop_y)</span>
        <span class="s1">scale_u = dx / (self.bbox.max[</span><span class="s4">0</span><span class="s1">] - self.bbox.min[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">scale_v = dy / (self.bbox.max[</span><span class="s4">1</span><span class="s1">] - self.bbox.min[</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s5"># Keep aspect ratios equal</span>
        <span class="s1">scale = max(scale_u</span><span class="s2">, </span><span class="s1">scale_v)</span>

        <span class="s5"># Zoom out</span>
        <span class="s2">if </span><span class="s1">direction == </span><span class="s3">'out'</span><span class="s1">:</span>
            <span class="s1">scale = </span><span class="s4">1 </span><span class="s1">/ scale</span>

        <span class="s1">self._zoom_data_limits(scale</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">scale)</span>

    <span class="s2">def </span><span class="s1">_zoom_data_limits(self</span><span class="s2">, </span><span class="s1">scale_u</span><span class="s2">, </span><span class="s1">scale_v</span><span class="s2">, </span><span class="s1">scale_w):</span>
        <span class="s0">&quot;&quot;&quot; 
        Zoom in or out of a 3D plot. 
 
        Will scale the data limits by the scale factors. These will be 
        transformed to the x, y, z data axes based on the current view angles. 
        A scale factor &gt; 1 zooms out and a scale factor &lt; 1 zooms in. 
 
        For an axes that has had its aspect ratio set to 'equal', 'equalxy', 
        'equalyz', or 'equalxz', the relevant axes are constrained to zoom 
        equally. 
 
        Parameters 
        ---------- 
        scale_u : float 
            Scale factor for the u view axis (view screen horizontal). 
        scale_v : float 
            Scale factor for the v view axis (view screen vertical). 
        scale_w : float 
            Scale factor for the w view axis (view screen depth). 
        &quot;&quot;&quot;</span>
        <span class="s1">scale = np.array([scale_u</span><span class="s2">, </span><span class="s1">scale_v</span><span class="s2">, </span><span class="s1">scale_w])</span>

        <span class="s5"># Only perform frame conversion if unequal scale factors</span>
        <span class="s2">if not </span><span class="s1">np.allclose(scale</span><span class="s2">, </span><span class="s1">scale_u):</span>
            <span class="s5"># Convert the scale factors from the view frame to the data frame</span>
            <span class="s1">R = np.array([self._view_u</span><span class="s2">, </span><span class="s1">self._view_v</span><span class="s2">, </span><span class="s1">self._view_w])</span>
            <span class="s1">S = scale * np.eye(</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">scale = np.linalg.norm(R.T @ S</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

            <span class="s5"># Set the constrained scale factors to the factor closest to 1</span>
            <span class="s2">if </span><span class="s1">self._aspect </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'equal'</span><span class="s2">, </span><span class="s3">'equalxy'</span><span class="s2">, </span><span class="s3">'equalxz'</span><span class="s2">, </span><span class="s3">'equalyz'</span><span class="s1">):</span>
                <span class="s1">ax_idxs = self._equal_aspect_axis_indices(self._aspect)</span>
                <span class="s1">min_ax_idxs = np.argmin(np.abs(scale[ax_idxs] - </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">scale[ax_idxs] = scale[ax_idxs][min_ax_idxs]</span>

        <span class="s1">self._scale_axis_limits(scale[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">scale[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">scale[</span><span class="s4">2</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_scale_axis_limits(self</span><span class="s2">, </span><span class="s1">scale_x</span><span class="s2">, </span><span class="s1">scale_y</span><span class="s2">, </span><span class="s1">scale_z):</span>
        <span class="s0">&quot;&quot;&quot; 
        Keeping the center of the x, y, and z data axes fixed, scale their 
        limits by scale factors. A scale factor &gt; 1 zooms out and a scale 
        factor &lt; 1 zooms in. 
 
        Parameters 
        ---------- 
        scale_x : float 
            Scale factor for the x data axis. 
        scale_y : float 
            Scale factor for the y data axis. 
        scale_z : float 
            Scale factor for the z data axis. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Get the axis limits and centers</span>
        <span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx</span><span class="s2">, </span><span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy</span><span class="s2">, </span><span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz = self.get_w_lims()</span>
        <span class="s1">cx = (maxx + minx)/</span><span class="s4">2</span>
        <span class="s1">cy = (maxy + miny)/</span><span class="s4">2</span>
        <span class="s1">cz = (maxz + minz)/</span><span class="s4">2</span>

        <span class="s5"># Scale the data range</span>
        <span class="s1">dx = (maxx - minx)*scale_x</span>
        <span class="s1">dy = (maxy - miny)*scale_y</span>
        <span class="s1">dz = (maxz - minz)*scale_z</span>

        <span class="s5"># Set the scaled axis limits</span>
        <span class="s1">self.set_xlim3d(cx - dx/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">cx + dx/</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.set_ylim3d(cy - dy/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">cy + dy/</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.set_zlim3d(cz - dz/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">cz + dz/</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_zlabel(self</span><span class="s2">, </span><span class="s1">zlabel</span><span class="s2">, </span><span class="s1">fontdict=</span><span class="s2">None, </span><span class="s1">labelpad=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set zlabel.  See doc for `.set_ylabel` for description. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">labelpad </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.zaxis.labelpad = labelpad</span>
        <span class="s2">return </span><span class="s1">self.zaxis.set_label_text(zlabel</span><span class="s2">, </span><span class="s1">fontdict</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">get_zlabel(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the z-label text string. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = self.zaxis.get_label()</span>
        <span class="s2">return </span><span class="s1">label.get_text()</span>

    <span class="s5"># Axes rectangle characteristics</span>

    <span class="s2">def </span><span class="s1">get_frame_on(self):</span>
        <span class="s0">&quot;&quot;&quot;Get whether the 3D axes panels are drawn.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._frameon</span>

    <span class="s2">def </span><span class="s1">set_frame_on(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the 3D axes panels are drawn. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._frameon = bool(b)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">grid(self</span><span class="s2">, </span><span class="s1">visible=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set / unset 3D grid. 
 
        .. note:: 
 
            Currently, this function does not behave the same as 
            `.axes.Axes.grid`, but it is intended to eventually support that 
            behavior. 
        &quot;&quot;&quot;</span>
        <span class="s5"># TODO: Operate on each axes separately</span>
        <span class="s2">if </span><span class="s1">len(kwargs):</span>
            <span class="s1">visible = </span><span class="s2">True</span>
        <span class="s1">self._draw_grid = visible</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">tick_params(self</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">'both'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convenience method for changing the appearance of ticks and 
        tick labels. 
 
        See `.Axes.tick_params` for full documentation.  Because this function 
        applies to 3D Axes, *axis* can also be set to 'z', and setting *axis* 
        to 'both' autoscales all three axes. 
 
        Also, because of how Axes3D objects are drawn very differently 
        from regular 2D axes, some of these settings may have 
        ambiguous meaning.  For simplicity, the 'z' axis will 
        accept settings as if it was like the 'y' axis. 
 
        .. note:: 
           Axes3D currently ignores some of these settings. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'z'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=axis)</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]:</span>
            <span class="s1">super().tick_params(axis</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'z'</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">]:</span>
            <span class="s1">zkw = dict(kwargs)</span>
            <span class="s1">zkw.pop(</span><span class="s3">'top'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">zkw.pop(</span><span class="s3">'bottom'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">zkw.pop(</span><span class="s3">'labeltop'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">zkw.pop(</span><span class="s3">'labelbottom'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">self.zaxis.set_tick_params(**zkw)</span>

    <span class="s5"># data limits, ticks, tick labels, and formatting</span>

    <span class="s2">def </span><span class="s1">invert_zaxis(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Invert the z-axis. 
        &quot;&quot;&quot;</span>
        <span class="s1">bottom</span><span class="s2">, </span><span class="s1">top = self.get_zlim()</span>
        <span class="s1">self.set_zlim(top</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">auto=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">zaxis_inverted = _axis_method_wrapper(</span><span class="s3">&quot;zaxis&quot;</span><span class="s2">, </span><span class="s3">&quot;get_inverted&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_zbound(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the lower and upper z-axis bounds, in increasing order. 
        &quot;&quot;&quot;</span>
        <span class="s1">bottom</span><span class="s2">, </span><span class="s1">top = self.get_zlim()</span>
        <span class="s2">if </span><span class="s1">bottom &lt; top:</span>
            <span class="s2">return </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">top</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">top</span><span class="s2">, </span><span class="s1">bottom</span>

    <span class="s2">def </span><span class="s1">set_zbound(self</span><span class="s2">, </span><span class="s1">lower=</span><span class="s2">None, </span><span class="s1">upper=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the lower and upper numerical bounds of the z-axis. 
 
        This method will honor axes inversion regardless of parameter order. 
        It will not change the autoscaling setting (`.get_autoscalez_on()`). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">upper </span><span class="s2">is None and </span><span class="s1">np.iterable(lower):</span>
            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = lower</span>

        <span class="s1">old_lower</span><span class="s2">, </span><span class="s1">old_upper = self.get_zbound()</span>
        <span class="s2">if </span><span class="s1">lower </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lower = old_lower</span>
        <span class="s2">if </span><span class="s1">upper </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">upper = old_upper</span>

        <span class="s1">self.set_zlim(sorted((lower</span><span class="s2">, </span><span class="s1">upper)</span><span class="s2">,</span>
                             <span class="s1">reverse=bool(self.zaxis_inverted()))</span><span class="s2">,</span>
                      <span class="s1">auto=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">text(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add text to the plot. 
 
        Keyword arguments will be passed on to `.Axes.text`, except for the 
        *zdir* keyword, which sets the direction to be used as the z 
        direction. 
        &quot;&quot;&quot;</span>
        <span class="s1">text = super().text(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">art3d.text_2d_to_3d(text</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s2">return </span><span class="s1">text</span>

    <span class="s1">text3D = text</span>
    <span class="s1">text2D = Axes.text</span>

    <span class="s2">def </span><span class="s1">plot(self</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Plot 2D or 3D data. 
 
        Parameters 
        ---------- 
        xs : 1D array-like 
            x coordinates of vertices. 
        ys : 1D array-like 
            y coordinates of vertices. 
        zs : float or 1D array-like 
            z coordinates of vertices; either one for all points or one for 
            each point. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            When plotting 2D data, the direction to use as z. 
        **kwargs 
            Other arguments are forwarded to `matplotlib.axes.Axes.plot`. 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s5"># `zs` can be passed positionally or as keyword; checking whether</span>
        <span class="s5"># args[0] is a string matches the behavior of 2D `plot` (via</span>
        <span class="s5"># `_process_plot_var_args`).</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">and not </span><span class="s1">isinstance(args[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">zs</span><span class="s2">, </span><span class="s1">*args = args</span>
            <span class="s2">if </span><span class="s3">'zs' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;plot() for multiple values for argument 'z'&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">zs = kwargs.pop(</span><span class="s3">'zs'</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s5"># Match length</span>
        <span class="s1">zs = np.broadcast_to(zs</span><span class="s2">, </span><span class="s1">np.shape(xs))</span>

        <span class="s1">lines = super().plot(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">lines:</span>
            <span class="s1">art3d.line_2d_to_3d(line</span><span class="s2">, </span><span class="s1">zs=zs</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>

        <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs = art3d.juggle_axes(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">self.auto_scale_xyz(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">had_data)</span>
        <span class="s2">return </span><span class="s1">lines</span>

    <span class="s1">plot3D = plot</span>

    <span class="s2">def </span><span class="s1">plot_surface(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">vmin=</span><span class="s2">None,</span>
                     <span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">lightsource=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a surface plot. 
 
        By default, it will be colored in shades of a solid color, but it also 
        supports colormapping by supplying the *cmap* argument. 
 
        .. note:: 
 
           The *rcount* and *ccount* kwargs, which both default to 50, 
           determine the maximum number of samples used in each direction.  If 
           the input data is larger, it will be downsampled (by slicing) to 
           these numbers of points. 
 
        .. note:: 
 
           To maximize rendering speed consider setting *rstride* and *cstride* 
           to divisors of the number of rows minus 1 and columns minus 1 
           respectively. For example, given 51 rows rstride can be any of the 
           divisors of 50. 
 
           Similarly, a setting of *rstride* and *cstride* equal to 1 (or 
           *rcount* and *ccount* equal the number of rows and columns) can use 
           the optimized path. 
 
        Parameters 
        ---------- 
        X, Y, Z : 2D arrays 
            Data values. 
 
        rcount, ccount : int 
            Maximum number of samples used in each direction.  If the input 
            data is larger, it will be downsampled (by slicing) to these 
            numbers of points.  Defaults to 50. 
 
        rstride, cstride : int 
            Downsampling stride in each direction.  These arguments are 
            mutually exclusive with *rcount* and *ccount*.  If only one of 
            *rstride* or *cstride* is set, the other defaults to 10. 
 
            'classic' mode uses a default of ``rstride = cstride = 10`` instead 
            of the new default of ``rcount = ccount = 50``. 
 
        color : color-like 
            Color of the surface patches. 
 
        cmap : Colormap 
            Colormap of the surface patches. 
 
        facecolors : array-like of colors. 
            Colors of each individual patch. 
 
        norm : Normalize 
            Normalization for the colormap. 
 
        vmin, vmax : float 
            Bounds for the normalization. 
 
        shade : bool, default: True 
            Whether to shade the facecolors.  Shading is always disabled when 
            *cmap* is specified. 
 
        lightsource : `~matplotlib.colors.LightSource` 
            The lightsource to use when *shade* is True. 
 
        **kwargs 
            Other keyword arguments are forwarded to `.Poly3DCollection`. 
        &quot;&quot;&quot;</span>

        <span class="s1">had_data = self.has_data()</span>

        <span class="s2">if </span><span class="s1">Z.ndim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Argument Z must be 2-dimensional.&quot;</span><span class="s1">)</span>

        <span class="s1">Z = cbook._to_unmasked_float_array(Z)</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z = np.broadcast_arrays(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z)</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = Z.shape</span>

        <span class="s1">has_stride = </span><span class="s3">'rstride' </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s3">'cstride' </span><span class="s2">in </span><span class="s1">kwargs</span>
        <span class="s1">has_count = </span><span class="s3">'rcount' </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s3">'ccount' </span><span class="s2">in </span><span class="s1">kwargs</span>

        <span class="s2">if </span><span class="s1">has_stride </span><span class="s2">and </span><span class="s1">has_count:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot specify both stride and count arguments&quot;</span><span class="s1">)</span>

        <span class="s1">rstride = kwargs.pop(</span><span class="s3">'rstride'</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">cstride = kwargs.pop(</span><span class="s3">'cstride'</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">rcount = kwargs.pop(</span><span class="s3">'rcount'</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">ccount = kwargs.pop(</span><span class="s3">'ccount'</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s5"># Strides have priority over counts in classic mode.</span>
            <span class="s5"># So, only compute strides from counts</span>
            <span class="s5"># if counts were explicitly given</span>
            <span class="s1">compute_strides = has_count</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># If the strides are provided then it has priority.</span>
            <span class="s5"># Otherwise, compute the strides from the counts.</span>
            <span class="s1">compute_strides = </span><span class="s2">not </span><span class="s1">has_stride</span>

        <span class="s2">if </span><span class="s1">compute_strides:</span>
            <span class="s1">rstride = int(max(np.ceil(rows / rcount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">cstride = int(max(np.ceil(cols / ccount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">fcolors = kwargs.pop(</span><span class="s3">'facecolors'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">fcolors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = kwargs.pop(</span><span class="s3">'color'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">color = self._get_lines.get_next_color()</span>
            <span class="s1">color = np.array(mcolors.to_rgba(color))</span>

        <span class="s1">cmap = kwargs.get(</span><span class="s3">'cmap'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">shade = kwargs.pop(</span><span class="s3">'shade'</span><span class="s2">, </span><span class="s1">cmap </span><span class="s2">is None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">shade </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;shade cannot be None.&quot;</span><span class="s1">)</span>

        <span class="s1">colset = []  </span><span class="s5"># the sampled facecolor</span>
        <span class="s2">if </span><span class="s1">(rows - </span><span class="s4">1</span><span class="s1">) % rstride == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s1">(cols - </span><span class="s4">1</span><span class="s1">) % cstride == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">\</span>
           <span class="s1">fcolors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">polys = np.stack(</span>
                <span class="s1">[cbook._array_patch_perimeters(a</span><span class="s2">, </span><span class="s1">rstride</span><span class="s2">, </span><span class="s1">cstride)</span>
                 <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z)]</span><span class="s2">,</span>
                <span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># evenly spaced, and including both endpoints</span>
            <span class="s1">row_inds = list(range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rows-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">rstride)) + [rows-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">col_inds = list(range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">cols-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">cstride)) + [cols-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s1">polys = []</span>
            <span class="s2">for </span><span class="s1">rs</span><span class="s2">, </span><span class="s1">rs_next </span><span class="s2">in </span><span class="s1">zip(row_inds[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">row_inds[</span><span class="s4">1</span><span class="s1">:]):</span>
                <span class="s2">for </span><span class="s1">cs</span><span class="s2">, </span><span class="s1">cs_next </span><span class="s2">in </span><span class="s1">zip(col_inds[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">col_inds[</span><span class="s4">1</span><span class="s1">:]):</span>
                    <span class="s1">ps = [</span>
                        <span class="s5"># +1 ensures we share edges between polygons</span>
                        <span class="s1">cbook._array_perimeter(a[rs:rs_next+</span><span class="s4">1</span><span class="s2">, </span><span class="s1">cs:cs_next+</span><span class="s4">1</span><span class="s1">])</span>
                        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z)</span>
                    <span class="s1">]</span>
                    <span class="s5"># ps = np.stack(ps, axis=-1)</span>
                    <span class="s1">ps = np.array(ps).T</span>
                    <span class="s1">polys.append(ps)</span>

                    <span class="s2">if </span><span class="s1">fcolors </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">colset.append(fcolors[rs][cs])</span>

        <span class="s5"># In cases where there are NaNs in the data (possibly from masked</span>
        <span class="s5"># arrays), artifacts can be introduced. Here check whether NaNs exist</span>
        <span class="s5"># and remove the entries if so</span>
        <span class="s2">if not </span><span class="s1">isinstance(polys</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">or </span><span class="s1">np.isnan(polys).any():</span>
            <span class="s1">new_polys = []</span>
            <span class="s1">new_colset = []</span>

            <span class="s5"># Depending on fcolors, colset is either an empty list or has as</span>
            <span class="s5"># many elements as polys. In the former case new_colset results in</span>
            <span class="s5"># a list with None entries, that is discarded later.</span>
            <span class="s2">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">itertools.zip_longest(polys</span><span class="s2">, </span><span class="s1">colset):</span>
                <span class="s1">new_poly = np.array(p)[~np.isnan(p).any(axis=</span><span class="s4">1</span><span class="s1">)]</span>
                <span class="s2">if </span><span class="s1">len(new_poly):</span>
                    <span class="s1">new_polys.append(new_poly)</span>
                    <span class="s1">new_colset.append(col)</span>

            <span class="s5"># Replace previous polys and, if fcolors is not None, colset</span>
            <span class="s1">polys = new_polys</span>
            <span class="s2">if </span><span class="s1">fcolors </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">colset = new_colset</span>

        <span class="s5"># note that the striding causes some polygons to have more coordinates</span>
        <span class="s5"># than others</span>

        <span class="s2">if </span><span class="s1">fcolors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">polyc = art3d.Poly3DCollection(</span>
                <span class="s1">polys</span><span class="s2">, </span><span class="s1">edgecolors=colset</span><span class="s2">, </span><span class="s1">facecolors=colset</span><span class="s2">, </span><span class="s1">shade=shade</span><span class="s2">,</span>
                <span class="s1">lightsource=lightsource</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">elif </span><span class="s1">cmap:</span>
            <span class="s1">polyc = art3d.Poly3DCollection(polys</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s5"># can't always vectorize, because polys might be jagged</span>
            <span class="s2">if </span><span class="s1">isinstance(polys</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">avg_z = polys[...</span><span class="s2">, </span><span class="s4">2</span><span class="s1">].mean(axis=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">avg_z = np.array([ps[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">].mean() </span><span class="s2">for </span><span class="s1">ps </span><span class="s2">in </span><span class="s1">polys])</span>
            <span class="s1">polyc.set_array(avg_z)</span>
            <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is not None or </span><span class="s1">vmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">polyc.set_clim(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
            <span class="s2">if </span><span class="s1">norm </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">polyc.set_norm(norm)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">polyc = art3d.Poly3DCollection(</span>
                <span class="s1">polys</span><span class="s2">, </span><span class="s1">facecolors=color</span><span class="s2">, </span><span class="s1">shade=shade</span><span class="s2">,</span>
                <span class="s1">lightsource=lightsource</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.add_collection(polyc)</span>
        <span class="s1">self.auto_scale_xyz(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">polyc</span>

    <span class="s2">def </span><span class="s1">plot_wireframe(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Plot a 3D wireframe. 
 
        .. note:: 
 
           The *rcount* and *ccount* kwargs, which both default to 50, 
           determine the maximum number of samples used in each direction.  If 
           the input data is larger, it will be downsampled (by slicing) to 
           these numbers of points. 
 
        Parameters 
        ---------- 
        X, Y, Z : 2D arrays 
            Data values. 
 
        rcount, ccount : int 
            Maximum number of samples used in each direction.  If the input 
            data is larger, it will be downsampled (by slicing) to these 
            numbers of points.  Setting a count to zero causes the data to be 
            not sampled in the corresponding direction, producing a 3D line 
            plot rather than a wireframe plot.  Defaults to 50. 
 
        rstride, cstride : int 
            Downsampling stride in each direction.  These arguments are 
            mutually exclusive with *rcount* and *ccount*.  If only one of 
            *rstride* or *cstride* is set, the other defaults to 1.  Setting a 
            stride to zero causes the data to be not sampled in the 
            corresponding direction, producing a 3D line plot rather than a 
            wireframe plot. 
 
            'classic' mode uses a default of ``rstride = cstride = 1`` instead 
            of the new default of ``rcount = ccount = 50``. 
 
        **kwargs 
            Other keyword arguments are forwarded to `.Line3DCollection`. 
        &quot;&quot;&quot;</span>

        <span class="s1">had_data = self.has_data()</span>
        <span class="s2">if </span><span class="s1">Z.ndim != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Argument Z must be 2-dimensional.&quot;</span><span class="s1">)</span>
        <span class="s5"># FIXME: Support masked arrays</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z = np.broadcast_arrays(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z)</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = Z.shape</span>

        <span class="s1">has_stride = </span><span class="s3">'rstride' </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s3">'cstride' </span><span class="s2">in </span><span class="s1">kwargs</span>
        <span class="s1">has_count = </span><span class="s3">'rcount' </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">or </span><span class="s3">'ccount' </span><span class="s2">in </span><span class="s1">kwargs</span>

        <span class="s2">if </span><span class="s1">has_stride </span><span class="s2">and </span><span class="s1">has_count:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot specify both stride and count arguments&quot;</span><span class="s1">)</span>

        <span class="s1">rstride = kwargs.pop(</span><span class="s3">'rstride'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">cstride = kwargs.pop(</span><span class="s3">'cstride'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">rcount = kwargs.pop(</span><span class="s3">'rcount'</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">ccount = kwargs.pop(</span><span class="s3">'ccount'</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s5"># Strides have priority over counts in classic mode.</span>
            <span class="s5"># So, only compute strides from counts</span>
            <span class="s5"># if counts were explicitly given</span>
            <span class="s2">if </span><span class="s1">has_count:</span>
                <span class="s1">rstride = int(max(np.ceil(rows / rcount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">rcount </span><span class="s2">else </span><span class="s4">0</span>
                <span class="s1">cstride = int(max(np.ceil(cols / ccount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">ccount </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># If the strides are provided then it has priority.</span>
            <span class="s5"># Otherwise, compute the strides from the counts.</span>
            <span class="s2">if not </span><span class="s1">has_stride:</span>
                <span class="s1">rstride = int(max(np.ceil(rows / rcount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">rcount </span><span class="s2">else </span><span class="s4">0</span>
                <span class="s1">cstride = int(max(np.ceil(cols / ccount)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">ccount </span><span class="s2">else </span><span class="s4">0</span>

        <span class="s5"># We want two sets of lines, one running along the &quot;rows&quot; of</span>
        <span class="s5"># Z and another set of lines running along the &quot;columns&quot; of Z.</span>
        <span class="s5"># This transpose will make it easy to obtain the columns.</span>
        <span class="s1">tX</span><span class="s2">, </span><span class="s1">tY</span><span class="s2">, </span><span class="s1">tZ = np.transpose(X)</span><span class="s2">, </span><span class="s1">np.transpose(Y)</span><span class="s2">, </span><span class="s1">np.transpose(Z)</span>

        <span class="s2">if </span><span class="s1">rstride:</span>
            <span class="s1">rii = list(range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rows</span><span class="s2">, </span><span class="s1">rstride))</span>
            <span class="s5"># Add the last index only if needed</span>
            <span class="s2">if </span><span class="s1">rows &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">rii[-</span><span class="s4">1</span><span class="s1">] != (rows - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">rii += [rows-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rii = []</span>
        <span class="s2">if </span><span class="s1">cstride:</span>
            <span class="s1">cii = list(range(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">cstride))</span>
            <span class="s5"># Add the last index only if needed</span>
            <span class="s2">if </span><span class="s1">cols &gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">cii[-</span><span class="s4">1</span><span class="s1">] != (cols - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">cii += [cols-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cii = []</span>

        <span class="s2">if </span><span class="s1">rstride == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">cstride == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Either rstride or cstride must be non zero&quot;</span><span class="s1">)</span>

        <span class="s5"># If the inputs were empty, then just</span>
        <span class="s5"># reset everything.</span>
        <span class="s2">if </span><span class="s1">Z.size == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">rii = []</span>
            <span class="s1">cii = []</span>

        <span class="s1">xlines = [X[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rii]</span>
        <span class="s1">ylines = [Y[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rii]</span>
        <span class="s1">zlines = [Z[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">rii]</span>

        <span class="s1">txlines = [tX[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cii]</span>
        <span class="s1">tylines = [tY[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cii]</span>
        <span class="s1">tzlines = [tZ[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cii]</span>

        <span class="s1">lines = ([list(zip(xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl))</span>
                 <span class="s2">for </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl </span><span class="s2">in </span><span class="s1">zip(xlines</span><span class="s2">, </span><span class="s1">ylines</span><span class="s2">, </span><span class="s1">zlines)]</span>
                 <span class="s1">+ [list(zip(xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl))</span>
                 <span class="s2">for </span><span class="s1">xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl </span><span class="s2">in </span><span class="s1">zip(txlines</span><span class="s2">, </span><span class="s1">tylines</span><span class="s2">, </span><span class="s1">tzlines)])</span>

        <span class="s1">linec = art3d.Line3DCollection(lines</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.add_collection(linec)</span>
        <span class="s1">self.auto_scale_xyz(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">linec</span>

    <span class="s2">def </span><span class="s1">plot_trisurf(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">color=</span><span class="s2">None, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None,</span>
                     <span class="s1">lightsource=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Plot a triangulated surface. 
 
        The (optional) triangulation can be specified in one of two ways; 
        either:: 
 
          plot_trisurf(triangulation, ...) 
 
        where triangulation is a `~matplotlib.tri.Triangulation` object, or:: 
 
          plot_trisurf(X, Y, ...) 
          plot_trisurf(X, Y, triangles, ...) 
          plot_trisurf(X, Y, triangles=triangles, ...) 
 
        in which case a Triangulation object will be created.  See 
        `.Triangulation` for an explanation of these possibilities. 
 
        The remaining arguments are:: 
 
          plot_trisurf(..., Z) 
 
        where *Z* is the array of values to contour, one per point 
        in the triangulation. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like 
            Data values as 1D arrays. 
        color 
            Color of the surface patches. 
        cmap 
            A colormap for the surface patches. 
        norm : Normalize 
            An instance of Normalize to map values to colors. 
        vmin, vmax : float, default: None 
            Minimum and maximum value to map. 
        shade : bool, default: True 
            Whether to shade the facecolors.  Shading is always disabled when 
            *cmap* is specified. 
        lightsource : `~matplotlib.colors.LightSource` 
            The lightsource to use when *shade* is True. 
        **kwargs 
            All other keyword arguments are passed on to 
            :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection` 
 
        Examples 
        -------- 
        .. plot:: gallery/mplot3d/trisurf3d.py 
        .. plot:: gallery/mplot3d/trisurf3d_2.py 
        &quot;&quot;&quot;</span>

        <span class="s1">had_data = self.has_data()</span>

        <span class="s5"># TODO: Support custom face colours</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = self._get_lines.get_next_color()</span>
        <span class="s1">color = np.array(mcolors.to_rgba(color))</span>

        <span class="s1">cmap = kwargs.get(</span><span class="s3">'cmap'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">shade = kwargs.pop(</span><span class="s3">'shade'</span><span class="s2">, </span><span class="s1">cmap </span><span class="s2">is None</span><span class="s1">)</span>

        <span class="s1">tri</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = \</span>
            <span class="s1">Triangulation.get_from_args_and_kwargs(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">z = kwargs.pop(</span><span class="s3">'Z'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s5"># We do this so Z doesn't get passed as an arg to PolyCollection</span>
            <span class="s1">z</span><span class="s2">, </span><span class="s1">*args = args</span>
        <span class="s1">z = np.asarray(z)</span>

        <span class="s1">triangles = tri.get_masked_triangles()</span>
        <span class="s1">xt = tri.x[triangles]</span>
        <span class="s1">yt = tri.y[triangles]</span>
        <span class="s1">zt = z[triangles]</span>
        <span class="s1">verts = np.stack((xt</span><span class="s2">, </span><span class="s1">yt</span><span class="s2">, </span><span class="s1">zt)</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">cmap:</span>
            <span class="s1">polyc = art3d.Poly3DCollection(verts</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s5"># average over the three points of each triangle</span>
            <span class="s1">avg_z = verts[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">].mean(axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">polyc.set_array(avg_z)</span>
            <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is not None or </span><span class="s1">vmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">polyc.set_clim(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
            <span class="s2">if </span><span class="s1">norm </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">polyc.set_norm(norm)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">polyc = art3d.Poly3DCollection(</span>
                <span class="s1">verts</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">shade=shade</span><span class="s2">, </span><span class="s1">lightsource=lightsource</span><span class="s2">,</span>
                <span class="s1">facecolors=color</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.add_collection(polyc)</span>
        <span class="s1">self.auto_scale_xyz(tri.x</span><span class="s2">, </span><span class="s1">tri.y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">polyc</span>

    <span class="s2">def </span><span class="s1">_3d_extend_contour(self</span><span class="s2">, </span><span class="s1">cset</span><span class="s2">, </span><span class="s1">stride=</span><span class="s4">5</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Extend a contour in 3D by creating 
        &quot;&quot;&quot;</span>

        <span class="s1">levels = cset.levels</span>
        <span class="s1">colls = cset.collections</span>
        <span class="s1">dz = (levels[</span><span class="s4">1</span><span class="s1">] - levels[</span><span class="s4">0</span><span class="s1">]) / </span><span class="s4">2</span>

        <span class="s2">for </span><span class="s1">z</span><span class="s2">, </span><span class="s1">linec </span><span class="s2">in </span><span class="s1">zip(levels</span><span class="s2">, </span><span class="s1">colls):</span>
            <span class="s1">paths = linec.get_paths()</span>
            <span class="s2">if not </span><span class="s1">paths:</span>
                <span class="s2">continue</span>
            <span class="s1">topverts = art3d._paths_to_3d_segments(paths</span><span class="s2">, </span><span class="s1">z - dz)</span>
            <span class="s1">botverts = art3d._paths_to_3d_segments(paths</span><span class="s2">, </span><span class="s1">z + dz)</span>

            <span class="s1">color = linec.get_edgecolor()[</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s1">nsteps = round(len(topverts[</span><span class="s4">0</span><span class="s1">]) / stride)</span>
            <span class="s2">if </span><span class="s1">nsteps &lt;= </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(topverts[</span><span class="s4">0</span><span class="s1">]) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">nsteps = </span><span class="s4">2</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">continue</span>

            <span class="s1">polyverts = []</span>
            <span class="s1">stepsize = (len(topverts[</span><span class="s4">0</span><span class="s1">]) - </span><span class="s4">1</span><span class="s1">) / (nsteps - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(round(nsteps) - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">i1 = round(i * stepsize)</span>
                <span class="s1">i2 = round((i + </span><span class="s4">1</span><span class="s1">) * stepsize)</span>
                <span class="s1">polyverts.append([topverts[</span><span class="s4">0</span><span class="s1">][i1]</span><span class="s2">,</span>
                                  <span class="s1">topverts[</span><span class="s4">0</span><span class="s1">][i2]</span><span class="s2">,</span>
                                  <span class="s1">botverts[</span><span class="s4">0</span><span class="s1">][i2]</span><span class="s2">,</span>
                                  <span class="s1">botverts[</span><span class="s4">0</span><span class="s1">][i1]])</span>

            <span class="s5"># all polygons have 4 vertices, so vectorize</span>
            <span class="s1">polyverts = np.array(polyverts)</span>
            <span class="s1">polycol = art3d.Poly3DCollection(polyverts</span><span class="s2">,</span>
                                             <span class="s1">facecolors=color</span><span class="s2">,</span>
                                             <span class="s1">edgecolors=color</span><span class="s2">,</span>
                                             <span class="s1">shade=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">polycol.set_sort_zpos(z)</span>
            <span class="s1">self.add_collection3d(polycol)</span>

        <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">colls:</span>
            <span class="s1">col.remove()</span>

    <span class="s2">def </span><span class="s1">add_contour_set(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">cset</span><span class="s2">, </span><span class="s1">extend3d=</span><span class="s2">False, </span><span class="s1">stride=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">zdir = </span><span class="s3">'-' </span><span class="s1">+ zdir</span>
        <span class="s2">if </span><span class="s1">extend3d:</span>
            <span class="s1">self._3d_extend_contour(cset</span><span class="s2">, </span><span class="s1">stride)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">z</span><span class="s2">, </span><span class="s1">linec </span><span class="s2">in </span><span class="s1">zip(cset.levels</span><span class="s2">, </span><span class="s1">cset.collections):</span>
                <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">z = offset</span>
                <span class="s1">art3d.line_collection_2d_to_3d(linec</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>

    <span class="s2">def </span><span class="s1">add_contourf_set(self</span><span class="s2">, </span><span class="s1">cset</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._add_contourf_set(cset</span><span class="s2">, </span><span class="s1">zdir=zdir</span><span class="s2">, </span><span class="s1">offset=offset)</span>

    <span class="s2">def </span><span class="s1">_add_contourf_set(self</span><span class="s2">, </span><span class="s1">cset</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns 
        ------- 
        levels : `numpy.ndarray` 
            Levels at which the filled contours are added. 
        &quot;&quot;&quot;</span>
        <span class="s1">zdir = </span><span class="s3">'-' </span><span class="s1">+ zdir</span>

        <span class="s1">midpoints = cset.levels[:-</span><span class="s4">1</span><span class="s1">] + np.diff(cset.levels) / </span><span class="s4">2</span>
        <span class="s5"># Linearly interpolate to get levels for any extensions</span>
        <span class="s2">if </span><span class="s1">cset._extend_min:</span>
            <span class="s1">min_level = cset.levels[</span><span class="s4">0</span><span class="s1">] - np.diff(cset.levels[:</span><span class="s4">2</span><span class="s1">]) / </span><span class="s4">2</span>
            <span class="s1">midpoints = np.insert(midpoints</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">min_level)</span>
        <span class="s2">if </span><span class="s1">cset._extend_max:</span>
            <span class="s1">max_level = cset.levels[-</span><span class="s4">1</span><span class="s1">] + np.diff(cset.levels[-</span><span class="s4">2</span><span class="s1">:]) / </span><span class="s4">2</span>
            <span class="s1">midpoints = np.append(midpoints</span><span class="s2">, </span><span class="s1">max_level)</span>

        <span class="s2">for </span><span class="s1">z</span><span class="s2">, </span><span class="s1">linec </span><span class="s2">in </span><span class="s1">zip(midpoints</span><span class="s2">, </span><span class="s1">cset.collections):</span>
            <span class="s2">if </span><span class="s1">offset </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">z = offset</span>
            <span class="s1">art3d.poly_collection_2d_to_3d(linec</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>
            <span class="s1">linec.set_sort_zpos(z)</span>
        <span class="s2">return </span><span class="s1">midpoints</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">contour(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                <span class="s1">extend3d=</span><span class="s2">False, </span><span class="s1">stride=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a 3D contour plot. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like, 
            Input data. See `.Axes.contour` for supported data shapes. 
        extend3d : bool, default: False 
            Whether to extend contour in 3D. 
        stride : int 
            Step size for extending contour. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            The direction to use. 
        offset : float, optional 
            If specified, plot a projection of the contour lines at this 
            position in a plane normal to *zdir*. 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
 
        *args, **kwargs 
            Other arguments are forwarded to `matplotlib.axes.Axes.contour`. 
 
        Returns 
        ------- 
        matplotlib.contour.QuadContourSet 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ = art3d.rotate_axes(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">cset = super().contour(jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.add_contour_set(cset</span><span class="s2">, </span><span class="s1">extend3d</span><span class="s2">, </span><span class="s1">stride</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">offset)</span>

        <span class="s1">self.auto_scale_xyz(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">had_data)</span>
        <span class="s2">return </span><span class="s1">cset</span>

    <span class="s1">contour3D = contour</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">tricontour(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                   <span class="s1">extend3d=</span><span class="s2">False, </span><span class="s1">stride=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a 3D contour plot. 
 
        .. note:: 
            This method currently produces incorrect output due to a 
            longstanding bug in 3D PolyCollection rendering. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like 
            Input data. See `.Axes.tricontour` for supported data shapes. 
        extend3d : bool, default: False 
            Whether to extend contour in 3D. 
        stride : int 
            Step size for extending contour. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            The direction to use. 
        offset : float, optional 
            If specified, plot a projection of the contour lines at this 
            position in a plane normal to *zdir*. 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
        *args, **kwargs 
            Other arguments are forwarded to `matplotlib.axes.Axes.tricontour`. 
 
        Returns 
        ------- 
        matplotlib.tri._tricontour.TriContourSet 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">tri</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = Triangulation.get_from_args_and_kwargs(</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">X = tri.x</span>
        <span class="s1">Y = tri.y</span>
        <span class="s2">if </span><span class="s3">'Z' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">Z = kwargs.pop(</span><span class="s3">'Z'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># We do this so Z doesn't get passed as an arg to Axes.tricontour</span>
            <span class="s1">Z</span><span class="s2">, </span><span class="s1">*args = args</span>

        <span class="s1">jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ = art3d.rotate_axes(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">tri = Triangulation(jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">tri.triangles</span><span class="s2">, </span><span class="s1">tri.mask)</span>

        <span class="s1">cset = super().tricontour(tri</span><span class="s2">, </span><span class="s1">jZ</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.add_contour_set(cset</span><span class="s2">, </span><span class="s1">extend3d</span><span class="s2">, </span><span class="s1">stride</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">offset)</span>

        <span class="s1">self.auto_scale_xyz(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">had_data)</span>
        <span class="s2">return </span><span class="s1">cset</span>

    <span class="s2">def </span><span class="s1">_auto_scale_contourf(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">had_data):</span>
        <span class="s5"># Autoscale in the zdir based on the levels added, which are</span>
        <span class="s5"># different from data range if any contour extensions are present</span>
        <span class="s1">dim_vals = {</span><span class="s3">'x'</span><span class="s1">: X</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">: Y</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">: Z</span><span class="s2">, </span><span class="s1">zdir: levels}</span>
        <span class="s5"># Input data and levels have different sizes, but auto_scale_xyz</span>
        <span class="s5"># expected same-size input, so manually take min/max limits</span>
        <span class="s1">limits = [(np.nanmin(dim_vals[dim])</span><span class="s2">, </span><span class="s1">np.nanmax(dim_vals[dim]))</span>
                  <span class="s2">for </span><span class="s1">dim </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">]]</span>
        <span class="s1">self.auto_scale_xyz(*limits</span><span class="s2">, </span><span class="s1">had_data)</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">contourf(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a 3D filled contour plot. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like 
            Input data. See `.Axes.contourf` for supported data shapes. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            The direction to use. 
        offset : float, optional 
            If specified, plot a projection of the contour lines at this 
            position in a plane normal to *zdir*. 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
        *args, **kwargs 
            Other arguments are forwarded to `matplotlib.axes.Axes.contourf`. 
 
        Returns 
        ------- 
        matplotlib.contour.QuadContourSet 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ = art3d.rotate_axes(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">cset = super().contourf(jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">levels = self._add_contourf_set(cset</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">offset)</span>

        <span class="s1">self._auto_scale_contourf(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">had_data)</span>
        <span class="s2">return </span><span class="s1">cset</span>

    <span class="s1">contourf3D = contourf</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">tricontourf(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">offset=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a 3D filled contour plot. 
 
        .. note:: 
            This method currently produces incorrect output due to a 
            longstanding bug in 3D PolyCollection rendering. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like 
            Input data. See `.Axes.tricontourf` for supported data shapes. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            The direction to use. 
        offset : float, optional 
            If specified, plot a projection of the contour lines at this 
            position in a plane normal to zdir. 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
        *args, **kwargs 
            Other arguments are forwarded to 
            `matplotlib.axes.Axes.tricontourf`. 
 
        Returns 
        ------- 
        matplotlib.tri._tricontour.TriContourSet 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">tri</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = Triangulation.get_from_args_and_kwargs(</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">X = tri.x</span>
        <span class="s1">Y = tri.y</span>
        <span class="s2">if </span><span class="s3">'Z' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">Z = kwargs.pop(</span><span class="s3">'Z'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># We do this so Z doesn't get passed as an arg to Axes.tricontourf</span>
            <span class="s1">Z</span><span class="s2">, </span><span class="s1">*args = args</span>

        <span class="s1">jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">jZ = art3d.rotate_axes(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">tri = Triangulation(jX</span><span class="s2">, </span><span class="s1">jY</span><span class="s2">, </span><span class="s1">tri.triangles</span><span class="s2">, </span><span class="s1">tri.mask)</span>

        <span class="s1">cset = super().tricontourf(tri</span><span class="s2">, </span><span class="s1">jZ</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">levels = self._add_contourf_set(cset</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">offset)</span>

        <span class="s1">self._auto_scale_contourf(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">had_data)</span>
        <span class="s2">return </span><span class="s1">cset</span>

    <span class="s2">def </span><span class="s1">add_collection3d(self</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a 3D collection object to the plot. 
 
        2D collection types are converted to a 3D version by 
        modifying the object and adding z coordinate information. 
 
        Supported are: 
 
        - PolyCollection 
        - LineCollection 
        - PatchCollection 
        &quot;&quot;&quot;</span>
        <span class="s1">zvals = np.atleast_1d(zs)</span>
        <span class="s1">zsortval = (np.min(zvals) </span><span class="s2">if </span><span class="s1">zvals.size</span>
                    <span class="s2">else </span><span class="s4">0</span><span class="s1">)  </span><span class="s5"># FIXME: arbitrary default</span>

        <span class="s5"># FIXME: use issubclass() (although, then a 3D collection</span>
        <span class="s5">#       object would also pass.)  Maybe have a collection3d</span>
        <span class="s5">#       abstract class to test for and exclude?</span>
        <span class="s2">if </span><span class="s1">type(col) </span><span class="s2">is </span><span class="s1">mcoll.PolyCollection:</span>
            <span class="s1">art3d.poly_collection_2d_to_3d(col</span><span class="s2">, </span><span class="s1">zs=zs</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>
            <span class="s1">col.set_sort_zpos(zsortval)</span>
        <span class="s2">elif </span><span class="s1">type(col) </span><span class="s2">is </span><span class="s1">mcoll.LineCollection:</span>
            <span class="s1">art3d.line_collection_2d_to_3d(col</span><span class="s2">, </span><span class="s1">zs=zs</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>
            <span class="s1">col.set_sort_zpos(zsortval)</span>
        <span class="s2">elif </span><span class="s1">type(col) </span><span class="s2">is </span><span class="s1">mcoll.PatchCollection:</span>
            <span class="s1">art3d.patch_collection_2d_to_3d(col</span><span class="s2">, </span><span class="s1">zs=zs</span><span class="s2">, </span><span class="s1">zdir=zdir)</span>
            <span class="s1">col.set_sort_zpos(zsortval)</span>

        <span class="s1">collection = super().add_collection(col)</span>
        <span class="s2">return </span><span class="s1">collection</span>

    <span class="s1">@_preprocess_data(replace_names=[</span><span class="s3">&quot;xs&quot;</span><span class="s2">, </span><span class="s3">&quot;ys&quot;</span><span class="s2">, </span><span class="s3">&quot;zs&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">,</span>
                                     <span class="s3">&quot;edgecolors&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;facecolor&quot;</span><span class="s2">,</span>
                                     <span class="s3">&quot;facecolors&quot;</span><span class="s2">, </span><span class="s3">&quot;color&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">scatter(self</span><span class="s2">, </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">s=</span><span class="s4">20</span><span class="s2">, </span><span class="s1">c=</span><span class="s2">None, </span><span class="s1">depthshade=</span><span class="s2">True,</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a scatter plot. 
 
        Parameters 
        ---------- 
        xs, ys : array-like 
            The data positions. 
        zs : float or array-like, default: 0 
            The z-positions. Either an array of the same length as *xs* and 
            *ys* or a single value to place all points in the same plane. 
        zdir : {'x', 'y', 'z', '-x', '-y', '-z'}, default: 'z' 
            The axis direction for the *zs*. This is useful when plotting 2D 
            data on a 3D Axes. The data must be passed as *xs*, *ys*. Setting 
            *zdir* to 'y' then plots the data to the x-z-plane. 
 
            See also :doc:`/gallery/mplot3d/2dcollections3d`. 
 
        s : float or array-like, default: 20 
            The marker size in points**2. Either an array of the same length 
            as *xs* and *ys* or a single value to make all markers the same 
            size. 
        c : color, sequence, or sequence of colors, optional 
            The marker color. Possible values: 
 
            - A single color format string. 
            - A sequence of colors of length n. 
            - A sequence of n numbers to be mapped to colors using *cmap* and 
              *norm*. 
            - A 2D array in which the rows are RGB or RGBA. 
 
            For more details see the *c* argument of `~.axes.Axes.scatter`. 
        depthshade : bool, default: True 
            Whether to shade the scatter markers to give the appearance of 
            depth. Each call to ``scatter()`` will perform its depthshading 
            independently. 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
        **kwargs 
            All other keyword arguments are passed on to `~.axes.Axes.scatter`. 
 
        Returns 
        ------- 
        paths : `~matplotlib.collections.PathCollection` 
        &quot;&quot;&quot;</span>

        <span class="s1">had_data = self.has_data()</span>
        <span class="s1">zs_orig = zs</span>

        <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs = np.broadcast_arrays(</span>
            <span class="s1">*[np.ravel(np.ma.filled(t</span><span class="s2">, </span><span class="s1">np.nan)) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">[xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs]])</span>
        <span class="s1">s = np.ma.ravel(s)  </span><span class="s5"># This doesn't have to match x, y in size.</span>

        <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">c = cbook.delete_masked_points(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">c)</span>

        <span class="s5"># For xs and ys, 2D scatter() will do the copying.</span>
        <span class="s2">if </span><span class="s1">np.may_share_memory(zs_orig</span><span class="s2">, </span><span class="s1">zs):  </span><span class="s5"># Avoid unnecessary copies.</span>
            <span class="s1">zs = zs.copy()</span>

        <span class="s1">patches = super().scatter(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">s=s</span><span class="s2">, </span><span class="s1">c=c</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">art3d.patch_collection_2d_to_3d(patches</span><span class="s2">, </span><span class="s1">zs=zs</span><span class="s2">, </span><span class="s1">zdir=zdir</span><span class="s2">,</span>
                                        <span class="s1">depthshade=depthshade)</span>

        <span class="s2">if </span><span class="s1">self._zmargin &lt; </span><span class="s4">0.05 </span><span class="s2">and </span><span class="s1">xs.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.set_zmargin(</span><span class="s4">0.05</span><span class="s1">)</span>

        <span class="s1">self.auto_scale_xyz(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">patches</span>

    <span class="s1">scatter3D = scatter</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">bar(self</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">zdir=</span><span class="s3">'z'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add 2D bar(s). 
 
        Parameters 
        ---------- 
        left : 1D array-like 
            The x coordinates of the left sides of the bars. 
        height : 1D array-like 
            The height of the bars. 
        zs : float or 1D array-like 
            Z coordinate of bars; if a single value is specified, it will be 
            used for all bars. 
        zdir : {'x', 'y', 'z'}, default: 'z' 
            When plotting 2D data, the direction to use as z ('x', 'y' or 'z'). 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
        **kwargs 
            Other keyword arguments are forwarded to 
            `matplotlib.axes.Axes.bar`. 
 
        Returns 
        ------- 
        mpl_toolkits.mplot3d.art3d.Patch3DCollection 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">patches = super().bar(left</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">zs = np.broadcast_to(zs</span><span class="s2">, </span><span class="s1">len(left))</span>

        <span class="s1">verts = []</span>
        <span class="s1">verts_zs = []</span>
        <span class="s2">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">zip(patches</span><span class="s2">, </span><span class="s1">zs):</span>
            <span class="s1">vs = art3d._get_patch_verts(p)</span>
            <span class="s1">verts += vs.tolist()</span>
            <span class="s1">verts_zs += [z] * len(vs)</span>
            <span class="s1">art3d.patch_2d_to_3d(p</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">zdir)</span>
            <span class="s2">if </span><span class="s3">'alpha' </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">p.set_alpha(kwargs[</span><span class="s3">'alpha'</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">len(verts) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># the following has to be skipped if verts is empty</span>
            <span class="s5"># NOTE: Bugs could still occur if len(verts) &gt; 0,</span>
            <span class="s5">#       but the &quot;2nd dimension&quot; is empty.</span>
            <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys = zip(*verts)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys = []</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">verts_zs = art3d.juggle_axes(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">verts_zs</span><span class="s2">, </span><span class="s1">zdir)</span>
        <span class="s1">self.auto_scale_xyz(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">verts_zs</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">patches</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">bar3d(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">dz</span><span class="s2">, </span><span class="s1">color=</span><span class="s2">None,</span>
              <span class="s1">zsort=</span><span class="s3">'average'</span><span class="s2">, </span><span class="s1">shade=</span><span class="s2">True, </span><span class="s1">lightsource=</span><span class="s2">None, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Generate a 3D barplot. 
 
        This method creates three-dimensional barplot where the width, 
        depth, height, and color of the bars can all be uniquely set. 
 
        Parameters 
        ---------- 
        x, y, z : array-like 
            The coordinates of the anchor point of the bars. 
 
        dx, dy, dz : float or array-like 
            The width, depth, and height of the bars, respectively. 
 
        color : sequence of colors, optional 
            The color of the bars can be specified globally or 
            individually. This parameter can be: 
 
            - A single color, to color all bars the same color. 
            - An array of colors of length N bars, to color each bar 
              independently. 
            - An array of colors of length 6, to color the faces of the 
              bars similarly. 
            - An array of colors of length 6 * N bars, to color each face 
              independently. 
 
            When coloring the faces of the boxes specifically, this is 
            the order of the coloring: 
 
            1. -Z (bottom of box) 
            2. +Z (top of box) 
            3. -Y 
            4. +Y 
            5. -X 
            6. +X 
 
        zsort : str, optional 
            The z-axis sorting scheme passed onto `~.art3d.Poly3DCollection` 
 
        shade : bool, default: True 
            When true, this shades the dark sides of the bars (relative 
            to the plot's source of light). 
 
        lightsource : `~matplotlib.colors.LightSource` 
            The lightsource to use when *shade* is True. 
 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
 
        **kwargs 
            Any additional keyword arguments are passed onto 
            `~.art3d.Poly3DCollection`. 
 
        Returns 
        ------- 
        collection : `~.art3d.Poly3DCollection` 
            A collection of three-dimensional polygons representing the bars. 
        &quot;&quot;&quot;</span>

        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">dz = np.broadcast_arrays(</span>
            <span class="s1">np.atleast_1d(x)</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">dz)</span>
        <span class="s1">minx = np.min(x)</span>
        <span class="s1">maxx = np.max(x + dx)</span>
        <span class="s1">miny = np.min(y)</span>
        <span class="s1">maxy = np.max(y + dy)</span>
        <span class="s1">minz = np.min(z)</span>
        <span class="s1">maxz = np.max(z + dz)</span>

        <span class="s5"># shape (6, 4, 3)</span>
        <span class="s5"># All faces are oriented facing outwards - when viewed from the</span>
        <span class="s5"># outside, their vertices are in a counterclockwise ordering.</span>
        <span class="s1">cuboid = np.array([</span>
            <span class="s5"># -z</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># +z</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># -y</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># +y</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># -x</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s5"># +x</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">])</span>

        <span class="s5"># indexed by [bar, face, vertex, coord]</span>
        <span class="s1">polys = np.empty(x.shape + cuboid.shape)</span>

        <span class="s5"># handle each coordinate separately</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">dp </span><span class="s2">in </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">dy)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">dz)]:</span>
            <span class="s1">p = p[...</span><span class="s2">, </span><span class="s1">np.newaxis</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">dp = dp[...</span><span class="s2">, </span><span class="s1">np.newaxis</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">polys[...</span><span class="s2">, </span><span class="s1">i] = p + dp * cuboid[...</span><span class="s2">, </span><span class="s1">i]</span>

        <span class="s5"># collapse the first two axes</span>
        <span class="s1">polys = polys.reshape((-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">) + polys.shape[</span><span class="s4">2</span><span class="s1">:])</span>

        <span class="s1">facecolors = []</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = [self._get_patches_for_fill.get_next_color()]</span>

        <span class="s1">color = list(mcolors.to_rgba_array(color))</span>

        <span class="s2">if </span><span class="s1">len(color) == len(x):</span>
            <span class="s5"># bar colors specified, need to expand to number of faces</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">color:</span>
                <span class="s1">facecolors.extend([c] * </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># a single color specified, or face colors specified explicitly</span>
            <span class="s1">facecolors = color</span>
            <span class="s2">if </span><span class="s1">len(facecolors) &lt; len(x):</span>
                <span class="s1">facecolors *= (</span><span class="s4">6 </span><span class="s1">* len(x))</span>

        <span class="s1">col = art3d.Poly3DCollection(polys</span><span class="s2">,</span>
                                     <span class="s1">zsort=zsort</span><span class="s2">,</span>
                                     <span class="s1">facecolors=facecolors</span><span class="s2">,</span>
                                     <span class="s1">shade=shade</span><span class="s2">,</span>
                                     <span class="s1">lightsource=lightsource</span><span class="s2">,</span>
                                     <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.add_collection(col)</span>

        <span class="s1">self.auto_scale_xyz((minx</span><span class="s2">, </span><span class="s1">maxx)</span><span class="s2">, </span><span class="s1">(miny</span><span class="s2">, </span><span class="s1">maxy)</span><span class="s2">, </span><span class="s1">(minz</span><span class="s2">, </span><span class="s1">maxz)</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">col</span>

    <span class="s2">def </span><span class="s1">set_title(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">fontdict=</span><span class="s2">None, </span><span class="s1">loc=</span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">ret = super().set_title(label</span><span class="s2">, </span><span class="s1">fontdict=fontdict</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">(x</span><span class="s2">, </span><span class="s1">y) = self.title.get_position()</span>
        <span class="s1">self.title.set_y(</span><span class="s4">0.92 </span><span class="s1">* y)</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">quiver(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">W</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
               <span class="s1">length=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">arrow_length_ratio=</span><span class="s4">.3</span><span class="s2">, </span><span class="s1">pivot=</span><span class="s3">'tail'</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">False,</span>
               <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Plot a 3D field of arrows. 
 
        The arguments can be array-like or scalars, so long as they can be 
        broadcast together. The arguments can also be masked arrays. If an 
        element in any of argument is masked, then that corresponding quiver 
        element will not be plotted. 
 
        Parameters 
        ---------- 
        X, Y, Z : array-like 
            The x, y and z coordinates of the arrow locations (default is 
            tail of arrow; see *pivot* kwarg). 
 
        U, V, W : array-like 
            The x, y and z components of the arrow vectors. 
 
        length : float, default: 1 
            The length of each quiver. 
 
        arrow_length_ratio : float, default: 0.3 
            The ratio of the arrow head with respect to the quiver. 
 
        pivot : {'tail', 'middle', 'tip'}, default: 'tail' 
            The part of the arrow that is at the grid point; the arrow 
            rotates about this point, hence the name *pivot*. 
 
        normalize : bool, default: False 
            Whether all arrows are normalized to have the same length, or keep 
            the lengths defined by *u*, *v*, and *w*. 
 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
 
        **kwargs 
            Any additional keyword arguments are delegated to 
            :class:`.Line3DCollection` 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">calc_arrows(UVW</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">15</span><span class="s1">):</span>
            <span class="s5"># get unit direction vector perpendicular to (u, v, w)</span>
            <span class="s1">x = UVW[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">y = UVW[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">norm = np.linalg.norm(UVW[:</span><span class="s2">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">x_p = np.divide(y</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">where=norm != </span><span class="s4">0</span><span class="s2">, </span><span class="s1">out=np.zeros_like(x))</span>
            <span class="s1">y_p = np.divide(-x</span><span class="s2">,  </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">where=norm != </span><span class="s4">0</span><span class="s2">, </span><span class="s1">out=np.ones_like(x))</span>
            <span class="s5"># compute the two arrowhead direction unit vectors</span>
            <span class="s1">ra = math.radians(angle)</span>
            <span class="s1">c = math.cos(ra)</span>
            <span class="s1">s = math.sin(ra)</span>
            <span class="s5"># construct the rotation matrices of shape (3, 3, n)</span>
            <span class="s1">Rpos = np.array(</span>
                <span class="s1">[[c + (x_p ** </span><span class="s4">2</span><span class="s1">) * (</span><span class="s4">1 </span><span class="s1">- c)</span><span class="s2">, </span><span class="s1">x_p * y_p * (</span><span class="s4">1 </span><span class="s1">- c)</span><span class="s2">, </span><span class="s1">y_p * s]</span><span class="s2">,</span>
                 <span class="s1">[y_p * x_p * (</span><span class="s4">1 </span><span class="s1">- c)</span><span class="s2">, </span><span class="s1">c + (y_p ** </span><span class="s4">2</span><span class="s1">) * (</span><span class="s4">1 </span><span class="s1">- c)</span><span class="s2">, </span><span class="s1">-x_p * s]</span><span class="s2">,</span>
                 <span class="s1">[-y_p * s</span><span class="s2">, </span><span class="s1">x_p * s</span><span class="s2">, </span><span class="s1">np.full_like(x_p</span><span class="s2">, </span><span class="s1">c)]])</span>
            <span class="s5"># opposite rotation negates all the sin terms</span>
            <span class="s1">Rneg = Rpos.copy()</span>
            <span class="s1">Rneg[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]] *= -</span><span class="s4">1</span>
            <span class="s5"># Batch n (3, 3) x (3) matrix multiplications ((3, 3, n) x (n, 3)).</span>
            <span class="s1">Rpos_vecs = np.einsum(</span><span class="s3">&quot;ij...,...j-&gt;...i&quot;</span><span class="s2">, </span><span class="s1">Rpos</span><span class="s2">, </span><span class="s1">UVW)</span>
            <span class="s1">Rneg_vecs = np.einsum(</span><span class="s3">&quot;ij...,...j-&gt;...i&quot;</span><span class="s2">, </span><span class="s1">Rneg</span><span class="s2">, </span><span class="s1">UVW)</span>
            <span class="s5"># Stack into (n, 2, 3) result.</span>
            <span class="s1">head_dirs = np.stack([Rpos_vecs</span><span class="s2">, </span><span class="s1">Rneg_vecs]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">head_dirs</span>

        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">input_args = [X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span><span class="s2">, </span><span class="s1">U</span><span class="s2">, </span><span class="s1">V</span><span class="s2">, </span><span class="s1">W]</span>

        <span class="s5"># extract the masks, if any</span>
        <span class="s1">masks = [k.mask </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">input_args</span>
                 <span class="s2">if </span><span class="s1">isinstance(k</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray)]</span>
        <span class="s5"># broadcast to match the shape</span>
        <span class="s1">bcast = np.broadcast_arrays(*input_args</span><span class="s2">, </span><span class="s1">*masks)</span>
        <span class="s1">input_args = bcast[:</span><span class="s4">6</span><span class="s1">]</span>
        <span class="s1">masks = bcast[</span><span class="s4">6</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">masks:</span>
            <span class="s5"># combine the masks into one</span>
            <span class="s1">mask = functools.reduce(np.logical_or</span><span class="s2">, </span><span class="s1">masks)</span>
            <span class="s5"># put mask on and compress</span>
            <span class="s1">input_args = [np.ma.array(k</span><span class="s2">, </span><span class="s1">mask=mask).compressed()</span>
                          <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">input_args]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">input_args = [np.ravel(k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">input_args]</span>

        <span class="s2">if </span><span class="s1">any(len(v) == </span><span class="s4">0 </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">input_args):</span>
            <span class="s5"># No quivers, so just make an empty collection and return early</span>
            <span class="s1">linec = art3d.Line3DCollection([]</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.add_collection(linec)</span>
            <span class="s2">return </span><span class="s1">linec</span>

        <span class="s1">shaft_dt = np.array([</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">length]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">arrow_dt = shaft_dt * arrow_length_ratio</span>

        <span class="s1">_api.check_in_list([</span><span class="s3">'tail'</span><span class="s2">, </span><span class="s3">'middle'</span><span class="s2">, </span><span class="s3">'tip'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pivot=pivot)</span>
        <span class="s2">if </span><span class="s1">pivot == </span><span class="s3">'tail'</span><span class="s1">:</span>
            <span class="s1">shaft_dt -= length</span>
        <span class="s2">elif </span><span class="s1">pivot == </span><span class="s3">'middle'</span><span class="s1">:</span>
            <span class="s1">shaft_dt -= length / </span><span class="s4">2</span>

        <span class="s1">XYZ = np.column_stack(input_args[:</span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">UVW = np.column_stack(input_args[</span><span class="s4">3</span><span class="s1">:]).astype(float)</span>

        <span class="s5"># Normalize rows of UVW</span>
        <span class="s1">norm = np.linalg.norm(UVW</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s5"># If any row of UVW is all zeros, don't make a quiver for it</span>
        <span class="s1">mask = norm &gt; </span><span class="s4">0</span>
        <span class="s1">XYZ = XYZ[mask]</span>
        <span class="s2">if </span><span class="s1">normalize:</span>
            <span class="s1">UVW = UVW[mask] / norm[mask].reshape((-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">UVW = UVW[mask]</span>

        <span class="s2">if </span><span class="s1">len(XYZ) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s5"># compute the shaft lines all at once with an outer product</span>
            <span class="s1">shafts = (XYZ - np.multiply.outer(shaft_dt</span><span class="s2">, </span><span class="s1">UVW)).swapaxes(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s5"># compute head direction vectors, n heads x 2 sides x 3 dimensions</span>
            <span class="s1">head_dirs = calc_arrows(UVW)</span>
            <span class="s5"># compute all head lines at once, starting from the shaft ends</span>
            <span class="s1">heads = shafts[:</span><span class="s2">, </span><span class="s1">:</span><span class="s4">1</span><span class="s1">] - np.multiply.outer(arrow_dt</span><span class="s2">, </span><span class="s1">head_dirs)</span>
            <span class="s5"># stack left and right head lines together</span>
            <span class="s1">heads = heads.reshape((len(arrow_dt)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
            <span class="s5"># transpose to get a list of lines</span>
            <span class="s1">heads = heads.swapaxes(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">lines = [*shafts</span><span class="s2">, </span><span class="s1">*heads]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lines = []</span>

        <span class="s1">linec = art3d.Line3DCollection(lines</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.add_collection(linec)</span>

        <span class="s1">self.auto_scale_xyz(XYZ[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">XYZ[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">XYZ[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">linec</span>

    <span class="s1">quiver3D = quiver</span>

    <span class="s2">def </span><span class="s1">voxels(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">facecolors=</span><span class="s2">None, </span><span class="s1">edgecolors=</span><span class="s2">None, </span><span class="s1">shade=</span><span class="s2">True,</span>
               <span class="s1">lightsource=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        ax.voxels([x, y, z,] /, filled, facecolors=None, edgecolors=None, \ 
**kwargs) 
 
        Plot a set of filled voxels 
 
        All voxels are plotted as 1x1x1 cubes on the axis, with 
        ``filled[0, 0, 0]`` placed with its lower corner at the origin. 
        Occluded faces are not plotted. 
 
        Parameters 
        ---------- 
        filled : 3D np.array of bool 
            A 3D array of values, with truthy values indicating which voxels 
            to fill 
 
        x, y, z : 3D np.array, optional 
            The coordinates of the corners of the voxels. This should broadcast 
            to a shape one larger in every dimension than the shape of 
            *filled*.  These can be used to plot non-cubic voxels. 
 
            If not specified, defaults to increasing integers along each axis, 
            like those returned by :func:`~numpy.indices`. 
            As indicated by the ``/`` in the function signature, these 
            arguments can only be passed positionally. 
 
        facecolors, edgecolors : array-like, optional 
            The color to draw the faces and edges of the voxels. Can only be 
            passed as keyword arguments. 
            These parameters can be: 
 
            - A single color value, to color all voxels the same color. This 
              can be either a string, or a 1D rgb/rgba array 
            - ``None``, the default, to use a single color for the faces, and 
              the style default for the edges. 
            - A 3D `~numpy.ndarray` of color names, with each item the color 
              for the corresponding voxel. The size must match the voxels. 
            - A 4D `~numpy.ndarray` of rgb/rgba data, with the components 
              along the last axis. 
 
        shade : bool, default: True 
            Whether to shade the facecolors. 
 
        lightsource : `~matplotlib.colors.LightSource` 
            The lightsource to use when *shade* is True. 
 
        **kwargs 
            Additional keyword arguments to pass onto 
            `~mpl_toolkits.mplot3d.art3d.Poly3DCollection`. 
 
        Returns 
        ------- 
        faces : dict 
            A dictionary indexed by coordinate, where ``faces[i, j, k]`` is a 
            `.Poly3DCollection` of the faces drawn for the voxel 
            ``filled[i, j, k]``. If no faces were drawn for a given voxel, 
            either because it was not asked to be drawn, or it is fully 
            occluded, then ``(i, j, k) not in faces``. 
 
        Examples 
        -------- 
        .. plot:: gallery/mplot3d/voxels.py 
        .. plot:: gallery/mplot3d/voxels_rgb.py 
        .. plot:: gallery/mplot3d/voxels_torus.py 
        .. plot:: gallery/mplot3d/voxels_numpy_logo.py 
        &quot;&quot;&quot;</span>

        <span class="s5"># work out which signature we should be using, and use it to parse</span>
        <span class="s5"># the arguments. Name must be voxels for the correct error message</span>
        <span class="s2">if </span><span class="s1">len(args) &gt;= </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s5"># underscores indicate position only</span>
            <span class="s2">def </span><span class="s1">voxels(__x</span><span class="s2">, </span><span class="s1">__y</span><span class="s2">, </span><span class="s1">__z</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s2">return </span><span class="s1">(__x</span><span class="s2">, </span><span class="s1">__y</span><span class="s2">, </span><span class="s1">__z)</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">kwargs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">voxels(filled</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s2">return None, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">kwargs</span>

        <span class="s1">xyz</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">kwargs = voxels(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s5"># check dimensions</span>
        <span class="s2">if </span><span class="s1">filled.ndim != </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Argument filled must be 3-dimensional&quot;</span><span class="s1">)</span>
        <span class="s1">size = np.array(filled.shape</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s5"># check xyz coordinates, which are one larger than the filled shape</span>
        <span class="s1">coord_shape = tuple(size + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">xyz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = np.indices(coord_shape)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z = (np.broadcast_to(c</span><span class="s2">, </span><span class="s1">coord_shape) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">xyz)</span>

        <span class="s2">def </span><span class="s1">_broadcast_color_arg(color</span><span class="s2">, </span><span class="s1">name):</span>
            <span class="s2">if </span><span class="s1">np.ndim(color) </span><span class="s2">in </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s5"># single color, like &quot;red&quot; or [1, 0, 0]</span>
                <span class="s2">return </span><span class="s1">np.broadcast_to(color</span><span class="s2">, </span><span class="s1">filled.shape + np.shape(color))</span>
            <span class="s2">elif </span><span class="s1">np.ndim(color) </span><span class="s2">in </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">):</span>
                <span class="s5"># 3D array of strings, or 4D array with last axis rgb</span>
                <span class="s2">if </span><span class="s1">np.shape(color)[:</span><span class="s4">3</span><span class="s1">] != filled.shape:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;When multidimensional, {} must match the shape of &quot;</span>
                        <span class="s3">&quot;filled&quot;</span><span class="s1">.format(name))</span>
                <span class="s2">return </span><span class="s1">color</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid {} argument&quot;</span><span class="s1">.format(name))</span>

        <span class="s5"># broadcast and default on facecolors</span>
        <span class="s2">if </span><span class="s1">facecolors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">facecolors = self._get_patches_for_fill.get_next_color()</span>
        <span class="s1">facecolors = _broadcast_color_arg(facecolors</span><span class="s2">, </span><span class="s3">'facecolors'</span><span class="s1">)</span>

        <span class="s5"># broadcast but no default on edgecolors</span>
        <span class="s1">edgecolors = _broadcast_color_arg(edgecolors</span><span class="s2">, </span><span class="s3">'edgecolors'</span><span class="s1">)</span>

        <span class="s5"># scale to the full array, even if the data is only in the center</span>
        <span class="s1">self.auto_scale_xyz(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)</span>

        <span class="s5"># points lying on corners of a square</span>
        <span class="s1">square = np.array([</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s1">voxel_faces = defaultdict(list)</span>

        <span class="s2">def </span><span class="s1">permutation_matrices(n):</span>
            <span class="s0">&quot;&quot;&quot;Generate cyclic permutation matrices.&quot;&quot;&quot;</span>
            <span class="s1">mat = np.eye(n</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
                <span class="s2">yield </span><span class="s1">mat</span>
                <span class="s1">mat = np.roll(mat</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s5"># iterate over each of the YZ, ZX, and XY orientations, finding faces</span>
        <span class="s5"># to render</span>
        <span class="s2">for </span><span class="s1">permute </span><span class="s2">in </span><span class="s1">permutation_matrices(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s5"># find the set of ranges to iterate over</span>
            <span class="s1">pc</span><span class="s2">, </span><span class="s1">qc</span><span class="s2">, </span><span class="s1">rc = permute.T.dot(size)</span>
            <span class="s1">pinds = np.arange(pc)</span>
            <span class="s1">qinds = np.arange(qc)</span>
            <span class="s1">rinds = np.arange(rc)</span>

            <span class="s1">square_rot_pos = square.dot(permute.T)</span>
            <span class="s1">square_rot_neg = square_rot_pos[::-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s5"># iterate within the current plane</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pinds:</span>
                <span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">qinds:</span>
                    <span class="s5"># iterate perpendicularly to the current plane, handling</span>
                    <span class="s5"># boundaries. We only draw faces between a voxel and an</span>
                    <span class="s5"># empty space, to avoid drawing internal faces.</span>

                    <span class="s5"># draw lower faces</span>
                    <span class="s1">p0 = permute.dot([p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">i0 = tuple(p0)</span>
                    <span class="s2">if </span><span class="s1">filled[i0]:</span>
                        <span class="s1">voxel_faces[i0].append(p0 + square_rot_neg)</span>

                    <span class="s5"># draw middle faces</span>
                    <span class="s2">for </span><span class="s1">r1</span><span class="s2">, </span><span class="s1">r2 </span><span class="s2">in </span><span class="s1">zip(rinds[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rinds[</span><span class="s4">1</span><span class="s1">:]):</span>
                        <span class="s1">p1 = permute.dot([p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">r1])</span>
                        <span class="s1">p2 = permute.dot([p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">r2])</span>

                        <span class="s1">i1 = tuple(p1)</span>
                        <span class="s1">i2 = tuple(p2)</span>

                        <span class="s2">if </span><span class="s1">filled[i1] </span><span class="s2">and not </span><span class="s1">filled[i2]:</span>
                            <span class="s1">voxel_faces[i1].append(p2 + square_rot_pos)</span>
                        <span class="s2">elif not </span><span class="s1">filled[i1] </span><span class="s2">and </span><span class="s1">filled[i2]:</span>
                            <span class="s1">voxel_faces[i2].append(p2 + square_rot_neg)</span>

                    <span class="s5"># draw upper faces</span>
                    <span class="s1">pk = permute.dot([p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">rc-</span><span class="s4">1</span><span class="s1">])</span>
                    <span class="s1">pk2 = permute.dot([p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">rc])</span>
                    <span class="s1">ik = tuple(pk)</span>
                    <span class="s2">if </span><span class="s1">filled[ik]:</span>
                        <span class="s1">voxel_faces[ik].append(pk2 + square_rot_pos)</span>

        <span class="s5"># iterate over the faces, and generate a Poly3DCollection for each</span>
        <span class="s5"># voxel</span>
        <span class="s1">polygons = {}</span>
        <span class="s2">for </span><span class="s1">coord</span><span class="s2">, </span><span class="s1">faces_inds </span><span class="s2">in </span><span class="s1">voxel_faces.items():</span>
            <span class="s5"># convert indices into 3D positions</span>
            <span class="s2">if </span><span class="s1">xyz </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">faces = faces_inds</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">faces = []</span>
                <span class="s2">for </span><span class="s1">face_inds </span><span class="s2">in </span><span class="s1">faces_inds:</span>
                    <span class="s1">ind = face_inds[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">face_inds[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">face_inds[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span>
                    <span class="s1">face = np.empty(face_inds.shape)</span>
                    <span class="s1">face[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = x[ind]</span>
                    <span class="s1">face[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = y[ind]</span>
                    <span class="s1">face[:</span><span class="s2">, </span><span class="s4">2</span><span class="s1">] = z[ind]</span>
                    <span class="s1">faces.append(face)</span>

            <span class="s5"># shade the faces</span>
            <span class="s1">facecolor = facecolors[coord]</span>
            <span class="s1">edgecolor = edgecolors[coord]</span>

            <span class="s1">poly = art3d.Poly3DCollection(</span>
                <span class="s1">faces</span><span class="s2">, </span><span class="s1">facecolors=facecolor</span><span class="s2">, </span><span class="s1">edgecolors=edgecolor</span><span class="s2">,</span>
                <span class="s1">shade=shade</span><span class="s2">, </span><span class="s1">lightsource=lightsource</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.add_collection3d(poly)</span>
            <span class="s1">polygons[coord] = poly</span>

        <span class="s2">return </span><span class="s1">polygons</span>

    <span class="s1">@_preprocess_data(replace_names=[</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s3">&quot;z&quot;</span><span class="s2">, </span><span class="s3">&quot;xerr&quot;</span><span class="s2">, </span><span class="s3">&quot;yerr&quot;</span><span class="s2">, </span><span class="s3">&quot;zerr&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">errorbar(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">zerr=</span><span class="s2">None, </span><span class="s1">yerr=</span><span class="s2">None, </span><span class="s1">xerr=</span><span class="s2">None, </span><span class="s1">fmt=</span><span class="s3">''</span><span class="s2">,</span>
                 <span class="s1">barsabove=</span><span class="s2">False, </span><span class="s1">errorevery=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ecolor=</span><span class="s2">None, </span><span class="s1">elinewidth=</span><span class="s2">None,</span>
                 <span class="s1">capsize=</span><span class="s2">None, </span><span class="s1">capthick=</span><span class="s2">None, </span><span class="s1">xlolims=</span><span class="s2">False, </span><span class="s1">xuplims=</span><span class="s2">False,</span>
                 <span class="s1">ylolims=</span><span class="s2">False, </span><span class="s1">yuplims=</span><span class="s2">False, </span><span class="s1">zlolims=</span><span class="s2">False, </span><span class="s1">zuplims=</span><span class="s2">False,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Plot lines and/or markers with errorbars around them. 
 
        *x*/*y*/*z* define the data locations, and *xerr*/*yerr*/*zerr* define 
        the errorbar sizes. By default, this draws the data markers/lines as 
        well the errorbars. Use fmt='none' to draw errorbars only. 
 
        Parameters 
        ---------- 
        x, y, z : float or array-like 
            The data positions. 
 
        xerr, yerr, zerr : float or array-like, shape (N,) or (2, N), optional 
            The errorbar sizes: 
 
            - scalar: Symmetric +/- values for all data points. 
            - shape(N,): Symmetric +/-values for each data point. 
            - shape(2, N): Separate - and + values for each bar. First row 
              contains the lower errors, the second row contains the upper 
              errors. 
            - *None*: No errorbar. 
 
            Note that all error arrays should have *positive* values. 
 
        fmt : str, default: '' 
            The format for the data points / data lines. See `.plot` for 
            details. 
 
            Use 'none' (case-insensitive) to plot errorbars without any data 
            markers. 
 
        ecolor : color, default: None 
            The color of the errorbar lines.  If None, use the color of the 
            line connecting the markers. 
 
        elinewidth : float, default: None 
            The linewidth of the errorbar lines. If None, the linewidth of 
            the current style is used. 
 
        capsize : float, default: :rc:`errorbar.capsize` 
            The length of the error bar caps in points. 
 
        capthick : float, default: None 
            An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*). 
            This setting is a more sensible name for the property that 
            controls the thickness of the error bar cap in points. For 
            backwards compatibility, if *mew* or *markeredgewidth* are given, 
            then they will over-ride *capthick*. This may change in future 
            releases. 
 
        barsabove : bool, default: False 
            If True, will plot the errorbars above the plot 
            symbols. Default is below. 
 
        xlolims, ylolims, zlolims : bool, default: False 
            These arguments can be used to indicate that a value gives only 
            lower limits. In that case a caret symbol is used to indicate 
            this. *lims*-arguments may be scalars, or array-likes of the same 
            length as the errors. To use limits with inverted axes, 
            `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before 
            `errorbar`. Note the tricky parameter names: setting e.g. 
            *ylolims* to True means that the y-value is a *lower* limit of the 
            True value, so, only an *upward*-pointing arrow will be drawn! 
 
        xuplims, yuplims, zuplims : bool, default: False 
            Same as above, but for controlling the upper limits. 
 
        errorevery : int or (int, int), default: 1 
            draws error bars on a subset of the data. *errorevery* =N draws 
            error bars on the points (x[::N], y[::N], z[::N]). 
            *errorevery* =(start, N) draws error bars on the points 
            (x[start::N], y[start::N], z[start::N]). e.g. errorevery=(6, 3) 
            adds error bars to the data at (x[6], x[9], x[12], x[15], ...). 
            Used to avoid overlapping error bars when two series share x-axis 
            values. 
 
        Returns 
        ------- 
        errlines : list 
            List of `~mpl_toolkits.mplot3d.art3d.Line3DCollection` instances 
            each containing an errorbar line. 
        caplines : list 
            List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each 
            containing a capline object. 
        limmarks : list 
            List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each 
            containing a marker with an upper or lower limit. 
 
        Other Parameters 
        ---------------- 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
 
        **kwargs 
            All other keyword arguments for styling errorbar lines are passed 
            `~mpl_toolkits.mplot3d.art3d.Line3DCollection`. 
 
        Examples 
        -------- 
        .. plot:: gallery/mplot3d/errorbar3d.py 
        &quot;&quot;&quot;</span>
        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">kwargs = cbook.normalize_kwargs(kwargs</span><span class="s2">, </span><span class="s1">mlines.Line2D)</span>
        <span class="s5"># Drop anything that comes in as None to use the default instead.</span>
        <span class="s1">kwargs = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">}</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">'zorder'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">self._process_unit_info([(</span><span class="s3">&quot;x&quot;</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;y&quot;</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;z&quot;</span><span class="s2">, </span><span class="s1">z)]</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">,</span>
                                <span class="s1">convert=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s5"># make sure all the args are iterable; use lists not arrays to</span>
        <span class="s5"># preserve units</span>
        <span class="s1">x = x </span><span class="s2">if </span><span class="s1">np.iterable(x) </span><span class="s2">else </span><span class="s1">[x]</span>
        <span class="s1">y = y </span><span class="s2">if </span><span class="s1">np.iterable(y) </span><span class="s2">else </span><span class="s1">[y]</span>
        <span class="s1">z = z </span><span class="s2">if </span><span class="s1">np.iterable(z) </span><span class="s2">else </span><span class="s1">[z]</span>

        <span class="s2">if not </span><span class="s1">len(x) == len(y) == len(z):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'x', 'y', and 'z' must have the same size&quot;</span><span class="s1">)</span>

        <span class="s1">everymask = self._errorevery_to_mask(x</span><span class="s2">, </span><span class="s1">errorevery)</span>

        <span class="s1">label = kwargs.pop(</span><span class="s3">&quot;label&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s3">'label'</span><span class="s1">] = </span><span class="s3">'_nolegend_'</span>

        <span class="s5"># Create the main line and determine overall kwargs for child artists.</span>
        <span class="s5"># We avoid calling self.plot() directly, or self._get_lines(), because</span>
        <span class="s5"># that would call self._process_unit_info again, and do other indirect</span>
        <span class="s5"># data processing.</span>
        <span class="s1">(data_line</span><span class="s2">, </span><span class="s1">base_style)</span><span class="s2">, </span><span class="s1">= self._get_lines._plot_args(</span>
            <span class="s1">(x</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">if </span><span class="s1">fmt == </span><span class="s3">'' </span><span class="s2">else </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fmt)</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">return_kwargs=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">art3d.line_2d_to_3d(data_line</span><span class="s2">, </span><span class="s1">zs=z)</span>

        <span class="s5"># Do this after creating `data_line` to avoid modifying `base_style`.</span>
        <span class="s2">if </span><span class="s1">barsabove:</span>
            <span class="s1">data_line.set_zorder(kwargs[</span><span class="s3">'zorder'</span><span class="s1">] - </span><span class="s4">.1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data_line.set_zorder(kwargs[</span><span class="s3">'zorder'</span><span class="s1">] + </span><span class="s4">.1</span><span class="s1">)</span>

        <span class="s5"># Add line to plot, or throw it away and use it to determine kwargs.</span>
        <span class="s2">if </span><span class="s1">fmt.lower() != </span><span class="s3">'none'</span><span class="s1">:</span>
            <span class="s1">self.add_line(data_line)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data_line = </span><span class="s2">None</span>
            <span class="s5"># Remove alpha=0 color that _process_plot_format returns.</span>
            <span class="s1">base_style.pop(</span><span class="s3">'color'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s3">'color' </span><span class="s2">not in </span><span class="s1">base_style:</span>
            <span class="s1">base_style[</span><span class="s3">'color'</span><span class="s1">] = </span><span class="s3">'C0'</span>
        <span class="s2">if </span><span class="s1">ecolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ecolor = base_style[</span><span class="s3">'color'</span><span class="s1">]</span>

        <span class="s5"># Eject any line-specific information from format string, as it's not</span>
        <span class="s5"># needed for bars or caps.</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'marker'</span><span class="s2">, </span><span class="s3">'markersize'</span><span class="s2">, </span><span class="s3">'markerfacecolor'</span><span class="s2">,</span>
                    <span class="s3">'markeredgewidth'</span><span class="s2">, </span><span class="s3">'markeredgecolor'</span><span class="s2">, </span><span class="s3">'markevery'</span><span class="s2">,</span>
                    <span class="s3">'linestyle'</span><span class="s2">, </span><span class="s3">'fillstyle'</span><span class="s2">, </span><span class="s3">'drawstyle'</span><span class="s2">, </span><span class="s3">'dash_capstyle'</span><span class="s2">,</span>
                    <span class="s3">'dash_joinstyle'</span><span class="s2">, </span><span class="s3">'solid_capstyle'</span><span class="s2">, </span><span class="s3">'solid_joinstyle'</span><span class="s1">]:</span>
            <span class="s1">base_style.pop(key</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s5"># Make the style dict for the line collections (the bars).</span>
        <span class="s1">eb_lines_style = {**base_style</span><span class="s2">, </span><span class="s3">'color'</span><span class="s1">: ecolor}</span>

        <span class="s2">if </span><span class="s1">elinewidth:</span>
            <span class="s1">eb_lines_style[</span><span class="s3">'linewidth'</span><span class="s1">] = elinewidth</span>
        <span class="s2">elif </span><span class="s3">'linewidth' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">eb_lines_style[</span><span class="s3">'linewidth'</span><span class="s1">] = kwargs[</span><span class="s3">'linewidth'</span><span class="s1">]</span>

        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'transform'</span><span class="s2">, </span><span class="s3">'alpha'</span><span class="s2">, </span><span class="s3">'zorder'</span><span class="s2">, </span><span class="s3">'rasterized'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">eb_lines_style[key] = kwargs[key]</span>

        <span class="s5"># Make the style dict for caps (the &quot;hats&quot;).</span>
        <span class="s1">eb_cap_style = {**base_style</span><span class="s2">, </span><span class="s3">'linestyle'</span><span class="s1">: </span><span class="s3">'None'</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">capsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">capsize = mpl.rcParams[</span><span class="s3">&quot;errorbar.capsize&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">capsize &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">eb_cap_style[</span><span class="s3">'markersize'</span><span class="s1">] = </span><span class="s4">2. </span><span class="s1">* capsize</span>
        <span class="s2">if </span><span class="s1">capthick </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">eb_cap_style[</span><span class="s3">'markeredgewidth'</span><span class="s1">] = capthick</span>
        <span class="s1">eb_cap_style[</span><span class="s3">'color'</span><span class="s1">] = ecolor</span>

        <span class="s2">def </span><span class="s1">_apply_mask(arrays</span><span class="s2">, </span><span class="s1">mask):</span>
            <span class="s5"># Return, for each array in *arrays*, the elements for which *mask*</span>
            <span class="s5"># is True, without using fancy indexing.</span>
            <span class="s2">return </span><span class="s1">[[*itertools.compress(array</span><span class="s2">, </span><span class="s1">mask)] </span><span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">arrays]</span>

        <span class="s2">def </span><span class="s1">_extract_errs(err</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">lomask</span><span class="s2">, </span><span class="s1">himask):</span>
            <span class="s5"># For separate +/- error values we need to unpack err</span>
            <span class="s2">if </span><span class="s1">len(err.shape) == </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">low_err</span><span class="s2">, </span><span class="s1">high_err = err</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">low_err</span><span class="s2">, </span><span class="s1">high_err = err</span><span class="s2">, </span><span class="s1">err</span>

            <span class="s1">lows = np.where(lomask | ~everymask</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">data - low_err)</span>
            <span class="s1">highs = np.where(himask | ~everymask</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">data + high_err)</span>

            <span class="s2">return </span><span class="s1">lows</span><span class="s2">, </span><span class="s1">highs</span>

        <span class="s5"># collect drawn items while looping over the three coordinates</span>
        <span class="s1">errlines</span><span class="s2">, </span><span class="s1">caplines</span><span class="s2">, </span><span class="s1">limmarks = []</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s5"># list of endpoint coordinates, used for auto-scaling</span>
        <span class="s1">coorderrs = []</span>

        <span class="s5"># define the markers used for errorbar caps and limits below</span>
        <span class="s5"># the dictionary key is mapped by the `i_xyz` helper dictionary</span>
        <span class="s1">capmarker = {</span><span class="s4">0</span><span class="s1">: </span><span class="s3">'|'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">: </span><span class="s3">'|'</span><span class="s2">, </span><span class="s4">2</span><span class="s1">: </span><span class="s3">'_'</span><span class="s1">}</span>
        <span class="s1">i_xyz = {</span><span class="s3">'x'</span><span class="s1">: </span><span class="s4">0</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span>

        <span class="s5"># Calculate marker size from points to quiver length. Because these are</span>
        <span class="s5"># not markers, and 3D Axes do not use the normal transform stack, this</span>
        <span class="s5"># is a bit involved. Since the quiver arrows will change size as the</span>
        <span class="s5"># scene is rotated, they are given a standard size based on viewing</span>
        <span class="s5"># them directly in planar form.</span>
        <span class="s1">quiversize = eb_cap_style.get(</span><span class="s3">'markersize'</span><span class="s2">,</span>
                                      <span class="s1">mpl.rcParams[</span><span class="s3">'lines.markersize'</span><span class="s1">]) ** </span><span class="s4">2</span>
        <span class="s1">quiversize *= self.figure.dpi / </span><span class="s4">72</span>
        <span class="s1">quiversize = self.transAxes.inverted().transform([</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(quiversize</span><span class="s2">, </span><span class="s1">quiversize)])</span>
        <span class="s1">quiversize = np.mean(np.diff(quiversize</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s5"># quiversize is now in Axes coordinates, and to convert back to data</span>
        <span class="s5"># coordinates, we need to run it through the inverse 3D transform. For</span>
        <span class="s5"># consistency, this uses a fixed elevation, azimuth, and roll.</span>
        <span class="s2">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s2">, </span><span class="s1">elev=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">azim=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">roll=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">invM = np.linalg.inv(self.get_proj())</span>
        <span class="s5"># elev=azim=roll=0 produces the Y-Z plane, so quiversize in 2D 'x' is</span>
        <span class="s5"># 'y' in 3D, hence the 1 index.</span>
        <span class="s1">quiversize = np.dot(invM</span><span class="s2">, </span><span class="s1">[quiversize</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s5"># Quivers use a fixed 15-degree arrow head, so scale up the length so</span>
        <span class="s5"># that the size corresponds to the base. In other words, this constant</span>
        <span class="s5"># corresponds to the equation tan(15) = (base / 2) / (arrow length).</span>
        <span class="s1">quiversize *= </span><span class="s4">1.8660254037844388</span>
        <span class="s1">eb_quiver_style = {**eb_cap_style</span><span class="s2">,</span>
                           <span class="s3">'length'</span><span class="s1">: quiversize</span><span class="s2">, </span><span class="s3">'arrow_length_ratio'</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span>
        <span class="s1">eb_quiver_style.pop(</span><span class="s3">'markersize'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s5"># loop over x-, y-, and z-direction and draw relevant elements</span>
        <span class="s2">for </span><span class="s1">zdir</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">err</span><span class="s2">, </span><span class="s1">lolims</span><span class="s2">, </span><span class="s1">uplims </span><span class="s2">in </span><span class="s1">zip(</span>
                <span class="s1">[</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z]</span><span class="s2">, </span><span class="s1">[xerr</span><span class="s2">, </span><span class="s1">yerr</span><span class="s2">, </span><span class="s1">zerr]</span><span class="s2">,</span>
                <span class="s1">[xlolims</span><span class="s2">, </span><span class="s1">ylolims</span><span class="s2">, </span><span class="s1">zlolims]</span><span class="s2">, </span><span class="s1">[xuplims</span><span class="s2">, </span><span class="s1">yuplims</span><span class="s2">, </span><span class="s1">zuplims]):</span>

            <span class="s1">dir_vector = art3d.get_dir_vector(zdir)</span>
            <span class="s1">i_zdir = i_xyz[zdir]</span>

            <span class="s2">if </span><span class="s1">err </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s2">if not </span><span class="s1">np.iterable(err):</span>
                <span class="s1">err = [err] * len(data)</span>

            <span class="s1">err = np.atleast_1d(err)</span>

            <span class="s5"># arrays fine here, they are booleans and hence not units</span>
            <span class="s1">lolims = np.broadcast_to(lolims</span><span class="s2">, </span><span class="s1">len(data)).astype(bool)</span>
            <span class="s1">uplims = np.broadcast_to(uplims</span><span class="s2">, </span><span class="s1">len(data)).astype(bool)</span>

            <span class="s5"># a nested list structure that expands to (xl,xh),(yl,yh),(zl,zh),</span>
            <span class="s5"># where x/y/z and l/h correspond to dimensions and low/high</span>
            <span class="s5"># positions of errorbars in a dimension we're looping over</span>
            <span class="s1">coorderr = [</span>
                <span class="s1">_extract_errs(err * dir_vector[i]</span><span class="s2">, </span><span class="s1">coord</span><span class="s2">, </span><span class="s1">lolims</span><span class="s2">, </span><span class="s1">uplims)</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">coord </span><span class="s2">in </span><span class="s1">enumerate([x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z])]</span>
            <span class="s1">(xl</span><span class="s2">, </span><span class="s1">xh)</span><span class="s2">, </span><span class="s1">(yl</span><span class="s2">, </span><span class="s1">yh)</span><span class="s2">, </span><span class="s1">(zl</span><span class="s2">, </span><span class="s1">zh) = coorderr</span>

            <span class="s5"># draws capmarkers - flat caps orthogonal to the error bars</span>
            <span class="s1">nolims = ~(lolims | uplims)</span>
            <span class="s2">if </span><span class="s1">nolims.any() </span><span class="s2">and </span><span class="s1">capsize &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">lo_caps_xyz = _apply_mask([xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl]</span><span class="s2">, </span><span class="s1">nolims &amp; everymask)</span>
                <span class="s1">hi_caps_xyz = _apply_mask([xh</span><span class="s2">, </span><span class="s1">yh</span><span class="s2">, </span><span class="s1">zh]</span><span class="s2">, </span><span class="s1">nolims &amp; everymask)</span>

                <span class="s5"># setting '_' for z-caps and '|' for x- and y-caps;</span>
                <span class="s5"># these markers will rotate as the viewing angle changes</span>
                <span class="s1">cap_lo = art3d.Line3D(*lo_caps_xyz</span><span class="s2">, </span><span class="s1">ls=</span><span class="s3">''</span><span class="s2">,</span>
                                      <span class="s1">marker=capmarker[i_zdir]</span><span class="s2">,</span>
                                      <span class="s1">**eb_cap_style)</span>
                <span class="s1">cap_hi = art3d.Line3D(*hi_caps_xyz</span><span class="s2">, </span><span class="s1">ls=</span><span class="s3">''</span><span class="s2">,</span>
                                      <span class="s1">marker=capmarker[i_zdir]</span><span class="s2">,</span>
                                      <span class="s1">**eb_cap_style)</span>
                <span class="s1">self.add_line(cap_lo)</span>
                <span class="s1">self.add_line(cap_hi)</span>
                <span class="s1">caplines.append(cap_lo)</span>
                <span class="s1">caplines.append(cap_hi)</span>

            <span class="s2">if </span><span class="s1">lolims.any():</span>
                <span class="s1">xh0</span><span class="s2">, </span><span class="s1">yh0</span><span class="s2">, </span><span class="s1">zh0 = _apply_mask([xh</span><span class="s2">, </span><span class="s1">yh</span><span class="s2">, </span><span class="s1">zh]</span><span class="s2">, </span><span class="s1">lolims &amp; everymask)</span>
                <span class="s1">self.quiver(xh0</span><span class="s2">, </span><span class="s1">yh0</span><span class="s2">, </span><span class="s1">zh0</span><span class="s2">, </span><span class="s1">*dir_vector</span><span class="s2">, </span><span class="s1">**eb_quiver_style)</span>
            <span class="s2">if </span><span class="s1">uplims.any():</span>
                <span class="s1">xl0</span><span class="s2">, </span><span class="s1">yl0</span><span class="s2">, </span><span class="s1">zl0 = _apply_mask([xl</span><span class="s2">, </span><span class="s1">yl</span><span class="s2">, </span><span class="s1">zl]</span><span class="s2">, </span><span class="s1">uplims &amp; everymask)</span>
                <span class="s1">self.quiver(xl0</span><span class="s2">, </span><span class="s1">yl0</span><span class="s2">, </span><span class="s1">zl0</span><span class="s2">, </span><span class="s1">*-dir_vector</span><span class="s2">, </span><span class="s1">**eb_quiver_style)</span>

            <span class="s1">errline = art3d.Line3DCollection(np.array(coorderr).T</span><span class="s2">,</span>
                                             <span class="s1">**eb_lines_style)</span>
            <span class="s1">self.add_collection(errline)</span>
            <span class="s1">errlines.append(errline)</span>
            <span class="s1">coorderrs.append(coorderr)</span>

        <span class="s1">coorderrs = np.array(coorderrs)</span>

        <span class="s2">def </span><span class="s1">_digout_minmax(err_arr</span><span class="s2">, </span><span class="s1">coord_label):</span>
            <span class="s2">return </span><span class="s1">(np.nanmin(err_arr[:</span><span class="s2">, </span><span class="s1">i_xyz[coord_label]</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:])</span><span class="s2">,</span>
                    <span class="s1">np.nanmax(err_arr[:</span><span class="s2">, </span><span class="s1">i_xyz[coord_label]</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:]))</span>

        <span class="s1">minx</span><span class="s2">, </span><span class="s1">maxx = _digout_minmax(coorderrs</span><span class="s2">, </span><span class="s3">'x'</span><span class="s1">)</span>
        <span class="s1">miny</span><span class="s2">, </span><span class="s1">maxy = _digout_minmax(coorderrs</span><span class="s2">, </span><span class="s3">'y'</span><span class="s1">)</span>
        <span class="s1">minz</span><span class="s2">, </span><span class="s1">maxz = _digout_minmax(coorderrs</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">)</span>
        <span class="s1">self.auto_scale_xyz((minx</span><span class="s2">, </span><span class="s1">maxx)</span><span class="s2">, </span><span class="s1">(miny</span><span class="s2">, </span><span class="s1">maxy)</span><span class="s2">, </span><span class="s1">(minz</span><span class="s2">, </span><span class="s1">maxz)</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s5"># Adapting errorbar containers for 3d case, assuming z-axis points &quot;up&quot;</span>
        <span class="s1">errorbar_container = mcontainer.ErrorbarContainer(</span>
            <span class="s1">(data_line</span><span class="s2">, </span><span class="s1">tuple(caplines)</span><span class="s2">, </span><span class="s1">tuple(errlines))</span><span class="s2">,</span>
            <span class="s1">has_xerr=(xerr </span><span class="s2">is not None or </span><span class="s1">yerr </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">has_yerr=(zerr </span><span class="s2">is not None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">label=label)</span>
        <span class="s1">self.containers.append(errorbar_container)</span>

        <span class="s2">return </span><span class="s1">errlines</span><span class="s2">, </span><span class="s1">caplines</span><span class="s2">, </span><span class="s1">limmarks</span>

    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">call_axes_locator=</span><span class="s2">True,</span>
                      <span class="s1">bbox_extra_artists=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">for_layout_only=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">ret = super().get_tightbbox(renderer</span><span class="s2">,</span>
                                    <span class="s1">call_axes_locator=call_axes_locator</span><span class="s2">,</span>
                                    <span class="s1">bbox_extra_artists=bbox_extra_artists</span><span class="s2">,</span>
                                    <span class="s1">for_layout_only=for_layout_only)</span>
        <span class="s1">batch = [ret]</span>
        <span class="s2">if </span><span class="s1">self._axis3don:</span>
            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self._axis_map.values():</span>
                <span class="s2">if </span><span class="s1">axis.get_visible():</span>
                    <span class="s1">axis_bb = martist._get_tightbbox_for_layout_only(</span>
                        <span class="s1">axis</span><span class="s2">, </span><span class="s1">renderer)</span>
                    <span class="s2">if </span><span class="s1">axis_bb:</span>
                        <span class="s1">batch.append(axis_bb)</span>
        <span class="s2">return </span><span class="s1">mtransforms.Bbox.union(batch)</span>

    <span class="s1">@_preprocess_data()</span>
    <span class="s2">def </span><span class="s1">stem(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">linefmt=</span><span class="s3">'C0-'</span><span class="s2">, </span><span class="s1">markerfmt=</span><span class="s3">'C0o'</span><span class="s2">, </span><span class="s1">basefmt=</span><span class="s3">'C3-'</span><span class="s2">,</span>
             <span class="s1">bottom=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">label=</span><span class="s2">None, </span><span class="s1">orientation=</span><span class="s3">'z'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a 3D stem plot. 
 
        A stem plot draws lines perpendicular to a baseline, and places markers 
        at the heads. By default, the baseline is defined by *x* and *y*, and 
        stems are drawn vertically from *bottom* to *z*. 
 
        Parameters 
        ---------- 
        x, y, z : array-like 
            The positions of the heads of the stems. The stems are drawn along 
            the *orientation*-direction from the baseline at *bottom* (in the 
            *orientation*-coordinate) to the heads. By default, the *x* and *y* 
            positions are used for the baseline and *z* for the head position, 
            but this can be changed by *orientation*. 
 
        linefmt : str, default: 'C0-' 
            A string defining the properties of the vertical lines. Usually, 
            this will be a color or a color and a linestyle: 
 
            =========  ============= 
            Character  Line Style 
            =========  ============= 
            ``'-'``    solid line 
            ``'--'``   dashed line 
            ``'-.'``   dash-dot line 
            ``':'``    dotted line 
            =========  ============= 
 
            Note: While it is technically possible to specify valid formats 
            other than color or color and linestyle (e.g. 'rx' or '-.'), this 
            is beyond the intention of the method and will most likely not 
            result in a reasonable plot. 
 
        markerfmt : str, default: 'C0o' 
            A string defining the properties of the markers at the stem heads. 
 
        basefmt : str, default: 'C3-' 
            A format string defining the properties of the baseline. 
 
        bottom : float, default: 0 
            The position of the baseline, in *orientation*-coordinates. 
 
        label : str, default: None 
            The label to use for the stems in legends. 
 
        orientation : {'x', 'y', 'z'}, default: 'z' 
            The direction along which stems are drawn. 
 
        data : indexable object, optional 
            DATA_PARAMETER_PLACEHOLDER 
 
        Returns 
        ------- 
        `.StemContainer` 
            The container may be treated like a tuple 
            (*markerline*, *stemlines*, *baseline*) 
 
        Examples 
        -------- 
        .. plot:: gallery/mplot3d/stem3d_demo.py 
        &quot;&quot;&quot;</span>

        <span class="s2">from </span><span class="s1">matplotlib.container </span><span class="s2">import </span><span class="s1">StemContainer</span>

        <span class="s1">had_data = self.has_data()</span>

        <span class="s1">_api.check_in_list([</span><span class="s3">'x'</span><span class="s2">, </span><span class="s3">'y'</span><span class="s2">, </span><span class="s3">'z'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">orientation=orientation)</span>

        <span class="s1">xlim = (np.min(x)</span><span class="s2">, </span><span class="s1">np.max(x))</span>
        <span class="s1">ylim = (np.min(y)</span><span class="s2">, </span><span class="s1">np.max(y))</span>
        <span class="s1">zlim = (np.min(z)</span><span class="s2">, </span><span class="s1">np.max(z))</span>

        <span class="s5"># Determine the appropriate plane for the baseline and the direction of</span>
        <span class="s5"># stemlines based on the value of orientation.</span>
        <span class="s2">if </span><span class="s1">orientation == </span><span class="s3">'x'</span><span class="s1">:</span>
            <span class="s1">basex</span><span class="s2">, </span><span class="s1">basexlim = y</span><span class="s2">, </span><span class="s1">ylim</span>
            <span class="s1">basey</span><span class="s2">, </span><span class="s1">baseylim = z</span><span class="s2">, </span><span class="s1">zlim</span>
            <span class="s1">lines = [[(bottom</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz)</span><span class="s2">, </span><span class="s1">(thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz)]</span>
                     <span class="s2">for </span><span class="s1">thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz </span><span class="s2">in </span><span class="s1">zip(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)]</span>
        <span class="s2">elif </span><span class="s1">orientation == </span><span class="s3">'y'</span><span class="s1">:</span>
            <span class="s1">basex</span><span class="s2">, </span><span class="s1">basexlim = x</span><span class="s2">, </span><span class="s1">xlim</span>
            <span class="s1">basey</span><span class="s2">, </span><span class="s1">baseylim = z</span><span class="s2">, </span><span class="s1">zlim</span>
            <span class="s1">lines = [[(thisx</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">thisz)</span><span class="s2">, </span><span class="s1">(thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz)]</span>
                     <span class="s2">for </span><span class="s1">thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz </span><span class="s2">in </span><span class="s1">zip(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">basex</span><span class="s2">, </span><span class="s1">basexlim = x</span><span class="s2">, </span><span class="s1">xlim</span>
            <span class="s1">basey</span><span class="s2">, </span><span class="s1">baseylim = y</span><span class="s2">, </span><span class="s1">ylim</span>
            <span class="s1">lines = [[(thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">bottom)</span><span class="s2">, </span><span class="s1">(thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz)]</span>
                     <span class="s2">for </span><span class="s1">thisx</span><span class="s2">, </span><span class="s1">thisy</span><span class="s2">, </span><span class="s1">thisz </span><span class="s2">in </span><span class="s1">zip(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z)]</span>

        <span class="s5"># Determine style for stem lines.</span>
        <span class="s1">linestyle</span><span class="s2">, </span><span class="s1">linemarker</span><span class="s2">, </span><span class="s1">linecolor = _process_plot_format(linefmt)</span>
        <span class="s2">if </span><span class="s1">linestyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">linestyle = mpl.rcParams[</span><span class="s3">'lines.linestyle'</span><span class="s1">]</span>

        <span class="s5"># Plot everything in required order.</span>
        <span class="s1">baseline</span><span class="s2">, </span><span class="s1">= self.plot(basex</span><span class="s2">, </span><span class="s1">basey</span><span class="s2">, </span><span class="s1">basefmt</span><span class="s2">, </span><span class="s1">zs=bottom</span><span class="s2">,</span>
                              <span class="s1">zdir=orientation</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'_nolegend_'</span><span class="s1">)</span>
        <span class="s1">stemlines = art3d.Line3DCollection(</span>
            <span class="s1">lines</span><span class="s2">, </span><span class="s1">linestyles=linestyle</span><span class="s2">, </span><span class="s1">colors=linecolor</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'_nolegend_'</span><span class="s1">)</span>
        <span class="s1">self.add_collection(stemlines)</span>
        <span class="s1">markerline</span><span class="s2">, </span><span class="s1">= self.plot(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">markerfmt</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'_nolegend_'</span><span class="s1">)</span>

        <span class="s1">stem_container = StemContainer((markerline</span><span class="s2">, </span><span class="s1">stemlines</span><span class="s2">, </span><span class="s1">baseline)</span><span class="s2">,</span>
                                       <span class="s1">label=label)</span>
        <span class="s1">self.add_container(stem_container)</span>

        <span class="s1">jx</span><span class="s2">, </span><span class="s1">jy</span><span class="s2">, </span><span class="s1">jz = art3d.juggle_axes(basexlim</span><span class="s2">, </span><span class="s1">baseylim</span><span class="s2">, </span><span class="s1">[bottom</span><span class="s2">, </span><span class="s1">bottom]</span><span class="s2">,</span>
                                       <span class="s1">orientation)</span>
        <span class="s1">self.auto_scale_xyz([*jx</span><span class="s2">, </span><span class="s1">*xlim]</span><span class="s2">, </span><span class="s1">[*jy</span><span class="s2">, </span><span class="s1">*ylim]</span><span class="s2">, </span><span class="s1">[*jz</span><span class="s2">, </span><span class="s1">*zlim]</span><span class="s2">, </span><span class="s1">had_data)</span>

        <span class="s2">return </span><span class="s1">stem_container</span>

    <span class="s1">stem3D = stem</span>


<span class="s2">def </span><span class="s1">get_test_data(delta=</span><span class="s4">0.05</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Return a tuple X, Y, Z with a test data set.&quot;&quot;&quot;</span>
    <span class="s1">x = y = np.arange(-</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">delta)</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = np.meshgrid(x</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s1">Z1 = np.exp(-(X**</span><span class="s4">2 </span><span class="s1">+ Y**</span><span class="s4">2</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">) / (</span><span class="s4">2 </span><span class="s1">* np.pi)</span>
    <span class="s1">Z2 = (np.exp(-(((X - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">1.5</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ ((Y - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">0.5</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">) /</span>
          <span class="s1">(</span><span class="s4">2 </span><span class="s1">* np.pi * </span><span class="s4">0.5 </span><span class="s1">* </span><span class="s4">1.5</span><span class="s1">))</span>
    <span class="s1">Z = Z2 - Z1</span>

    <span class="s1">X = X * </span><span class="s4">10</span>
    <span class="s1">Y = Y * </span><span class="s4">10</span>
    <span class="s1">Z = Z * </span><span class="s4">500</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">Z</span>
</pre>
</body>
</html>