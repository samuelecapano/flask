<html>
<head>
<title>test_transforms.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_transforms.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">copy</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_allclose</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal)</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">scale</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
<span class="s0">import </span><span class="s1">matplotlib.patches </span><span class="s0">as </span><span class="s1">mpatches</span>
<span class="s0">import </span><span class="s1">matplotlib.transforms </span><span class="s0">as </span><span class="s1">mtransforms</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">matplotlib.testing.decorators </span><span class="s0">import </span><span class="s1">image_comparison</span><span class="s0">, </span><span class="s1">check_figures_equal</span>


<span class="s0">def </span><span class="s1">test_non_affine_caching():</span>
    <span class="s0">class </span><span class="s1">AssertingNonAffineTransform(mtransforms.Transform):</span>
        <span class="s2">&quot;&quot;&quot; 
        This transform raises an assertion error when called when it 
        shouldn't be and ``self.raise_on_transform`` is True. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">input_dims = output_dims = </span><span class="s3">2</span>
        <span class="s1">is_affine = </span><span class="s0">False</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.raise_on_transform = </span><span class="s0">False</span>
            <span class="s1">self.underlying_transform = mtransforms.Affine2D().scale(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">transform_path_non_affine(self</span><span class="s0">, </span><span class="s1">path):</span>
            <span class="s0">assert not </span><span class="s1">self.raise_on_transform</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s4">'Invalidated affine part of transform unnecessarily.'</span>
            <span class="s0">return </span><span class="s1">self.underlying_transform.transform_path(path)</span>
        <span class="s1">transform_path = transform_path_non_affine</span>

        <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">path):</span>
            <span class="s0">assert not </span><span class="s1">self.raise_on_transform</span><span class="s0">, </span><span class="s1">\</span>
                <span class="s4">'Invalidated affine part of transform unnecessarily.'</span>
            <span class="s0">return </span><span class="s1">self.underlying_transform.transform(path)</span>
        <span class="s1">transform = transform_non_affine</span>

    <span class="s1">my_trans = AssertingNonAffineTransform()</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">plt.plot(np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=my_trans + ax.transData)</span>
    <span class="s1">plt.draw()</span>
    <span class="s5"># enable the transform to raise an exception if it's non-affine transform</span>
    <span class="s5"># method is triggered again.</span>
    <span class="s1">my_trans.raise_on_transform = </span><span class="s0">True</span>
    <span class="s1">ax.transAxes.invalidate()</span>
    <span class="s1">plt.draw()</span>


<span class="s0">def </span><span class="s1">test_external_transform_api():</span>
    <span class="s0">class </span><span class="s1">ScaledBy:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">scale_factor):</span>
            <span class="s1">self._scale_factor = scale_factor</span>

        <span class="s0">def </span><span class="s1">_as_mpl_transform(self</span><span class="s0">, </span><span class="s1">axes):</span>
            <span class="s0">return </span><span class="s1">(mtransforms.Affine2D().scale(self._scale_factor)</span>
                    <span class="s1">+ axes.transData)</span>

    <span class="s1">ax = plt.axes()</span>
    <span class="s1">line</span><span class="s0">, </span><span class="s1">= plt.plot(np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=ScaledBy(</span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">ax.set_xlim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">ax.set_ylim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s5"># assert that the top transform of the line is the scale transform.</span>
    <span class="s1">assert_allclose(line.get_transform()._a.get_matrix()</span><span class="s0">,</span>
                    <span class="s1">mtransforms.Affine2D().scale(</span><span class="s3">10</span><span class="s1">).get_matrix())</span>


<span class="s1">@image_comparison([</span><span class="s4">'pre_transform_data'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True, </span><span class="s1">style=</span><span class="s4">'mpl20'</span><span class="s0">,</span>
                  <span class="s1">tol=</span><span class="s3">0.05</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_pre_transform_plotting():</span>
    <span class="s5"># a catch-all for as many as possible plot layouts which handle</span>
    <span class="s5"># pre-transforming the data NOTE: The axis range is important in this</span>
    <span class="s5"># plot. It should be x10 what the data suggests it should be</span>

    <span class="s1">ax = plt.axes()</span>
    <span class="s1">times10 = mtransforms.Affine2D().scale(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s1">ax.contourf(np.arange(</span><span class="s3">48</span><span class="s1">).reshape(</span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=times10 + ax.transData)</span>

    <span class="s1">ax.pcolormesh(np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">np.linspace(</span><span class="s3">5.5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">np.arange(</span><span class="s3">48</span><span class="s1">).reshape(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
                  <span class="s1">transform=times10 + ax.transData)</span>

    <span class="s1">ax.scatter(np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
               <span class="s1">transform=times10 + ax.transData)</span>

    <span class="s1">x = np.linspace(</span><span class="s3">8</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">u = </span><span class="s3">2</span><span class="s1">*np.sin(x) + np.cos(y[:</span><span class="s0">, </span><span class="s1">np.newaxis])</span>
    <span class="s1">v = np.sin(x) - np.cos(y[:</span><span class="s0">, </span><span class="s1">np.newaxis])</span>

    <span class="s1">ax.streamplot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">transform=times10 + ax.transData</span><span class="s0">,</span>
                  <span class="s1">linewidth=np.hypot(u</span><span class="s0">, </span><span class="s1">v))</span>

    <span class="s5"># reduce the vector data down a bit for barb and quiver plotting</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = x[::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y[::</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">u</span><span class="s0">, </span><span class="s1">v = u[::</span><span class="s3">3</span><span class="s0">, </span><span class="s1">::</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">v[::</span><span class="s3">3</span><span class="s0">, </span><span class="s1">::</span><span class="s3">3</span><span class="s1">]</span>

    <span class="s1">ax.quiver(x</span><span class="s0">, </span><span class="s1">y + </span><span class="s3">5</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">transform=times10 + ax.transData)</span>

    <span class="s1">ax.barbs(x - </span><span class="s3">3</span><span class="s0">, </span><span class="s1">y + </span><span class="s3">5</span><span class="s0">, </span><span class="s1">u**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">v**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">transform=times10 + ax.transData)</span>


<span class="s0">def </span><span class="s1">test_contour_pre_transform_limits():</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(np.linspace(</span><span class="s3">15</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s3">12.4</span><span class="s0">, </span><span class="s3">12.5</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
    <span class="s1">ax.contourf(xs</span><span class="s0">, </span><span class="s1">ys</span><span class="s0">, </span><span class="s1">np.log(xs * ys)</span><span class="s0">,</span>
                <span class="s1">transform=mtransforms.Affine2D().scale(</span><span class="s3">0.1</span><span class="s1">) + ax.transData)</span>

    <span class="s1">expected = np.array([[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.24</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">1.25</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(expected</span><span class="s0">, </span><span class="s1">ax.dataLim.get_points())</span>


<span class="s0">def </span><span class="s1">test_pcolor_pre_transform_limits():</span>
    <span class="s5"># Based on test_contour_pre_transform_limits()</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(np.linspace(</span><span class="s3">15</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s3">12.4</span><span class="s0">, </span><span class="s3">12.5</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
    <span class="s1">ax.pcolor(xs</span><span class="s0">, </span><span class="s1">ys</span><span class="s0">, </span><span class="s1">np.log(xs * ys)[:-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
              <span class="s1">transform=mtransforms.Affine2D().scale(</span><span class="s3">0.1</span><span class="s1">) + ax.transData)</span>

    <span class="s1">expected = np.array([[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.24</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">1.25</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(expected</span><span class="s0">, </span><span class="s1">ax.dataLim.get_points())</span>


<span class="s0">def </span><span class="s1">test_pcolormesh_pre_transform_limits():</span>
    <span class="s5"># Based on test_contour_pre_transform_limits()</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(np.linspace(</span><span class="s3">15</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s3">12.4</span><span class="s0">, </span><span class="s3">12.5</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
    <span class="s1">ax.pcolormesh(xs</span><span class="s0">, </span><span class="s1">ys</span><span class="s0">, </span><span class="s1">np.log(xs * ys)[:-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">transform=mtransforms.Affine2D().scale(</span><span class="s3">0.1</span><span class="s1">) + ax.transData)</span>

    <span class="s1">expected = np.array([[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.24</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">1.25</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(expected</span><span class="s0">, </span><span class="s1">ax.dataLim.get_points())</span>


<span class="s0">def </span><span class="s1">test_Affine2D_from_values():</span>
    <span class="s1">points = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s1">])</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">60</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">80</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">t = mtransforms.Affine2D.from_values(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">actual = t.transform(points)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]])</span>
    <span class="s1">assert_almost_equal(actual</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_affine_inverted_invalidated():</span>
    <span class="s5"># Ensure that the an affine transform is not declared valid on access</span>
    <span class="s1">point = [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">t = mtransforms.Affine2D()</span>

    <span class="s1">assert_almost_equal(point</span><span class="s0">, </span><span class="s1">t.transform(t.inverted().transform(point)))</span>
    <span class="s5"># Change and access the transform</span>
    <span class="s1">t.translate(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">).get_matrix()</span>
    <span class="s1">assert_almost_equal(point</span><span class="s0">, </span><span class="s1">t.transform(t.inverted().transform(point)))</span>


<span class="s0">def </span><span class="s1">test_clipping_of_log():</span>
    <span class="s5"># issue 804</span>
    <span class="s1">path = Path._create_closed([(</span><span class="s3">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">99</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">-</span><span class="s3">99</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.4</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)])</span>
    <span class="s5"># something like this happens in plotting logarithmic histograms</span>
    <span class="s1">trans = mtransforms.BlendedGenericTransform(</span>
        <span class="s1">mtransforms.Affine2D()</span><span class="s0">, </span><span class="s1">scale.LogTransform(</span><span class="s3">10</span><span class="s0">, </span><span class="s4">'clip'</span><span class="s1">))</span>
    <span class="s1">tpath = trans.transform_path_non_affine(path)</span>
    <span class="s1">result = tpath.iter_segments(trans.get_affine()</span><span class="s0">,</span>
                                 <span class="s1">clip=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">simplify=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">tpoints</span><span class="s0">, </span><span class="s1">tcodes = zip(*result)</span>
    <span class="s1">assert_allclose(tcodes</span><span class="s0">, </span><span class="s1">path.codes[:-</span><span class="s3">1</span><span class="s1">])  </span><span class="s5"># No longer closed.</span>


<span class="s0">class </span><span class="s1">NonAffineForTest(mtransforms.Transform):</span>
    <span class="s2">&quot;&quot;&quot; 
    A class which looks like a non affine transform, but does whatever 
    the given transform does (even if it is affine). This is very useful 
    for testing NonAffine behaviour with a simple Affine transform. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">is_affine = </span><span class="s0">False</span>
    <span class="s1">output_dims = </span><span class="s3">2</span>
    <span class="s1">input_dims = </span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">real_trans</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.real_trans = real_trans</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">transform_non_affine(self</span><span class="s0">, </span><span class="s1">values):</span>
        <span class="s0">return </span><span class="s1">self.real_trans.transform(values)</span>

    <span class="s0">def </span><span class="s1">transform_path_non_affine(self</span><span class="s0">, </span><span class="s1">path):</span>
        <span class="s0">return </span><span class="s1">self.real_trans.transform_path(path)</span>


<span class="s0">class </span><span class="s1">TestBasicTransform:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>

        <span class="s1">self.ta1 = mtransforms.Affine2D(shorthand_name=</span><span class="s4">'ta1'</span><span class="s1">).rotate(np.pi / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">self.ta2 = mtransforms.Affine2D(shorthand_name=</span><span class="s4">'ta2'</span><span class="s1">).translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">self.ta3 = mtransforms.Affine2D(shorthand_name=</span><span class="s4">'ta3'</span><span class="s1">).scale(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">self.tn1 = NonAffineForTest(mtransforms.Affine2D().translate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">shorthand_name=</span><span class="s4">'tn1'</span><span class="s1">)</span>
        <span class="s1">self.tn2 = NonAffineForTest(mtransforms.Affine2D().translate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">shorthand_name=</span><span class="s4">'tn2'</span><span class="s1">)</span>
        <span class="s1">self.tn3 = NonAffineForTest(mtransforms.Affine2D().translate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                    <span class="s1">shorthand_name=</span><span class="s4">'tn3'</span><span class="s1">)</span>

        <span class="s5"># creates a transform stack which looks like ((A, (N, A)), A)</span>
        <span class="s1">self.stack1 = (self.ta1 + (self.tn1 + self.ta2)) + self.ta3</span>
        <span class="s5"># creates a transform stack which looks like (((A, N), A), A)</span>
        <span class="s1">self.stack2 = self.ta1 + self.tn1 + self.ta2 + self.ta3</span>
        <span class="s5"># creates a transform stack which is a subset of stack2</span>
        <span class="s1">self.stack2_subset = self.tn1 + self.ta2 + self.ta3</span>

        <span class="s5"># when in debug, the transform stacks can produce dot images:</span>
<span class="s5">#        self.stack1.write_graphviz(file('stack1.dot', 'w'))</span>
<span class="s5">#        self.stack2.write_graphviz(file('stack2.dot', 'w'))</span>
<span class="s5">#        self.stack2_subset.write_graphviz(file('stack2_subset.dot', 'w'))</span>

    <span class="s0">def </span><span class="s1">test_transform_depth(self):</span>
        <span class="s0">assert </span><span class="s1">self.stack1.depth == </span><span class="s3">4</span>
        <span class="s0">assert </span><span class="s1">self.stack2.depth == </span><span class="s3">4</span>
        <span class="s0">assert </span><span class="s1">self.stack2_subset.depth == </span><span class="s3">3</span>

    <span class="s0">def </span><span class="s1">test_left_to_right_iteration(self):</span>
        <span class="s1">stack3 = (self.ta1 + (self.tn1 + (self.ta2 + self.tn2))) + self.ta3</span>
<span class="s5">#        stack3.write_graphviz(file('stack3.dot', 'w'))</span>

        <span class="s1">target_transforms = [stack3</span><span class="s0">,</span>
                             <span class="s1">(self.tn1 + (self.ta2 + self.tn2)) + self.ta3</span><span class="s0">,</span>
                             <span class="s1">(self.ta2 + self.tn2) + self.ta3</span><span class="s0">,</span>
                             <span class="s1">self.tn2 + self.ta3</span><span class="s0">,</span>
                             <span class="s1">self.ta3</span><span class="s0">,</span>
                             <span class="s1">]</span>
        <span class="s1">r = [rh </span><span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">rh </span><span class="s0">in </span><span class="s1">stack3._iter_break_from_left_to_right()]</span>
        <span class="s0">assert </span><span class="s1">len(r) == len(target_transforms)</span>

        <span class="s0">for </span><span class="s1">target_stack</span><span class="s0">, </span><span class="s1">stack </span><span class="s0">in </span><span class="s1">zip(target_transforms</span><span class="s0">, </span><span class="s1">r):</span>
            <span class="s0">assert </span><span class="s1">target_stack == stack</span>

    <span class="s0">def </span><span class="s1">test_transform_shortcuts(self):</span>
        <span class="s0">assert </span><span class="s1">self.stack1 - self.stack2_subset == self.ta1</span>
        <span class="s0">assert </span><span class="s1">self.stack2 - self.stack2_subset == self.ta1</span>

        <span class="s0">assert </span><span class="s1">self.stack2_subset - self.stack2 == self.ta1.inverted()</span>
        <span class="s0">assert </span><span class="s1">(self.stack2_subset - self.stack2).depth == </span><span class="s3">1</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">self.stack1 - self.stack2</span>

        <span class="s1">aff1 = self.ta1 + (self.ta2 + self.ta3)</span>
        <span class="s1">aff2 = self.ta2 + self.ta3</span>

        <span class="s0">assert </span><span class="s1">aff1 - aff2 == self.ta1</span>
        <span class="s0">assert </span><span class="s1">aff1 - self.ta2 == aff1 + self.ta2.inverted()</span>

        <span class="s0">assert </span><span class="s1">self.stack1 - self.ta3 == self.ta1 + (self.tn1 + self.ta2)</span>
        <span class="s0">assert </span><span class="s1">self.stack2 - self.ta3 == self.ta1 + self.tn1 + self.ta2</span>

        <span class="s0">assert </span><span class="s1">((self.ta2 + self.ta3) - self.ta3 + self.ta3 ==</span>
                <span class="s1">self.ta2 + self.ta3)</span>

    <span class="s0">def </span><span class="s1">test_contains_branch(self):</span>
        <span class="s1">r1 = (self.ta2 + self.ta1)</span>
        <span class="s1">r2 = (self.ta2 + self.ta1)</span>
        <span class="s0">assert </span><span class="s1">r1 == r2</span>
        <span class="s0">assert </span><span class="s1">r1 != self.ta1</span>
        <span class="s0">assert </span><span class="s1">r1.contains_branch(r2)</span>
        <span class="s0">assert </span><span class="s1">r1.contains_branch(self.ta1)</span>
        <span class="s0">assert not </span><span class="s1">r1.contains_branch(self.ta2)</span>
        <span class="s0">assert not </span><span class="s1">r1.contains_branch(self.ta2 + self.ta2)</span>

        <span class="s0">assert </span><span class="s1">r1 == r2</span>

        <span class="s0">assert </span><span class="s1">self.stack1.contains_branch(self.ta3)</span>
        <span class="s0">assert </span><span class="s1">self.stack2.contains_branch(self.ta3)</span>

        <span class="s0">assert </span><span class="s1">self.stack1.contains_branch(self.stack2_subset)</span>
        <span class="s0">assert </span><span class="s1">self.stack2.contains_branch(self.stack2_subset)</span>

        <span class="s0">assert not </span><span class="s1">self.stack2_subset.contains_branch(self.stack1)</span>
        <span class="s0">assert not </span><span class="s1">self.stack2_subset.contains_branch(self.stack2)</span>

        <span class="s0">assert </span><span class="s1">self.stack1.contains_branch(self.ta2 + self.ta3)</span>
        <span class="s0">assert </span><span class="s1">self.stack2.contains_branch(self.ta2 + self.ta3)</span>

        <span class="s0">assert not </span><span class="s1">self.stack1.contains_branch(self.tn1 + self.ta2)</span>

    <span class="s0">def </span><span class="s1">test_affine_simplification(self):</span>
        <span class="s5"># tests that a transform stack only calls as much is absolutely</span>
        <span class="s5"># necessary &quot;non-affine&quot; allowing the best possible optimization with</span>
        <span class="s5"># complex transformation stacks.</span>
        <span class="s1">points = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]]</span><span class="s0">,</span>
                          <span class="s1">dtype=np.float64)</span>
        <span class="s1">na_pts = self.stack1.transform_non_affine(points)</span>
        <span class="s1">all_pts = self.stack1.transform(points)</span>

        <span class="s1">na_expected = np.array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">19.</span><span class="s0">, </span><span class="s3">12.</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">all_expected = np.array([[</span><span class="s3">11.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">9.</span><span class="s0">, </span><span class="s3">24.</span><span class="s1">]</span><span class="s0">,</span>
                                 <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">11.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]]</span><span class="s0">,</span>
                                <span class="s1">dtype=np.float64)</span>

        <span class="s5"># check we have the expected results from doing the affine part only</span>
        <span class="s1">assert_array_almost_equal(na_pts</span><span class="s0">, </span><span class="s1">na_expected)</span>
        <span class="s5"># check we have the expected results from a full transformation</span>
        <span class="s1">assert_array_almost_equal(all_pts</span><span class="s0">, </span><span class="s1">all_expected)</span>
        <span class="s5"># check we have the expected results from doing the transformation in</span>
        <span class="s5"># two steps</span>
        <span class="s1">assert_array_almost_equal(self.stack1.transform_affine(na_pts)</span><span class="s0">,</span>
                                  <span class="s1">all_expected)</span>
        <span class="s5"># check that getting the affine transformation first, then fully</span>
        <span class="s5"># transforming using that yields the same result as before.</span>
        <span class="s1">assert_array_almost_equal(self.stack1.get_affine().transform(na_pts)</span><span class="s0">,</span>
                                  <span class="s1">all_expected)</span>

        <span class="s5"># check that the affine part of stack1 &amp; stack2 are equivalent</span>
        <span class="s5"># (i.e. the optimization is working)</span>
        <span class="s1">expected_result = (self.ta2 + self.ta3).get_matrix()</span>
        <span class="s1">result = self.stack1.get_affine().get_matrix()</span>
        <span class="s1">assert_array_equal(expected_result</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s1">result = self.stack2.get_affine().get_matrix()</span>
        <span class="s1">assert_array_equal(expected_result</span><span class="s0">, </span><span class="s1">result)</span>


<span class="s0">class </span><span class="s1">TestTransformPlotInterface:</span>
    <span class="s0">def </span><span class="s1">test_line_extent_axes_coords(self):</span>
        <span class="s5"># a simple line in axes coordinates</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">ax.plot([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.9</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">transform=ax.transAxes)</span>
        <span class="s1">assert_array_equal(ax.dataLim.get_points()</span><span class="s0">,</span>
                           <span class="s1">np.array([[np.inf</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
                                     <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">-np.inf]]))</span>

    <span class="s0">def </span><span class="s1">test_line_extent_data_coords(self):</span>
        <span class="s5"># a simple line in data coordinates</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">ax.plot([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.9</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">transform=ax.transData)</span>
        <span class="s1">assert_array_equal(ax.dataLim.get_points()</span><span class="s0">,</span>
                           <span class="s1">np.array([[</span><span class="s3">0.1</span><span class="s0">,  </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.2</span><span class="s0">,  </span><span class="s3">0.9</span><span class="s1">]]))</span>

    <span class="s0">def </span><span class="s1">test_line_extent_compound_coords1(self):</span>
        <span class="s5"># a simple line in data coordinates in the y component, and in axes</span>
        <span class="s5"># coordinates in the x</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">trans = mtransforms.blended_transform_factory(ax.transAxes</span><span class="s0">,</span>
                                                      <span class="s1">ax.transData)</span>
        <span class="s1">ax.plot([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">35</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">18</span><span class="s1">]</span><span class="s0">, </span><span class="s1">transform=trans)</span>
        <span class="s1">assert_array_equal(ax.dataLim.get_points()</span><span class="s0">,</span>
                           <span class="s1">np.array([[np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5.</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s3">35.</span><span class="s1">]]))</span>

    <span class="s0">def </span><span class="s1">test_line_extent_predata_transform_coords(self):</span>
        <span class="s5"># a simple line in (offset + data) coordinates</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">trans = mtransforms.Affine2D().scale(</span><span class="s3">10</span><span class="s1">) + ax.transData</span>
        <span class="s1">ax.plot([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">35</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">18</span><span class="s1">]</span><span class="s0">, </span><span class="s1">transform=trans)</span>
        <span class="s1">assert_array_equal(ax.dataLim.get_points()</span><span class="s0">,</span>
                           <span class="s1">np.array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s3">50.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">12.</span><span class="s0">, </span><span class="s3">350.</span><span class="s1">]]))</span>

    <span class="s0">def </span><span class="s1">test_line_extent_compound_coords2(self):</span>
        <span class="s5"># a simple line in (offset + data) coordinates in the y component, and</span>
        <span class="s5"># in axes coordinates in the x</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">trans = mtransforms.blended_transform_factory(</span>
            <span class="s1">ax.transAxes</span><span class="s0">, </span><span class="s1">mtransforms.Affine2D().scale(</span><span class="s3">10</span><span class="s1">) + ax.transData)</span>
        <span class="s1">ax.plot([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.2</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">35</span><span class="s0">, </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">18</span><span class="s1">]</span><span class="s0">, </span><span class="s1">transform=trans)</span>
        <span class="s1">assert_array_equal(ax.dataLim.get_points()</span><span class="s0">,</span>
                           <span class="s1">np.array([[np.inf</span><span class="s0">, </span><span class="s1">-</span><span class="s3">50.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s3">350.</span><span class="s1">]]))</span>

    <span class="s0">def </span><span class="s1">test_line_extents_affine(self):</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">offset = mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">plt.plot(np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=offset + ax.transData)</span>
        <span class="s1">expected_data_lim = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">9.</span><span class="s0">,  </span><span class="s3">9.</span><span class="s1">]]) + </span><span class="s3">10</span>
        <span class="s1">assert_array_almost_equal(ax.dataLim.get_points()</span><span class="s0">, </span><span class="s1">expected_data_lim)</span>

    <span class="s0">def </span><span class="s1">test_line_extents_non_affine(self):</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">offset = mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">na_offset = NonAffineForTest(mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">plt.plot(np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=offset + na_offset + ax.transData)</span>
        <span class="s1">expected_data_lim = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">9.</span><span class="s0">,  </span><span class="s3">9.</span><span class="s1">]]) + </span><span class="s3">20</span>
        <span class="s1">assert_array_almost_equal(ax.dataLim.get_points()</span><span class="s0">, </span><span class="s1">expected_data_lim)</span>

    <span class="s0">def </span><span class="s1">test_pathc_extents_non_affine(self):</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">offset = mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">na_offset = NonAffineForTest(mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">pth = Path([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">patch = mpatches.PathPatch(pth</span><span class="s0">,</span>
                                   <span class="s1">transform=offset + na_offset + ax.transData)</span>
        <span class="s1">ax.add_patch(patch)</span>
        <span class="s1">expected_data_lim = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10.</span><span class="s0">,  </span><span class="s3">10.</span><span class="s1">]]) + </span><span class="s3">20</span>
        <span class="s1">assert_array_almost_equal(ax.dataLim.get_points()</span><span class="s0">, </span><span class="s1">expected_data_lim)</span>

    <span class="s0">def </span><span class="s1">test_pathc_extents_affine(self):</span>
        <span class="s1">ax = plt.axes()</span>
        <span class="s1">offset = mtransforms.Affine2D().translate(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">pth = Path([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">patch = mpatches.PathPatch(pth</span><span class="s0">, </span><span class="s1">transform=offset + ax.transData)</span>
        <span class="s1">ax.add_patch(patch)</span>
        <span class="s1">expected_data_lim = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">10.</span><span class="s0">,  </span><span class="s3">10.</span><span class="s1">]]) + </span><span class="s3">10</span>
        <span class="s1">assert_array_almost_equal(ax.dataLim.get_points()</span><span class="s0">, </span><span class="s1">expected_data_lim)</span>

    <span class="s0">def </span><span class="s1">test_line_extents_for_non_affine_transData(self):</span>
        <span class="s1">ax = plt.axes(projection=</span><span class="s4">'polar'</span><span class="s1">)</span>
        <span class="s5"># add 10 to the radius of the data</span>
        <span class="s1">offset = mtransforms.Affine2D().translate(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">plt.plot(np.arange(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">transform=offset + ax.transData)</span>
        <span class="s5"># the data lim of a polar plot is stored in coordinates</span>
        <span class="s5"># before a transData transformation, hence the data limits</span>
        <span class="s5"># are not what is being shown on the actual plot.</span>
        <span class="s1">expected_data_lim = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">9.</span><span class="s0">,  </span><span class="s3">9.</span><span class="s1">]]) + [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s1">assert_array_almost_equal(ax.dataLim.get_points()</span><span class="s0">, </span><span class="s1">expected_data_lim)</span>


<span class="s0">def </span><span class="s1">assert_bbox_eq(bbox1</span><span class="s0">, </span><span class="s1">bbox2):</span>
    <span class="s1">assert_array_equal(bbox1.bounds</span><span class="s0">, </span><span class="s1">bbox2.bounds)</span>


<span class="s0">def </span><span class="s1">test_bbox_frozen_copies_minpos():</span>
    <span class="s1">bbox = mtransforms.Bbox.from_extents(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">minpos=</span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s1">frozen = bbox.frozen()</span>
    <span class="s1">assert_array_equal(frozen.minpos</span><span class="s0">, </span><span class="s1">bbox.minpos)</span>


<span class="s0">def </span><span class="s1">test_bbox_intersection():</span>
    <span class="s1">bbox_from_ext = mtransforms.Bbox.from_extents</span>
    <span class="s1">inter = mtransforms.Bbox.intersection</span>

    <span class="s1">r1 = bbox_from_ext(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">r2 = bbox_from_ext(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">)</span>
    <span class="s1">r3 = bbox_from_ext(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.75</span><span class="s0">, </span><span class="s3">0.75</span><span class="s1">)</span>
    <span class="s1">r4 = bbox_from_ext(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">)</span>
    <span class="s1">r5 = bbox_from_ext(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s5"># self intersection -&gt; no change</span>
    <span class="s1">assert_bbox_eq(inter(r1</span><span class="s0">, </span><span class="s1">r1)</span><span class="s0">, </span><span class="s1">r1)</span>
    <span class="s5"># simple intersection</span>
    <span class="s1">assert_bbox_eq(inter(r1</span><span class="s0">, </span><span class="s1">r2)</span><span class="s0">, </span><span class="s1">bbox_from_ext(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s5"># r3 contains r2</span>
    <span class="s1">assert_bbox_eq(inter(r1</span><span class="s0">, </span><span class="s1">r3)</span><span class="s0">, </span><span class="s1">r3)</span>
    <span class="s5"># no intersection</span>
    <span class="s0">assert </span><span class="s1">inter(r1</span><span class="s0">, </span><span class="s1">r4) </span><span class="s0">is None</span>
    <span class="s5"># single point</span>
    <span class="s1">assert_bbox_eq(inter(r1</span><span class="s0">, </span><span class="s1">r5)</span><span class="s0">, </span><span class="s1">bbox_from_ext(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_bbox_as_strings():</span>
    <span class="s1">b = mtransforms.Bbox([[</span><span class="s3">.5</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">.75</span><span class="s0">, </span><span class="s3">.75</span><span class="s1">]])</span>
    <span class="s1">assert_bbox_eq(b</span><span class="s0">, </span><span class="s1">eval(repr(b)</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'Bbox'</span><span class="s1">: mtransforms.Bbox}))</span>
    <span class="s1">asdict = eval(str(b)</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'Bbox'</span><span class="s1">: dict})</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">asdict.items():</span>
        <span class="s0">assert </span><span class="s1">getattr(b</span><span class="s0">, </span><span class="s1">k) == v</span>
    <span class="s1">fmt = </span><span class="s4">'.1f'</span>
    <span class="s1">asdict = eval(format(b</span><span class="s0">, </span><span class="s1">fmt)</span><span class="s0">, </span><span class="s1">{</span><span class="s4">'Bbox'</span><span class="s1">: dict})</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">asdict.items():</span>
        <span class="s0">assert </span><span class="s1">eval(format(getattr(b</span><span class="s0">, </span><span class="s1">k)</span><span class="s0">, </span><span class="s1">fmt)) == v</span>


<span class="s0">def </span><span class="s1">test_str_transform():</span>
    <span class="s5"># The str here should not be considered as &quot;absolutely stable&quot;, and may be</span>
    <span class="s5"># reformatted later; this is just a smoketest for __str__.</span>
    <span class="s0">assert </span><span class="s1">str(plt.subplot(projection=</span><span class="s4">&quot;polar&quot;</span><span class="s1">).transData) == </span><span class="s4">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s4">CompositeGenericTransform( 
    CompositeGenericTransform( 
        CompositeGenericTransform( 
            TransformWrapper( 
                BlendedAffine2D( 
                    IdentityTransform(), 
                    IdentityTransform())), 
            CompositeAffine2D( 
                Affine2D().scale(1.0), 
                Affine2D().scale(1.0))), 
        PolarTransform( 
            PolarAxes(0.125,0.1;0.775x0.8), 
            use_rmin=True, 
            _apply_theta_transforms=False)), 
    CompositeGenericTransform( 
        CompositeGenericTransform( 
            PolarAffine( 
                TransformWrapper( 
                    BlendedAffine2D( 
                        IdentityTransform(), 
                        IdentityTransform())), 
                LockableBbox( 
                    Bbox(x0=0.0, y0=0.0, x1=6.283185307179586, y1=1.0), 
                    [[-- --] 
                     [-- --]])), 
            BboxTransformFrom( 
                _WedgeBbox( 
                    (0.5, 0.5), 
                    TransformedBbox( 
                        Bbox(x0=0.0, y0=0.0, x1=6.283185307179586, y1=1.0), 
                        CompositeAffine2D( 
                            Affine2D().scale(1.0), 
                            Affine2D().scale(1.0))), 
                    LockableBbox( 
                        Bbox(x0=0.0, y0=0.0, x1=6.283185307179586, y1=1.0), 
                        [[-- --] 
                         [-- --]])))), 
        BboxTransformTo( 
            TransformedBbox( 
                Bbox(x0=0.125, y0=0.09999999999999998, x1=0.9, y1=0.9), 
                BboxTransformTo( 
                    TransformedBbox( 
                        Bbox(x0=0.0, y0=0.0, x1=8.0, y1=6.0), 
                        Affine2D().scale(80.0)))))))&quot;&quot;&quot;</span>


<span class="s0">def </span><span class="s1">test_transform_single_point():</span>
    <span class="s1">t = mtransforms.Affine2D()</span>
    <span class="s1">r = t.transform_affine((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">r.shape == (</span><span class="s3">2</span><span class="s0">,</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_log_transform():</span>
    <span class="s5"># Tests that the last line runs without exception (previously the</span>
    <span class="s5"># transform would fail if one of the axes was logarithmic).</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.set_yscale(</span><span class="s4">'log'</span><span class="s1">)</span>
    <span class="s1">ax.transData.transform((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_nan_overlap():</span>
    <span class="s1">a = mtransforms.Bbox([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">b = mtransforms.Bbox([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan]])</span>
    <span class="s0">assert not </span><span class="s1">a.overlaps(b)</span>


<span class="s0">def </span><span class="s1">test_transform_angles():</span>
    <span class="s1">t = mtransforms.Affine2D()  </span><span class="s5"># Identity transform</span>
    <span class="s1">angles = np.array([</span><span class="s3">20</span><span class="s0">, </span><span class="s3">45</span><span class="s0">, </span><span class="s3">60</span><span class="s1">])</span>
    <span class="s1">points = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>

    <span class="s5"># Identity transform does not change angles</span>
    <span class="s1">new_angles = t.transform_angles(angles</span><span class="s0">, </span><span class="s1">points)</span>
    <span class="s1">assert_array_almost_equal(angles</span><span class="s0">, </span><span class="s1">new_angles)</span>

    <span class="s5"># points missing a 2nd dimension</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.transform_angles(angles</span><span class="s0">, </span><span class="s1">points[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">:</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s5"># Number of angles != Number of points</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.transform_angles(angles</span><span class="s0">, </span><span class="s1">points[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s0">, </span><span class="s1">:])</span>


<span class="s0">def </span><span class="s1">test_nonsingular():</span>
    <span class="s5"># test for zero-expansion type cases; other cases may be added later</span>
    <span class="s1">zero_expansion = np.array([-</span><span class="s3">0.001</span><span class="s0">, </span><span class="s3">0.001</span><span class="s1">])</span>
    <span class="s1">cases = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">7.9e-317</span><span class="s1">)]</span>
    <span class="s0">for </span><span class="s1">args </span><span class="s0">in </span><span class="s1">cases:</span>
        <span class="s1">out = np.array(mtransforms.nonsingular(*args))</span>
        <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">zero_expansion)</span>


<span class="s0">def </span><span class="s1">test_invalid_arguments():</span>
    <span class="s1">t = mtransforms.Affine2D()</span>
    <span class="s5"># There are two different exceptions, since the wrong number of</span>
    <span class="s5"># dimensions is caught when constructing an array_view, and that</span>
    <span class="s5"># raises a ValueError, and a wrong shape with a possible number</span>
    <span class="s5"># of dimensions is caught by our CALL_CPP macro, which always</span>
    <span class="s5"># raises the less precise RuntimeError.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.transform(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">t.transform([[[</span><span class="s3">1</span><span class="s1">]]])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">t.transform([])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">t.transform([</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">t.transform([[</span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">t.transform([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]])</span>


<span class="s0">def </span><span class="s1">test_transformed_path():</span>
    <span class="s1">points = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>
    <span class="s1">path = Path(points</span><span class="s0">, </span><span class="s1">closed=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">trans = mtransforms.Affine2D()</span>
    <span class="s1">trans_path = mtransforms.TransformedPath(path</span><span class="s0">, </span><span class="s1">trans)</span>
    <span class="s1">assert_allclose(trans_path.get_fully_transformed_path().vertices</span><span class="s0">, </span><span class="s1">points)</span>

    <span class="s5"># Changing the transform should change the result.</span>
    <span class="s1">r2 = </span><span class="s3">1 </span><span class="s1">/ np.sqrt(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">trans.rotate(np.pi / </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(trans_path.get_fully_transformed_path().vertices</span><span class="s0">,</span>
                    <span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(r2</span><span class="s0">, </span><span class="s1">r2)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* r2)</span><span class="s0">, </span><span class="s1">(-r2</span><span class="s0">, </span><span class="s1">r2)]</span><span class="s0">,</span>
                    <span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>

    <span class="s5"># Changing the path does not change the result (it's cached).</span>
    <span class="s1">path.points = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)] * </span><span class="s3">4</span>
    <span class="s1">assert_allclose(trans_path.get_fully_transformed_path().vertices</span><span class="s0">,</span>
                    <span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(r2</span><span class="s0">, </span><span class="s1">r2)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">* r2)</span><span class="s0">, </span><span class="s1">(-r2</span><span class="s0">, </span><span class="s1">r2)]</span><span class="s0">,</span>
                    <span class="s1">atol=</span><span class="s3">1e-15</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_transformed_patch_path():</span>
    <span class="s1">trans = mtransforms.Affine2D()</span>
    <span class="s1">patch = mpatches.Wedge((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">45</span><span class="s0">, </span><span class="s3">135</span><span class="s0">, </span><span class="s1">transform=trans)</span>

    <span class="s1">tpatch = mtransforms.TransformedPatchPath(patch)</span>
    <span class="s1">points = tpatch.get_fully_transformed_path().vertices</span>

    <span class="s5"># Changing the transform should change the result.</span>
    <span class="s1">trans.scale(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(tpatch.get_fully_transformed_path().vertices</span><span class="s0">, </span><span class="s1">points * </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s5"># Changing the path should change the result (and cancel out the scaling</span>
    <span class="s5"># from the transform).</span>
    <span class="s1">patch.set_radius(</span><span class="s3">0.5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(tpatch.get_fully_transformed_path().vertices</span><span class="s0">, </span><span class="s1">points)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'locked_element'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'x0'</span><span class="s0">, </span><span class="s4">'y0'</span><span class="s0">, </span><span class="s4">'x1'</span><span class="s0">, </span><span class="s4">'y1'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_lockable_bbox(locked_element):</span>
    <span class="s1">other_elements = [</span><span class="s4">'x0'</span><span class="s0">, </span><span class="s4">'y0'</span><span class="s0">, </span><span class="s4">'x1'</span><span class="s0">, </span><span class="s4">'y1'</span><span class="s1">]</span>
    <span class="s1">other_elements.remove(locked_element)</span>

    <span class="s1">orig = mtransforms.Bbox.unit()</span>
    <span class="s1">locked = mtransforms.LockableBbox(orig</span><span class="s0">, </span><span class="s1">**{locked_element: </span><span class="s3">2</span><span class="s1">})</span>

    <span class="s5"># LockableBbox should keep its locked element as specified in __init__.</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">locked_element) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element) == </span><span class="s3">2</span>
    <span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">other_elements:</span>
        <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">elem) == getattr(orig</span><span class="s0">, </span><span class="s1">elem)</span>

    <span class="s5"># Changing underlying Bbox should update everything but locked element.</span>
    <span class="s1">orig.set_points(orig.get_points() + </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">locked_element) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element) == </span><span class="s3">2</span>
    <span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">other_elements:</span>
        <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">elem) == getattr(orig</span><span class="s0">, </span><span class="s1">elem)</span>

    <span class="s5"># Unlocking element should revert values back to the underlying Bbox.</span>
    <span class="s1">setattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element) </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">np.all(orig.get_points() == locked.get_points())</span>

    <span class="s5"># Relocking an element should change its value, but not others.</span>
    <span class="s1">setattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">locked_element) == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s4">'locked_' </span><span class="s1">+ locked_element) == </span><span class="s3">3</span>
    <span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">other_elements:</span>
        <span class="s0">assert </span><span class="s1">getattr(locked</span><span class="s0">, </span><span class="s1">elem) == getattr(orig</span><span class="s0">, </span><span class="s1">elem)</span>


<span class="s0">def </span><span class="s1">test_copy():</span>
    <span class="s1">a = mtransforms.Affine2D()</span>
    <span class="s1">b = mtransforms.Affine2D()</span>
    <span class="s1">s = a + b</span>
    <span class="s5"># Updating a dependee should invalidate a copy of the dependent.</span>
    <span class="s1">s.get_matrix()  </span><span class="s5"># resolve it.</span>
    <span class="s1">s1 = copy.copy(s)</span>
    <span class="s0">assert not </span><span class="s1">s._invalid </span><span class="s0">and not </span><span class="s1">s1._invalid</span>
    <span class="s1">a.translate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">s._invalid </span><span class="s0">and </span><span class="s1">s1._invalid</span>
    <span class="s0">assert </span><span class="s1">(s1.get_matrix() == a.get_matrix()).all()</span>
    <span class="s5"># Updating a copy of a dependee shouldn't invalidate a dependent.</span>
    <span class="s1">s.get_matrix()  </span><span class="s5"># resolve it.</span>
    <span class="s1">b1 = copy.copy(b)</span>
    <span class="s1">b1.translate(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">s._invalid</span>
    <span class="s0">assert </span><span class="s1">(s.get_matrix() == a.get_matrix()).all()</span>


<span class="s0">def </span><span class="s1">test_deepcopy():</span>
    <span class="s1">a = mtransforms.Affine2D()</span>
    <span class="s1">b = mtransforms.Affine2D()</span>
    <span class="s1">s = a + b</span>
    <span class="s5"># Updating a dependee shouldn't invalidate a deepcopy of the dependent.</span>
    <span class="s1">s.get_matrix()  </span><span class="s5"># resolve it.</span>
    <span class="s1">s1 = copy.deepcopy(s)</span>
    <span class="s0">assert not </span><span class="s1">s._invalid </span><span class="s0">and not </span><span class="s1">s1._invalid</span>
    <span class="s1">a.translate(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">s._invalid </span><span class="s0">and not </span><span class="s1">s1._invalid</span>
    <span class="s0">assert </span><span class="s1">(s1.get_matrix() == mtransforms.Affine2D().get_matrix()).all()</span>
    <span class="s5"># Updating a deepcopy of a dependee shouldn't invalidate a dependent.</span>
    <span class="s1">s.get_matrix()  </span><span class="s5"># resolve it.</span>
    <span class="s1">b1 = copy.deepcopy(b)</span>
    <span class="s1">b1.translate(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">s._invalid</span>
    <span class="s0">assert </span><span class="s1">(s.get_matrix() == a.get_matrix()).all()</span>


<span class="s0">def </span><span class="s1">test_transformwrapper():</span>
    <span class="s1">t = mtransforms.TransformWrapper(mtransforms.Affine2D())</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=(</span>
            <span class="s4">r&quot;The input and output dims of the new child \(1, 1\) &quot;</span>
            <span class="s4">r&quot;do not match those of current child \(2, 2\)&quot;</span><span class="s1">)):</span>
        <span class="s1">t.set(scale.LogTransform(</span><span class="s3">10</span><span class="s1">))</span>


<span class="s1">@check_figures_equal(extensions=[</span><span class="s4">&quot;png&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_scale_swapping(fig_test</span><span class="s0">, </span><span class="s1">fig_ref):</span>
    <span class="s1">np.random.seed(</span><span class="s3">19680801</span><span class="s1">)</span>
    <span class="s1">samples = np.random.normal(size=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">x = np.linspace(-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">log_state </span><span class="s0">in </span><span class="s1">zip([fig_test</span><span class="s0">, </span><span class="s1">fig_ref]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]):</span>
        <span class="s1">ax = fig.subplots()</span>
        <span class="s1">ax.hist(samples</span><span class="s0">, </span><span class="s1">log=log_state</span><span class="s0">, </span><span class="s1">density=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">np.exp(-(x**</span><span class="s3">2</span><span class="s1">) / </span><span class="s3">2</span><span class="s1">) / np.sqrt(</span><span class="s3">2 </span><span class="s1">* np.pi))</span>
        <span class="s1">fig.canvas.draw()</span>
        <span class="s1">ax.set_yscale(</span><span class="s4">'linear'</span><span class="s1">)</span>
</pre>
</body>
</html>