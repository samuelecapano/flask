<html>
<head>
<title>message.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
message.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0"># https://developers.google.com/protocol-buffers/</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0">#     * Redistributions of source code must retain the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#     * Redistributions in binary form must reproduce the above</span>
<span class="s0"># copyright notice, this list of conditions and the following disclaimer</span>
<span class="s0"># in the documentation and/or other materials provided with the</span>
<span class="s0"># distribution.</span>
<span class="s0">#     * Neither the name of Google Inc. nor the names of its</span>
<span class="s0"># contributors may be used to endorse or promote products derived from</span>
<span class="s0"># this software without specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s0"># TODO(robinson): We should just make these methods all &quot;pure-virtual&quot; and move</span>
<span class="s0"># all implementation out, into reflection.py for now.</span>


<span class="s2">&quot;&quot;&quot;Contains an abstract base class for protocol messages.&quot;&quot;&quot;</span>

<span class="s1">__author__ = </span><span class="s3">'robinson@google.com (Will Robinson)'</span>

<span class="s4">class </span><span class="s1">Error(Exception):</span>
  <span class="s2">&quot;&quot;&quot;Base error type for this module.&quot;&quot;&quot;</span>
  <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">DecodeError(Error):</span>
  <span class="s2">&quot;&quot;&quot;Exception raised when deserializing messages.&quot;&quot;&quot;</span>
  <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">EncodeError(Error):</span>
  <span class="s2">&quot;&quot;&quot;Exception raised when serializing messages.&quot;&quot;&quot;</span>
  <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">Message(object):</span>

  <span class="s2">&quot;&quot;&quot;Abstract base class for protocol messages. 
 
  Protocol message classes are almost always generated by the protocol 
  compiler.  These generated types subclass Message and implement the methods 
  shown below. 
  &quot;&quot;&quot;</span>

  <span class="s0"># TODO(robinson): Link to an HTML document here.</span>

  <span class="s0"># TODO(robinson): Document that instances of this class will also</span>
  <span class="s0"># have an Extensions attribute with __getitem__ and __setitem__.</span>
  <span class="s0"># Again, not sure how to best convey this.</span>

  <span class="s0"># TODO(robinson): Document that the class must also have a static</span>
  <span class="s0">#   RegisterExtension(extension_field) method.</span>
  <span class="s0">#   Not sure how to best express at this point.</span>

  <span class="s0"># TODO(robinson): Document these fields and methods.</span>

  <span class="s1">__slots__ = []</span>

  <span class="s0">#: The :class:`google.protobuf.descriptor.Descriptor` for this message type.</span>
  <span class="s1">DESCRIPTOR = </span><span class="s4">None</span>

  <span class="s4">def </span><span class="s1">__deepcopy__(self</span><span class="s4">, </span><span class="s1">memo=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s1">clone = type(self)()</span>
    <span class="s1">clone.MergeFrom(self)</span>
    <span class="s4">return </span><span class="s1">clone</span>

  <span class="s4">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other_msg):</span>
    <span class="s2">&quot;&quot;&quot;Recursively compares two messages by value and structure.&quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">__ne__(self</span><span class="s4">, </span><span class="s1">other_msg):</span>
    <span class="s0"># Can't just say self != other_msg, since that would infinitely recurse. :)</span>
    <span class="s4">return not </span><span class="s1">self == other_msg</span>

  <span class="s4">def </span><span class="s1">__hash__(self):</span>
    <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'unhashable object'</span><span class="s1">)</span>

  <span class="s4">def </span><span class="s1">__str__(self):</span>
    <span class="s2">&quot;&quot;&quot;Outputs a human-readable representation of the message.&quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">__unicode__(self):</span>
    <span class="s2">&quot;&quot;&quot;Outputs a human-readable representation of the message.&quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">MergeFrom(self</span><span class="s4">, </span><span class="s1">other_msg):</span>
    <span class="s2">&quot;&quot;&quot;Merges the contents of the specified message into current message. 
 
    This method merges the contents of the specified message into the current 
    message. Singular fields that are set in the specified message overwrite 
    the corresponding fields in the current message. Repeated fields are 
    appended. Singular sub-messages and groups are recursively merged. 
 
    Args: 
      other_msg (Message): A message to merge into the current message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">CopyFrom(self</span><span class="s4">, </span><span class="s1">other_msg):</span>
    <span class="s2">&quot;&quot;&quot;Copies the content of the specified message into the current message. 
 
    The method clears the current message and then merges the specified 
    message using MergeFrom. 
 
    Args: 
      other_msg (Message): A message to copy into the current one. 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">self </span><span class="s4">is </span><span class="s1">other_msg:</span>
      <span class="s4">return</span>
    <span class="s1">self.Clear()</span>
    <span class="s1">self.MergeFrom(other_msg)</span>

  <span class="s4">def </span><span class="s1">Clear(self):</span>
    <span class="s2">&quot;&quot;&quot;Clears all data that was set in the message.&quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">SetInParent(self):</span>
    <span class="s2">&quot;&quot;&quot;Mark this as present in the parent. 
 
    This normally happens automatically when you assign a field of a 
    sub-message, but sometimes you want to make the sub-message 
    present while keeping it empty.  If you find yourself using this, 
    you may want to reconsider your design. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">IsInitialized(self):</span>
    <span class="s2">&quot;&quot;&quot;Checks if the message is initialized. 
 
    Returns: 
      bool: The method returns True if the message is initialized (i.e. all of 
      its required fields are set). 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s0"># TODO(robinson): MergeFromString() should probably return None and be</span>
  <span class="s0"># implemented in terms of a helper that returns the # of bytes read.  Our</span>
  <span class="s0"># deserialization routines would use the helper when recursively</span>
  <span class="s0"># deserializing, but the end user would almost always just want the no-return</span>
  <span class="s0"># MergeFromString().</span>

  <span class="s4">def </span><span class="s1">MergeFromString(self</span><span class="s4">, </span><span class="s1">serialized):</span>
    <span class="s2">&quot;&quot;&quot;Merges serialized protocol buffer data into this message. 
 
    When we find a field in `serialized` that is already present 
    in this message: 
 
    -   If it's a &quot;repeated&quot; field, we append to the end of our list. 
    -   Else, if it's a scalar, we overwrite our field. 
    -   Else, (it's a nonrepeated composite), we recursively merge 
        into the existing composite. 
 
    Args: 
      serialized (bytes): Any object that allows us to call 
        ``memoryview(serialized)`` to access a string of bytes using the 
        buffer interface. 
 
    Returns: 
      int: The number of bytes read from `serialized`. 
      For non-group messages, this will always be `len(serialized)`, 
      but for messages which are actually groups, this will 
      generally be less than `len(serialized)`, since we must 
      stop when we reach an ``END_GROUP`` tag.  Note that if 
      we *do* stop because of an ``END_GROUP`` tag, the number 
      of bytes returned does not include the bytes 
      for the ``END_GROUP`` tag information. 
 
    Raises: 
      DecodeError: if the input cannot be parsed. 
    &quot;&quot;&quot;</span>
    <span class="s0"># TODO(robinson): Document handling of unknown fields.</span>
    <span class="s0"># TODO(robinson): When we switch to a helper, this will return None.</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">ParseFromString(self</span><span class="s4">, </span><span class="s1">serialized):</span>
    <span class="s2">&quot;&quot;&quot;Parse serialized protocol buffer data into this message. 
 
    Like :func:`MergeFromString()`, except we clear the object first. 
 
    Raises: 
      message.DecodeError if the input cannot be parsed. 
    &quot;&quot;&quot;</span>
    <span class="s1">self.Clear()</span>
    <span class="s4">return </span><span class="s1">self.MergeFromString(serialized)</span>

  <span class="s4">def </span><span class="s1">SerializeToString(self</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Serializes the protocol message to a binary string. 
 
    Keyword Args: 
      deterministic (bool): If true, requests deterministic serialization 
        of the protobuf, with predictable ordering of map keys. 
 
    Returns: 
      A binary string representation of the message if all of the required 
      fields in the message are set (i.e. the message is initialized). 
 
    Raises: 
      EncodeError: if the message isn't initialized (see :func:`IsInitialized`). 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">SerializePartialToString(self</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Serializes the protocol message to a binary string. 
 
    This method is similar to SerializeToString but doesn't check if the 
    message is initialized. 
 
    Keyword Args: 
      deterministic (bool): If true, requests deterministic serialization 
        of the protobuf, with predictable ordering of map keys. 
 
    Returns: 
      bytes: A serialized representation of the partial message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s0"># TODO(robinson): Decide whether we like these better</span>
  <span class="s0"># than auto-generated has_foo() and clear_foo() methods</span>
  <span class="s0"># on the instances themselves.  This way is less consistent</span>
  <span class="s0"># with C++, but it makes reflection-type access easier and</span>
  <span class="s0"># reduces the number of magically autogenerated things.</span>
  <span class="s0">#</span>
  <span class="s0"># TODO(robinson): Be sure to document (and test) exactly</span>
  <span class="s0"># which field names are accepted here.  Are we case-sensitive?</span>
  <span class="s0"># What do we do with fields that share names with Python keywords</span>
  <span class="s0"># like 'lambda' and 'yield'?</span>
  <span class="s0">#</span>
  <span class="s0"># nnorwitz says:</span>
  <span class="s0"># &quot;&quot;&quot;</span>
  <span class="s0"># Typically (in python), an underscore is appended to names that are</span>
  <span class="s0"># keywords. So they would become lambda_ or yield_.</span>
  <span class="s0"># &quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">ListFields(self):</span>
    <span class="s2">&quot;&quot;&quot;Returns a list of (FieldDescriptor, value) tuples for present fields. 
 
    A message field is non-empty if HasField() would return true. A singular 
    primitive field is non-empty if HasField() would return true in proto2 or it 
    is non zero in proto3. A repeated field is non-empty if it contains at least 
    one element. The fields are ordered by field number. 
 
    Returns: 
      list[tuple(FieldDescriptor, value)]: field descriptors and values 
      for all fields in the message which are not empty. The values vary by 
      field type. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">HasField(self</span><span class="s4">, </span><span class="s1">field_name):</span>
    <span class="s2">&quot;&quot;&quot;Checks if a certain field is set for the message. 
 
    For a oneof group, checks if any field inside is set. Note that if the 
    field_name is not defined in the message descriptor, :exc:`ValueError` will 
    be raised. 
 
    Args: 
      field_name (str): The name of the field to check for presence. 
 
    Returns: 
      bool: Whether a value has been set for the named field. 
 
    Raises: 
      ValueError: if the `field_name` is not a member of this message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">ClearField(self</span><span class="s4">, </span><span class="s1">field_name):</span>
    <span class="s2">&quot;&quot;&quot;Clears the contents of a given field. 
 
    Inside a oneof group, clears the field set. If the name neither refers to a 
    defined field or oneof group, :exc:`ValueError` is raised. 
 
    Args: 
      field_name (str): The name of the field to check for presence. 
 
    Raises: 
      ValueError: if the `field_name` is not a member of this message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">WhichOneof(self</span><span class="s4">, </span><span class="s1">oneof_group):</span>
    <span class="s2">&quot;&quot;&quot;Returns the name of the field that is set inside a oneof group. 
 
    If no field is set, returns None. 
 
    Args: 
      oneof_group (str): the name of the oneof group to check. 
 
    Returns: 
      str or None: The name of the group that is set, or None. 
 
    Raises: 
      ValueError: no group with the given name exists 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">HasExtension(self</span><span class="s4">, </span><span class="s1">extension_handle):</span>
    <span class="s2">&quot;&quot;&quot;Checks if a certain extension is present for this message. 
 
    Extensions are retrieved using the :attr:`Extensions` mapping (if present). 
 
    Args: 
      extension_handle: The handle for the extension to check. 
 
    Returns: 
      bool: Whether the extension is present for this message. 
 
    Raises: 
      KeyError: if the extension is repeated. Similar to repeated fields, 
        there is no separate notion of presence: a &quot;not present&quot; repeated 
        extension is an empty list. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">ClearExtension(self</span><span class="s4">, </span><span class="s1">extension_handle):</span>
    <span class="s2">&quot;&quot;&quot;Clears the contents of a given extension. 
 
    Args: 
      extension_handle: The handle for the extension to clear. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">UnknownFields(self):</span>
    <span class="s2">&quot;&quot;&quot;Returns the UnknownFieldSet. 
 
    Returns: 
      UnknownFieldSet: The unknown fields stored in this message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">DiscardUnknownFields(self):</span>
    <span class="s2">&quot;&quot;&quot;Clears all fields in the :class:`UnknownFieldSet`. 
 
    This operation is recursive for nested message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">ByteSize(self):</span>
    <span class="s2">&quot;&quot;&quot;Returns the serialized size of this message. 
 
    Recursively calls ByteSize() on all contained messages. 
 
    Returns: 
      int: The number of bytes required to serialize this message. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s1">@classmethod</span>
  <span class="s4">def </span><span class="s1">FromString(cls</span><span class="s4">, </span><span class="s1">s):</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s1">@staticmethod</span>
  <span class="s4">def </span><span class="s1">RegisterExtension(extension_handle):</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">_SetListener(self</span><span class="s4">, </span><span class="s1">message_listener):</span>
    <span class="s2">&quot;&quot;&quot;Internal method used by the protocol message implementation. 
    Clients should not call this directly. 
 
    Sets a listener that this message will call on certain state transitions. 
 
    The purpose of this method is to register back-edges from children to 
    parents at runtime, for the purpose of setting &quot;has&quot; bits and 
    byte-size-dirty bits in the parent and ancestor objects whenever a child or 
    descendant object is modified. 
 
    If the client wants to disconnect this Message from the object tree, she 
    explicitly sets callback to None. 
 
    If message_listener is None, unregisters any existing listener.  Otherwise, 
    message_listener must implement the MessageListener interface in 
    internal/message_listener.py, and we discard any listener registered 
    via a previous _SetListener() call. 
    &quot;&quot;&quot;</span>
    <span class="s4">raise </span><span class="s1">NotImplementedError</span>

  <span class="s4">def </span><span class="s1">__getstate__(self):</span>
    <span class="s2">&quot;&quot;&quot;Support the pickle protocol.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">dict(serialized=self.SerializePartialToString())</span>

  <span class="s4">def </span><span class="s1">__setstate__(self</span><span class="s4">, </span><span class="s1">state):</span>
    <span class="s2">&quot;&quot;&quot;Support the pickle protocol.&quot;&quot;&quot;</span>
    <span class="s1">self.__init__()</span>
    <span class="s1">serialized = state[</span><span class="s3">'serialized'</span><span class="s1">]</span>
    <span class="s0"># On Python 3, using encoding='latin1' is required for unpickling</span>
    <span class="s0"># protos pickled by Python 2.</span>
    <span class="s4">if not </span><span class="s1">isinstance(serialized</span><span class="s4">, </span><span class="s1">bytes):</span>
      <span class="s1">serialized = serialized.encode(</span><span class="s3">'latin1'</span><span class="s1">)</span>
    <span class="s1">self.ParseFromString(serialized)</span>

  <span class="s4">def </span><span class="s1">__reduce__(self):</span>
    <span class="s1">message_descriptor = self.DESCRIPTOR</span>
    <span class="s4">if </span><span class="s1">message_descriptor.containing_type </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">type(self)</span><span class="s4">, </span><span class="s1">()</span><span class="s4">, </span><span class="s1">self.__getstate__()</span>
    <span class="s0"># the message type must be nested.</span>
    <span class="s0"># Python does not pickle nested classes; use the symbol_database on the</span>
    <span class="s0"># receiving end.</span>
    <span class="s1">container = message_descriptor</span>
    <span class="s4">return </span><span class="s1">(_InternalConstructMessage</span><span class="s4">, </span><span class="s1">(container.full_name</span><span class="s4">,</span><span class="s1">)</span><span class="s4">,</span>
            <span class="s1">self.__getstate__())</span>


<span class="s4">def </span><span class="s1">_InternalConstructMessage(full_name):</span>
  <span class="s2">&quot;&quot;&quot;Constructs a nested message.&quot;&quot;&quot;</span>
  <span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">symbol_database  </span><span class="s0"># pylint:disable=g-import-not-at-top</span>

  <span class="s4">return </span><span class="s1">symbol_database.Default().GetSymbol(full_name)()</span>
</pre>
</body>
</html>