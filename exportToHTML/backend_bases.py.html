<html>
<head>
<title>backend_bases.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
backend_bases.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Abstract base classes define the primitives that renderers and 
graphics contexts must implement to serve as a Matplotlib backend. 
 
`RendererBase` 
    An abstract base class to handle drawing/rendering operations. 
 
`FigureCanvasBase` 
    The abstraction layer that separates the `.Figure` from the backend 
    specific details like a user interface drawing area. 
 
`GraphicsContextBase` 
    An abstract base class that provides color, line styles, etc. 
 
`Event` 
    The base class for all of the Matplotlib event handling.  Derived classes 
    such as `KeyEvent` and `MouseEvent` store the meta data like keys and 
    buttons pressed, x and y locations in pixel and `~.axes.Axes` coordinates. 
 
`ShowBase` 
    The base class for the ``Show`` class of each interactive backend; the 
    'show' callable is then set to ``Show.__call__``. 
 
`ToolContainerBase` 
    The base class for the Toolbar class of each interactive backend. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">ExitStack</span><span class="s2">, </span><span class="s1">contextmanager</span><span class="s2">, </span><span class="s1">nullcontext</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span><span class="s2">, </span><span class="s1">IntEnum</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">importlib</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">from </span><span class="s1">weakref </span><span class="s2">import </span><span class="s1">WeakKeyDictionary</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_api</span><span class="s2">, </span><span class="s1">backend_tools </span><span class="s2">as </span><span class="s1">tools</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">, </span><span class="s1">text</span><span class="s2">,</span>
    <span class="s1">_tight_bbox</span><span class="s2">, </span><span class="s1">transforms</span><span class="s2">, </span><span class="s1">widgets</span><span class="s2">, </span><span class="s1">get_backend</span><span class="s2">, </span><span class="s1">is_interactive</span><span class="s2">, </span><span class="s1">rcParams)</span>
<span class="s2">from </span><span class="s1">matplotlib._pylab_helpers </span><span class="s2">import </span><span class="s1">Gcf</span>
<span class="s2">from </span><span class="s1">matplotlib.backend_managers </span><span class="s2">import </span><span class="s1">ToolManager</span>
<span class="s2">from </span><span class="s1">matplotlib.cbook </span><span class="s2">import </span><span class="s1">_setattr_cm</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">matplotlib.texmanager </span><span class="s2">import </span><span class="s1">TexManager</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Affine2D</span>
<span class="s2">from </span><span class="s1">matplotlib._enums </span><span class="s2">import </span><span class="s1">JoinStyle</span><span class="s2">, </span><span class="s1">CapStyle</span>


<span class="s1">_log = logging.getLogger(__name__)</span>
<span class="s1">_default_filetypes = {</span>
    <span class="s3">'eps'</span><span class="s1">: </span><span class="s3">'Encapsulated Postscript'</span><span class="s2">,</span>
    <span class="s3">'jpg'</span><span class="s1">: </span><span class="s3">'Joint Photographic Experts Group'</span><span class="s2">,</span>
    <span class="s3">'jpeg'</span><span class="s1">: </span><span class="s3">'Joint Photographic Experts Group'</span><span class="s2">,</span>
    <span class="s3">'pdf'</span><span class="s1">: </span><span class="s3">'Portable Document Format'</span><span class="s2">,</span>
    <span class="s3">'pgf'</span><span class="s1">: </span><span class="s3">'PGF code for LaTeX'</span><span class="s2">,</span>
    <span class="s3">'png'</span><span class="s1">: </span><span class="s3">'Portable Network Graphics'</span><span class="s2">,</span>
    <span class="s3">'ps'</span><span class="s1">: </span><span class="s3">'Postscript'</span><span class="s2">,</span>
    <span class="s3">'raw'</span><span class="s1">: </span><span class="s3">'Raw RGBA bitmap'</span><span class="s2">,</span>
    <span class="s3">'rgba'</span><span class="s1">: </span><span class="s3">'Raw RGBA bitmap'</span><span class="s2">,</span>
    <span class="s3">'svg'</span><span class="s1">: </span><span class="s3">'Scalable Vector Graphics'</span><span class="s2">,</span>
    <span class="s3">'svgz'</span><span class="s1">: </span><span class="s3">'Scalable Vector Graphics'</span><span class="s2">,</span>
    <span class="s3">'tif'</span><span class="s1">: </span><span class="s3">'Tagged Image File Format'</span><span class="s2">,</span>
    <span class="s3">'tiff'</span><span class="s1">: </span><span class="s3">'Tagged Image File Format'</span><span class="s2">,</span>
    <span class="s3">'webp'</span><span class="s1">: </span><span class="s3">'WebP Image Format'</span><span class="s2">,</span>
<span class="s1">}</span>
<span class="s1">_default_backends = {</span>
    <span class="s3">'eps'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_ps'</span><span class="s2">,</span>
    <span class="s3">'jpg'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'jpeg'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'pdf'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_pdf'</span><span class="s2">,</span>
    <span class="s3">'pgf'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_pgf'</span><span class="s2">,</span>
    <span class="s3">'png'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'ps'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_ps'</span><span class="s2">,</span>
    <span class="s3">'raw'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'rgba'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'svg'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_svg'</span><span class="s2">,</span>
    <span class="s3">'svgz'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_svg'</span><span class="s2">,</span>
    <span class="s3">'tif'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'tiff'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
    <span class="s3">'webp'</span><span class="s1">: </span><span class="s3">'matplotlib.backends.backend_agg'</span><span class="s2">,</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">_safe_pyplot_import():</span>
    <span class="s0">&quot;&quot;&quot; 
    Import and return ``pyplot``, correctly setting the backend if one is 
    already forced. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
    <span class="s2">except </span><span class="s1">ImportError:  </span><span class="s4"># Likely due to a framework mismatch.</span>
        <span class="s1">current_framework = cbook._get_running_interactive_framework()</span>
        <span class="s2">if </span><span class="s1">current_framework </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise  </span><span class="s4"># No, something else went wrong, likely with the install...</span>
        <span class="s1">backend_mapping = {</span>
            <span class="s3">'qt'</span><span class="s1">: </span><span class="s3">'qtagg'</span><span class="s2">,</span>
            <span class="s3">'gtk3'</span><span class="s1">: </span><span class="s3">'gtk3agg'</span><span class="s2">,</span>
            <span class="s3">'gtk4'</span><span class="s1">: </span><span class="s3">'gtk4agg'</span><span class="s2">,</span>
            <span class="s3">'wx'</span><span class="s1">: </span><span class="s3">'wxagg'</span><span class="s2">,</span>
            <span class="s3">'tk'</span><span class="s1">: </span><span class="s3">'tkagg'</span><span class="s2">,</span>
            <span class="s3">'macosx'</span><span class="s1">: </span><span class="s3">'macosx'</span><span class="s2">,</span>
            <span class="s3">'headless'</span><span class="s1">: </span><span class="s3">'agg'</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">backend = backend_mapping[current_framework]</span>
        <span class="s1">rcParams[</span><span class="s3">&quot;backend&quot;</span><span class="s1">] = mpl.rcParamsOrig[</span><span class="s3">&quot;backend&quot;</span><span class="s1">] = backend</span>
        <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt  </span><span class="s4"># Now this should succeed.</span>
    <span class="s2">return </span><span class="s1">plt</span>


<span class="s2">def </span><span class="s1">register_backend(format</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">description=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Register a backend for saving to a given file format. 
 
    Parameters 
    ---------- 
    format : str 
        File extension 
    backend : module string or canvas class 
        Backend for handling file output 
    description : str, default: &quot;&quot; 
        Description of the file type. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">description </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">description = </span><span class="s3">''</span>
    <span class="s1">_default_backends[format] = backend</span>
    <span class="s1">_default_filetypes[format] = description</span>


<span class="s2">def </span><span class="s1">get_registered_canvas_class(format):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the registered default canvas for given file format. 
    Handles deferred import of required backend. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">format </span><span class="s2">not in </span><span class="s1">_default_backends:</span>
        <span class="s2">return None</span>
    <span class="s1">backend_class = _default_backends[format]</span>
    <span class="s2">if </span><span class="s1">isinstance(backend_class</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">backend_class = importlib.import_module(backend_class).FigureCanvas</span>
        <span class="s1">_default_backends[format] = backend_class</span>
    <span class="s2">return </span><span class="s1">backend_class</span>


<span class="s2">class </span><span class="s1">RendererBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    An abstract base class to handle drawing/rendering operations. 
 
    The following methods must be implemented in the backend for full 
    functionality (though just implementing `draw_path` alone would give a 
    highly capable backend): 
 
    * `draw_path` 
    * `draw_image` 
    * `draw_gouraud_triangles` 
 
    The following methods *should* be implemented in the backend for 
    optimization reasons: 
 
    * `draw_text` 
    * `draw_markers` 
    * `draw_path_collection` 
    * `draw_quad_mesh` 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._texmanager = </span><span class="s2">None</span>
        <span class="s1">self._text2path = text.TextToPath()</span>
        <span class="s1">self._raster_depth = </span><span class="s5">0</span>
        <span class="s1">self._rasterizing = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">open_group(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">gid=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Open a grouping element with label *s* and *gid* (if set) as id. 
 
        Only used by the SVG renderer. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">close_group(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Close a grouping element with label *s*. 
 
        Only used by the SVG renderer. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Draw a `~.path.Path` instance using the given affine transform.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">draw_markers(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">path</span><span class="s2">,</span>
                     <span class="s1">trans</span><span class="s2">, </span><span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a marker at each of *path*'s vertices (excluding control points). 
 
        The base (fallback) implementation makes multiple calls to `draw_path`. 
        Backends may want to override this method in order to draw the marker 
        only once and reuse it multiple times. 
 
        Parameters 
        ---------- 
        gc : `.GraphicsContextBase` 
            The graphics context. 
        marker_trans : `matplotlib.transforms.Transform` 
            An affine transform applied to the marker. 
        trans : `matplotlib.transforms.Transform` 
            An affine transform applied to the path. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">vertices</span><span class="s2">, </span><span class="s1">codes </span><span class="s2">in </span><span class="s1">path.iter_segments(trans</span><span class="s2">, </span><span class="s1">simplify=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">len(vertices):</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = vertices[-</span><span class="s5">2</span><span class="s1">:]</span>
                <span class="s1">self.draw_path(gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">,</span>
                               <span class="s1">marker_trans +</span>
                               <span class="s1">transforms.Affine2D().translate(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">,</span>
                               <span class="s1">rgbFace)</span>

    <span class="s2">def </span><span class="s1">draw_path_collection(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms</span><span class="s2">,</span>
                             <span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors</span><span class="s2">,</span>
                             <span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">, </span><span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">,</span>
                             <span class="s1">offset_position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a collection of *paths*. 
 
        Each path is first transformed by the corresponding entry 
        in *all_transforms* (a list of (3, 3) matrices) and then by 
        *master_transform*.  They are then translated by the corresponding 
        entry in *offsets*, which has been first transformed by *offset_trans*. 
 
        *facecolors*, *edgecolors*, *linewidths*, *linestyles*, and 
        *antialiased* are lists that set the corresponding properties. 
 
        *offset_position* is unused now, but the argument is kept for 
        backwards compatibility. 
 
        The base (fallback) implementation makes multiple calls to `draw_path`. 
        Backends may want to override this in order to render each set of 
        path data only once, and then reference that path multiple times with 
        the different offsets, colors, styles etc.  The generator methods 
        `_iter_collection_raw_paths` and `_iter_collection` are provided to 
        help with (and standardize) the implementation across backends.  It 
        is highly recommended to use those generators, so that changes to the 
        behavior of `draw_path_collection` can be made globally. 
        &quot;&quot;&quot;</span>
        <span class="s1">path_ids = self._iter_collection_raw_paths(master_transform</span><span class="s2">,</span>
                                                   <span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms)</span>

        <span class="s2">for </span><span class="s1">xo</span><span class="s2">, </span><span class="s1">yo</span><span class="s2">, </span><span class="s1">path_id</span><span class="s2">, </span><span class="s1">gc0</span><span class="s2">, </span><span class="s1">rgbFace </span><span class="s2">in </span><span class="s1">self._iter_collection(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">list(path_ids)</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">,</span>
                <span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">,</span>
                <span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">, </span><span class="s1">offset_position):</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">transform = path_id</span>
            <span class="s4"># Only apply another translation if we have an offset, else we</span>
            <span class="s4"># reuse the initial transform.</span>
            <span class="s2">if </span><span class="s1">xo != </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">yo != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s4"># The transformation can be used by multiple paths. Since</span>
                <span class="s4"># translate is a inplace operation, we need to copy the</span>
                <span class="s4"># transformation by .frozen() before applying the translation.</span>
                <span class="s1">transform = transform.frozen()</span>
                <span class="s1">transform.translate(xo</span><span class="s2">, </span><span class="s1">yo)</span>
            <span class="s1">self.draw_path(gc0</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">rgbFace)</span>

    <span class="s2">def </span><span class="s1">draw_quad_mesh(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">meshWidth</span><span class="s2">, </span><span class="s1">meshHeight</span><span class="s2">,</span>
                       <span class="s1">coordinates</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offsetTrans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">,</span>
                       <span class="s1">antialiased</span><span class="s2">, </span><span class="s1">edgecolors):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a quadmesh. 
 
        The base (fallback) implementation converts the quadmesh to paths and 
        then calls `draw_path_collection`. 
        &quot;&quot;&quot;</span>

        <span class="s2">from </span><span class="s1">matplotlib.collections </span><span class="s2">import </span><span class="s1">QuadMesh</span>
        <span class="s1">paths = QuadMesh._convert_mesh_to_paths(coordinates)</span>

        <span class="s2">if </span><span class="s1">edgecolors </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">edgecolors = facecolors</span>
        <span class="s1">linewidths = np.array([gc.get_linewidth()]</span><span class="s2">, </span><span class="s1">float)</span>

        <span class="s2">return </span><span class="s1">self.draw_path_collection(</span>
            <span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offsetTrans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">,</span>
            <span class="s1">edgecolors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[antialiased]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'screen'</span><span class="s1">)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;draw_gouraud_triangles&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">draw_gouraud_triangle(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a Gouraud-shaded triangle. 
 
        Parameters 
        ---------- 
        gc : `.GraphicsContextBase` 
            The graphics context. 
        points : (3, 2) array-like 
            Array of (x, y) points for the triangle. 
        colors : (3, 4) array-like 
            RGBA colors for each point of the triangle. 
        transform : `matplotlib.transforms.Transform` 
            An affine transform to apply to the points. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">draw_gouraud_triangles(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">triangles_array</span><span class="s2">, </span><span class="s1">colors_array</span><span class="s2">,</span>
                               <span class="s1">transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a series of Gouraud triangles. 
 
        Parameters 
        ---------- 
        points : (N, 3, 2) array-like 
            Array of *N* (x, y) points for the triangles. 
        colors : (N, 3, 4) array-like 
            Array of *N* RGBA colors for each point of the triangles. 
        transform : `matplotlib.transforms.Transform` 
            An affine transform to apply to the points. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_iter_collection_raw_paths(self</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">,</span>
                                   <span class="s1">all_transforms):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper method (along with `_iter_collection`) to implement 
        `draw_path_collection` in a memory-efficient manner. 
 
        This method yields all of the base path/transform combinations, given a 
        master transform, a list of paths and list of transforms. 
 
        The arguments should be exactly what is passed in to 
        `draw_path_collection`. 
 
        The backend should take each yielded path and transform and create an 
        object that can be referenced (reused) later. 
        &quot;&quot;&quot;</span>
        <span class="s1">Npaths = len(paths)</span>
        <span class="s1">Ntransforms = len(all_transforms)</span>
        <span class="s1">N = max(Npaths</span><span class="s2">, </span><span class="s1">Ntransforms)</span>

        <span class="s2">if </span><span class="s1">Npaths == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">transform = transforms.IdentityTransform()</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(N):</span>
            <span class="s1">path = paths[i % Npaths]</span>
            <span class="s2">if </span><span class="s1">Ntransforms:</span>
                <span class="s1">transform = Affine2D(all_transforms[i % Ntransforms])</span>
            <span class="s2">yield </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform + master_transform</span>

    <span class="s2">def </span><span class="s1">_iter_collection_uses_per_path(self</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms</span><span class="s2">,</span>
                                       <span class="s1">offsets</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute how many times each raw path object returned by 
        `_iter_collection_raw_paths` would be used when calling 
        `_iter_collection`. This is intended for the backend to decide 
        on the tradeoff between using the paths in-line and storing 
        them once and reusing. Rounds up in case the number of uses 
        is not the same for every path. 
        &quot;&quot;&quot;</span>
        <span class="s1">Npaths = len(paths)</span>
        <span class="s2">if </span><span class="s1">Npaths == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">len(facecolors) == len(edgecolors) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">0</span>
        <span class="s1">Npath_ids = max(Npaths</span><span class="s2">, </span><span class="s1">len(all_transforms))</span>
        <span class="s1">N = max(Npath_ids</span><span class="s2">, </span><span class="s1">len(offsets))</span>
        <span class="s2">return </span><span class="s1">(N + Npath_ids - </span><span class="s5">1</span><span class="s1">) // Npath_ids</span>

    <span class="s2">def </span><span class="s1">_iter_collection(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">path_ids</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">,</span>
                         <span class="s1">edgecolors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">,</span>
                         <span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">, </span><span class="s1">offset_position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper method (along with `_iter_collection_raw_paths`) to implement 
        `draw_path_collection` in a memory-efficient manner. 
 
        This method yields all of the path, offset and graphics context 
        combinations to draw the path collection.  The caller should already 
        have looped over the results of `_iter_collection_raw_paths` to draw 
        this collection. 
 
        The arguments should be the same as that passed into 
        `draw_path_collection`, with the exception of *path_ids*, which is a 
        list of arbitrary objects that the backend will use to reference one of 
        the paths created in the `_iter_collection_raw_paths` stage. 
 
        Each yielded result is of the form:: 
 
           xo, yo, path_id, gc, rgbFace 
 
        where *xo*, *yo* is an offset; *path_id* is one of the elements of 
        *path_ids*; *gc* is a graphics context and *rgbFace* is a color to 
        use for filling the path. 
        &quot;&quot;&quot;</span>
        <span class="s1">Npaths = len(path_ids)</span>
        <span class="s1">Noffsets = len(offsets)</span>
        <span class="s1">N = max(Npaths</span><span class="s2">, </span><span class="s1">Noffsets)</span>
        <span class="s1">Nfacecolors = len(facecolors)</span>
        <span class="s1">Nedgecolors = len(edgecolors)</span>
        <span class="s1">Nlinewidths = len(linewidths)</span>
        <span class="s1">Nlinestyles = len(linestyles)</span>
        <span class="s1">Nurls = len(urls)</span>

        <span class="s2">if </span><span class="s1">(Nfacecolors == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">Nedgecolors == </span><span class="s5">0</span><span class="s1">) </span><span class="s2">or </span><span class="s1">Npaths == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">gc0 = self.new_gc()</span>
        <span class="s1">gc0.copy_properties(gc)</span>

        <span class="s2">def </span><span class="s1">cycle_or_default(seq</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s4"># Cycle over *seq* if it is not empty; else always yield *default*.</span>
            <span class="s2">return </span><span class="s1">(itertools.cycle(seq) </span><span class="s2">if </span><span class="s1">len(seq)</span>
                    <span class="s2">else </span><span class="s1">itertools.repeat(default))</span>

        <span class="s1">pathids = cycle_or_default(path_ids)</span>
        <span class="s1">toffsets = cycle_or_default(offset_trans.transform(offsets)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">fcs = cycle_or_default(facecolors)</span>
        <span class="s1">ecs = cycle_or_default(edgecolors)</span>
        <span class="s1">lws = cycle_or_default(linewidths)</span>
        <span class="s1">lss = cycle_or_default(linestyles)</span>
        <span class="s1">aas = cycle_or_default(antialiaseds)</span>
        <span class="s1">urls = cycle_or_default(urls)</span>

        <span class="s2">if </span><span class="s1">Nedgecolors == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">gc0.set_linewidth(</span><span class="s5">0.0</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">pathid</span><span class="s2">, </span><span class="s1">(xo</span><span class="s2">, </span><span class="s1">yo)</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">ec</span><span class="s2">, </span><span class="s1">lw</span><span class="s2">, </span><span class="s1">ls</span><span class="s2">, </span><span class="s1">aa</span><span class="s2">, </span><span class="s1">url </span><span class="s2">in </span><span class="s1">itertools.islice(</span>
                <span class="s1">zip(pathids</span><span class="s2">, </span><span class="s1">toffsets</span><span class="s2">, </span><span class="s1">fcs</span><span class="s2">, </span><span class="s1">ecs</span><span class="s2">, </span><span class="s1">lws</span><span class="s2">, </span><span class="s1">lss</span><span class="s2">, </span><span class="s1">aas</span><span class="s2">, </span><span class="s1">urls)</span><span class="s2">, </span><span class="s1">N):</span>
            <span class="s2">if not </span><span class="s1">(np.isfinite(xo) </span><span class="s2">and </span><span class="s1">np.isfinite(yo)):</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">Nedgecolors:</span>
                <span class="s2">if </span><span class="s1">Nlinewidths:</span>
                    <span class="s1">gc0.set_linewidth(lw)</span>
                <span class="s2">if </span><span class="s1">Nlinestyles:</span>
                    <span class="s1">gc0.set_dashes(*ls)</span>
                <span class="s2">if </span><span class="s1">len(ec) == </span><span class="s5">4 </span><span class="s2">and </span><span class="s1">ec[</span><span class="s5">3</span><span class="s1">] == </span><span class="s5">0.0</span><span class="s1">:</span>
                    <span class="s1">gc0.set_linewidth(</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">gc0.set_foreground(ec)</span>
            <span class="s2">if </span><span class="s1">fc </span><span class="s2">is not None and </span><span class="s1">len(fc) == </span><span class="s5">4 </span><span class="s2">and </span><span class="s1">fc[</span><span class="s5">3</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">fc = </span><span class="s2">None</span>
            <span class="s1">gc0.set_antialiased(aa)</span>
            <span class="s2">if </span><span class="s1">Nurls:</span>
                <span class="s1">gc0.set_url(url)</span>
            <span class="s2">yield </span><span class="s1">xo</span><span class="s2">, </span><span class="s1">yo</span><span class="s2">, </span><span class="s1">pathid</span><span class="s2">, </span><span class="s1">gc0</span><span class="s2">, </span><span class="s1">fc</span>
        <span class="s1">gc0.restore()</span>

    <span class="s2">def </span><span class="s1">get_image_magnification(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the factor by which to magnify images passed to `draw_image`. 
        Allows a backend to have images at a different resolution to other 
        artists. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1.0</span>

    <span class="s2">def </span><span class="s1">draw_image(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw an RGBA image. 
 
        Parameters 
        ---------- 
        gc : `.GraphicsContextBase` 
            A graphics context with clipping information. 
 
        x : scalar 
            The distance in physical units (i.e., dots or pixels) from the left 
            hand side of the canvas. 
 
        y : scalar 
            The distance in physical units (i.e., dots or pixels) from the 
            bottom side of the canvas. 
 
        im : (N, M, 4) array-like of np.uint8 
            An array of RGBA pixels. 
 
        transform : `matplotlib.transforms.Affine2DBase` 
            If and only if the concrete backend is written such that 
            `option_scale_image` returns ``True``, an affine transformation 
            (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The 
            translation vector of the transformation is given in physical units 
            (i.e., dots or pixels). Note that the transformation does not 
            override *x* and *y*, and has to be applied *before* translating 
            the result by *x* and *y* (this can be accomplished by adding *x* 
            and *y* to the translation vector defined by *transform*). 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">option_image_nocomposite(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether image composition by Matplotlib should be skipped. 
 
        Raster backends should usually return False (letting the C-level 
        rasterizer take care of image composition); vector backends should 
        usually return ``not rcParams[&quot;image.composite_image&quot;]``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">option_scale_image(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether arbitrary affine transformations in `draw_image` are 
        supported (True for most vector backends). 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">draw_tex(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">mtext=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a TeX instance. 
 
        Parameters 
        ---------- 
        gc : `.GraphicsContextBase` 
            The graphics context. 
        x : float 
            The x location of the text in display coords. 
        y : float 
            The y location of the text baseline in display coords. 
        s : str 
            The TeX text string. 
        prop : `~matplotlib.font_manager.FontProperties` 
            The font properties. 
        angle : float 
            The rotation angle in degrees anti-clockwise. 
        mtext : `matplotlib.text.Text` 
            The original text object to be rendered. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._draw_text_as_path(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath=</span><span class="s3">&quot;TeX&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_text(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath=</span><span class="s2">False, </span><span class="s1">mtext=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a text instance. 
 
        Parameters 
        ---------- 
        gc : `.GraphicsContextBase` 
            The graphics context. 
        x : float 
            The x location of the text in display coords. 
        y : float 
            The y location of the text baseline in display coords. 
        s : str 
            The text string. 
        prop : `~matplotlib.font_manager.FontProperties` 
            The font properties. 
        angle : float 
            The rotation angle in degrees anti-clockwise. 
        ismath : bool or &quot;TeX&quot; 
            If True, use mathtext parser. If &quot;TeX&quot;, use tex for rendering. 
        mtext : `matplotlib.text.Text` 
            The original text object to be rendered. 
 
        Notes 
        ----- 
        **Note for backend implementers:** 
 
        When you are trying to determine if you have gotten your bounding box 
        right (which is what enables the text layout/alignment to work 
        properly), it helps to change the line in text.py:: 
 
            if 0: bbox_artist(self, renderer) 
 
        to if 1, and then the actual bounding box will be plotted along with 
        your text. 
        &quot;&quot;&quot;</span>

        <span class="s1">self._draw_text_as_path(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath)</span>

    <span class="s2">def </span><span class="s1">_get_text_path_transform(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the text path and transform. 
 
        Parameters 
        ---------- 
        x : float 
            The x location of the text in display coords. 
        y : float 
            The y location of the text baseline in display coords. 
        s : str 
            The text to be converted. 
        prop : `~matplotlib.font_manager.FontProperties` 
            The font property. 
        angle : float 
            Angle in degrees to render the text at. 
        ismath : bool or &quot;TeX&quot; 
            If True, use mathtext parser. If &quot;TeX&quot;, use tex for rendering. 
        &quot;&quot;&quot;</span>

        <span class="s1">text2path = self._text2path</span>
        <span class="s1">fontsize = self.points_to_pixels(prop.get_size_in_points())</span>
        <span class="s1">verts</span><span class="s2">, </span><span class="s1">codes = text2path.get_text_path(prop</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">ismath=ismath)</span>

        <span class="s1">path = Path(verts</span><span class="s2">, </span><span class="s1">codes)</span>
        <span class="s1">angle = np.deg2rad(angle)</span>
        <span class="s2">if </span><span class="s1">self.flipy():</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = self.get_canvas_width_height()</span>
            <span class="s1">transform = (Affine2D()</span>
                         <span class="s1">.scale(fontsize / text2path.FONT_SCALE)</span>
                         <span class="s1">.rotate(angle)</span>
                         <span class="s1">.translate(x</span><span class="s2">, </span><span class="s1">height - y))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">transform = (Affine2D()</span>
                         <span class="s1">.scale(fontsize / text2path.FONT_SCALE)</span>
                         <span class="s1">.rotate(angle)</span>
                         <span class="s1">.translate(x</span><span class="s2">, </span><span class="s1">y))</span>

        <span class="s2">return </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span>

    <span class="s2">def </span><span class="s1">_draw_text_as_path(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw the text by converting them to paths using `.TextToPath`. 
 
        Parameters 
        ---------- 
        x : float 
            The x location of the text in display coords. 
        y : float 
            The y location of the text baseline in display coords. 
        s : str 
            The text to be converted. 
        prop : `~matplotlib.font_manager.FontProperties` 
            The font property. 
        angle : float 
            Angle in degrees to render the text at. 
        ismath : bool or &quot;TeX&quot; 
            If True, use mathtext parser. If &quot;TeX&quot;, use tex for rendering. 
        &quot;&quot;&quot;</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">transform = self._get_text_path_transform(</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath)</span>
        <span class="s1">color = gc.get_rgb()</span>
        <span class="s1">gc.set_linewidth(</span><span class="s5">0.0</span><span class="s1">)</span>
        <span class="s1">self.draw_path(gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">rgbFace=color)</span>

    <span class="s2">def </span><span class="s1">get_text_width_height_descent(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">ismath):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the width, height, and descent (offset from the bottom 
        to the baseline), in display coords, of the string *s* with 
        `.FontProperties` *prop*. 
        &quot;&quot;&quot;</span>
        <span class="s1">fontsize = prop.get_size_in_points()</span>

        <span class="s2">if </span><span class="s1">ismath == </span><span class="s3">'TeX'</span><span class="s1">:</span>
            <span class="s4"># todo: handle properties</span>
            <span class="s2">return </span><span class="s1">self.get_texmanager().get_text_width_height_descent(</span>
                <span class="s1">s</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">renderer=self)</span>

        <span class="s1">dpi = self.points_to_pixels(</span><span class="s5">72</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ismath:</span>
            <span class="s1">dims = self._text2path.mathtext_parser.parse(s</span><span class="s2">, </span><span class="s1">dpi</span><span class="s2">, </span><span class="s1">prop)</span>
            <span class="s2">return </span><span class="s1">dims[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]  </span><span class="s4"># return width, height, descent</span>

        <span class="s1">flags = self._text2path._get_hinting_flag()</span>
        <span class="s1">font = self._text2path._get_font(prop)</span>
        <span class="s1">font.set_size(fontsize</span><span class="s2">, </span><span class="s1">dpi)</span>
        <span class="s4"># the width and height of unrotated string</span>
        <span class="s1">font.set_text(s</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">flags=flags)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = font.get_width_height()</span>
        <span class="s1">d = font.get_descent()</span>
        <span class="s1">w /= </span><span class="s5">64.0  </span><span class="s4"># convert from subpixels</span>
        <span class="s1">h /= </span><span class="s5">64.0</span>
        <span class="s1">d /= </span><span class="s5">64.0</span>
        <span class="s2">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">d</span>

    <span class="s2">def </span><span class="s1">flipy(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether y values increase from top to bottom. 
 
        Note that this only affects drawing of texts. 
        &quot;&quot;&quot;</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_canvas_width_height(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the canvas width and height in display coords.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">get_texmanager(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.TexManager` instance.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._texmanager </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._texmanager = TexManager()</span>
        <span class="s2">return </span><span class="s1">self._texmanager</span>

    <span class="s2">def </span><span class="s1">new_gc(self):</span>
        <span class="s0">&quot;&quot;&quot;Return an instance of a `.GraphicsContextBase`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">GraphicsContextBase()</span>

    <span class="s2">def </span><span class="s1">points_to_pixels(self</span><span class="s2">, </span><span class="s1">points):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert points to display units. 
 
        You need to override this function (unless your backend 
        doesn't have a dpi, e.g., postscript or svg).  Some imaging 
        systems assume some value for pixels per inch:: 
 
            points to pixels = points * pixels_per_inch/72 * dpi/72 
 
        Parameters 
        ---------- 
        points : float or array-like 
            a float or a numpy array of float 
 
        Returns 
        ------- 
        Points converted to pixels 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">points</span>

    <span class="s2">def </span><span class="s1">start_rasterizing(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch to the raster renderer. 
 
        Used by `.MixedModeRenderer`. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">stop_rasterizing(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch back to the vector renderer and draw the contents of the raster 
        renderer as an image on the vector renderer. 
 
        Used by `.MixedModeRenderer`. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">start_filter(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch to a temporary renderer for image filtering effects. 
 
        Currently only supported by the agg renderer. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">stop_filter(self</span><span class="s2">, </span><span class="s1">filter_func):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch back to the original renderer.  The contents of the temporary 
        renderer is processed with the *filter_func* and is drawn on the 
        original renderer as an image. 
 
        Currently only supported by the agg renderer. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_draw_disabled(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Context manager to temporary disable drawing. 
 
        This is used for getting the drawn size of Artists.  This lets us 
        run the draw process to update any Python state but does not pay the 
        cost of the draw_XYZ calls on the canvas. 
        &quot;&quot;&quot;</span>
        <span class="s1">no_ops = {</span>
            <span class="s1">meth_name: </span><span class="s2">lambda </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs: </span><span class="s2">None</span>
            <span class="s2">for </span><span class="s1">meth_name </span><span class="s2">in </span><span class="s1">dir(RendererBase)</span>
            <span class="s2">if </span><span class="s1">(meth_name.startswith(</span><span class="s3">&quot;draw_&quot;</span><span class="s1">)</span>
                <span class="s2">or </span><span class="s1">meth_name </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;open_group&quot;</span><span class="s2">, </span><span class="s3">&quot;close_group&quot;</span><span class="s1">])</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">_setattr_cm(self</span><span class="s2">, </span><span class="s1">**no_ops)</span>


<span class="s2">class </span><span class="s1">GraphicsContextBase:</span>
    <span class="s0">&quot;&quot;&quot;An abstract base class that provides color, line styles, etc.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._alpha = </span><span class="s5">1.0</span>
        <span class="s1">self._forced_alpha = </span><span class="s2">False  </span><span class="s4"># if True, _alpha overrides A from RGBA</span>
        <span class="s1">self._antialiased = </span><span class="s5">1  </span><span class="s4"># use 0, 1 not True, False for extension code</span>
        <span class="s1">self._capstyle = CapStyle(</span><span class="s3">'butt'</span><span class="s1">)</span>
        <span class="s1">self._cliprect = </span><span class="s2">None</span>
        <span class="s1">self._clippath = </span><span class="s2">None</span>
        <span class="s1">self._dashes = </span><span class="s5">0</span><span class="s2">, None</span>
        <span class="s1">self._joinstyle = JoinStyle(</span><span class="s3">'round'</span><span class="s1">)</span>
        <span class="s1">self._linestyle = </span><span class="s3">'solid'</span>
        <span class="s1">self._linewidth = </span><span class="s5">1</span>
        <span class="s1">self._rgb = (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>
        <span class="s1">self._hatch = </span><span class="s2">None</span>
        <span class="s1">self._hatch_color = colors.to_rgba(rcParams[</span><span class="s3">'hatch.color'</span><span class="s1">])</span>
        <span class="s1">self._hatch_linewidth = rcParams[</span><span class="s3">'hatch.linewidth'</span><span class="s1">]</span>
        <span class="s1">self._url = </span><span class="s2">None</span>
        <span class="s1">self._gid = </span><span class="s2">None</span>
        <span class="s1">self._snap = </span><span class="s2">None</span>
        <span class="s1">self._sketch = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">copy_properties(self</span><span class="s2">, </span><span class="s1">gc):</span>
        <span class="s0">&quot;&quot;&quot;Copy properties from *gc* to self.&quot;&quot;&quot;</span>
        <span class="s1">self._alpha = gc._alpha</span>
        <span class="s1">self._forced_alpha = gc._forced_alpha</span>
        <span class="s1">self._antialiased = gc._antialiased</span>
        <span class="s1">self._capstyle = gc._capstyle</span>
        <span class="s1">self._cliprect = gc._cliprect</span>
        <span class="s1">self._clippath = gc._clippath</span>
        <span class="s1">self._dashes = gc._dashes</span>
        <span class="s1">self._joinstyle = gc._joinstyle</span>
        <span class="s1">self._linestyle = gc._linestyle</span>
        <span class="s1">self._linewidth = gc._linewidth</span>
        <span class="s1">self._rgb = gc._rgb</span>
        <span class="s1">self._hatch = gc._hatch</span>
        <span class="s1">self._hatch_color = gc._hatch_color</span>
        <span class="s1">self._hatch_linewidth = gc._hatch_linewidth</span>
        <span class="s1">self._url = gc._url</span>
        <span class="s1">self._gid = gc._gid</span>
        <span class="s1">self._snap = gc._snap</span>
        <span class="s1">self._sketch = gc._sketch</span>

    <span class="s2">def </span><span class="s1">restore(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restore the graphics context from the stack - needed only 
        for backends that save graphics contexts on a stack. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_alpha(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the alpha value used for blending - not supported on all 
        backends. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._alpha</span>

    <span class="s2">def </span><span class="s1">get_antialiased(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the object should try to do antialiased rendering.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._antialiased</span>

    <span class="s2">def </span><span class="s1">get_capstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.CapStyle`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._capstyle.name</span>

    <span class="s2">def </span><span class="s1">get_clip_rectangle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the clip rectangle as a `~matplotlib.transforms.Bbox` instance. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cliprect</span>

    <span class="s2">def </span><span class="s1">get_clip_path(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the clip path in the form (path, transform), where path 
        is a `~.path.Path` instance, and transform is 
        an affine transform to apply to the path before clipping. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._clippath </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">tpath</span><span class="s2">, </span><span class="s1">tr = self._clippath.get_transformed_path_and_affine()</span>
            <span class="s2">if </span><span class="s1">np.all(np.isfinite(tpath.vertices)):</span>
                <span class="s2">return </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">tr</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_log.warning(</span><span class="s3">&quot;Ill-defined clip_path detected. Returning None.&quot;</span><span class="s1">)</span>
                <span class="s2">return None, None</span>
        <span class="s2">return None, None</span>

    <span class="s2">def </span><span class="s1">get_dashes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dash style as an (offset, dash-list) pair. 
 
        See `.set_dashes` for details. 
 
        Default value is (None, None). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dashes</span>

    <span class="s2">def </span><span class="s1">get_forced_alpha(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the value given by get_alpha() should be used to 
        override any other alpha-channel values. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._forced_alpha</span>

    <span class="s2">def </span><span class="s1">get_joinstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.JoinStyle`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._joinstyle.name</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the line width in points.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linewidth</span>

    <span class="s2">def </span><span class="s1">get_rgb(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a tuple of three or four floats from 0-1.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._rgb</span>

    <span class="s2">def </span><span class="s1">get_url(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a url if one is set, None otherwise.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._url</span>

    <span class="s2">def </span><span class="s1">get_gid(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the object identifier if one is set, None otherwise.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._gid</span>

    <span class="s2">def </span><span class="s1">get_snap(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the snap setting, which can be: 
 
        * True: snap vertices to the nearest pixel center 
        * False: leave vertices as-is 
        * None: (auto) If the path contains only rectilinear line segments, 
          round to the nearest pixel center 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._snap</span>

    <span class="s2">def </span><span class="s1">set_alpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the alpha value used for blending - not supported on all backends. 
 
        If ``alpha=None`` (the default), the alpha components of the 
        foreground and fill colors will be used to set their respective 
        transparencies (where applicable); otherwise, ``alpha`` will override 
        them. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._alpha = alpha</span>
            <span class="s1">self._forced_alpha = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._alpha = </span><span class="s5">1.0</span>
            <span class="s1">self._forced_alpha = </span><span class="s2">False</span>
        <span class="s1">self.set_foreground(self._rgb</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_antialiased(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot;Set whether object should be drawn with antialiased rendering.&quot;&quot;&quot;</span>
        <span class="s4"># Use ints to make life easier on extension code trying to read the gc.</span>
        <span class="s1">self._antialiased = int(bool(b))</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_capstyle(self</span><span class="s2">, </span><span class="s1">cs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set how to draw endpoints of lines. 
 
        Parameters 
        ---------- 
        cs : `.CapStyle` or %(CapStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._capstyle = CapStyle(cs)</span>

    <span class="s2">def </span><span class="s1">set_clip_rectangle(self</span><span class="s2">, </span><span class="s1">rectangle):</span>
        <span class="s0">&quot;&quot;&quot;Set the clip rectangle to a `.Bbox` or None.&quot;&quot;&quot;</span>
        <span class="s1">self._cliprect = rectangle</span>

    <span class="s2">def </span><span class="s1">set_clip_path(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot;Set the clip path to a `.TransformedPath` or None.&quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance((transforms.TransformedPath</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">path=path)</span>
        <span class="s1">self._clippath = path</span>

    <span class="s2">def </span><span class="s1">set_dashes(self</span><span class="s2">, </span><span class="s1">dash_offset</span><span class="s2">, </span><span class="s1">dash_list):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the dash style for the gc. 
 
        Parameters 
        ---------- 
        dash_offset : float 
            Distance, in points, into the dash pattern at which to 
            start the pattern. It is usually set to 0. 
        dash_list : array-like or None 
            The on-off sequence as points.  None specifies a solid line. All 
            values must otherwise be non-negative (:math:`\\ge 0`). 
 
        Notes 
        ----- 
        See p. 666 of the PostScript 
        `Language Reference 
        &lt;https://www.adobe.com/jp/print/postscript/pdfs/PLRM.pdf&gt;`_ 
        for more info. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dash_list </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">dl = np.asarray(dash_list)</span>
            <span class="s2">if </span><span class="s1">np.any(dl &lt; </span><span class="s5">0.0</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;All values in the dash list must be non-negative&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dl.size </span><span class="s2">and not </span><span class="s1">np.any(dl &gt; </span><span class="s5">0.0</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">'At least one value in the dash list must be positive'</span><span class="s1">)</span>
        <span class="s1">self._dashes = dash_offset</span><span class="s2">, </span><span class="s1">dash_list</span>

    <span class="s2">def </span><span class="s1">set_foreground(self</span><span class="s2">, </span><span class="s1">fg</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the foreground color. 
 
        Parameters 
        ---------- 
        fg : color 
        isRGBA : bool 
            If *fg* is known to be an ``(r, g, b, a)`` tuple, *isRGBA* can be 
            set to True to improve performance. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._forced_alpha </span><span class="s2">and </span><span class="s1">isRGBA:</span>
            <span class="s1">self._rgb = fg[:</span><span class="s5">3</span><span class="s1">] + (self._alpha</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self._forced_alpha:</span>
            <span class="s1">self._rgb = colors.to_rgba(fg</span><span class="s2">, </span><span class="s1">self._alpha)</span>
        <span class="s2">elif </span><span class="s1">isRGBA:</span>
            <span class="s1">self._rgb = fg</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._rgb = colors.to_rgba(fg)</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_joinstyle(self</span><span class="s2">, </span><span class="s1">js):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set how to draw connections between line segments. 
 
        Parameters 
        ---------- 
        js : `.JoinStyle` or %(JoinStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._joinstyle = JoinStyle(js)</span>

    <span class="s2">def </span><span class="s1">set_linewidth(self</span><span class="s2">, </span><span class="s1">w):</span>
        <span class="s0">&quot;&quot;&quot;Set the linewidth in points.&quot;&quot;&quot;</span>
        <span class="s1">self._linewidth = float(w)</span>

    <span class="s2">def </span><span class="s1">set_url(self</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot;Set the url for links in compatible backends.&quot;&quot;&quot;</span>
        <span class="s1">self._url = url</span>

    <span class="s2">def </span><span class="s1">set_gid(self</span><span class="s2">, </span><span class="s1">id):</span>
        <span class="s0">&quot;&quot;&quot;Set the id.&quot;&quot;&quot;</span>
        <span class="s1">self._gid = id</span>

    <span class="s2">def </span><span class="s1">set_snap(self</span><span class="s2">, </span><span class="s1">snap):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the snap setting which may be: 
 
        * True: snap vertices to the nearest pixel center 
        * False: leave vertices as-is 
        * None: (auto) If the path contains only rectilinear line segments, 
          round to the nearest pixel center 
        &quot;&quot;&quot;</span>
        <span class="s1">self._snap = snap</span>

    <span class="s2">def </span><span class="s1">set_hatch(self</span><span class="s2">, </span><span class="s1">hatch):</span>
        <span class="s0">&quot;&quot;&quot;Set the hatch style (for fills).&quot;&quot;&quot;</span>
        <span class="s1">self._hatch = hatch</span>

    <span class="s2">def </span><span class="s1">get_hatch(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the current hatch style.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._hatch</span>

    <span class="s2">def </span><span class="s1">get_hatch_path(self</span><span class="s2">, </span><span class="s1">density=</span><span class="s5">6.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return a `.Path` for the current hatch.&quot;&quot;&quot;</span>
        <span class="s1">hatch = self.get_hatch()</span>
        <span class="s2">if </span><span class="s1">hatch </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">Path.hatch(hatch</span><span class="s2">, </span><span class="s1">density)</span>

    <span class="s2">def </span><span class="s1">get_hatch_color(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the hatch color.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._hatch_color</span>

    <span class="s2">def </span><span class="s1">set_hatch_color(self</span><span class="s2">, </span><span class="s1">hatch_color):</span>
        <span class="s0">&quot;&quot;&quot;Set the hatch color.&quot;&quot;&quot;</span>
        <span class="s1">self._hatch_color = hatch_color</span>

    <span class="s2">def </span><span class="s1">get_hatch_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the hatch linewidth.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._hatch_linewidth</span>

    <span class="s2">def </span><span class="s1">get_sketch_params(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the sketch parameters for the artist. 
 
        Returns 
        ------- 
        tuple or `None` 
 
            A 3-tuple with the following elements: 
 
            * ``scale``: The amplitude of the wiggle perpendicular to the 
              source line. 
            * ``length``: The length of the wiggle along the line. 
            * ``randomness``: The scale factor by which the length is 
              shrunken or expanded. 
 
            May return `None` if no sketch parameters were set. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._sketch</span>

    <span class="s2">def </span><span class="s1">set_sketch_params(self</span><span class="s2">, </span><span class="s1">scale=</span><span class="s2">None, </span><span class="s1">length=</span><span class="s2">None, </span><span class="s1">randomness=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the sketch parameters. 
 
        Parameters 
        ---------- 
        scale : float, optional 
            The amplitude of the wiggle perpendicular to the source line, in 
            pixels.  If scale is `None`, or not provided, no sketch filter will 
            be provided. 
        length : float, default: 128 
            The length of the wiggle along the line, in pixels. 
        randomness : float, default: 16 
            The scale factor by which the length is shrunken or expanded. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._sketch = (</span>
            <span class="s2">None if </span><span class="s1">scale </span><span class="s2">is None</span>
            <span class="s2">else </span><span class="s1">(scale</span><span class="s2">, </span><span class="s1">length </span><span class="s2">or </span><span class="s5">128.</span><span class="s2">, </span><span class="s1">randomness </span><span class="s2">or </span><span class="s5">16.</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TimerBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    A base class for providing timer events, useful for things animations. 
    Backends need to implement a few specific methods in order to use their 
    own timing mechanisms so that the timer events are integrated into their 
    event loops. 
 
    Subclasses must override the following methods: 
 
    - ``_timer_start``: Backend-specific code for starting the timer. 
    - ``_timer_stop``: Backend-specific code for stopping the timer. 
 
    Subclasses may additionally override the following methods: 
 
    - ``_timer_set_single_shot``: Code for setting the timer to single shot 
      operating mode, if supported by the timer object.  If not, the `Timer` 
      class itself will store the flag and the ``_on_timer`` method should be 
      overridden to support such behavior. 
 
    - ``_timer_set_interval``: Code for setting the interval on the timer, if 
      there is a method for doing so on the timer object. 
 
    - ``_on_timer``: The internal function that any timer object should call, 
      which will handle the task of running all callbacks that have been set. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">interval=</span><span class="s2">None, </span><span class="s1">callbacks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        interval : int, default: 1000ms 
            The time between timer events in milliseconds.  Will be stored as 
            ``timer.interval``. 
        callbacks : list[tuple[callable, tuple, dict]] 
            List of (func, args, kwargs) tuples that will be called upon 
            timer events.  This list is accessible as ``timer.callbacks`` and 
            can be manipulated directly, or the functions `add_callback` and 
            `remove_callback` can be used. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.callbacks = [] </span><span class="s2">if </span><span class="s1">callbacks </span><span class="s2">is None else </span><span class="s1">callbacks.copy()</span>
        <span class="s4"># Set .interval and not ._interval to go through the property setter.</span>
        <span class="s1">self.interval = </span><span class="s5">1000 </span><span class="s2">if </span><span class="s1">interval </span><span class="s2">is None else </span><span class="s1">interval</span>
        <span class="s1">self.single_shot = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__del__(self):</span>
        <span class="s0">&quot;&quot;&quot;Need to stop timer and possibly disconnect timer.&quot;&quot;&quot;</span>
        <span class="s1">self._timer_stop()</span>

    <span class="s2">def </span><span class="s1">start(self</span><span class="s2">, </span><span class="s1">interval=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Start the timer object. 
 
        Parameters 
        ---------- 
        interval : int, optional 
            Timer interval in milliseconds; overrides a previously set interval 
            if provided. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">interval </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.interval = interval</span>
        <span class="s1">self._timer_start()</span>

    <span class="s2">def </span><span class="s1">stop(self):</span>
        <span class="s0">&quot;&quot;&quot;Stop the timer.&quot;&quot;&quot;</span>
        <span class="s1">self._timer_stop()</span>

    <span class="s2">def </span><span class="s1">_timer_start(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_timer_stop(self):</span>
        <span class="s2">pass</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">interval(self):</span>
        <span class="s0">&quot;&quot;&quot;The time between timer events, in milliseconds.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._interval</span>

    <span class="s1">@interval.setter</span>
    <span class="s2">def </span><span class="s1">interval(self</span><span class="s2">, </span><span class="s1">interval):</span>
        <span class="s4"># Force to int since none of the backends actually support fractional</span>
        <span class="s4"># milliseconds, and some error or give warnings.</span>
        <span class="s1">interval = int(interval)</span>
        <span class="s1">self._interval = interval</span>
        <span class="s1">self._timer_set_interval()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">single_shot(self):</span>
        <span class="s0">&quot;&quot;&quot;Whether this timer should stop after a single run.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._single</span>

    <span class="s1">@single_shot.setter</span>
    <span class="s2">def </span><span class="s1">single_shot(self</span><span class="s2">, </span><span class="s1">ss):</span>
        <span class="s1">self._single = ss</span>
        <span class="s1">self._timer_set_single_shot()</span>

    <span class="s2">def </span><span class="s1">add_callback(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Register *func* to be called by timer when the event fires. Any 
        additional arguments provided will be passed to *func*. 
 
        This function returns *func*, which makes it possible to use it as a 
        decorator. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.callbacks.append((func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs))</span>
        <span class="s2">return </span><span class="s1">func</span>

    <span class="s2">def </span><span class="s1">remove_callback(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove *func* from list of callbacks. 
 
        *args* and *kwargs* are optional and used to distinguish between copies 
        of the same function registered to be called with different arguments. 
        This behavior is deprecated.  In the future, ``*args, **kwargs`` won't 
        be considered anymore; to keep a specific callback removable by itself, 
        pass it to `add_callback` as a `functools.partial` object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">or </span><span class="s1">kwargs:</span>
            <span class="s1">_api.warn_deprecated(</span>
                <span class="s3">&quot;3.1&quot;</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;In a future version, Timer.remove_callback &quot;</span>
                <span class="s3">&quot;will not take *args, **kwargs anymore, but remove all &quot;</span>
                <span class="s3">&quot;callbacks where the callable matches; to keep a specific &quot;</span>
                <span class="s3">&quot;callback removable by itself, pass it to add_callback as a &quot;</span>
                <span class="s3">&quot;functools.partial object.&quot;</span><span class="s1">)</span>
            <span class="s1">self.callbacks.remove((func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">funcs = [c[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.callbacks]</span>
            <span class="s2">if </span><span class="s1">func </span><span class="s2">in </span><span class="s1">funcs:</span>
                <span class="s1">self.callbacks.pop(funcs.index(func))</span>

    <span class="s2">def </span><span class="s1">_timer_set_interval(self):</span>
        <span class="s0">&quot;&quot;&quot;Used to set interval on underlying timer object.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_timer_set_single_shot(self):</span>
        <span class="s0">&quot;&quot;&quot;Used to set single shot on underlying timer object.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_on_timer(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Runs all function that have been registered as callbacks. Functions 
        can return False (or 0) if they should not be called any more. If there 
        are no callbacks, the timer is automatically stopped. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs </span><span class="s2">in </span><span class="s1">self.callbacks:</span>
            <span class="s1">ret = func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s4"># docstring above explains why we use `if ret == 0` here,</span>
            <span class="s4"># instead of `if not ret`.</span>
            <span class="s4"># This will also catch `ret == False` as `False == 0`</span>
            <span class="s4"># but does not annoy the linters</span>
            <span class="s4"># https://docs.python.org/3/library/stdtypes.html#boolean-values</span>
            <span class="s2">if </span><span class="s1">ret == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.callbacks.remove((func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs))</span>

        <span class="s2">if </span><span class="s1">len(self.callbacks) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.stop()</span>


<span class="s2">class </span><span class="s1">Event:</span>
    <span class="s0">&quot;&quot;&quot; 
    A Matplotlib event. 
 
    The following attributes are defined and shown with their default values. 
    Subclasses may define additional attributes. 
 
    Attributes 
    ---------- 
    name : str 
        The event name. 
    canvas : `FigureCanvasBase` 
        The backend-specific canvas instance generating the event. 
    guiEvent 
        The GUI event that triggered the Matplotlib event. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.canvas = canvas</span>
        <span class="s1">self.guiEvent = guiEvent</span>

    <span class="s2">def </span><span class="s1">_process(self):</span>
        <span class="s0">&quot;&quot;&quot;Generate an event with name ``self.name`` on ``self.canvas``.&quot;&quot;&quot;</span>
        <span class="s1">self.canvas.callbacks.process(self.name</span><span class="s2">, </span><span class="s1">self)</span>


<span class="s2">class </span><span class="s1">DrawEvent(Event):</span>
    <span class="s0">&quot;&quot;&quot; 
    An event triggered by a draw operation on the canvas. 
 
    In most backends, callbacks subscribed to this event will be fired after 
    the rendering is complete but before the screen is updated. Any extra 
    artists drawn to the canvas's renderer will be reflected without an 
    explicit call to ``blit``. 
 
    .. warning:: 
 
       Calling ``canvas.draw`` and ``canvas.blit`` in these callbacks may 
       not be safe with all backends and may cause infinite recursion. 
 
    A DrawEvent has a number of special attributes in addition to those defined 
    by the parent `Event` class. 
 
    Attributes 
    ---------- 
    renderer : `RendererBase` 
        The renderer for the draw event. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">canvas)</span>
        <span class="s1">self.renderer = renderer</span>


<span class="s2">class </span><span class="s1">ResizeEvent(Event):</span>
    <span class="s0">&quot;&quot;&quot; 
    An event triggered by a canvas resize. 
 
    A ResizeEvent has a number of special attributes in addition to those 
    defined by the parent `Event` class. 
 
    Attributes 
    ---------- 
    width : int 
        Width of the canvas in pixels. 
    height : int 
        Height of the canvas in pixels. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas):</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">canvas)</span>
        <span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.height = canvas.get_width_height()</span>


<span class="s2">class </span><span class="s1">CloseEvent(Event):</span>
    <span class="s0">&quot;&quot;&quot;An event triggered by a figure being closed.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">LocationEvent(Event):</span>
    <span class="s0">&quot;&quot;&quot; 
    An event that has a screen location. 
 
    A LocationEvent has a number of special attributes in addition to those 
    defined by the parent `Event` class. 
 
    Attributes 
    ---------- 
    x, y : int or None 
        Event location in pixels from bottom left of canvas. 
    inaxes : `~.axes.Axes` or None 
        The `~.axes.Axes` instance over which the mouse is, if any. 
    xdata, ydata : float or None 
        Data coordinates of the mouse within *inaxes*, or *None* if the mouse 
        is not over an Axes. 
    modifiers : frozenset 
        The keyboard modifiers currently being pressed (except for KeyEvent). 
    &quot;&quot;&quot;</span>

    <span class="s1">lastevent = </span><span class="s2">None  </span><span class="s4"># The last event processed so far.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">modifiers=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s4"># x position - pixels from left of canvas</span>
        <span class="s1">self.x = int(x) </span><span class="s2">if </span><span class="s1">x </span><span class="s2">is not None else </span><span class="s1">x</span>
        <span class="s4"># y position - pixels from right of canvas</span>
        <span class="s1">self.y = int(y) </span><span class="s2">if </span><span class="s1">y </span><span class="s2">is not None else </span><span class="s1">y</span>
        <span class="s1">self.inaxes = </span><span class="s2">None  </span><span class="s4"># the Axes instance the mouse is over</span>
        <span class="s1">self.xdata = </span><span class="s2">None   </span><span class="s4"># x coord of mouse in data coords</span>
        <span class="s1">self.ydata = </span><span class="s2">None   </span><span class="s4"># y coord of mouse in data coords</span>
        <span class="s1">self.modifiers = frozenset(modifiers </span><span class="s2">if </span><span class="s1">modifiers </span><span class="s2">is not None else </span><span class="s1">[])</span>

        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None or </span><span class="s1">y </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># cannot check if event was in Axes if no (x, y) info</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.canvas.mouse_grabber </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.inaxes = self.canvas.inaxes((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.inaxes = self.canvas.mouse_grabber</span>

        <span class="s2">if </span><span class="s1">self.inaxes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">trans = self.inaxes.transData.inverted()</span>
                <span class="s1">xdata</span><span class="s2">, </span><span class="s1">ydata = trans.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.xdata = xdata</span>
                <span class="s1">self.ydata = ydata</span>


<span class="s2">class </span><span class="s1">MouseButton(IntEnum):</span>
    <span class="s1">LEFT = </span><span class="s5">1</span>
    <span class="s1">MIDDLE = </span><span class="s5">2</span>
    <span class="s1">RIGHT = </span><span class="s5">3</span>
    <span class="s1">BACK = </span><span class="s5">8</span>
    <span class="s1">FORWARD = </span><span class="s5">9</span>


<span class="s2">class </span><span class="s1">MouseEvent(LocationEvent):</span>
    <span class="s0">&quot;&quot;&quot; 
    A mouse event ('button_press_event', 'button_release_event', \ 
'scroll_event', 'motion_notify_event'). 
 
    A MouseEvent has a number of special attributes in addition to those 
    defined by the parent `Event` and `LocationEvent` classes. 
 
    Attributes 
    ---------- 
    button : None or `MouseButton` or {'up', 'down'} 
        The button pressed. 'up' and 'down' are used for scroll events. 
 
        Note that LEFT and RIGHT actually refer to the &quot;primary&quot; and 
        &quot;secondary&quot; buttons, i.e. if the user inverts their left and right 
        buttons (&quot;left-handed setting&quot;) then the LEFT button will be the one 
        physically on the right. 
 
        If this is unset, *name* is &quot;scroll_event&quot;, and *step* is nonzero, then 
        this will be set to &quot;up&quot; or &quot;down&quot; depending on the sign of *step*. 
 
    key : None or str 
        The key pressed when the mouse event triggered, e.g. 'shift'. 
        See `KeyEvent`. 
 
        .. warning:: 
           This key is currently obtained from the last 'key_press_event' or 
           'key_release_event' that occurred within the canvas.  Thus, if the 
           last change of keyboard state occurred while the canvas did not have 
           focus, this attribute will be wrong.  On the other hand, the 
           ``modifiers`` attribute should always be correct, but it can only 
           report on modifier keys. 
 
    step : float 
        The number of scroll steps (positive for 'up', negative for 'down'). 
        This applies only to 'scroll_event' and defaults to 0 otherwise. 
 
    dblclick : bool 
        Whether the event is a double-click. This applies only to 
        'button_press_event' and is False otherwise. In particular, it's 
        not used in 'button_release_event'. 
 
    Examples 
    -------- 
    :: 
 
        def on_press(event): 
            print('you pressed', event.button, event.xdata, event.ydata) 
 
        cid = fig.canvas.mpl_connect('button_press_event', on_press) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button=</span><span class="s2">None, </span><span class="s1">key=</span><span class="s2">None,</span>
                 <span class="s1">step=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dblclick=</span><span class="s2">False, </span><span class="s1">guiEvent=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">modifiers=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent</span><span class="s2">, </span><span class="s1">modifiers=modifiers)</span>
        <span class="s2">if </span><span class="s1">button </span><span class="s2">in </span><span class="s1">MouseButton.__members__.values():</span>
            <span class="s1">button = MouseButton(button)</span>
        <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;scroll_event&quot; </span><span class="s2">and </span><span class="s1">button </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">step &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">button = </span><span class="s3">&quot;up&quot;</span>
            <span class="s2">elif </span><span class="s1">step &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">button = </span><span class="s3">&quot;down&quot;</span>
        <span class="s1">self.button = button</span>
        <span class="s1">self.key = key</span>
        <span class="s1">self.step = step</span>
        <span class="s1">self.dblclick = dblclick</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s3">: &quot;</span>
                <span class="s3">f&quot;xy=(</span><span class="s2">{</span><span class="s1">self.x</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">self.y</span><span class="s2">}</span><span class="s3">) xydata=(</span><span class="s2">{</span><span class="s1">self.xdata</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">self.ydata</span><span class="s2">}</span><span class="s3">) &quot;</span>
                <span class="s3">f&quot;button=</span><span class="s2">{</span><span class="s1">self.button</span><span class="s2">} </span><span class="s3">dblclick=</span><span class="s2">{</span><span class="s1">self.dblclick</span><span class="s2">} </span><span class="s3">&quot;</span>
                <span class="s3">f&quot;inaxes=</span><span class="s2">{</span><span class="s1">self.inaxes</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">PickEvent(Event):</span>
    <span class="s0">&quot;&quot;&quot; 
    A pick event. 
 
    This event is fired when the user picks a location on the canvas 
    sufficiently close to an artist that has been made pickable with 
    `.Artist.set_picker`. 
 
    A PickEvent has a number of special attributes in addition to those defined 
    by the parent `Event` class. 
 
    Attributes 
    ---------- 
    mouseevent : `MouseEvent` 
        The mouse event that generated the pick. 
    artist : `matplotlib.artist.Artist` 
        The picked artist.  Note that artists are not pickable by default 
        (see `.Artist.set_picker`). 
    other 
        Additional attributes may be present depending on the type of the 
        picked object; e.g., a `.Line2D` pick may define different extra 
        attributes than a `.PatchCollection` pick. 
 
    Examples 
    -------- 
    Bind a function ``on_pick()`` to pick events, that prints the coordinates 
    of the picked data point:: 
 
        ax.plot(np.rand(100), 'o', picker=5)  # 5 points tolerance 
 
        def on_pick(event): 
            line = event.artist 
            xdata, ydata = line.get_data() 
            ind = event.ind 
            print(f'on pick line: {xdata[ind]:.3f}, {ydata[ind]:.3f}') 
 
        cid = fig.canvas.mpl_connect('pick_event', on_pick) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">mouseevent</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">,</span>
                 <span class="s1">guiEvent=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">guiEvent </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">guiEvent = mouseevent.guiEvent</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">guiEvent)</span>
        <span class="s1">self.mouseevent = mouseevent</span>
        <span class="s1">self.artist = artist</span>
        <span class="s1">self.__dict__.update(kwargs)</span>


<span class="s2">class </span><span class="s1">KeyEvent(LocationEvent):</span>
    <span class="s0">&quot;&quot;&quot; 
    A key event (key press, key release). 
 
    A KeyEvent has a number of special attributes in addition to those defined 
    by the parent `Event` and `LocationEvent` classes. 
 
    Attributes 
    ---------- 
    key : None or str 
        The key(s) pressed. Could be *None*, a single case sensitive Unicode 
        character (&quot;g&quot;, &quot;G&quot;, &quot;#&quot;, etc.), a special key (&quot;control&quot;, &quot;shift&quot;, 
        &quot;f1&quot;, &quot;up&quot;, etc.) or a combination of the above (e.g., &quot;ctrl+alt+g&quot;, 
        &quot;ctrl+alt+G&quot;). 
 
    Notes 
    ----- 
    Modifier keys will be prefixed to the pressed key and will be in the order 
    &quot;ctrl&quot;, &quot;alt&quot;, &quot;super&quot;. The exception to this rule is when the pressed key 
    is itself a modifier key, therefore &quot;ctrl+alt&quot; and &quot;alt+control&quot; can both 
    be valid key values. 
 
    Examples 
    -------- 
    :: 
 
        def on_key(event): 
            print('you pressed', event.key, event.xdata, event.ydata) 
 
        cid = fig.canvas.mpl_connect('key_press_event', on_key) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">x=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.key = key</span>


<span class="s4"># Default callback for key events.</span>
<span class="s2">def </span><span class="s1">_key_handler(event):</span>
    <span class="s4"># Dead reckoning of key.</span>
    <span class="s2">if </span><span class="s1">event.name == </span><span class="s3">&quot;key_press_event&quot;</span><span class="s1">:</span>
        <span class="s1">event.canvas._key = event.key</span>
    <span class="s2">elif </span><span class="s1">event.name == </span><span class="s3">&quot;key_release_event&quot;</span><span class="s1">:</span>
        <span class="s1">event.canvas._key = </span><span class="s2">None</span>


<span class="s4"># Default callback for mouse events.</span>
<span class="s2">def </span><span class="s1">_mouse_handler(event):</span>
    <span class="s4"># Dead-reckoning of button and key.</span>
    <span class="s2">if </span><span class="s1">event.name == </span><span class="s3">&quot;button_press_event&quot;</span><span class="s1">:</span>
        <span class="s1">event.canvas._button = event.button</span>
    <span class="s2">elif </span><span class="s1">event.name == </span><span class="s3">&quot;button_release_event&quot;</span><span class="s1">:</span>
        <span class="s1">event.canvas._button = </span><span class="s2">None</span>
    <span class="s2">elif </span><span class="s1">event.name == </span><span class="s3">&quot;motion_notify_event&quot; </span><span class="s2">and </span><span class="s1">event.button </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">event.button = event.canvas._button</span>
    <span class="s2">if </span><span class="s1">event.key </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">event.key = event.canvas._key</span>
    <span class="s4"># Emit axes_enter/axes_leave.</span>
    <span class="s2">if </span><span class="s1">event.name == </span><span class="s3">&quot;motion_notify_event&quot;</span><span class="s1">:</span>
        <span class="s1">last = LocationEvent.lastevent</span>
        <span class="s1">last_axes = last.inaxes </span><span class="s2">if </span><span class="s1">last </span><span class="s2">is not None else None</span>
        <span class="s2">if </span><span class="s1">last_axes != event.inaxes:</span>
            <span class="s2">if </span><span class="s1">last_axes </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">last.canvas.callbacks.process(</span><span class="s3">&quot;axes_leave_event&quot;</span><span class="s2">, </span><span class="s1">last)</span>
                <span class="s2">except </span><span class="s1">Exception:</span>
                    <span class="s2">pass  </span><span class="s4"># The last canvas may already have been torn down.</span>
            <span class="s2">if </span><span class="s1">event.inaxes </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">event.canvas.callbacks.process(</span><span class="s3">&quot;axes_enter_event&quot;</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s1">LocationEvent.lastevent = (</span>
            <span class="s2">None if </span><span class="s1">event.name == </span><span class="s3">&quot;figure_leave_event&quot; </span><span class="s2">else </span><span class="s1">event)</span>


<span class="s2">def </span><span class="s1">_get_renderer(figure</span><span class="s2">, </span><span class="s1">print_method=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the renderer that would be used to save a `.Figure`. 
 
    If you need a renderer without any active draw methods use 
    renderer._draw_disabled to temporary patch them out at your call site. 
    &quot;&quot;&quot;</span>
    <span class="s4"># This is implemented by triggering a draw, then immediately jumping out of</span>
    <span class="s4"># Figure.draw() by raising an exception.</span>

    <span class="s2">class </span><span class="s1">Done(Exception):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">_draw(renderer): </span><span class="s2">raise </span><span class="s1">Done(renderer)</span>

    <span class="s2">with </span><span class="s1">cbook._setattr_cm(figure</span><span class="s2">, </span><span class="s1">draw=_draw)</span><span class="s2">, </span><span class="s1">ExitStack() </span><span class="s2">as </span><span class="s1">stack:</span>
        <span class="s2">if </span><span class="s1">print_method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fmt = figure.canvas.get_default_filetype()</span>
            <span class="s4"># Even for a canvas' default output type, a canvas switch may be</span>
            <span class="s4"># needed, e.g. for FigureCanvasBase.</span>
            <span class="s1">print_method = stack.enter_context(</span>
                <span class="s1">figure.canvas._switch_canvas_and_return_print_method(fmt))</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">print_method(io.BytesIO())</span>
        <span class="s2">except </span><span class="s1">Done </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">renderer</span><span class="s2">, </span><span class="s1">= exc.args</span>
            <span class="s2">return </span><span class="s1">renderer</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">print_method</span><span class="s2">} </span><span class="s3">did not call Figure.draw, so &quot;</span>
                               <span class="s3">f&quot;no renderer is available&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_no_output_draw(figure):</span>
    <span class="s4"># _no_output_draw was promoted to the figure level, but</span>
    <span class="s4"># keep this here in case someone was calling it...</span>
    <span class="s1">figure.draw_without_rendering()</span>


<span class="s2">def </span><span class="s1">_is_non_interactive_terminal_ipython(ip):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether we are in a terminal IPython, but non interactive. 
 
    When in _terminal_ IPython, ip.parent will have and `interact` attribute, 
    if this attribute is False we do not setup eventloop integration as the 
    user will _not_ interact with IPython. In all other case (ZMQKernel, or is 
    interactive), we do. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(hasattr(ip</span><span class="s2">, </span><span class="s3">'parent'</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">(ip.parent </span><span class="s2">is not None</span><span class="s1">)</span>
            <span class="s2">and </span><span class="s1">getattr(ip.parent</span><span class="s2">, </span><span class="s3">'interact'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is False</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">FigureCanvasBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    The canvas the figure renders into. 
 
    Attributes 
    ---------- 
    figure : `matplotlib.figure.Figure` 
        A high-level figure instance. 
    &quot;&quot;&quot;</span>

    <span class="s4"># Set to one of {&quot;qt&quot;, &quot;gtk3&quot;, &quot;gtk4&quot;, &quot;wx&quot;, &quot;tk&quot;, &quot;macosx&quot;} if an</span>
    <span class="s4"># interactive framework is required, or None otherwise.</span>
    <span class="s1">required_interactive_framework = </span><span class="s2">None</span>

    <span class="s4"># The manager class instantiated by new_manager.</span>
    <span class="s4"># (This is defined as a classproperty because the manager class is</span>
    <span class="s4"># currently defined *after* the canvas class, but one could also assign</span>
    <span class="s4"># ``FigureCanvasBase.manager_class = FigureManagerBase``</span>
    <span class="s4"># after defining both classes.)</span>
    <span class="s1">manager_class = _api.classproperty(</span><span class="s2">lambda </span><span class="s1">cls: FigureManagerBase)</span>

    <span class="s1">events = [</span>
        <span class="s3">'resize_event'</span><span class="s2">,</span>
        <span class="s3">'draw_event'</span><span class="s2">,</span>
        <span class="s3">'key_press_event'</span><span class="s2">,</span>
        <span class="s3">'key_release_event'</span><span class="s2">,</span>
        <span class="s3">'button_press_event'</span><span class="s2">,</span>
        <span class="s3">'button_release_event'</span><span class="s2">,</span>
        <span class="s3">'scroll_event'</span><span class="s2">,</span>
        <span class="s3">'motion_notify_event'</span><span class="s2">,</span>
        <span class="s3">'pick_event'</span><span class="s2">,</span>
        <span class="s3">'figure_enter_event'</span><span class="s2">,</span>
        <span class="s3">'figure_leave_event'</span><span class="s2">,</span>
        <span class="s3">'axes_enter_event'</span><span class="s2">,</span>
        <span class="s3">'axes_leave_event'</span><span class="s2">,</span>
        <span class="s3">'close_event'</span>
    <span class="s1">]</span>

    <span class="s1">fixed_dpi = </span><span class="s2">None</span>

    <span class="s1">filetypes = _default_filetypes</span>

    <span class="s1">@_api.classproperty</span>
    <span class="s2">def </span><span class="s1">supports_blit(cls):</span>
        <span class="s0">&quot;&quot;&quot;If this Canvas sub-class supports blitting.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(hasattr(cls</span><span class="s2">, </span><span class="s3">&quot;copy_from_bbox&quot;</span><span class="s1">)</span>
                <span class="s2">and </span><span class="s1">hasattr(cls</span><span class="s2">, </span><span class="s3">&quot;restore_region&quot;</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
        <span class="s1">self._fix_ipython_backend2gui()</span>
        <span class="s1">self._is_idle_drawing = </span><span class="s2">True</span>
        <span class="s1">self._is_saving = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">figure </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">figure = Figure()</span>
        <span class="s1">figure.set_canvas(self)</span>
        <span class="s1">self.figure = figure</span>
        <span class="s1">self.manager = </span><span class="s2">None</span>
        <span class="s1">self.widgetlock = widgets.LockDraw()</span>
        <span class="s1">self._button = </span><span class="s2">None  </span><span class="s4"># the button pressed</span>
        <span class="s1">self._key = </span><span class="s2">None  </span><span class="s4"># the key pressed</span>
        <span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty = </span><span class="s2">None, None</span>
        <span class="s1">self.mouse_grabber = </span><span class="s2">None  </span><span class="s4"># the Axes currently grabbing mouse</span>
        <span class="s1">self.toolbar = </span><span class="s2">None  </span><span class="s4"># NavigationToolbar2 will set me</span>
        <span class="s1">self._is_idle_drawing = </span><span class="s2">False</span>
        <span class="s4"># We don't want to scale up the figure DPI more than once.</span>
        <span class="s1">figure._original_dpi = figure.dpi</span>
        <span class="s1">self._device_pixel_ratio = </span><span class="s5">1</span>
        <span class="s1">super().__init__()  </span><span class="s4"># Typically the GUI widget init (if any).</span>

    <span class="s1">callbacks = property(</span><span class="s2">lambda </span><span class="s1">self: self.figure._canvas_callbacks)</span>
    <span class="s1">button_pick_id = property(</span><span class="s2">lambda </span><span class="s1">self: self.figure._button_pick_id)</span>
    <span class="s1">scroll_pick_id = property(</span><span class="s2">lambda </span><span class="s1">self: self.figure._scroll_pick_id)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@functools.lru_cache()</span>
    <span class="s2">def </span><span class="s1">_fix_ipython_backend2gui(cls):</span>
        <span class="s4"># Fix hard-coded module -&gt; toolkit mapping in IPython (used for</span>
        <span class="s4"># `ipython --auto`).  This cannot be done at import time due to</span>
        <span class="s4"># ordering issues, so we do it when creating a canvas, and should only</span>
        <span class="s4"># be done once per class (hence the `lru_cache(1)`).</span>
        <span class="s2">if </span><span class="s1">sys.modules.get(</span><span class="s3">&quot;IPython&quot;</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">import </span><span class="s1">IPython</span>
        <span class="s1">ip = IPython.get_ipython()</span>
        <span class="s2">if not </span><span class="s1">ip:</span>
            <span class="s2">return</span>
        <span class="s2">from </span><span class="s1">IPython.core </span><span class="s2">import </span><span class="s1">pylabtools </span><span class="s2">as </span><span class="s1">pt</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">hasattr(pt</span><span class="s2">, </span><span class="s3">&quot;backend2gui&quot;</span><span class="s1">)</span>
                <span class="s2">or not </span><span class="s1">hasattr(ip</span><span class="s2">, </span><span class="s3">&quot;enable_matplotlib&quot;</span><span class="s1">)):</span>
            <span class="s4"># In case we ever move the patch to IPython and remove these APIs,</span>
            <span class="s4"># don't break on our side.</span>
            <span class="s2">return</span>
        <span class="s1">backend2gui_rif = {</span>
            <span class="s3">&quot;qt&quot;</span><span class="s1">: </span><span class="s3">&quot;qt&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;gtk3&quot;</span><span class="s1">: </span><span class="s3">&quot;gtk3&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;gtk4&quot;</span><span class="s1">: </span><span class="s3">&quot;gtk4&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;wx&quot;</span><span class="s1">: </span><span class="s3">&quot;wx&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;macosx&quot;</span><span class="s1">: </span><span class="s3">&quot;osx&quot;</span><span class="s2">,</span>
        <span class="s1">}.get(cls.required_interactive_framework)</span>
        <span class="s2">if </span><span class="s1">backend2gui_rif:</span>
            <span class="s2">if </span><span class="s1">_is_non_interactive_terminal_ipython(ip):</span>
                <span class="s1">ip.enable_gui(backend2gui_rif)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">new_manager(cls</span><span class="s2">, </span><span class="s1">figure</span><span class="s2">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new figure manager for *figure*, using this canvas class. 
 
        Notes 
        ----- 
        This method should not be reimplemented in subclasses.  If 
        custom manager creation logic is needed, please reimplement 
        ``FigureManager.create_with_canvas``. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls.manager_class.create_with_canvas(cls</span><span class="s2">, </span><span class="s1">figure</span><span class="s2">, </span><span class="s1">num)</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">_idle_draw_cntx(self):</span>
        <span class="s1">self._is_idle_drawing = </span><span class="s2">True</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self._is_idle_drawing = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">is_saving(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the renderer is in the process of saving 
        to a file, rather than rendering for an on-screen buffer. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._is_saving</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;canvas.figure.pick&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">pick(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s2">if not </span><span class="s1">self.widgetlock.locked():</span>
            <span class="s1">self.figure.pick(mouseevent)</span>

    <span class="s2">def </span><span class="s1">blit(self</span><span class="s2">, </span><span class="s1">bbox=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Blit the canvas in bbox (default entire canvas).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">resize(self</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h):</span>
        <span class="s0">&quot;&quot;&quot; 
        UNUSED: Set the canvas size in pixels. 
 
        Certain backends may implement a similar method internally, but this is 
        not a requirement of, nor is it used by, Matplotlib itself. 
        &quot;&quot;&quot;</span>
        <span class="s4"># The entire method is actually deprecated, but we allow pass-through</span>
        <span class="s4"># to a parent class to support e.g. QWidget.resize.</span>
        <span class="s2">if </span><span class="s1">hasattr(super()</span><span class="s2">, </span><span class="s3">&quot;resize&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">super().resize(w</span><span class="s2">, </span><span class="s1">h)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_api.warn_deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;resize&quot;</span><span class="s2">, </span><span class="s1">obj_type=</span><span class="s3">&quot;method&quot;</span><span class="s2">,</span>
                                 <span class="s1">alternative=</span><span class="s3">&quot;FigureManagerBase.resize&quot;</span><span class="s1">)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('draw_event', DrawEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">draw_event(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Pass a `DrawEvent` to all functions connected to ``draw_event``.&quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'draw_event'</span>
        <span class="s1">event = DrawEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('resize_event', ResizeEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">resize_event(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Pass a `ResizeEvent` to all functions connected to ``resize_event``. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'resize_event'</span>
        <span class="s1">event = ResizeEvent(s</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s1">self.draw_idle()</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('close_event', CloseEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">close_event(self</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Pass a `CloseEvent` to all functions connected to ``close_event``. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'close_event'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">event = CloseEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
            <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">AttributeError):</span>
            <span class="s2">pass</span>
            <span class="s4"># Suppress the TypeError when the python session is being killed.</span>
            <span class="s4"># It may be that a better solution would be a mechanism to</span>
            <span class="s4"># disconnect all callbacks upon shutdown.</span>
            <span class="s4"># AttributeError occurs on OSX with qt4agg upon exiting</span>
            <span class="s4"># with an open window; 'callbacks' attribute no longer exists.</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('key_press_event', KeyEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">key_press_event(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Pass a `KeyEvent` to all functions connected to ``key_press_event``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._key = key</span>
        <span class="s1">s = </span><span class="s3">'key_press_event'</span>
        <span class="s1">event = KeyEvent(</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('key_release_event', KeyEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">key_release_event(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Pass a `KeyEvent` to all functions connected to ``key_release_event``. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'key_release_event'</span>
        <span class="s1">event = KeyEvent(</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s1">self._key = </span><span class="s2">None</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('pick_event', PickEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">pick_event(self</span><span class="s2">, </span><span class="s1">mouseevent</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for pick events. 
 
        This method will be called by artists who are picked and will 
        fire off `PickEvent` callbacks registered listeners. 
 
        Note that artists are not pickable by default (see 
        `.Artist.set_picker`). 
        &quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'pick_event'</span>
        <span class="s1">event = PickEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">mouseevent</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">,</span>
                          <span class="s1">guiEvent=mouseevent.guiEvent</span><span class="s2">,</span>
                          <span class="s1">**kwargs)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('scroll_event', MouseEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">scroll_event(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for scroll events. 
 
        Backend derived classes should call this function on any 
        scroll wheel event.  (*x*, *y*) are the canvas coords ((0, 0) is lower 
        left).  button and key are as defined in `MouseEvent`. 
 
        This method will call all functions connected to the 'scroll_event' 
        with a `MouseEvent` instance. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">step &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self._button = </span><span class="s3">'up'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._button = </span><span class="s3">'down'</span>
        <span class="s1">s = </span><span class="s3">'scroll_event'</span>
        <span class="s1">mouseevent = MouseEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">self._button</span><span class="s2">, </span><span class="s1">self._key</span><span class="s2">,</span>
                                <span class="s1">step=step</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">mouseevent)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('button_press_event', MouseEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">button_press_event(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">dblclick=</span><span class="s2">False, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for mouse button press events. 
 
        Backend derived classes should call this function on any mouse 
        button press.  (*x*, *y*) are the canvas coords ((0, 0) is lower left). 
        button and key are as defined in `MouseEvent`. 
 
        This method will call all functions connected to the 
        'button_press_event' with a `MouseEvent` instance. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._button = button</span>
        <span class="s1">s = </span><span class="s3">'button_press_event'</span>
        <span class="s1">mouseevent = MouseEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">self._key</span><span class="s2">,</span>
                                <span class="s1">dblclick=dblclick</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">mouseevent)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('button_release_event', MouseEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">button_release_event(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for mouse button release events. 
 
        Backend derived classes should call this function on any mouse 
        button release. 
 
        This method will call all functions connected to the 
        'button_release_event' with a `MouseEvent` instance. 
 
        Parameters 
        ---------- 
        x : float 
            The canvas coordinates where 0=left. 
        y : float 
            The canvas coordinates where 0=bottom. 
        guiEvent 
            The native UI event that generated the Matplotlib event. 
        &quot;&quot;&quot;</span>
        <span class="s1">s = </span><span class="s3">'button_release_event'</span>
        <span class="s1">event = MouseEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">self._key</span><span class="s2">, </span><span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s1">self._button = </span><span class="s2">None</span>

    <span class="s4"># Also remove _lastx, _lasty when this goes away.</span>
    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('motion_notify_event', MouseEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">motion_notify_event(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for mouse movement events. 
 
        Backend derived classes should call this function on any 
        motion-notify-event. 
 
        This method will call all functions connected to the 
        'motion_notify_event' with a `MouseEvent` instance. 
 
        Parameters 
        ---------- 
        x : float 
            The canvas coordinates where 0=left. 
        y : float 
            The canvas coordinates where 0=bottom. 
        guiEvent 
            The native UI event that generated the Matplotlib event. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty = x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s1">s = </span><span class="s3">'motion_notify_event'</span>
        <span class="s1">event = MouseEvent(s</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">self._button</span><span class="s2">, </span><span class="s1">self._key</span><span class="s2">,</span>
                           <span class="s1">guiEvent=guiEvent)</span>
        <span class="s1">self.callbacks.process(s</span><span class="s2">, </span><span class="s1">event)</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('leave_notify_event', LocationEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">leave_notify_event(self</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for the mouse cursor leaving the canvas. 
 
        Backend derived classes should call this function when leaving 
        canvas. 
 
        Parameters 
        ---------- 
        guiEvent 
            The native UI event that generated the Matplotlib event. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.callbacks.process(</span><span class="s3">'figure_leave_event'</span><span class="s2">, </span><span class="s1">LocationEvent.lastevent)</span>
        <span class="s1">LocationEvent.lastevent = </span><span class="s2">None</span>
        <span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty = </span><span class="s2">None, None</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=(</span>
        <span class="s3">&quot;callbacks.process('enter_notify_event', LocationEvent(...))&quot;</span><span class="s1">))</span>
    <span class="s2">def </span><span class="s1">enter_notify_event(self</span><span class="s2">, </span><span class="s1">guiEvent=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback processing for the mouse cursor entering the canvas. 
 
        Backend derived classes should call this function when entering 
        canvas. 
 
        Parameters 
        ---------- 
        guiEvent 
            The native UI event that generated the Matplotlib event. 
        xy : (float, float) 
            The coordinate location of the pointer when the canvas is entered. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._lastx</span><span class="s2">, </span><span class="s1">self._lasty = x</span><span class="s2">, </span><span class="s1">y = xy</span>
        <span class="s1">event = LocationEvent(</span><span class="s3">'figure_enter_event'</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">guiEvent)</span>
        <span class="s1">self.callbacks.process(</span><span class="s3">'figure_enter_event'</span><span class="s2">, </span><span class="s1">event)</span>

    <span class="s2">def </span><span class="s1">inaxes(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the topmost visible `~.axes.Axes` containing the point *xy*. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
            (x, y) pixel positions from left/bottom of the canvas. 
 
        Returns 
        ------- 
        `~matplotlib.axes.Axes` or None 
            The topmost visible Axes containing the point, or None if there 
            is no Axes at the point. 
        &quot;&quot;&quot;</span>
        <span class="s1">axes_list = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.figure.get_axes()</span>
                     <span class="s2">if </span><span class="s1">a.patch.contains_point(xy) </span><span class="s2">and </span><span class="s1">a.get_visible()]</span>
        <span class="s2">if </span><span class="s1">axes_list:</span>
            <span class="s1">axes = cbook._topmost_artist(axes_list)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">axes = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">axes</span>

    <span class="s2">def </span><span class="s1">grab_mouse(self</span><span class="s2">, </span><span class="s1">ax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the child `~.axes.Axes` which is grabbing the mouse events. 
 
        Usually called by the widgets themselves. It is an error to call this 
        if the mouse is already grabbed by another Axes. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.mouse_grabber </span><span class="s2">not in </span><span class="s1">(</span><span class="s2">None, </span><span class="s1">ax):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Another Axes already grabs mouse input&quot;</span><span class="s1">)</span>
        <span class="s1">self.mouse_grabber = ax</span>

    <span class="s2">def </span><span class="s1">release_mouse(self</span><span class="s2">, </span><span class="s1">ax):</span>
        <span class="s0">&quot;&quot;&quot; 
        Release the mouse grab held by the `~.axes.Axes` *ax*. 
 
        Usually called by the widgets. It is ok to call this even if *ax* 
        doesn't have the mouse grab currently. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.mouse_grabber </span><span class="s2">is </span><span class="s1">ax:</span>
            <span class="s1">self.mouse_grabber = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">set_cursor(self</span><span class="s2">, </span><span class="s1">cursor):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the current cursor. 
 
        This may have no effect if the backend does not display anything. 
 
        If required by the backend, this method should trigger an update in 
        the backend event loop after the cursor is set, as this method may be 
        called e.g. before a long-running task during which the GUI is not 
        updated. 
 
        Parameters 
        ---------- 
        cursor : `.Cursors` 
            The cursor to display over the canvas. Note: some backends may 
            change the cursor for the entire window. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Render the `.Figure`. 
 
        This method must walk the artist tree, even if no output is produced, 
        because it triggers deferred work that users may want to access 
        before saving output to disk. For example computing limits, 
        auto-limits, and tick values. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">draw_idle(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Request a widget redraw once control returns to the GUI event loop. 
 
        Even if multiple calls to `draw_idle` occur before control returns 
        to the GUI event loop, the figure will only be rendered once. 
 
        Notes 
        ----- 
        Backends may choose to override the method and implement their own 
        strategy to prevent multiple renderings. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._is_idle_drawing:</span>
            <span class="s2">with </span><span class="s1">self._idle_draw_cntx():</span>
                <span class="s1">self.draw(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">device_pixel_ratio(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The ratio of physical to logical pixels used for the canvas on screen. 
 
        By default, this is 1, meaning physical and logical pixels are the same 
        size. Subclasses that support High DPI screens may set this property to 
        indicate that said ratio is different. All Matplotlib interaction, 
        unless working directly with the canvas, remains in logical pixels. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._device_pixel_ratio</span>

    <span class="s2">def </span><span class="s1">_set_device_pixel_ratio(self</span><span class="s2">, </span><span class="s1">ratio):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the ratio of physical to logical pixels used for the canvas. 
 
        Subclasses that support High DPI screens can set this property to 
        indicate that said ratio is different. The canvas itself will be 
        created at the physical size, while the client side will use the 
        logical size. Thus the DPI of the Figure will change to be scaled by 
        this ratio. Implementations that support High DPI screens should use 
        physical pixels for events so that transforms back to Axes space are 
        correct. 
 
        By default, this is 1, meaning physical and logical pixels are the same 
        size. 
 
        Parameters 
        ---------- 
        ratio : float 
            The ratio of logical to physical pixels used for the canvas. 
 
        Returns 
        ------- 
        bool 
            Whether the ratio has changed. Backends may interpret this as a 
            signal to resize the window, repaint the canvas, or change any 
            other relevant properties. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._device_pixel_ratio == ratio:</span>
            <span class="s2">return False</span>
        <span class="s4"># In cases with mixed resolution displays, we need to be careful if the</span>
        <span class="s4"># device pixel ratio changes - in this case we need to resize the</span>
        <span class="s4"># canvas accordingly. Some backends provide events that indicate a</span>
        <span class="s4"># change in DPI, but those that don't will update this before drawing.</span>
        <span class="s1">dpi = ratio * self.figure._original_dpi</span>
        <span class="s1">self.figure._set_dpi(dpi</span><span class="s2">, </span><span class="s1">forward=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._device_pixel_ratio = ratio</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">get_width_height(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">physical=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the figure width and height in integral points or pixels. 
 
        When the figure is used on High DPI screens (and the backend supports 
        it), the truncation to integers occurs after scaling by the device 
        pixel ratio. 
 
        Parameters 
        ---------- 
        physical : bool, default: False 
            Whether to return true physical pixels or logical pixels. Physical 
            pixels may be used by backends that support HiDPI, but still 
            configure the canvas using its actual size. 
 
        Returns 
        ------- 
        width, height : int 
            The size of the figure, in points or pixels, depending on the 
            backend. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(int(size / (</span><span class="s5">1 </span><span class="s2">if </span><span class="s1">physical </span><span class="s2">else </span><span class="s1">self.device_pixel_ratio))</span>
                     <span class="s2">for </span><span class="s1">size </span><span class="s2">in </span><span class="s1">self.figure.bbox.max)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_supported_filetypes(cls):</span>
        <span class="s0">&quot;&quot;&quot;Return dict of savefig file formats supported by this backend.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls.filetypes</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_supported_filetypes_grouped(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a dict of savefig file formats supported by this backend, 
        where the keys are a file type name, such as 'Joint Photographic 
        Experts Group', and the values are a list of filename extensions used 
        for that filetype, such as ['jpg', 'jpeg']. 
        &quot;&quot;&quot;</span>
        <span class="s1">groupings = {}</span>
        <span class="s2">for </span><span class="s1">ext</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">cls.filetypes.items():</span>
            <span class="s1">groupings.setdefault(name</span><span class="s2">, </span><span class="s1">[]).append(ext)</span>
            <span class="s1">groupings[name].sort()</span>
        <span class="s2">return </span><span class="s1">groupings</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">_switch_canvas_and_return_print_method(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">backend=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Context manager temporarily setting the canvas for saving the figure:: 
 
            with canvas._switch_canvas_and_return_print_method(fmt, backend) \\ 
                    as print_method: 
                # ``print_method`` is a suitable ``print_{fmt}`` method, and 
                # the figure's canvas is temporarily switched to the method's 
                # canvas within the with... block.  ``print_method`` is also 
                # wrapped to suppress extra kwargs passed by ``print_figure``. 
 
        Parameters 
        ---------- 
        fmt : str 
            If *backend* is None, then determine a suitable canvas class for 
            saving to format *fmt* -- either the current canvas class, if it 
            supports *fmt*, or whatever `get_registered_canvas_class` returns; 
            switch the figure canvas to that canvas class. 
        backend : str or None, default: None 
            If not None, switch the figure canvas to the ``FigureCanvas`` class 
            of the given backend. 
        &quot;&quot;&quot;</span>
        <span class="s1">canvas = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">backend </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># Return a specific canvas class, if requested.</span>
            <span class="s1">canvas_class = (</span>
                <span class="s1">importlib.import_module(cbook._backend_module_name(backend))</span>
                <span class="s1">.FigureCanvas)</span>
            <span class="s2">if not </span><span class="s1">hasattr(canvas_class</span><span class="s2">, </span><span class="s3">f&quot;print_</span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">backend</span><span class="s2">!r} </span><span class="s3">backend does not support </span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">} </span><span class="s3">output&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">f&quot;print_</span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s4"># Return the current canvas if it supports the requested format.</span>
            <span class="s1">canvas = self</span>
            <span class="s1">canvas_class = </span><span class="s2">None  </span><span class="s4"># Skip call to switch_backends.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Return a default canvas for the requested format, if it exists.</span>
            <span class="s1">canvas_class = get_registered_canvas_class(fmt)</span>
        <span class="s2">if </span><span class="s1">canvas_class:</span>
            <span class="s1">canvas = self.switch_backends(canvas_class)</span>
        <span class="s2">if </span><span class="s1">canvas </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Format {!r} is not supported (supported formats: {})&quot;</span><span class="s1">.format(</span>
                    <span class="s1">fmt</span><span class="s2">, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(sorted(self.get_supported_filetypes()))))</span>
        <span class="s1">meth = getattr(canvas</span><span class="s2">, </span><span class="s3">f&quot;print_</span><span class="s2">{</span><span class="s1">fmt</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">mod = (meth.func.__module__</span>
               <span class="s2">if </span><span class="s1">hasattr(meth</span><span class="s2">, </span><span class="s3">&quot;func&quot;</span><span class="s1">)  </span><span class="s4"># partialmethod, e.g. backend_wx.</span>
               <span class="s2">else </span><span class="s1">meth.__module__)</span>
        <span class="s2">if </span><span class="s1">mod.startswith((</span><span class="s3">&quot;matplotlib.&quot;</span><span class="s2">, </span><span class="s3">&quot;mpl_toolkits.&quot;</span><span class="s1">)):</span>
            <span class="s1">optional_kws = {  </span><span class="s4"># Passed by print_figure for other renderers.</span>
                <span class="s3">&quot;dpi&quot;</span><span class="s2">, </span><span class="s3">&quot;facecolor&quot;</span><span class="s2">, </span><span class="s3">&quot;edgecolor&quot;</span><span class="s2">, </span><span class="s3">&quot;orientation&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;bbox_inches_restore&quot;</span><span class="s1">}</span>
            <span class="s1">skip = optional_kws - {*inspect.signature(meth).parameters}</span>
            <span class="s1">print_method = functools.wraps(meth)(</span><span class="s2">lambda </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs: meth(</span>
                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**{k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">skip}))</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># Let third-parties do as they see fit.</span>
            <span class="s1">print_method = meth</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">print_method</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.figure.canvas = self</span>

    <span class="s2">def </span><span class="s1">print_figure(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">dpi=</span><span class="s2">None, </span><span class="s1">facecolor=</span><span class="s2">None, </span><span class="s1">edgecolor=</span><span class="s2">None,</span>
            <span class="s1">orientation=</span><span class="s3">'portrait'</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
            <span class="s1">bbox_inches=</span><span class="s2">None, </span><span class="s1">pad_inches=</span><span class="s2">None, </span><span class="s1">bbox_extra_artists=</span><span class="s2">None,</span>
            <span class="s1">backend=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Render the figure to hardcopy. Set the figure patch face and edge 
        colors.  This is useful because some of the GUIs have a gray figure 
        face color background and you'll probably want to override this on 
        hardcopy. 
 
        Parameters 
        ---------- 
        filename : str or path-like or file-like 
            The file where the figure is saved. 
 
        dpi : float, default: :rc:`savefig.dpi` 
            The dots per inch to save the figure in. 
 
        facecolor : color or 'auto', default: :rc:`savefig.facecolor` 
            The facecolor of the figure.  If 'auto', use the current figure 
            facecolor. 
 
        edgecolor : color or 'auto', default: :rc:`savefig.edgecolor` 
            The edgecolor of the figure.  If 'auto', use the current figure 
            edgecolor. 
 
        orientation : {'landscape', 'portrait'}, default: 'portrait' 
            Only currently applies to PostScript printing. 
 
        format : str, optional 
            Force a specific file format. If not given, the format is inferred 
            from the *filename* extension, and if that fails from 
            :rc:`savefig.format`. 
 
        bbox_inches : 'tight' or `.Bbox`, default: :rc:`savefig.bbox` 
            Bounding box in inches: only the given portion of the figure is 
            saved.  If 'tight', try to figure out the tight bbox of the figure. 
 
        pad_inches : float, default: :rc:`savefig.pad_inches` 
            Amount of padding around the figure when *bbox_inches* is 'tight'. 
 
        bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional 
            A list of extra artists that will be considered when the 
            tight bbox is calculated. 
 
        backend : str, optional 
            Use a non-default backend to render the file, e.g. to render a 
            png file with the &quot;cairo&quot; backend rather than the default &quot;agg&quot;, 
            or a pdf file with the &quot;pgf&quot; backend rather than the default 
            &quot;pdf&quot;.  Note that the default backend is normally sufficient.  See 
            :ref:`the-builtin-backends` for a list of valid backends for each 
            file format.  Custom backends can be referenced as &quot;module://...&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># get format from filename, or from backend's default filetype</span>
            <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">os.PathLike):</span>
                <span class="s1">filename = os.fspath(filename)</span>
            <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">format = os.path.splitext(filename)[</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">format </span><span class="s2">is None or </span><span class="s1">format == </span><span class="s3">''</span><span class="s1">:</span>
                <span class="s1">format = self.get_default_filetype()</span>
                <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">filename = filename.rstrip(</span><span class="s3">'.'</span><span class="s1">) + </span><span class="s3">'.' </span><span class="s1">+ format</span>
        <span class="s1">format = format.lower()</span>

        <span class="s2">if </span><span class="s1">dpi </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dpi = rcParams[</span><span class="s3">'savefig.dpi'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">dpi == </span><span class="s3">'figure'</span><span class="s1">:</span>
            <span class="s1">dpi = getattr(self.figure</span><span class="s2">, </span><span class="s3">'_original_dpi'</span><span class="s2">, </span><span class="s1">self.figure.dpi)</span>

        <span class="s4"># Remove the figure manager, if any, to avoid resizing the GUI widget.</span>
        <span class="s2">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s2">, </span><span class="s1">manager=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">\</span>
             <span class="s1">self._switch_canvas_and_return_print_method(format</span><span class="s2">, </span><span class="s1">backend) \</span>
                 <span class="s2">as </span><span class="s1">print_method</span><span class="s2">, </span><span class="s1">\</span>
             <span class="s1">cbook._setattr_cm(self.figure</span><span class="s2">, </span><span class="s1">dpi=dpi)</span><span class="s2">, </span><span class="s1">\</span>
             <span class="s1">cbook._setattr_cm(self.figure.canvas</span><span class="s2">, </span><span class="s1">_device_pixel_ratio=</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">\</span>
             <span class="s1">cbook._setattr_cm(self.figure.canvas</span><span class="s2">, </span><span class="s1">_is_saving=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">\</span>
             <span class="s1">ExitStack() </span><span class="s2">as </span><span class="s1">stack:</span>

            <span class="s2">for </span><span class="s1">prop </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;facecolor&quot;</span><span class="s2">, </span><span class="s3">&quot;edgecolor&quot;</span><span class="s1">]:</span>
                <span class="s1">color = locals()[prop]</span>
                <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">color = rcParams[</span><span class="s3">f&quot;savefig.</span><span class="s2">{</span><span class="s1">prop</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">]</span>
                <span class="s2">if not </span><span class="s1">cbook._str_equal(color</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">):</span>
                    <span class="s1">stack.enter_context(self.figure._cm_set(**{prop: color}))</span>

            <span class="s2">if </span><span class="s1">bbox_inches </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">bbox_inches = rcParams[</span><span class="s3">'savefig.bbox'</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">(self.figure.get_layout_engine() </span><span class="s2">is not None or</span>
                    <span class="s1">bbox_inches == </span><span class="s3">&quot;tight&quot;</span><span class="s1">):</span>
                <span class="s4"># we need to trigger a draw before printing to make sure</span>
                <span class="s4"># CL works.  &quot;tight&quot; also needs a draw to get the right</span>
                <span class="s4"># locations:</span>
                <span class="s1">renderer = _get_renderer(</span>
                    <span class="s1">self.figure</span><span class="s2">,</span>
                    <span class="s1">functools.partial(</span>
                        <span class="s1">print_method</span><span class="s2">, </span><span class="s1">orientation=orientation)</span>
                <span class="s1">)</span>
                <span class="s2">with </span><span class="s1">getattr(renderer</span><span class="s2">, </span><span class="s3">&quot;_draw_disabled&quot;</span><span class="s2">, </span><span class="s1">nullcontext)():</span>
                    <span class="s1">self.figure.draw(renderer)</span>

            <span class="s2">if </span><span class="s1">bbox_inches:</span>
                <span class="s2">if </span><span class="s1">bbox_inches == </span><span class="s3">&quot;tight&quot;</span><span class="s1">:</span>
                    <span class="s1">bbox_inches = self.figure.get_tightbbox(</span>
                        <span class="s1">renderer</span><span class="s2">, </span><span class="s1">bbox_extra_artists=bbox_extra_artists)</span>
                    <span class="s2">if </span><span class="s1">pad_inches </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">pad_inches = rcParams[</span><span class="s3">'savefig.pad_inches'</span><span class="s1">]</span>
                    <span class="s1">bbox_inches = bbox_inches.padded(pad_inches)</span>

                <span class="s4"># call adjust_bbox to save only the given area</span>
                <span class="s1">restore_bbox = _tight_bbox.adjust_bbox(</span>
                    <span class="s1">self.figure</span><span class="s2">, </span><span class="s1">bbox_inches</span><span class="s2">, </span><span class="s1">self.figure.canvas.fixed_dpi)</span>

                <span class="s1">_bbox_inches_restore = (bbox_inches</span><span class="s2">, </span><span class="s1">restore_bbox)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_bbox_inches_restore = </span><span class="s2">None</span>

            <span class="s4"># we have already done layout above, so turn it off:</span>
            <span class="s1">stack.enter_context(self.figure._cm_set(layout_engine=</span><span class="s3">'none'</span><span class="s1">))</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># _get_renderer may change the figure dpi (as vector formats</span>
                <span class="s4"># force the figure dpi to 72), so we need to set it again here.</span>
                <span class="s2">with </span><span class="s1">cbook._setattr_cm(self.figure</span><span class="s2">, </span><span class="s1">dpi=dpi):</span>
                    <span class="s1">result = print_method(</span>
                        <span class="s1">filename</span><span class="s2">,</span>
                        <span class="s1">facecolor=facecolor</span><span class="s2">,</span>
                        <span class="s1">edgecolor=edgecolor</span><span class="s2">,</span>
                        <span class="s1">orientation=orientation</span><span class="s2">,</span>
                        <span class="s1">bbox_inches_restore=_bbox_inches_restore</span><span class="s2">,</span>
                        <span class="s1">**kwargs)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">bbox_inches </span><span class="s2">and </span><span class="s1">restore_bbox:</span>
                    <span class="s1">restore_bbox()</span>

            <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_default_filetype(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the default savefig file format as specified in 
        :rc:`savefig.format`. 
 
        The returned string does not include a period. This method is 
        overridden in backends that only support a single file type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">rcParams[</span><span class="s3">'savefig.format'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">get_default_filename(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string, which includes extension, suitable for use as 
        a default filename. 
        &quot;&quot;&quot;</span>
        <span class="s1">basename = (self.manager.get_window_title() </span><span class="s2">if </span><span class="s1">self.manager </span><span class="s2">is not None</span>
                    <span class="s2">else </span><span class="s3">''</span><span class="s1">)</span>
        <span class="s1">basename = (basename </span><span class="s2">or </span><span class="s3">'image'</span><span class="s1">).replace(</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">'_'</span><span class="s1">)</span>
        <span class="s1">filetype = self.get_default_filetype()</span>
        <span class="s1">filename = basename + </span><span class="s3">'.' </span><span class="s1">+ filetype</span>
        <span class="s2">return </span><span class="s1">filename</span>

    <span class="s2">def </span><span class="s1">switch_backends(self</span><span class="s2">, </span><span class="s1">FigureCanvasClass):</span>
        <span class="s0">&quot;&quot;&quot; 
        Instantiate an instance of FigureCanvasClass 
 
        This is used for backend switching, e.g., to instantiate a 
        FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is 
        not done, so any changes to one of the instances (e.g., setting 
        figure size or line props), will be reflected in the other 
        &quot;&quot;&quot;</span>
        <span class="s1">newCanvas = FigureCanvasClass(self.figure)</span>
        <span class="s1">newCanvas._is_saving = self._is_saving</span>
        <span class="s2">return </span><span class="s1">newCanvas</span>

    <span class="s2">def </span><span class="s1">mpl_connect(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot; 
        Bind function *func* to event *s*. 
 
        Parameters 
        ---------- 
        s : str 
            One of the following events ids: 
 
            - 'button_press_event' 
            - 'button_release_event' 
            - 'draw_event' 
            - 'key_press_event' 
            - 'key_release_event' 
            - 'motion_notify_event' 
            - 'pick_event' 
            - 'resize_event' 
            - 'scroll_event' 
            - 'figure_enter_event', 
            - 'figure_leave_event', 
            - 'axes_enter_event', 
            - 'axes_leave_event' 
            - 'close_event'. 
 
        func : callable 
            The callback function to be executed, which must have the 
            signature:: 
 
                def func(event: Event) -&gt; Any 
 
            For the location events (button and key press/release), if the 
            mouse is over the Axes, the ``inaxes`` attribute of the event will 
            be set to the `~matplotlib.axes.Axes` the event occurs is over, and 
            additionally, the variables ``xdata`` and ``ydata`` attributes will 
            be set to the mouse location in data coordinates.  See `.KeyEvent` 
            and `.MouseEvent` for more info. 
 
            .. note:: 
 
                If func is a method, this only stores a weak reference to the 
                method. Thus, the figure does not influence the lifetime of 
                the associated object. Usually, you want to make sure that the 
                object is kept alive throughout the lifetime of the figure by 
                holding a reference to it. 
 
        Returns 
        ------- 
        cid 
            A connection id that can be used with 
            `.FigureCanvasBase.mpl_disconnect`. 
 
        Examples 
        -------- 
        :: 
 
            def on_press(event): 
                print('you pressed', event.button, event.xdata, event.ydata) 
 
            cid = canvas.mpl_connect('button_press_event', on_press) 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self.callbacks.connect(s</span><span class="s2">, </span><span class="s1">func)</span>

    <span class="s2">def </span><span class="s1">mpl_disconnect(self</span><span class="s2">, </span><span class="s1">cid):</span>
        <span class="s0">&quot;&quot;&quot; 
        Disconnect the callback with id *cid*. 
 
        Examples 
        -------- 
        :: 
 
            cid = canvas.mpl_connect('button_press_event', on_press) 
            # ... later 
            canvas.mpl_disconnect(cid) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.callbacks.disconnect(cid)</span>

    <span class="s4"># Internal subclasses can override _timer_cls instead of new_timer, though</span>
    <span class="s4"># this is not a public API for third-party subclasses.</span>
    <span class="s1">_timer_cls = TimerBase</span>

    <span class="s2">def </span><span class="s1">new_timer(self</span><span class="s2">, </span><span class="s1">interval=</span><span class="s2">None, </span><span class="s1">callbacks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new backend-specific subclass of `.Timer`. 
 
        This is useful for getting periodic events through the backend's native 
        event loop.  Implemented only for backends with GUIs. 
 
        Parameters 
        ---------- 
        interval : int 
            Timer interval in milliseconds. 
 
        callbacks : list[tuple[callable, tuple, dict]] 
            Sequence of (func, args, kwargs) where ``func(*args, **kwargs)`` 
            will be executed by the timer every *interval*. 
 
            Callbacks which return ``False`` or ``0`` will be removed from the 
            timer. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; timer = fig.canvas.new_timer(callbacks=[(f1, (1,), {'a': 3})]) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._timer_cls(interval=interval</span><span class="s2">, </span><span class="s1">callbacks=callbacks)</span>

    <span class="s2">def </span><span class="s1">flush_events(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Flush the GUI events for the figure. 
 
        Interactive backends need to reimplement this method. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">start_event_loop(self</span><span class="s2">, </span><span class="s1">timeout=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Start a blocking event loop. 
 
        Such an event loop is used by interactive functions, such as 
        `~.Figure.ginput` and `~.Figure.waitforbuttonpress`, to wait for 
        events. 
 
        The event loop blocks until a callback function triggers 
        `stop_event_loop`, or *timeout* is reached. 
 
        If *timeout* is 0 or negative, never timeout. 
 
        Only interactive backends need to reimplement this method and it relies 
        on `flush_events` being properly implemented. 
 
        Interactive backends should implement this in a more native way. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">timeout &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">timeout = np.inf</span>
        <span class="s1">timestep = </span><span class="s5">0.01</span>
        <span class="s1">counter = </span><span class="s5">0</span>
        <span class="s1">self._looping = </span><span class="s2">True</span>
        <span class="s2">while </span><span class="s1">self._looping </span><span class="s2">and </span><span class="s1">counter * timestep &lt; timeout:</span>
            <span class="s1">self.flush_events()</span>
            <span class="s1">time.sleep(timestep)</span>
            <span class="s1">counter += </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">stop_event_loop(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Stop the current blocking event loop. 
 
        Interactive backends need to reimplement this to match 
        `start_event_loop` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._looping = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">key_press_handler(event</span><span class="s2">, </span><span class="s1">canvas=</span><span class="s2">None, </span><span class="s1">toolbar=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Implement the default Matplotlib key bindings for the canvas and toolbar 
    described at :ref:`key-event-handling`. 
 
    Parameters 
    ---------- 
    event : `KeyEvent` 
        A key press/release event. 
    canvas : `FigureCanvasBase`, default: ``event.canvas`` 
        The backend-specific canvas instance.  This parameter is kept for 
        back-compatibility, but, if set, should always be equal to 
        ``event.canvas``. 
    toolbar : `NavigationToolbar2`, default: ``event.canvas.toolbar`` 
        The navigation cursor toolbar.  This parameter is kept for 
        back-compatibility, but, if set, should always be equal to 
        ``event.canvas.toolbar``. 
    &quot;&quot;&quot;</span>
    <span class="s4"># these bindings happen whether you are over an Axes or not</span>

    <span class="s2">if </span><span class="s1">event.key </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">canvas </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">canvas = event.canvas</span>
    <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">toolbar = canvas.toolbar</span>

    <span class="s4"># Load key-mappings from rcParams.</span>
    <span class="s1">fullscreen_keys = rcParams[</span><span class="s3">'keymap.fullscreen'</span><span class="s1">]</span>
    <span class="s1">home_keys = rcParams[</span><span class="s3">'keymap.home'</span><span class="s1">]</span>
    <span class="s1">back_keys = rcParams[</span><span class="s3">'keymap.back'</span><span class="s1">]</span>
    <span class="s1">forward_keys = rcParams[</span><span class="s3">'keymap.forward'</span><span class="s1">]</span>
    <span class="s1">pan_keys = rcParams[</span><span class="s3">'keymap.pan'</span><span class="s1">]</span>
    <span class="s1">zoom_keys = rcParams[</span><span class="s3">'keymap.zoom'</span><span class="s1">]</span>
    <span class="s1">save_keys = rcParams[</span><span class="s3">'keymap.save'</span><span class="s1">]</span>
    <span class="s1">quit_keys = rcParams[</span><span class="s3">'keymap.quit'</span><span class="s1">]</span>
    <span class="s1">quit_all_keys = rcParams[</span><span class="s3">'keymap.quit_all'</span><span class="s1">]</span>
    <span class="s1">grid_keys = rcParams[</span><span class="s3">'keymap.grid'</span><span class="s1">]</span>
    <span class="s1">grid_minor_keys = rcParams[</span><span class="s3">'keymap.grid_minor'</span><span class="s1">]</span>
    <span class="s1">toggle_yscale_keys = rcParams[</span><span class="s3">'keymap.yscale'</span><span class="s1">]</span>
    <span class="s1">toggle_xscale_keys = rcParams[</span><span class="s3">'keymap.xscale'</span><span class="s1">]</span>

    <span class="s4"># toggle fullscreen mode ('f', 'ctrl + f')</span>
    <span class="s2">if </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">fullscreen_keys:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">canvas.manager.full_screen_toggle()</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

    <span class="s4"># quit the figure (default key 'ctrl+w')</span>
    <span class="s2">if </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">quit_keys:</span>
        <span class="s1">Gcf.destroy_fig(canvas.figure)</span>
    <span class="s2">if </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">quit_all_keys:</span>
        <span class="s1">Gcf.destroy_all()</span>

    <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s4"># home or reset mnemonic  (default key 'h', 'home' and 'r')</span>
        <span class="s2">if </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">home_keys:</span>
            <span class="s1">toolbar.home()</span>
        <span class="s4"># forward / backward keys to enable left handed quick navigation</span>
        <span class="s4"># (default key for backward: 'left', 'backspace' and 'c')</span>
        <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">back_keys:</span>
            <span class="s1">toolbar.back()</span>
        <span class="s4"># (default key for forward: 'right' and 'v')</span>
        <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">forward_keys:</span>
            <span class="s1">toolbar.forward()</span>
        <span class="s4"># pan mnemonic (default key 'p')</span>
        <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">pan_keys:</span>
            <span class="s1">toolbar.pan()</span>
            <span class="s1">toolbar._update_cursor(event)</span>
        <span class="s4"># zoom mnemonic (default key 'o')</span>
        <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">zoom_keys:</span>
            <span class="s1">toolbar.zoom()</span>
            <span class="s1">toolbar._update_cursor(event)</span>
        <span class="s4"># saving current figure (default key 's')</span>
        <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">save_keys:</span>
            <span class="s1">toolbar.save_figure()</span>

    <span class="s2">if </span><span class="s1">event.inaxes </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return</span>

    <span class="s4"># these bindings require the mouse to be over an Axes to trigger</span>
    <span class="s2">def </span><span class="s1">_get_uniform_gridstate(ticks):</span>
        <span class="s4"># Return True/False if all grid lines are on or off, None if they are</span>
        <span class="s4"># not all in the same state.</span>
        <span class="s2">if </span><span class="s1">all(tick.gridline.get_visible() </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks):</span>
            <span class="s2">return True</span>
        <span class="s2">elif not </span><span class="s1">any(tick.gridline.get_visible() </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks):</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s1">ax = event.inaxes</span>
    <span class="s4"># toggle major grids in current Axes (default key 'g')</span>
    <span class="s4"># Both here and below (for 'G'), we do nothing if *any* grid (major or</span>
    <span class="s4"># minor, x or y) is not in a uniform state, to avoid messing up user</span>
    <span class="s4"># customization.</span>
    <span class="s2">if </span><span class="s1">(event.key </span><span class="s2">in </span><span class="s1">grid_keys</span>
            <span class="s4"># Exclude minor grids not in a uniform state.</span>
            <span class="s2">and None not in </span><span class="s1">[_get_uniform_gridstate(ax.xaxis.minorTicks)</span><span class="s2">,</span>
                             <span class="s1">_get_uniform_gridstate(ax.yaxis.minorTicks)]):</span>
        <span class="s1">x_state = _get_uniform_gridstate(ax.xaxis.majorTicks)</span>
        <span class="s1">y_state = _get_uniform_gridstate(ax.yaxis.majorTicks)</span>
        <span class="s1">cycle = [(</span><span class="s2">False, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">True, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">True, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, True</span><span class="s1">)]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">x_state</span><span class="s2">, </span><span class="s1">y_state = (</span>
                <span class="s1">cycle[(cycle.index((x_state</span><span class="s2">, </span><span class="s1">y_state)) + </span><span class="s5">1</span><span class="s1">) % len(cycle)])</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s4"># Exclude major grids not in a uniform state.</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># If turning major grids off, also turn minor grids off.</span>
            <span class="s1">ax.grid(x_state</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">&quot;major&quot; </span><span class="s2">if </span><span class="s1">x_state </span><span class="s2">else </span><span class="s3">&quot;both&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">ax.grid(y_state</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">&quot;major&quot; </span><span class="s2">if </span><span class="s1">y_state </span><span class="s2">else </span><span class="s3">&quot;both&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">canvas.draw_idle()</span>
    <span class="s4"># toggle major and minor grids in current Axes (default key 'G')</span>
    <span class="s2">if </span><span class="s1">(event.key </span><span class="s2">in </span><span class="s1">grid_minor_keys</span>
            <span class="s4"># Exclude major grids not in a uniform state.</span>
            <span class="s2">and None not in </span><span class="s1">[_get_uniform_gridstate(ax.xaxis.majorTicks)</span><span class="s2">,</span>
                             <span class="s1">_get_uniform_gridstate(ax.yaxis.majorTicks)]):</span>
        <span class="s1">x_state = _get_uniform_gridstate(ax.xaxis.minorTicks)</span>
        <span class="s1">y_state = _get_uniform_gridstate(ax.yaxis.minorTicks)</span>
        <span class="s1">cycle = [(</span><span class="s2">False, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">True, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">True, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, True</span><span class="s1">)]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">x_state</span><span class="s2">, </span><span class="s1">y_state = (</span>
                <span class="s1">cycle[(cycle.index((x_state</span><span class="s2">, </span><span class="s1">y_state)) + </span><span class="s5">1</span><span class="s1">) % len(cycle)])</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s4"># Exclude minor grids not in a uniform state.</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ax.grid(x_state</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">&quot;both&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">ax.grid(y_state</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">&quot;both&quot;</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">canvas.draw_idle()</span>
    <span class="s4"># toggle scaling of y-axes between 'log and 'linear' (default key 'l')</span>
    <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">toggle_yscale_keys:</span>
        <span class="s1">scale = ax.get_yscale()</span>
        <span class="s2">if </span><span class="s1">scale == </span><span class="s3">'log'</span><span class="s1">:</span>
            <span class="s1">ax.set_yscale(</span><span class="s3">'linear'</span><span class="s1">)</span>
            <span class="s1">ax.figure.canvas.draw_idle()</span>
        <span class="s2">elif </span><span class="s1">scale == </span><span class="s3">'linear'</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">ax.set_yscale(</span><span class="s3">'log'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">_log.warning(str(exc))</span>
                <span class="s1">ax.set_yscale(</span><span class="s3">'linear'</span><span class="s1">)</span>
            <span class="s1">ax.figure.canvas.draw_idle()</span>
    <span class="s4"># toggle scaling of x-axes between 'log and 'linear' (default key 'k')</span>
    <span class="s2">elif </span><span class="s1">event.key </span><span class="s2">in </span><span class="s1">toggle_xscale_keys:</span>
        <span class="s1">scalex = ax.get_xscale()</span>
        <span class="s2">if </span><span class="s1">scalex == </span><span class="s3">'log'</span><span class="s1">:</span>
            <span class="s1">ax.set_xscale(</span><span class="s3">'linear'</span><span class="s1">)</span>
            <span class="s1">ax.figure.canvas.draw_idle()</span>
        <span class="s2">elif </span><span class="s1">scalex == </span><span class="s3">'linear'</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">ax.set_xscale(</span><span class="s3">'log'</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">_log.warning(str(exc))</span>
                <span class="s1">ax.set_xscale(</span><span class="s3">'linear'</span><span class="s1">)</span>
            <span class="s1">ax.figure.canvas.draw_idle()</span>


<span class="s2">def </span><span class="s1">button_press_handler(event</span><span class="s2">, </span><span class="s1">canvas=</span><span class="s2">None, </span><span class="s1">toolbar=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The default Matplotlib button actions for extra mouse buttons. 
 
    Parameters are as for `key_press_handler`, except that *event* is a 
    `MouseEvent`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">canvas </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">canvas = event.canvas</span>
    <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">toolbar = canvas.toolbar</span>
    <span class="s2">if </span><span class="s1">toolbar </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">button_name = str(MouseButton(event.button))</span>
        <span class="s2">if </span><span class="s1">button_name </span><span class="s2">in </span><span class="s1">rcParams[</span><span class="s3">'keymap.back'</span><span class="s1">]:</span>
            <span class="s1">toolbar.back()</span>
        <span class="s2">elif </span><span class="s1">button_name </span><span class="s2">in </span><span class="s1">rcParams[</span><span class="s3">'keymap.forward'</span><span class="s1">]:</span>
            <span class="s1">toolbar.forward()</span>


<span class="s2">class </span><span class="s1">NonGuiException(Exception):</span>
    <span class="s0">&quot;&quot;&quot;Raised when trying show a figure in a non-GUI backend.&quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">FigureManagerBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    A backend-independent abstraction of a figure container and controller. 
 
    The figure manager is used by pyplot to interact with the window in a 
    backend-independent way. It's an adapter for the real (GUI) framework that 
    represents the visual figure on screen. 
 
    GUI backends define from this class to translate common operations such 
    as *show* or *resize* to the GUI-specific code. Non-GUI backends do not 
    support these operations an can just use the base class. 
 
    This following basic operations are accessible: 
 
    **Window operations** 
 
    - `~.FigureManagerBase.show` 
    - `~.FigureManagerBase.destroy` 
    - `~.FigureManagerBase.full_screen_toggle` 
    - `~.FigureManagerBase.resize` 
    - `~.FigureManagerBase.get_window_title` 
    - `~.FigureManagerBase.set_window_title` 
 
    **Key and mouse button press handling** 
 
    The figure manager sets up default key and mouse button press handling by 
    hooking up the `.key_press_handler` to the matplotlib event system. This 
    ensures the same shortcuts and mouse actions across backends. 
 
    **Other operations** 
 
    Subclasses will have additional attributes and functions to access 
    additional functionality. This is of course backend-specific. For example, 
    most GUI backends have ``window`` and ``toolbar`` attributes that give 
    access to the native GUI widgets of the respective framework. 
 
    Attributes 
    ---------- 
    canvas : `FigureCanvasBase` 
        The backend-specific canvas instance. 
 
    num : int or str 
        The figure number. 
 
    key_press_handler_id : int 
        The default key handler cid, when using the toolmanager. 
        To disable the default key press handling use:: 
 
            figure.canvas.mpl_disconnect( 
                figure.canvas.manager.key_press_handler_id) 
 
    button_press_handler_id : int 
        The default mouse button handler cid, when using the toolmanager. 
        To disable the default button press handling use:: 
 
            figure.canvas.mpl_disconnect( 
                figure.canvas.manager.button_press_handler_id) 
    &quot;&quot;&quot;</span>

    <span class="s1">_toolbar2_class = </span><span class="s2">None</span>
    <span class="s1">_toolmanager_toolbar_class = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">canvas</span><span class="s2">, </span><span class="s1">num):</span>
        <span class="s1">self.canvas = canvas</span>
        <span class="s1">canvas.manager = self  </span><span class="s4"># store a pointer to parent</span>
        <span class="s1">self.num = num</span>
        <span class="s1">self.set_window_title(</span><span class="s3">f&quot;Figure </span><span class="s2">{</span><span class="s1">num</span><span class="s2">:</span><span class="s3">d</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s1">self.key_press_handler_id = </span><span class="s2">None</span>
        <span class="s1">self.button_press_handler_id = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">rcParams[</span><span class="s3">'toolbar'</span><span class="s1">] != </span><span class="s3">'toolmanager'</span><span class="s1">:</span>
            <span class="s1">self.key_press_handler_id = self.canvas.mpl_connect(</span>
                <span class="s3">'key_press_event'</span><span class="s2">, </span><span class="s1">key_press_handler)</span>
            <span class="s1">self.button_press_handler_id = self.canvas.mpl_connect(</span>
                <span class="s3">'button_press_event'</span><span class="s2">, </span><span class="s1">button_press_handler)</span>

        <span class="s1">self.toolmanager = (ToolManager(canvas.figure)</span>
                            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'toolbar'</span><span class="s1">] == </span><span class="s3">'toolmanager'</span>
                            <span class="s2">else None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(mpl.rcParams[</span><span class="s3">&quot;toolbar&quot;</span><span class="s1">] == </span><span class="s3">&quot;toolbar2&quot;</span>
                <span class="s2">and </span><span class="s1">self._toolbar2_class):</span>
            <span class="s1">self.toolbar = self._toolbar2_class(self.canvas)</span>
        <span class="s2">elif </span><span class="s1">(mpl.rcParams[</span><span class="s3">&quot;toolbar&quot;</span><span class="s1">] == </span><span class="s3">&quot;toolmanager&quot;</span>
                <span class="s2">and </span><span class="s1">self._toolmanager_toolbar_class):</span>
            <span class="s1">self.toolbar = self._toolmanager_toolbar_class(self.toolmanager)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.toolbar = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.toolmanager:</span>
            <span class="s1">tools.add_tools_to_manager(self.toolmanager)</span>
            <span class="s2">if </span><span class="s1">self.toolbar:</span>
                <span class="s1">tools.add_tools_to_container(self.toolbar)</span>

        <span class="s1">@self.canvas.figure.add_axobserver</span>
        <span class="s2">def </span><span class="s1">notify_axes_change(fig):</span>
            <span class="s4"># Called whenever the current Axes is changed.</span>
            <span class="s2">if </span><span class="s1">self.toolmanager </span><span class="s2">is None and </span><span class="s1">self.toolbar </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.toolbar.update()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">create_with_canvas(cls</span><span class="s2">, </span><span class="s1">canvas_class</span><span class="s2">, </span><span class="s1">figure</span><span class="s2">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a manager for a given *figure* using a specific *canvas_class*. 
 
        Backends should override this method if they have specific needs for 
        setting up the canvas or the manager. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls(canvas_class(figure)</span><span class="s2">, </span><span class="s1">num)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">start_main_loop(cls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Start the main event loop. 
 
        This method is called by `.FigureManagerBase.pyplot_show`, which is the 
        implementation of `.pyplot.show`.  To customize the behavior of 
        `.pyplot.show`, interactive backends should usually override 
        `~.FigureManagerBase.start_main_loop`; if more customized logic is 
        necessary, `~.FigureManagerBase.pyplot_show` can also be overridden. 
        &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">pyplot_show(cls</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">block=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Show all figures.  This method is the implementation of `.pyplot.show`. 
 
        To customize the behavior of `.pyplot.show`, interactive backends 
        should usually override `~.FigureManagerBase.start_main_loop`; if more 
        customized logic is necessary, `~.FigureManagerBase.pyplot_show` can 
        also be overridden. 
 
        Parameters 
        ---------- 
        block : bool, optional 
            Whether to block by calling ``start_main_loop``.  The default, 
            None, means to block if we are neither in IPython's ``%pylab`` mode 
            nor in ``interactive`` mode. 
        &quot;&quot;&quot;</span>
        <span class="s1">managers = Gcf.get_all_fig_managers()</span>
        <span class="s2">if not </span><span class="s1">managers:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">manager </span><span class="s2">in </span><span class="s1">managers:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">manager.show()  </span><span class="s4"># Emits a warning for non-interactive backend.</span>
            <span class="s2">except </span><span class="s1">NonGuiException </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">_api.warn_external(str(exc))</span>
        <span class="s2">if </span><span class="s1">block </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython</span>
            <span class="s4"># (&gt;= 0.10) tacks a _needmain attribute onto pyplot.show (always</span>
            <span class="s4"># set to False).</span>
            <span class="s1">ipython_pylab = hasattr(</span>
                <span class="s1">getattr(sys.modules.get(</span><span class="s3">&quot;pyplot&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;show&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;_needmain&quot;</span><span class="s1">)</span>
            <span class="s1">block = </span><span class="s2">not </span><span class="s1">ipython_pylab </span><span class="s2">and not </span><span class="s1">is_interactive()</span>
        <span class="s2">if </span><span class="s1">block:</span>
            <span class="s1">cls.start_main_loop()</span>

    <span class="s2">def </span><span class="s1">show(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        For GUI backends, show the figure window and redraw. 
        For non-GUI backends, raise an exception, unless running headless (i.e. 
        on Linux with an unset DISPLAY); this exception is converted to a 
        warning in `.Figure.show`. 
        &quot;&quot;&quot;</span>
        <span class="s4"># This should be overridden in GUI backends.</span>
        <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s3">&quot;linux&quot; </span><span class="s2">and not </span><span class="s1">os.environ.get(</span><span class="s3">&quot;DISPLAY&quot;</span><span class="s1">):</span>
            <span class="s4"># We cannot check _get_running_interactive_framework() ==</span>
            <span class="s4"># &quot;headless&quot; because that would also suppress the warning when</span>
            <span class="s4"># $DISPLAY exists but is invalid, which is more likely an error and</span>
            <span class="s4"># thus warrants a warning.</span>
            <span class="s2">return</span>
        <span class="s2">raise </span><span class="s1">NonGuiException(</span>
            <span class="s3">f&quot;Matplotlib is currently using </span><span class="s2">{</span><span class="s1">get_backend()</span><span class="s2">}</span><span class="s3">, which is a &quot;</span>
            <span class="s3">f&quot;non-GUI backend, so cannot show the figure.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">destroy(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">full_screen_toggle(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">resize(self</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h):</span>
        <span class="s0">&quot;&quot;&quot;For GUI backends, resize the window (in physical pixels).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_window_title(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the title text of the window containing the figure, or None 
        if there is no window (e.g., a PS backend). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s3">'image'</span>

    <span class="s2">def </span><span class="s1">set_window_title(self</span><span class="s2">, </span><span class="s1">title):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the title text of the window containing the figure. 
 
        This has no effect for non-GUI (e.g., PS) backends. 
        &quot;&quot;&quot;</span>


<span class="s1">cursors = tools.cursors</span>


<span class="s2">class </span><span class="s1">_Mode(str</span><span class="s2">, </span><span class="s1">Enum):</span>
    <span class="s1">NONE = </span><span class="s3">&quot;&quot;</span>
    <span class="s1">PAN = </span><span class="s3">&quot;pan/zoom&quot;</span>
    <span class="s1">ZOOM = </span><span class="s3">&quot;zoom rect&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_navigate_mode(self):</span>
        <span class="s2">return </span><span class="s1">self.name </span><span class="s2">if </span><span class="s1">self </span><span class="s2">is not </span><span class="s1">_Mode.NONE </span><span class="s2">else None</span>


<span class="s2">class </span><span class="s1">NavigationToolbar2:</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for the navigation cursor, version 2. 
 
    Backends must implement a canvas that handles connections for 
    'button_press_event' and 'button_release_event'.  See 
    :meth:`FigureCanvasBase.mpl_connect` for more information. 
 
    They must also define 
 
      :meth:`save_figure` 
         save the current figure 
 
      :meth:`draw_rubberband` (optional) 
         draw the zoom to rect &quot;rubberband&quot; rectangle 
 
      :meth:`set_message` (optional) 
         display message 
 
      :meth:`set_history_buttons` (optional) 
         you can change the history back / forward buttons to 
         indicate disabled / enabled state. 
 
    and override ``__init__`` to set up the toolbar -- without forgetting to 
    call the base-class init.  Typically, ``__init__`` needs to set up toolbar 
    buttons connected to the `home`, `back`, `forward`, `pan`, `zoom`, and 
    `save_figure` methods and using standard icons in the &quot;images&quot; subdirectory 
    of the data path. 
 
    That's it, we'll do the rest! 
    &quot;&quot;&quot;</span>

    <span class="s4"># list of toolitems to add to the toolbar, format is:</span>
    <span class="s4"># (</span>
    <span class="s4">#   text, # the text of the button (often not visible to users)</span>
    <span class="s4">#   tooltip_text, # the tooltip shown on hover (where possible)</span>
    <span class="s4">#   image_file, # name of the image for the button (without the extension)</span>
    <span class="s4">#   name_of_method, # name of the method in NavigationToolbar2 to call</span>
    <span class="s4"># )</span>
    <span class="s1">toolitems = (</span>
        <span class="s1">(</span><span class="s3">'Home'</span><span class="s2">, </span><span class="s3">'Reset original view'</span><span class="s2">, </span><span class="s3">'home'</span><span class="s2">, </span><span class="s3">'home'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Back'</span><span class="s2">, </span><span class="s3">'Back to previous view'</span><span class="s2">, </span><span class="s3">'back'</span><span class="s2">, </span><span class="s3">'back'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Forward'</span><span class="s2">, </span><span class="s3">'Forward to next view'</span><span class="s2">, </span><span class="s3">'forward'</span><span class="s2">, </span><span class="s3">'forward'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s2">None, None, None, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Pan'</span><span class="s2">,</span>
         <span class="s3">'Left button pans, Right button zooms</span><span class="s2">\n</span><span class="s3">'</span>
         <span class="s3">'x/y fixes axis, CTRL fixes aspect'</span><span class="s2">,</span>
         <span class="s3">'move'</span><span class="s2">, </span><span class="s3">'pan'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Zoom'</span><span class="s2">, </span><span class="s3">'Zoom to rectangle</span><span class="s2">\n</span><span class="s3">x/y fixes axis'</span><span class="s2">, </span><span class="s3">'zoom_to_rect'</span><span class="s2">, </span><span class="s3">'zoom'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Subplots'</span><span class="s2">, </span><span class="s3">'Configure subplots'</span><span class="s2">, </span><span class="s3">'subplots'</span><span class="s2">, </span><span class="s3">'configure_subplots'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s2">None, None, None, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">'Save'</span><span class="s2">, </span><span class="s3">'Save the figure'</span><span class="s2">, </span><span class="s3">'filesave'</span><span class="s2">, </span><span class="s3">'save_figure'</span><span class="s1">)</span><span class="s2">,</span>
      <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">canvas):</span>
        <span class="s1">self.canvas = canvas</span>
        <span class="s1">canvas.toolbar = self</span>
        <span class="s1">self._nav_stack = cbook.Stack()</span>
        <span class="s4"># This cursor will be set after the initial draw.</span>
        <span class="s1">self._last_cursor = tools.Cursors.POINTER</span>

        <span class="s1">self._id_press = self.canvas.mpl_connect(</span>
            <span class="s3">'button_press_event'</span><span class="s2">, </span><span class="s1">self._zoom_pan_handler)</span>
        <span class="s1">self._id_release = self.canvas.mpl_connect(</span>
            <span class="s3">'button_release_event'</span><span class="s2">, </span><span class="s1">self._zoom_pan_handler)</span>
        <span class="s1">self._id_drag = self.canvas.mpl_connect(</span>
            <span class="s3">'motion_notify_event'</span><span class="s2">, </span><span class="s1">self.mouse_move)</span>
        <span class="s1">self._pan_info = </span><span class="s2">None</span>
        <span class="s1">self._zoom_info = </span><span class="s2">None</span>

        <span class="s1">self.mode = _Mode.NONE  </span><span class="s4"># a mode string for the status bar</span>
        <span class="s1">self.set_history_buttons()</span>

    <span class="s2">def </span><span class="s1">set_message(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot;Display a message on toolbar or in status bar.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">draw_rubberband(self</span><span class="s2">, </span><span class="s1">event</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a rectangle rubberband to indicate zoom limits. 
 
        Note that it is not guaranteed that ``x0 &lt;= x1`` and ``y0 &lt;= y1``. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">remove_rubberband(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove the rubberband.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">home(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Restore the original view. 
 
        For convenience of being directly connected as a GUI callback, which 
        often get passed additional parameters, this method accepts arbitrary 
        parameters, but does not use them. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._nav_stack.home()</span>
        <span class="s1">self.set_history_buttons()</span>
        <span class="s1">self._update_view()</span>

    <span class="s2">def </span><span class="s1">back(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move back up the view lim stack. 
 
        For convenience of being directly connected as a GUI callback, which 
        often get passed additional parameters, this method accepts arbitrary 
        parameters, but does not use them. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._nav_stack.back()</span>
        <span class="s1">self.set_history_buttons()</span>
        <span class="s1">self._update_view()</span>

    <span class="s2">def </span><span class="s1">forward(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move forward in the view lim stack. 
 
        For convenience of being directly connected as a GUI callback, which 
        often get passed additional parameters, this method accepts arbitrary 
        parameters, but does not use them. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._nav_stack.forward()</span>
        <span class="s1">self.set_history_buttons()</span>
        <span class="s1">self._update_view()</span>

    <span class="s2">def </span><span class="s1">_update_cursor(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the cursor after a mouse move event or a tool (de)activation. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.mode </span><span class="s2">and </span><span class="s1">event.inaxes </span><span class="s2">and </span><span class="s1">event.inaxes.get_navigate():</span>
            <span class="s2">if </span><span class="s1">(self.mode == _Mode.ZOOM</span>
                    <span class="s2">and </span><span class="s1">self._last_cursor != tools.Cursors.SELECT_REGION):</span>
                <span class="s1">self.canvas.set_cursor(tools.Cursors.SELECT_REGION)</span>
                <span class="s1">self._last_cursor = tools.Cursors.SELECT_REGION</span>
            <span class="s2">elif </span><span class="s1">(self.mode == _Mode.PAN</span>
                  <span class="s2">and </span><span class="s1">self._last_cursor != tools.Cursors.MOVE):</span>
                <span class="s1">self.canvas.set_cursor(tools.Cursors.MOVE)</span>
                <span class="s1">self._last_cursor = tools.Cursors.MOVE</span>
        <span class="s2">elif </span><span class="s1">self._last_cursor != tools.Cursors.POINTER:</span>
            <span class="s1">self.canvas.set_cursor(tools.Cursors.POINTER)</span>
            <span class="s1">self._last_cursor = tools.Cursors.POINTER</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">_wait_cursor_for_draw_cm(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the cursor to a wait cursor when drawing the canvas. 
 
        In order to avoid constantly changing the cursor when the canvas 
        changes frequently, do nothing if this context was triggered during the 
        last second.  (Optimally we'd prefer only setting the wait cursor if 
        the *current* draw takes too long, but the current draw blocks the GUI 
        thread). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._draw_time</span><span class="s2">, </span><span class="s1">last_draw_time = (</span>
            <span class="s1">time.time()</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s3">&quot;_draw_time&quot;</span><span class="s2">, </span><span class="s1">-np.inf))</span>
        <span class="s2">if </span><span class="s1">self._draw_time - last_draw_time &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.canvas.set_cursor(tools.Cursors.WAIT)</span>
                <span class="s2">yield</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">self.canvas.set_cursor(self._last_cursor)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_mouse_event_to_message(event):</span>
        <span class="s2">if </span><span class="s1">event.inaxes </span><span class="s2">and </span><span class="s1">event.inaxes.get_navigate():</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">s = event.inaxes.format_coord(event.xdata</span><span class="s2">, </span><span class="s1">event.ydata)</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">s = s.rstrip()</span>
                <span class="s1">artists = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">event.inaxes._mouseover_set</span>
                           <span class="s2">if </span><span class="s1">a.contains(event)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">and </span><span class="s1">a.get_visible()]</span>
                <span class="s2">if </span><span class="s1">artists:</span>
                    <span class="s1">a = cbook._topmost_artist(artists)</span>
                    <span class="s2">if </span><span class="s1">a </span><span class="s2">is not </span><span class="s1">event.inaxes.patch:</span>
                        <span class="s1">data = a.get_cursor_data(event)</span>
                        <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s1">data_str = a.format_cursor_data(data).rstrip()</span>
                            <span class="s2">if </span><span class="s1">data_str:</span>
                                <span class="s1">s = s + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ data_str</span>
                <span class="s2">return </span><span class="s1">s</span>
        <span class="s2">return </span><span class="s3">&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">mouse_move(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s1">self._update_cursor(event)</span>
        <span class="s1">self.set_message(self._mouse_event_to_message(event))</span>

    <span class="s2">def </span><span class="s1">_zoom_pan_handler(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s2">if </span><span class="s1">self.mode == _Mode.PAN:</span>
            <span class="s2">if </span><span class="s1">event.name == </span><span class="s3">&quot;button_press_event&quot;</span><span class="s1">:</span>
                <span class="s1">self.press_pan(event)</span>
            <span class="s2">elif </span><span class="s1">event.name == </span><span class="s3">&quot;button_release_event&quot;</span><span class="s1">:</span>
                <span class="s1">self.release_pan(event)</span>
        <span class="s2">if </span><span class="s1">self.mode == _Mode.ZOOM:</span>
            <span class="s2">if </span><span class="s1">event.name == </span><span class="s3">&quot;button_press_event&quot;</span><span class="s1">:</span>
                <span class="s1">self.press_zoom(event)</span>
            <span class="s2">elif </span><span class="s1">event.name == </span><span class="s3">&quot;button_release_event&quot;</span><span class="s1">:</span>
                <span class="s1">self.release_zoom(event)</span>

    <span class="s2">def </span><span class="s1">pan(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Toggle the pan/zoom tool. 
 
        Pan with left button, zoom with right. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.canvas.widgetlock.available(self):</span>
            <span class="s1">self.set_message(</span><span class="s3">&quot;pan unavailable&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self.mode == _Mode.PAN:</span>
            <span class="s1">self.mode = _Mode.NONE</span>
            <span class="s1">self.canvas.widgetlock.release(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mode = _Mode.PAN</span>
            <span class="s1">self.canvas.widgetlock(self)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.canvas.figure.get_axes():</span>
            <span class="s1">a.set_navigate_mode(self.mode._navigate_mode)</span>

    <span class="s1">_PanInfo = namedtuple(</span><span class="s3">&quot;_PanInfo&quot;</span><span class="s2">, </span><span class="s3">&quot;button axes cid&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">press_pan(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for mouse button press in pan/zoom mode.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(event.button </span><span class="s2">not in </span><span class="s1">[MouseButton.LEFT</span><span class="s2">, </span><span class="s1">MouseButton.RIGHT]</span>
                <span class="s2">or </span><span class="s1">event.x </span><span class="s2">is None or </span><span class="s1">event.y </span><span class="s2">is None</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">axes = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.canvas.figure.get_axes()</span>
                <span class="s2">if </span><span class="s1">a.in_axes(event) </span><span class="s2">and </span><span class="s1">a.get_navigate() </span><span class="s2">and </span><span class="s1">a.can_pan()]</span>
        <span class="s2">if not </span><span class="s1">axes:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self._nav_stack() </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.push_current()  </span><span class="s4"># set the home button to this view</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axes:</span>
            <span class="s1">ax.start_pan(event.x</span><span class="s2">, </span><span class="s1">event.y</span><span class="s2">, </span><span class="s1">event.button)</span>
        <span class="s1">self.canvas.mpl_disconnect(self._id_drag)</span>
        <span class="s1">id_drag = self.canvas.mpl_connect(</span><span class="s3">&quot;motion_notify_event&quot;</span><span class="s2">, </span><span class="s1">self.drag_pan)</span>
        <span class="s1">self._pan_info = self._PanInfo(</span>
            <span class="s1">button=event.button</span><span class="s2">, </span><span class="s1">axes=axes</span><span class="s2">, </span><span class="s1">cid=id_drag)</span>

    <span class="s2">def </span><span class="s1">drag_pan(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for dragging in pan/zoom mode.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._pan_info.axes:</span>
            <span class="s4"># Using the recorded button at the press is safer than the current</span>
            <span class="s4"># button, as multiple buttons can get pressed during motion.</span>
            <span class="s1">ax.drag_pan(self._pan_info.button</span><span class="s2">, </span><span class="s1">event.key</span><span class="s2">, </span><span class="s1">event.x</span><span class="s2">, </span><span class="s1">event.y)</span>
        <span class="s1">self.canvas.draw_idle()</span>

    <span class="s2">def </span><span class="s1">release_pan(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for mouse button release in pan/zoom mode.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._pan_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">self.canvas.mpl_disconnect(self._pan_info.cid)</span>
        <span class="s1">self._id_drag = self.canvas.mpl_connect(</span>
            <span class="s3">'motion_notify_event'</span><span class="s2">, </span><span class="s1">self.mouse_move)</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self._pan_info.axes:</span>
            <span class="s1">ax.end_pan()</span>
        <span class="s1">self.canvas.draw_idle()</span>
        <span class="s1">self._pan_info = </span><span class="s2">None</span>
        <span class="s1">self.push_current()</span>

    <span class="s2">def </span><span class="s1">zoom(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">if not </span><span class="s1">self.canvas.widgetlock.available(self):</span>
            <span class="s1">self.set_message(</span><span class="s3">&quot;zoom unavailable&quot;</span><span class="s1">)</span>
            <span class="s2">return</span>
        <span class="s3">&quot;&quot;&quot;Toggle zoom to rect mode.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.mode == _Mode.ZOOM:</span>
            <span class="s1">self.mode = _Mode.NONE</span>
            <span class="s1">self.canvas.widgetlock.release(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.mode = _Mode.ZOOM</span>
            <span class="s1">self.canvas.widgetlock(self)</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.canvas.figure.get_axes():</span>
            <span class="s1">a.set_navigate_mode(self.mode._navigate_mode)</span>

    <span class="s1">_ZoomInfo = namedtuple(</span><span class="s3">&quot;_ZoomInfo&quot;</span><span class="s2">, </span><span class="s3">&quot;direction start_xy axes cid cbar&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">press_zoom(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for mouse button press in zoom to rect mode.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(event.button </span><span class="s2">not in </span><span class="s1">[MouseButton.LEFT</span><span class="s2">, </span><span class="s1">MouseButton.RIGHT]</span>
                <span class="s2">or </span><span class="s1">event.x </span><span class="s2">is None or </span><span class="s1">event.y </span><span class="s2">is None</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">axes = [a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.canvas.figure.get_axes()</span>
                <span class="s2">if </span><span class="s1">a.in_axes(event) </span><span class="s2">and </span><span class="s1">a.get_navigate() </span><span class="s2">and </span><span class="s1">a.can_zoom()]</span>
        <span class="s2">if not </span><span class="s1">axes:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self._nav_stack() </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.push_current()  </span><span class="s4"># set the home button to this view</span>
        <span class="s1">id_zoom = self.canvas.mpl_connect(</span>
            <span class="s3">&quot;motion_notify_event&quot;</span><span class="s2">, </span><span class="s1">self.drag_zoom)</span>
        <span class="s4"># A colorbar is one-dimensional, so we extend the zoom rectangle out</span>
        <span class="s4"># to the edge of the Axes bbox in the other dimension. To do that we</span>
        <span class="s4"># store the orientation of the colorbar for later.</span>
        <span class="s2">if </span><span class="s1">hasattr(axes[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;_colorbar&quot;</span><span class="s1">):</span>
            <span class="s1">cbar = axes[</span><span class="s5">0</span><span class="s1">]._colorbar.orientation</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cbar = </span><span class="s2">None</span>
        <span class="s1">self._zoom_info = self._ZoomInfo(</span>
            <span class="s1">direction=</span><span class="s3">&quot;in&quot; </span><span class="s2">if </span><span class="s1">event.button == </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">&quot;out&quot;</span><span class="s2">,</span>
            <span class="s1">start_xy=(event.x</span><span class="s2">, </span><span class="s1">event.y)</span><span class="s2">, </span><span class="s1">axes=axes</span><span class="s2">, </span><span class="s1">cid=id_zoom</span><span class="s2">, </span><span class="s1">cbar=cbar)</span>

    <span class="s2">def </span><span class="s1">drag_zoom(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for dragging in zoom mode.&quot;&quot;&quot;</span>
        <span class="s1">start_xy = self._zoom_info.start_xy</span>
        <span class="s1">ax = self._zoom_info.axes[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2) = np.clip(</span>
            <span class="s1">[start_xy</span><span class="s2">, </span><span class="s1">[event.x</span><span class="s2">, </span><span class="s1">event.y]]</span><span class="s2">, </span><span class="s1">ax.bbox.min</span><span class="s2">, </span><span class="s1">ax.bbox.max)</span>
        <span class="s1">key = event.key</span>
        <span class="s4"># Force the key on colorbars to extend the short-axis bbox</span>
        <span class="s2">if </span><span class="s1">self._zoom_info.cbar == </span><span class="s3">&quot;horizontal&quot;</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s3">&quot;x&quot;</span>
        <span class="s2">elif </span><span class="s1">self._zoom_info.cbar == </span><span class="s3">&quot;vertical&quot;</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s3">&quot;y&quot;</span>
        <span class="s2">if </span><span class="s1">key == </span><span class="s3">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">y1</span><span class="s2">, </span><span class="s1">y2 = ax.bbox.intervaly</span>
        <span class="s2">elif </span><span class="s1">key == </span><span class="s3">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2 = ax.bbox.intervalx</span>

        <span class="s1">self.draw_rubberband(event</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2)</span>

    <span class="s2">def </span><span class="s1">release_zoom(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot;Callback for mouse button release in zoom to rect mode.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._zoom_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s4"># We don't check the event button here, so that zooms can be cancelled</span>
        <span class="s4"># by (pressing and) releasing another mouse button.</span>
        <span class="s1">self.canvas.mpl_disconnect(self._zoom_info.cid)</span>
        <span class="s1">self.remove_rubberband()</span>

        <span class="s1">start_x</span><span class="s2">, </span><span class="s1">start_y = self._zoom_info.start_xy</span>
        <span class="s1">key = event.key</span>
        <span class="s4"># Force the key on colorbars to ignore the zoom-cancel on the</span>
        <span class="s4"># short-axis side</span>
        <span class="s2">if </span><span class="s1">self._zoom_info.cbar == </span><span class="s3">&quot;horizontal&quot;</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s3">&quot;x&quot;</span>
        <span class="s2">elif </span><span class="s1">self._zoom_info.cbar == </span><span class="s3">&quot;vertical&quot;</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s3">&quot;y&quot;</span>
        <span class="s4"># Ignore single clicks: 5 pixels is a threshold that allows the user to</span>
        <span class="s4"># &quot;cancel&quot; a zoom action by zooming by less than 5 pixels.</span>
        <span class="s2">if </span><span class="s1">((abs(event.x - start_x) &lt; </span><span class="s5">5 </span><span class="s2">and </span><span class="s1">key != </span><span class="s3">&quot;y&quot;</span><span class="s1">) </span><span class="s2">or</span>
                <span class="s1">(abs(event.y - start_y) &lt; </span><span class="s5">5 </span><span class="s2">and </span><span class="s1">key != </span><span class="s3">&quot;x&quot;</span><span class="s1">)):</span>
            <span class="s1">self.canvas.draw_idle()</span>
            <span class="s1">self._zoom_info = </span><span class="s2">None</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">enumerate(self._zoom_info.axes):</span>
            <span class="s4"># Detect whether this Axes is twinned with an earlier Axes in the</span>
            <span class="s4"># list of zoomed Axes, to avoid double zooming.</span>
            <span class="s1">twinx = any(ax.get_shared_x_axes().joined(ax</span><span class="s2">, </span><span class="s1">prev)</span>
                        <span class="s2">for </span><span class="s1">prev </span><span class="s2">in </span><span class="s1">self._zoom_info.axes[:i])</span>
            <span class="s1">twiny = any(ax.get_shared_y_axes().joined(ax</span><span class="s2">, </span><span class="s1">prev)</span>
                        <span class="s2">for </span><span class="s1">prev </span><span class="s2">in </span><span class="s1">self._zoom_info.axes[:i])</span>
            <span class="s1">ax._set_view_from_bbox(</span>
                <span class="s1">(start_x</span><span class="s2">, </span><span class="s1">start_y</span><span class="s2">, </span><span class="s1">event.x</span><span class="s2">, </span><span class="s1">event.y)</span><span class="s2">,</span>
                <span class="s1">self._zoom_info.direction</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">twinx</span><span class="s2">, </span><span class="s1">twiny)</span>

        <span class="s1">self.canvas.draw_idle()</span>
        <span class="s1">self._zoom_info = </span><span class="s2">None</span>
        <span class="s1">self.push_current()</span>

    <span class="s2">def </span><span class="s1">push_current(self):</span>
        <span class="s0">&quot;&quot;&quot;Push the current view limits and position onto the stack.&quot;&quot;&quot;</span>
        <span class="s1">self._nav_stack.push(</span>
            <span class="s1">WeakKeyDictionary(</span>
                <span class="s1">{ax: (ax._get_view()</span><span class="s2">,</span>
                      <span class="s4"># Store both the original and modified positions.</span>
                      <span class="s1">(ax.get_position(</span><span class="s2">True</span><span class="s1">).frozen()</span><span class="s2">,</span>
                       <span class="s1">ax.get_position().frozen()))</span>
                 <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.canvas.figure.axes}))</span>
        <span class="s1">self.set_history_buttons()</span>

    <span class="s2">def </span><span class="s1">_update_view(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the viewlim and position from the view and position stack for 
        each Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">nav_info = self._nav_stack()</span>
        <span class="s2">if </span><span class="s1">nav_info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s4"># Retrieve all items at once to avoid any risk of GC deleting an Axes</span>
        <span class="s4"># while in the middle of the loop below.</span>
        <span class="s1">items = list(nav_info.items())</span>
        <span class="s2">for </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">(view</span><span class="s2">, </span><span class="s1">(pos_orig</span><span class="s2">, </span><span class="s1">pos_active)) </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s1">ax._set_view(view)</span>
            <span class="s4"># Restore both the original and modified positions</span>
            <span class="s1">ax._set_position(pos_orig</span><span class="s2">, </span><span class="s3">'original'</span><span class="s1">)</span>
            <span class="s1">ax._set_position(pos_active</span><span class="s2">, </span><span class="s3">'active'</span><span class="s1">)</span>
        <span class="s1">self.canvas.draw_idle()</span>

    <span class="s2">def </span><span class="s1">configure_subplots(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;subplot_tool&quot;</span><span class="s1">):</span>
            <span class="s1">self.subplot_tool.figure.canvas.manager.show()</span>
            <span class="s2">return</span>
        <span class="s4"># This import needs to happen here due to circular imports.</span>
        <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
        <span class="s2">with </span><span class="s1">mpl.rc_context({</span><span class="s3">&quot;toolbar&quot;</span><span class="s1">: </span><span class="s3">&quot;none&quot;</span><span class="s1">}):  </span><span class="s4"># No navbar for the toolfig.</span>
            <span class="s1">manager = type(self.canvas).new_manager(Figure(figsize=(</span><span class="s5">6</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">manager.set_window_title(</span><span class="s3">&quot;Subplot configuration tool&quot;</span><span class="s1">)</span>
        <span class="s1">tool_fig = manager.canvas.figure</span>
        <span class="s1">tool_fig.subplots_adjust(top=</span><span class="s5">0.9</span><span class="s1">)</span>
        <span class="s1">self.subplot_tool = widgets.SubplotTool(self.canvas.figure</span><span class="s2">, </span><span class="s1">tool_fig)</span>
        <span class="s1">cid = self.canvas.mpl_connect(</span>
            <span class="s3">&quot;close_event&quot;</span><span class="s2">, lambda </span><span class="s1">e: manager.destroy())</span>

        <span class="s2">def </span><span class="s1">on_tool_fig_close(e):</span>
            <span class="s1">self.canvas.mpl_disconnect(cid)</span>
            <span class="s2">del </span><span class="s1">self.subplot_tool</span>

        <span class="s1">tool_fig.canvas.mpl_connect(</span><span class="s3">&quot;close_event&quot;</span><span class="s2">, </span><span class="s1">on_tool_fig_close)</span>
        <span class="s1">manager.show()</span>
        <span class="s2">return </span><span class="s1">self.subplot_tool</span>

    <span class="s2">def </span><span class="s1">save_figure(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot;Save the current figure.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">update(self):</span>
        <span class="s0">&quot;&quot;&quot;Reset the Axes stack.&quot;&quot;&quot;</span>
        <span class="s1">self._nav_stack.clear()</span>
        <span class="s1">self.set_history_buttons()</span>

    <span class="s2">def </span><span class="s1">set_history_buttons(self):</span>
        <span class="s0">&quot;&quot;&quot;Enable or disable the back/forward button.&quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">ToolContainerBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for all tool containers, e.g. toolbars. 
 
    Attributes 
    ---------- 
    toolmanager : `.ToolManager` 
        The tools with which this `ToolContainer` wants to communicate. 
    &quot;&quot;&quot;</span>

    <span class="s1">_icon_extension = </span><span class="s3">'.png'</span>
    <span class="s3">&quot;&quot;&quot; 
    Toolcontainer button icon image format extension 
 
    **String**: Image extension 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">toolmanager):</span>
        <span class="s1">self.toolmanager = toolmanager</span>
        <span class="s1">toolmanager.toolmanager_connect(</span>
            <span class="s3">'tool_message_event'</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">event: self.set_message(event.message))</span>
        <span class="s1">toolmanager.toolmanager_connect(</span>
            <span class="s3">'tool_removed_event'</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">event: self.remove_toolitem(event.tool.name))</span>

    <span class="s2">def </span><span class="s1">_tool_toggled_cbk(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot; 
        Capture the 'tool_trigger_[name]' 
 
        This only gets used for toggled tools. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.toggle_toolitem(event.tool.name</span><span class="s2">, </span><span class="s1">event.tool.toggled)</span>

    <span class="s2">def </span><span class="s1">add_tool(self</span><span class="s2">, </span><span class="s1">tool</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">position=-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a tool to this container. 
 
        Parameters 
        ---------- 
        tool : tool_like 
            The tool to add, see `.ToolManager.get_tool`. 
        group : str 
            The name of the group to add this tool to. 
        position : int, default: -1 
            The position within the group to place this tool. 
        &quot;&quot;&quot;</span>
        <span class="s1">tool = self.toolmanager.get_tool(tool)</span>
        <span class="s1">image = self._get_image_filename(tool.image)</span>
        <span class="s1">toggle = getattr(tool</span><span class="s2">, </span><span class="s3">'toggled'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span>
        <span class="s1">self.add_toolitem(tool.name</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">position</span><span class="s2">,</span>
                          <span class="s1">image</span><span class="s2">, </span><span class="s1">tool.description</span><span class="s2">, </span><span class="s1">toggle)</span>
        <span class="s2">if </span><span class="s1">toggle:</span>
            <span class="s1">self.toolmanager.toolmanager_connect(</span><span class="s3">'tool_trigger_%s' </span><span class="s1">% tool.name</span><span class="s2">,</span>
                                                 <span class="s1">self._tool_toggled_cbk)</span>
            <span class="s4"># If initially toggled</span>
            <span class="s2">if </span><span class="s1">tool.toggled:</span>
                <span class="s1">self.toggle_toolitem(tool.name</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_image_filename(self</span><span class="s2">, </span><span class="s1">image):</span>
        <span class="s0">&quot;&quot;&quot;Find the image based on its name.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">image:</span>
            <span class="s2">return None</span>

        <span class="s1">basedir = cbook._get_data_path(</span><span class="s3">&quot;images&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s1">image</span><span class="s2">,</span>
            <span class="s1">image + self._icon_extension</span><span class="s2">,</span>
            <span class="s1">str(basedir / image)</span><span class="s2">,</span>
            <span class="s1">str(basedir / (image + self._icon_extension))</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">os.path.isfile(fname):</span>
                <span class="s2">return </span><span class="s1">fname</span>

    <span class="s2">def </span><span class="s1">trigger_tool(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Trigger the tool. 
 
        Parameters 
        ---------- 
        name : str 
            Name (id) of the tool triggered from within the container. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.toolmanager.trigger_tool(name</span><span class="s2">, </span><span class="s1">sender=self)</span>

    <span class="s2">def </span><span class="s1">add_toolitem(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">group</span><span class="s2">, </span><span class="s1">position</span><span class="s2">, </span><span class="s1">image</span><span class="s2">, </span><span class="s1">description</span><span class="s2">, </span><span class="s1">toggle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a toolitem to the container. 
 
        This method must be implemented per backend. 
 
        The callback associated with the button click event, 
        must be *exactly* ``self.trigger_tool(name)``. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the tool to add, this gets used as the tool's ID and as the 
            default label of the buttons. 
        group : str 
            Name of the group that this tool belongs to. 
        position : int 
            Position of the tool within its group, if -1 it goes at the end. 
        image : str 
            Filename of the image for the button or `None`. 
        description : str 
            Description of the tool, used for the tooltips. 
        toggle : bool 
            * `True` : The button is a toggle (change the pressed/unpressed 
              state between consecutive clicks). 
            * `False` : The button is a normal button (returns to unpressed 
              state after release). 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">toggle_toolitem(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">toggled):</span>
        <span class="s0">&quot;&quot;&quot; 
        Toggle the toolitem without firing event. 
 
        Parameters 
        ---------- 
        name : str 
            Id of the tool to toggle. 
        toggled : bool 
            Whether to set this tool as toggled or not. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">remove_toolitem(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove a toolitem from the `ToolContainer`. 
 
        This method must get implemented per backend. 
 
        Called when `.ToolManager` emits a `tool_removed_event`. 
 
        Parameters 
        ---------- 
        name : str 
            Name of the tool to remove. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">set_message(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Display a message on the toolbar. 
 
        Parameters 
        ---------- 
        s : str 
            Message text. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>


<span class="s2">class </span><span class="s1">_Backend:</span>
    <span class="s4"># A backend can be defined by using the following pattern:</span>
    <span class="s4">#</span>
    <span class="s4"># @_Backend.export</span>
    <span class="s4"># class FooBackend(_Backend):</span>
    <span class="s4">#     # override the attributes and methods documented below.</span>

    <span class="s4"># `backend_version` may be overridden by the subclass.</span>
    <span class="s1">backend_version = </span><span class="s3">&quot;unknown&quot;</span>

    <span class="s4"># The `FigureCanvas` class must be defined.</span>
    <span class="s1">FigureCanvas = </span><span class="s2">None</span>

    <span class="s4"># For interactive backends, the `FigureManager` class must be overridden.</span>
    <span class="s1">FigureManager = FigureManagerBase</span>

    <span class="s4"># For interactive backends, `mainloop` should be a function taking no</span>
    <span class="s4"># argument and starting the backend main loop.  It should be left as None</span>
    <span class="s4"># for non-interactive backends.</span>
    <span class="s1">mainloop = </span><span class="s2">None</span>

    <span class="s4"># The following methods will be automatically defined and exported, but</span>
    <span class="s4"># can be overridden.</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">new_figure_manager(cls</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Create a new figure manager instance.&quot;&quot;&quot;</span>
        <span class="s4"># This import needs to happen here due to circular imports.</span>
        <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
        <span class="s1">fig_cls = kwargs.pop(</span><span class="s3">'FigureClass'</span><span class="s2">, </span><span class="s1">Figure)</span>
        <span class="s1">fig = fig_cls(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">cls.new_figure_manager_given_figure(num</span><span class="s2">, </span><span class="s1">fig)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">new_figure_manager_given_figure(cls</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">figure):</span>
        <span class="s0">&quot;&quot;&quot;Create a new figure manager instance for the given figure.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls.FigureCanvas.new_manager(figure</span><span class="s2">, </span><span class="s1">num)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">draw_if_interactive(cls):</span>
        <span class="s1">manager_class = cls.FigureCanvas.manager_class</span>
        <span class="s4"># Interactive backends reimplement start_main_loop or pyplot_show.</span>
        <span class="s1">backend_is_interactive = (</span>
            <span class="s1">manager_class.start_main_loop != FigureManagerBase.start_main_loop</span>
            <span class="s2">or </span><span class="s1">manager_class.pyplot_show != FigureManagerBase.pyplot_show)</span>
        <span class="s2">if </span><span class="s1">backend_is_interactive </span><span class="s2">and </span><span class="s1">is_interactive():</span>
            <span class="s1">manager = Gcf.get_active()</span>
            <span class="s2">if </span><span class="s1">manager:</span>
                <span class="s1">manager.canvas.draw_idle()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">show(cls</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">block=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Show all figures. 
 
        `show` blocks by calling `mainloop` if *block* is ``True``, or if it 
        is ``None`` and we are neither in IPython's ``%pylab`` mode, nor in 
        `interactive` mode. 
        &quot;&quot;&quot;</span>
        <span class="s1">managers = Gcf.get_all_fig_managers()</span>
        <span class="s2">if not </span><span class="s1">managers:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">manager </span><span class="s2">in </span><span class="s1">managers:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">manager.show()  </span><span class="s4"># Emits a warning for non-interactive backend.</span>
            <span class="s2">except </span><span class="s1">NonGuiException </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s1">_api.warn_external(str(exc))</span>
        <span class="s2">if </span><span class="s1">cls.mainloop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">block </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Hack: Are we in IPython's %pylab mode?  In pylab mode, IPython</span>
            <span class="s4"># (&gt;= 0.10) tacks a _needmain attribute onto pyplot.show (always</span>
            <span class="s4"># set to False).</span>
            <span class="s1">ipython_pylab = hasattr(</span>
                <span class="s1">getattr(sys.modules.get(</span><span class="s3">&quot;pyplot&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;show&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;_needmain&quot;</span><span class="s1">)</span>
            <span class="s1">block = </span><span class="s2">not </span><span class="s1">ipython_pylab </span><span class="s2">and not </span><span class="s1">is_interactive()</span>
        <span class="s2">if </span><span class="s1">block:</span>
            <span class="s1">cls.mainloop()</span>

    <span class="s4"># This method is the one actually exporting the required methods.</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">export(cls):</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s3">&quot;backend_version&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;FigureCanvas&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;FigureManager&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;new_figure_manager&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;new_figure_manager_given_figure&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;draw_if_interactive&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;show&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">setattr(sys.modules[cls.__module__]</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">getattr(cls</span><span class="s2">, </span><span class="s1">name))</span>

        <span class="s4"># For back-compatibility, generate a shim `Show` class.</span>

        <span class="s2">class </span><span class="s1">Show(ShowBase):</span>
            <span class="s2">def </span><span class="s1">mainloop(self):</span>
                <span class="s2">return </span><span class="s1">cls.mainloop()</span>

        <span class="s1">setattr(sys.modules[cls.__module__]</span><span class="s2">, </span><span class="s3">&quot;Show&quot;</span><span class="s2">, </span><span class="s1">Show)</span>
        <span class="s2">return </span><span class="s1">cls</span>


<span class="s2">class </span><span class="s1">ShowBase(_Backend):</span>
    <span class="s0">&quot;&quot;&quot; 
    Simple base class to generate a ``show()`` function in backends. 
 
    Subclass must override ``mainloop()`` method. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">block=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.show(block=block)</span>
</pre>
</body>
</html>