<html>
<head>
<title>offsetbox.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
offsetbox.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
Container classes for `.Artist`\s. 
 
`OffsetBox` 
    The base of all container artists defined in this module. 
 
`AnchoredOffsetbox`, `AnchoredText` 
    Anchor and align an arbitrary `.Artist` or a text relative to the parent 
    axes or a specific anchor point. 
 
`DrawingArea` 
    A container with fixed width and height. Children have a fixed position 
    inside the container and may be clipped. 
 
`HPacker`, `VPacker` 
    Containers for layouting their children vertically or horizontally. 
 
`PaddedBox` 
    A container to add a padding around an `.Artist`. 
 
`TextArea` 
    Contains a single `.Text` instance. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">import </span><span class="s1">matplotlib.path </span><span class="s2">as </span><span class="s1">mpath</span>
<span class="s2">import </span><span class="s1">matplotlib.text </span><span class="s2">as </span><span class="s1">mtext</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>
<span class="s2">from </span><span class="s1">matplotlib.font_manager </span><span class="s2">import </span><span class="s1">FontProperties</span>
<span class="s2">from </span><span class="s1">matplotlib.image </span><span class="s2">import </span><span class="s1">BboxImage</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FancyBboxPatch</span><span class="s2">, </span><span class="s1">FancyArrowPatch</span><span class="s2">, </span><span class="s1">bbox_artist </span><span class="s2">as </span><span class="s1">mbbox_artist)</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxBase</span><span class="s2">, </span><span class="s1">TransformedBbox</span>


<span class="s1">DEBUG = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_compat_get_offset(meth):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator for the get_offset method of OffsetBox and subclasses, that 
    allows supporting both the new signature (self, bbox, renderer) and the old 
    signature (self, width, height, xdescent, ydescent, renderer). 
    &quot;&quot;&quot;</span>
    <span class="s1">sigs = [</span><span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">renderer: locals()</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">renderer: locals()]</span>

    <span class="s1">@functools.wraps(meth)</span>
    <span class="s2">def </span><span class="s1">get_offset(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">params = _api.select_matching_signature(sigs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">bbox = (params[</span><span class="s3">&quot;bbox&quot;</span><span class="s1">] </span><span class="s2">if </span><span class="s3">&quot;bbox&quot; </span><span class="s2">in </span><span class="s1">params </span><span class="s2">else</span>
                <span class="s1">Bbox.from_bounds(-params[</span><span class="s3">&quot;xdescent&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-params[</span><span class="s3">&quot;ydescent&quot;</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">params[</span><span class="s3">&quot;width&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">&quot;height&quot;</span><span class="s1">]))</span>
        <span class="s2">return </span><span class="s1">meth(params[</span><span class="s3">&quot;self&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">params[</span><span class="s3">&quot;renderer&quot;</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">get_offset</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">'patches.bbox_artist'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">bbox_artist(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">if </span><span class="s1">DEBUG:</span>
        <span class="s1">mbbox_artist(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s4"># for debugging use</span>
<span class="s2">def </span><span class="s1">_bbox_artist(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s2">if </span><span class="s1">DEBUG:</span>
        <span class="s1">mbbox_artist(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">_get_packed_offsets(widths</span><span class="s2">, </span><span class="s1">total</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;fixed&quot;</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Pack boxes specified by their *widths*. 
 
    For simplicity of the description, the terminology used here assumes a 
    horizontal layout, but the function works equally for a vertical layout. 
 
    There are three packing *mode*\s: 
 
    - 'fixed': The elements are packed tight to the left with a spacing of 
      *sep* in between. If *total* is *None* the returned total will be the 
      right edge of the last box. A non-*None* total will be passed unchecked 
      to the output. In particular this means that right edge of the last 
      box may be further to the right than the returned total. 
 
    - 'expand': Distribute the boxes with equal spacing so that the left edge 
      of the first box is at 0, and the right edge of the last box is at 
      *total*. The parameter *sep* is ignored in this mode. A total of *None* 
      is accepted and considered equal to 1. The total is returned unchanged 
      (except for the conversion *None* to 1). If the total is smaller than 
      the sum of the widths, the laid out boxes will overlap. 
 
    - 'equal': If *total* is given, the total space is divided in N equal 
      ranges and each box is left-aligned within its subspace. 
      Otherwise (*total* is *None*), *sep* must be provided and each box is 
      left-aligned in its subspace of width ``(max(widths) + sep)``. The 
      total width is then calculated to be ``N * (max(widths) + sep)``. 
 
    Parameters 
    ---------- 
    widths : list of float 
        Widths of boxes to be packed. 
    total : float or None 
        Intended total length. *None* if not used. 
    sep : float 
        Spacing between boxes. 
    mode : {'fixed', 'expand', 'equal'} 
        The packing mode. 
 
    Returns 
    ------- 
    total : float 
        The total width needed to accommodate the laid out boxes. 
    offsets : array of float 
        The left offsets of the boxes. 
    &quot;&quot;&quot;</span>
    <span class="s1">_api.check_in_list([</span><span class="s3">&quot;fixed&quot;</span><span class="s2">, </span><span class="s3">&quot;expand&quot;</span><span class="s2">, </span><span class="s3">&quot;equal&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mode=mode)</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;fixed&quot;</span><span class="s1">:</span>
        <span class="s1">offsets_ = np.cumsum([</span><span class="s5">0</span><span class="s1">] + [w + sep </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">widths])</span>
        <span class="s1">offsets = offsets_[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">total </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">total = offsets_[-</span><span class="s5">1</span><span class="s1">] - sep</span>
        <span class="s2">return </span><span class="s1">total</span><span class="s2">, </span><span class="s1">offsets</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;expand&quot;</span><span class="s1">:</span>
        <span class="s4"># This is a bit of a hack to avoid a TypeError when *total*</span>
        <span class="s4"># is None and used in conjugation with tight layout.</span>
        <span class="s2">if </span><span class="s1">total </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">total = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">len(widths) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">sep = (total - sum(widths)) / (len(widths) - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sep = </span><span class="s5">0</span>
        <span class="s1">offsets_ = np.cumsum([</span><span class="s5">0</span><span class="s1">] + [w + sep </span><span class="s2">for </span><span class="s1">w </span><span class="s2">in </span><span class="s1">widths])</span>
        <span class="s1">offsets = offsets_[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">total</span><span class="s2">, </span><span class="s1">offsets</span>

    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;equal&quot;</span><span class="s1">:</span>
        <span class="s1">maxh = max(widths)</span>
        <span class="s2">if </span><span class="s1">total </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">sep </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;total and sep cannot both be None when &quot;</span>
                                 <span class="s3">&quot;using layout mode 'equal'&quot;</span><span class="s1">)</span>
            <span class="s1">total = (maxh + sep) * len(widths)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sep = total / len(widths) - maxh</span>
        <span class="s1">offsets = (maxh + sep) * np.arange(len(widths))</span>
        <span class="s2">return </span><span class="s1">total</span><span class="s2">, </span><span class="s1">offsets</span>


<span class="s2">def </span><span class="s1">_get_aligned_offsets(yspans</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">align=</span><span class="s3">&quot;baseline&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Align boxes each specified by their ``(y0, y1)`` spans. 
 
    For simplicity of the description, the terminology used here assumes a 
    horizontal layout (i.e., vertical alignment), but the function works 
    equally for a vertical layout. 
 
    Parameters 
    ---------- 
    yspans 
        List of (y0, y1) spans of boxes to be aligned. 
    height : float or None 
        Intended total height. If None, the maximum of the heights 
        (``y1 - y0``) in *yspans* is used. 
    align : {'baseline', 'left', 'top', 'right', 'bottom', 'center'} 
        The alignment anchor of the boxes. 
 
    Returns 
    ------- 
    (y0, y1) 
        y range spanned by the packing.  If a *height* was originally passed 
        in, then for all alignments other than &quot;baseline&quot;, a span of ``(0, 
        height)`` is used without checking that it is actually large enough). 
    descent 
        The descent of the packing. 
    offsets 
        The bottom offsets of the boxes. 
    &quot;&quot;&quot;</span>

    <span class="s1">_api.check_in_list(</span>
        <span class="s1">[</span><span class="s3">&quot;baseline&quot;</span><span class="s2">, </span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s2">, </span><span class="s3">&quot;center&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">align=align)</span>
    <span class="s2">if </span><span class="s1">height </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">height = max(y1 - y0 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans)</span>

    <span class="s2">if </span><span class="s1">align == </span><span class="s3">&quot;baseline&quot;</span><span class="s1">:</span>
        <span class="s1">yspan = (min(y0 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans)</span><span class="s2">, </span><span class="s1">max(y1 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans))</span>
        <span class="s1">offsets = [</span><span class="s5">0</span><span class="s1">] * len(yspans)</span>
    <span class="s2">elif </span><span class="s1">align </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">]:</span>
        <span class="s1">yspan = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">offsets = [-y0 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans]</span>
    <span class="s2">elif </span><span class="s1">align </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;top&quot;</span><span class="s1">]:</span>
        <span class="s1">yspan = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">offsets = [height - y1 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans]</span>
    <span class="s2">elif </span><span class="s1">align == </span><span class="s3">&quot;center&quot;</span><span class="s1">:</span>
        <span class="s1">yspan = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">offsets = [(height - (y1 - y0)) * </span><span class="s5">.5 </span><span class="s1">- y0 </span><span class="s2">for </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 </span><span class="s2">in </span><span class="s1">yspans]</span>

    <span class="s2">return </span><span class="s1">yspan</span><span class="s2">, </span><span class="s1">offsets</span>


<span class="s2">class </span><span class="s1">OffsetBox(martist.Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    The OffsetBox is a simple container artist. 
 
    The child artists are meant to be drawn at a relative position to its 
    parent. 
 
    Being an artist itself, all parameters are passed on to `.Artist`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args)</span>
        <span class="s1">self._internal_update(kwargs)</span>
        <span class="s4"># Clipping has not been implemented in the OffsetBox family, so</span>
        <span class="s4"># disable the clip flag for consistency. It can always be turned back</span>
        <span class="s4"># on to zero effect.</span>
        <span class="s1">self.set_clip_on(</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._children = []</span>
        <span class="s1">self._offset = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_figure(self</span><span class="s2">, </span><span class="s1">fig):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the `.Figure` for the `.OffsetBox` and all its children. 
 
        Parameters 
        ---------- 
        fig : `~matplotlib.figure.Figure` 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_figure(fig)</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s1">c.set_figure(fig)</span>

    <span class="s1">@martist.Artist.axes.setter</span>
    <span class="s2">def </span><span class="s1">axes(self</span><span class="s2">, </span><span class="s1">ax):</span>
        <span class="s4"># TODO deal with this better</span>
        <span class="s1">martist.Artist.axes.fset(self</span><span class="s2">, </span><span class="s1">ax)</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s2">if </span><span class="s1">c </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">c.axes = ax</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Delegate the mouse event contains-check to the children. 
 
        As a container, the `.OffsetBox` does not respond itself to 
        mouseevents. 
 
        Parameters 
        ---------- 
        mouseevent : `matplotlib.backend_bases.MouseEvent` 
 
        Returns 
        ------- 
        contains : bool 
            Whether any values are within the radius. 
        details : dict 
            An artist-specific dictionary of details of the event context, 
            such as which points are contained in the pick radius. See the 
            individual Artist subclasses for details. 
 
        See Also 
        -------- 
        .Artist.contains 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_children():</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b = c.contains(mouseevent)</span>
            <span class="s2">if </span><span class="s1">a:</span>
                <span class="s2">return </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span>
        <span class="s2">return False, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">set_offset(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offset. 
 
        Parameters 
        ---------- 
        xy : (float, float) or callable 
            The (x, y) coordinates of the offset in display units. These can 
            either be given explicitly as a tuple (x, y), or by providing a 
            function that converts the extent into the offset. This function 
            must have the signature:: 
 
                def offset(width, height, xdescent, ydescent, renderer) \ 
-&gt; (float, float) 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset = xy</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_compat_get_offset</span>
    <span class="s2">def </span><span class="s1">get_offset(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the offset as a tuple (x, y). 
 
        The extent parameters have to be provided to handle the case where the 
        offset is dynamically determined by a callable (see 
        `~.OffsetBox.set_offset`). 
 
        Parameters 
        ---------- 
        bbox : `.Bbox` 
        renderer : `.RendererBase` subclass 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._offset(bbox.width</span><span class="s2">, </span><span class="s1">bbox.height</span><span class="s2">, </span><span class="s1">-bbox.x0</span><span class="s2">, </span><span class="s1">-bbox.y0</span><span class="s2">, </span><span class="s1">renderer)</span>
            <span class="s2">if </span><span class="s1">callable(self._offset)</span>
            <span class="s2">else </span><span class="s1">self._offset)</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the width of the box. 
 
        Parameters 
        ---------- 
        width : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_height(self</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the height of the box. 
 
        Parameters 
        ---------- 
        height : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_visible_children(self):</span>
        <span class="s0">r&quot;&quot;&quot;Return a list of the visible child `.Artist`\s.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[c </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._children </span><span class="s2">if </span><span class="s1">c.get_visible()]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">r&quot;&quot;&quot;Return a list of the child `.Artist`\s.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._children</span>

    <span class="s2">def </span><span class="s1">_get_bbox_and_child_offsets(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the bbox of the offsetbox and the child offsets. 
 
        The bbox should satisfy ``x0 &lt;= x1 and y0 &lt;= y1``. 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass 
 
        Returns 
        ------- 
        bbox 
        list of (xoffset, yoffset) pairs 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s3">&quot;get_bbox_and_offsets must be overridden in derived classes&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Return the bbox of the offsetbox, ignoring parent offsets.&quot;&quot;&quot;</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">offsets = self._get_bbox_and_child_offsets(renderer)</span>
        <span class="s2">return </span><span class="s1">bbox</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_bbox and child.get_offset&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_extent_offsets(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update offset of the children and return the extent of the box. 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass 
 
        Returns 
        ------- 
        width 
        height 
        xdescent 
        ydescent 
        list of (xoffset, yoffset) pairs 
        &quot;&quot;&quot;</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">offsets = self._get_bbox_and_child_offsets(renderer)</span>
        <span class="s2">return </span><span class="s1">bbox.width</span><span class="s2">, </span><span class="s1">bbox.height</span><span class="s2">, </span><span class="s1">-bbox.x0</span><span class="s2">, </span><span class="s1">-bbox.y0</span><span class="s2">, </span><span class="s1">offsets</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_bbox&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_extent(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Return a tuple ``width, height, xdescent, ydescent`` of the box.&quot;&quot;&quot;</span>
        <span class="s1">bbox = self.get_bbox(renderer)</span>
        <span class="s2">return </span><span class="s1">bbox.width</span><span class="s2">, </span><span class="s1">bbox.height</span><span class="s2">, </span><span class="s1">-bbox.x0</span><span class="s2">, </span><span class="s1">-bbox.y0</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>
        <span class="s1">bbox = self.get_bbox(renderer)</span>
        <span class="s2">try</span><span class="s1">:  </span><span class="s4"># Some subclasses redefine get_offset to take no args.</span>
            <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset(bbox</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset()</span>
        <span class="s2">return </span><span class="s1">bbox.translated(px</span><span class="s2">, </span><span class="s1">py)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the location of children if necessary and draw them 
        to the given *renderer*. 
        &quot;&quot;&quot;</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">offsets = self._get_bbox_and_child_offsets(renderer)</span>
        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset(bbox</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">(ox</span><span class="s2">, </span><span class="s1">oy) </span><span class="s2">in </span><span class="s1">zip(self.get_visible_children()</span><span class="s2">, </span><span class="s1">offsets):</span>
            <span class="s1">c.set_offset((px + ox</span><span class="s2">, </span><span class="s1">py + oy))</span>
            <span class="s1">c.draw(renderer)</span>
        <span class="s1">_bbox_artist(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">False, </span><span class="s1">props=dict(pad=</span><span class="s5">0.</span><span class="s1">))</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">PackerBase(OffsetBox):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">sep=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">width=</span><span class="s2">None, </span><span class="s1">height=</span><span class="s2">None,</span>
                 <span class="s1">align=</span><span class="s3">&quot;baseline&quot;</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;fixed&quot;</span><span class="s2">, </span><span class="s1">children=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        pad : float, default: 0.0 
            The boundary padding in points. 
 
        sep : float, default: 0.0 
            The spacing between items in points. 
 
        width, height : float, optional 
            Width and height of the container box in pixels, calculated if 
            *None*. 
 
        align : {'top', 'bottom', 'left', 'right', 'center', 'baseline'}, \ 
default: 'baseline' 
            Alignment of boxes. 
 
        mode : {'fixed', 'expand', 'equal'}, default: 'fixed' 
            The packing mode. 
 
            - 'fixed' packs the given `.Artist`\\s tight with *sep* spacing. 
            - 'expand' uses the maximal available space to distribute the 
              artists with equal spacing in between. 
            - 'equal': Each artist an equal fraction of the available space 
              and is left-aligned (or top-aligned) therein. 
 
        children : list of `.Artist` 
            The artists to pack. 
 
        Notes 
        ----- 
        *pad* and *sep* are in points and will be scaled with the renderer 
        dpi, while *width* and *height* are in pixels. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.sep = sep</span>
        <span class="s1">self.pad = pad</span>
        <span class="s1">self.mode = mode</span>
        <span class="s1">self.align = align</span>
        <span class="s1">self._children = children</span>


<span class="s2">class </span><span class="s1">VPacker(PackerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    VPacker packs its children vertically, automatically adjusting their 
    relative positions at draw time. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_bbox_and_child_offsets(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">dpicor = renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">pad = self.pad * dpicor</span>
        <span class="s1">sep = self.sep * dpicor</span>

        <span class="s2">if </span><span class="s1">self.width </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_visible_children():</span>
                <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">PackerBase) </span><span class="s2">and </span><span class="s1">c.mode == </span><span class="s3">&quot;expand&quot;</span><span class="s1">:</span>
                    <span class="s1">c.set_width(self.width)</span>

        <span class="s1">bboxes = [c.get_bbox(renderer) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_visible_children()]</span>
        <span class="s1">(x0</span><span class="s2">, </span><span class="s1">x1)</span><span class="s2">, </span><span class="s1">xoffsets = _get_aligned_offsets(</span>
            <span class="s1">[bbox.intervalx </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes]</span><span class="s2">, </span><span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.align)</span>
        <span class="s1">height</span><span class="s2">, </span><span class="s1">yoffsets = _get_packed_offsets(</span>
            <span class="s1">[bbox.height </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes]</span><span class="s2">, </span><span class="s1">self.height</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">self.mode)</span>

        <span class="s1">yoffsets = height - (yoffsets + [bbox.y1 </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes])</span>
        <span class="s1">ydescent = yoffsets[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">yoffsets = yoffsets - ydescent</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">Bbox.from_bounds(x0</span><span class="s2">, </span><span class="s1">-ydescent</span><span class="s2">, </span><span class="s1">x1 - x0</span><span class="s2">, </span><span class="s1">height).padded(pad)</span><span class="s2">,</span>
            <span class="s1">[*zip(xoffsets</span><span class="s2">, </span><span class="s1">yoffsets)])</span>


<span class="s2">class </span><span class="s1">HPacker(PackerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    HPacker packs its children horizontally, automatically adjusting their 
    relative positions at draw time. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_bbox_and_child_offsets(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">dpicor = renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">pad = self.pad * dpicor</span>
        <span class="s1">sep = self.sep * dpicor</span>

        <span class="s1">bboxes = [c.get_bbox(renderer) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_visible_children()]</span>
        <span class="s2">if not </span><span class="s1">bboxes:</span>
            <span class="s2">return </span><span class="s1">Bbox.from_bounds(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">).padded(pad)</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s1">(y0</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">yoffsets = _get_aligned_offsets(</span>
            <span class="s1">[bbox.intervaly </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes]</span><span class="s2">, </span><span class="s1">self.height</span><span class="s2">, </span><span class="s1">self.align)</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">xoffsets = _get_packed_offsets(</span>
            <span class="s1">[bbox.width </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes]</span><span class="s2">, </span><span class="s1">self.width</span><span class="s2">, </span><span class="s1">sep</span><span class="s2">, </span><span class="s1">self.mode)</span>

        <span class="s1">x0 = bboxes[</span><span class="s5">0</span><span class="s1">].x0</span>
        <span class="s1">xoffsets -= ([bbox.x0 </span><span class="s2">for </span><span class="s1">bbox </span><span class="s2">in </span><span class="s1">bboxes] - x0)</span>

        <span class="s2">return </span><span class="s1">(Bbox.from_bounds(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">y1 - y0).padded(pad)</span><span class="s2">,</span>
                <span class="s1">[*zip(xoffsets</span><span class="s2">, </span><span class="s1">yoffsets)])</span>


<span class="s2">class </span><span class="s1">PaddedBox(OffsetBox):</span>
    <span class="s0">&quot;&quot;&quot; 
    A container to add a padding around an `.Artist`. 
 
    The `.PaddedBox` contains a `.FancyBboxPatch` that is used to visualize 
    it when rendering. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;draw_frame&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">pad=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">draw_frame=</span><span class="s2">False, </span><span class="s1">patch_attrs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        child : `~matplotlib.artist.Artist` 
            The contained `.Artist`. 
        pad : float, default: 0.0 
            The padding in points. This will be scaled with the renderer dpi. 
            In contrast, *width* and *height* are in *pixels* and thus not 
            scaled. 
        draw_frame : bool 
            Whether to draw the contained `.FancyBboxPatch`. 
        patch_attrs : dict or None 
            Additional parameters passed to the contained `.FancyBboxPatch`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.pad = pad</span>
        <span class="s1">self._children = [child]</span>
        <span class="s1">self.patch = FancyBboxPatch(</span>
            <span class="s1">xy=(</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">width=</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">height=</span><span class="s5">1.</span><span class="s2">,</span>
            <span class="s1">facecolor=</span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">edgecolor=</span><span class="s3">'k'</span><span class="s2">,</span>
            <span class="s1">mutation_scale=</span><span class="s5">1</span><span class="s2">,  </span><span class="s4"># self.prop.get_size_in_points(),</span>
            <span class="s1">snap=</span><span class="s2">True,</span>
            <span class="s1">visible=draw_frame</span><span class="s2">,</span>
            <span class="s1">boxstyle=</span><span class="s3">&quot;square,pad=0&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">patch_attrs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.patch.update(patch_attrs)</span>

    <span class="s2">def </span><span class="s1">_get_bbox_and_child_offsets(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited.</span>
        <span class="s1">pad = self.pad * renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(self._children[</span><span class="s5">0</span><span class="s1">].get_bbox(renderer).padded(pad)</span><span class="s2">, </span><span class="s1">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">offsets = self._get_bbox_and_child_offsets(renderer)</span>
        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset(bbox</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">(ox</span><span class="s2">, </span><span class="s1">oy) </span><span class="s2">in </span><span class="s1">zip(self.get_visible_children()</span><span class="s2">, </span><span class="s1">offsets):</span>
            <span class="s1">c.set_offset((px + ox</span><span class="s2">, </span><span class="s1">py + oy))</span>

        <span class="s1">self.draw_frame(renderer)</span>

        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.get_visible_children():</span>
            <span class="s1">c.draw(renderer)</span>

        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">update_frame(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.patch.set_bounds(bbox.bounds)</span>
        <span class="s2">if </span><span class="s1">fontsize:</span>
            <span class="s1">self.patch.set_mutation_scale(fontsize)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">draw_frame(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># update the location and size of the legend</span>
        <span class="s1">self.update_frame(self.get_window_extent(renderer))</span>
        <span class="s1">self.patch.draw(renderer)</span>


<span class="s2">class </span><span class="s1">DrawingArea(OffsetBox):</span>
    <span class="s0">&quot;&quot;&quot; 
    The DrawingArea can contain any Artist as a child. The DrawingArea 
    has a fixed width and height. The position of children relative to 
    the parent is fixed. The children can be clipped at the 
    boundaries of the parent. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">xdescent=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">ydescent=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        width, height : float 
            Width and height of the container box. 
        xdescent, ydescent : float 
            Descent of the box in x- and y-direction. 
        clip : bool 
            Whether to clip the children to the box. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.height = height</span>
        <span class="s1">self.xdescent = xdescent</span>
        <span class="s1">self.ydescent = ydescent</span>
        <span class="s1">self._clip_children = clip</span>
        <span class="s1">self.offset_transform = mtransforms.Affine2D()</span>
        <span class="s1">self.dpi_transform = mtransforms.Affine2D()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">clip_children(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        If the children of this DrawingArea should be clipped 
        by DrawingArea bounding box. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._clip_children</span>

    <span class="s1">@clip_children.setter</span>
    <span class="s2">def </span><span class="s1">clip_children(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s1">self._clip_children = bool(val)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `~matplotlib.transforms.Transform` applied to the children. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.dpi_transform + self.offset_transform</span>

    <span class="s2">def </span><span class="s1">set_transform(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        set_transform is ignored. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_offset(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offset of the container. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
            The (x, y) coordinates of the offset in display units. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset = xy</span>
        <span class="s1">self.offset_transform.clear()</span>
        <span class="s1">self.offset_transform.translate(xy[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xy[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s0">&quot;&quot;&quot;Return offset of the container.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._offset</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">dpi_cor = renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">Bbox.from_bounds(</span>
            <span class="s1">-self.xdescent * dpi_cor</span><span class="s2">, </span><span class="s1">-self.ydescent * dpi_cor</span><span class="s2">,</span>
            <span class="s1">self.width * dpi_cor</span><span class="s2">, </span><span class="s1">self.height * dpi_cor)</span>

    <span class="s2">def </span><span class="s1">add_artist(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Add an `.Artist` to the container box.&quot;&quot;&quot;</span>
        <span class="s1">self._children.append(a)</span>
        <span class="s2">if not </span><span class="s1">a.is_transform_set():</span>
            <span class="s1">a.set_transform(self.get_transform())</span>
        <span class="s2">if </span><span class="s1">self.axes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">a.axes = self.axes</span>
        <span class="s1">fig = self.figure</span>
        <span class="s2">if </span><span class="s1">fig </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">a.set_figure(fig)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>

        <span class="s1">dpi_cor = renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">self.dpi_transform.clear()</span>
        <span class="s1">self.dpi_transform.scale(dpi_cor)</span>

        <span class="s4"># At this point the DrawingArea has a transform</span>
        <span class="s4"># to the display space so the path created is</span>
        <span class="s4"># good for clipping children</span>
        <span class="s1">tpath = mtransforms.TransformedPath(</span>
            <span class="s1">mpath.Path([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.height]</span><span class="s2">,</span>
                        <span class="s1">[self.width</span><span class="s2">, </span><span class="s1">self.height]</span><span class="s2">,</span>
                        <span class="s1">[self.width</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span><span class="s2">,</span>
            <span class="s1">self.get_transform())</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._children:</span>
            <span class="s2">if </span><span class="s1">self._clip_children </span><span class="s2">and not </span><span class="s1">(c.clipbox </span><span class="s2">or </span><span class="s1">c._clippath):</span>
                <span class="s1">c.set_clip_path(tpath)</span>
            <span class="s1">c.draw(renderer)</span>

        <span class="s1">_bbox_artist(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">False, </span><span class="s1">props=dict(pad=</span><span class="s5">0.</span><span class="s1">))</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">TextArea(OffsetBox):</span>
    <span class="s0">&quot;&quot;&quot; 
    The TextArea is a container artist for a single Text instance. 
 
    The text is placed at (0, 0) with baseline+left alignment, by default. The 
    width and height of the TextArea instance is the width and height of its 
    child text. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;textprops&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">,</span>
                 <span class="s1">textprops=</span><span class="s2">None,</span>
                 <span class="s1">multilinebaseline=</span><span class="s2">False,</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        s : str 
            The text to be displayed. 
        textprops : dict, default: {} 
            Dictionary of keyword parameters to be passed to the `.Text` 
            instance in the TextArea. 
        multilinebaseline : bool, default: False 
            Whether the baseline for multiline text is adjusted so that it 
            is (approximately) center-aligned with single-line text. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">textprops </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">textprops = {}</span>
        <span class="s1">self._text = mtext.Text(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">**textprops)</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._children = [self._text]</span>
        <span class="s1">self.offset_transform = mtransforms.Affine2D()</span>
        <span class="s1">self._baseline_transform = mtransforms.Affine2D()</span>
        <span class="s1">self._text.set_transform(self.offset_transform +</span>
                                 <span class="s1">self._baseline_transform)</span>
        <span class="s1">self._multilinebaseline = multilinebaseline</span>

    <span class="s2">def </span><span class="s1">set_text(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot;Set the text of this area as a string.&quot;&quot;&quot;</span>
        <span class="s1">self._text.set_text(s)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_text(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the string representation of this area's text.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._text.get_text()</span>

    <span class="s2">def </span><span class="s1">set_multilinebaseline(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set multilinebaseline. 
 
        If True, the baseline for multiline text is adjusted so that it is 
        (approximately) center-aligned with single-line text.  This is used 
        e.g. by the legend implementation so that single-line labels are 
        baseline-aligned, but multiline labels are &quot;center&quot;-aligned with them. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._multilinebaseline = t</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_multilinebaseline(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get multilinebaseline. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._multilinebaseline</span>

    <span class="s2">def </span><span class="s1">set_transform(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        set_transform is ignored. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_offset(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offset of the container. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
            The (x, y) coordinates of the offset in display units. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset = xy</span>
        <span class="s1">self.offset_transform.clear()</span>
        <span class="s1">self.offset_transform.translate(xy[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xy[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s0">&quot;&quot;&quot;Return offset of the container.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._offset</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">h_</span><span class="s2">, </span><span class="s1">d_ = renderer.get_text_width_height_descent(</span>
            <span class="s3">&quot;lp&quot;</span><span class="s2">, </span><span class="s1">self._text._fontproperties</span><span class="s2">,</span>
            <span class="s1">ismath=</span><span class="s3">&quot;TeX&quot; </span><span class="s2">if </span><span class="s1">self._text.get_usetex() </span><span class="s2">else False</span><span class="s1">)</span>

        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">yd = self._text._get_layout(renderer)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = bbox.size</span>

        <span class="s1">self._baseline_transform.clear()</span>

        <span class="s2">if </span><span class="s1">len(info) &gt; </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">self._multilinebaseline:</span>
            <span class="s1">yd_new = </span><span class="s5">0.5 </span><span class="s1">* h - </span><span class="s5">0.5 </span><span class="s1">* (h_ - d_)</span>
            <span class="s1">self._baseline_transform.translate(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">yd - yd_new)</span>
            <span class="s1">yd = yd_new</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># single line</span>
            <span class="s1">h_d = max(h_ - d_</span><span class="s2">, </span><span class="s1">h - yd)</span>
            <span class="s1">h = h_d + yd</span>

        <span class="s1">ha = self._text.get_horizontalalignment()</span>
        <span class="s1">x0 = {</span><span class="s3">&quot;left&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">&quot;center&quot;</span><span class="s1">: -w / </span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">: -w}[ha]</span>

        <span class="s2">return </span><span class="s1">Bbox.from_bounds(x0</span><span class="s2">, </span><span class="s1">-yd</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">self._text.draw(renderer)</span>
        <span class="s1">_bbox_artist(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">False, </span><span class="s1">props=dict(pad=</span><span class="s5">0.</span><span class="s1">))</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">AuxTransformBox(OffsetBox):</span>
    <span class="s0">&quot;&quot;&quot; 
    Offset Box with the aux_transform. Its children will be 
    transformed with the aux_transform first then will be 
    offsetted. The absolute coordinate of the aux_transform is meaning 
    as it will be automatically adjust so that the left-lower corner 
    of the bounding box of children will be set to (0, 0) before the 
    offset transform. 
 
    It is similar to drawing area, except that the extent of the box 
    is not predetermined but calculated from the window extent of its 
    children. Furthermore, the extent of the children will be 
    calculated in the transformed coordinate. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">aux_transform):</span>
        <span class="s1">self.aux_transform = aux_transform</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.offset_transform = mtransforms.Affine2D()</span>
        <span class="s4"># ref_offset_transform makes offset_transform always relative to the</span>
        <span class="s4"># lower-left corner of the bbox of its children.</span>
        <span class="s1">self.ref_offset_transform = mtransforms.Affine2D()</span>

    <span class="s2">def </span><span class="s1">add_artist(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Add an `.Artist` to the container box.&quot;&quot;&quot;</span>
        <span class="s1">self._children.append(a)</span>
        <span class="s1">a.set_transform(self.get_transform())</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the :class:`~matplotlib.transforms.Transform` applied 
        to the children 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self.aux_transform</span>
                <span class="s1">+ self.ref_offset_transform</span>
                <span class="s1">+ self.offset_transform)</span>

    <span class="s2">def </span><span class="s1">set_transform(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        set_transform is ignored. 
        &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">set_offset(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offset of the container. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
            The (x, y) coordinates of the offset in display units. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset = xy</span>
        <span class="s1">self.offset_transform.clear()</span>
        <span class="s1">self.offset_transform.translate(xy[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xy[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s0">&quot;&quot;&quot;Return offset of the container.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._offset</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># clear the offset transforms</span>
        <span class="s1">_off = self.offset_transform.get_matrix()  </span><span class="s4"># to be restored later</span>
        <span class="s1">self.ref_offset_transform.clear()</span>
        <span class="s1">self.offset_transform.clear()</span>
        <span class="s4"># calculate the extent</span>
        <span class="s1">bboxes = [c.get_window_extent(renderer) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._children]</span>
        <span class="s1">ub = Bbox.union(bboxes)</span>
        <span class="s4"># adjust ref_offset_transform</span>
        <span class="s1">self.ref_offset_transform.translate(-ub.x0</span><span class="s2">, </span><span class="s1">-ub.y0)</span>
        <span class="s4"># restore offset transform</span>
        <span class="s1">self.offset_transform.set_matrix(_off)</span>
        <span class="s2">return </span><span class="s1">Bbox.from_bounds(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">ub.width</span><span class="s2">, </span><span class="s1">ub.height)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self._children:</span>
            <span class="s1">c.draw(renderer)</span>
        <span class="s1">_bbox_artist(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">False, </span><span class="s1">props=dict(pad=</span><span class="s5">0.</span><span class="s1">))</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">AnchoredOffsetbox(OffsetBox):</span>
    <span class="s0">&quot;&quot;&quot; 
    An offset box placed according to location *loc*. 
 
    AnchoredOffsetbox has a single child.  When multiple children are needed, 
    use an extra OffsetBox to enclose them.  By default, the offset box is 
    anchored against its parent axes. You may explicitly specify the 
    *bbox_to_anchor*. 
    &quot;&quot;&quot;</span>
    <span class="s1">zorder = </span><span class="s5">5  </span><span class="s4"># zorder of the legend</span>

    <span class="s4"># Location codes</span>
    <span class="s1">codes = {</span><span class="s3">'upper right'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,</span>
             <span class="s3">'upper left'</span><span class="s1">: </span><span class="s5">2</span><span class="s2">,</span>
             <span class="s3">'lower left'</span><span class="s1">: </span><span class="s5">3</span><span class="s2">,</span>
             <span class="s3">'lower right'</span><span class="s1">: </span><span class="s5">4</span><span class="s2">,</span>
             <span class="s3">'right'</span><span class="s1">: </span><span class="s5">5</span><span class="s2">,</span>
             <span class="s3">'center left'</span><span class="s1">: </span><span class="s5">6</span><span class="s2">,</span>
             <span class="s3">'center right'</span><span class="s1">: </span><span class="s5">7</span><span class="s2">,</span>
             <span class="s3">'lower center'</span><span class="s1">: </span><span class="s5">8</span><span class="s2">,</span>
             <span class="s3">'upper center'</span><span class="s1">: </span><span class="s5">9</span><span class="s2">,</span>
             <span class="s3">'center'</span><span class="s1">: </span><span class="s5">10</span><span class="s2">,</span>
             <span class="s1">}</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;pad&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span>
                 <span class="s1">pad=</span><span class="s5">0.4</span><span class="s2">, </span><span class="s1">borderpad=</span><span class="s5">0.5</span><span class="s2">,</span>
                 <span class="s1">child=</span><span class="s2">None, </span><span class="s1">prop=</span><span class="s2">None, </span><span class="s1">frameon=</span><span class="s2">True,</span>
                 <span class="s1">bbox_to_anchor=</span><span class="s2">None,</span>
                 <span class="s1">bbox_transform=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        loc : str 
            The box location.  Valid locations are 
            'upper left', 'upper center', 'upper right', 
            'center left', 'center', 'center right', 
            'lower left', 'lower center', 'lower right'. 
            For backward compatibility, numeric values are accepted as well. 
            See the parameter *loc* of `.Legend` for details. 
        pad : float, default: 0.4 
            Padding around the child as fraction of the fontsize. 
        borderpad : float, default: 0.5 
            Padding between the offsetbox frame and the *bbox_to_anchor*. 
        child : `.OffsetBox` 
            The box that will be anchored. 
        prop : `.FontProperties` 
            This is only used as a reference for paddings. If not given, 
            :rc:`legend.fontsize` is used. 
        frameon : bool 
            Whether to draw a frame around the box. 
        bbox_to_anchor : `.BboxBase`, 2-tuple, or 4-tuple of floats 
            Box that is used to position the legend in conjunction with *loc*. 
        bbox_transform : None or :class:`matplotlib.transforms.Transform` 
            The transform for the bounding box (*bbox_to_anchor*). 
        **kwargs 
            All other parameters are passed on to `.OffsetBox`. 
 
        Notes 
        ----- 
        See `.Legend` for a detailed description of the anchoring mechanism. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s1">self.set_bbox_to_anchor(bbox_to_anchor</span><span class="s2">, </span><span class="s1">bbox_transform)</span>
        <span class="s1">self.set_child(child)</span>

        <span class="s2">if </span><span class="s1">isinstance(loc</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">loc = _api.check_getitem(self.codes</span><span class="s2">, </span><span class="s1">loc=loc)</span>

        <span class="s1">self.loc = loc</span>
        <span class="s1">self.borderpad = borderpad</span>
        <span class="s1">self.pad = pad</span>

        <span class="s2">if </span><span class="s1">prop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.prop = FontProperties(size=mpl.rcParams[</span><span class="s3">&quot;legend.fontsize&quot;</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.prop = FontProperties._from_any(prop)</span>
            <span class="s2">if </span><span class="s1">isinstance(prop</span><span class="s2">, </span><span class="s1">dict) </span><span class="s2">and </span><span class="s3">&quot;size&quot; </span><span class="s2">not in </span><span class="s1">prop:</span>
                <span class="s1">self.prop.set_size(mpl.rcParams[</span><span class="s3">&quot;legend.fontsize&quot;</span><span class="s1">])</span>

        <span class="s1">self.patch = FancyBboxPatch(</span>
            <span class="s1">xy=(</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">width=</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">height=</span><span class="s5">1.</span><span class="s2">,</span>
            <span class="s1">facecolor=</span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">edgecolor=</span><span class="s3">'k'</span><span class="s2">,</span>
            <span class="s1">mutation_scale=self.prop.get_size_in_points()</span><span class="s2">,</span>
            <span class="s1">snap=</span><span class="s2">True,</span>
            <span class="s1">visible=frameon</span><span class="s2">,</span>
            <span class="s1">boxstyle=</span><span class="s3">&quot;square,pad=0&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_child(self</span><span class="s2">, </span><span class="s1">child):</span>
        <span class="s0">&quot;&quot;&quot;Set the child to be anchored.&quot;&quot;&quot;</span>
        <span class="s1">self._child = child</span>
        <span class="s2">if </span><span class="s1">child </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">child.axes = self.axes</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_child(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the child.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._child</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the list of children.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[self._child]</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())</span>
        <span class="s1">pad = self.pad * fontsize</span>
        <span class="s2">return </span><span class="s1">self.get_child().get_bbox(renderer).padded(pad)</span>

    <span class="s2">def </span><span class="s1">get_bbox_to_anchor(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the bbox that the box is anchored to.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._bbox_to_anchor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.axes.bbox</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">transform = self._bbox_to_anchor_transform</span>
            <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._bbox_to_anchor</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">TransformedBbox(self._bbox_to_anchor</span><span class="s2">, </span><span class="s1">transform)</span>

    <span class="s2">def </span><span class="s1">set_bbox_to_anchor(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the bbox that the box is anchored to. 
 
        *bbox* can be a Bbox instance, a list of [left, bottom, width, 
        height], or a list of [left, bottom] where the width and 
        height will be assumed to be zero. The bbox will be 
        transformed to display coordinate by the given transform. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">bbox </span><span class="s2">is None or </span><span class="s1">isinstance(bbox</span><span class="s2">, </span><span class="s1">BboxBase):</span>
            <span class="s1">self._bbox_to_anchor = bbox</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">l = len(bbox)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Invalid bbox: </span><span class="s2">{</span><span class="s1">bbox</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>

            <span class="s2">if </span><span class="s1">l == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">bbox = [bbox[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bbox[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">self._bbox_to_anchor = Bbox.from_bounds(*bbox)</span>

        <span class="s1">self._bbox_to_anchor_transform = transform</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_compat_get_offset</span>
    <span class="s2">def </span><span class="s1">get_offset(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">pad = (self.borderpad</span>
               <span class="s1">* renderer.points_to_pixels(self.prop.get_size_in_points()))</span>
        <span class="s1">bbox_to_anchor = self.get_bbox_to_anchor()</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = _get_anchored_bbox(</span>
            <span class="s1">self.loc</span><span class="s2">, </span><span class="s1">Bbox.from_bounds(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">bbox.width</span><span class="s2">, </span><span class="s1">bbox.height)</span><span class="s2">,</span>
            <span class="s1">bbox_to_anchor</span><span class="s2">, </span><span class="s1">pad)</span>
        <span class="s2">return </span><span class="s1">x0 - bbox.x0</span><span class="s2">, </span><span class="s1">y0 - bbox.y0</span>

    <span class="s2">def </span><span class="s1">update_frame(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.patch.set_bounds(bbox.bounds)</span>
        <span class="s2">if </span><span class="s1">fontsize:</span>
            <span class="s1">self.patch.set_mutation_scale(fontsize)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s4"># update the location and size of the legend</span>
        <span class="s1">bbox = self.get_window_extent(renderer)</span>
        <span class="s1">fontsize = renderer.points_to_pixels(self.prop.get_size_in_points())</span>
        <span class="s1">self.update_frame(bbox</span><span class="s2">, </span><span class="s1">fontsize)</span>
        <span class="s1">self.patch.draw(renderer)</span>

        <span class="s1">px</span><span class="s2">, </span><span class="s1">py = self.get_offset(self.get_bbox(renderer)</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">self.get_child().set_offset((px</span><span class="s2">, </span><span class="s1">py))</span>
        <span class="s1">self.get_child().draw(renderer)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">def </span><span class="s1">_get_anchored_bbox(loc</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">parentbbox</span><span class="s2">, </span><span class="s1">borderpad):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the (x, y) position of the *bbox* anchored at the *parentbbox* with 
    the *loc* code with the *borderpad*. 
    &quot;&quot;&quot;</span>
    <span class="s4"># This is only called internally and *loc* should already have been</span>
    <span class="s4"># validated.  If 0 (None), we just let ``bbox.anchored`` raise.</span>
    <span class="s1">c = [</span><span class="s2">None, </span><span class="s3">&quot;NE&quot;</span><span class="s2">, </span><span class="s3">&quot;NW&quot;</span><span class="s2">, </span><span class="s3">&quot;SW&quot;</span><span class="s2">, </span><span class="s3">&quot;SE&quot;</span><span class="s2">, </span><span class="s3">&quot;E&quot;</span><span class="s2">, </span><span class="s3">&quot;W&quot;</span><span class="s2">, </span><span class="s3">&quot;E&quot;</span><span class="s2">, </span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s3">&quot;N&quot;</span><span class="s2">, </span><span class="s3">&quot;C&quot;</span><span class="s1">][loc]</span>
    <span class="s1">container = parentbbox.padded(-borderpad)</span>
    <span class="s2">return </span><span class="s1">bbox.anchored(c</span><span class="s2">, </span><span class="s1">container=container).p0</span>


<span class="s2">class </span><span class="s1">AnchoredText(AnchoredOffsetbox):</span>
    <span class="s0">&quot;&quot;&quot; 
    AnchoredOffsetbox with Text. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;pad&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">pad=</span><span class="s5">0.4</span><span class="s2">, </span><span class="s1">borderpad=</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">prop=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        s : str 
            Text. 
 
        loc : str 
            Location code. See `AnchoredOffsetbox`. 
 
        pad : float, default: 0.4 
            Padding around the text as fraction of the fontsize. 
 
        borderpad : float, default: 0.5 
            Spacing between the offsetbox frame and the *bbox_to_anchor*. 
 
        prop : dict, optional 
            Dictionary of keyword parameters to be passed to the 
            `~matplotlib.text.Text` instance contained inside AnchoredText. 
 
        **kwargs 
            All other parameters are passed to `AnchoredOffsetbox`. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">prop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">prop = {}</span>
        <span class="s1">badkwargs = {</span><span class="s3">'va'</span><span class="s2">, </span><span class="s3">'verticalalignment'</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">badkwargs &amp; set(prop):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'Mixing verticalalignment with AnchoredText is not supported.'</span><span class="s1">)</span>

        <span class="s1">self.txt = TextArea(s</span><span class="s2">, </span><span class="s1">textprops=prop)</span>
        <span class="s1">fp = self.txt._text.get_fontproperties()</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">loc</span><span class="s2">, </span><span class="s1">pad=pad</span><span class="s2">, </span><span class="s1">borderpad=borderpad</span><span class="s2">, </span><span class="s1">child=self.txt</span><span class="s2">, </span><span class="s1">prop=fp</span><span class="s2">,</span>
            <span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">OffsetImage(OffsetBox):</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;zoom&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">,</span>
                 <span class="s1">zoom=</span><span class="s5">1</span><span class="s2">,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">interpolation=</span><span class="s2">None,</span>
                 <span class="s1">origin=</span><span class="s2">None,</span>
                 <span class="s1">filternorm=</span><span class="s2">True,</span>
                 <span class="s1">filterrad=</span><span class="s5">4.0</span><span class="s2">,</span>
                 <span class="s1">resample=</span><span class="s2">False,</span>
                 <span class="s1">dpi_cor=</span><span class="s2">True,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>

        <span class="s1">super().__init__()</span>
        <span class="s1">self._dpi_cor = dpi_cor</span>

        <span class="s1">self.image = BboxImage(bbox=self.get_window_extent</span><span class="s2">,</span>
                               <span class="s1">cmap=cmap</span><span class="s2">,</span>
                               <span class="s1">norm=norm</span><span class="s2">,</span>
                               <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
                               <span class="s1">origin=origin</span><span class="s2">,</span>
                               <span class="s1">filternorm=filternorm</span><span class="s2">,</span>
                               <span class="s1">filterrad=filterrad</span><span class="s2">,</span>
                               <span class="s1">resample=resample</span><span class="s2">,</span>
                               <span class="s1">**kwargs</span>
                               <span class="s1">)</span>

        <span class="s1">self._children = [self.image]</span>

        <span class="s1">self.set_zoom(zoom)</span>
        <span class="s1">self.set_data(arr)</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s1">self._data = np.asarray(arr)</span>
        <span class="s1">self.image.set_data(self._data)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_data(self):</span>
        <span class="s2">return </span><span class="s1">self._data</span>

    <span class="s2">def </span><span class="s1">set_zoom(self</span><span class="s2">, </span><span class="s1">zoom):</span>
        <span class="s1">self._zoom = zoom</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_zoom(self):</span>
        <span class="s2">return </span><span class="s1">self._zoom</span>

    <span class="s2">def </span><span class="s1">get_offset(self):</span>
        <span class="s0">&quot;&quot;&quot;Return offset of the container.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._offset</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">return </span><span class="s1">[self.image]</span>

    <span class="s2">def </span><span class="s1">get_bbox(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">dpi_cor = renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">) </span><span class="s2">if </span><span class="s1">self._dpi_cor </span><span class="s2">else </span><span class="s5">1.</span>
        <span class="s1">zoom = self.get_zoom()</span>
        <span class="s1">data = self.get_data()</span>
        <span class="s1">ny</span><span class="s2">, </span><span class="s1">nx = data.shape[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = dpi_cor * nx * zoom</span><span class="s2">, </span><span class="s1">dpi_cor * ny * zoom</span>
        <span class="s2">return </span><span class="s1">Bbox.from_bounds(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">self.image.draw(renderer)</span>
        <span class="s4"># bbox_artist(self, renderer, fill=False, props=dict(pad=0.))</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">AnnotationBbox(martist.Artist</span><span class="s2">, </span><span class="s1">mtext._AnnotationBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Container for an `OffsetBox` referring to a specific position *xy*. 
 
    Optionally an arrow pointing from the offsetbox to *xy* can be drawn. 
 
    This is like `.Annotation`, but with `OffsetBox` instead of `.Text`. 
    &quot;&quot;&quot;</span>

    <span class="s1">zorder = </span><span class="s5">3</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;AnnotationBbox(%g,%g)&quot; </span><span class="s1">% (self.xy[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;xycoords&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offsetbox</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">,</span>
                 <span class="s1">xybox=</span><span class="s2">None,</span>
                 <span class="s1">xycoords=</span><span class="s3">'data'</span><span class="s2">,</span>
                 <span class="s1">boxcoords=</span><span class="s2">None,</span>
                 <span class="s1">frameon=</span><span class="s2">True, </span><span class="s1">pad=</span><span class="s5">0.4</span><span class="s2">,  </span><span class="s4"># FancyBboxPatch boxstyle.</span>
                 <span class="s1">annotation_clip=</span><span class="s2">None,</span>
                 <span class="s1">box_alignment=(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">bboxprops=</span><span class="s2">None,</span>
                 <span class="s1">arrowprops=</span><span class="s2">None,</span>
                 <span class="s1">fontsize=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offsetbox : `OffsetBox` 
 
        xy : (float, float) 
            The point *(x, y)* to annotate. The coordinate system is determined 
            by *xycoords*. 
 
        xybox : (float, float), default: *xy* 
            The position *(x, y)* to place the text at. The coordinate system 
            is determined by *boxcoords*. 
 
        xycoords : single or two-tuple of str or `.Artist` or `.Transform` or \ 
callable, default: 'data' 
            The coordinate system that *xy* is given in. See the parameter 
            *xycoords* in `.Annotation` for a detailed description. 
 
        boxcoords : single or two-tuple of str or `.Artist` or `.Transform` \ 
or callable, default: value of *xycoords* 
            The coordinate system that *xybox* is given in. See the parameter 
            *textcoords* in `.Annotation` for a detailed description. 
 
        frameon : bool, default: True 
            By default, the text is surrounded by a white `.FancyBboxPatch` 
            (accessible as the ``patch`` attribute of the `.AnnotationBbox`). 
            If *frameon* is set to False, this patch is made invisible. 
 
        annotation_clip: bool or None, default: None 
            Whether to clip (i.e. not draw) the annotation when the annotation 
            point *xy* is outside the axes area. 
 
            - If *True*, the annotation will be clipped when *xy* is outside 
              the axes. 
            - If *False*, the annotation will always be drawn. 
            - If *None*, the annotation will be clipped when *xy* is outside 
              the axes and *xycoords* is 'data'. 
 
        pad : float, default: 0.4 
            Padding around the offsetbox. 
 
        box_alignment : (float, float) 
            A tuple of two floats for a vertical and horizontal alignment of 
            the offset box w.r.t. the *boxcoords*. 
            The lower-left corner is (0, 0) and upper-right corner is (1, 1). 
 
        bboxprops : dict, optional 
            A dictionary of properties to set for the annotation bounding box, 
            for example *boxstyle* and *alpha*.  See `.FancyBboxPatch` for 
            details. 
 
        arrowprops: dict, optional 
            Arrow properties, see `.Annotation` for description. 
 
        fontsize: float or str, optional 
            Translated to points and passed as *mutation_scale* into 
            `.FancyBboxPatch` to scale attributes of the box style (e.g. pad 
            or rounding_size).  The name is chosen in analogy to `.Text` where 
            *fontsize* defines the mutation scale as well.  If not given, 
            :rc:`legend.fontsize` is used.  See `.Text.set_fontsize` for valid 
            values. 
 
        **kwargs 
            Other `AnnotationBbox` properties.  See `.AnnotationBbox.set` for 
            a list. 
        &quot;&quot;&quot;</span>

        <span class="s1">martist.Artist.__init__(self)</span>
        <span class="s1">mtext._AnnotationBase.__init__(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">xycoords=xycoords</span><span class="s2">, </span><span class="s1">annotation_clip=annotation_clip)</span>

        <span class="s1">self.offsetbox = offsetbox</span>
        <span class="s1">self.arrowprops = arrowprops.copy() </span><span class="s2">if </span><span class="s1">arrowprops </span><span class="s2">is not None else None</span>
        <span class="s1">self.set_fontsize(fontsize)</span>
        <span class="s1">self.xybox = xybox </span><span class="s2">if </span><span class="s1">xybox </span><span class="s2">is not None else </span><span class="s1">xy</span>
        <span class="s1">self.boxcoords = boxcoords </span><span class="s2">if </span><span class="s1">boxcoords </span><span class="s2">is not None else </span><span class="s1">xycoords</span>
        <span class="s1">self._box_alignment = box_alignment</span>

        <span class="s2">if </span><span class="s1">arrowprops </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._arrow_relpos = self.arrowprops.pop(</span><span class="s3">&quot;relpos&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">))</span>
            <span class="s1">self.arrow_patch = FancyArrowPatch((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                                               <span class="s1">**self.arrowprops)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._arrow_relpos = </span><span class="s2">None</span>
            <span class="s1">self.arrow_patch = </span><span class="s2">None</span>

        <span class="s1">self.patch = FancyBboxPatch(  </span><span class="s4"># frame</span>
            <span class="s1">xy=(</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">width=</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">height=</span><span class="s5">1.</span><span class="s2">,</span>
            <span class="s1">facecolor=</span><span class="s3">'w'</span><span class="s2">, </span><span class="s1">edgecolor=</span><span class="s3">'k'</span><span class="s2">,</span>
            <span class="s1">mutation_scale=self.prop.get_size_in_points()</span><span class="s2">,</span>
            <span class="s1">snap=</span><span class="s2">True,</span>
            <span class="s1">visible=frameon</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.patch.set_boxstyle(</span><span class="s3">&quot;square&quot;</span><span class="s2">, </span><span class="s1">pad=pad)</span>
        <span class="s2">if </span><span class="s1">bboxprops:</span>
            <span class="s1">self.patch.set(**bboxprops)</span>

        <span class="s1">self._internal_update(kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">xyann(self):</span>
        <span class="s2">return </span><span class="s1">self.xybox</span>

    <span class="s1">@xyann.setter</span>
    <span class="s2">def </span><span class="s1">xyann(self</span><span class="s2">, </span><span class="s1">xyann):</span>
        <span class="s1">self.xybox = xyann</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">anncoords(self):</span>
        <span class="s2">return </span><span class="s1">self.boxcoords</span>

    <span class="s1">@anncoords.setter</span>
    <span class="s2">def </span><span class="s1">anncoords(self</span><span class="s2">, </span><span class="s1">coords):</span>
        <span class="s1">self.boxcoords = coords</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s2">if not </span><span class="s1">self._check_xy(</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s2">return False, </span><span class="s1">{}</span>
        <span class="s2">return </span><span class="s1">self.offsetbox.contains(mouseevent)</span>
        <span class="s4"># self.arrow_patch is currently not checked as this can be a line - JJ</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s1">children = [self.offsetbox</span><span class="s2">, </span><span class="s1">self.patch]</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch:</span>
            <span class="s1">children.append(self.arrow_patch)</span>
        <span class="s2">return </span><span class="s1">children</span>

    <span class="s2">def </span><span class="s1">set_figure(self</span><span class="s2">, </span><span class="s1">fig):</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.arrow_patch.set_figure(fig)</span>
        <span class="s1">self.offsetbox.set_figure(fig)</span>
        <span class="s1">martist.Artist.set_figure(self</span><span class="s2">, </span><span class="s1">fig)</span>

    <span class="s2">def </span><span class="s1">set_fontsize(self</span><span class="s2">, </span><span class="s1">s=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the fontsize in points. 
 
        If *s* is not given, reset to :rc:`legend.fontsize`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">s = mpl.rcParams[</span><span class="s3">&quot;legend.fontsize&quot;</span><span class="s1">]</span>

        <span class="s1">self.prop = FontProperties(size=s)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_fontsize(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the fontsize in points.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.prop.get_size_in_points()</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>
        <span class="s2">return </span><span class="s1">Bbox.union([child.get_window_extent(renderer)</span>
                           <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">self.get_children()])</span>

    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">Bbox.union([child.get_tightbbox(renderer)</span>
                           <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">self.get_children()])</span>

    <span class="s2">def </span><span class="s1">update_positions(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update pixel positions for the annotated point, the text and the arrow. 
        &quot;&quot;&quot;</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.xybox</span>
        <span class="s2">if </span><span class="s1">isinstance(self.boxcoords</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">xcoord</span><span class="s2">, </span><span class="s1">ycoord = self.boxcoords</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = self._get_xy(renderer</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">xcoord)</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = self._get_xy(renderer</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">ycoord)</span>
            <span class="s1">ox0</span><span class="s2">, </span><span class="s1">oy0 = x1</span><span class="s2">, </span><span class="s1">y2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ox0</span><span class="s2">, </span><span class="s1">oy0 = self._get_xy(renderer</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">self.boxcoords)</span>

        <span class="s1">bbox = self.offsetbox.get_bbox(renderer)</span>
        <span class="s1">fw</span><span class="s2">, </span><span class="s1">fh = self._box_alignment</span>
        <span class="s1">self.offsetbox.set_offset(</span>
            <span class="s1">(ox0 - fw*bbox.width - bbox.x0</span><span class="s2">, </span><span class="s1">oy0 - fh*bbox.height - bbox.y0))</span>

        <span class="s1">bbox = self.offsetbox.get_window_extent(renderer)</span>
        <span class="s1">self.patch.set_bounds(bbox.bounds)</span>

        <span class="s1">mutation_scale = renderer.points_to_pixels(self.get_fontsize())</span>
        <span class="s1">self.patch.set_mutation_scale(mutation_scale)</span>

        <span class="s2">if </span><span class="s1">self.arrowprops:</span>
            <span class="s4"># Use FancyArrowPatch if self.arrowprops has &quot;arrowstyle&quot; key.</span>

            <span class="s4"># Adjust the starting point of the arrow relative to the textbox.</span>
            <span class="s4"># TODO: Rotation needs to be accounted.</span>
            <span class="s1">arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos</span>
            <span class="s1">arrow_end = self._get_position_xy(renderer)</span>
            <span class="s4"># The arrow (from arrow_begin to arrow_end) will be first clipped</span>
            <span class="s4"># by patchA and patchB, then shrunk by shrinkA and shrinkB (in</span>
            <span class="s4"># points).  If patch A is not set, self.bbox_patch is used.</span>
            <span class="s1">self.arrow_patch.set_positions(arrow_begin</span><span class="s2">, </span><span class="s1">arrow_end)</span>

            <span class="s2">if </span><span class="s3">&quot;mutation_scale&quot; </span><span class="s2">in </span><span class="s1">self.arrowprops:</span>
                <span class="s1">mutation_scale = renderer.points_to_pixels(</span>
                    <span class="s1">self.arrowprops[</span><span class="s3">&quot;mutation_scale&quot;</span><span class="s1">])</span>
                <span class="s4"># Else, use fontsize-based mutation_scale defined above.</span>
            <span class="s1">self.arrow_patch.set_mutation_scale(mutation_scale)</span>

            <span class="s1">patchA = self.arrowprops.get(</span><span class="s3">&quot;patchA&quot;</span><span class="s2">, </span><span class="s1">self.patch)</span>
            <span class="s1">self.arrow_patch.set_patchA(patchA)</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if not </span><span class="s1">self.get_visible() </span><span class="s2">or not </span><span class="s1">self._check_xy(renderer):</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(self.__class__.__name__</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>
        <span class="s1">self.update_positions(renderer)</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.arrow_patch.figure </span><span class="s2">is None and </span><span class="s1">self.figure </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.arrow_patch.figure = self.figure</span>
            <span class="s1">self.arrow_patch.draw(renderer)</span>
        <span class="s1">self.patch.draw(renderer)</span>
        <span class="s1">self.offsetbox.draw(renderer)</span>
        <span class="s1">renderer.close_group(self.__class__.__name__)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>


<span class="s2">class </span><span class="s1">DraggableBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper base class for a draggable artist (legend, offsetbox). 
 
    Derived classes must override the following methods:: 
 
        def save_offset(self): 
            ''' 
            Called when the object is picked for dragging; should save the 
            reference position of the artist. 
            ''' 
 
        def update_offset(self, dx, dy): 
            ''' 
            Called during the dragging; (*dx*, *dy*) is the pixel offset from 
            the point where the mouse drag started. 
            ''' 
 
    Optionally, you may override the following method:: 
 
        def finalize_offset(self): 
            '''Called when the mouse is released.''' 
 
    In the current implementation of `.DraggableLegend` and 
    `DraggableAnnotation`, `update_offset` places the artists in display 
    coordinates, and `finalize_offset` recalculates their position in axes 
    coordinate and set a relevant attribute. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ref_artist</span><span class="s2">, </span><span class="s1">use_blit=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self.ref_artist = ref_artist</span>
        <span class="s2">if not </span><span class="s1">ref_artist.pickable():</span>
            <span class="s1">ref_artist.set_picker(</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.got_artist = </span><span class="s2">False</span>
        <span class="s1">self.canvas = self.ref_artist.figure.canvas</span>
        <span class="s1">self._use_blit = use_blit </span><span class="s2">and </span><span class="s1">self.canvas.supports_blit</span>
        <span class="s1">self.cids = [</span>
            <span class="s1">self.canvas.callbacks._connect_picklable(</span>
                <span class="s3">'pick_event'</span><span class="s2">, </span><span class="s1">self.on_pick)</span><span class="s2">,</span>
            <span class="s1">self.canvas.callbacks._connect_picklable(</span>
                <span class="s3">'button_release_event'</span><span class="s2">, </span><span class="s1">self.on_release)</span><span class="s2">,</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">on_motion(self</span><span class="s2">, </span><span class="s1">evt):</span>
        <span class="s2">if </span><span class="s1">self._check_still_parented() </span><span class="s2">and </span><span class="s1">self.got_artist:</span>
            <span class="s1">dx = evt.x - self.mouse_x</span>
            <span class="s1">dy = evt.y - self.mouse_y</span>
            <span class="s1">self.update_offset(dx</span><span class="s2">, </span><span class="s1">dy)</span>
            <span class="s2">if </span><span class="s1">self._use_blit:</span>
                <span class="s1">self.canvas.restore_region(self.background)</span>
                <span class="s1">self.ref_artist.draw(</span>
                    <span class="s1">self.ref_artist.figure._get_renderer())</span>
                <span class="s1">self.canvas.blit()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.canvas.draw()</span>

    <span class="s2">def </span><span class="s1">on_pick(self</span><span class="s2">, </span><span class="s1">evt):</span>
        <span class="s2">if </span><span class="s1">self._check_still_parented() </span><span class="s2">and </span><span class="s1">evt.artist == self.ref_artist:</span>
            <span class="s1">self.mouse_x = evt.mouseevent.x</span>
            <span class="s1">self.mouse_y = evt.mouseevent.y</span>
            <span class="s1">self.got_artist = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">self._use_blit:</span>
                <span class="s1">self.ref_artist.set_animated(</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">self.canvas.draw()</span>
                <span class="s1">self.background = \</span>
                    <span class="s1">self.canvas.copy_from_bbox(self.ref_artist.figure.bbox)</span>
                <span class="s1">self.ref_artist.draw(</span>
                    <span class="s1">self.ref_artist.figure._get_renderer())</span>
                <span class="s1">self.canvas.blit()</span>
            <span class="s1">self._c1 = self.canvas.callbacks._connect_picklable(</span>
                <span class="s3">&quot;motion_notify_event&quot;</span><span class="s2">, </span><span class="s1">self.on_motion)</span>
            <span class="s1">self.save_offset()</span>

    <span class="s2">def </span><span class="s1">on_release(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s2">if </span><span class="s1">self._check_still_parented() </span><span class="s2">and </span><span class="s1">self.got_artist:</span>
            <span class="s1">self.finalize_offset()</span>
            <span class="s1">self.got_artist = </span><span class="s2">False</span>
            <span class="s1">self.canvas.mpl_disconnect(self._c1)</span>

            <span class="s2">if </span><span class="s1">self._use_blit:</span>
                <span class="s1">self.ref_artist.set_animated(</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_still_parented(self):</span>
        <span class="s2">if </span><span class="s1">self.ref_artist.figure </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.disconnect()</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">disconnect(self):</span>
        <span class="s0">&quot;&quot;&quot;Disconnect the callbacks.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">cid </span><span class="s2">in </span><span class="s1">self.cids:</span>
            <span class="s1">self.canvas.mpl_disconnect(cid)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">c1 = self._c1</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.canvas.mpl_disconnect(c1)</span>

    <span class="s2">def </span><span class="s1">save_offset(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">update_offset(self</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">finalize_offset(self):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">DraggableOffsetBox(DraggableBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ref_artist</span><span class="s2">, </span><span class="s1">offsetbox</span><span class="s2">, </span><span class="s1">use_blit=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(ref_artist</span><span class="s2">, </span><span class="s1">use_blit=use_blit)</span>
        <span class="s1">self.offsetbox = offsetbox</span>

    <span class="s2">def </span><span class="s1">save_offset(self):</span>
        <span class="s1">offsetbox = self.offsetbox</span>
        <span class="s1">renderer = offsetbox.figure._get_renderer()</span>
        <span class="s1">offset = offsetbox.get_offset(offsetbox.get_bbox(renderer)</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">self.offsetbox_x</span><span class="s2">, </span><span class="s1">self.offsetbox_y = offset</span>
        <span class="s1">self.offsetbox.set_offset(offset)</span>

    <span class="s2">def </span><span class="s1">update_offset(self</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy):</span>
        <span class="s1">loc_in_canvas = self.offsetbox_x + dx</span><span class="s2">, </span><span class="s1">self.offsetbox_y + dy</span>
        <span class="s1">self.offsetbox.set_offset(loc_in_canvas)</span>

    <span class="s2">def </span><span class="s1">get_loc_in_canvas(self):</span>
        <span class="s1">offsetbox = self.offsetbox</span>
        <span class="s1">renderer = offsetbox.figure._get_renderer()</span>
        <span class="s1">bbox = offsetbox.get_bbox(renderer)</span>
        <span class="s1">ox</span><span class="s2">, </span><span class="s1">oy = offsetbox._offset</span>
        <span class="s1">loc_in_canvas = (ox + bbox.x0</span><span class="s2">, </span><span class="s1">oy + bbox.y0)</span>
        <span class="s2">return </span><span class="s1">loc_in_canvas</span>


<span class="s2">class </span><span class="s1">DraggableAnnotation(DraggableBase):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">use_blit=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">super().__init__(annotation</span><span class="s2">, </span><span class="s1">use_blit=use_blit)</span>
        <span class="s1">self.annotation = annotation</span>

    <span class="s2">def </span><span class="s1">save_offset(self):</span>
        <span class="s1">ann = self.annotation</span>
        <span class="s1">self.ox</span><span class="s2">, </span><span class="s1">self.oy = ann.get_transform().transform(ann.xyann)</span>

    <span class="s2">def </span><span class="s1">update_offset(self</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy):</span>
        <span class="s1">ann = self.annotation</span>
        <span class="s1">ann.xyann = ann.get_transform().inverted().transform(</span>
            <span class="s1">(self.ox + dx</span><span class="s2">, </span><span class="s1">self.oy + dy))</span>
</pre>
</body>
</html>