<html>
<head>
<title>streamplot.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
streamplot.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Streamline plotting for 2D vector fields. 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cm</span><span class="s2">, </span><span class="s1">patches</span>
<span class="s2">import </span><span class="s1">matplotlib.colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">import </span><span class="s1">matplotlib.collections </span><span class="s2">as </span><span class="s1">mcollections</span>
<span class="s2">import </span><span class="s1">matplotlib.lines </span><span class="s2">as </span><span class="s1">mlines</span>


<span class="s1">__all__ = [</span><span class="s3">'streamplot'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">streamplot(axes</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">density=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s2">None, </span><span class="s1">color=</span><span class="s2">None,</span>
               <span class="s1">cmap=</span><span class="s2">None, </span><span class="s1">norm=</span><span class="s2">None, </span><span class="s1">arrowsize=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">arrowstyle=</span><span class="s3">'-|&gt;'</span><span class="s2">,</span>
               <span class="s1">minlength=</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None, </span><span class="s1">zorder=</span><span class="s2">None, </span><span class="s1">start_points=</span><span class="s2">None,</span>
               <span class="s1">maxlength=</span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">integration_direction=</span><span class="s3">'both'</span><span class="s2">,</span>
               <span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Draw streamlines of a vector flow. 
 
    Parameters 
    ---------- 
    x, y : 1D/2D arrays 
        Evenly spaced strictly increasing arrays to make a grid.  If 2D, all 
        rows of *x* must be equal and all columns of *y* must be equal; i.e., 
        they must be as if generated by ``np.meshgrid(x_1d, y_1d)``. 
    u, v : 2D arrays 
        *x* and *y*-velocities. The number of rows and columns must match 
        the length of *y* and *x*, respectively. 
    density : float or (float, float) 
        Controls the closeness of streamlines. When ``density = 1``, the domain 
        is divided into a 30x30 grid. *density* linearly scales this grid. 
        Each cell in the grid can have, at most, one traversing streamline. 
        For different densities in each direction, use a tuple 
        (density_x, density_y). 
    linewidth : float or 2D array 
        The width of the streamlines. With a 2D array the line width can be 
        varied across the grid. The array must have the same shape as *u* 
        and *v*. 
    color : color or 2D array 
        The streamline color. If given an array, its values are converted to 
        colors using *cmap* and *norm*.  The array must have the same shape 
        as *u* and *v*. 
    cmap, norm 
        Data normalization and colormapping parameters for *color*; only used 
        if *color* is an array of floats. See `~.Axes.imshow` for a detailed 
        description. 
    arrowsize : float 
        Scaling factor for the arrow size. 
    arrowstyle : str 
        Arrow style specification. 
        See `~matplotlib.patches.FancyArrowPatch`. 
    minlength : float 
        Minimum length of streamline in axes coordinates. 
    start_points : Nx2 array 
        Coordinates of starting points for the streamlines in data coordinates 
        (the same coordinates as the *x* and *y* arrays). 
    zorder : float 
        The zorder of the streamlines and arrows. 
        Artists with lower zorder values are drawn first. 
    maxlength : float 
        Maximum length of streamline in axes coordinates. 
    integration_direction : {'forward', 'backward', 'both'}, default: 'both' 
        Integrate the streamline in forward, backward or both directions. 
    data : indexable object, optional 
        DATA_PARAMETER_PLACEHOLDER 
    broken_streamlines : boolean, default: True 
        If False, forces streamlines to continue until they 
        leave the plot domain.  If True, they may be terminated if they 
        come too close to another streamline. 
 
    Returns 
    ------- 
    StreamplotSet 
        Container object with attributes 
 
        - ``lines``: `.LineCollection` of streamlines 
 
        - ``arrows``: `.PatchCollection` containing `.FancyArrowPatch` 
          objects representing the arrows half-way along streamlines. 
 
        This container will probably change in the future to allow changes 
        to the colormap, alpha, etc. for both lines and arrows, but these 
        changes should be backward compatible. 
    &quot;&quot;&quot;</span>
    <span class="s1">grid = Grid(x</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">mask = StreamMask(density)</span>
    <span class="s1">dmap = DomainMap(grid</span><span class="s2">, </span><span class="s1">mask)</span>

    <span class="s2">if </span><span class="s1">zorder </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">zorder = mlines.Line2D.zorder</span>

    <span class="s5"># default to data coordinates</span>
    <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">transform = axes.transData</span>

    <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">color = axes._get_lines.get_next_color()</span>

    <span class="s2">if </span><span class="s1">linewidth </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">linewidth = mpl.rcParams[</span><span class="s3">'lines.linewidth'</span><span class="s1">]</span>

    <span class="s1">line_kw = {}</span>
    <span class="s1">arrow_kw = dict(arrowstyle=arrowstyle</span><span class="s2">, </span><span class="s1">mutation_scale=</span><span class="s4">10 </span><span class="s1">* arrowsize)</span>

    <span class="s1">_api.check_in_list([</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'forward'</span><span class="s2">, </span><span class="s3">'backward'</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">integration_direction=integration_direction)</span>

    <span class="s2">if </span><span class="s1">integration_direction == </span><span class="s3">'both'</span><span class="s1">:</span>
        <span class="s1">maxlength /= </span><span class="s4">2.</span>

    <span class="s1">use_multicolor_lines = isinstance(color</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
    <span class="s2">if </span><span class="s1">use_multicolor_lines:</span>
        <span class="s2">if </span><span class="s1">color.shape != grid.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;If 'color' is given, it must match the shape of &quot;</span>
                             <span class="s3">&quot;the (x, y) grid&quot;</span><span class="s1">)</span>
        <span class="s1">line_colors = [[]]  </span><span class="s5"># Empty entry allows concatenation of zero arrays.</span>
        <span class="s1">color = np.ma.masked_invalid(color)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">line_kw[</span><span class="s3">'color'</span><span class="s1">] = color</span>
        <span class="s1">arrow_kw[</span><span class="s3">'color'</span><span class="s1">] = color</span>

    <span class="s2">if </span><span class="s1">isinstance(linewidth</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">linewidth.shape != grid.shape:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;If 'linewidth' is given, it must match the &quot;</span>
                             <span class="s3">&quot;shape of the (x, y) grid&quot;</span><span class="s1">)</span>
        <span class="s1">line_kw[</span><span class="s3">'linewidth'</span><span class="s1">] = []</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">line_kw[</span><span class="s3">'linewidth'</span><span class="s1">] = linewidth</span>
        <span class="s1">arrow_kw[</span><span class="s3">'linewidth'</span><span class="s1">] = linewidth</span>

    <span class="s1">line_kw[</span><span class="s3">'zorder'</span><span class="s1">] = zorder</span>
    <span class="s1">arrow_kw[</span><span class="s3">'zorder'</span><span class="s1">] = zorder</span>

    <span class="s5"># Sanity checks.</span>
    <span class="s2">if </span><span class="s1">u.shape != grid.shape </span><span class="s2">or </span><span class="s1">v.shape != grid.shape:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'u' and 'v' must match the shape of the (x, y) grid&quot;</span><span class="s1">)</span>

    <span class="s1">u = np.ma.masked_invalid(u)</span>
    <span class="s1">v = np.ma.masked_invalid(v)</span>

    <span class="s1">integrate = _get_integrator(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">minlength</span><span class="s2">, </span><span class="s1">maxlength</span><span class="s2">,</span>
                                <span class="s1">integration_direction)</span>

    <span class="s1">trajectories = []</span>
    <span class="s2">if </span><span class="s1">start_points </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">xm</span><span class="s2">, </span><span class="s1">ym </span><span class="s2">in </span><span class="s1">_gen_starting_points(mask.shape):</span>
            <span class="s2">if </span><span class="s1">mask[ym</span><span class="s2">, </span><span class="s1">xm] == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">xg</span><span class="s2">, </span><span class="s1">yg = dmap.mask2grid(xm</span><span class="s2">, </span><span class="s1">ym)</span>
                <span class="s1">t = integrate(xg</span><span class="s2">, </span><span class="s1">yg</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>
                <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">trajectories.append(t)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">sp2 = np.asanyarray(start_points</span><span class="s2">, </span><span class="s1">dtype=float).copy()</span>

        <span class="s5"># Check if start_points are outside the data boundaries</span>
        <span class="s2">for </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys </span><span class="s2">in </span><span class="s1">sp2:</span>
            <span class="s2">if not </span><span class="s1">(grid.x_origin &lt;= xs &lt;= grid.x_origin + grid.width </span><span class="s2">and</span>
                    <span class="s1">grid.y_origin &lt;= ys &lt;= grid.y_origin + grid.height):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Starting point ({}, {}) outside of data &quot;</span>
                                 <span class="s3">&quot;boundaries&quot;</span><span class="s1">.format(xs</span><span class="s2">, </span><span class="s1">ys))</span>

        <span class="s5"># Convert start_points from data to array coords</span>
        <span class="s5"># Shift the seed points from the bottom left of the data so that</span>
        <span class="s5"># data2grid works properly.</span>
        <span class="s1">sp2[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] -= grid.x_origin</span>
        <span class="s1">sp2[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] -= grid.y_origin</span>

        <span class="s2">for </span><span class="s1">xs</span><span class="s2">, </span><span class="s1">ys </span><span class="s2">in </span><span class="s1">sp2:</span>
            <span class="s1">xg</span><span class="s2">, </span><span class="s1">yg = dmap.data2grid(xs</span><span class="s2">, </span><span class="s1">ys)</span>
            <span class="s5"># Floating point issues can cause xg, yg to be slightly out of</span>
            <span class="s5"># bounds for xs, ys on the upper boundaries. Because we have</span>
            <span class="s5"># already checked that the starting points are within the original</span>
            <span class="s5"># grid, clip the xg, yg to the grid to work around this issue</span>
            <span class="s1">xg = np.clip(xg</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">grid.nx - </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">yg = np.clip(yg</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">grid.ny - </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">t = integrate(xg</span><span class="s2">, </span><span class="s1">yg</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">trajectories.append(t)</span>

    <span class="s2">if </span><span class="s1">use_multicolor_lines:</span>
        <span class="s2">if </span><span class="s1">norm </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">norm = mcolors.Normalize(color.min()</span><span class="s2">, </span><span class="s1">color.max())</span>
        <span class="s1">cmap = cm._ensure_cmap(cmap)</span>

    <span class="s1">streamlines = []</span>
    <span class="s1">arrows = []</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">trajectories:</span>
        <span class="s1">tgx</span><span class="s2">, </span><span class="s1">tgy = t.T</span>
        <span class="s5"># Rescale from grid-coordinates to data-coordinates.</span>
        <span class="s1">tx</span><span class="s2">, </span><span class="s1">ty = dmap.grid2data(tgx</span><span class="s2">, </span><span class="s1">tgy)</span>
        <span class="s1">tx += grid.x_origin</span>
        <span class="s1">ty += grid.y_origin</span>

        <span class="s1">points = np.transpose([tx</span><span class="s2">, </span><span class="s1">ty]).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">streamlines.extend(np.hstack([points[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">points[</span><span class="s4">1</span><span class="s1">:]]))</span>

        <span class="s5"># Add arrows halfway along each trajectory.</span>
        <span class="s1">s = np.cumsum(np.hypot(np.diff(tx)</span><span class="s2">, </span><span class="s1">np.diff(ty)))</span>
        <span class="s1">n = np.searchsorted(s</span><span class="s2">, </span><span class="s1">s[-</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">2.</span><span class="s1">)</span>
        <span class="s1">arrow_tail = (tx[n]</span><span class="s2">, </span><span class="s1">ty[n])</span>
        <span class="s1">arrow_head = (np.mean(tx[n:n + </span><span class="s4">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.mean(ty[n:n + </span><span class="s4">2</span><span class="s1">]))</span>

        <span class="s2">if </span><span class="s1">isinstance(linewidth</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s1">line_widths = interpgrid(linewidth</span><span class="s2">, </span><span class="s1">tgx</span><span class="s2">, </span><span class="s1">tgy)[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">line_kw[</span><span class="s3">'linewidth'</span><span class="s1">].extend(line_widths)</span>
            <span class="s1">arrow_kw[</span><span class="s3">'linewidth'</span><span class="s1">] = line_widths[n]</span>

        <span class="s2">if </span><span class="s1">use_multicolor_lines:</span>
            <span class="s1">color_values = interpgrid(color</span><span class="s2">, </span><span class="s1">tgx</span><span class="s2">, </span><span class="s1">tgy)[:-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">line_colors.append(color_values)</span>
            <span class="s1">arrow_kw[</span><span class="s3">'color'</span><span class="s1">] = cmap(norm(color_values[n]))</span>

        <span class="s1">p = patches.FancyArrowPatch(</span>
            <span class="s1">arrow_tail</span><span class="s2">, </span><span class="s1">arrow_head</span><span class="s2">, </span><span class="s1">transform=transform</span><span class="s2">, </span><span class="s1">**arrow_kw)</span>
        <span class="s1">arrows.append(p)</span>

    <span class="s1">lc = mcollections.LineCollection(</span>
        <span class="s1">streamlines</span><span class="s2">, </span><span class="s1">transform=transform</span><span class="s2">, </span><span class="s1">**line_kw)</span>
    <span class="s1">lc.sticky_edges.x[:] = [grid.x_origin</span><span class="s2">, </span><span class="s1">grid.x_origin + grid.width]</span>
    <span class="s1">lc.sticky_edges.y[:] = [grid.y_origin</span><span class="s2">, </span><span class="s1">grid.y_origin + grid.height]</span>
    <span class="s2">if </span><span class="s1">use_multicolor_lines:</span>
        <span class="s1">lc.set_array(np.ma.hstack(line_colors))</span>
        <span class="s1">lc.set_cmap(cmap)</span>
        <span class="s1">lc.set_norm(norm)</span>
    <span class="s1">axes.add_collection(lc)</span>

    <span class="s1">ac = mcollections.PatchCollection(arrows)</span>
    <span class="s5"># Adding the collection itself is broken; see #2341.</span>
    <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">arrows:</span>
        <span class="s1">axes.add_patch(p)</span>

    <span class="s1">axes.autoscale_view()</span>
    <span class="s1">stream_container = StreamplotSet(lc</span><span class="s2">, </span><span class="s1">ac)</span>
    <span class="s2">return </span><span class="s1">stream_container</span>


<span class="s2">class </span><span class="s1">StreamplotSet:</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">lines</span><span class="s2">, </span><span class="s1">arrows):</span>
        <span class="s1">self.lines = lines</span>
        <span class="s1">self.arrows = arrows</span>


<span class="s5"># Coordinate definitions</span>
<span class="s5"># ========================</span>

<span class="s2">class </span><span class="s1">DomainMap:</span>
    <span class="s0">&quot;&quot;&quot; 
    Map representing different coordinate systems. 
 
    Coordinate definitions: 
 
    * axes-coordinates goes from 0 to 1 in the domain. 
    * data-coordinates are specified by the input x-y coordinates. 
    * grid-coordinates goes from 0 to N and 0 to M for an N x M grid, 
      where N and M match the shape of the input data. 
    * mask-coordinates goes from 0 to N and 0 to M for an N x M mask, 
      where N and M are user-specified to control the density of streamlines. 
 
    This class also has methods for adding trajectories to the StreamMask. 
    Before adding a trajectory, run `start_trajectory` to keep track of regions 
    crossed by a given trajectory. Later, if you decide the trajectory is bad 
    (e.g., if the trajectory is very short) just call `undo_trajectory`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">grid</span><span class="s2">, </span><span class="s1">mask):</span>
        <span class="s1">self.grid = grid</span>
        <span class="s1">self.mask = mask</span>
        <span class="s5"># Constants for conversion between grid- and mask-coordinates</span>
        <span class="s1">self.x_grid2mask = (mask.nx - </span><span class="s4">1</span><span class="s1">) / (grid.nx - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.y_grid2mask = (mask.ny - </span><span class="s4">1</span><span class="s1">) / (grid.ny - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">self.x_mask2grid = </span><span class="s4">1. </span><span class="s1">/ self.x_grid2mask</span>
        <span class="s1">self.y_mask2grid = </span><span class="s4">1. </span><span class="s1">/ self.y_grid2mask</span>

        <span class="s1">self.x_data2grid = </span><span class="s4">1. </span><span class="s1">/ grid.dx</span>
        <span class="s1">self.y_data2grid = </span><span class="s4">1. </span><span class="s1">/ grid.dy</span>

    <span class="s2">def </span><span class="s1">grid2mask(self</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi):</span>
        <span class="s0">&quot;&quot;&quot;Return nearest space in mask-coords from given grid-coords.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">round(xi * self.x_grid2mask)</span><span class="s2">, </span><span class="s1">round(yi * self.y_grid2mask)</span>

    <span class="s2">def </span><span class="s1">mask2grid(self</span><span class="s2">, </span><span class="s1">xm</span><span class="s2">, </span><span class="s1">ym):</span>
        <span class="s2">return </span><span class="s1">xm * self.x_mask2grid</span><span class="s2">, </span><span class="s1">ym * self.y_mask2grid</span>

    <span class="s2">def </span><span class="s1">data2grid(self</span><span class="s2">, </span><span class="s1">xd</span><span class="s2">, </span><span class="s1">yd):</span>
        <span class="s2">return </span><span class="s1">xd * self.x_data2grid</span><span class="s2">, </span><span class="s1">yd * self.y_data2grid</span>

    <span class="s2">def </span><span class="s1">grid2data(self</span><span class="s2">, </span><span class="s1">xg</span><span class="s2">, </span><span class="s1">yg):</span>
        <span class="s2">return </span><span class="s1">xg / self.x_data2grid</span><span class="s2">, </span><span class="s1">yg / self.y_data2grid</span>

    <span class="s2">def </span><span class="s1">start_trajectory(self</span><span class="s2">, </span><span class="s1">xg</span><span class="s2">, </span><span class="s1">yg</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">xm</span><span class="s2">, </span><span class="s1">ym = self.grid2mask(xg</span><span class="s2">, </span><span class="s1">yg)</span>
        <span class="s1">self.mask._start_trajectory(xm</span><span class="s2">, </span><span class="s1">ym</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>

    <span class="s2">def </span><span class="s1">reset_start_point(self</span><span class="s2">, </span><span class="s1">xg</span><span class="s2">, </span><span class="s1">yg):</span>
        <span class="s1">xm</span><span class="s2">, </span><span class="s1">ym = self.grid2mask(xg</span><span class="s2">, </span><span class="s1">yg)</span>
        <span class="s1">self.mask._current_xy = (xm</span><span class="s2">, </span><span class="s1">ym)</span>

    <span class="s2">def </span><span class="s1">update_trajectory(self</span><span class="s2">, </span><span class="s1">xg</span><span class="s2">, </span><span class="s1">yg</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">self.grid.within_grid(xg</span><span class="s2">, </span><span class="s1">yg):</span>
            <span class="s2">raise </span><span class="s1">InvalidIndexError</span>
        <span class="s1">xm</span><span class="s2">, </span><span class="s1">ym = self.grid2mask(xg</span><span class="s2">, </span><span class="s1">yg)</span>
        <span class="s1">self.mask._update_trajectory(xm</span><span class="s2">, </span><span class="s1">ym</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>

    <span class="s2">def </span><span class="s1">undo_trajectory(self):</span>
        <span class="s1">self.mask._undo_trajectory()</span>


<span class="s2">class </span><span class="s1">Grid:</span>
    <span class="s0">&quot;&quot;&quot;Grid of data.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y):</span>

        <span class="s2">if </span><span class="s1">np.ndim(x) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">np.ndim(x) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">x_row = x[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">np.allclose(x_row</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The rows of 'x' must be equal&quot;</span><span class="s1">)</span>
            <span class="s1">x = x_row</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'x' can have at maximum 2 dimensions&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">np.ndim(y) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">np.ndim(y) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">yt = np.transpose(y)  </span><span class="s5"># Also works for nested lists.</span>
            <span class="s1">y_col = yt[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if not </span><span class="s1">np.allclose(y_col</span><span class="s2">, </span><span class="s1">yt):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The columns of 'y' must be equal&quot;</span><span class="s1">)</span>
            <span class="s1">y = y_col</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'y' can have at maximum 2 dimensions&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">(np.diff(x) &gt; </span><span class="s4">0</span><span class="s1">).all():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'x' must be strictly increasing&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(np.diff(y) &gt; </span><span class="s4">0</span><span class="s1">).all():</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'y' must be strictly increasing&quot;</span><span class="s1">)</span>

        <span class="s1">self.nx = len(x)</span>
        <span class="s1">self.ny = len(y)</span>

        <span class="s1">self.dx = x[</span><span class="s4">1</span><span class="s1">] - x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.dy = y[</span><span class="s4">1</span><span class="s1">] - y[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">self.x_origin = x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.y_origin = y[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">self.width = x[-</span><span class="s4">1</span><span class="s1">] - x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.height = y[-</span><span class="s4">1</span><span class="s1">] - y[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">np.allclose(np.diff(x)</span><span class="s2">, </span><span class="s1">self.width / (self.nx - </span><span class="s4">1</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'x' values must be equally spaced&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">np.allclose(np.diff(y)</span><span class="s2">, </span><span class="s1">self.height / (self.ny - </span><span class="s4">1</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'y' values must be equally spaced&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">shape(self):</span>
        <span class="s2">return </span><span class="s1">self.ny</span><span class="s2">, </span><span class="s1">self.nx</span>

    <span class="s2">def </span><span class="s1">within_grid(self</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi):</span>
        <span class="s0">&quot;&quot;&quot;Return whether (*xi*, *yi*) is a valid index of the grid.&quot;&quot;&quot;</span>
        <span class="s5"># Note that xi/yi can be floats; so, for example, we can't simply check</span>
        <span class="s5"># `xi &lt; self.nx` since *xi* can be `self.nx - 1 &lt; xi &lt; self.nx`</span>
        <span class="s2">return </span><span class="s4">0 </span><span class="s1">&lt;= xi &lt;= self.nx - </span><span class="s4">1 </span><span class="s2">and </span><span class="s4">0 </span><span class="s1">&lt;= yi &lt;= self.ny - </span><span class="s4">1</span>


<span class="s2">class </span><span class="s1">StreamMask:</span>
    <span class="s0">&quot;&quot;&quot; 
    Mask to keep track of discrete regions crossed by streamlines. 
 
    The resolution of this grid determines the approximate spacing between 
    trajectories. Streamlines are only allowed to pass through zeroed cells: 
    When a streamline enters a cell, that cell is set to 1, and no new 
    streamlines are allowed to enter. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">density):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.nx</span><span class="s2">, </span><span class="s1">self.ny = (</span><span class="s4">30 </span><span class="s1">* np.broadcast_to(density</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)).astype(int)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'density' must be a scalar or be of length &quot;</span>
                             <span class="s3">&quot;2&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">if </span><span class="s1">self.nx &lt; </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self.ny &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'density' must be positive&quot;</span><span class="s1">)</span>
        <span class="s1">self._mask = np.zeros((self.ny</span><span class="s2">, </span><span class="s1">self.nx))</span>
        <span class="s1">self.shape = self._mask.shape</span>

        <span class="s1">self._current_xy = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s2">return </span><span class="s1">self._mask[args]</span>

    <span class="s2">def </span><span class="s1">_start_trajectory(self</span><span class="s2">, </span><span class="s1">xm</span><span class="s2">, </span><span class="s1">ym</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Start recording streamline trajectory&quot;&quot;&quot;</span>
        <span class="s1">self._traj = []</span>
        <span class="s1">self._update_trajectory(xm</span><span class="s2">, </span><span class="s1">ym</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>

    <span class="s2">def </span><span class="s1">_undo_trajectory(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove current trajectory from mask&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self._traj:</span>
            <span class="s1">self._mask[t] = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">_update_trajectory(self</span><span class="s2">, </span><span class="s1">xm</span><span class="s2">, </span><span class="s1">ym</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update current trajectory position in mask. 
 
        If the new position has already been filled, raise `InvalidIndexError`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._current_xy != (xm</span><span class="s2">, </span><span class="s1">ym):</span>
            <span class="s2">if </span><span class="s1">self[ym</span><span class="s2">, </span><span class="s1">xm] == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._traj.append((ym</span><span class="s2">, </span><span class="s1">xm))</span>
                <span class="s1">self._mask[ym</span><span class="s2">, </span><span class="s1">xm] = </span><span class="s4">1</span>
                <span class="s1">self._current_xy = (xm</span><span class="s2">, </span><span class="s1">ym)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">broken_streamlines:</span>
                    <span class="s2">raise </span><span class="s1">InvalidIndexError</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">InvalidIndexError(Exception):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TerminateTrajectory(Exception):</span>
    <span class="s2">pass</span>


<span class="s5"># Integrator definitions</span>
<span class="s5"># =======================</span>

<span class="s2">def </span><span class="s1">_get_integrator(u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">minlength</span><span class="s2">, </span><span class="s1">maxlength</span><span class="s2">, </span><span class="s1">integration_direction):</span>

    <span class="s5"># rescale velocity onto grid-coordinates for integrations.</span>
    <span class="s1">u</span><span class="s2">, </span><span class="s1">v = dmap.data2grid(u</span><span class="s2">, </span><span class="s1">v)</span>

    <span class="s5"># speed (path length) will be in axes-coordinates</span>
    <span class="s1">u_ax = u / (dmap.grid.nx - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">v_ax = v / (dmap.grid.ny - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">speed = np.ma.sqrt(u_ax ** </span><span class="s4">2 </span><span class="s1">+ v_ax ** </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">forward_time(xi</span><span class="s2">, </span><span class="s1">yi):</span>
        <span class="s2">if not </span><span class="s1">dmap.grid.within_grid(xi</span><span class="s2">, </span><span class="s1">yi):</span>
            <span class="s2">raise </span><span class="s1">OutOfBounds</span>
        <span class="s1">ds_dt = interpgrid(speed</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi)</span>
        <span class="s2">if </span><span class="s1">ds_dt == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TerminateTrajectory()</span>
        <span class="s1">dt_ds = </span><span class="s4">1. </span><span class="s1">/ ds_dt</span>
        <span class="s1">ui = interpgrid(u</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi)</span>
        <span class="s1">vi = interpgrid(v</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi)</span>
        <span class="s2">return </span><span class="s1">ui * dt_ds</span><span class="s2">, </span><span class="s1">vi * dt_ds</span>

    <span class="s2">def </span><span class="s1">backward_time(xi</span><span class="s2">, </span><span class="s1">yi):</span>
        <span class="s1">dxi</span><span class="s2">, </span><span class="s1">dyi = forward_time(xi</span><span class="s2">, </span><span class="s1">yi)</span>
        <span class="s2">return </span><span class="s1">-dxi</span><span class="s2">, </span><span class="s1">-dyi</span>

    <span class="s2">def </span><span class="s1">integrate(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return x, y grid-coordinates of trajectory based on starting point. 
 
        Integrate both forward and backward in time from starting point in 
        grid coordinates. 
 
        Integration is terminated when a trajectory reaches a domain boundary 
        or when it crosses into an already occupied cell in the StreamMask. The 
        resulting trajectory is None if it is shorter than `minlength`. 
        &quot;&quot;&quot;</span>

        <span class="s1">stotal</span><span class="s2">, </span><span class="s1">xy_traj = </span><span class="s4">0.</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dmap.start_trajectory(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>
        <span class="s2">except </span><span class="s1">InvalidIndexError:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">integration_direction </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'backward'</span><span class="s1">]:</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">xyt = _integrate_rk12(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">backward_time</span><span class="s2">, </span><span class="s1">maxlength</span><span class="s2">,</span>
                                     <span class="s1">broken_streamlines)</span>
            <span class="s1">stotal += s</span>
            <span class="s1">xy_traj += xyt[::-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">integration_direction </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'both'</span><span class="s2">, </span><span class="s3">'forward'</span><span class="s1">]:</span>
            <span class="s1">dmap.reset_start_point(x0</span><span class="s2">, </span><span class="s1">y0)</span>
            <span class="s1">s</span><span class="s2">, </span><span class="s1">xyt = _integrate_rk12(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">forward_time</span><span class="s2">, </span><span class="s1">maxlength</span><span class="s2">,</span>
                                     <span class="s1">broken_streamlines)</span>
            <span class="s1">stotal += s</span>
            <span class="s1">xy_traj += xyt[</span><span class="s4">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">stotal &gt; minlength:</span>
            <span class="s2">return </span><span class="s1">np.broadcast_arrays(xy_traj</span><span class="s2">, </span><span class="s1">np.empty((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)))[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># reject short trajectories</span>
            <span class="s1">dmap.undo_trajectory()</span>
            <span class="s2">return None</span>

    <span class="s2">return </span><span class="s1">integrate</span>


<span class="s2">class </span><span class="s1">OutOfBounds(IndexError):</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_integrate_rk12(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">maxlength</span><span class="s2">, </span><span class="s1">broken_streamlines=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    2nd-order Runge-Kutta algorithm with adaptive step size. 
 
    This method is also referred to as the improved Euler's method, or Heun's 
    method. This method is favored over higher-order methods because: 
 
    1. To get decent looking trajectories and to sample every mask cell 
       on the trajectory we need a small timestep, so a lower order 
       solver doesn't hurt us unless the data is *very* high resolution. 
       In fact, for cases where the user inputs 
       data smaller or of similar grid size to the mask grid, the higher 
       order corrections are negligible because of the very fast linear 
       interpolation used in `interpgrid`. 
 
    2. For high resolution input data (i.e. beyond the mask 
       resolution), we must reduce the timestep. Therefore, an adaptive 
       timestep is more suited to the problem as this would be very hard 
       to judge automatically otherwise. 
 
    This integrator is about 1.5 - 2x as fast as RK4 and RK45 solvers (using 
    similar Python implementations) in most setups. 
    &quot;&quot;&quot;</span>
    <span class="s5"># This error is below that needed to match the RK4 integrator. It</span>
    <span class="s5"># is set for visual reasons -- too low and corners start</span>
    <span class="s5"># appearing ugly and jagged. Can be tuned.</span>
    <span class="s1">maxerror = </span><span class="s4">0.003</span>

    <span class="s5"># This limit is important (for all integrators) to avoid the</span>
    <span class="s5"># trajectory skipping some mask cells. We could relax this</span>
    <span class="s5"># condition if we use the code which is commented out below to</span>
    <span class="s5"># increment the location gradually. However, due to the efficient</span>
    <span class="s5"># nature of the interpolation, this doesn't boost speed by much</span>
    <span class="s5"># for quite a bit of complexity.</span>
    <span class="s1">maxds = min(</span><span class="s4">1. </span><span class="s1">/ dmap.mask.nx</span><span class="s2">, </span><span class="s4">1. </span><span class="s1">/ dmap.mask.ny</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s1">ds = maxds</span>
    <span class="s1">stotal = </span><span class="s4">0</span>
    <span class="s1">xi = x0</span>
    <span class="s1">yi = y0</span>
    <span class="s1">xyf_traj = []</span>

    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">dmap.grid.within_grid(xi</span><span class="s2">, </span><span class="s1">yi):</span>
                <span class="s1">xyf_traj.append((xi</span><span class="s2">, </span><span class="s1">yi))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">OutOfBounds</span>

            <span class="s5"># Compute the two intermediate gradients.</span>
            <span class="s5"># f should raise OutOfBounds if the locations given are</span>
            <span class="s5"># outside the grid.</span>
            <span class="s1">k1x</span><span class="s2">, </span><span class="s1">k1y = f(xi</span><span class="s2">, </span><span class="s1">yi)</span>
            <span class="s1">k2x</span><span class="s2">, </span><span class="s1">k2y = f(xi + ds * k1x</span><span class="s2">, </span><span class="s1">yi + ds * k1y)</span>

        <span class="s2">except </span><span class="s1">OutOfBounds:</span>
            <span class="s5"># Out of the domain during this step.</span>
            <span class="s5"># Take an Euler step to the boundary to improve neatness</span>
            <span class="s5"># unless the trajectory is currently empty.</span>
            <span class="s2">if </span><span class="s1">xyf_traj:</span>
                <span class="s1">ds</span><span class="s2">, </span><span class="s1">xyf_traj = _euler_step(xyf_traj</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">f)</span>
                <span class="s1">stotal += ds</span>
            <span class="s2">break</span>
        <span class="s2">except </span><span class="s1">TerminateTrajectory:</span>
            <span class="s2">break</span>

        <span class="s1">dx1 = ds * k1x</span>
        <span class="s1">dy1 = ds * k1y</span>
        <span class="s1">dx2 = ds * </span><span class="s4">0.5 </span><span class="s1">* (k1x + k2x)</span>
        <span class="s1">dy2 = ds * </span><span class="s4">0.5 </span><span class="s1">* (k1y + k2y)</span>

        <span class="s1">ny</span><span class="s2">, </span><span class="s1">nx = dmap.grid.shape</span>
        <span class="s5"># Error is normalized to the axes coordinates</span>
        <span class="s1">error = np.hypot((dx2 - dx1) / (nx - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(dy2 - dy1) / (ny - </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s5"># Only save step if within error tolerance</span>
        <span class="s2">if </span><span class="s1">error &lt; maxerror:</span>
            <span class="s1">xi += dx2</span>
            <span class="s1">yi += dy2</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">dmap.update_trajectory(xi</span><span class="s2">, </span><span class="s1">yi</span><span class="s2">, </span><span class="s1">broken_streamlines)</span>
            <span class="s2">except </span><span class="s1">InvalidIndexError:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">stotal + ds &gt; maxlength:</span>
                <span class="s2">break</span>
            <span class="s1">stotal += ds</span>

        <span class="s5"># recalculate stepsize based on step error</span>
        <span class="s2">if </span><span class="s1">error == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">ds = maxds</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ds = min(maxds</span><span class="s2">, </span><span class="s4">0.85 </span><span class="s1">* ds * (maxerror / error) ** </span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">stotal</span><span class="s2">, </span><span class="s1">xyf_traj</span>


<span class="s2">def </span><span class="s1">_euler_step(xyf_traj</span><span class="s2">, </span><span class="s1">dmap</span><span class="s2">, </span><span class="s1">f):</span>
    <span class="s0">&quot;&quot;&quot;Simple Euler integration step that extends streamline to boundary.&quot;&quot;&quot;</span>
    <span class="s1">ny</span><span class="s2">, </span><span class="s1">nx = dmap.grid.shape</span>
    <span class="s1">xi</span><span class="s2">, </span><span class="s1">yi = xyf_traj[-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">cx</span><span class="s2">, </span><span class="s1">cy = f(xi</span><span class="s2">, </span><span class="s1">yi)</span>
    <span class="s2">if </span><span class="s1">cx == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dsx = np.inf</span>
    <span class="s2">elif </span><span class="s1">cx &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dsx = xi / -cx</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dsx = (nx - </span><span class="s4">1 </span><span class="s1">- xi) / cx</span>
    <span class="s2">if </span><span class="s1">cy == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dsy = np.inf</span>
    <span class="s2">elif </span><span class="s1">cy &lt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dsy = yi / -cy</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dsy = (ny - </span><span class="s4">1 </span><span class="s1">- yi) / cy</span>
    <span class="s1">ds = min(dsx</span><span class="s2">, </span><span class="s1">dsy)</span>
    <span class="s1">xyf_traj.append((xi + cx * ds</span><span class="s2">, </span><span class="s1">yi + cy * ds))</span>
    <span class="s2">return </span><span class="s1">ds</span><span class="s2">, </span><span class="s1">xyf_traj</span>


<span class="s5"># Utility functions</span>
<span class="s5"># ========================</span>

<span class="s2">def </span><span class="s1">interpgrid(a</span><span class="s2">, </span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yi):</span>
    <span class="s0">&quot;&quot;&quot;Fast 2D, linear interpolation on an integer grid&quot;&quot;&quot;</span>

    <span class="s1">Ny</span><span class="s2">, </span><span class="s1">Nx = np.shape(a)</span>
    <span class="s2">if </span><span class="s1">isinstance(xi</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">x = xi.astype(int)</span>
        <span class="s1">y = yi.astype(int)</span>
        <span class="s5"># Check that xn, yn don't exceed max index</span>
        <span class="s1">xn = np.clip(x + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">Nx - </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">yn = np.clip(y + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">Ny - </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x = int(xi)</span>
        <span class="s1">y = int(yi)</span>
        <span class="s5"># conditional is faster than clipping for integers</span>
        <span class="s2">if </span><span class="s1">x == (Nx - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">xn = x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xn = x + </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">y == (Ny - </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">yn = y</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">yn = y + </span><span class="s4">1</span>

    <span class="s1">a00 = a[y</span><span class="s2">, </span><span class="s1">x]</span>
    <span class="s1">a01 = a[y</span><span class="s2">, </span><span class="s1">xn]</span>
    <span class="s1">a10 = a[yn</span><span class="s2">, </span><span class="s1">x]</span>
    <span class="s1">a11 = a[yn</span><span class="s2">, </span><span class="s1">xn]</span>
    <span class="s1">xt = xi - x</span>
    <span class="s1">yt = yi - y</span>
    <span class="s1">a0 = a00 * (</span><span class="s4">1 </span><span class="s1">- xt) + a01 * xt</span>
    <span class="s1">a1 = a10 * (</span><span class="s4">1 </span><span class="s1">- xt) + a11 * xt</span>
    <span class="s1">ai = a0 * (</span><span class="s4">1 </span><span class="s1">- yt) + a1 * yt</span>

    <span class="s2">if not </span><span class="s1">isinstance(xi</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s2">if </span><span class="s1">np.ma.is_masked(ai):</span>
            <span class="s2">raise </span><span class="s1">TerminateTrajectory</span>

    <span class="s2">return </span><span class="s1">ai</span>


<span class="s2">def </span><span class="s1">_gen_starting_points(shape):</span>
    <span class="s0">&quot;&quot;&quot; 
    Yield starting points for streamlines. 
 
    Trying points on the boundary first gives higher quality streamlines. 
    This algorithm starts with a point on the mask corner and spirals inward. 
    This algorithm is inefficient, but fast compared to rest of streamplot. 
    &quot;&quot;&quot;</span>
    <span class="s1">ny</span><span class="s2">, </span><span class="s1">nx = shape</span>
    <span class="s1">xfirst = </span><span class="s4">0</span>
    <span class="s1">yfirst = </span><span class="s4">1</span>
    <span class="s1">xlast = nx - </span><span class="s4">1</span>
    <span class="s1">ylast = ny - </span><span class="s4">1</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">y = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span>
    <span class="s1">direction = </span><span class="s3">'right'</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(nx * ny):</span>
        <span class="s2">yield </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>

        <span class="s2">if </span><span class="s1">direction == </span><span class="s3">'right'</span><span class="s1">:</span>
            <span class="s1">x += </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">x &gt;= xlast:</span>
                <span class="s1">xlast -= </span><span class="s4">1</span>
                <span class="s1">direction = </span><span class="s3">'up'</span>
        <span class="s2">elif </span><span class="s1">direction == </span><span class="s3">'up'</span><span class="s1">:</span>
            <span class="s1">y += </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">y &gt;= ylast:</span>
                <span class="s1">ylast -= </span><span class="s4">1</span>
                <span class="s1">direction = </span><span class="s3">'left'</span>
        <span class="s2">elif </span><span class="s1">direction == </span><span class="s3">'left'</span><span class="s1">:</span>
            <span class="s1">x -= </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">x &lt;= xfirst:</span>
                <span class="s1">xfirst += </span><span class="s4">1</span>
                <span class="s1">direction = </span><span class="s3">'down'</span>
        <span class="s2">elif </span><span class="s1">direction == </span><span class="s3">'down'</span><span class="s1">:</span>
            <span class="s1">y -= </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">y &lt;= yfirst:</span>
                <span class="s1">yfirst += </span><span class="s4">1</span>
                <span class="s1">direction = </span><span class="s3">'right'</span>
</pre>
</body>
</html>