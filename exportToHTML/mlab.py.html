<html>
<head>
<title>mlab.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mlab.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Numerical Python functions written for compatibility with MATLAB 
commands with the same names. Most numerical Python functions can be found in 
the `NumPy`_ and `SciPy`_ libraries. What remains here is code for performing 
spectral computations and kernel density estimations. 
 
.. _NumPy: https://numpy.org 
.. _SciPy: https://www.scipy.org 
 
Spectral functions 
------------------ 
 
`cohere` 
    Coherence (normalized cross spectral density) 
 
`csd` 
    Cross spectral density using Welch's average periodogram 
 
`detrend` 
    Remove the mean or best fit line from an array 
 
`psd` 
    Power spectral density using Welch's average periodogram 
 
`specgram` 
    Spectrogram (spectrum over segments of time) 
 
`complex_spectrum` 
    Return the complex-valued frequency spectrum of a signal 
 
`magnitude_spectrum` 
    Return the magnitude of the frequency spectrum of a signal 
 
`angle_spectrum` 
    Return the angle (wrapped phase) of the frequency spectrum of a signal 
 
`phase_spectrum` 
    Return the phase (unwrapped angle) of the frequency spectrum of a signal 
 
`detrend_mean` 
    Remove the mean from a line. 
 
`detrend_linear` 
    Remove the best fit line from a line. 
 
`detrend_none` 
    Return the original line. 
 
`stride_windows` 
    Get all windows in an array in a memory-efficient manner 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">, </span><span class="s1">cbook</span>


<span class="s2">def </span><span class="s1">window_hanning(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *x* times the Hanning (or Hann) window of len(*x*). 
 
    See Also 
    -------- 
    window_none : Another window algorithm. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np.hanning(len(x))*x</span>


<span class="s2">def </span><span class="s1">window_none(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    No window function; simply return *x*. 
 
    See Also 
    -------- 
    window_hanning : Another window algorithm. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">detrend(x</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *x* with its trend removed. 
 
    Parameters 
    ---------- 
    x : array or sequence 
        Array or sequence containing the data. 
 
    key : {'default', 'constant', 'mean', 'linear', 'none'} or function 
        The detrending algorithm to use. 'default', 'mean', and 'constant' are 
        the same as `detrend_mean`. 'linear' is the same as `detrend_linear`. 
        'none' is the same as `detrend_none`. The default is 'mean'. See the 
        corresponding functions for more details regarding the algorithms. Can 
        also be a function that carries out the detrend operation. 
 
    axis : int 
        The axis along which to do the detrending. 
 
    See Also 
    -------- 
    detrend_mean : Implementation of the 'mean' algorithm. 
    detrend_linear : Implementation of the 'linear' algorithm. 
    detrend_none : Implementation of the 'none' algorithm. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">key </span><span class="s2">is None or </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'constant'</span><span class="s2">, </span><span class="s3">'mean'</span><span class="s2">, </span><span class="s3">'default'</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">detrend(x</span><span class="s2">, </span><span class="s1">key=detrend_mean</span><span class="s2">, </span><span class="s1">axis=axis)</span>
    <span class="s2">elif </span><span class="s1">key == </span><span class="s3">'linear'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">detrend(x</span><span class="s2">, </span><span class="s1">key=detrend_linear</span><span class="s2">, </span><span class="s1">axis=axis)</span>
    <span class="s2">elif </span><span class="s1">key == </span><span class="s3">'none'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">detrend(x</span><span class="s2">, </span><span class="s1">key=detrend_none</span><span class="s2">, </span><span class="s1">axis=axis)</span>
    <span class="s2">elif </span><span class="s1">callable(key):</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None and </span><span class="s1">axis + </span><span class="s4">1 </span><span class="s1">&gt; x.ndim:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f'axis(=</span><span class="s2">{</span><span class="s1">axis</span><span class="s2">}</span><span class="s3">) out of bounds'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(axis </span><span class="s2">is None and </span><span class="s1">x.ndim == </span><span class="s4">0</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">axis </span><span class="s2">and </span><span class="s1">x.ndim == </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">key(x)</span>
        <span class="s5"># try to use the 'axis' argument if the function supports it,</span>
        <span class="s5"># otherwise use apply_along_axis to do it</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">key(x</span><span class="s2">, </span><span class="s1">axis=axis)</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">return </span><span class="s1">np.apply_along_axis(key</span><span class="s2">, </span><span class="s1">axis=axis</span><span class="s2">, </span><span class="s1">arr=x)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">f&quot;Unknown value for key: </span><span class="s2">{</span><span class="s1">key</span><span class="s2">!r}</span><span class="s3">, must be one of: 'default', &quot;</span>
            <span class="s3">f&quot;'constant', 'mean', 'linear', or a function&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">detrend_mean(x</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *x* minus the mean(*x*). 
 
    Parameters 
    ---------- 
    x : array or sequence 
        Array or sequence containing the data 
        Can have any dimensionality 
 
    axis : int 
        The axis along which to take the mean.  See `numpy.mean` for a 
        description of this argument. 
 
    See Also 
    -------- 
    detrend_linear : Another detrend algorithm. 
    detrend_none : Another detrend algorithm. 
    detrend : A wrapper around all the detrend algorithms. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x)</span>

    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None and </span><span class="s1">axis+</span><span class="s4">1 </span><span class="s1">&gt; x.ndim:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'axis(=%s) out of bounds' </span><span class="s1">% axis)</span>

    <span class="s2">return </span><span class="s1">x - x.mean(axis</span><span class="s2">, </span><span class="s1">keepdims=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">detrend_none(x</span><span class="s2">, </span><span class="s1">axis=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *x*: no detrending. 
 
    Parameters 
    ---------- 
    x : any object 
        An object containing the data 
 
    axis : int 
        This parameter is ignored. 
        It is included for compatibility with detrend_mean 
 
    See Also 
    -------- 
    detrend_mean : Another detrend algorithm. 
    detrend_linear : Another detrend algorithm. 
    detrend : A wrapper around all the detrend algorithms. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">detrend_linear(y):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *x* minus best fit line; 'linear' detrending. 
 
    Parameters 
    ---------- 
    y : 0-D or 1-D array or sequence 
        Array or sequence containing the data 
 
    See Also 
    -------- 
    detrend_mean : Another detrend algorithm. 
    detrend_none : Another detrend algorithm. 
    detrend : A wrapper around all the detrend algorithms. 
    &quot;&quot;&quot;</span>
    <span class="s5"># This is faster than an algorithm based on linalg.lstsq.</span>
    <span class="s1">y = np.asarray(y)</span>

    <span class="s2">if </span><span class="s1">y.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'y cannot have ndim &gt; 1'</span><span class="s1">)</span>

    <span class="s5"># short-circuit 0-D array.</span>
    <span class="s2">if not </span><span class="s1">y.ndim:</span>
        <span class="s2">return </span><span class="s1">np.array(</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">dtype=y.dtype)</span>

    <span class="s1">x = np.arange(y.size</span><span class="s2">, </span><span class="s1">dtype=float)</span>

    <span class="s1">C = np.cov(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">bias=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">b = C[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]/C[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">a = y.mean() - b*x.mean()</span>
    <span class="s2">return </span><span class="s1">y - (b*x + a)</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">stride_windows(x</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get all windows of *x* with length *n* as a single array, 
    using strides to avoid data duplication. 
 
    .. warning:: 
 
        It is not safe to write to the output array.  Multiple 
        elements may point to the same piece of memory, 
        so modifying one value may change others. 
 
    Parameters 
    ---------- 
    x : 1D array or sequence 
        Array or sequence containing the data. 
    n : int 
        The number of data points in each window. 
    noverlap : int, default: 0 (no overlap) 
        The overlap between adjacent windows. 
    axis : int 
        The axis along which the windows will run. 
 
    References 
    ---------- 
    `stackoverflow: Rolling window for 1D arrays in Numpy? 
    &lt;https://stackoverflow.com/a/6811241&gt;`_ 
    `stackoverflow: Using strides for an efficient moving average filter 
    &lt;https://stackoverflow.com/a/4947453&gt;`_ 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">np.ndim(x) != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'only 1-dimensional arrays can be used'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_stride_windows(x</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">axis)</span>


<span class="s2">def </span><span class="s1">_stride_windows(x</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">noverlap=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5"># np&gt;=1.20 provides sliding_window_view, and we only ever use axis=0.</span>
    <span class="s2">if </span><span class="s1">hasattr(np.lib.stride_tricks</span><span class="s2">, </span><span class="s3">&quot;sliding_window_view&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">noverlap &gt;= n:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than n'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">np.lib.stride_tricks.sliding_window_view(</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)[::n - noverlap].T</span>

    <span class="s2">if </span><span class="s1">noverlap &gt;= n:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'noverlap must be less than n'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">n &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'n cannot be less than 1'</span><span class="s1">)</span>

    <span class="s1">x = np.asarray(x)</span>

    <span class="s2">if </span><span class="s1">n == </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">noverlap == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x[np.newaxis]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x[np.newaxis].T</span>
    <span class="s2">if </span><span class="s1">n &gt; x.size:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'n cannot be greater than the length of x'</span><span class="s1">)</span>

    <span class="s5"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="s5"># non integer shape and strides, i.e. noverlap or n. See #3845.</span>
    <span class="s1">noverlap = int(noverlap)</span>
    <span class="s1">n = int(n)</span>

    <span class="s1">step = n - noverlap</span>
    <span class="s2">if </span><span class="s1">axis == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">shape = (n</span><span class="s2">, </span><span class="s1">(x.shape[-</span><span class="s4">1</span><span class="s1">]-noverlap)//step)</span>
        <span class="s1">strides = (x.strides[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">step*x.strides[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">shape = ((x.shape[-</span><span class="s4">1</span><span class="s1">]-noverlap)//step</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s1">strides = (step*x.strides[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x.strides[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">np.lib.stride_tricks.as_strided(x</span><span class="s2">, </span><span class="s1">shape=shape</span><span class="s2">, </span><span class="s1">strides=strides)</span>


<span class="s2">def </span><span class="s1">_spectral_helper(x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">NFFT=</span><span class="s2">None, </span><span class="s1">Fs=</span><span class="s2">None, </span><span class="s1">detrend_func=</span><span class="s2">None,</span>
                     <span class="s1">window=</span><span class="s2">None, </span><span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">pad_to=</span><span class="s2">None,</span>
                     <span class="s1">sides=</span><span class="s2">None, </span><span class="s1">scale_by_freq=</span><span class="s2">None, </span><span class="s1">mode=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private helper implementing the common parts between the psd, csd, 
    spectrogram and complex, magnitude, angle, and phase spectrums. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">y </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s5"># if y is None use x for y</span>
        <span class="s1">same_data = </span><span class="s2">True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s5"># The checks for if y is x are so that we can use the same function to</span>
        <span class="s5"># implement the core of psd(), csd(), and spectrogram() without doing</span>
        <span class="s5"># extra calculations.  We return the unaveraged Pxy, freqs, and t.</span>
        <span class="s1">same_data = y </span><span class="s2">is </span><span class="s1">x</span>

    <span class="s2">if </span><span class="s1">Fs </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">Fs = </span><span class="s4">2</span>
    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = </span><span class="s4">0</span>
    <span class="s2">if </span><span class="s1">detrend_func </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">detrend_func = detrend_none</span>
    <span class="s2">if </span><span class="s1">window </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">window = window_hanning</span>

    <span class="s5"># if NFFT is set to None use the whole signal</span>
    <span class="s2">if </span><span class="s1">NFFT </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">NFFT = </span><span class="s4">256</span>

    <span class="s2">if </span><span class="s1">mode </span><span class="s2">is None or </span><span class="s1">mode == </span><span class="s3">'default'</span><span class="s1">:</span>
        <span class="s1">mode = </span><span class="s3">'psd'</span>
    <span class="s1">_api.check_in_list(</span>
        <span class="s1">[</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'psd'</span><span class="s2">, </span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'magnitude'</span><span class="s2">, </span><span class="s3">'angle'</span><span class="s2">, </span><span class="s3">'phase'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mode=mode)</span>

    <span class="s2">if not </span><span class="s1">same_data </span><span class="s2">and </span><span class="s1">mode != </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;x and y must be equal if mode is not 'psd'&quot;</span><span class="s1">)</span>

    <span class="s5"># Make sure we're dealing with a numpy array. If y and x were the same</span>
    <span class="s5"># object to start with, keep them that way</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s1">y = np.asarray(y)</span>

    <span class="s2">if </span><span class="s1">sides </span><span class="s2">is None or </span><span class="s1">sides == </span><span class="s3">'default'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.iscomplexobj(x):</span>
            <span class="s1">sides = </span><span class="s3">'twosided'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sides = </span><span class="s3">'onesided'</span>
    <span class="s1">_api.check_in_list([</span><span class="s3">'default'</span><span class="s2">, </span><span class="s3">'onesided'</span><span class="s2">, </span><span class="s3">'twosided'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sides=sides)</span>

    <span class="s5"># zero pad x and y up to NFFT if they are shorter than NFFT</span>
    <span class="s2">if </span><span class="s1">len(x) &lt; NFFT:</span>
        <span class="s1">n = len(x)</span>
        <span class="s1">x = np.resize(x</span><span class="s2">, </span><span class="s1">NFFT)</span>
        <span class="s1">x[n:] = </span><span class="s4">0</span>

    <span class="s2">if not </span><span class="s1">same_data </span><span class="s2">and </span><span class="s1">len(y) &lt; NFFT:</span>
        <span class="s1">n = len(y)</span>
        <span class="s1">y = np.resize(y</span><span class="s2">, </span><span class="s1">NFFT)</span>
        <span class="s1">y[n:] = </span><span class="s4">0</span>

    <span class="s2">if </span><span class="s1">pad_to </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">pad_to = NFFT</span>

    <span class="s2">if </span><span class="s1">mode != </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">scale_by_freq = </span><span class="s2">False</span>
    <span class="s2">elif </span><span class="s1">scale_by_freq </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">scale_by_freq = </span><span class="s2">True</span>

    <span class="s5"># For real x, ignore the negative frequencies unless told otherwise</span>
    <span class="s2">if </span><span class="s1">sides == </span><span class="s3">'twosided'</span><span class="s1">:</span>
        <span class="s1">numFreqs = pad_to</span>
        <span class="s2">if </span><span class="s1">pad_to % </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">freqcenter = (pad_to - </span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">freqcenter = pad_to//</span><span class="s4">2</span>
        <span class="s1">scaling_factor = </span><span class="s4">1.</span>
    <span class="s2">elif </span><span class="s1">sides == </span><span class="s3">'onesided'</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">pad_to % </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">numFreqs = (pad_to + </span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">numFreqs = pad_to//</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span>
        <span class="s1">scaling_factor = </span><span class="s4">2.</span>

    <span class="s2">if not </span><span class="s1">np.iterable(window):</span>
        <span class="s1">window = window(np.ones(NFFT</span><span class="s2">, </span><span class="s1">x.dtype))</span>
    <span class="s2">if </span><span class="s1">len(window) != NFFT:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;The window length must match the data's first dimension&quot;</span><span class="s1">)</span>

    <span class="s1">result = _stride_windows(x</span><span class="s2">, </span><span class="s1">NFFT</span><span class="s2">, </span><span class="s1">noverlap)</span>
    <span class="s1">result = detrend(result</span><span class="s2">, </span><span class="s1">detrend_func</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">result = result * window.reshape((-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">result = np.fft.fft(result</span><span class="s2">, </span><span class="s1">n=pad_to</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)[:numFreqs</span><span class="s2">, </span><span class="s1">:]</span>
    <span class="s1">freqs = np.fft.fftfreq(pad_to</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/Fs)[:numFreqs]</span>

    <span class="s2">if not </span><span class="s1">same_data:</span>
        <span class="s5"># if same_data is False, mode must be 'psd'</span>
        <span class="s1">resultY = _stride_windows(y</span><span class="s2">, </span><span class="s1">NFFT</span><span class="s2">, </span><span class="s1">noverlap)</span>
        <span class="s1">resultY = detrend(resultY</span><span class="s2">, </span><span class="s1">detrend_func</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">resultY = resultY * window.reshape((-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">resultY = np.fft.fft(resultY</span><span class="s2">, </span><span class="s1">n=pad_to</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)[:numFreqs</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">result = np.conj(result) * resultY</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'psd'</span><span class="s1">:</span>
        <span class="s1">result = np.conj(result) * result</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'magnitude'</span><span class="s1">:</span>
        <span class="s1">result = np.abs(result) / window.sum()</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'angle' </span><span class="s2">or </span><span class="s1">mode == </span><span class="s3">'phase'</span><span class="s1">:</span>
        <span class="s5"># we unwrap the phase later to handle the onesided vs. twosided case</span>
        <span class="s1">result = np.angle(result)</span>
    <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">'complex'</span><span class="s1">:</span>
        <span class="s1">result /= window.sum()</span>

    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'psd'</span><span class="s1">:</span>

        <span class="s5"># Also include scaling factors for one-sided densities and dividing by</span>
        <span class="s5"># the sampling frequency, if desired. Scale everything, except the DC</span>
        <span class="s5"># component and the NFFT/2 component:</span>

        <span class="s5"># if we have a even number of frequencies, don't scale NFFT/2</span>
        <span class="s2">if not </span><span class="s1">NFFT % </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">slc = slice(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s5"># if we have an odd number, just don't scale DC</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">slc = slice(</span><span class="s4">1</span><span class="s2">, None, None</span><span class="s1">)</span>

        <span class="s1">result[slc] *= scaling_factor</span>

        <span class="s5"># MATLAB divides by the sampling frequency so that density function</span>
        <span class="s5"># has units of dB/Hz and can be integrated by the plotted frequency</span>
        <span class="s5"># values. Perform the same scaling here.</span>
        <span class="s2">if </span><span class="s1">scale_by_freq:</span>
            <span class="s1">result /= Fs</span>
            <span class="s5"># Scale the spectrum by the norm of the window to compensate for</span>
            <span class="s5"># windowing loss; see Bendat &amp; Piersol Sec 11.5.2.</span>
            <span class="s1">result /= (window**</span><span class="s4">2</span><span class="s1">).sum()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># In this case, preserve power in the segment, not amplitude</span>
            <span class="s1">result /= window.sum()**</span><span class="s4">2</span>

    <span class="s1">t = np.arange(NFFT/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">len(x) - NFFT/</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">NFFT - noverlap)/Fs</span>

    <span class="s2">if </span><span class="s1">sides == </span><span class="s3">'twosided'</span><span class="s1">:</span>
        <span class="s5"># center the frequency range at zero</span>
        <span class="s1">freqs = np.roll(freqs</span><span class="s2">, </span><span class="s1">-freqcenter</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">result = np.roll(result</span><span class="s2">, </span><span class="s1">-freqcenter</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">elif not </span><span class="s1">pad_to % </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s5"># get the last value correctly, it is negative otherwise</span>
        <span class="s1">freqs[-</span><span class="s4">1</span><span class="s1">] *= -</span><span class="s4">1</span>

    <span class="s5"># we unwrap the phase here to handle the onesided vs. twosided case</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s3">'phase'</span><span class="s1">:</span>
        <span class="s1">result = np.unwrap(result</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">result</span><span class="s2">, </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">t</span>


<span class="s2">def </span><span class="s1">_single_spectrum_helper(</span>
        <span class="s1">mode</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">Fs=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None, </span><span class="s1">pad_to=</span><span class="s2">None, </span><span class="s1">sides=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Private helper implementing the commonality between the complex, magnitude, 
    angle, and phase spectrums. 
    &quot;&quot;&quot;</span>
    <span class="s1">_api.check_in_list([</span><span class="s3">'complex'</span><span class="s2">, </span><span class="s3">'magnitude'</span><span class="s2">, </span><span class="s3">'angle'</span><span class="s2">, </span><span class="s3">'phase'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mode=mode)</span>

    <span class="s2">if </span><span class="s1">pad_to </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">pad_to = len(x)</span>

    <span class="s1">spec</span><span class="s2">, </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">_ = _spectral_helper(x=x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">NFFT=len(x)</span><span class="s2">, </span><span class="s1">Fs=Fs</span><span class="s2">,</span>
                                      <span class="s1">detrend_func=detrend_none</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">,</span>
                                      <span class="s1">noverlap=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">pad_to=pad_to</span><span class="s2">,</span>
                                      <span class="s1">sides=sides</span><span class="s2">,</span>
                                      <span class="s1">scale_by_freq=</span><span class="s2">False,</span>
                                      <span class="s1">mode=mode)</span>
    <span class="s2">if </span><span class="s1">mode != </span><span class="s3">'complex'</span><span class="s1">:</span>
        <span class="s1">spec = spec.real</span>

    <span class="s2">if </span><span class="s1">spec.ndim == </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">spec.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">spec = spec[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">freqs</span>


<span class="s5"># Split out these keyword docs so that they can be used elsewhere</span>
<span class="s1">_docstring.interpd.update(</span>
    <span class="s1">Spectral=</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Fs : float, default: 2 
    The sampling frequency (samples per time unit).  It is used to calculate 
    the Fourier frequencies, *freqs*, in cycles per time unit. 
 
window : callable or ndarray, default: `.window_hanning` 
    A function or a vector of length *NFFT*.  To create window vectors see 
    `.window_hanning`, `.window_none`, `numpy.blackman`, `numpy.hamming`, 
    `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  If a 
    function is passed as the argument, it must take a data segment as an 
    argument and return the windowed version of the segment. 
 
sides : {'default', 'onesided', 'twosided'}, optional 
    Which sides of the spectrum to return. 'default' is one-sided for real 
    data and two-sided for complex data. 'onesided' forces the return of a 
    one-sided spectrum, while 'twosided' forces two-sided.&quot;&quot;&quot;</span><span class="s2">,</span>

    <span class="s1">Single_Spectrum=</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">pad_to : int, optional 
    The number of points to which the data segment is padded when performing 
    the FFT.  While not increasing the actual resolution of the spectrum (the 
    minimum distance between resolvable peaks), this can give more points in 
    the plot, allowing for more detail. This corresponds to the *n* parameter 
    in the call to `~numpy.fft.fft`.  The default is None, which sets *pad_to* 
    equal to the length of the input signal (i.e. no padding).&quot;&quot;&quot;</span><span class="s2">,</span>

    <span class="s1">PSD=</span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">pad_to : int, optional 
    The number of points to which the data segment is padded when performing 
    the FFT.  This can be different from *NFFT*, which specifies the number 
    of data points used.  While not increasing the actual resolution of the 
    spectrum (the minimum distance between resolvable peaks), this can give 
    more points in the plot, allowing for more detail. This corresponds to 
    the *n* parameter in the call to `~numpy.fft.fft`. The default is None, 
    which sets *pad_to* equal to *NFFT* 
 
NFFT : int, default: 256 
    The number of data points used in each block for the FFT.  A power 2 is 
    most efficient.  This should *NOT* be used to get zero padding, or the 
    scaling of the result will be incorrect; use *pad_to* for this instead. 
 
detrend : {'none', 'mean', 'linear'} or callable, default: 'none' 
    The function applied to each segment before fft-ing, designed to remove 
    the mean or linear trend.  Unlike in MATLAB, where the *detrend* parameter 
    is a vector, in Matplotlib it is a function.  The :mod:`~matplotlib.mlab` 
    module defines `.detrend_none`, `.detrend_mean`, and `.detrend_linear`, 
    but you can use a custom function as well.  You can also use a string to 
    choose one of the functions: 'none' calls `.detrend_none`. 'mean' calls 
    `.detrend_mean`. 'linear' calls `.detrend_linear`. 
 
scale_by_freq : bool, default: True 
    Whether the resulting density values should be scaled by the scaling 
    frequency, which gives density in units of 1/Hz.  This allows for 
    integration over the returned frequency values.  The default is True for 
    MATLAB compatibility.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">psd(x</span><span class="s2">, </span><span class="s1">NFFT=</span><span class="s2">None, </span><span class="s1">Fs=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None,</span>
        <span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">pad_to=</span><span class="s2">None, </span><span class="s1">sides=</span><span class="s2">None, </span><span class="s1">scale_by_freq=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Compute the power spectral density. 
 
    The power spectral density :math:`P_{xx}` by Welch's average 
    periodogram method.  The vector *x* is divided into *NFFT* length 
    segments.  Each segment is detrended by function *detrend* and 
    windowed by function *window*.  *noverlap* gives the length of 
    the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2` 
    of each segment :math:`i` are averaged to compute :math:`P_{xx}`. 
 
    If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*. 
 
    Parameters 
    ---------- 
    x : 1-D array or sequence 
        Array or sequence containing the data 
 
    %(Spectral)s 
 
    %(PSD)s 
 
    noverlap : int, default: 0 (no overlap) 
        The number of points of overlap between segments. 
 
    Returns 
    ------- 
    Pxx : 1-D array 
        The values for the power spectrum :math:`P_{xx}` (real valued) 
 
    freqs : 1-D array 
        The frequencies corresponding to the elements in *Pxx* 
 
    References 
    ---------- 
    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John 
    Wiley &amp; Sons (1986) 
 
    See Also 
    -------- 
    specgram 
        `specgram` differs in the default overlap; in not returning the mean of 
        the segment periodograms; and in returning the times of the segments. 
 
    magnitude_spectrum : returns the magnitude spectrum. 
 
    csd : returns the spectral density between two signals. 
    &quot;&quot;&quot;</span>
    <span class="s1">Pxx</span><span class="s2">, </span><span class="s1">freqs = csd(x=x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">NFFT=NFFT</span><span class="s2">, </span><span class="s1">Fs=Fs</span><span class="s2">, </span><span class="s1">detrend=detrend</span><span class="s2">,</span>
                     <span class="s1">window=window</span><span class="s2">, </span><span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">pad_to=pad_to</span><span class="s2">,</span>
                     <span class="s1">sides=sides</span><span class="s2">, </span><span class="s1">scale_by_freq=scale_by_freq)</span>
    <span class="s2">return </span><span class="s1">Pxx.real</span><span class="s2">, </span><span class="s1">freqs</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">csd(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">NFFT=</span><span class="s2">None, </span><span class="s1">Fs=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None,</span>
        <span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">pad_to=</span><span class="s2">None, </span><span class="s1">sides=</span><span class="s2">None, </span><span class="s1">scale_by_freq=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the cross-spectral density. 
 
    The cross spectral density :math:`P_{xy}` by Welch's average 
    periodogram method.  The vectors *x* and *y* are divided into 
    *NFFT* length segments.  Each segment is detrended by function 
    *detrend* and windowed by function *window*.  *noverlap* gives 
    the length of the overlap between segments.  The product of 
    the direct FFTs of *x* and *y* are averaged over each segment 
    to compute :math:`P_{xy}`, with a scaling to correct for power 
    loss due to windowing. 
 
    If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero 
    padded to *NFFT*. 
 
    Parameters 
    ---------- 
    x, y : 1-D arrays or sequences 
        Arrays or sequences containing the data 
 
    %(Spectral)s 
 
    %(PSD)s 
 
    noverlap : int, default: 0 (no overlap) 
        The number of points of overlap between segments. 
 
    Returns 
    ------- 
    Pxy : 1-D array 
        The values for the cross spectrum :math:`P_{xy}` before scaling (real 
        valued) 
 
    freqs : 1-D array 
        The frequencies corresponding to the elements in *Pxy* 
 
    References 
    ---------- 
    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John 
    Wiley &amp; Sons (1986) 
 
    See Also 
    -------- 
    psd : equivalent to setting ``y = x``. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">NFFT </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">NFFT = </span><span class="s4">256</span>
    <span class="s1">Pxy</span><span class="s2">, </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">_ = _spectral_helper(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">NFFT=NFFT</span><span class="s2">, </span><span class="s1">Fs=Fs</span><span class="s2">,</span>
                                     <span class="s1">detrend_func=detrend</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">,</span>
                                     <span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">pad_to=pad_to</span><span class="s2">,</span>
                                     <span class="s1">sides=sides</span><span class="s2">, </span><span class="s1">scale_by_freq=scale_by_freq</span><span class="s2">,</span>
                                     <span class="s1">mode=</span><span class="s3">'psd'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">Pxy.ndim == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">Pxy.shape[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">Pxy = Pxy.mean(axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Pxy = Pxy[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">Pxy</span><span class="s2">, </span><span class="s1">freqs</span>


<span class="s1">_single_spectrum_docs = </span><span class="s3">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s3">Compute the {quantity} of *x*. 
Data is padded to a length of *pad_to* and the windowing function *window* is 
applied to the signal. 
 
Parameters 
---------- 
x : 1-D array or sequence 
    Array or sequence containing the data 
 
{Spectral} 
 
{Single_Spectrum} 
 
Returns 
------- 
spectrum : 1-D array 
    The {quantity}. 
freqs : 1-D array 
    The frequencies corresponding to the elements in *spectrum*. 
 
See Also 
-------- 
psd 
    Returns the power spectral density. 
complex_spectrum 
    Returns the complex-valued frequency spectrum. 
magnitude_spectrum 
    Returns the absolute value of the `complex_spectrum`. 
angle_spectrum 
    Returns the angle of the `complex_spectrum`. 
phase_spectrum 
    Returns the phase (unwrapped angle) of the `complex_spectrum`. 
specgram 
    Can return the complex spectrum of segments within the signal. 
&quot;&quot;&quot;</span>


<span class="s1">complex_spectrum = functools.partial(_single_spectrum_helper</span><span class="s2">, </span><span class="s3">&quot;complex&quot;</span><span class="s1">)</span>
<span class="s1">complex_spectrum.__doc__ = _single_spectrum_docs.format(</span>
    <span class="s1">quantity=</span><span class="s3">&quot;complex-valued frequency spectrum&quot;</span><span class="s2">,</span>
    <span class="s1">**_docstring.interpd.params)</span>
<span class="s1">magnitude_spectrum = functools.partial(_single_spectrum_helper</span><span class="s2">, </span><span class="s3">&quot;magnitude&quot;</span><span class="s1">)</span>
<span class="s1">magnitude_spectrum.__doc__ = _single_spectrum_docs.format(</span>
    <span class="s1">quantity=</span><span class="s3">&quot;magnitude (absolute value) of the frequency spectrum&quot;</span><span class="s2">,</span>
    <span class="s1">**_docstring.interpd.params)</span>
<span class="s1">angle_spectrum = functools.partial(_single_spectrum_helper</span><span class="s2">, </span><span class="s3">&quot;angle&quot;</span><span class="s1">)</span>
<span class="s1">angle_spectrum.__doc__ = _single_spectrum_docs.format(</span>
    <span class="s1">quantity=</span><span class="s3">&quot;angle of the frequency spectrum (wrapped phase spectrum)&quot;</span><span class="s2">,</span>
    <span class="s1">**_docstring.interpd.params)</span>
<span class="s1">phase_spectrum = functools.partial(_single_spectrum_helper</span><span class="s2">, </span><span class="s3">&quot;phase&quot;</span><span class="s1">)</span>
<span class="s1">phase_spectrum.__doc__ = _single_spectrum_docs.format(</span>
    <span class="s1">quantity=</span><span class="s3">&quot;phase of the frequency spectrum (unwrapped phase spectrum)&quot;</span><span class="s2">,</span>
    <span class="s1">**_docstring.interpd.params)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">specgram(x</span><span class="s2">, </span><span class="s1">NFFT=</span><span class="s2">None, </span><span class="s1">Fs=</span><span class="s2">None, </span><span class="s1">detrend=</span><span class="s2">None, </span><span class="s1">window=</span><span class="s2">None,</span>
             <span class="s1">noverlap=</span><span class="s2">None, </span><span class="s1">pad_to=</span><span class="s2">None, </span><span class="s1">sides=</span><span class="s2">None, </span><span class="s1">scale_by_freq=</span><span class="s2">None,</span>
             <span class="s1">mode=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute a spectrogram. 
 
    Compute and plot a spectrogram of data in *x*.  Data are split into 
    *NFFT* length segments and the spectrum of each section is 
    computed.  The windowing function *window* is applied to each 
    segment, and the amount of overlap of each segment is 
    specified with *noverlap*. 
 
    Parameters 
    ---------- 
    x : array-like 
        1-D array or sequence. 
 
    %(Spectral)s 
 
    %(PSD)s 
 
    noverlap : int, default: 128 
        The number of points of overlap between blocks. 
    mode : str, default: 'psd' 
        What sort of spectrum to use: 
            'psd' 
                Returns the power spectral density. 
            'complex' 
                Returns the complex-valued frequency spectrum. 
            'magnitude' 
                Returns the magnitude spectrum. 
            'angle' 
                Returns the phase spectrum without unwrapping. 
            'phase' 
                Returns the phase spectrum with unwrapping. 
 
    Returns 
    ------- 
    spectrum : array-like 
        2D array, columns are the periodograms of successive segments. 
 
    freqs : array-like 
        1-D array, frequencies corresponding to the rows in *spectrum*. 
 
    t : array-like 
        1-D array, the times corresponding to midpoints of segments 
        (i.e the columns in *spectrum*). 
 
    See Also 
    -------- 
    psd : differs in the overlap and in the return values. 
    complex_spectrum : similar, but with complex valued frequencies. 
    magnitude_spectrum : similar single segment when *mode* is 'magnitude'. 
    angle_spectrum : similar to single segment when *mode* is 'angle'. 
    phase_spectrum : similar to single segment when *mode* is 'phase'. 
 
    Notes 
    ----- 
    *detrend* and *scale_by_freq* only apply when *mode* is set to 'psd'. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">noverlap </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">noverlap = </span><span class="s4">128  </span><span class="s5"># default in _spectral_helper() is noverlap = 0</span>
    <span class="s2">if </span><span class="s1">NFFT </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">NFFT = </span><span class="s4">256  </span><span class="s5"># same default as in _spectral_helper()</span>
    <span class="s2">if </span><span class="s1">len(x) &lt;= NFFT:</span>
        <span class="s1">_api.warn_external(</span><span class="s3">&quot;Only one segment is calculated since parameter &quot;</span>
                           <span class="s3">f&quot;NFFT (=</span><span class="s2">{</span><span class="s1">NFFT</span><span class="s2">}</span><span class="s3">) &gt;= signal length (=</span><span class="s2">{</span><span class="s1">len(x)</span><span class="s2">}</span><span class="s3">).&quot;</span><span class="s1">)</span>

    <span class="s1">spec</span><span class="s2">, </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">t = _spectral_helper(x=x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">NFFT=NFFT</span><span class="s2">, </span><span class="s1">Fs=Fs</span><span class="s2">,</span>
                                      <span class="s1">detrend_func=detrend</span><span class="s2">, </span><span class="s1">window=window</span><span class="s2">,</span>
                                      <span class="s1">noverlap=noverlap</span><span class="s2">, </span><span class="s1">pad_to=pad_to</span><span class="s2">,</span>
                                      <span class="s1">sides=sides</span><span class="s2">,</span>
                                      <span class="s1">scale_by_freq=scale_by_freq</span><span class="s2">,</span>
                                      <span class="s1">mode=mode)</span>

    <span class="s2">if </span><span class="s1">mode != </span><span class="s3">'complex'</span><span class="s1">:</span>
        <span class="s1">spec = spec.real  </span><span class="s5"># Needed since helper implements generically</span>

    <span class="s2">return </span><span class="s1">spec</span><span class="s2">, </span><span class="s1">freqs</span><span class="s2">, </span><span class="s1">t</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">def </span><span class="s1">cohere(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">NFFT=</span><span class="s4">256</span><span class="s2">, </span><span class="s1">Fs=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">detrend=detrend_none</span><span class="s2">, </span><span class="s1">window=window_hanning</span><span class="s2">,</span>
           <span class="s1">noverlap=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">pad_to=</span><span class="s2">None, </span><span class="s1">sides=</span><span class="s3">'default'</span><span class="s2">, </span><span class="s1">scale_by_freq=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    The coherence between *x* and *y*.  Coherence is the normalized 
    cross spectral density: 
 
    .. math:: 
 
        C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}} 
 
    Parameters 
    ---------- 
    x, y 
        Array or sequence containing the data 
 
    %(Spectral)s 
 
    %(PSD)s 
 
    noverlap : int, default: 0 (no overlap) 
        The number of points of overlap between segments. 
 
    Returns 
    ------- 
    Cxy : 1-D array 
        The coherence vector. 
    freqs : 1-D array 
            The frequencies for the elements in *Cxy*. 
 
    See Also 
    -------- 
    :func:`psd`, :func:`csd` : 
        For information about the methods used to compute :math:`P_{xy}`, 
        :math:`P_{xx}` and :math:`P_{yy}`. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(x) &lt; </span><span class="s4">2 </span><span class="s1">* NFFT:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;Coherence is calculated by averaging over *NFFT* length &quot;</span>
            <span class="s3">&quot;segments.  Your signal is too short for your choice of *NFFT*.&quot;</span><span class="s1">)</span>
    <span class="s1">Pxx</span><span class="s2">, </span><span class="s1">f = psd(x</span><span class="s2">, </span><span class="s1">NFFT</span><span class="s2">, </span><span class="s1">Fs</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">pad_to</span><span class="s2">, </span><span class="s1">sides</span><span class="s2">,</span>
                 <span class="s1">scale_by_freq)</span>
    <span class="s1">Pyy</span><span class="s2">, </span><span class="s1">f = psd(y</span><span class="s2">, </span><span class="s1">NFFT</span><span class="s2">, </span><span class="s1">Fs</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">pad_to</span><span class="s2">, </span><span class="s1">sides</span><span class="s2">,</span>
                 <span class="s1">scale_by_freq)</span>
    <span class="s1">Pxy</span><span class="s2">, </span><span class="s1">f = csd(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">NFFT</span><span class="s2">, </span><span class="s1">Fs</span><span class="s2">, </span><span class="s1">detrend</span><span class="s2">, </span><span class="s1">window</span><span class="s2">, </span><span class="s1">noverlap</span><span class="s2">, </span><span class="s1">pad_to</span><span class="s2">, </span><span class="s1">sides</span><span class="s2">,</span>
                 <span class="s1">scale_by_freq)</span>
    <span class="s1">Cxy = np.abs(Pxy) ** </span><span class="s4">2 </span><span class="s1">/ (Pxx * Pyy)</span>
    <span class="s2">return </span><span class="s1">Cxy</span><span class="s2">, </span><span class="s1">f</span>


<span class="s2">class </span><span class="s1">GaussianKDE:</span>
    <span class="s0">&quot;&quot;&quot; 
    Representation of a kernel-density estimate using Gaussian kernels. 
 
    Parameters 
    ---------- 
    dataset : array-like 
        Datapoints to estimate from. In case of univariate data this is a 1-D 
        array, otherwise a 2D array with shape (# of dims, # of data). 
    bw_method : str, scalar or callable, optional 
        The method used to calculate the estimator bandwidth.  This can be 
        'scott', 'silverman', a scalar constant or a callable.  If a 
        scalar, this will be used directly as `kde.factor`.  If a 
        callable, it should take a `GaussianKDE` instance as only 
        parameter and return a scalar. If None (default), 'scott' is used. 
 
    Attributes 
    ---------- 
    dataset : ndarray 
        The dataset passed to the constructor. 
    dim : int 
        Number of dimensions. 
    num_dp : int 
        Number of datapoints. 
    factor : float 
        The bandwidth factor, obtained from `kde.covariance_factor`, with which 
        the covariance matrix is multiplied. 
    covariance : ndarray 
        The covariance matrix of *dataset*, scaled by the calculated bandwidth 
        (`kde.factor`). 
    inv_cov : ndarray 
        The inverse of *covariance*. 
 
    Methods 
    ------- 
    kde.evaluate(points) : ndarray 
        Evaluate the estimated pdf on a provided set of points. 
    kde(points) : ndarray 
        Same as kde.evaluate(points) 
    &quot;&quot;&quot;</span>

    <span class="s5"># This implementation with minor modification was too good to pass up.</span>
    <span class="s5"># from scipy: https://github.com/scipy/scipy/blob/master/scipy/stats/kde.py</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dataset</span><span class="s2">, </span><span class="s1">bw_method=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.dataset = np.atleast_2d(dataset)</span>
        <span class="s2">if not </span><span class="s1">np.array(self.dataset).size &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;`dataset` input should have multiple elements.&quot;</span><span class="s1">)</span>

        <span class="s1">self.dim</span><span class="s2">, </span><span class="s1">self.num_dp = np.array(self.dataset).shape</span>

        <span class="s2">if </span><span class="s1">bw_method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">cbook._str_equal(bw_method</span><span class="s2">, </span><span class="s3">'scott'</span><span class="s1">):</span>
            <span class="s1">self.covariance_factor = self.scotts_factor</span>
        <span class="s2">elif </span><span class="s1">cbook._str_equal(bw_method</span><span class="s2">, </span><span class="s3">'silverman'</span><span class="s1">):</span>
            <span class="s1">self.covariance_factor = self.silverman_factor</span>
        <span class="s2">elif </span><span class="s1">isinstance(bw_method</span><span class="s2">, </span><span class="s1">Number):</span>
            <span class="s1">self._bw_method = </span><span class="s3">'use constant'</span>
            <span class="s1">self.covariance_factor = </span><span class="s2">lambda</span><span class="s1">: bw_method</span>
        <span class="s2">elif </span><span class="s1">callable(bw_method):</span>
            <span class="s1">self._bw_method = bw_method</span>
            <span class="s1">self.covariance_factor = </span><span class="s2">lambda</span><span class="s1">: self._bw_method(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;`bw_method` should be 'scott', 'silverman', a &quot;</span>
                             <span class="s3">&quot;scalar or a callable&quot;</span><span class="s1">)</span>

        <span class="s5"># Computes the covariance matrix for each Gaussian kernel using</span>
        <span class="s5"># covariance_factor().</span>

        <span class="s1">self.factor = self.covariance_factor()</span>
        <span class="s5"># Cache covariance and inverse covariance of the data</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'_data_inv_cov'</span><span class="s1">):</span>
            <span class="s1">self.data_covariance = np.atleast_2d(</span>
                <span class="s1">np.cov(</span>
                    <span class="s1">self.dataset</span><span class="s2">,</span>
                    <span class="s1">rowvar=</span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s1">bias=</span><span class="s2">False</span><span class="s1">))</span>
            <span class="s1">self.data_inv_cov = np.linalg.inv(self.data_covariance)</span>

        <span class="s1">self.covariance = self.data_covariance * self.factor ** </span><span class="s4">2</span>
        <span class="s1">self.inv_cov = self.data_inv_cov / self.factor ** </span><span class="s4">2</span>
        <span class="s1">self.norm_factor = (np.sqrt(np.linalg.det(</span><span class="s4">2 </span><span class="s1">* np.pi * self.covariance))</span>
                            <span class="s1">* self.num_dp)</span>

    <span class="s2">def </span><span class="s1">scotts_factor(self):</span>
        <span class="s2">return </span><span class="s1">np.power(self.num_dp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1. </span><span class="s1">/ (self.dim + </span><span class="s4">4</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">silverman_factor(self):</span>
        <span class="s2">return </span><span class="s1">np.power(</span>
            <span class="s1">self.num_dp * (self.dim + </span><span class="s4">2.0</span><span class="s1">) / </span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1. </span><span class="s1">/ (self.dim + </span><span class="s4">4</span><span class="s1">))</span>

    <span class="s5">#  Default method to calculate bandwidth, can be overwritten by subclass</span>
    <span class="s1">covariance_factor = scotts_factor</span>

    <span class="s2">def </span><span class="s1">evaluate(self</span><span class="s2">, </span><span class="s1">points):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the estimated pdf on a set of points. 
 
        Parameters 
        ---------- 
        points : (# of dimensions, # of points)-array 
            Alternatively, a (# of dimensions,) vector can be passed in and 
            treated as a single point. 
 
        Returns 
        ------- 
        (# of points,)-array 
            The values at each point. 
 
        Raises 
        ------ 
        ValueError : if the dimensionality of the input points is different 
                     than the dimensionality of the KDE. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">points = np.atleast_2d(points)</span>

        <span class="s1">dim</span><span class="s2">, </span><span class="s1">num_m = np.array(points).shape</span>
        <span class="s2">if </span><span class="s1">dim != self.dim:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;points have dimension {}, dataset has dimension &quot;</span>
                             <span class="s3">&quot;{}&quot;</span><span class="s1">.format(dim</span><span class="s2">, </span><span class="s1">self.dim))</span>

        <span class="s1">result = np.zeros(num_m)</span>

        <span class="s2">if </span><span class="s1">num_m &gt;= self.num_dp:</span>
            <span class="s5"># there are more points than data, so loop over data</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.num_dp):</span>
                <span class="s1">diff = self.dataset[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">np.newaxis] - points</span>
                <span class="s1">tdiff = np.dot(self.inv_cov</span><span class="s2">, </span><span class="s1">diff)</span>
                <span class="s1">energy = np.sum(diff * tdiff</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) / </span><span class="s4">2.0</span>
                <span class="s1">result = result + np.exp(-energy)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># loop over points</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num_m):</span>
                <span class="s1">diff = self.dataset - points[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
                <span class="s1">tdiff = np.dot(self.inv_cov</span><span class="s2">, </span><span class="s1">diff)</span>
                <span class="s1">energy = np.sum(diff * tdiff</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) / </span><span class="s4">2.0</span>
                <span class="s1">result[i] = np.sum(np.exp(-energy)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">result = result / self.norm_factor</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">__call__ = evaluate</span>
</pre>
</body>
</html>