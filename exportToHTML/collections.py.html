<html>
<head>
<title>collections.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
collections.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Classes for the efficient drawing of large collections of objects that 
share most properties, e.g., a large number of line segments or 
polygons. 
 
The classes are not meant to be as flexible as their single element 
counterparts (e.g., you may not be able to select all line styles) but 
they are meant to be fast for common use cases (e.g., a large set of solid 
line segments). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">(_api</span><span class="s2">, </span><span class="s1">_path</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">cm</span><span class="s2">, </span><span class="s1">colors </span><span class="s2">as </span><span class="s1">mcolors</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">,</span>
               <span class="s1">hatch </span><span class="s2">as </span><span class="s1">mhatch</span><span class="s2">, </span><span class="s1">lines </span><span class="s2">as </span><span class="s1">mlines</span><span class="s2">, </span><span class="s1">path </span><span class="s2">as </span><span class="s1">mpath</span><span class="s2">, </span><span class="s1">transforms)</span>
<span class="s2">from </span><span class="s1">._enums </span><span class="s2">import </span><span class="s1">JoinStyle</span><span class="s2">, </span><span class="s1">CapStyle</span>


<span class="s3"># &quot;color&quot; is excluded; it is a compound setter, and its docstring differs</span>
<span class="s3"># in LineCollection.</span>
<span class="s1">@_api.define_aliases({</span>
    <span class="s4">&quot;antialiased&quot;</span><span class="s1">: [</span><span class="s4">&quot;antialiaseds&quot;</span><span class="s2">, </span><span class="s4">&quot;aa&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;edgecolor&quot;</span><span class="s1">: [</span><span class="s4">&quot;edgecolors&quot;</span><span class="s2">, </span><span class="s4">&quot;ec&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;facecolor&quot;</span><span class="s1">: [</span><span class="s4">&quot;facecolors&quot;</span><span class="s2">, </span><span class="s4">&quot;fc&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;linestyle&quot;</span><span class="s1">: [</span><span class="s4">&quot;linestyles&quot;</span><span class="s2">, </span><span class="s4">&quot;dashes&quot;</span><span class="s2">, </span><span class="s4">&quot;ls&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;linewidth&quot;</span><span class="s1">: [</span><span class="s4">&quot;linewidths&quot;</span><span class="s2">, </span><span class="s4">&quot;lw&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;offset_transform&quot;</span><span class="s1">: [</span><span class="s4">&quot;transOffset&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">})</span>
<span class="s2">class </span><span class="s1">Collection(artist.Artist</span><span class="s2">, </span><span class="s1">cm.ScalarMappable):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Base class for Collections. Must be subclassed to be usable. 
 
    A Collection represents a sequence of `.Patch`\es that can be drawn 
    more efficiently together than individually. For example, when a single 
    path is being drawn repeatedly at different offsets, the renderer can 
    typically execute a ``draw_marker()`` call much more efficiently than a 
    series of repeated calls to ``draw_path()`` with the offsets put in 
    one-by-one. 
 
    Most properties of a collection can be configured per-element. Therefore, 
    Collections have &quot;plural&quot; versions of many of the properties of a `.Patch` 
    (e.g. `.Collection.get_paths` instead of `.Patch.get_path`). Exceptions are 
    the *zorder*, *hatch*, *pickradius*, *capstyle* and *joinstyle* properties, 
    which can only be set globally for the whole collection. 
 
    Besides these exceptions, all properties can be specified as single values 
    (applying to all elements) or sequences of values. The property of the 
    ``i``\th element of the collection is:: 
 
      prop[i % len(prop)] 
 
    Each Collection can optionally be used as its own `.ScalarMappable` by 
    passing the *norm* and *cmap* parameters to its constructor. If the 
    Collection's `.ScalarMappable` matrix ``_A`` has been set (via a call 
    to `.Collection.set_array`), then at draw time this internal scalar 
    mappable will be used to set the ``facecolors`` and ``edgecolors``, 
    ignoring those that were manually passed in. 
    &quot;&quot;&quot;</span>
    <span class="s3">#: Either a list of 3x3 arrays or an Nx3x3 array (representing N</span>
    <span class="s3">#: transforms), suitable for the `all_transforms` argument to</span>
    <span class="s3">#: `~matplotlib.backend_bases.RendererBase.draw_path_collection`;</span>
    <span class="s3">#: each 3x3 array is used to initialize an</span>
    <span class="s3">#: `~matplotlib.transforms.Affine2D` object.</span>
    <span class="s3">#: Each kind of collection defines this based on its arguments.</span>
    <span class="s1">_transforms = np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>

    <span class="s3"># Whether to draw an edge by default.  Set on a</span>
    <span class="s3"># subclass-by-subclass basis.</span>
    <span class="s1">_edge_default = </span><span class="s2">False</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;edgecolors&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">edgecolors=</span><span class="s2">None,</span>
                 <span class="s1">facecolors=</span><span class="s2">None,</span>
                 <span class="s1">linewidths=</span><span class="s2">None,</span>
                 <span class="s1">linestyles=</span><span class="s4">'solid'</span><span class="s2">,</span>
                 <span class="s1">capstyle=</span><span class="s2">None,</span>
                 <span class="s1">joinstyle=</span><span class="s2">None,</span>
                 <span class="s1">antialiaseds=</span><span class="s2">None,</span>
                 <span class="s1">offsets=</span><span class="s2">None,</span>
                 <span class="s1">offset_transform=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,  </span><span class="s3"># optional for ScalarMappable</span>
                 <span class="s1">cmap=</span><span class="s2">None,  </span><span class="s3"># ditto</span>
                 <span class="s1">pickradius=</span><span class="s5">5.0</span><span class="s2">,</span>
                 <span class="s1">hatch=</span><span class="s2">None,</span>
                 <span class="s1">urls=</span><span class="s2">None,</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">zorder=</span><span class="s5">1</span><span class="s2">,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        edgecolors : color or list of colors, default: :rc:`patch.edgecolor` 
            Edge color for each patch making up the collection. The special 
            value 'face' can be passed to make the edgecolor match the 
            facecolor. 
        facecolors : color or list of colors, default: :rc:`patch.facecolor` 
            Face color for each patch making up the collection. 
        linewidths : float or list of floats, default: :rc:`patch.linewidth` 
            Line width for each patch making up the collection. 
        linestyles : str or tuple or list thereof, default: 'solid' 
            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', '-', 
            '--', '-.', ':']. Dash tuples should be of the form:: 
 
                (offset, onoffseq), 
 
            where *onoffseq* is an even length tuple of on and off ink lengths 
            in points. For examples, see 
            :doc:`/gallery/lines_bars_and_markers/linestyles`. 
        capstyle : `.CapStyle`-like, default: :rc:`patch.capstyle` 
            Style to use for capping lines for all paths in the collection. 
            Allowed values are %(CapStyle)s. 
        joinstyle : `.JoinStyle`-like, default: :rc:`patch.joinstyle` 
            Style to use for joining lines for all paths in the collection. 
            Allowed values are %(JoinStyle)s. 
        antialiaseds : bool or list of bool, default: :rc:`patch.antialiased` 
            Whether each patch in the collection should be drawn with 
            antialiasing. 
        offsets : (float, float) or list thereof, default: (0, 0) 
            A vector by which to translate each patch after rendering (default 
            is no translation). The translation is performed in screen (pixel) 
            coordinates (i.e. after the Artist's transform is applied). 
        offset_transform : `~.Transform`, default: `.IdentityTransform` 
            A single transform which will be applied to each *offsets* vector 
            before it is used. 
        cmap, norm 
            Data normalization and colormapping parameters. See 
            `.ScalarMappable` for a detailed description. 
        hatch : str, optional 
            Hatching pattern to use in filled paths, if any. Valid strings are 
            ['/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*']. See 
            :doc:`/gallery/shapes_and_collections/hatch_style_reference` for 
            the meaning of each hatch type. 
        pickradius : float, default: 5.0 
            If ``pickradius &lt;= 0``, then `.Collection.contains` will return 
            ``True`` whenever the test point is inside of one of the polygons 
            formed by the control points of a Path in the Collection. On the 
            other hand, if it is greater than 0, then we instead check if the 
            test point is contained in a stroke of width ``2*pickradius`` 
            following any of the Paths in the Collection. 
        urls : list of str, default: None 
            A URL for each patch to link to once drawn. Currently only works 
            for the SVG backend. See :doc:`/gallery/misc/hyperlinks_sgskip` for 
            examples. 
        zorder : float, default: 1 
            The drawing order, shared by all Patches in the Collection. See 
            :doc:`/gallery/misc/zorder_demo` for all defaults and examples. 
        &quot;&quot;&quot;</span>
        <span class="s1">artist.Artist.__init__(self)</span>
        <span class="s1">cm.ScalarMappable.__init__(self</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">cmap)</span>
        <span class="s3"># list of un-scaled dash patterns</span>
        <span class="s3"># this is needed scaling the dash pattern by linewidth</span>
        <span class="s1">self._us_linestyles = [(</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)]</span>
        <span class="s3"># list of dash patterns</span>
        <span class="s1">self._linestyles = [(</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)]</span>
        <span class="s3"># list of unbroadcast/scaled linewidths</span>
        <span class="s1">self._us_lw = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self._linewidths = [</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3"># Flags set by _set_mappable_flags: are colors from mapping an array?</span>
        <span class="s1">self._face_is_mapped = </span><span class="s2">None</span>
        <span class="s1">self._edge_is_mapped = </span><span class="s2">None</span>
        <span class="s1">self._mapped_colors = </span><span class="s2">None  </span><span class="s3"># calculated in update_scalarmappable</span>
        <span class="s1">self._hatch_color = mcolors.to_rgba(mpl.rcParams[</span><span class="s4">'hatch.color'</span><span class="s1">])</span>
        <span class="s1">self.set_facecolor(facecolors)</span>
        <span class="s1">self.set_edgecolor(edgecolors)</span>
        <span class="s1">self.set_linewidth(linewidths)</span>
        <span class="s1">self.set_linestyle(linestyles)</span>
        <span class="s1">self.set_antialiased(antialiaseds)</span>
        <span class="s1">self.set_pickradius(pickradius)</span>
        <span class="s1">self.set_urls(urls)</span>
        <span class="s1">self.set_hatch(hatch)</span>
        <span class="s1">self.set_zorder(zorder)</span>

        <span class="s2">if </span><span class="s1">capstyle:</span>
            <span class="s1">self.set_capstyle(capstyle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._capstyle = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">joinstyle:</span>
            <span class="s1">self.set_joinstyle(joinstyle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._joinstyle = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">offsets </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">offsets = np.asanyarray(offsets</span><span class="s2">, </span><span class="s1">float)</span>
            <span class="s3"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="s2">if </span><span class="s1">offsets.shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">):</span>
                <span class="s1">offsets = offsets[</span><span class="s2">None, </span><span class="s1">:]</span>

        <span class="s1">self._offsets = offsets</span>
        <span class="s1">self._offset_transform = offset_transform</span>

        <span class="s1">self._path_effects = </span><span class="s2">None</span>
        <span class="s1">self._internal_update(kwargs)</span>
        <span class="s1">self._paths = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">get_paths(self):</span>
        <span class="s2">return </span><span class="s1">self._paths</span>

    <span class="s2">def </span><span class="s1">set_paths(self</span><span class="s2">, </span><span class="s1">paths):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">get_transforms(self):</span>
        <span class="s2">return </span><span class="s1">self._transforms</span>

    <span class="s2">def </span><span class="s1">get_offset_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.Transform` instance used by this artist offset.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._offset_transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._offset_transform = transforms.IdentityTransform()</span>
        <span class="s2">elif </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(self._offset_transform</span><span class="s2">, </span><span class="s1">transforms.Transform)</span>
              <span class="s2">and </span><span class="s1">hasattr(self._offset_transform</span><span class="s2">, </span><span class="s4">'_as_mpl_transform'</span><span class="s1">)):</span>
            <span class="s1">self._offset_transform = \</span>
                <span class="s1">self._offset_transform._as_mpl_transform(self.axes)</span>
        <span class="s2">return </span><span class="s1">self._offset_transform</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;transOffset&quot;</span><span class="s2">, </span><span class="s4">&quot;offset_transform&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_offset_transform(self</span><span class="s2">, </span><span class="s1">offset_transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the artist offset transform. 
 
        Parameters 
        ---------- 
        offset_transform : `.Transform` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset_transform = offset_transform</span>

    <span class="s2">def </span><span class="s1">get_datalim(self</span><span class="s2">, </span><span class="s1">transData):</span>
        <span class="s3"># Calculate the data limits and return them as a `.Bbox`.</span>
        <span class="s3">#</span>
        <span class="s3"># This operation depends on the transforms for the data in the</span>
        <span class="s3"># collection and whether the collection has offsets:</span>
        <span class="s3">#</span>
        <span class="s3"># 1. offsets = None, transform child of transData: use the paths for</span>
        <span class="s3"># the automatic limits (i.e. for LineCollection in streamline).</span>
        <span class="s3"># 2. offsets != None: offset_transform is child of transData:</span>
        <span class="s3">#</span>
        <span class="s3">#    a. transform is child of transData: use the path + offset for</span>
        <span class="s3">#       limits (i.e for bar).</span>
        <span class="s3">#    b. transform is not a child of transData: just use the offsets</span>
        <span class="s3">#       for the limits (i.e. for scatter)</span>
        <span class="s3">#</span>
        <span class="s3"># 3. otherwise return a null Bbox.</span>

        <span class="s1">transform = self.get_transform()</span>
        <span class="s1">offset_trf = self.get_offset_transform()</span>
        <span class="s2">if not </span><span class="s1">(isinstance(offset_trf</span><span class="s2">, </span><span class="s1">transforms.IdentityTransform)</span>
                <span class="s2">or </span><span class="s1">offset_trf.contains_branch(transData)):</span>
            <span class="s3"># if the offsets are in some coords other than data,</span>
            <span class="s3"># then don't use them for autoscaling.</span>
            <span class="s2">return </span><span class="s1">transforms.Bbox.null()</span>
        <span class="s1">offsets = self.get_offsets()</span>

        <span class="s1">paths = self.get_paths()</span>
        <span class="s2">if not </span><span class="s1">len(paths):</span>
            <span class="s3"># No paths to transform</span>
            <span class="s2">return </span><span class="s1">transforms.Bbox.null()</span>

        <span class="s2">if not </span><span class="s1">transform.is_affine:</span>
            <span class="s1">paths = [transform.transform_path_non_affine(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">paths]</span>
            <span class="s3"># Don't convert transform to transform.get_affine() here because</span>
            <span class="s3"># we may have transform.contains_branch(transData) but not</span>
            <span class="s3"># transforms.get_affine().contains_branch(transData).  But later,</span>
            <span class="s3"># be careful to only apply the affine part that remains.</span>

        <span class="s2">if </span><span class="s1">any(transform.contains_branch_seperately(transData)):</span>
            <span class="s3"># collections that are just in data units (like quiver)</span>
            <span class="s3"># can properly have the axes limits set by their shape +</span>
            <span class="s3"># offset.  LineCollections that have no offsets can</span>
            <span class="s3"># also use this algorithm (like streamplot).</span>
            <span class="s2">if </span><span class="s1">isinstance(offsets</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
                <span class="s1">offsets = offsets.filled(np.nan)</span>
                <span class="s3"># get_path_collection_extents handles nan but not masked arrays</span>
            <span class="s2">return </span><span class="s1">mpath.get_path_collection_extents(</span>
                <span class="s1">transform.get_affine() - transData</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">,</span>
                <span class="s1">self.get_transforms()</span><span class="s2">,</span>
                <span class="s1">offset_trf.transform_non_affine(offsets)</span><span class="s2">,</span>
                <span class="s1">offset_trf.get_affine().frozen())</span>

        <span class="s3"># NOTE: None is the default case where no offsets were passed in</span>
        <span class="s2">if </span><span class="s1">self._offsets </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># this is for collections that have their paths (shapes)</span>
            <span class="s3"># in physical, axes-relative, or figure-relative units</span>
            <span class="s3"># (i.e. like scatter). We can't uniquely set limits based on</span>
            <span class="s3"># those shapes, so we just set the limits based on their</span>
            <span class="s3"># location.</span>
            <span class="s1">offsets = (offset_trf - transData).transform(offsets)</span>
            <span class="s3"># note A-B means A B^{-1}</span>
            <span class="s1">offsets = np.ma.masked_invalid(offsets)</span>
            <span class="s2">if not </span><span class="s1">offsets.mask.all():</span>
                <span class="s1">bbox = transforms.Bbox.null()</span>
                <span class="s1">bbox.update_from_data_xy(offsets)</span>
                <span class="s2">return </span><span class="s1">bbox</span>
        <span class="s2">return </span><span class="s1">transforms.Bbox.null()</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># TODO: check to ensure that this does not fail for</span>
        <span class="s3"># cases other than scatter plot legend</span>
        <span class="s2">return </span><span class="s1">self.get_datalim(transforms.IdentityTransform())</span>

    <span class="s2">def </span><span class="s1">_prepare_points(self):</span>
        <span class="s3"># Helper for drawing and hit testing.</span>

        <span class="s1">transform = self.get_transform()</span>
        <span class="s1">offset_trf = self.get_offset_transform()</span>
        <span class="s1">offsets = self.get_offsets()</span>
        <span class="s1">paths = self.get_paths()</span>

        <span class="s2">if </span><span class="s1">self.have_units():</span>
            <span class="s1">paths = []</span>
            <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self.get_paths():</span>
                <span class="s1">vertices = path.vertices</span>
                <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys = vertices[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">vertices[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">xs = self.convert_xunits(xs)</span>
                <span class="s1">ys = self.convert_yunits(ys)</span>
                <span class="s1">paths.append(mpath.Path(np.column_stack([xs</span><span class="s2">, </span><span class="s1">ys])</span><span class="s2">, </span><span class="s1">path.codes))</span>
            <span class="s1">xs = self.convert_xunits(offsets[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">ys = self.convert_yunits(offsets[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">offsets = np.ma.column_stack([xs</span><span class="s2">, </span><span class="s1">ys])</span>

        <span class="s2">if not </span><span class="s1">transform.is_affine:</span>
            <span class="s1">paths = [transform.transform_path_non_affine(path)</span>
                     <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">paths]</span>
            <span class="s1">transform = transform.get_affine()</span>
        <span class="s2">if not </span><span class="s1">offset_trf.is_affine:</span>
            <span class="s1">offsets = offset_trf.transform_non_affine(offsets)</span>
            <span class="s3"># This might have changed an ndarray into a masked array.</span>
            <span class="s1">offset_trf = offset_trf.get_affine()</span>

        <span class="s2">if </span><span class="s1">isinstance(offsets</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">offsets = offsets.filled(np.nan)</span>
            <span class="s3"># Changing from a masked array to nan-filled ndarray</span>
            <span class="s3"># is probably most efficient at this point.</span>

        <span class="s2">return </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">paths</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.get_gid())</span>

        <span class="s1">self.update_scalarmappable()</span>

        <span class="s1">transform</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">paths = self._prepare_points()</span>

        <span class="s1">gc = renderer.new_gc()</span>
        <span class="s1">self._set_gc_clip(gc)</span>
        <span class="s1">gc.set_snap(self.get_snap())</span>

        <span class="s2">if </span><span class="s1">self._hatch:</span>
            <span class="s1">gc.set_hatch(self._hatch)</span>
            <span class="s1">gc.set_hatch_color(self._hatch_color)</span>

        <span class="s2">if </span><span class="s1">self.get_sketch_params() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">gc.set_sketch_params(*self.get_sketch_params())</span>

        <span class="s2">if </span><span class="s1">self.get_path_effects():</span>
            <span class="s2">from </span><span class="s1">matplotlib.patheffects </span><span class="s2">import </span><span class="s1">PathEffectRenderer</span>
            <span class="s1">renderer = PathEffectRenderer(self.get_path_effects()</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s3"># If the collection is made up of a single shape/color/stroke,</span>
        <span class="s3"># it can be rendered once and blitted multiple times, using</span>
        <span class="s3"># `draw_markers` rather than `draw_path_collection`.  This is</span>
        <span class="s3"># *much* faster for Agg, and results in smaller file sizes in</span>
        <span class="s3"># PDF/SVG/PS.</span>

        <span class="s1">trans = self.get_transforms()</span>
        <span class="s1">facecolors = self.get_facecolor()</span>
        <span class="s1">edgecolors = self.get_edgecolor()</span>
        <span class="s1">do_single_path_optimization = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">(len(paths) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(trans) &lt;= </span><span class="s5">1 </span><span class="s2">and</span>
                <span class="s1">len(facecolors) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(edgecolors) == </span><span class="s5">1 </span><span class="s2">and</span>
                <span class="s1">len(self._linewidths) == </span><span class="s5">1 </span><span class="s2">and</span>
                <span class="s1">all(ls[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">is None for </span><span class="s1">ls </span><span class="s2">in </span><span class="s1">self._linestyles) </span><span class="s2">and</span>
                <span class="s1">len(self._antialiaseds) == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(self._urls) == </span><span class="s5">1 </span><span class="s2">and</span>
                <span class="s1">self.get_hatch() </span><span class="s2">is None</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">len(trans):</span>
                <span class="s1">combined_transform = transforms.Affine2D(trans[</span><span class="s5">0</span><span class="s1">]) + transform</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">combined_transform = transform</span>
            <span class="s1">extents = paths[</span><span class="s5">0</span><span class="s1">].get_extents(combined_transform)</span>
            <span class="s2">if </span><span class="s1">(extents.width &lt; self.figure.bbox.width</span>
                    <span class="s2">and </span><span class="s1">extents.height &lt; self.figure.bbox.height):</span>
                <span class="s1">do_single_path_optimization = </span><span class="s2">True</span>

        <span class="s2">if </span><span class="s1">self._joinstyle:</span>
            <span class="s1">gc.set_joinstyle(self._joinstyle)</span>

        <span class="s2">if </span><span class="s1">self._capstyle:</span>
            <span class="s1">gc.set_capstyle(self._capstyle)</span>

        <span class="s2">if </span><span class="s1">do_single_path_optimization:</span>
            <span class="s1">gc.set_foreground(tuple(edgecolors[</span><span class="s5">0</span><span class="s1">]))</span>
            <span class="s1">gc.set_linewidth(self._linewidths[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">gc.set_dashes(*self._linestyles[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">gc.set_antialiased(self._antialiaseds[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">gc.set_url(self._urls[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">renderer.draw_markers(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">paths[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">combined_transform.frozen()</span><span class="s2">,</span>
                <span class="s1">mpath.Path(offsets)</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">, </span><span class="s1">tuple(facecolors[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">renderer.draw_path_collection(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">transform.frozen()</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">,</span>
                <span class="s1">self.get_transforms()</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">,</span>
                <span class="s1">self.get_facecolor()</span><span class="s2">, </span><span class="s1">self.get_edgecolor()</span><span class="s2">,</span>
                <span class="s1">self._linewidths</span><span class="s2">, </span><span class="s1">self._linestyles</span><span class="s2">,</span>
                <span class="s1">self._antialiaseds</span><span class="s2">, </span><span class="s1">self._urls</span><span class="s2">,</span>
                <span class="s4">&quot;screen&quot;</span><span class="s1">)  </span><span class="s3"># offset_position, kept for backcompat.</span>

        <span class="s1">gc.restore()</span>
        <span class="s1">renderer.close_group(self.__class__.__name__)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s4">&quot;pr&quot;</span><span class="s2">, </span><span class="s4">&quot;pickradius&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_pickradius(self</span><span class="s2">, </span><span class="s1">pickradius):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the pick radius used for containment tests. 
 
        Parameters 
        ---------- 
        pickradius : float 
            Pick radius, in points. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._pickradius = pickradius</span>

    <span class="s2">def </span><span class="s1">get_pickradius(self):</span>
        <span class="s2">return </span><span class="s1">self._pickradius</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether the mouse event occurred in the collection. 
 
        Returns ``bool, dict(ind=itemlist)``, where every item in itemlist 
        contains the event. 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return False, </span><span class="s1">{}</span>

        <span class="s1">pickradius = (</span>
            <span class="s1">float(self._picker)</span>
            <span class="s2">if </span><span class="s1">isinstance(self._picker</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">and</span>
               <span class="s1">self._picker </span><span class="s2">is not True  </span><span class="s3"># the bool, not just nonzero or 1</span>
            <span class="s2">else </span><span class="s1">self._pickradius)</span>

        <span class="s2">if </span><span class="s1">self.axes:</span>
            <span class="s1">self.axes._unstale_viewLim()</span>

        <span class="s1">transform</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">paths = self._prepare_points()</span>

        <span class="s3"># Tests if the point is contained on one of the polygons formed</span>
        <span class="s3"># by the control points of each of the paths. A point is considered</span>
        <span class="s3"># &quot;on&quot; a path if it would lie within a stroke of width 2*pickradius</span>
        <span class="s3"># following the path. If pickradius &lt;= 0, then we instead simply check</span>
        <span class="s3"># if the point is *inside* of the path instead.</span>
        <span class="s1">ind = _path.point_in_path_collection(</span>
            <span class="s1">mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y</span><span class="s2">, </span><span class="s1">pickradius</span><span class="s2">,</span>
            <span class="s1">transform.frozen()</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">self.get_transforms()</span><span class="s2">,</span>
            <span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">, </span><span class="s1">pickradius &lt;= </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">len(ind) &gt; </span><span class="s5">0</span><span class="s2">, </span><span class="s1">dict(ind=ind)</span>

    <span class="s2">def </span><span class="s1">set_urls(self</span><span class="s2">, </span><span class="s1">urls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        urls : list of str or None 
 
        Notes 
        ----- 
        URLs are currently only implemented by the SVG backend. They are 
        ignored by all other backends. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._urls = urls </span><span class="s2">if </span><span class="s1">urls </span><span class="s2">is not None else </span><span class="s1">[</span><span class="s2">None</span><span class="s1">]</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_urls(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of URLs, one for each element of the collection. 
 
        The list contains *None* for elements without a URL. See 
        :doc:`/gallery/misc/hyperlinks_sgskip` for an example. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._urls</span>

    <span class="s2">def </span><span class="s1">set_hatch(self</span><span class="s2">, </span><span class="s1">hatch):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set the hatching pattern 
 
        *hatch* can be one of:: 
 
          /   - diagonal hatching 
          \   - back diagonal 
          |   - vertical 
          -   - horizontal 
          +   - crossed 
          x   - crossed diagonal 
          o   - small circle 
          O   - large circle 
          .   - dots 
          *   - stars 
 
        Letters can be combined, in which case all the specified 
        hatchings are done.  If same letter repeats, it increases the 
        density of hatching of that pattern. 
 
        Hatching is supported in the PostScript, PDF, SVG and Agg 
        backends only. 
 
        Unlike other properties such as linewidth and colors, hatching 
        can only be specified for the collection as a whole, not separately 
        for each member. 
 
        Parameters 
        ---------- 
        hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} 
        &quot;&quot;&quot;</span>
        <span class="s3"># Use validate_hatch(list) after deprecation.</span>
        <span class="s1">mhatch._validate_hatch_pattern(hatch)</span>
        <span class="s1">self._hatch = hatch</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_hatch(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the current hatching pattern.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._hatch</span>

    <span class="s2">def </span><span class="s1">set_offsets(self</span><span class="s2">, </span><span class="s1">offsets):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the offsets for the collection. 
 
        Parameters 
        ---------- 
        offsets : (N, 2) or (2,) array-like 
        &quot;&quot;&quot;</span>
        <span class="s1">offsets = np.asanyarray(offsets)</span>
        <span class="s2">if </span><span class="s1">offsets.shape == (</span><span class="s5">2</span><span class="s2">,</span><span class="s1">):  </span><span class="s3"># Broadcast (2,) -&gt; (1, 2) but nothing else.</span>
            <span class="s1">offsets = offsets[</span><span class="s2">None, </span><span class="s1">:]</span>
        <span class="s1">cstack = (np.ma.column_stack </span><span class="s2">if </span><span class="s1">isinstance(offsets</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray)</span>
                  <span class="s2">else </span><span class="s1">np.column_stack)</span>
        <span class="s1">self._offsets = cstack(</span>
            <span class="s1">(np.asanyarray(self.convert_xunits(offsets[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
             <span class="s1">np.asanyarray(self.convert_yunits(offsets[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">float)))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_offsets(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the offsets for the collection.&quot;&quot;&quot;</span>
        <span class="s3"># Default to zeros in the no-offset (None) case</span>
        <span class="s2">return </span><span class="s1">np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)) </span><span class="s2">if </span><span class="s1">self._offsets </span><span class="s2">is None else </span><span class="s1">self._offsets</span>

    <span class="s2">def </span><span class="s1">_get_default_linewidth(self):</span>
        <span class="s3"># This may be overridden in a subclass.</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'patch.linewidth'</span><span class="s1">]  </span><span class="s3"># validated as float</span>

    <span class="s2">def </span><span class="s1">set_linewidth(self</span><span class="s2">, </span><span class="s1">lw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the linewidth(s) for the collection.  *lw* can be a scalar 
        or a sequence; if it is a sequence the patches will cycle 
        through the sequence 
 
        Parameters 
        ---------- 
        lw : float or list of floats 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">lw </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">lw = self._get_default_linewidth()</span>
        <span class="s3"># get the un-scaled/broadcast lw</span>
        <span class="s1">self._us_lw = np.atleast_1d(lw)</span>

        <span class="s3"># scale all of the dash patterns.</span>
        <span class="s1">self._linewidths</span><span class="s2">, </span><span class="s1">self._linestyles = self._bcast_lwls(</span>
            <span class="s1">self._us_lw</span><span class="s2">, </span><span class="s1">self._us_linestyles)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_linestyle(self</span><span class="s2">, </span><span class="s1">ls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the linestyle(s) for the collection. 
 
        ===========================   ================= 
        linestyle                     description 
        ===========================   ================= 
        ``'-'`` or ``'solid'``        solid line 
        ``'--'`` or  ``'dashed'``     dashed line 
        ``'-.'`` or  ``'dashdot'``    dash-dotted line 
        ``':'`` or ``'dotted'``       dotted line 
        ===========================   ================= 
 
        Alternatively a dash tuple of the following form can be provided:: 
 
            (offset, onoffseq), 
 
        where ``onoffseq`` is an even length tuple of on and off ink in points. 
 
        Parameters 
        ---------- 
        ls : str or tuple or list thereof 
            Valid values for individual linestyles include {'-', '--', '-.', 
            ':', '', (offset, on-off-seq)}. See `.Line2D.set_linestyle` for a 
            complete description. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dashes = [mlines._get_dash_pattern(ls)]</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">dashes = [mlines._get_dash_pattern(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ls]</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s1">emsg = </span><span class="s4">f'Do not know how to convert </span><span class="s2">{</span><span class="s1">ls</span><span class="s2">!r} </span><span class="s4">to dashes'</span>
                <span class="s2">raise </span><span class="s1">ValueError(emsg) </span><span class="s2">from </span><span class="s1">err</span>

        <span class="s3"># get the list of raw 'unscaled' dash patterns</span>
        <span class="s1">self._us_linestyles = dashes</span>

        <span class="s3"># broadcast and scale the lw and dash patterns</span>
        <span class="s1">self._linewidths</span><span class="s2">, </span><span class="s1">self._linestyles = self._bcast_lwls(</span>
            <span class="s1">self._us_lw</span><span class="s2">, </span><span class="s1">self._us_linestyles)</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_capstyle(self</span><span class="s2">, </span><span class="s1">cs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the `.CapStyle` for the collection (for all its elements). 
 
        Parameters 
        ---------- 
        cs : `.CapStyle` or %(CapStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._capstyle = CapStyle(cs)</span>

    <span class="s2">def </span><span class="s1">get_capstyle(self):</span>
        <span class="s2">return </span><span class="s1">self._capstyle.name</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_joinstyle(self</span><span class="s2">, </span><span class="s1">js):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the `.JoinStyle` for the collection (for all its elements). 
 
        Parameters 
        ---------- 
        js : `.JoinStyle` or %(JoinStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._joinstyle = JoinStyle(js)</span>

    <span class="s2">def </span><span class="s1">get_joinstyle(self):</span>
        <span class="s2">return </span><span class="s1">self._joinstyle.name</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_bcast_lwls(linewidths</span><span class="s2">, </span><span class="s1">dashes):</span>
        <span class="s0">&quot;&quot;&quot; 
        Internal helper function to broadcast + scale ls/lw 
 
        In the collection drawing code, the linewidth and linestyle are cycled 
        through as circular buffers (via ``v[i % len(v)]``).  Thus, if we are 
        going to scale the dash pattern at set time (not draw time) we need to 
        do the broadcasting now and expand both lists to be the same length. 
 
        Parameters 
        ---------- 
        linewidths : list 
            line widths of collection 
        dashes : list 
            dash specification (offset, (dash pattern tuple)) 
 
        Returns 
        ------- 
        linewidths, dashes : list 
            Will be the same length, dashes are scaled by paired linewidth 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">dashes</span>
        <span class="s3"># make sure they are the same length so we can zip them</span>
        <span class="s2">if </span><span class="s1">len(dashes) != len(linewidths):</span>
            <span class="s1">l_dashes = len(dashes)</span>
            <span class="s1">l_lw = len(linewidths)</span>
            <span class="s1">gcd = math.gcd(l_dashes</span><span class="s2">, </span><span class="s1">l_lw)</span>
            <span class="s1">dashes = list(dashes) * (l_lw // gcd)</span>
            <span class="s1">linewidths = list(linewidths) * (l_dashes // gcd)</span>

        <span class="s3"># scale the dash patterns</span>
        <span class="s1">dashes = [mlines._scale_dashes(o</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">lw)</span>
                  <span class="s2">for </span><span class="s1">(o</span><span class="s2">, </span><span class="s1">d)</span><span class="s2">, </span><span class="s1">lw </span><span class="s2">in </span><span class="s1">zip(dashes</span><span class="s2">, </span><span class="s1">linewidths)]</span>

        <span class="s2">return </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">dashes</span>

    <span class="s2">def </span><span class="s1">set_antialiased(self</span><span class="s2">, </span><span class="s1">aa):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the antialiasing state for rendering. 
 
        Parameters 
        ---------- 
        aa : bool or list of bools 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">aa </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">aa = self._get_default_antialiased()</span>
        <span class="s1">self._antialiaseds = np.atleast_1d(np.asarray(aa</span><span class="s2">, </span><span class="s1">bool))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_get_default_antialiased(self):</span>
        <span class="s3"># This may be overridden in a subclass.</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'patch.antialiased'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">set_color(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set both the edgecolor and the facecolor. 
 
        Parameters 
        ---------- 
        c : color or list of RGBA tuples 
 
        See Also 
        -------- 
        Collection.set_facecolor, Collection.set_edgecolor 
            For setting the edge or face color individually. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_facecolor(c)</span>
        <span class="s1">self.set_edgecolor(c)</span>

    <span class="s2">def </span><span class="s1">_get_default_facecolor(self):</span>
        <span class="s3"># This may be overridden in a subclass.</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'patch.facecolor'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_set_facecolor(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s2">if </span><span class="s1">c </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">c = self._get_default_facecolor()</span>

        <span class="s1">self._facecolors = mcolors.to_rgba_array(c</span><span class="s2">, </span><span class="s1">self._alpha)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_facecolor(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the facecolor(s) of the collection. *c* can be a color (all patches 
        have same color), or a sequence of colors; if it is a sequence the 
        patches will cycle through the sequence. 
 
        If *c* is 'none', the patch will not be filled. 
 
        Parameters 
        ---------- 
        c : color or list of colors 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">c.lower() </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;none&quot;</span><span class="s2">, </span><span class="s4">&quot;face&quot;</span><span class="s1">):</span>
            <span class="s1">c = c.lower()</span>
        <span class="s1">self._original_facecolor = c</span>
        <span class="s1">self._set_facecolor(c)</span>

    <span class="s2">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s2">return </span><span class="s1">self._facecolors</span>

    <span class="s2">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s2">if </span><span class="s1">cbook._str_equal(self._edgecolors</span><span class="s2">, </span><span class="s4">'face'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">self.get_facecolor()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._edgecolors</span>

    <span class="s2">def </span><span class="s1">_get_default_edgecolor(self):</span>
        <span class="s3"># This may be overridden in a subclass.</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'patch.edgecolor'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_set_edgecolor(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s1">set_hatch_color = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">c </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(mpl.rcParams[</span><span class="s4">'patch.force_edgecolor'</span><span class="s1">]</span>
                    <span class="s2">or </span><span class="s1">self._edge_default</span>
                    <span class="s2">or </span><span class="s1">cbook._str_equal(self._original_facecolor</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">)):</span>
                <span class="s1">c = self._get_default_edgecolor()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">c = </span><span class="s4">'none'</span>
                <span class="s1">set_hatch_color = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">cbook._str_lower_equal(c</span><span class="s2">, </span><span class="s4">'face'</span><span class="s1">):</span>
            <span class="s1">self._edgecolors = </span><span class="s4">'face'</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>
            <span class="s2">return</span>
        <span class="s1">self._edgecolors = mcolors.to_rgba_array(c</span><span class="s2">, </span><span class="s1">self._alpha)</span>
        <span class="s2">if </span><span class="s1">set_hatch_color </span><span class="s2">and </span><span class="s1">len(self._edgecolors):</span>
            <span class="s1">self._hatch_color = tuple(self._edgecolors[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_edgecolor(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the edgecolor(s) of the collection. 
 
        Parameters 
        ---------- 
        c : color or list of colors or 'face' 
            The collection edgecolor(s).  If a sequence, the patches cycle 
            through it.  If 'face', match the facecolor. 
        &quot;&quot;&quot;</span>
        <span class="s3"># We pass through a default value for use in LineCollection.</span>
        <span class="s3"># This allows us to maintain None as the default indicator in</span>
        <span class="s3"># _original_edgecolor.</span>
        <span class="s2">if </span><span class="s1">isinstance(c</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">c.lower() </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;none&quot;</span><span class="s2">, </span><span class="s4">&quot;face&quot;</span><span class="s1">):</span>
            <span class="s1">c = c.lower()</span>
        <span class="s1">self._original_edgecolor = c</span>
        <span class="s1">self._set_edgecolor(c)</span>

    <span class="s2">def </span><span class="s1">set_alpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the transparency of the collection. 
 
        Parameters 
        ---------- 
        alpha : float or array of float or None 
            If not None, *alpha* values must be between 0 and 1, inclusive. 
            If an array is provided, its length must match the number of 
            elements in the collection.  Masked values and nans are not 
            supported. 
        &quot;&quot;&quot;</span>
        <span class="s1">artist.Artist._set_alpha_for_array(self</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s1">self._set_facecolor(self._original_facecolor)</span>
        <span class="s1">self._set_edgecolor(self._original_edgecolor)</span>

    <span class="s1">set_alpha.__doc__ = artist.Artist._set_alpha_for_array.__doc__</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s2">return </span><span class="s1">self._linewidths</span>

    <span class="s2">def </span><span class="s1">get_linestyle(self):</span>
        <span class="s2">return </span><span class="s1">self._linestyles</span>

    <span class="s2">def </span><span class="s1">_set_mappable_flags(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Determine whether edges and/or faces are color-mapped. 
 
        This is a helper for update_scalarmappable. 
        It sets Boolean flags '_edge_is_mapped' and '_face_is_mapped'. 
 
        Returns 
        ------- 
        mapping_change : bool 
            True if either flag is True, or if a flag has changed. 
        &quot;&quot;&quot;</span>
        <span class="s3"># The flags are initialized to None to ensure this returns True</span>
        <span class="s3"># the first time it is called.</span>
        <span class="s1">edge0 = self._edge_is_mapped</span>
        <span class="s1">face0 = self._face_is_mapped</span>
        <span class="s3"># After returning, the flags must be Booleans, not None.</span>
        <span class="s1">self._edge_is_mapped = </span><span class="s2">False</span>
        <span class="s1">self._face_is_mapped = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">cbook._str_equal(self._original_facecolor</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">):</span>
                <span class="s1">self._face_is_mapped = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">cbook._str_equal(self._original_edgecolor</span><span class="s2">, </span><span class="s4">'face'</span><span class="s1">):</span>
                    <span class="s1">self._edge_is_mapped = </span><span class="s2">True</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._original_edgecolor </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self._edge_is_mapped = </span><span class="s2">True</span>

        <span class="s1">mapped = self._face_is_mapped </span><span class="s2">or </span><span class="s1">self._edge_is_mapped</span>
        <span class="s1">changed = (edge0 </span><span class="s2">is None or </span><span class="s1">face0 </span><span class="s2">is None</span>
                   <span class="s2">or </span><span class="s1">self._edge_is_mapped != edge0</span>
                   <span class="s2">or </span><span class="s1">self._face_is_mapped != face0)</span>
        <span class="s2">return </span><span class="s1">mapped </span><span class="s2">or </span><span class="s1">changed</span>

    <span class="s2">def </span><span class="s1">update_scalarmappable(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update colors from the scalar mappable array, if any. 
 
        Assign colors to edges and faces based on the array and/or 
        colors that were directly set, as appropriate. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._set_mappable_flags():</span>
            <span class="s2">return</span>
        <span class="s3"># Allow possibility to call 'self.set_array(None)'.</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)</span>
            <span class="s2">if </span><span class="s1">self._A.ndim &gt; </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">QuadMesh):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Collections can only map rank 1 arrays'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">np.iterable(self._alpha):</span>
                <span class="s2">if </span><span class="s1">self._alpha.size != self._A.size:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">f'Data array shape, </span><span class="s2">{</span><span class="s1">self._A.shape</span><span class="s2">} </span><span class="s4">'</span>
                        <span class="s4">'is incompatible with alpha array shape, '</span>
                        <span class="s4">f'</span><span class="s2">{</span><span class="s1">self._alpha.shape</span><span class="s2">}</span><span class="s4">. '</span>
                        <span class="s4">'This can occur with the deprecated '</span>
                        <span class="s4">'behavior of the &quot;flat&quot; shading option, '</span>
                        <span class="s4">'in which a row and/or column of the data '</span>
                        <span class="s4">'array is dropped.'</span><span class="s1">)</span>
                <span class="s3"># pcolormesh, scatter, maybe others flatten their _A</span>
                <span class="s1">self._alpha = self._alpha.reshape(self._A.shape)</span>
            <span class="s1">self._mapped_colors = self.to_rgba(self._A</span><span class="s2">, </span><span class="s1">self._alpha)</span>

        <span class="s2">if </span><span class="s1">self._face_is_mapped:</span>
            <span class="s1">self._facecolors = self._mapped_colors</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._set_facecolor(self._original_facecolor)</span>
        <span class="s2">if </span><span class="s1">self._edge_is_mapped:</span>
            <span class="s1">self._edgecolors = self._mapped_colors</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._set_edgecolor(self._original_edgecolor)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_fill(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether face is colored.&quot;&quot;&quot;</span>
        <span class="s2">return not </span><span class="s1">cbook._str_lower_equal(self._original_facecolor</span><span class="s2">, </span><span class="s4">&quot;none&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">update_from(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Copy properties from other to self.&quot;&quot;&quot;</span>

        <span class="s1">artist.Artist.update_from(self</span><span class="s2">, </span><span class="s1">other)</span>
        <span class="s1">self._antialiaseds = other._antialiaseds</span>
        <span class="s1">self._mapped_colors = other._mapped_colors</span>
        <span class="s1">self._edge_is_mapped = other._edge_is_mapped</span>
        <span class="s1">self._original_edgecolor = other._original_edgecolor</span>
        <span class="s1">self._edgecolors = other._edgecolors</span>
        <span class="s1">self._face_is_mapped = other._face_is_mapped</span>
        <span class="s1">self._original_facecolor = other._original_facecolor</span>
        <span class="s1">self._facecolors = other._facecolors</span>
        <span class="s1">self._linewidths = other._linewidths</span>
        <span class="s1">self._linestyles = other._linestyles</span>
        <span class="s1">self._us_linestyles = other._us_linestyles</span>
        <span class="s1">self._pickradius = other._pickradius</span>
        <span class="s1">self._hatch = other._hatch</span>

        <span class="s3"># update_from for scalarmappable</span>
        <span class="s1">self._A = other._A</span>
        <span class="s1">self.norm = other.norm</span>
        <span class="s1">self.cmap = other.cmap</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">_CollectionWithSizes(Collection):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for collections that have an array of sizes. 
    &quot;&quot;&quot;</span>
    <span class="s1">_factor = </span><span class="s5">1.0</span>

    <span class="s2">def </span><span class="s1">get_sizes(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the sizes ('areas') of the elements in the collection. 
 
        Returns 
        ------- 
        array 
            The 'area' of each element. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._sizes</span>

    <span class="s2">def </span><span class="s1">set_sizes(self</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">dpi=</span><span class="s5">72.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the sizes of each member of the collection. 
 
        Parameters 
        ---------- 
        sizes : `numpy.ndarray` or None 
            The size to set for each element of the collection.  The 
            value is the 'area' of the element. 
        dpi : float, default: 72 
            The dpi of the canvas. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">sizes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._sizes = np.array([])</span>
            <span class="s1">self._transforms = np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._sizes = np.asarray(sizes)</span>
            <span class="s1">self._transforms = np.zeros((len(self._sizes)</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
            <span class="s1">scale = np.sqrt(self._sizes) * dpi / </span><span class="s5">72.0 </span><span class="s1">* self._factor</span>
            <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = scale</span>
            <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = scale</span>
            <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = </span><span class="s5">1.0</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self.set_sizes(self._sizes</span><span class="s2">, </span><span class="s1">self.figure.dpi)</span>
        <span class="s1">super().draw(renderer)</span>


<span class="s2">class </span><span class="s1">PathCollection(_CollectionWithSizes):</span>
    <span class="s0">r&quot;&quot;&quot; 
    A collection of `~.path.Path`\s, as created by e.g. `~.Axes.scatter`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">sizes=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        paths : list of `.path.Path` 
            The paths that will make up the `.Collection`. 
        sizes : array-like 
            The factor by which to scale each drawn `~.path.Path`. One unit 
            squared in the Path's data space is scaled to be ``sizes**2`` 
            points when rendered. 
        **kwargs 
            Forwarded to `.Collection`. 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.set_paths(paths)</span>
        <span class="s1">self.set_sizes(sizes)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_paths(self</span><span class="s2">, </span><span class="s1">paths):</span>
        <span class="s1">self._paths = paths</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_paths(self):</span>
        <span class="s2">return </span><span class="s1">self._paths</span>

    <span class="s2">def </span><span class="s1">legend_elements(self</span><span class="s2">, </span><span class="s1">prop=</span><span class="s4">&quot;colors&quot;</span><span class="s2">, </span><span class="s1">num=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
                        <span class="s1">fmt=</span><span class="s2">None, </span><span class="s1">func=</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create legend handles and labels for a PathCollection. 
 
        Each legend handle is a `.Line2D` representing the Path that was drawn, 
        and each label is a string what each Path represents. 
 
        This is useful for obtaining a legend for a `~.Axes.scatter` plot; 
        e.g.:: 
 
            scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3]) 
            plt.legend(*scatter.legend_elements()) 
 
        creates three legend elements, one for each color with the numerical 
        values passed to *c* as the labels. 
 
        Also see the :ref:`automatedlegendcreation` example. 
 
        Parameters 
        ---------- 
        prop : {&quot;colors&quot;, &quot;sizes&quot;}, default: &quot;colors&quot; 
            If &quot;colors&quot;, the legend handles will show the different colors of 
            the collection. If &quot;sizes&quot;, the legend will show the different 
            sizes. To set both, use *kwargs* to directly edit the `.Line2D` 
            properties. 
        num : int, None, &quot;auto&quot; (default), array-like, or `~.ticker.Locator` 
            Target number of elements to create. 
            If None, use all unique elements of the mappable array. If an 
            integer, target to use *num* elements in the normed range. 
            If *&quot;auto&quot;*, try to determine which option better suits the nature 
            of the data. 
            The number of created elements may slightly deviate from *num* due 
            to a `~.ticker.Locator` being used to find useful locations. 
            If a list or array, use exactly those elements for the legend. 
            Finally, a `~.ticker.Locator` can be provided. 
        fmt : str, `~matplotlib.ticker.Formatter`, or None (default) 
            The format or formatter to use for the labels. If a string must be 
            a valid input for a `.StrMethodFormatter`. If None (the default), 
            use a `.ScalarFormatter`. 
        func : function, default: ``lambda x: x`` 
            Function to calculate the labels.  Often the size (or color) 
            argument to `~.Axes.scatter` will have been pre-processed by the 
            user using a function ``s = f(x)`` to make the markers visible; 
            e.g. ``size = np.log10(x)``.  Providing the inverse of this 
            function here allows that pre-processing to be inverted, so that 
            the legend labels have the correct values; e.g. ``func = lambda 
            x: 10**x``. 
        **kwargs 
            Allowed keyword arguments are *color* and *size*. E.g. it may be 
            useful to set the color of the markers if *prop=&quot;sizes&quot;* is used; 
            similarly to set the size of the markers if *prop=&quot;colors&quot;* is 
            used. Any further parameters are passed onto the `.Line2D` 
            instance. This may be useful to e.g. specify a different 
            *markeredgecolor* or *alpha* for the legend handles. 
 
        Returns 
        ------- 
        handles : list of `.Line2D` 
            Visual representation of each element of the legend. 
        labels : list of str 
            The string labels for elements of the legend. 
        &quot;&quot;&quot;</span>
        <span class="s1">handles = []</span>
        <span class="s1">labels = []</span>
        <span class="s1">hasarray = self.get_array() </span><span class="s2">is not None</span>
        <span class="s2">if </span><span class="s1">fmt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fmt = mpl.ticker.ScalarFormatter(useOffset=</span><span class="s2">False, </span><span class="s1">useMathText=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(fmt</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">fmt = mpl.ticker.StrMethodFormatter(fmt)</span>
        <span class="s1">fmt.create_dummy_axis()</span>

        <span class="s2">if </span><span class="s1">prop == </span><span class="s4">&quot;colors&quot;</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">hasarray:</span>
                <span class="s1">warnings.warn(</span><span class="s4">&quot;Collection without array used. Make sure to &quot;</span>
                              <span class="s4">&quot;specify the values to be colormapped via the &quot;</span>
                              <span class="s4">&quot;`c` argument.&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">handles</span><span class="s2">, </span><span class="s1">labels</span>
            <span class="s1">u = np.unique(self.get_array())</span>
            <span class="s1">size = kwargs.pop(</span><span class="s4">&quot;size&quot;</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;lines.markersize&quot;</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">prop == </span><span class="s4">&quot;sizes&quot;</span><span class="s1">:</span>
            <span class="s1">u = np.unique(self.get_sizes())</span>
            <span class="s1">color = kwargs.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s4">&quot;k&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Valid values for `prop` are 'colors' or &quot;</span>
                             <span class="s4">f&quot;'sizes'. You supplied '</span><span class="s2">{</span><span class="s1">prop</span><span class="s2">}</span><span class="s4">' instead.&quot;</span><span class="s1">)</span>

        <span class="s1">fu = func(u)</span>
        <span class="s1">fmt.axis.set_view_interval(fu.min()</span><span class="s2">, </span><span class="s1">fu.max())</span>
        <span class="s1">fmt.axis.set_data_interval(fu.min()</span><span class="s2">, </span><span class="s1">fu.max())</span>
        <span class="s2">if </span><span class="s1">num == </span><span class="s4">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">num = </span><span class="s5">9</span>
            <span class="s2">if </span><span class="s1">len(u) &lt;= num:</span>
                <span class="s1">num = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">num </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">values = u</span>
            <span class="s1">label_values = func(values)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">prop == </span><span class="s4">&quot;colors&quot;</span><span class="s1">:</span>
                <span class="s1">arr = self.get_array()</span>
            <span class="s2">elif </span><span class="s1">prop == </span><span class="s4">&quot;sizes&quot;</span><span class="s1">:</span>
                <span class="s1">arr = self.get_sizes()</span>
            <span class="s2">if </span><span class="s1">isinstance(num</span><span class="s2">, </span><span class="s1">mpl.ticker.Locator):</span>
                <span class="s1">loc = num</span>
            <span class="s2">elif </span><span class="s1">np.iterable(num):</span>
                <span class="s1">loc = mpl.ticker.FixedLocator(num)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">num = int(num)</span>
                <span class="s1">loc = mpl.ticker.MaxNLocator(nbins=num</span><span class="s2">, </span><span class="s1">min_n_ticks=num-</span><span class="s5">1</span><span class="s2">,</span>
                                             <span class="s1">steps=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span>
            <span class="s1">label_values = loc.tick_values(func(arr).min()</span><span class="s2">, </span><span class="s1">func(arr).max())</span>
            <span class="s1">cond = ((label_values &gt;= func(arr).min()) &amp;</span>
                    <span class="s1">(label_values &lt;= func(arr).max()))</span>
            <span class="s1">label_values = label_values[cond]</span>
            <span class="s1">yarr = np.linspace(arr.min()</span><span class="s2">, </span><span class="s1">arr.max()</span><span class="s2">, </span><span class="s5">256</span><span class="s1">)</span>
            <span class="s1">xarr = func(yarr)</span>
            <span class="s1">ix = np.argsort(xarr)</span>
            <span class="s1">values = np.interp(label_values</span><span class="s2">, </span><span class="s1">xarr[ix]</span><span class="s2">, </span><span class="s1">yarr[ix])</span>

        <span class="s1">kw = {</span><span class="s4">&quot;markeredgewidth&quot;</span><span class="s1">: self.get_linewidths()[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
              <span class="s4">&quot;alpha&quot;</span><span class="s1">: self.get_alpha()</span><span class="s2">,</span>
              <span class="s1">**kwargs}</span>

        <span class="s2">for </span><span class="s1">val</span><span class="s2">, </span><span class="s1">lab </span><span class="s2">in </span><span class="s1">zip(values</span><span class="s2">, </span><span class="s1">label_values):</span>
            <span class="s2">if </span><span class="s1">prop == </span><span class="s4">&quot;colors&quot;</span><span class="s1">:</span>
                <span class="s1">color = self.cmap(self.norm(val))</span>
            <span class="s2">elif </span><span class="s1">prop == </span><span class="s4">&quot;sizes&quot;</span><span class="s1">:</span>
                <span class="s1">size = np.sqrt(val)</span>
                <span class="s2">if </span><span class="s1">np.isclose(size</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">):</span>
                    <span class="s2">continue</span>
            <span class="s1">h = mlines.Line2D([</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ls=</span><span class="s4">&quot;&quot;</span><span class="s2">, </span><span class="s1">color=color</span><span class="s2">, </span><span class="s1">ms=size</span><span class="s2">,</span>
                              <span class="s1">marker=self.get_paths()[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">**kw)</span>
            <span class="s1">handles.append(h)</span>
            <span class="s2">if </span><span class="s1">hasattr(fmt</span><span class="s2">, </span><span class="s4">&quot;set_locs&quot;</span><span class="s1">):</span>
                <span class="s1">fmt.set_locs(label_values)</span>
            <span class="s1">l = fmt(lab)</span>
            <span class="s1">labels.append(l)</span>

        <span class="s2">return </span><span class="s1">handles</span><span class="s2">, </span><span class="s1">labels</span>


<span class="s2">class </span><span class="s1">PolyCollection(_CollectionWithSizes):</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;closed&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">verts</span><span class="s2">, </span><span class="s1">sizes=</span><span class="s2">None, </span><span class="s1">closed=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        verts : list of array-like 
            The sequence of polygons [*verts0*, *verts1*, ...] where each 
            element *verts_i* defines the vertices of polygon *i* as a 2D 
            array-like of shape (M, 2). 
        sizes : array-like, default: None 
            Squared scaling factors for the polygons. The coordinates of each 
            polygon *verts_i* are multiplied by the square-root of the 
            corresponding entry in *sizes* (i.e., *sizes* specify the scaling 
            of areas). The scaling is applied before the Artist master 
            transform. 
        closed : bool, default: True 
            Whether the polygon should be closed by adding a CLOSEPOLY 
            connection at the end. 
        **kwargs 
            Forwarded to `.Collection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.set_sizes(sizes)</span>
        <span class="s1">self.set_verts(verts</span><span class="s2">, </span><span class="s1">closed)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_verts(self</span><span class="s2">, </span><span class="s1">verts</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the vertices of the polygons. 
 
        Parameters 
        ---------- 
        verts : list of array-like 
            The sequence of polygons [*verts0*, *verts1*, ...] where each 
            element *verts_i* defines the vertices of polygon *i* as a 2D 
            array-like of shape (M, 2). 
        closed : bool, default: True 
            Whether the polygon should be closed by adding a CLOSEPOLY 
            connection at the end. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">isinstance(verts</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">verts = verts.astype(float).filled(np.nan)</span>

        <span class="s3"># No need to do anything fancy if the path isn't closed.</span>
        <span class="s2">if not </span><span class="s1">closed:</span>
            <span class="s1">self._paths = [mpath.Path(xy) </span><span class="s2">for </span><span class="s1">xy </span><span class="s2">in </span><span class="s1">verts]</span>
            <span class="s2">return</span>

        <span class="s3"># Fast path for arrays</span>
        <span class="s2">if </span><span class="s1">isinstance(verts</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">len(verts.shape) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">verts_pad = np.concatenate((verts</span><span class="s2">, </span><span class="s1">verts[:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3"># Creating the codes once is much faster than having Path do it</span>
            <span class="s3"># separately each time by passing closed=True.</span>
            <span class="s1">codes = np.empty(verts_pad.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=mpath.Path.code_type)</span>
            <span class="s1">codes[:] = mpath.Path.LINETO</span>
            <span class="s1">codes[</span><span class="s5">0</span><span class="s1">] = mpath.Path.MOVETO</span>
            <span class="s1">codes[-</span><span class="s5">1</span><span class="s1">] = mpath.Path.CLOSEPOLY</span>
            <span class="s1">self._paths = [mpath.Path(xy</span><span class="s2">, </span><span class="s1">codes) </span><span class="s2">for </span><span class="s1">xy </span><span class="s2">in </span><span class="s1">verts_pad]</span>
            <span class="s2">return</span>

        <span class="s1">self._paths = []</span>
        <span class="s2">for </span><span class="s1">xy </span><span class="s2">in </span><span class="s1">verts:</span>
            <span class="s2">if </span><span class="s1">len(xy):</span>
                <span class="s1">self._paths.append(mpath.Path._create_closed(xy))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._paths.append(mpath.Path(xy))</span>

    <span class="s1">set_paths = set_verts</span>

    <span class="s2">def </span><span class="s1">set_verts_and_codes(self</span><span class="s2">, </span><span class="s1">verts</span><span class="s2">, </span><span class="s1">codes):</span>
        <span class="s0">&quot;&quot;&quot;Initialize vertices with path codes.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(verts) != len(codes):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'codes' must be a 1D list or array &quot;</span>
                             <span class="s4">&quot;with the same length of 'verts'&quot;</span><span class="s1">)</span>
        <span class="s1">self._paths = [mpath.Path(xy</span><span class="s2">, </span><span class="s1">cds) </span><span class="s2">if </span><span class="s1">len(xy) </span><span class="s2">else </span><span class="s1">mpath.Path(xy)</span>
                       <span class="s2">for </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">cds </span><span class="s2">in </span><span class="s1">zip(verts</span><span class="s2">, </span><span class="s1">codes)]</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.7&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;fill_between&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">span_where(cls</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a `.BrokenBarHCollection` that plots horizontal bars from 
        over the regions in *x* where *where* is True.  The bars range 
        on the y-axis from *ymin* to *ymax* 
 
        *kwargs* are passed on to the collection. 
        &quot;&quot;&quot;</span>
        <span class="s1">xranges = []</span>
        <span class="s2">for </span><span class="s1">ind0</span><span class="s2">, </span><span class="s1">ind1 </span><span class="s2">in </span><span class="s1">cbook.contiguous_regions(where):</span>
            <span class="s1">xslice = x[ind0:ind1]</span>
            <span class="s2">if not </span><span class="s1">len(xslice):</span>
                <span class="s2">continue</span>
            <span class="s1">xranges.append((xslice[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xslice[-</span><span class="s5">1</span><span class="s1">] - xslice[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s2">return </span><span class="s1">BrokenBarHCollection(xranges</span><span class="s2">, </span><span class="s1">[ymin</span><span class="s2">, </span><span class="s1">ymax - ymin]</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.7&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">BrokenBarHCollection(PolyCollection):</span>
    <span class="s0">&quot;&quot;&quot; 
    A collection of horizontal bars spanning *yrange* with a sequence of 
    *xranges*. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xranges</span><span class="s2">, </span><span class="s1">yrange</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xranges : list of (float, float) 
            The sequence of (left-edge-position, width) pairs for each bar. 
        yrange : (float, float) 
            The (lower-edge, height) common to all bars. 
        **kwargs 
            Forwarded to `.Collection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">ymin</span><span class="s2">, </span><span class="s1">ywidth = yrange</span>
        <span class="s1">ymax = ymin + ywidth</span>
        <span class="s1">verts = [[(xmin</span><span class="s2">, </span><span class="s1">ymin)</span><span class="s2">,</span>
                  <span class="s1">(xmin</span><span class="s2">, </span><span class="s1">ymax)</span><span class="s2">,</span>
                  <span class="s1">(xmin + xwidth</span><span class="s2">, </span><span class="s1">ymax)</span><span class="s2">,</span>
                  <span class="s1">(xmin + xwidth</span><span class="s2">, </span><span class="s1">ymin)</span><span class="s2">,</span>
                  <span class="s1">(xmin</span><span class="s2">, </span><span class="s1">ymin)] </span><span class="s2">for </span><span class="s1">xmin</span><span class="s2">, </span><span class="s1">xwidth </span><span class="s2">in </span><span class="s1">xranges]</span>
        <span class="s1">super().__init__(verts</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">RegularPolyCollection(_CollectionWithSizes):</span>
    <span class="s0">&quot;&quot;&quot;A collection of n-sided regular polygons.&quot;&quot;&quot;</span>

    <span class="s1">_path_generator = mpath.Path.unit_regular_polygon</span>
    <span class="s1">_factor = np.pi ** (-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;rotation&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">numsides</span><span class="s2">,</span>
                 <span class="s1">rotation=</span><span class="s5">0</span><span class="s2">,</span>
                 <span class="s1">sizes=(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        numsides : int 
            The number of sides of the polygon. 
        rotation : float 
            The rotation of the polygon in radians. 
        sizes : tuple of float 
            The area of the circle circumscribing the polygon in points^2. 
        **kwargs 
            Forwarded to `.Collection`. 
 
        Examples 
        -------- 
        See :doc:`/gallery/event_handling/lasso_demo` for a complete example:: 
 
            offsets = np.random.rand(20, 2) 
            facecolors = [cm.jet(x) for x in np.random.rand(20)] 
 
            collection = RegularPolyCollection( 
                numsides=5, # a pentagon 
                rotation=0, sizes=(50,), 
                facecolors=facecolors, 
                edgecolors=(&quot;black&quot;,), 
                linewidths=(1,), 
                offsets=offsets, 
                offset_transform=ax.transData, 
                ) 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.set_sizes(sizes)</span>
        <span class="s1">self._numsides = numsides</span>
        <span class="s1">self._paths = [self._path_generator(numsides)]</span>
        <span class="s1">self._rotation = rotation</span>
        <span class="s1">self.set_transform(transforms.IdentityTransform())</span>

    <span class="s2">def </span><span class="s1">get_numsides(self):</span>
        <span class="s2">return </span><span class="s1">self._numsides</span>

    <span class="s2">def </span><span class="s1">get_rotation(self):</span>
        <span class="s2">return </span><span class="s1">self._rotation</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self.set_sizes(self._sizes</span><span class="s2">, </span><span class="s1">self.figure.dpi)</span>
        <span class="s1">self._transforms = [</span>
            <span class="s1">transforms.Affine2D(x).rotate(-self._rotation).get_matrix()</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._transforms</span>
        <span class="s1">]</span>
        <span class="s3"># Explicitly not super().draw, because set_sizes must be called before</span>
        <span class="s3"># updating self._transforms.</span>
        <span class="s1">Collection.draw(self</span><span class="s2">, </span><span class="s1">renderer)</span>


<span class="s2">class </span><span class="s1">StarPolygonCollection(RegularPolyCollection):</span>
    <span class="s0">&quot;&quot;&quot;Draw a collection of regular stars with *numsides* points.&quot;&quot;&quot;</span>
    <span class="s1">_path_generator = mpath.Path.unit_regular_star</span>


<span class="s2">class </span><span class="s1">AsteriskPolygonCollection(RegularPolyCollection):</span>
    <span class="s0">&quot;&quot;&quot;Draw a collection of regular asterisks with *numsides* points.&quot;&quot;&quot;</span>
    <span class="s1">_path_generator = mpath.Path.unit_regular_asterisk</span>


<span class="s2">class </span><span class="s1">LineCollection(Collection):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Represents a sequence of `.Line2D`\s that should be drawn together. 
 
    This class extends `.Collection` to represent a sequence of 
    `.Line2D`\s instead of just a sequence of `.Patch`\s. 
    Just as in `.Collection`, each property of a *LineCollection* may be either 
    a single value or a list of values. This list is then used cyclically for 
    each element of the LineCollection, so the property of the ``i``\th element 
    of the collection is:: 
 
      prop[i % len(prop)] 
 
    The properties of each member of a *LineCollection* default to their values 
    in :rc:`lines.*` instead of :rc:`patch.*`, and the property *colors* is 
    added in place of *edgecolors*. 
    &quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">segments</span><span class="s2">,  </span><span class="s3"># Can be None.</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">zorder=</span><span class="s5">2</span><span class="s2">,        </span><span class="s3"># Collection.zorder is 1</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        segments : list of array-like 
            A sequence of (*line0*, *line1*, *line2*), where:: 
 
                linen = (x0, y0), (x1, y1), ... (xm, ym) 
 
            or the equivalent numpy array with two columns. Each line 
            can have a different number of segments. 
        linewidths : float or list of float, default: :rc:`lines.linewidth` 
            The width of each line in points. 
        colors : color or list of color, default: :rc:`lines.color` 
            A sequence of RGBA tuples (e.g., arbitrary color strings, etc, not 
            allowed). 
        antialiaseds : bool or list of bool, default: :rc:`lines.antialiased` 
            Whether to use antialiasing for each line. 
        zorder : float, default: 2 
            zorder of the lines once drawn. 
 
        facecolors : color or list of color, default: 'none' 
            When setting *facecolors*, each line is interpreted as a boundary 
            for an area, implicitly closing the path from the last point to the 
            first point. The enclosed area is filled with *facecolor*. 
            In order to manually specify what should count as the &quot;interior&quot; of 
            each line, please use `.PathCollection` instead, where the 
            &quot;interior&quot; can be specified by appropriate usage of 
            `~.path.Path.CLOSEPOLY`. 
 
        **kwargs 
            Forwarded to `.Collection`. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Unfortunately, mplot3d needs this explicit setting of 'facecolors'.</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">'facecolors'</span><span class="s2">, </span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">zorder=zorder</span><span class="s2">,</span>
            <span class="s1">**kwargs)</span>
        <span class="s1">self.set_segments(segments)</span>

    <span class="s2">def </span><span class="s1">set_segments(self</span><span class="s2">, </span><span class="s1">segments):</span>
        <span class="s2">if </span><span class="s1">segments </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">self._paths = [mpath.Path(seg) </span><span class="s2">if </span><span class="s1">isinstance(seg</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray)</span>
                       <span class="s2">else </span><span class="s1">mpath.Path(np.asarray(seg</span><span class="s2">, </span><span class="s1">float))</span>
                       <span class="s2">for </span><span class="s1">seg </span><span class="s2">in </span><span class="s1">segments]</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">set_verts = set_segments  </span><span class="s3"># for compatibility with PolyCollection</span>
    <span class="s1">set_paths = set_segments</span>

    <span class="s2">def </span><span class="s1">get_segments(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns 
        ------- 
        list 
            List of segments in the LineCollection. Each list item contains an 
            array of vertices. 
        &quot;&quot;&quot;</span>
        <span class="s1">segments = []</span>

        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">self._paths:</span>
            <span class="s1">vertices = [</span>
                <span class="s1">vertex</span>
                <span class="s2">for </span><span class="s1">vertex</span><span class="s2">, </span><span class="s1">_</span>
                <span class="s3"># Never simplify here, we want to get the data-space values</span>
                <span class="s3"># back and there in no way to know the &quot;right&quot; simplification</span>
                <span class="s3"># threshold so never try.</span>
                <span class="s2">in </span><span class="s1">path.iter_segments(simplify=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">vertices = np.asarray(vertices)</span>
            <span class="s1">segments.append(vertices)</span>

        <span class="s2">return </span><span class="s1">segments</span>

    <span class="s2">def </span><span class="s1">_get_default_linewidth(self):</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'lines.linewidth'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_get_default_antialiased(self):</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'lines.antialiased'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_get_default_edgecolor(self):</span>
        <span class="s2">return </span><span class="s1">mpl.rcParams[</span><span class="s4">'lines.color'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_get_default_facecolor(self):</span>
        <span class="s2">return </span><span class="s4">'none'</span>

    <span class="s2">def </span><span class="s1">set_color(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the edgecolor(s) of the LineCollection. 
 
        Parameters 
        ---------- 
        c : color or list of colors 
            Single color (all lines have same color), or a 
            sequence of RGBA tuples; if it is a sequence the lines will 
            cycle through the sequence. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_edgecolor(c)</span>

    <span class="s1">set_colors = set_color</span>

    <span class="s2">def </span><span class="s1">get_color(self):</span>
        <span class="s2">return </span><span class="s1">self._edgecolors</span>

    <span class="s1">get_colors = get_color  </span><span class="s3"># for compatibility with old versions</span>


<span class="s2">class </span><span class="s1">EventCollection(LineCollection):</span>
    <span class="s0">&quot;&quot;&quot; 
    A collection of locations along a single axis at which an &quot;event&quot; occurred. 
 
    The events are given by a 1-dimensional array. They do not have an 
    amplitude and are displayed as parallel lines. 
    &quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;lineoffset&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">positions</span><span class="s2">,  </span><span class="s3"># Cannot be None.</span>
                 <span class="s1">orientation=</span><span class="s4">'horizontal'</span><span class="s2">,</span>
                 <span class="s1">lineoffset=</span><span class="s5">0</span><span class="s2">,</span>
                 <span class="s1">linelength=</span><span class="s5">1</span><span class="s2">,</span>
                 <span class="s1">linewidth=</span><span class="s2">None,</span>
                 <span class="s1">color=</span><span class="s2">None,</span>
                 <span class="s1">linestyle=</span><span class="s4">'solid'</span><span class="s2">,</span>
                 <span class="s1">antialiased=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        positions : 1D array-like 
            Each value is an event. 
        orientation : {'horizontal', 'vertical'}, default: 'horizontal' 
            The sequence of events is plotted along this direction. 
            The marker lines of the single events are along the orthogonal 
            direction. 
        lineoffset : float, default: 0 
            The offset of the center of the markers from the origin, in the 
            direction orthogonal to *orientation*. 
        linelength : float, default: 1 
            The total height of the marker (i.e. the marker stretches from 
            ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``). 
        linewidth : float or list thereof, default: :rc:`lines.linewidth` 
            The line width of the event lines, in points. 
        color : color or list of colors, default: :rc:`lines.color` 
            The color of the event lines. 
        linestyle : str or tuple or list thereof, default: 'solid' 
            Valid strings are ['solid', 'dashed', 'dashdot', 'dotted', 
            '-', '--', '-.', ':']. Dash tuples should be of the form:: 
 
                (offset, onoffseq), 
 
            where *onoffseq* is an even length tuple of on and off ink 
            in points. 
        antialiased : bool or list thereof, default: :rc:`lines.antialiased` 
            Whether to use antialiasing for drawing the lines. 
        **kwargs 
            Forwarded to `.LineCollection`. 
 
        Examples 
        -------- 
        .. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__([]</span><span class="s2">,</span>
                         <span class="s1">linewidths=linewidth</span><span class="s2">, </span><span class="s1">linestyles=linestyle</span><span class="s2">,</span>
                         <span class="s1">colors=color</span><span class="s2">, </span><span class="s1">antialiaseds=antialiased</span><span class="s2">,</span>
                         <span class="s1">**kwargs)</span>
        <span class="s1">self._is_horizontal = </span><span class="s2">True  </span><span class="s3"># Initial value, may be switched below.</span>
        <span class="s1">self._linelength = linelength</span>
        <span class="s1">self._lineoffset = lineoffset</span>
        <span class="s1">self.set_orientation(orientation)</span>
        <span class="s1">self.set_positions(positions)</span>

    <span class="s2">def </span><span class="s1">get_positions(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an array containing the floating-point values of the positions. 
        &quot;&quot;&quot;</span>
        <span class="s1">pos = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">self.is_horizontal() </span><span class="s2">else </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">[segment[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">pos] </span><span class="s2">for </span><span class="s1">segment </span><span class="s2">in </span><span class="s1">self.get_segments()]</span>

    <span class="s2">def </span><span class="s1">set_positions(self</span><span class="s2">, </span><span class="s1">positions):</span>
        <span class="s0">&quot;&quot;&quot;Set the positions of the events.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">positions </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">positions = []</span>
        <span class="s2">if </span><span class="s1">np.ndim(positions) != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'positions must be one-dimensional'</span><span class="s1">)</span>
        <span class="s1">lineoffset = self.get_lineoffset()</span>
        <span class="s1">linelength = self.get_linelength()</span>
        <span class="s1">pos_idx = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">self.is_horizontal() </span><span class="s2">else </span><span class="s5">1</span>
        <span class="s1">segments = np.empty((len(positions)</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">segments[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">pos_idx] = np.sort(positions)[:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">segments[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- pos_idx] = lineoffset + linelength / </span><span class="s5">2</span>
        <span class="s1">segments[:</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- pos_idx] = lineoffset - linelength / </span><span class="s5">2</span>
        <span class="s1">self.set_segments(segments)</span>

    <span class="s2">def </span><span class="s1">add_positions(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot;Add one or more events at the specified positions.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">position </span><span class="s2">is None or </span><span class="s1">(hasattr(position</span><span class="s2">, </span><span class="s4">'len'</span><span class="s1">) </span><span class="s2">and</span>
                                <span class="s1">len(position) == </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">positions = self.get_positions()</span>
        <span class="s1">positions = np.hstack([positions</span><span class="s2">, </span><span class="s1">np.asanyarray(position)])</span>
        <span class="s1">self.set_positions(positions)</span>
    <span class="s1">extend_positions = append_positions = add_positions</span>

    <span class="s2">def </span><span class="s1">is_horizontal(self):</span>
        <span class="s0">&quot;&quot;&quot;True if the eventcollection is horizontal, False if vertical.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._is_horizontal</span>

    <span class="s2">def </span><span class="s1">get_orientation(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the orientation of the event line ('horizontal' or 'vertical'). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s4">'horizontal' </span><span class="s2">if </span><span class="s1">self.is_horizontal() </span><span class="s2">else </span><span class="s4">'vertical'</span>

    <span class="s2">def </span><span class="s1">switch_orientation(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Switch the orientation of the event line, either from vertical to 
        horizontal or vice versus. 
        &quot;&quot;&quot;</span>
        <span class="s1">segments = self.get_segments()</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">segment </span><span class="s2">in </span><span class="s1">enumerate(segments):</span>
            <span class="s1">segments[i] = np.fliplr(segment)</span>
        <span class="s1">self.set_segments(segments)</span>
        <span class="s1">self._is_horizontal = </span><span class="s2">not </span><span class="s1">self.is_horizontal()</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_orientation(self</span><span class="s2">, </span><span class="s1">orientation):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the orientation of the event line. 
 
        Parameters 
        ---------- 
        orientation : {'horizontal', 'vertical'} 
        &quot;&quot;&quot;</span>
        <span class="s1">is_horizontal = _api.check_getitem(</span>
            <span class="s1">{</span><span class="s4">&quot;horizontal&quot;</span><span class="s1">: </span><span class="s2">True, </span><span class="s4">&quot;vertical&quot;</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s1">orientation=orientation)</span>
        <span class="s2">if </span><span class="s1">is_horizontal == self.is_horizontal():</span>
            <span class="s2">return</span>
        <span class="s1">self.switch_orientation()</span>

    <span class="s2">def </span><span class="s1">get_linelength(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the length of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linelength</span>

    <span class="s2">def </span><span class="s1">set_linelength(self</span><span class="s2">, </span><span class="s1">linelength):</span>
        <span class="s0">&quot;&quot;&quot;Set the length of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">linelength == self.get_linelength():</span>
            <span class="s2">return</span>
        <span class="s1">lineoffset = self.get_lineoffset()</span>
        <span class="s1">segments = self.get_segments()</span>
        <span class="s1">pos = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">self.is_horizontal() </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">segment </span><span class="s2">in </span><span class="s1">segments:</span>
            <span class="s1">segment[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">pos] = lineoffset + linelength / </span><span class="s5">2.</span>
            <span class="s1">segment[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">pos] = lineoffset - linelength / </span><span class="s5">2.</span>
        <span class="s1">self.set_segments(segments)</span>
        <span class="s1">self._linelength = linelength</span>

    <span class="s2">def </span><span class="s1">get_lineoffset(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the offset of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._lineoffset</span>

    <span class="s2">def </span><span class="s1">set_lineoffset(self</span><span class="s2">, </span><span class="s1">lineoffset):</span>
        <span class="s0">&quot;&quot;&quot;Set the offset of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">lineoffset == self.get_lineoffset():</span>
            <span class="s2">return</span>
        <span class="s1">linelength = self.get_linelength()</span>
        <span class="s1">segments = self.get_segments()</span>
        <span class="s1">pos = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">self.is_horizontal() </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">segment </span><span class="s2">in </span><span class="s1">segments:</span>
            <span class="s1">segment[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">pos] = lineoffset + linelength / </span><span class="s5">2.</span>
            <span class="s1">segment[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">pos] = lineoffset - linelength / </span><span class="s5">2.</span>
        <span class="s1">self.set_segments(segments)</span>
        <span class="s1">self._lineoffset = lineoffset</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the width of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super().get_linewidth()[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">get_linewidths(self):</span>
        <span class="s2">return </span><span class="s1">super().get_linewidth()</span>

    <span class="s2">def </span><span class="s1">get_color(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the color of the lines used to mark each event.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_colors()[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s2">class </span><span class="s1">CircleCollection(_CollectionWithSizes):</span>
    <span class="s0">&quot;&quot;&quot;A collection of circles, drawn using splines.&quot;&quot;&quot;</span>

    <span class="s1">_factor = np.pi ** (-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        sizes : float or array-like 
            The area of each circle in points^2. 
        **kwargs 
            Forwarded to `.Collection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.set_sizes(sizes)</span>
        <span class="s1">self.set_transform(transforms.IdentityTransform())</span>
        <span class="s1">self._paths = [mpath.Path.unit_circle()]</span>


<span class="s2">class </span><span class="s1">EllipseCollection(Collection):</span>
    <span class="s0">&quot;&quot;&quot;A collection of ellipses, drawn using splines.&quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;units&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widths</span><span class="s2">, </span><span class="s1">heights</span><span class="s2">, </span><span class="s1">angles</span><span class="s2">, </span><span class="s1">units=</span><span class="s4">'points'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        widths : array-like 
            The lengths of the first axes (e.g., major axis lengths). 
        heights : array-like 
            The lengths of second axes. 
        angles : array-like 
            The angles of the first axes, degrees CCW from the x-axis. 
        units : {'points', 'inches', 'dots', 'width', 'height', 'x', 'y', 'xy'} 
            The units in which majors and minors are given; 'width' and 
            'height' refer to the dimensions of the axes, while 'x' and 'y' 
            refer to the *offsets* data units. 'xy' differs from all others in 
            that the angle as plotted varies with the aspect ratio, and equals 
            the specified angle only when the aspect ratio is unity.  Hence 
            it behaves the same as the `~.patches.Ellipse` with 
            ``axes.transData`` as its transform. 
        **kwargs 
            Forwarded to `Collection`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._widths = </span><span class="s5">0.5 </span><span class="s1">* np.asarray(widths).ravel()</span>
        <span class="s1">self._heights = </span><span class="s5">0.5 </span><span class="s1">* np.asarray(heights).ravel()</span>
        <span class="s1">self._angles = np.deg2rad(angles).ravel()</span>
        <span class="s1">self._units = units</span>
        <span class="s1">self.set_transform(transforms.IdentityTransform())</span>
        <span class="s1">self._transforms = np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">self._paths = [mpath.Path.unit_circle()]</span>

    <span class="s2">def </span><span class="s1">_set_transforms(self):</span>
        <span class="s0">&quot;&quot;&quot;Calculate transforms immediately before drawing.&quot;&quot;&quot;</span>

        <span class="s1">ax = self.axes</span>
        <span class="s1">fig = self.figure</span>

        <span class="s2">if </span><span class="s1">self._units == </span><span class="s4">'xy'</span><span class="s1">:</span>
            <span class="s1">sc = </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'x'</span><span class="s1">:</span>
            <span class="s1">sc = ax.bbox.width / ax.viewLim.width</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'y'</span><span class="s1">:</span>
            <span class="s1">sc = ax.bbox.height / ax.viewLim.height</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'inches'</span><span class="s1">:</span>
            <span class="s1">sc = fig.dpi</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'points'</span><span class="s1">:</span>
            <span class="s1">sc = fig.dpi / </span><span class="s5">72.0</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'width'</span><span class="s1">:</span>
            <span class="s1">sc = ax.bbox.width</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'height'</span><span class="s1">:</span>
            <span class="s1">sc = ax.bbox.height</span>
        <span class="s2">elif </span><span class="s1">self._units == </span><span class="s4">'dots'</span><span class="s1">:</span>
            <span class="s1">sc = </span><span class="s5">1.0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'Unrecognized units: </span><span class="s2">{</span><span class="s1">self._units</span><span class="s2">!r}</span><span class="s4">'</span><span class="s1">)</span>

        <span class="s1">self._transforms = np.zeros((len(self._widths)</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">widths = self._widths * sc</span>
        <span class="s1">heights = self._heights * sc</span>
        <span class="s1">sin_angle = np.sin(self._angles)</span>
        <span class="s1">cos_angle = np.cos(self._angles)</span>
        <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = widths * cos_angle</span>
        <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = heights * -sin_angle</span>
        <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = widths * sin_angle</span>
        <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = heights * cos_angle</span>
        <span class="s1">self._transforms[:</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = </span><span class="s5">1.0</span>

        <span class="s1">_affine = transforms.Affine2D</span>
        <span class="s2">if </span><span class="s1">self._units == </span><span class="s4">'xy'</span><span class="s1">:</span>
            <span class="s1">m = ax.transData.get_affine().get_matrix().copy()</span>
            <span class="s1">m[:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">:] = </span><span class="s5">0</span>
            <span class="s1">self.set_transform(_affine(m))</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self._set_transforms()</span>
        <span class="s1">super().draw(renderer)</span>


<span class="s2">class </span><span class="s1">PatchCollection(Collection):</span>
    <span class="s0">&quot;&quot;&quot; 
    A generic collection of patches. 
 
    PatchCollection draws faster than a large number of equivalent individual 
    Patches. It also makes it easier to assign a colormap to a heterogeneous 
    collection of patches. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;match_original&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">patches</span><span class="s2">, </span><span class="s1">match_original=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        patches : list of `.Patch` 
            A sequence of Patch objects.  This list may include 
            a heterogeneous assortment of different patch types. 
 
        match_original : bool, default: False 
            If True, use the colors and linewidths of the original 
            patches.  If False, new colors may be assigned by 
            providing the standard collection arguments, facecolor, 
            edgecolor, linewidths, norm or cmap. 
 
        **kwargs 
            All other parameters are forwarded to `.Collection`. 
 
            If any of *edgecolors*, *facecolors*, *linewidths*, *antialiaseds* 
            are None, they default to their `.rcParams` patch setting, in 
            sequence form. 
 
        Notes 
        ----- 
        The use of `~matplotlib.cm.ScalarMappable` functionality is optional. 
        If the `~matplotlib.cm.ScalarMappable` matrix ``_A`` has been set (via 
        a call to `~.ScalarMappable.set_array`), at draw time a call to scalar 
        mappable will be made to set the face colors. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">match_original:</span>
            <span class="s2">def </span><span class="s1">determine_facecolor(patch):</span>
                <span class="s2">if </span><span class="s1">patch.get_fill():</span>
                    <span class="s2">return </span><span class="s1">patch.get_facecolor()</span>
                <span class="s2">return </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">kwargs[</span><span class="s4">'facecolors'</span><span class="s1">] = [determine_facecolor(p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>
            <span class="s1">kwargs[</span><span class="s4">'edgecolors'</span><span class="s1">] = [p.get_edgecolor() </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>
            <span class="s1">kwargs[</span><span class="s4">'linewidths'</span><span class="s1">] = [p.get_linewidth() </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>
            <span class="s1">kwargs[</span><span class="s4">'linestyles'</span><span class="s1">] = [p.get_linestyle() </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>
            <span class="s1">kwargs[</span><span class="s4">'antialiaseds'</span><span class="s1">] = [p.get_antialiased() </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>

        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s1">self.set_paths(patches)</span>

    <span class="s2">def </span><span class="s1">set_paths(self</span><span class="s2">, </span><span class="s1">patches):</span>
        <span class="s1">paths = [p.get_transform().transform_path(p.get_path())</span>
                 <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patches]</span>
        <span class="s1">self._paths = paths</span>


<span class="s2">class </span><span class="s1">TriMesh(Collection):</span>
    <span class="s0">&quot;&quot;&quot; 
    Class for the efficient drawing of a triangular mesh using Gouraud shading. 
 
    A triangular mesh is a `~matplotlib.tri.Triangulation` object. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">triangulation</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._triangulation = triangulation</span>
        <span class="s1">self._shading = </span><span class="s4">'gouraud'</span>

        <span class="s1">self._bbox = transforms.Bbox.unit()</span>

        <span class="s3"># Unfortunately this requires a copy, unless Triangulation</span>
        <span class="s3"># was rewritten.</span>
        <span class="s1">xy = np.hstack((triangulation.x.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">triangulation.y.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">self._bbox.update_from_data_xy(xy)</span>

    <span class="s2">def </span><span class="s1">get_paths(self):</span>
        <span class="s2">if </span><span class="s1">self._paths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.set_paths()</span>
        <span class="s2">return </span><span class="s1">self._paths</span>

    <span class="s2">def </span><span class="s1">set_paths(self):</span>
        <span class="s1">self._paths = self.convert_mesh_to_paths(self._triangulation)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">convert_mesh_to_paths(tri):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert a given mesh into a sequence of `.Path` objects. 
 
        This function is primarily of use to implementers of backends that do 
        not directly support meshes. 
        &quot;&quot;&quot;</span>
        <span class="s1">triangles = tri.get_masked_triangles()</span>
        <span class="s1">verts = np.stack((tri.x[triangles]</span><span class="s2">, </span><span class="s1">tri.y[triangles])</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[mpath.Path(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">verts]</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(self.__class__.__name__</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>
        <span class="s1">transform = self.get_transform()</span>

        <span class="s3"># Get a list of triangles and the color at each vertex.</span>
        <span class="s1">tri = self._triangulation</span>
        <span class="s1">triangles = tri.get_masked_triangles()</span>

        <span class="s1">verts = np.stack((tri.x[triangles]</span><span class="s2">, </span><span class="s1">tri.y[triangles])</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">self.update_scalarmappable()</span>
        <span class="s1">colors = self._facecolors[triangles]</span>

        <span class="s1">gc = renderer.new_gc()</span>
        <span class="s1">self._set_gc_clip(gc)</span>
        <span class="s1">gc.set_linewidth(self.get_linewidth()[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">renderer.draw_gouraud_triangles(gc</span><span class="s2">, </span><span class="s1">verts</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">transform.frozen())</span>
        <span class="s1">gc.restore()</span>
        <span class="s1">renderer.close_group(self.__class__.__name__)</span>


<span class="s2">class </span><span class="s1">QuadMesh(Collection):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Class for the efficient drawing of a quadrilateral mesh. 
 
    A quadrilateral mesh is a grid of M by N adjacent quadrilaterals that are 
    defined via a (M+1, N+1) grid of vertices. The quadrilateral (m, n) is 
    defined by the vertices :: 
 
               (m+1, n) ----------- (m+1, n+1) 
                  /                   / 
                 /                 / 
                /               / 
            (m, n) -------- (m, n+1) 
 
    The mesh need not be regular and the polygons need not be convex. 
 
    Parameters 
    ---------- 
    coordinates : (M+1, N+1, 2) array-like 
        The vertices. ``coordinates[m, n]`` specifies the (x, y) coordinates 
        of vertex (m, n). 
 
    antialiased : bool, default: True 
 
    shading : {'flat', 'gouraud'}, default: 'flat' 
 
    Notes 
    ----- 
    Unlike other `.Collection`\s, the default *pickradius* of `.QuadMesh` is 0, 
    i.e. `~.Artist.contains` checks whether the test point is within any of the 
    mesh quadrilaterals. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">coordinates</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">antialiased=</span><span class="s2">True, </span><span class="s1">shading=</span><span class="s4">'flat'</span><span class="s2">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;pickradius&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># end of signature deprecation code</span>

        <span class="s1">_api.check_shape((</span><span class="s2">None, None, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">coordinates=coordinates)</span>
        <span class="s1">self._coordinates = coordinates</span>
        <span class="s1">self._antialiased = antialiased</span>
        <span class="s1">self._shading = shading</span>
        <span class="s1">self._bbox = transforms.Bbox.unit()</span>
        <span class="s1">self._bbox.update_from_data_xy(self._coordinates.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s3"># super init delayed after own init because array kwarg requires</span>
        <span class="s3"># self._coordinates and self._shading</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.set_mouseover(</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_paths(self):</span>
        <span class="s2">if </span><span class="s1">self._paths </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.set_paths()</span>
        <span class="s2">return </span><span class="s1">self._paths</span>

    <span class="s2">def </span><span class="s1">set_paths(self):</span>
        <span class="s1">self._paths = self._convert_mesh_to_paths(self._coordinates)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_array(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the data values. 
 
        Parameters 
        ---------- 
        A : array-like 
            The mesh data. Supported array shapes are: 
 
            - (M, N) or (M*N,): a mesh with scalar data. The values are mapped 
              to colors using normalization and a colormap. See parameters 
              *norm*, *cmap*, *vmin*, *vmax*. 
            - (M, N, 3): an image with RGB values (0-1 float or 0-255 int). 
            - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int), 
              i.e. including transparency. 
 
            If the values are provided as a 2D grid, the shape must match the 
            coordinates grid. If the values are 1D, they are reshaped to 2D. 
            M, N follow from the coordinates grid, where the coordinates grid 
            shape is (M, N) for 'gouraud' *shading* and (M+1, N+1) for 'flat' 
            shading. 
        &quot;&quot;&quot;</span>
        <span class="s1">height</span><span class="s2">, </span><span class="s1">width = self._coordinates.shape[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._shading == </span><span class="s4">'flat'</span><span class="s1">:</span>
            <span class="s1">h</span><span class="s2">, </span><span class="s1">w = height - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">width - </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">h</span><span class="s2">, </span><span class="s1">w = height</span><span class="s2">, </span><span class="s1">width</span>
        <span class="s1">ok_shapes = [(h</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(h</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(h</span><span class="s2">, </span><span class="s1">w)</span><span class="s2">, </span><span class="s1">(h * w</span><span class="s2">,</span><span class="s1">)]</span>
        <span class="s2">if </span><span class="s1">A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">shape = np.shape(A)</span>
            <span class="s2">if </span><span class="s1">shape </span><span class="s2">not in </span><span class="s1">ok_shapes:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;For X (</span><span class="s2">{</span><span class="s1">width</span><span class="s2">}</span><span class="s4">) and Y (</span><span class="s2">{</span><span class="s1">height</span><span class="s2">}</span><span class="s4">) with </span><span class="s2">{</span><span class="s1">self._shading</span><span class="s2">} </span><span class="s4">&quot;</span>
                    <span class="s4">f&quot;shading, A should have shape &quot;</span>
                    <span class="s4">f&quot;</span><span class="s2">{</span><span class="s4">' or '</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">ok_shapes))</span><span class="s2">}</span><span class="s4">, not </span><span class="s2">{</span><span class="s1">A.shape</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super().set_array(A)</span>

    <span class="s2">def </span><span class="s1">get_datalim(self</span><span class="s2">, </span><span class="s1">transData):</span>
        <span class="s2">return </span><span class="s1">(self.get_transform() - transData).transform_bbox(self._bbox)</span>

    <span class="s2">def </span><span class="s1">get_coordinates(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the vertices of the mesh as an (M+1, N+1, 2) array. 
 
        M, N are the number of quadrilaterals in the rows / columns of the 
        mesh, corresponding to (M+1, N+1) vertices. 
        The last dimension specifies the components (x, y). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._coordinates</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_convert_mesh_to_paths(coordinates):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert a given mesh into a sequence of `.Path` objects. 
 
        This function is primarily of use to implementers of backends that do 
        not directly support quadmeshes. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(coordinates</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">c = coordinates.data</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">c = coordinates</span>
        <span class="s1">points = np.concatenate([</span>
            <span class="s1">c[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">c[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">c[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">c[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">c[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">).reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">[mpath.Path(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">points]</span>

    <span class="s2">def </span><span class="s1">_convert_mesh_to_triangles(self</span><span class="s2">, </span><span class="s1">coordinates):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert a given mesh into a sequence of triangles, each point 
        with its own color.  The result can be used to construct a call to 
        `~.RendererBase.draw_gouraud_triangles`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(coordinates</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">p = coordinates.data</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">p = coordinates</span>

        <span class="s1">p_a = p[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">p_b = p[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">p_c = p[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">p_d = p[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">p_center = (p_a + p_b + p_c + p_d) / </span><span class="s5">4.0</span>
        <span class="s1">triangles = np.concatenate([</span>
            <span class="s1">p_a</span><span class="s2">, </span><span class="s1">p_b</span><span class="s2">, </span><span class="s1">p_center</span><span class="s2">,</span>
            <span class="s1">p_b</span><span class="s2">, </span><span class="s1">p_c</span><span class="s2">, </span><span class="s1">p_center</span><span class="s2">,</span>
            <span class="s1">p_c</span><span class="s2">, </span><span class="s1">p_d</span><span class="s2">, </span><span class="s1">p_center</span><span class="s2">,</span>
            <span class="s1">p_d</span><span class="s2">, </span><span class="s1">p_a</span><span class="s2">, </span><span class="s1">p_center</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">).reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>

        <span class="s1">c = self.get_facecolor().reshape((*coordinates.shape[:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">c_a = c[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">c_b = c[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">c_c = c[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">c_d = c[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">c_center = (c_a + c_b + c_c + c_d) / </span><span class="s5">4.0</span>
        <span class="s1">colors = np.concatenate([</span>
            <span class="s1">c_a</span><span class="s2">, </span><span class="s1">c_b</span><span class="s2">, </span><span class="s1">c_center</span><span class="s2">,</span>
            <span class="s1">c_b</span><span class="s2">, </span><span class="s1">c_c</span><span class="s2">, </span><span class="s1">c_center</span><span class="s2">,</span>
            <span class="s1">c_c</span><span class="s2">, </span><span class="s1">c_d</span><span class="s2">, </span><span class="s1">c_center</span><span class="s2">,</span>
            <span class="s1">c_d</span><span class="s2">, </span><span class="s1">c_a</span><span class="s2">, </span><span class="s1">c_center</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">).reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span>

        <span class="s2">return </span><span class="s1">triangles</span><span class="s2">, </span><span class="s1">colors</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.get_gid())</span>
        <span class="s1">transform = self.get_transform()</span>
        <span class="s1">offset_trf = self.get_offset_transform()</span>
        <span class="s1">offsets = self.get_offsets()</span>

        <span class="s2">if </span><span class="s1">self.have_units():</span>
            <span class="s1">xs = self.convert_xunits(offsets[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">ys = self.convert_yunits(offsets[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">offsets = np.column_stack([xs</span><span class="s2">, </span><span class="s1">ys])</span>

        <span class="s1">self.update_scalarmappable()</span>

        <span class="s2">if not </span><span class="s1">transform.is_affine:</span>
            <span class="s1">coordinates = self._coordinates.reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">coordinates = transform.transform(coordinates)</span>
            <span class="s1">coordinates = coordinates.reshape(self._coordinates.shape)</span>
            <span class="s1">transform = transforms.IdentityTransform()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">coordinates = self._coordinates</span>

        <span class="s2">if not </span><span class="s1">offset_trf.is_affine:</span>
            <span class="s1">offsets = offset_trf.transform_non_affine(offsets)</span>
            <span class="s1">offset_trf = offset_trf.get_affine()</span>

        <span class="s1">gc = renderer.new_gc()</span>
        <span class="s1">gc.set_snap(self.get_snap())</span>
        <span class="s1">self._set_gc_clip(gc)</span>
        <span class="s1">gc.set_linewidth(self.get_linewidth()[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2">if </span><span class="s1">self._shading == </span><span class="s4">'gouraud'</span><span class="s1">:</span>
            <span class="s1">triangles</span><span class="s2">, </span><span class="s1">colors = self._convert_mesh_to_triangles(coordinates)</span>
            <span class="s1">renderer.draw_gouraud_triangles(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">triangles</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">transform.frozen())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">renderer.draw_quad_mesh(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">transform.frozen()</span><span class="s2">,</span>
                <span class="s1">coordinates.shape[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">coordinates.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">coordinates</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trf</span><span class="s2">,</span>
                <span class="s3"># Backends expect flattened rgba arrays (n*m, 4) for fc and ec</span>
                <span class="s1">self.get_facecolor().reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">self._antialiased</span><span class="s2">, </span><span class="s1">self.get_edgecolors().reshape((-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)))</span>
        <span class="s1">gc.restore()</span>
        <span class="s1">renderer.close_group(self.__class__.__name__)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_cursor_data(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s1">contained</span><span class="s2">, </span><span class="s1">info = self.contains(event)</span>
        <span class="s2">if </span><span class="s1">contained </span><span class="s2">and </span><span class="s1">self.get_array() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.get_array().ravel()[info[</span><span class="s4">&quot;ind&quot;</span><span class="s1">]]</span>
        <span class="s2">return None</span>
</pre>
</body>
</html>