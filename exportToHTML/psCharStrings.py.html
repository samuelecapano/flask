<html>
<head>
<title>psCharStrings.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
psCharStrings.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;psCharStrings.py -- module implementing various kinds of CharStrings: 
CFF dictionary data and Type1/Type2 CharStrings. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">fontTools.misc.fixedTools </span><span class="s2">import </span><span class="s1">(</span>
	<span class="s1">fixedToFloat</span><span class="s2">, </span><span class="s1">floatToFixed</span><span class="s2">, </span><span class="s1">floatToFixedToStr</span><span class="s2">, </span><span class="s1">strToFixedToFloat</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">fontTools.misc.textTools </span><span class="s2">import </span><span class="s1">bytechr</span><span class="s2">, </span><span class="s1">byteord</span><span class="s2">, </span><span class="s1">bytesjoin</span><span class="s2">, </span><span class="s1">strjoin</span>
<span class="s2">from </span><span class="s1">fontTools.pens.boundsPen </span><span class="s2">import </span><span class="s1">BoundsPen</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">logging</span>


<span class="s1">log = logging.getLogger(__name__)</span>


<span class="s2">def </span><span class="s1">read_operator(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s2">if </span><span class="s1">b0 == </span><span class="s3">12</span><span class="s1">:</span>
		<span class="s1">op = (b0</span><span class="s2">, </span><span class="s1">byteord(data[index]))</span>
		<span class="s1">index = index+</span><span class="s3">1</span>
	<span class="s2">else</span><span class="s1">:</span>
		<span class="s1">op = b0</span>
	<span class="s2">try</span><span class="s1">:</span>
		<span class="s1">operator = self.operators[op]</span>
	<span class="s2">except </span><span class="s1">KeyError:</span>
		<span class="s2">return None, </span><span class="s1">index</span>
	<span class="s1">value = self.handle_operator(operator)</span>
	<span class="s2">return </span><span class="s1">value</span><span class="s2">, </span><span class="s1">index</span>

<span class="s2">def </span><span class="s1">read_byte(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s2">return </span><span class="s1">b0 - </span><span class="s3">139</span><span class="s2">, </span><span class="s1">index</span>

<span class="s2">def </span><span class="s1">read_smallInt1(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">b1 = byteord(data[index])</span>
	<span class="s2">return </span><span class="s1">(b0-</span><span class="s3">247</span><span class="s1">)*</span><span class="s3">256 </span><span class="s1">+ b1 + </span><span class="s3">108</span><span class="s2">, </span><span class="s1">index+</span><span class="s3">1</span>

<span class="s2">def </span><span class="s1">read_smallInt2(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">b1 = byteord(data[index])</span>
	<span class="s2">return </span><span class="s1">-(b0-</span><span class="s3">251</span><span class="s1">)*</span><span class="s3">256 </span><span class="s1">- b1 - </span><span class="s3">108</span><span class="s2">, </span><span class="s1">index+</span><span class="s3">1</span>

<span class="s2">def </span><span class="s1">read_shortInt(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">value</span><span class="s2">, </span><span class="s1">= struct.unpack(</span><span class="s4">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">data[index:index+</span><span class="s3">2</span><span class="s1">])</span>
	<span class="s2">return </span><span class="s1">value</span><span class="s2">, </span><span class="s1">index+</span><span class="s3">2</span>

<span class="s2">def </span><span class="s1">read_longInt(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">value</span><span class="s2">, </span><span class="s1">= struct.unpack(</span><span class="s4">&quot;&gt;l&quot;</span><span class="s2">, </span><span class="s1">data[index:index+</span><span class="s3">4</span><span class="s1">])</span>
	<span class="s2">return </span><span class="s1">value</span><span class="s2">, </span><span class="s1">index+</span><span class="s3">4</span>

<span class="s2">def </span><span class="s1">read_fixed1616(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">value</span><span class="s2">, </span><span class="s1">= struct.unpack(</span><span class="s4">&quot;&gt;l&quot;</span><span class="s2">, </span><span class="s1">data[index:index+</span><span class="s3">4</span><span class="s1">])</span>
	<span class="s2">return </span><span class="s1">fixedToFloat(value</span><span class="s2">, </span><span class="s1">precisionBits=</span><span class="s3">16</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index+</span><span class="s3">4</span>

<span class="s2">def </span><span class="s1">read_reserved(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s2">assert </span><span class="s1">NotImplementedError</span>
	<span class="s2">return </span><span class="s1">NotImplemented</span><span class="s2">, </span><span class="s1">index</span>

<span class="s2">def </span><span class="s1">read_realNumber(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index):</span>
	<span class="s1">number = </span><span class="s4">''</span>
	<span class="s2">while True</span><span class="s1">:</span>
		<span class="s1">b = byteord(data[index])</span>
		<span class="s1">index = index + </span><span class="s3">1</span>
		<span class="s1">nibble0 = (b &amp; </span><span class="s3">0xf0</span><span class="s1">) &gt;&gt; </span><span class="s3">4</span>
		<span class="s1">nibble1 = b &amp; </span><span class="s3">0x0f</span>
		<span class="s2">if </span><span class="s1">nibble0 == </span><span class="s3">0xf</span><span class="s1">:</span>
			<span class="s2">break</span>
		<span class="s1">number = number + realNibbles[nibble0]</span>
		<span class="s2">if </span><span class="s1">nibble1 == </span><span class="s3">0xf</span><span class="s1">:</span>
			<span class="s2">break</span>
		<span class="s1">number = number + realNibbles[nibble1]</span>
	<span class="s2">return </span><span class="s1">float(number)</span><span class="s2">, </span><span class="s1">index</span>


<span class="s1">t1OperandEncoding = [</span><span class="s2">None</span><span class="s1">] * </span><span class="s3">256</span>
<span class="s1">t1OperandEncoding[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">32</span><span class="s1">] = (</span><span class="s3">32</span><span class="s1">) * [read_operator]</span>
<span class="s1">t1OperandEncoding[</span><span class="s3">32</span><span class="s1">:</span><span class="s3">247</span><span class="s1">] = (</span><span class="s3">247 </span><span class="s1">- </span><span class="s3">32</span><span class="s1">) * [read_byte]</span>
<span class="s1">t1OperandEncoding[</span><span class="s3">247</span><span class="s1">:</span><span class="s3">251</span><span class="s1">] = (</span><span class="s3">251 </span><span class="s1">- </span><span class="s3">247</span><span class="s1">) * [read_smallInt1]</span>
<span class="s1">t1OperandEncoding[</span><span class="s3">251</span><span class="s1">:</span><span class="s3">255</span><span class="s1">] = (</span><span class="s3">255 </span><span class="s1">- </span><span class="s3">251</span><span class="s1">) * [read_smallInt2]</span>
<span class="s1">t1OperandEncoding[</span><span class="s3">255</span><span class="s1">] = read_longInt</span>
<span class="s2">assert </span><span class="s1">len(t1OperandEncoding) == </span><span class="s3">256</span>

<span class="s1">t2OperandEncoding = t1OperandEncoding[:]</span>
<span class="s1">t2OperandEncoding[</span><span class="s3">28</span><span class="s1">] = read_shortInt</span>
<span class="s1">t2OperandEncoding[</span><span class="s3">255</span><span class="s1">] = read_fixed1616</span>

<span class="s1">cffDictOperandEncoding = t2OperandEncoding[:]</span>
<span class="s1">cffDictOperandEncoding[</span><span class="s3">29</span><span class="s1">] = read_longInt</span>
<span class="s1">cffDictOperandEncoding[</span><span class="s3">30</span><span class="s1">] = read_realNumber</span>
<span class="s1">cffDictOperandEncoding[</span><span class="s3">255</span><span class="s1">] = read_reserved</span>


<span class="s1">realNibbles = [</span><span class="s4">'0'</span><span class="s2">, </span><span class="s4">'1'</span><span class="s2">, </span><span class="s4">'2'</span><span class="s2">, </span><span class="s4">'3'</span><span class="s2">, </span><span class="s4">'4'</span><span class="s2">, </span><span class="s4">'5'</span><span class="s2">, </span><span class="s4">'6'</span><span class="s2">, </span><span class="s4">'7'</span><span class="s2">, </span><span class="s4">'8'</span><span class="s2">, </span><span class="s4">'9'</span><span class="s2">,</span>
		<span class="s4">'.'</span><span class="s2">, </span><span class="s4">'E'</span><span class="s2">, </span><span class="s4">'E-'</span><span class="s2">, None, </span><span class="s4">'-'</span><span class="s1">]</span>
<span class="s1">realNibblesDict = {v:i </span><span class="s2">for </span><span class="s1">i</span><span class="s2">,</span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(realNibbles)}</span>

<span class="s1">maxOpStack = </span><span class="s3">193</span>


<span class="s2">def </span><span class="s1">buildOperatorDict(operatorList):</span>
	<span class="s1">oper = {}</span>
	<span class="s1">opc = {}</span>
	<span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">operatorList:</span>
		<span class="s2">if </span><span class="s1">len(item) == </span><span class="s3">2</span><span class="s1">:</span>
			<span class="s1">oper[item[</span><span class="s3">0</span><span class="s1">]] = item[</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">oper[item[</span><span class="s3">0</span><span class="s1">]] = item[</span><span class="s3">1</span><span class="s1">:]</span>
		<span class="s2">if </span><span class="s1">isinstance(item[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
			<span class="s1">opc[item[</span><span class="s3">1</span><span class="s1">]] = item[</span><span class="s3">0</span><span class="s1">]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">opc[item[</span><span class="s3">1</span><span class="s1">]] = (item[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span>
	<span class="s2">return </span><span class="s1">oper</span><span class="s2">, </span><span class="s1">opc</span>


<span class="s1">t2Operators = [</span>
<span class="s5">#   opcode      name</span>
	<span class="s1">(</span><span class="s3">1</span><span class="s2">,		</span><span class="s4">'hstem'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">3</span><span class="s2">,		</span><span class="s4">'vstem'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">4</span><span class="s2">,		</span><span class="s4">'vmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">5</span><span class="s2">,		</span><span class="s4">'rlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">6</span><span class="s2">,		</span><span class="s4">'hlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">7</span><span class="s2">,		</span><span class="s4">'vlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">8</span><span class="s2">,		</span><span class="s4">'rrcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">10</span><span class="s2">,		</span><span class="s4">'callsubr'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">11</span><span class="s2">,		</span><span class="s4">'return'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">14</span><span class="s2">,		</span><span class="s4">'endchar'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">15</span><span class="s2">,		</span><span class="s4">'vsindex'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">16</span><span class="s2">,		</span><span class="s4">'blend'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">18</span><span class="s2">,		</span><span class="s4">'hstemhm'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">19</span><span class="s2">,		</span><span class="s4">'hintmask'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">20</span><span class="s2">,		</span><span class="s4">'cntrmask'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">21</span><span class="s2">,		</span><span class="s4">'rmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">22</span><span class="s2">,		</span><span class="s4">'hmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">23</span><span class="s2">,		</span><span class="s4">'vstemhm'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">24</span><span class="s2">,		</span><span class="s4">'rcurveline'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">25</span><span class="s2">,		</span><span class="s4">'rlinecurve'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">26</span><span class="s2">,		</span><span class="s4">'vvcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">27</span><span class="s2">,		</span><span class="s4">'hhcurveto'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s5">#   (28,        'shortint'),  # not really an operator</span>
	<span class="s1">(</span><span class="s3">29</span><span class="s2">,		</span><span class="s4">'callgsubr'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">30</span><span class="s2">,		</span><span class="s4">'vhcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">31</span><span class="s2">,		</span><span class="s4">'hvcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'ignore'</span><span class="s1">)</span><span class="s2">,	</span><span class="s5"># dotsection. Yes, there a few very early OTF/CFF</span>
							<span class="s5"># fonts with this deprecated operator. Just ignore it.</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'and'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'or'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">5</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'not'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">8</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'store'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">9</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'abs'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'add'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">11</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'sub'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">12</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'div'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">13</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'load'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">14</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'neg'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">15</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'eq'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">18</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'drop'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">20</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'put'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">21</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'get'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">22</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'ifelse'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">23</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'random'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">24</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'mul'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">26</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'sqrt'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">27</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'dup'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">28</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'exch'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">29</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'index'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">30</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'roll'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">34</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'hflex'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">35</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'flex'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">36</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'hflex1'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">37</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'flex1'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s2">def </span><span class="s1">getIntEncoder(format):</span>
	<span class="s2">if </span><span class="s1">format == </span><span class="s4">&quot;cff&quot;</span><span class="s1">:</span>
		<span class="s1">fourByteOp = bytechr(</span><span class="s3">29</span><span class="s1">)</span>
	<span class="s2">elif </span><span class="s1">format == </span><span class="s4">&quot;t1&quot;</span><span class="s1">:</span>
		<span class="s1">fourByteOp = bytechr(</span><span class="s3">255</span><span class="s1">)</span>
	<span class="s2">else</span><span class="s1">:</span>
		<span class="s2">assert </span><span class="s1">format == </span><span class="s4">&quot;t2&quot;</span>
		<span class="s1">fourByteOp = </span><span class="s2">None</span>

	<span class="s2">def </span><span class="s1">encodeInt(value</span><span class="s2">, </span><span class="s1">fourByteOp=fourByteOp</span><span class="s2">, </span><span class="s1">bytechr=bytechr</span><span class="s2">,</span>
			<span class="s1">pack=struct.pack</span><span class="s2">, </span><span class="s1">unpack=struct.unpack):</span>
		<span class="s2">if </span><span class="s1">-</span><span class="s3">107 </span><span class="s1">&lt;= value &lt;= </span><span class="s3">107</span><span class="s1">:</span>
			<span class="s1">code = bytechr(value + </span><span class="s3">139</span><span class="s1">)</span>
		<span class="s2">elif </span><span class="s3">108 </span><span class="s1">&lt;= value &lt;= </span><span class="s3">1131</span><span class="s1">:</span>
			<span class="s1">value = value - </span><span class="s3">108</span>
			<span class="s1">code = bytechr((value &gt;&gt; </span><span class="s3">8</span><span class="s1">) + </span><span class="s3">247</span><span class="s1">) + bytechr(value &amp; </span><span class="s3">0xFF</span><span class="s1">)</span>
		<span class="s2">elif </span><span class="s1">-</span><span class="s3">1131 </span><span class="s1">&lt;= value &lt;= -</span><span class="s3">108</span><span class="s1">:</span>
			<span class="s1">value = -value - </span><span class="s3">108</span>
			<span class="s1">code = bytechr((value &gt;&gt; </span><span class="s3">8</span><span class="s1">) + </span><span class="s3">251</span><span class="s1">) + bytechr(value &amp; </span><span class="s3">0xFF</span><span class="s1">)</span>
		<span class="s2">elif </span><span class="s1">fourByteOp </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s5"># T2 only supports 2 byte ints</span>
			<span class="s2">if </span><span class="s1">-</span><span class="s3">32768 </span><span class="s1">&lt;= value &lt;= </span><span class="s3">32767</span><span class="s1">:</span>
				<span class="s1">code = bytechr(</span><span class="s3">28</span><span class="s1">) + pack(</span><span class="s4">&quot;&gt;h&quot;</span><span class="s2">, </span><span class="s1">value)</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s5"># Backwards compatible hack: due to a previous bug in FontTools,</span>
				<span class="s5"># 16.16 fixed numbers were written out as 4-byte ints. When</span>
				<span class="s5"># these numbers were small, they were wrongly written back as</span>
				<span class="s5"># small ints instead of 4-byte ints, breaking round-tripping.</span>
				<span class="s5"># This here workaround doesn't do it any better, since we can't</span>
				<span class="s5"># distinguish anymore between small ints that were supposed to</span>
				<span class="s5"># be small fixed numbers and small ints that were just small</span>
				<span class="s5"># ints. Hence the warning.</span>
				<span class="s1">log.warning(</span><span class="s4">&quot;4-byte T2 number got passed to the &quot;</span>
					<span class="s4">&quot;IntType handler. This should happen only when reading in &quot;</span>
					<span class="s4">&quot;old XML files.</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
				<span class="s1">code = bytechr(</span><span class="s3">255</span><span class="s1">) + pack(</span><span class="s4">&quot;&gt;l&quot;</span><span class="s2">, </span><span class="s1">value)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">code = fourByteOp + pack(</span><span class="s4">&quot;&gt;l&quot;</span><span class="s2">, </span><span class="s1">value)</span>
		<span class="s2">return </span><span class="s1">code</span>

	<span class="s2">return </span><span class="s1">encodeInt</span>


<span class="s1">encodeIntCFF = getIntEncoder(</span><span class="s4">&quot;cff&quot;</span><span class="s1">)</span>
<span class="s1">encodeIntT1 = getIntEncoder(</span><span class="s4">&quot;t1&quot;</span><span class="s1">)</span>
<span class="s1">encodeIntT2 = getIntEncoder(</span><span class="s4">&quot;t2&quot;</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">encodeFixed(f</span><span class="s2">, </span><span class="s1">pack=struct.pack):</span>
	<span class="s0">&quot;&quot;&quot;For T2 only&quot;&quot;&quot;</span>
	<span class="s1">value = floatToFixed(f</span><span class="s2">, </span><span class="s1">precisionBits=</span><span class="s3">16</span><span class="s1">)</span>
	<span class="s2">if </span><span class="s1">value &amp; </span><span class="s3">0xFFFF </span><span class="s1">== </span><span class="s3">0</span><span class="s1">:  </span><span class="s5"># check if the fractional part is zero</span>
		<span class="s2">return </span><span class="s1">encodeIntT2(value &gt;&gt; </span><span class="s3">16</span><span class="s1">)  </span><span class="s5"># encode only the integer part</span>
	<span class="s2">else</span><span class="s1">:</span>
		<span class="s2">return </span><span class="s6">b&quot;</span><span class="s2">\xff</span><span class="s6">&quot; </span><span class="s1">+ pack(</span><span class="s4">&quot;&gt;l&quot;</span><span class="s2">, </span><span class="s1">value)  </span><span class="s5"># encode the entire fixed point value</span>


<span class="s1">realZeroBytes = bytechr(</span><span class="s3">30</span><span class="s1">) + bytechr(</span><span class="s3">0xf</span><span class="s1">)</span>

<span class="s2">def </span><span class="s1">encodeFloat(f):</span>
	<span class="s5"># For CFF only, used in cffLib</span>
	<span class="s2">if </span><span class="s1">f == </span><span class="s3">0.0</span><span class="s1">: </span><span class="s5"># 0.0 == +0.0 == -0.0</span>
		<span class="s2">return </span><span class="s1">realZeroBytes</span>
	<span class="s5"># Note: 14 decimal digits seems to be the limitation for CFF real numbers</span>
	<span class="s5"># in macOS. However, we use 8 here to match the implementation of AFDKO.</span>
	<span class="s1">s = </span><span class="s4">&quot;%.8G&quot; </span><span class="s1">% f</span>
	<span class="s2">if </span><span class="s1">s[:</span><span class="s3">2</span><span class="s1">] == </span><span class="s4">&quot;0.&quot;</span><span class="s1">:</span>
		<span class="s1">s = s[</span><span class="s3">1</span><span class="s1">:]</span>
	<span class="s2">elif </span><span class="s1">s[:</span><span class="s3">3</span><span class="s1">] == </span><span class="s4">&quot;-0.&quot;</span><span class="s1">:</span>
		<span class="s1">s = </span><span class="s4">&quot;-&quot; </span><span class="s1">+ s[</span><span class="s3">2</span><span class="s1">:]</span>
	<span class="s1">nibbles = []</span>
	<span class="s2">while </span><span class="s1">s:</span>
		<span class="s1">c = s[</span><span class="s3">0</span><span class="s1">]</span>
		<span class="s1">s = s[</span><span class="s3">1</span><span class="s1">:]</span>
		<span class="s2">if </span><span class="s1">c == </span><span class="s4">&quot;E&quot;</span><span class="s1">:</span>
			<span class="s1">c2 = s[:</span><span class="s3">1</span><span class="s1">]</span>
			<span class="s2">if </span><span class="s1">c2 == </span><span class="s4">&quot;-&quot;</span><span class="s1">:</span>
				<span class="s1">s = s[</span><span class="s3">1</span><span class="s1">:]</span>
				<span class="s1">c = </span><span class="s4">&quot;E-&quot;</span>
			<span class="s2">elif </span><span class="s1">c2 == </span><span class="s4">&quot;+&quot;</span><span class="s1">:</span>
				<span class="s1">s = s[</span><span class="s3">1</span><span class="s1">:]</span>
		<span class="s1">nibbles.append(realNibblesDict[c])</span>
	<span class="s1">nibbles.append(</span><span class="s3">0xf</span><span class="s1">)</span>
	<span class="s2">if </span><span class="s1">len(nibbles) % </span><span class="s3">2</span><span class="s1">:</span>
		<span class="s1">nibbles.append(</span><span class="s3">0xf</span><span class="s1">)</span>
	<span class="s1">d = bytechr(</span><span class="s3">30</span><span class="s1">)</span>
	<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(nibbles)</span><span class="s2">, </span><span class="s3">2</span><span class="s1">):</span>
		<span class="s1">d = d + bytechr(nibbles[i] &lt;&lt; </span><span class="s3">4 </span><span class="s1">| nibbles[i+</span><span class="s3">1</span><span class="s1">])</span>
	<span class="s2">return </span><span class="s1">d</span>


<span class="s2">class </span><span class="s1">CharStringCompileError(Exception): </span><span class="s2">pass</span>


<span class="s2">class </span><span class="s1">SimpleT2Decompiler(object):</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">localSubrs</span><span class="s2">, </span><span class="s1">globalSubrs</span><span class="s2">, </span><span class="s1">private=</span><span class="s2">None, </span><span class="s1">blender=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">self.localSubrs = localSubrs</span>
		<span class="s1">self.localBias = calcSubrBias(localSubrs)</span>
		<span class="s1">self.globalSubrs = globalSubrs</span>
		<span class="s1">self.globalBias = calcSubrBias(globalSubrs)</span>
		<span class="s1">self.private = private</span>
		<span class="s1">self.blender = blender</span>
		<span class="s1">self.reset()</span>

	<span class="s2">def </span><span class="s1">reset(self):</span>
		<span class="s1">self.callingStack = []</span>
		<span class="s1">self.operandStack = []</span>
		<span class="s1">self.hintCount = </span><span class="s3">0</span>
		<span class="s1">self.hintMaskBytes = </span><span class="s3">0</span>
		<span class="s1">self.numRegions = </span><span class="s3">0</span>
		<span class="s1">self.vsIndex = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">execute(self</span><span class="s2">, </span><span class="s1">charString):</span>
		<span class="s1">self.callingStack.append(charString)</span>
		<span class="s1">needsDecompilation = charString.needsDecompilation()</span>
		<span class="s2">if </span><span class="s1">needsDecompilation:</span>
			<span class="s1">program = []</span>
			<span class="s1">pushToProgram = program.append</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">pushToProgram = </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s2">None</span>
		<span class="s1">pushToStack = self.operandStack.append</span>
		<span class="s1">index = </span><span class="s3">0</span>
		<span class="s2">while True</span><span class="s1">:</span>
			<span class="s1">token</span><span class="s2">, </span><span class="s1">isOperator</span><span class="s2">, </span><span class="s1">index = charString.getToken(index)</span>
			<span class="s2">if </span><span class="s1">token </span><span class="s2">is None</span><span class="s1">:</span>
				<span class="s2">break  </span><span class="s5"># we're done!</span>
			<span class="s1">pushToProgram(token)</span>
			<span class="s2">if </span><span class="s1">isOperator:</span>
				<span class="s1">handlerName = </span><span class="s4">&quot;op_&quot; </span><span class="s1">+ token</span>
				<span class="s1">handler = getattr(self</span><span class="s2">, </span><span class="s1">handlerName</span><span class="s2">, None</span><span class="s1">)</span>
				<span class="s2">if </span><span class="s1">handler </span><span class="s2">is not None</span><span class="s1">:</span>
					<span class="s1">rv = handler(index)</span>
					<span class="s2">if </span><span class="s1">rv:</span>
						<span class="s1">hintMaskBytes</span><span class="s2">, </span><span class="s1">index = rv</span>
						<span class="s1">pushToProgram(hintMaskBytes)</span>
				<span class="s2">else</span><span class="s1">:</span>
					<span class="s1">self.popall()</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">pushToStack(token)</span>
		<span class="s2">if </span><span class="s1">needsDecompilation:</span>
			<span class="s1">charString.setProgram(program)</span>
		<span class="s2">del </span><span class="s1">self.callingStack[-</span><span class="s3">1</span><span class="s1">]</span>

	<span class="s2">def </span><span class="s1">pop(self):</span>
		<span class="s1">value = self.operandStack[-</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">del </span><span class="s1">self.operandStack[-</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">return </span><span class="s1">value</span>

	<span class="s2">def </span><span class="s1">popall(self):</span>
		<span class="s1">stack = self.operandStack[:]</span>
		<span class="s1">self.operandStack[:] = []</span>
		<span class="s2">return </span><span class="s1">stack</span>

	<span class="s2">def </span><span class="s1">push(self</span><span class="s2">, </span><span class="s1">value):</span>
		<span class="s1">self.operandStack.append(value)</span>

	<span class="s2">def </span><span class="s1">op_return(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if </span><span class="s1">self.operandStack:</span>
			<span class="s2">pass</span>

	<span class="s2">def </span><span class="s1">op_endchar(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">pass</span>

	<span class="s2">def </span><span class="s1">op_ignore(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">pass</span>

	<span class="s2">def </span><span class="s1">op_callsubr(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">subrIndex = self.pop()</span>
		<span class="s1">subr = self.localSubrs[subrIndex+self.localBias]</span>
		<span class="s1">self.execute(subr)</span>

	<span class="s2">def </span><span class="s1">op_callgsubr(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">subrIndex = self.pop()</span>
		<span class="s1">subr = self.globalSubrs[subrIndex+self.globalBias]</span>
		<span class="s1">self.execute(subr)</span>

	<span class="s2">def </span><span class="s1">op_hstem(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.countHints()</span>
	<span class="s2">def </span><span class="s1">op_vstem(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.countHints()</span>
	<span class="s2">def </span><span class="s1">op_hstemhm(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.countHints()</span>
	<span class="s2">def </span><span class="s1">op_vstemhm(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.countHints()</span>

	<span class="s2">def </span><span class="s1">op_hintmask(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if not </span><span class="s1">self.hintMaskBytes:</span>
			<span class="s1">self.countHints()</span>
			<span class="s1">self.hintMaskBytes = (self.hintCount + </span><span class="s3">7</span><span class="s1">) // </span><span class="s3">8</span>
		<span class="s1">hintMaskBytes</span><span class="s2">, </span><span class="s1">index = self.callingStack[-</span><span class="s3">1</span><span class="s1">].getBytes(index</span><span class="s2">, </span><span class="s1">self.hintMaskBytes)</span>
		<span class="s2">return </span><span class="s1">hintMaskBytes</span><span class="s2">, </span><span class="s1">index</span>

	<span class="s1">op_cntrmask = op_hintmask</span>

	<span class="s2">def </span><span class="s1">countHints(self):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s1">self.hintCount = self.hintCount + len(args) // </span><span class="s3">2</span>

	<span class="s5"># misc</span>
	<span class="s2">def </span><span class="s1">op_and(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_or(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_not(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_store(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_abs(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_add(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_sub(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_div(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_load(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_neg(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_eq(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_drop(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_put(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_get(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_ifelse(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_random(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_mul(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_sqrt(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_dup(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_exch(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_index(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_roll(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>

	<span class="s2">def </span><span class="s1">op_blend(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if </span><span class="s1">self.numRegions == </span><span class="s3">0</span><span class="s1">:</span>
			<span class="s1">self.numRegions = self.private.getNumRegions()</span>
		<span class="s1">numBlends = self.pop()</span>
		<span class="s1">numOps = numBlends * (self.numRegions + </span><span class="s3">1</span><span class="s1">)</span>
		<span class="s2">if </span><span class="s1">self.blender </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">del </span><span class="s1">self.operandStack[-(numOps-numBlends):] </span><span class="s5"># Leave the default operands on the stack.</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">argi = len(self.operandStack) - numOps</span>
			<span class="s1">end_args = tuplei = argi + numBlends</span>
			<span class="s2">while </span><span class="s1">argi &lt; end_args:</span>
				<span class="s1">next_ti = tuplei + self.numRegions</span>
				<span class="s1">deltas = self.operandStack[tuplei:next_ti]</span>
				<span class="s1">delta = self.blender(self.vsIndex</span><span class="s2">, </span><span class="s1">deltas)</span>
				<span class="s1">self.operandStack[argi] += delta</span>
				<span class="s1">tuplei = next_ti</span>
				<span class="s1">argi += </span><span class="s3">1</span>
			<span class="s1">self.operandStack[end_args:] = []</span>

	<span class="s2">def </span><span class="s1">op_vsindex(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">vi = self.pop()</span>
		<span class="s1">self.vsIndex = vi</span>
		<span class="s1">self.numRegions = self.private.getNumRegions(vi)</span>


<span class="s1">t1Operators = [</span>
<span class="s5">#   opcode      name</span>
	<span class="s1">(</span><span class="s3">1</span><span class="s2">,		</span><span class="s4">'hstem'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">3</span><span class="s2">,		</span><span class="s4">'vstem'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">4</span><span class="s2">,		</span><span class="s4">'vmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">5</span><span class="s2">,		</span><span class="s4">'rlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">6</span><span class="s2">,		</span><span class="s4">'hlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">7</span><span class="s2">,		</span><span class="s4">'vlineto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">8</span><span class="s2">,		</span><span class="s4">'rrcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">9</span><span class="s2">,		</span><span class="s4">'closepath'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">10</span><span class="s2">,		</span><span class="s4">'callsubr'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">11</span><span class="s2">,		</span><span class="s4">'return'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">13</span><span class="s2">,		</span><span class="s4">'hsbw'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">14</span><span class="s2">,		</span><span class="s4">'endchar'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">21</span><span class="s2">,		</span><span class="s4">'rmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">22</span><span class="s2">,		</span><span class="s4">'hmoveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">30</span><span class="s2">,		</span><span class="s4">'vhcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">(</span><span class="s3">31</span><span class="s2">,		</span><span class="s4">'hvcurveto'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'dotsection'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'vstem3'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'hstem3'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">6</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'seac'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">7</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'sbw'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">12</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'div'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">16</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'callothersubr'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">17</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'pop'</span><span class="s1">)</span><span class="s2">,</span>
	<span class="s1">((</span><span class="s3">12</span><span class="s2">, </span><span class="s3">33</span><span class="s1">)</span><span class="s2">,	</span><span class="s4">'setcurrentpoint'</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">class </span><span class="s1">T2WidthExtractor(SimpleT2Decompiler):</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">localSubrs</span><span class="s2">, </span><span class="s1">globalSubrs</span><span class="s2">, </span><span class="s1">nominalWidthX</span><span class="s2">, </span><span class="s1">defaultWidthX</span><span class="s2">, </span><span class="s1">private=</span><span class="s2">None, </span><span class="s1">blender=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">SimpleT2Decompiler.__init__(self</span><span class="s2">, </span><span class="s1">localSubrs</span><span class="s2">, </span><span class="s1">globalSubrs</span><span class="s2">, </span><span class="s1">private</span><span class="s2">, </span><span class="s1">blender)</span>
		<span class="s1">self.nominalWidthX = nominalWidthX</span>
		<span class="s1">self.defaultWidthX = defaultWidthX</span>

	<span class="s2">def </span><span class="s1">reset(self):</span>
		<span class="s1">SimpleT2Decompiler.reset(self)</span>
		<span class="s1">self.gotWidth = </span><span class="s3">0</span>
		<span class="s1">self.width = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">popallWidth(self</span><span class="s2">, </span><span class="s1">evenOdd=</span><span class="s3">0</span><span class="s1">):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">if not </span><span class="s1">self.gotWidth:</span>
			<span class="s2">if </span><span class="s1">evenOdd ^ (len(args) % </span><span class="s3">2</span><span class="s1">):</span>
				<span class="s5"># For CFF2 charstrings, this should never happen</span>
				<span class="s2">assert </span><span class="s1">self.defaultWidthX </span><span class="s2">is not None, </span><span class="s4">&quot;CFF2 CharStrings must not have an initial width value&quot;</span>
				<span class="s1">self.width = self.nominalWidthX + args[</span><span class="s3">0</span><span class="s1">]</span>
				<span class="s1">args = args[</span><span class="s3">1</span><span class="s1">:]</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">self.width = self.defaultWidthX</span>
			<span class="s1">self.gotWidth = </span><span class="s3">1</span>
		<span class="s2">return </span><span class="s1">args</span>

	<span class="s2">def </span><span class="s1">countHints(self):</span>
		<span class="s1">args = self.popallWidth()</span>
		<span class="s1">self.hintCount = self.hintCount + len(args) // </span><span class="s3">2</span>

	<span class="s2">def </span><span class="s1">op_rmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popallWidth()</span>

	<span class="s2">def </span><span class="s1">op_hmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popallWidth(</span><span class="s3">1</span><span class="s1">)</span>

	<span class="s2">def </span><span class="s1">op_vmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popallWidth(</span><span class="s3">1</span><span class="s1">)</span>

	<span class="s2">def </span><span class="s1">op_endchar(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popallWidth()</span>


<span class="s2">class </span><span class="s1">T2OutlineExtractor(T2WidthExtractor):</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pen</span><span class="s2">, </span><span class="s1">localSubrs</span><span class="s2">, </span><span class="s1">globalSubrs</span><span class="s2">, </span><span class="s1">nominalWidthX</span><span class="s2">, </span><span class="s1">defaultWidthX</span><span class="s2">, </span><span class="s1">private=</span><span class="s2">None, </span><span class="s1">blender=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">T2WidthExtractor.__init__(</span>
			<span class="s1">self</span><span class="s2">, </span><span class="s1">localSubrs</span><span class="s2">, </span><span class="s1">globalSubrs</span><span class="s2">, </span><span class="s1">nominalWidthX</span><span class="s2">, </span><span class="s1">defaultWidthX</span><span class="s2">, </span><span class="s1">private</span><span class="s2">, </span><span class="s1">blender)</span>
		<span class="s1">self.pen = pen</span>
		<span class="s1">self.subrLevel = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">reset(self):</span>
		<span class="s1">T2WidthExtractor.reset(self)</span>
		<span class="s1">self.currentPoint = (</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
		<span class="s1">self.sawMoveTo = </span><span class="s3">0</span>
		<span class="s1">self.subrLevel = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">execute(self</span><span class="s2">, </span><span class="s1">charString):</span>
		<span class="s1">self.subrLevel += </span><span class="s3">1</span>
		<span class="s1">super().execute(charString)</span>
		<span class="s1">self.subrLevel -= </span><span class="s3">1</span>
		<span class="s2">if </span><span class="s1">self.subrLevel == </span><span class="s3">0</span><span class="s1">:</span>
			<span class="s1">self.endPath()</span>

	<span class="s2">def </span><span class="s1">_nextPoint(self</span><span class="s2">, </span><span class="s1">point):</span>
		<span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.currentPoint</span>
		<span class="s1">point = x + point[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y + point[</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s1">self.currentPoint = point</span>
		<span class="s2">return </span><span class="s1">point</span>

	<span class="s2">def </span><span class="s1">rMoveTo(self</span><span class="s2">, </span><span class="s1">point):</span>
		<span class="s1">self.pen.moveTo(self._nextPoint(point))</span>
		<span class="s1">self.sawMoveTo = </span><span class="s3">1</span>

	<span class="s2">def </span><span class="s1">rLineTo(self</span><span class="s2">, </span><span class="s1">point):</span>
		<span class="s2">if not </span><span class="s1">self.sawMoveTo:</span>
			<span class="s1">self.rMoveTo((</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
		<span class="s1">self.pen.lineTo(self._nextPoint(point))</span>

	<span class="s2">def </span><span class="s1">rCurveTo(self</span><span class="s2">, </span><span class="s1">pt1</span><span class="s2">, </span><span class="s1">pt2</span><span class="s2">, </span><span class="s1">pt3):</span>
		<span class="s2">if not </span><span class="s1">self.sawMoveTo:</span>
			<span class="s1">self.rMoveTo((</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
		<span class="s1">nextPoint = self._nextPoint</span>
		<span class="s1">self.pen.curveTo(nextPoint(pt1)</span><span class="s2">, </span><span class="s1">nextPoint(pt2)</span><span class="s2">, </span><span class="s1">nextPoint(pt3))</span>

	<span class="s2">def </span><span class="s1">closePath(self):</span>
		<span class="s2">if </span><span class="s1">self.sawMoveTo:</span>
			<span class="s1">self.pen.closePath()</span>
		<span class="s1">self.sawMoveTo = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">endPath(self):</span>
		<span class="s5"># In T2 there are no open paths, so always do a closePath when</span>
		<span class="s5"># finishing a sub path. We avoid spurious calls to closePath()</span>
		<span class="s5"># because its a real T1 op we're emulating in T2 whereas</span>
		<span class="s5"># endPath() is just a means to that emulation</span>
		<span class="s2">if </span><span class="s1">self.sawMoveTo:</span>
			<span class="s1">self.closePath()</span>

	<span class="s5">#</span>
	<span class="s5"># hint operators</span>
	<span class="s5">#</span>
	<span class="s5">#def op_hstem(self, index):</span>
	<span class="s5">#   self.countHints()</span>
	<span class="s5">#def op_vstem(self, index):</span>
	<span class="s5">#   self.countHints()</span>
	<span class="s5">#def op_hstemhm(self, index):</span>
	<span class="s5">#   self.countHints()</span>
	<span class="s5">#def op_vstemhm(self, index):</span>
	<span class="s5">#   self.countHints()</span>
	<span class="s5">#def op_hintmask(self, index):</span>
	<span class="s5">#   self.countHints()</span>
	<span class="s5">#def op_cntrmask(self, index):</span>
	<span class="s5">#   self.countHints()</span>

	<span class="s5">#</span>
	<span class="s5"># path constructors, moveto</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_rmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo(self.popallWidth())</span>
	<span class="s2">def </span><span class="s1">op_hmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo((self.popallWidth(</span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
	<span class="s2">def </span><span class="s1">op_vmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">self.popallWidth(</span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]))</span>
	<span class="s2">def </span><span class="s1">op_endchar(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">args = self.popallWidth()</span>
		<span class="s2">if </span><span class="s1">args:</span>
			<span class="s2">from </span><span class="s1">fontTools.encodings.StandardEncoding </span><span class="s2">import </span><span class="s1">StandardEncoding</span>
			<span class="s5"># endchar can do seac accent bulding; The T2 spec says it's deprecated,</span>
			<span class="s5"># but recent software that shall remain nameless does output it.</span>
			<span class="s1">adx</span><span class="s2">, </span><span class="s1">ady</span><span class="s2">, </span><span class="s1">bchar</span><span class="s2">, </span><span class="s1">achar = args</span>
			<span class="s1">baseGlyph = StandardEncoding[bchar]</span>
			<span class="s1">self.pen.addComponent(baseGlyph</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
			<span class="s1">accentGlyph = StandardEncoding[achar]</span>
			<span class="s1">self.pen.addComponent(accentGlyph</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">adx</span><span class="s2">, </span><span class="s1">ady))</span>

	<span class="s5">#</span>
	<span class="s5"># path constructors, lines</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_rlineto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(args)</span><span class="s2">, </span><span class="s3">2</span><span class="s1">):</span>
			<span class="s1">point = args[i:i+</span><span class="s3">2</span><span class="s1">]</span>
			<span class="s1">self.rLineTo(point)</span>

	<span class="s2">def </span><span class="s1">op_hlineto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.alternatingLineto(</span><span class="s3">1</span><span class="s1">)</span>
	<span class="s2">def </span><span class="s1">op_vlineto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.alternatingLineto(</span><span class="s3">0</span><span class="s1">)</span>

	<span class="s5">#</span>
	<span class="s5"># path constructors, curves</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_rrcurveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;{dxa dya dxb dyb dxc dyc}+ rrcurveto&quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(args)</span><span class="s2">, </span><span class="s3">6</span><span class="s1">):</span>
			<span class="s1">dxa</span><span class="s2">, </span><span class="s1">dya</span><span class="s2">, </span><span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dxc</span><span class="s2">, </span><span class="s1">dyc</span><span class="s2">, </span><span class="s1">= args[i:i+</span><span class="s3">6</span><span class="s1">]</span>
			<span class="s1">self.rCurveTo((dxa</span><span class="s2">, </span><span class="s1">dya)</span><span class="s2">, </span><span class="s1">(dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s1">dyc))</span>

	<span class="s2">def </span><span class="s1">op_rcurveline(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;{dxa dya dxb dyb dxc dyc}+ dxd dyd rcurveline&quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(args)-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">6</span><span class="s1">):</span>
			<span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dxc</span><span class="s2">, </span><span class="s1">dyc</span><span class="s2">, </span><span class="s1">dxd</span><span class="s2">, </span><span class="s1">dyd = args[i:i+</span><span class="s3">6</span><span class="s1">]</span>
			<span class="s1">self.rCurveTo((dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s1">dyc)</span><span class="s2">, </span><span class="s1">(dxd</span><span class="s2">, </span><span class="s1">dyd))</span>
		<span class="s1">self.rLineTo(args[-</span><span class="s3">2</span><span class="s1">:])</span>

	<span class="s2">def </span><span class="s1">op_rlinecurve(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;{dxa dya}+ dxb dyb dxc dyc dxd dyd rlinecurve&quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s1">lineArgs = args[:-</span><span class="s3">6</span><span class="s1">]</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(lineArgs)</span><span class="s2">, </span><span class="s3">2</span><span class="s1">):</span>
			<span class="s1">self.rLineTo(lineArgs[i:i+</span><span class="s3">2</span><span class="s1">])</span>
		<span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dxc</span><span class="s2">, </span><span class="s1">dyc</span><span class="s2">, </span><span class="s1">dxd</span><span class="s2">, </span><span class="s1">dyd = args[-</span><span class="s3">6</span><span class="s1">:]</span>
		<span class="s1">self.rCurveTo((dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s1">dyc)</span><span class="s2">, </span><span class="s1">(dxd</span><span class="s2">, </span><span class="s1">dyd))</span>

	<span class="s2">def </span><span class="s1">op_vvcurveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;dx1? {dya dxb dyb dyc}+ vvcurveto&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">if </span><span class="s1">len(args) % </span><span class="s3">2</span><span class="s1">:</span>
			<span class="s1">dx1 = args[</span><span class="s3">0</span><span class="s1">]</span>
			<span class="s1">args = args[</span><span class="s3">1</span><span class="s1">:]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">dx1 = </span><span class="s3">0</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(args)</span><span class="s2">, </span><span class="s3">4</span><span class="s1">):</span>
			<span class="s1">dya</span><span class="s2">, </span><span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dyc = args[i:i+</span><span class="s3">4</span><span class="s1">]</span>
			<span class="s1">self.rCurveTo((dx1</span><span class="s2">, </span><span class="s1">dya)</span><span class="s2">, </span><span class="s1">(dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">dyc))</span>
			<span class="s1">dx1 = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">op_hhcurveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;dy1? {dxa dxb dyb dxc}+ hhcurveto&quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">if </span><span class="s1">len(args) % </span><span class="s3">2</span><span class="s1">:</span>
			<span class="s1">dy1 = args[</span><span class="s3">0</span><span class="s1">]</span>
			<span class="s1">args = args[</span><span class="s3">1</span><span class="s1">:]</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">dy1 = </span><span class="s3">0</span>
		<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(args)</span><span class="s2">, </span><span class="s3">4</span><span class="s1">):</span>
			<span class="s1">dxa</span><span class="s2">, </span><span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dxc = args[i:i+</span><span class="s3">4</span><span class="s1">]</span>
			<span class="s1">self.rCurveTo((dxa</span><span class="s2">, </span><span class="s1">dy1)</span><span class="s2">, </span><span class="s1">(dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
			<span class="s1">dy1 = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">op_vhcurveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;dy1 dx2 dy2 dx3 {dxa dxb dyb dyc dyd dxe dye dxf}* dyf? vhcurveto (30) 
        {dya dxb dyb dxc dxd dxe dye dyf}+ dxf? vhcurveto 
        &quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">while </span><span class="s1">args:</span>
			<span class="s1">args = self.vcurveto(args)</span>
			<span class="s2">if </span><span class="s1">args:</span>
				<span class="s1">args = self.hcurveto(args)</span>

	<span class="s2">def </span><span class="s1">op_hvcurveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;&quot;&quot;dx1 dx2 dy2 dy3 {dya dxb dyb dxc dxd dxe dye dyf}* dxf? 
        {dxa dxb dyb dyc dyd dxe dye dxf}+ dyf? 
        &quot;&quot;&quot;</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">while </span><span class="s1">args:</span>
			<span class="s1">args = self.hcurveto(args)</span>
			<span class="s2">if </span><span class="s1">args:</span>
				<span class="s1">args = self.vcurveto(args)</span>

	<span class="s5">#</span>
	<span class="s5"># path constructors, flex</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_hflex(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">dx1</span><span class="s2">, </span><span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2</span><span class="s2">, </span><span class="s1">dx3</span><span class="s2">, </span><span class="s1">dx4</span><span class="s2">, </span><span class="s1">dx5</span><span class="s2">, </span><span class="s1">dx6 = self.popall()</span>
		<span class="s1">dy1 = dy3 = dy4 = dy6 = </span><span class="s3">0</span>
		<span class="s1">dy5 = -dy2</span>
		<span class="s1">self.rCurveTo((dx1</span><span class="s2">, </span><span class="s1">dy1)</span><span class="s2">, </span><span class="s1">(dx2</span><span class="s2">, </span><span class="s1">dy2)</span><span class="s2">, </span><span class="s1">(dx3</span><span class="s2">, </span><span class="s1">dy3))</span>
		<span class="s1">self.rCurveTo((dx4</span><span class="s2">, </span><span class="s1">dy4)</span><span class="s2">, </span><span class="s1">(dx5</span><span class="s2">, </span><span class="s1">dy5)</span><span class="s2">, </span><span class="s1">(dx6</span><span class="s2">, </span><span class="s1">dy6))</span>
	<span class="s2">def </span><span class="s1">op_flex(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">dx1</span><span class="s2">, </span><span class="s1">dy1</span><span class="s2">, </span><span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2</span><span class="s2">, </span><span class="s1">dx3</span><span class="s2">, </span><span class="s1">dy3</span><span class="s2">, </span><span class="s1">dx4</span><span class="s2">, </span><span class="s1">dy4</span><span class="s2">, </span><span class="s1">dx5</span><span class="s2">, </span><span class="s1">dy5</span><span class="s2">, </span><span class="s1">dx6</span><span class="s2">, </span><span class="s1">dy6</span><span class="s2">, </span><span class="s1">fd = self.popall()</span>
		<span class="s1">self.rCurveTo((dx1</span><span class="s2">, </span><span class="s1">dy1)</span><span class="s2">, </span><span class="s1">(dx2</span><span class="s2">, </span><span class="s1">dy2)</span><span class="s2">, </span><span class="s1">(dx3</span><span class="s2">, </span><span class="s1">dy3))</span>
		<span class="s1">self.rCurveTo((dx4</span><span class="s2">, </span><span class="s1">dy4)</span><span class="s2">, </span><span class="s1">(dx5</span><span class="s2">, </span><span class="s1">dy5)</span><span class="s2">, </span><span class="s1">(dx6</span><span class="s2">, </span><span class="s1">dy6))</span>
	<span class="s2">def </span><span class="s1">op_hflex1(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">dx1</span><span class="s2">, </span><span class="s1">dy1</span><span class="s2">, </span><span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2</span><span class="s2">, </span><span class="s1">dx3</span><span class="s2">, </span><span class="s1">dx4</span><span class="s2">, </span><span class="s1">dx5</span><span class="s2">, </span><span class="s1">dy5</span><span class="s2">, </span><span class="s1">dx6 = self.popall()</span>
		<span class="s1">dy3 = dy4 = </span><span class="s3">0</span>
		<span class="s1">dy6 = -(dy1 + dy2 + dy3 + dy4 + dy5)</span>

		<span class="s1">self.rCurveTo((dx1</span><span class="s2">, </span><span class="s1">dy1)</span><span class="s2">, </span><span class="s1">(dx2</span><span class="s2">, </span><span class="s1">dy2)</span><span class="s2">, </span><span class="s1">(dx3</span><span class="s2">, </span><span class="s1">dy3))</span>
		<span class="s1">self.rCurveTo((dx4</span><span class="s2">, </span><span class="s1">dy4)</span><span class="s2">, </span><span class="s1">(dx5</span><span class="s2">, </span><span class="s1">dy5)</span><span class="s2">, </span><span class="s1">(dx6</span><span class="s2">, </span><span class="s1">dy6))</span>
	<span class="s2">def </span><span class="s1">op_flex1(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">dx1</span><span class="s2">, </span><span class="s1">dy1</span><span class="s2">, </span><span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2</span><span class="s2">, </span><span class="s1">dx3</span><span class="s2">, </span><span class="s1">dy3</span><span class="s2">, </span><span class="s1">dx4</span><span class="s2">, </span><span class="s1">dy4</span><span class="s2">, </span><span class="s1">dx5</span><span class="s2">, </span><span class="s1">dy5</span><span class="s2">, </span><span class="s1">d6 = self.popall()</span>
		<span class="s1">dx = dx1 + dx2 + dx3 + dx4 + dx5</span>
		<span class="s1">dy = dy1 + dy2 + dy3 + dy4 + dy5</span>
		<span class="s2">if </span><span class="s1">abs(dx) &gt; abs(dy):</span>
			<span class="s1">dx6 = d6</span>
			<span class="s1">dy6 = -dy</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">dx6 = -dx</span>
			<span class="s1">dy6 = d6</span>
		<span class="s1">self.rCurveTo((dx1</span><span class="s2">, </span><span class="s1">dy1)</span><span class="s2">, </span><span class="s1">(dx2</span><span class="s2">, </span><span class="s1">dy2)</span><span class="s2">, </span><span class="s1">(dx3</span><span class="s2">, </span><span class="s1">dy3))</span>
		<span class="s1">self.rCurveTo((dx4</span><span class="s2">, </span><span class="s1">dy4)</span><span class="s2">, </span><span class="s1">(dx5</span><span class="s2">, </span><span class="s1">dy5)</span><span class="s2">, </span><span class="s1">(dx6</span><span class="s2">, </span><span class="s1">dy6))</span>

	<span class="s5"># misc</span>
	<span class="s2">def </span><span class="s1">op_and(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_or(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_not(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_store(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_abs(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_add(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_sub(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_div(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">num2 = self.pop()</span>
		<span class="s1">num1 = self.pop()</span>
		<span class="s1">d1 = num1//num2</span>
		<span class="s1">d2 = num1/num2</span>
		<span class="s2">if </span><span class="s1">d1 == d2:</span>
			<span class="s1">self.push(d1)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">self.push(d2)</span>
	<span class="s2">def </span><span class="s1">op_load(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_neg(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_eq(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_drop(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_put(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_get(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_ifelse(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_random(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_mul(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_sqrt(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_dup(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_exch(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_index(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>
	<span class="s2">def </span><span class="s1">op_roll(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">raise </span><span class="s1">NotImplementedError</span>

	<span class="s5">#</span>
	<span class="s5"># miscellaneous helpers</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">alternatingLineto(self</span><span class="s2">, </span><span class="s1">isHorizontal):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
			<span class="s2">if </span><span class="s1">isHorizontal:</span>
				<span class="s1">point = (arg</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">point = (</span><span class="s3">0</span><span class="s2">, </span><span class="s1">arg)</span>
			<span class="s1">self.rLineTo(point)</span>
			<span class="s1">isHorizontal = </span><span class="s2">not </span><span class="s1">isHorizontal</span>

	<span class="s2">def </span><span class="s1">vcurveto(self</span><span class="s2">, </span><span class="s1">args):</span>
		<span class="s1">dya</span><span class="s2">, </span><span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dxc = args[:</span><span class="s3">4</span><span class="s1">]</span>
		<span class="s1">args = args[</span><span class="s3">4</span><span class="s1">:]</span>
		<span class="s2">if </span><span class="s1">len(args) == </span><span class="s3">1</span><span class="s1">:</span>
			<span class="s1">dyc = args[</span><span class="s3">0</span><span class="s1">]</span>
			<span class="s1">args = []</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">dyc = </span><span class="s3">0</span>
		<span class="s1">self.rCurveTo((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">dya)</span><span class="s2">, </span><span class="s1">(dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s1">dyc))</span>
		<span class="s2">return </span><span class="s1">args</span>

	<span class="s2">def </span><span class="s1">hcurveto(self</span><span class="s2">, </span><span class="s1">args):</span>
		<span class="s1">dxa</span><span class="s2">, </span><span class="s1">dxb</span><span class="s2">, </span><span class="s1">dyb</span><span class="s2">, </span><span class="s1">dyc = args[:</span><span class="s3">4</span><span class="s1">]</span>
		<span class="s1">args = args[</span><span class="s3">4</span><span class="s1">:]</span>
		<span class="s2">if </span><span class="s1">len(args) == </span><span class="s3">1</span><span class="s1">:</span>
			<span class="s1">dxc = args[</span><span class="s3">0</span><span class="s1">]</span>
			<span class="s1">args = []</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">dxc = </span><span class="s3">0</span>
		<span class="s1">self.rCurveTo((dxa</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(dxb</span><span class="s2">, </span><span class="s1">dyb)</span><span class="s2">, </span><span class="s1">(dxc</span><span class="s2">, </span><span class="s1">dyc))</span>
		<span class="s2">return </span><span class="s1">args</span>

<span class="s2">class </span><span class="s1">T1OutlineExtractor(T2OutlineExtractor):</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pen</span><span class="s2">, </span><span class="s1">subrs):</span>
		<span class="s1">self.pen = pen</span>
		<span class="s1">self.subrs = subrs</span>
		<span class="s1">self.reset()</span>

	<span class="s2">def </span><span class="s1">reset(self):</span>
		<span class="s1">self.flexing = </span><span class="s3">0</span>
		<span class="s1">self.width = </span><span class="s3">0</span>
		<span class="s1">self.sbx = </span><span class="s3">0</span>
		<span class="s1">T2OutlineExtractor.reset(self)</span>

	<span class="s2">def </span><span class="s1">endPath(self):</span>
		<span class="s2">if </span><span class="s1">self.sawMoveTo:</span>
			<span class="s1">self.pen.endPath()</span>
		<span class="s1">self.sawMoveTo = </span><span class="s3">0</span>

	<span class="s2">def </span><span class="s1">popallWidth(self</span><span class="s2">, </span><span class="s1">evenOdd=</span><span class="s3">0</span><span class="s1">):</span>
		<span class="s2">return </span><span class="s1">self.popall()</span>

	<span class="s2">def </span><span class="s1">exch(self):</span>
		<span class="s1">stack = self.operandStack</span>
		<span class="s1">stack[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stack[-</span><span class="s3">2</span><span class="s1">] = stack[-</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stack[-</span><span class="s3">1</span><span class="s1">]</span>

	<span class="s5">#</span>
	<span class="s5"># path constructors</span>
	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_rmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if </span><span class="s1">self.flexing:</span>
			<span class="s2">return</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo(self.popall())</span>
	<span class="s2">def </span><span class="s1">op_hmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if </span><span class="s1">self.flexing:</span>
			<span class="s5"># We must add a parameter to the stack if we are flexing</span>
			<span class="s1">self.push(</span><span class="s3">0</span><span class="s1">)</span>
			<span class="s2">return</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo((self.popall()[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
	<span class="s2">def </span><span class="s1">op_vmoveto(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">if </span><span class="s1">self.flexing:</span>
			<span class="s5"># We must add a parameter to the stack if we are flexing</span>
			<span class="s1">self.push(</span><span class="s3">0</span><span class="s1">)</span>
			<span class="s1">self.exch()</span>
			<span class="s2">return</span>
		<span class="s1">self.endPath()</span>
		<span class="s1">self.rMoveTo((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">self.popall()[</span><span class="s3">0</span><span class="s1">]))</span>
	<span class="s2">def </span><span class="s1">op_closepath(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.closePath()</span>
	<span class="s2">def </span><span class="s1">op_setcurrentpoint(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">args = self.popall()</span>
		<span class="s1">x</span><span class="s2">, </span><span class="s1">y = args</span>
		<span class="s1">self.currentPoint = x</span><span class="s2">, </span><span class="s1">y</span>

	<span class="s2">def </span><span class="s1">op_endchar(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.endPath()</span>

	<span class="s2">def </span><span class="s1">op_hsbw(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">sbx</span><span class="s2">, </span><span class="s1">wx = self.popall()</span>
		<span class="s1">self.width = wx</span>
		<span class="s1">self.sbx = sbx</span>
		<span class="s1">self.currentPoint = sbx</span><span class="s2">, </span><span class="s1">self.currentPoint[</span><span class="s3">1</span><span class="s1">]</span>
	<span class="s2">def </span><span class="s1">op_sbw(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popall()  </span><span class="s5"># XXX</span>

	<span class="s5">#</span>
	<span class="s2">def </span><span class="s1">op_callsubr(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">subrIndex = self.pop()</span>
		<span class="s1">subr = self.subrs[subrIndex]</span>
		<span class="s1">self.execute(subr)</span>
	<span class="s2">def </span><span class="s1">op_callothersubr(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">subrIndex = self.pop()</span>
		<span class="s1">nArgs = self.pop()</span>
		<span class="s5">#print nArgs, subrIndex, &quot;callothersubr&quot;</span>
		<span class="s2">if </span><span class="s1">subrIndex == </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">nArgs == </span><span class="s3">3</span><span class="s1">:</span>
			<span class="s1">self.doFlex()</span>
			<span class="s1">self.flexing = </span><span class="s3">0</span>
		<span class="s2">elif </span><span class="s1">subrIndex == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">nArgs == </span><span class="s3">0</span><span class="s1">:</span>
			<span class="s1">self.flexing = </span><span class="s3">1</span>
		<span class="s5"># ignore...</span>
	<span class="s2">def </span><span class="s1">op_pop(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s2">pass  </span><span class="s5"># ignore...</span>

	<span class="s2">def </span><span class="s1">doFlex(self):</span>
		<span class="s1">finaly = self.pop()</span>
		<span class="s1">finalx = self.pop()</span>
		<span class="s1">self.pop()	</span><span class="s5"># flex height is unused</span>

		<span class="s1">p3y = self.pop()</span>
		<span class="s1">p3x = self.pop()</span>
		<span class="s1">bcp4y = self.pop()</span>
		<span class="s1">bcp4x = self.pop()</span>
		<span class="s1">bcp3y = self.pop()</span>
		<span class="s1">bcp3x = self.pop()</span>
		<span class="s1">p2y = self.pop()</span>
		<span class="s1">p2x = self.pop()</span>
		<span class="s1">bcp2y = self.pop()</span>
		<span class="s1">bcp2x = self.pop()</span>
		<span class="s1">bcp1y = self.pop()</span>
		<span class="s1">bcp1x = self.pop()</span>
		<span class="s1">rpy = self.pop()</span>
		<span class="s1">rpx = self.pop()</span>

		<span class="s5"># call rrcurveto</span>
		<span class="s1">self.push(bcp1x+rpx)</span>
		<span class="s1">self.push(bcp1y+rpy)</span>
		<span class="s1">self.push(bcp2x)</span>
		<span class="s1">self.push(bcp2y)</span>
		<span class="s1">self.push(p2x)</span>
		<span class="s1">self.push(p2y)</span>
		<span class="s1">self.op_rrcurveto(</span><span class="s2">None</span><span class="s1">)</span>

		<span class="s5"># call rrcurveto</span>
		<span class="s1">self.push(bcp3x)</span>
		<span class="s1">self.push(bcp3y)</span>
		<span class="s1">self.push(bcp4x)</span>
		<span class="s1">self.push(bcp4y)</span>
		<span class="s1">self.push(p3x)</span>
		<span class="s1">self.push(p3y)</span>
		<span class="s1">self.op_rrcurveto(</span><span class="s2">None</span><span class="s1">)</span>

		<span class="s5"># Push back final coords so subr 0 can find them</span>
		<span class="s1">self.push(finalx)</span>
		<span class="s1">self.push(finaly)</span>

	<span class="s2">def </span><span class="s1">op_dotsection(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popall()  </span><span class="s5"># XXX</span>
	<span class="s2">def </span><span class="s1">op_hstem3(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popall()  </span><span class="s5"># XXX</span>
	<span class="s2">def </span><span class="s1">op_seac(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s0">&quot;asb adx ady bchar achar seac&quot;</span>
		<span class="s2">from </span><span class="s1">fontTools.encodings.StandardEncoding </span><span class="s2">import </span><span class="s1">StandardEncoding</span>
		<span class="s1">asb</span><span class="s2">, </span><span class="s1">adx</span><span class="s2">, </span><span class="s1">ady</span><span class="s2">, </span><span class="s1">bchar</span><span class="s2">, </span><span class="s1">achar = self.popall()</span>
		<span class="s1">baseGlyph = StandardEncoding[bchar]</span>
		<span class="s1">self.pen.addComponent(baseGlyph</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
		<span class="s1">accentGlyph = StandardEncoding[achar]</span>
		<span class="s1">adx = adx + self.sbx - asb  </span><span class="s5"># seac weirdness</span>
		<span class="s1">self.pen.addComponent(accentGlyph</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">adx</span><span class="s2">, </span><span class="s1">ady))</span>
	<span class="s2">def </span><span class="s1">op_vstem3(self</span><span class="s2">, </span><span class="s1">index):</span>
		<span class="s1">self.popall()  </span><span class="s5"># XXX</span>

<span class="s2">class </span><span class="s1">T2CharString(object):</span>

	<span class="s1">operandEncoding = t2OperandEncoding</span>
	<span class="s1">operators</span><span class="s2">, </span><span class="s1">opcodes = buildOperatorDict(t2Operators)</span>
	<span class="s1">decompilerClass = SimpleT2Decompiler</span>
	<span class="s1">outlineExtractor = T2OutlineExtractor</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bytecode=</span><span class="s2">None, </span><span class="s1">program=</span><span class="s2">None, </span><span class="s1">private=</span><span class="s2">None, </span><span class="s1">globalSubrs=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s2">if </span><span class="s1">program </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s1">program = []</span>
		<span class="s1">self.bytecode = bytecode</span>
		<span class="s1">self.program = program</span>
		<span class="s1">self.private = private</span>
		<span class="s1">self.globalSubrs = globalSubrs </span><span class="s2">if </span><span class="s1">globalSubrs </span><span class="s2">is not None else </span><span class="s1">[]</span>
		<span class="s1">self._cur_vsindex = </span><span class="s2">None</span>

	<span class="s2">def </span><span class="s1">getNumRegions(self</span><span class="s2">, </span><span class="s1">vsindex=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">pd = self.private</span>
		<span class="s2">assert</span><span class="s1">(pd </span><span class="s2">is not None</span><span class="s1">)</span>
		<span class="s2">if </span><span class="s1">vsindex </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s1">self._cur_vsindex = vsindex</span>
		<span class="s2">elif </span><span class="s1">self._cur_vsindex </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s1">self._cur_vsindex = pd.vsindex </span><span class="s2">if </span><span class="s1">hasattr(pd</span><span class="s2">, </span><span class="s4">'vsindex'</span><span class="s1">) </span><span class="s2">else </span><span class="s3">0</span>
		<span class="s2">return </span><span class="s1">pd.getNumRegions(self._cur_vsindex)</span>

	<span class="s2">def </span><span class="s1">__repr__(self):</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">return </span><span class="s4">&quot;&lt;%s (source) at %x&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">id(self))</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">return </span><span class="s4">&quot;&lt;%s (bytecode) at %x&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">id(self))</span>

	<span class="s2">def </span><span class="s1">getIntEncoder(self):</span>
		<span class="s2">return </span><span class="s1">encodeIntT2</span>

	<span class="s2">def </span><span class="s1">getFixedEncoder(self):</span>
		<span class="s2">return </span><span class="s1">encodeFixed</span>

	<span class="s2">def </span><span class="s1">decompile(self):</span>
		<span class="s2">if not </span><span class="s1">self.needsDecompilation():</span>
			<span class="s2">return</span>
		<span class="s1">subrs = getattr(self.private</span><span class="s2">, </span><span class="s4">&quot;Subrs&quot;</span><span class="s2">, </span><span class="s1">[])</span>
		<span class="s1">decompiler = self.decompilerClass(subrs</span><span class="s2">, </span><span class="s1">self.globalSubrs</span><span class="s2">, </span><span class="s1">self.private)</span>
		<span class="s1">decompiler.execute(self)</span>

	<span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">pen</span><span class="s2">, </span><span class="s1">blender=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">subrs = getattr(self.private</span><span class="s2">, </span><span class="s4">&quot;Subrs&quot;</span><span class="s2">, </span><span class="s1">[])</span>
		<span class="s1">extractor = self.outlineExtractor(pen</span><span class="s2">, </span><span class="s1">subrs</span><span class="s2">, </span><span class="s1">self.globalSubrs</span><span class="s2">,</span>
				<span class="s1">self.private.nominalWidthX</span><span class="s2">, </span><span class="s1">self.private.defaultWidthX</span><span class="s2">,</span>
				<span class="s1">self.private</span><span class="s2">, </span><span class="s1">blender)</span>
		<span class="s1">extractor.execute(self)</span>
		<span class="s1">self.width = extractor.width</span>

	<span class="s2">def </span><span class="s1">calcBounds(self</span><span class="s2">, </span><span class="s1">glyphSet):</span>
		<span class="s1">boundsPen = BoundsPen(glyphSet)</span>
		<span class="s1">self.draw(boundsPen)</span>
		<span class="s2">return </span><span class="s1">boundsPen.bounds</span>

	<span class="s2">def </span><span class="s1">compile(self</span><span class="s2">, </span><span class="s1">isCFF2=</span><span class="s2">False</span><span class="s1">):</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s2">return</span>
		<span class="s1">opcodes = self.opcodes</span>
		<span class="s1">program = self.program</span>

		<span class="s2">if </span><span class="s1">isCFF2:</span>
			<span class="s5"># If present, remove return and endchar operators.</span>
			<span class="s2">if </span><span class="s1">program </span><span class="s2">and </span><span class="s1">program[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;return&quot;</span><span class="s2">, </span><span class="s4">&quot;endchar&quot;</span><span class="s1">):</span>
				<span class="s1">program = program[:-</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">elif </span><span class="s1">program </span><span class="s2">and not </span><span class="s1">isinstance(program[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str):</span>
			<span class="s2">raise </span><span class="s1">CharStringCompileError(</span>
				<span class="s4">&quot;T2CharString or Subr has items on the stack after last operator.&quot;</span>
			<span class="s1">)</span>

		<span class="s1">bytecode = []</span>
		<span class="s1">encodeInt = self.getIntEncoder()</span>
		<span class="s1">encodeFixed = self.getFixedEncoder()</span>
		<span class="s1">i = </span><span class="s3">0</span>
		<span class="s1">end = len(program)</span>
		<span class="s2">while </span><span class="s1">i &lt; end:</span>
			<span class="s1">token = program[i]</span>
			<span class="s1">i = i + </span><span class="s3">1</span>
			<span class="s2">if </span><span class="s1">isinstance(token</span><span class="s2">, </span><span class="s1">str):</span>
				<span class="s2">try</span><span class="s1">:</span>
					<span class="s1">bytecode.extend(bytechr(b) </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">opcodes[token])</span>
				<span class="s2">except </span><span class="s1">KeyError:</span>
					<span class="s2">raise </span><span class="s1">CharStringCompileError(</span><span class="s4">&quot;illegal operator: %s&quot; </span><span class="s1">% token)</span>
				<span class="s2">if </span><span class="s1">token </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'hintmask'</span><span class="s2">, </span><span class="s4">'cntrmask'</span><span class="s1">):</span>
					<span class="s1">bytecode.append(program[i])  </span><span class="s5"># hint mask</span>
					<span class="s1">i = i + </span><span class="s3">1</span>
			<span class="s2">elif </span><span class="s1">isinstance(token</span><span class="s2">, </span><span class="s1">int):</span>
				<span class="s1">bytecode.append(encodeInt(token))</span>
			<span class="s2">elif </span><span class="s1">isinstance(token</span><span class="s2">, </span><span class="s1">float):</span>
				<span class="s1">bytecode.append(encodeFixed(token))</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s2">assert </span><span class="s3">0</span><span class="s2">, </span><span class="s4">&quot;unsupported type: %s&quot; </span><span class="s1">% type(token)</span>
		<span class="s2">try</span><span class="s1">:</span>
			<span class="s1">bytecode = bytesjoin(bytecode)</span>
		<span class="s2">except </span><span class="s1">TypeError:</span>
			<span class="s1">log.error(bytecode)</span>
			<span class="s2">raise</span>
		<span class="s1">self.setBytecode(bytecode)</span>

	<span class="s2">def </span><span class="s1">needsDecompilation(self):</span>
		<span class="s2">return </span><span class="s1">self.bytecode </span><span class="s2">is not None</span>

	<span class="s2">def </span><span class="s1">setProgram(self</span><span class="s2">, </span><span class="s1">program):</span>
		<span class="s1">self.program = program</span>
		<span class="s1">self.bytecode = </span><span class="s2">None</span>

	<span class="s2">def </span><span class="s1">setBytecode(self</span><span class="s2">, </span><span class="s1">bytecode):</span>
		<span class="s1">self.bytecode = bytecode</span>
		<span class="s1">self.program = </span><span class="s2">None</span>

	<span class="s2">def </span><span class="s1">getToken(self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">,</span>
			<span class="s1">len=len</span><span class="s2">, </span><span class="s1">byteord=byteord</span><span class="s2">, </span><span class="s1">isinstance=isinstance):</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s2">if </span><span class="s1">index &gt;= len(self.bytecode):</span>
				<span class="s2">return None, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span>
			<span class="s1">b0 = byteord(self.bytecode[index])</span>
			<span class="s1">index = index + </span><span class="s3">1</span>
			<span class="s1">handler = self.operandEncoding[b0]</span>
			<span class="s1">token</span><span class="s2">, </span><span class="s1">index = handler(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">self.bytecode</span><span class="s2">, </span><span class="s1">index)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s2">if </span><span class="s1">index &gt;= len(self.program):</span>
				<span class="s2">return None, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span>
			<span class="s1">token = self.program[index]</span>
			<span class="s1">index = index + </span><span class="s3">1</span>
		<span class="s1">isOperator = isinstance(token</span><span class="s2">, </span><span class="s1">str)</span>
		<span class="s2">return </span><span class="s1">token</span><span class="s2">, </span><span class="s1">isOperator</span><span class="s2">, </span><span class="s1">index</span>

	<span class="s2">def </span><span class="s1">getBytes(self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">nBytes):</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s1">newIndex = index + nBytes</span>
			<span class="s1">bytes = self.bytecode[index:newIndex]</span>
			<span class="s1">index = newIndex</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">bytes = self.program[index]</span>
			<span class="s1">index = index + </span><span class="s3">1</span>
		<span class="s2">assert </span><span class="s1">len(bytes) == nBytes</span>
		<span class="s2">return </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">index</span>

	<span class="s2">def </span><span class="s1">handle_operator(self</span><span class="s2">, </span><span class="s1">operator):</span>
		<span class="s2">return </span><span class="s1">operator</span>

	<span class="s2">def </span><span class="s1">toXML(self</span><span class="s2">, </span><span class="s1">xmlWriter</span><span class="s2">, </span><span class="s1">ttFont=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s2">from </span><span class="s1">fontTools.misc.textTools </span><span class="s2">import </span><span class="s1">num2binary</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is not None</span><span class="s1">:</span>
			<span class="s1">xmlWriter.dumphex(self.bytecode)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">index = </span><span class="s3">0</span>
			<span class="s1">args = []</span>
			<span class="s2">while True</span><span class="s1">:</span>
				<span class="s1">token</span><span class="s2">, </span><span class="s1">isOperator</span><span class="s2">, </span><span class="s1">index = self.getToken(index)</span>
				<span class="s2">if </span><span class="s1">token </span><span class="s2">is None</span><span class="s1">:</span>
					<span class="s2">break</span>
				<span class="s2">if </span><span class="s1">isOperator:</span>
					<span class="s2">if </span><span class="s1">token </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'hintmask'</span><span class="s2">, </span><span class="s4">'cntrmask'</span><span class="s1">):</span>
						<span class="s1">hintMask</span><span class="s2">, </span><span class="s1">isOperator</span><span class="s2">, </span><span class="s1">index = self.getToken(index)</span>
						<span class="s1">bits = []</span>
						<span class="s2">for </span><span class="s1">byte </span><span class="s2">in </span><span class="s1">hintMask:</span>
							<span class="s1">bits.append(num2binary(byteord(byte)</span><span class="s2">, </span><span class="s3">8</span><span class="s1">))</span>
						<span class="s1">hintMask = strjoin(bits)</span>
						<span class="s1">line = </span><span class="s4">' '</span><span class="s1">.join(args + [token</span><span class="s2">, </span><span class="s1">hintMask])</span>
					<span class="s2">else</span><span class="s1">:</span>
						<span class="s1">line = </span><span class="s4">' '</span><span class="s1">.join(args + [token])</span>
					<span class="s1">xmlWriter.write(line)</span>
					<span class="s1">xmlWriter.newline()</span>
					<span class="s1">args = []</span>
				<span class="s2">else</span><span class="s1">:</span>
					<span class="s2">if </span><span class="s1">isinstance(token</span><span class="s2">, </span><span class="s1">float):</span>
						<span class="s1">token = floatToFixedToStr(token</span><span class="s2">, </span><span class="s1">precisionBits=</span><span class="s3">16</span><span class="s1">)</span>
					<span class="s2">else</span><span class="s1">:</span>
						<span class="s1">token = str(token)</span>
					<span class="s1">args.append(token)</span>
			<span class="s2">if </span><span class="s1">args:</span>
				<span class="s5"># NOTE: only CFF2 charstrings/subrs can have numeric arguments on</span>
				<span class="s5"># the stack after the last operator. Compiling this would fail if</span>
				<span class="s5"># this is part of CFF 1.0 table.</span>
				<span class="s1">line = </span><span class="s4">' '</span><span class="s1">.join(args)</span>
				<span class="s1">xmlWriter.write(line)</span>

	<span class="s2">def </span><span class="s1">fromXML(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attrs</span><span class="s2">, </span><span class="s1">content):</span>
		<span class="s2">from </span><span class="s1">fontTools.misc.textTools </span><span class="s2">import </span><span class="s1">binary2num</span><span class="s2">, </span><span class="s1">readHex</span>
		<span class="s2">if </span><span class="s1">attrs.get(</span><span class="s4">&quot;raw&quot;</span><span class="s1">):</span>
			<span class="s1">self.setBytecode(readHex(content))</span>
			<span class="s2">return</span>
		<span class="s1">content = strjoin(content)</span>
		<span class="s1">content = content.split()</span>
		<span class="s1">program = []</span>
		<span class="s1">end = len(content)</span>
		<span class="s1">i = </span><span class="s3">0</span>
		<span class="s2">while </span><span class="s1">i &lt; end:</span>
			<span class="s1">token = content[i]</span>
			<span class="s1">i = i + </span><span class="s3">1</span>
			<span class="s2">try</span><span class="s1">:</span>
				<span class="s1">token = int(token)</span>
			<span class="s2">except </span><span class="s1">ValueError:</span>
				<span class="s2">try</span><span class="s1">:</span>
					<span class="s1">token = strToFixedToFloat(token</span><span class="s2">, </span><span class="s1">precisionBits=</span><span class="s3">16</span><span class="s1">)</span>
				<span class="s2">except </span><span class="s1">ValueError:</span>
					<span class="s1">program.append(token)</span>
					<span class="s2">if </span><span class="s1">token </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'hintmask'</span><span class="s2">, </span><span class="s4">'cntrmask'</span><span class="s1">):</span>
						<span class="s1">mask = content[i]</span>
						<span class="s1">maskBytes = </span><span class="s6">b&quot;&quot;</span>
						<span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(mask)</span><span class="s2">, </span><span class="s3">8</span><span class="s1">):</span>
							<span class="s1">maskBytes = maskBytes + bytechr(binary2num(mask[j:j+</span><span class="s3">8</span><span class="s1">]))</span>
						<span class="s1">program.append(maskBytes)</span>
						<span class="s1">i = i + </span><span class="s3">1</span>
				<span class="s2">else</span><span class="s1">:</span>
					<span class="s1">program.append(token)</span>
			<span class="s2">else</span><span class="s1">:</span>
				<span class="s1">program.append(token)</span>
		<span class="s1">self.setProgram(program)</span>

<span class="s2">class </span><span class="s1">T1CharString(T2CharString):</span>

	<span class="s1">operandEncoding = t1OperandEncoding</span>
	<span class="s1">operators</span><span class="s2">, </span><span class="s1">opcodes = buildOperatorDict(t1Operators)</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bytecode=</span><span class="s2">None, </span><span class="s1">program=</span><span class="s2">None, </span><span class="s1">subrs=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">super().__init__(bytecode</span><span class="s2">, </span><span class="s1">program)</span>
		<span class="s1">self.subrs = subrs</span>

	<span class="s2">def </span><span class="s1">getIntEncoder(self):</span>
		<span class="s2">return </span><span class="s1">encodeIntT1</span>

	<span class="s2">def </span><span class="s1">getFixedEncoder(self):</span>
		<span class="s2">def </span><span class="s1">encodeFixed(value):</span>
			<span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Type 1 charstrings don't support floating point operands&quot;</span><span class="s1">)</span>

	<span class="s2">def </span><span class="s1">decompile(self):</span>
		<span class="s2">if </span><span class="s1">self.bytecode </span><span class="s2">is None</span><span class="s1">:</span>
			<span class="s2">return</span>
		<span class="s1">program = []</span>
		<span class="s1">index = </span><span class="s3">0</span>
		<span class="s2">while True</span><span class="s1">:</span>
			<span class="s1">token</span><span class="s2">, </span><span class="s1">isOperator</span><span class="s2">, </span><span class="s1">index = self.getToken(index)</span>
			<span class="s2">if </span><span class="s1">token </span><span class="s2">is None</span><span class="s1">:</span>
				<span class="s2">break</span>
			<span class="s1">program.append(token)</span>
		<span class="s1">self.setProgram(program)</span>

	<span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">pen):</span>
		<span class="s1">extractor = T1OutlineExtractor(pen</span><span class="s2">, </span><span class="s1">self.subrs)</span>
		<span class="s1">extractor.execute(self)</span>
		<span class="s1">self.width = extractor.width</span>

<span class="s2">class </span><span class="s1">DictDecompiler(object):</span>

	<span class="s1">operandEncoding = cffDictOperandEncoding</span>

	<span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">strings</span><span class="s2">, </span><span class="s1">parent=</span><span class="s2">None</span><span class="s1">):</span>
		<span class="s1">self.stack = []</span>
		<span class="s1">self.strings = strings</span>
		<span class="s1">self.dict = {}</span>
		<span class="s1">self.parent = parent</span>

	<span class="s2">def </span><span class="s1">getDict(self):</span>
		<span class="s2">assert </span><span class="s1">len(self.stack) == </span><span class="s3">0</span><span class="s2">, </span><span class="s4">&quot;non-empty stack&quot;</span>
		<span class="s2">return </span><span class="s1">self.dict</span>

	<span class="s2">def </span><span class="s1">decompile(self</span><span class="s2">, </span><span class="s1">data):</span>
		<span class="s1">index = </span><span class="s3">0</span>
		<span class="s1">lenData = len(data)</span>
		<span class="s1">push = self.stack.append</span>
		<span class="s2">while </span><span class="s1">index &lt; lenData:</span>
			<span class="s1">b0 = byteord(data[index])</span>
			<span class="s1">index = index + </span><span class="s3">1</span>
			<span class="s1">handler = self.operandEncoding[b0]</span>
			<span class="s1">value</span><span class="s2">, </span><span class="s1">index = handler(self</span><span class="s2">, </span><span class="s1">b0</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">index)</span>
			<span class="s2">if </span><span class="s1">value </span><span class="s2">is not None</span><span class="s1">:</span>
				<span class="s1">push(value)</span>
	<span class="s2">def </span><span class="s1">pop(self):</span>
		<span class="s1">value = self.stack[-</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">del </span><span class="s1">self.stack[-</span><span class="s3">1</span><span class="s1">]</span>
		<span class="s2">return </span><span class="s1">value</span>

	<span class="s2">def </span><span class="s1">popall(self):</span>
		<span class="s1">args = self.stack[:]</span>
		<span class="s2">del </span><span class="s1">self.stack[:]</span>
		<span class="s2">return </span><span class="s1">args</span>

	<span class="s2">def </span><span class="s1">handle_operator(self</span><span class="s2">, </span><span class="s1">operator):</span>
		<span class="s1">operator</span><span class="s2">, </span><span class="s1">argType = operator</span>
		<span class="s2">if </span><span class="s1">isinstance(argType</span><span class="s2">, </span><span class="s1">tuple):</span>
			<span class="s1">value = ()</span>
			<span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(argType)-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">):</span>
				<span class="s1">arg = argType[i]</span>
				<span class="s1">arghandler = getattr(self</span><span class="s2">, </span><span class="s4">&quot;arg_&quot; </span><span class="s1">+ arg)</span>
				<span class="s1">value = (arghandler(operator)</span><span class="s2">,</span><span class="s1">) + value</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">arghandler = getattr(self</span><span class="s2">, </span><span class="s4">&quot;arg_&quot; </span><span class="s1">+ argType)</span>
			<span class="s1">value = arghandler(operator)</span>
		<span class="s2">if </span><span class="s1">operator == </span><span class="s4">&quot;blend&quot;</span><span class="s1">:</span>
			<span class="s1">self.stack.extend(value)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">self.dict[operator] = value</span>

	<span class="s2">def </span><span class="s1">arg_number(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s2">if </span><span class="s1">isinstance(self.stack[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">list):</span>
			<span class="s1">out = self.arg_blend_number(self.stack)</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">out = self.pop()</span>
		<span class="s2">return </span><span class="s1">out</span>

	<span class="s2">def </span><span class="s1">arg_blend_number(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s1">out = []</span>
		<span class="s1">blendArgs = self.pop()</span>
		<span class="s1">numMasters = len(blendArgs)</span>
		<span class="s1">out.append(blendArgs)</span>
		<span class="s1">out.append(</span><span class="s4">&quot;blend&quot;</span><span class="s1">)</span>
		<span class="s1">dummy = self.popall()</span>
		<span class="s2">return </span><span class="s1">blendArgs</span>

	<span class="s2">def </span><span class="s1">arg_SID(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s2">return </span><span class="s1">self.strings[self.pop()]</span>
	<span class="s2">def </span><span class="s1">arg_array(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s2">return </span><span class="s1">self.popall()</span>
	<span class="s2">def </span><span class="s1">arg_blendList(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s0">&quot;&quot;&quot; 
        There may be non-blend args at the top of the stack. We first calculate 
        where the blend args start in the stack. These are the last 
        numMasters*numBlends) +1 args. 
        The blend args starts with numMasters relative coordinate values, the  BlueValues in the list from the default master font. This is followed by 
        numBlends list of values. Each of  value in one of these lists is the 
        Variable Font delta for the matching region. 
 
        We re-arrange this to be a list of numMaster entries. Each entry starts with the corresponding default font relative value, and is followed by 
        the delta values. We then convert the default values, the first item in each entry, to an absolute value. 
        &quot;&quot;&quot;</span>
		<span class="s1">vsindex = self.dict.get(</span><span class="s4">'vsindex'</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
		<span class="s1">numMasters = self.parent.getNumRegions(vsindex) + </span><span class="s3">1 </span><span class="s5"># only a PrivateDict has blended ops.</span>
		<span class="s1">numBlends = self.pop()</span>
		<span class="s1">args = self.popall()</span>
		<span class="s1">numArgs = len(args)</span>
		<span class="s5"># The spec says that there should be no non-blended Blue Values,.</span>
		<span class="s2">assert</span><span class="s1">(numArgs == numMasters * numBlends)</span>
		<span class="s1">value = [</span><span class="s2">None</span><span class="s1">]*numBlends</span>
		<span class="s1">numDeltas = numMasters-</span><span class="s3">1</span>
		<span class="s1">i = </span><span class="s3">0</span>
		<span class="s1">prevVal = </span><span class="s3">0</span>
		<span class="s2">while </span><span class="s1">i &lt; numBlends:</span>
			<span class="s1">newVal = args[i] + prevVal</span>
			<span class="s1">prevVal = newVal</span>
			<span class="s1">masterOffset = numBlends + (i* numDeltas)</span>
			<span class="s1">blendList = [newVal] + args[masterOffset:masterOffset+numDeltas]</span>
			<span class="s1">value[i] = blendList</span>
			<span class="s1">i += </span><span class="s3">1</span>
		<span class="s2">return </span><span class="s1">value</span>

	<span class="s2">def </span><span class="s1">arg_delta(self</span><span class="s2">, </span><span class="s1">name):</span>
		<span class="s1">valueList = self.popall()</span>
		<span class="s1">out = []</span>
		<span class="s2">if </span><span class="s1">valueList </span><span class="s2">and </span><span class="s1">isinstance(valueList[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">list):</span>
			<span class="s5"># arg_blendList() has already converted these to absolute values.</span>
			<span class="s1">out = valueList</span>
		<span class="s2">else</span><span class="s1">:</span>
			<span class="s1">current = </span><span class="s3">0</span>
			<span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">valueList:</span>
				<span class="s1">current = current + v</span>
				<span class="s1">out.append(current)</span>
		<span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">calcSubrBias(subrs):</span>
	<span class="s1">nSubrs = len(subrs)</span>
	<span class="s2">if </span><span class="s1">nSubrs &lt; </span><span class="s3">1240</span><span class="s1">:</span>
		<span class="s1">bias = </span><span class="s3">107</span>
	<span class="s2">elif </span><span class="s1">nSubrs &lt; </span><span class="s3">33900</span><span class="s1">:</span>
		<span class="s1">bias = </span><span class="s3">1131</span>
	<span class="s2">else</span><span class="s1">:</span>
		<span class="s1">bias = </span><span class="s3">32768</span>
	<span class="s2">return </span><span class="s1">bias</span>
</pre>
</body>
</html>