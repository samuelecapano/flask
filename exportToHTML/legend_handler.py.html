<html>
<head>
<title>legend_handler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
legend_handler.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Default legend handlers. 
 
.. important:: 
 
    This is a low-level legend API, which most end users do not need. 
 
    We recommend that you are familiar with the :doc:`legend guide 
    &lt;/tutorials/intermediate/legend_guide&gt;` before reading this documentation. 
 
Legend handlers are expected to be a callable object with a following 
signature:: 
 
    legend_handler(legend, orig_handle, fontsize, handlebox) 
 
Where *legend* is the legend itself, *orig_handle* is the original 
plot, *fontsize* is the fontsize in pixels, and *handlebox* is an 
`.OffsetBox` instance. Within the call, you should create relevant 
artists (using relevant properties from the *legend* and/or 
*orig_handle*) and add them into the *handlebox*. The artists need to 
be scaled according to the *fontsize* (note that the size is in pixels, 
i.e., this is dpi-scaled value). 
 
This module includes definition of several legend handler classes 
derived from the base class (HandlerBase) with the following method:: 
 
    def legend_artist(self, legend, orig_handle, fontsize, handlebox) 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">cycle</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span>
<span class="s2">from </span><span class="s1">matplotlib.lines </span><span class="s2">import </span><span class="s1">Line2D</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">Rectangle</span>
<span class="s2">import </span><span class="s1">matplotlib.collections </span><span class="s2">as </span><span class="s1">mcoll</span>


<span class="s2">def </span><span class="s1">update_from_first_child(tgt</span><span class="s2">, </span><span class="s1">src):</span>
    <span class="s1">first_child = next(iter(src.get_children())</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">first_child </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">tgt.update_from(first_child)</span>


<span class="s2">class </span><span class="s1">HandlerBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    A base class for default legend handlers. 
 
    The derived classes are meant to override *create_artists* method, which 
    has the following signature:: 
 
      def create_artists(self, legend, orig_handle, 
                         xdescent, ydescent, width, height, fontsize, 
                         trans): 
 
    The overridden method needs to create artists of the given 
    transform that fits in the given dimension (xdescent, ydescent, 
    width, height) that are scaled by fontsize if necessary. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xpad=</span><span class="s3">0.</span><span class="s2">, </span><span class="s1">ypad=</span><span class="s3">0.</span><span class="s2">, </span><span class="s1">update_func=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
 
        xpad : float, optional 
            Padding in x-direction. 
        ypad : float, optional 
            Padding in y-direction. 
        update_func : callable, optional 
            Function for updating the legend handler properties from another 
            legend handler, used by `~HandlerBase.update_prop`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._xpad</span><span class="s2">, </span><span class="s1">self._ypad = xpad</span><span class="s2">, </span><span class="s1">ypad</span>
        <span class="s1">self._update_prop_func = update_func</span>

    <span class="s2">def </span><span class="s1">_update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle):</span>
        <span class="s2">if </span><span class="s1">self._update_prop_func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._default_update_prop(legend_handle</span><span class="s2">, </span><span class="s1">orig_handle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._update_prop_func(legend_handle</span><span class="s2">, </span><span class="s1">orig_handle)</span>

    <span class="s2">def </span><span class="s1">_default_update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle):</span>
        <span class="s1">legend_handle.update_from(orig_handle)</span>

    <span class="s2">def </span><span class="s1">update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend):</span>

        <span class="s1">self._update_prop(legend_handle</span><span class="s2">, </span><span class="s1">orig_handle)</span>

        <span class="s1">legend._set_artist_props(legend_handle)</span>
        <span class="s1">legend_handle.set_clip_box(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">legend_handle.set_clip_path(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">adjust_drawing_area(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                            <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                            <span class="s1">):</span>
        <span class="s1">xdescent = xdescent - self._xpad * fontsize</span>
        <span class="s1">ydescent = ydescent - self._ypad * fontsize</span>
        <span class="s1">width = width - self._xpad * fontsize</span>
        <span class="s1">height = height - self._ypad * fontsize</span>
        <span class="s2">return </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span>

    <span class="s2">def </span><span class="s1">legend_artist(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                      <span class="s1">fontsize</span><span class="s2">, </span><span class="s1">handlebox):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the artist that this HandlerBase generates for the given 
        original artist/handle. 
 
        Parameters 
        ---------- 
        legend : `~matplotlib.legend.Legend` 
            The legend for which these legend artists are being created. 
        orig_handle : :class:`matplotlib.artist.Artist` or similar 
            The object for which these legend artists are being created. 
        fontsize : int 
            The fontsize in pixels. The artists being created should 
            be scaled according to the given fontsize. 
        handlebox : `matplotlib.offsetbox.OffsetBox` 
            The box which has been created to hold this legend entry's 
            artists. Artists created in the `legend_artist` method must 
            be added to this handlebox inside this method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height = self.adjust_drawing_area(</span>
                 <span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                 <span class="s1">handlebox.xdescent</span><span class="s2">, </span><span class="s1">handlebox.ydescent</span><span class="s2">,</span>
                 <span class="s1">handlebox.width</span><span class="s2">, </span><span class="s1">handlebox.height</span><span class="s2">,</span>
                 <span class="s1">fontsize)</span>
        <span class="s1">artists = self.create_artists(legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                                      <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">,</span>
                                      <span class="s1">fontsize</span><span class="s2">, </span><span class="s1">handlebox.get_transform())</span>

        <span class="s4"># create_artists will return a list of artists.</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s1">handlebox.add_artist(a)</span>

        <span class="s4"># we only return the first artist</span>
        <span class="s2">return </span><span class="s1">artists[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the legend artists generated. 
 
        Parameters 
        ---------- 
        legend : `~matplotlib.legend.Legend` 
            The legend for which these legend artists are being created. 
        orig_handle : `~matplotlib.artist.Artist` or similar 
            The object for which these legend artists are being created. 
        xdescent, ydescent, width, height : int 
            The rectangle (*xdescent*, *ydescent*, *width*, *height*) that the 
            legend artists being created should fit within. 
        fontsize : int 
            The fontsize in pixels. The legend artists being created should 
            be scaled according to the given fontsize. 
        trans :  `~matplotlib.transforms.Transform` 
            The transform that is applied to the legend artists being created. 
            Typically from unit coordinates in the handler box to screen 
            coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">HandlerNpoints(HandlerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A legend handler that shows *numpoints* points in the legend entry. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">marker_pad=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">numpoints=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        marker_pad : float 
            Padding between points in legend entry. 
        numpoints : int 
            Number of points to show in legend entry. 
        **kwargs 
            Keyword arguments forwarded to `.HandlerBase`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s1">self._numpoints = numpoints</span>
        <span class="s1">self._marker_pad = marker_pad</span>

    <span class="s2">def </span><span class="s1">get_numpoints(self</span><span class="s2">, </span><span class="s1">legend):</span>
        <span class="s2">if </span><span class="s1">self._numpoints </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">legend.numpoints</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._numpoints</span>

    <span class="s2">def </span><span class="s1">get_xdata(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s1">numpoints = self.get_numpoints(legend)</span>
        <span class="s2">if </span><span class="s1">numpoints &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s4"># we put some pad here to compensate the size of the marker</span>
            <span class="s1">pad = self._marker_pad * fontsize</span>
            <span class="s1">xdata = np.linspace(-xdescent + pad</span><span class="s2">,</span>
                                <span class="s1">-xdescent + width - pad</span><span class="s2">,</span>
                                <span class="s1">numpoints)</span>
            <span class="s1">xdata_marker = xdata</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xdata = [-xdescent</span><span class="s2">, </span><span class="s1">-xdescent + width]</span>
            <span class="s1">xdata_marker = [-xdescent + </span><span class="s3">0.5 </span><span class="s1">* width]</span>
        <span class="s2">return </span><span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker</span>


<span class="s2">class </span><span class="s1">HandlerNpointsYoffsets(HandlerNpoints):</span>
    <span class="s0">&quot;&quot;&quot; 
    A legend handler that shows *numpoints* in the legend, and allows them to 
    be individually offset in the y-direction. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">numpoints=</span><span class="s2">None, </span><span class="s1">yoffsets=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        numpoints : int 
            Number of points to show in legend entry. 
        yoffsets : array of floats 
            Length *numpoints* list of y offsets for each point in 
            legend entry. 
        **kwargs 
            Keyword arguments forwarded to `.HandlerNpoints`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(numpoints=numpoints</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._yoffsets = yoffsets</span>

    <span class="s2">def </span><span class="s1">get_ydata(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s2">if </span><span class="s1">self._yoffsets </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ydata = height * legend._scatteryoffsets</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ydata = height * np.asarray(self._yoffsets)</span>

        <span class="s2">return </span><span class="s1">ydata</span>


<span class="s2">class </span><span class="s1">HandlerLine2DCompound(HandlerNpoints):</span>
    <span class="s0">&quot;&quot;&quot; 
    Original handler for `.Line2D` instances, that relies on combining 
    a line-only with a marker-only artist.  May be deprecated in the future. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">ydata = np.full_like(xdata</span><span class="s2">, </span><span class="s1">((height - ydescent) / </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">legline = Line2D(xdata</span><span class="s2">, </span><span class="s1">ydata)</span>

        <span class="s1">self.update_prop(legline</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">legline.set_drawstyle(</span><span class="s5">'default'</span><span class="s1">)</span>
        <span class="s1">legline.set_marker(</span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">legline_marker = Line2D(xdata_marker</span><span class="s2">, </span><span class="s1">ydata[:len(xdata_marker)])</span>
        <span class="s1">self.update_prop(legline_marker</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">legline_marker.set_linestyle(</span><span class="s5">'None'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">legend.markerscale != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">newsz = legline_marker.get_markersize() * legend.markerscale</span>
            <span class="s1">legline_marker.set_markersize(newsz)</span>
        <span class="s4"># we don't want to add this to the return list because</span>
        <span class="s4"># the texts and handles are assumed to be in one-to-one</span>
        <span class="s4"># correspondence.</span>
        <span class="s1">legline._legmarker = legline_marker</span>

        <span class="s1">legline.set_transform(trans)</span>
        <span class="s1">legline_marker.set_transform(trans)</span>

        <span class="s2">return </span><span class="s1">[legline</span><span class="s2">, </span><span class="s1">legline_marker]</span>


<span class="s2">class </span><span class="s1">HandlerLine2D(HandlerNpoints):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for `.Line2D` instances. 
 
    See Also 
    -------- 
    HandlerLine2DCompound : An earlier handler implementation, which used one 
                            artist for the line and another for the marker(s). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">markevery = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.get_numpoints(legend) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s4"># Special case: one wants a single marker in the center</span>
            <span class="s4"># and a line that extends on both sides. One will use a</span>
            <span class="s4"># 3 points line, but only mark the #1 (i.e. middle) point.</span>
            <span class="s1">xdata = np.linspace(xdata[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">xdata[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">markevery = [</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s1">ydata = np.full_like(xdata</span><span class="s2">, </span><span class="s1">(height - ydescent) / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">legline = Line2D(xdata</span><span class="s2">, </span><span class="s1">ydata</span><span class="s2">, </span><span class="s1">markevery=markevery)</span>

        <span class="s1">self.update_prop(legline</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>

        <span class="s2">if </span><span class="s1">legend.markerscale != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">newsz = legline.get_markersize() * legend.markerscale</span>
            <span class="s1">legline.set_markersize(newsz)</span>

        <span class="s1">legline.set_transform(trans)</span>

        <span class="s2">return </span><span class="s1">[legline]</span>


<span class="s2">class </span><span class="s1">HandlerPatch(HandlerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for `.Patch` instances. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">patch_func=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        patch_func : callable, optional 
            The function that creates the legend key artist. 
            *patch_func* should have the signature:: 
 
                def patch_func(legend=legend, orig_handle=orig_handle, 
                               xdescent=xdescent, ydescent=ydescent, 
                               width=width, height=height, fontsize=fontsize) 
 
            Subsequently, the created artist will have its ``update_prop`` 
            method called and the appropriate transform will be applied. 
 
        **kwargs 
            Keyword arguments forwarded to `.HandlerBase`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._patch_func = patch_func</span>

    <span class="s2">def </span><span class="s1">_create_patch(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                      <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s2">if </span><span class="s1">self._patch_func </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">p = Rectangle(xy=(-xdescent</span><span class="s2">, </span><span class="s1">-ydescent)</span><span class="s2">,</span>
                          <span class="s1">width=width</span><span class="s2">, </span><span class="s1">height=height)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">p = self._patch_func(legend=legend</span><span class="s2">, </span><span class="s1">orig_handle=orig_handle</span><span class="s2">,</span>
                                 <span class="s1">xdescent=xdescent</span><span class="s2">, </span><span class="s1">ydescent=ydescent</span><span class="s2">,</span>
                                 <span class="s1">width=width</span><span class="s2">, </span><span class="s1">height=height</span><span class="s2">, </span><span class="s1">fontsize=fontsize)</span>
        <span class="s2">return </span><span class="s1">p</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">p = self._create_patch(legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                               <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>
        <span class="s1">self.update_prop(p</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">p.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">[p]</span>


<span class="s2">class </span><span class="s1">HandlerStepPatch(HandlerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for `~.matplotlib.patches.StepPatch` instances. 
    &quot;&quot;&quot;</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_create_patch(orig_handle</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s2">return </span><span class="s1">Rectangle(xy=(-xdescent</span><span class="s2">, </span><span class="s1">-ydescent)</span><span class="s2">, </span><span class="s1">width=width</span><span class="s2">,</span>
                         <span class="s1">height=height</span><span class="s2">, </span><span class="s1">color=orig_handle.get_facecolor())</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_create_line(orig_handle</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s4"># Unfilled StepPatch should show as a line</span>
        <span class="s1">legline = Line2D([</span><span class="s3">0</span><span class="s2">, </span><span class="s1">width]</span><span class="s2">, </span><span class="s1">[height/</span><span class="s3">2</span><span class="s2">, </span><span class="s1">height/</span><span class="s3">2</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">color=orig_handle.get_edgecolor()</span><span class="s2">,</span>
                         <span class="s1">linestyle=orig_handle.get_linestyle()</span><span class="s2">,</span>
                         <span class="s1">linewidth=orig_handle.get_linewidth()</span><span class="s2">,</span>
                         <span class="s1">)</span>

        <span class="s4"># Overwrite manually because patch and line properties don't mix</span>
        <span class="s1">legline.set_drawstyle(</span><span class="s5">'default'</span><span class="s1">)</span>
        <span class="s1">legline.set_marker(</span><span class="s5">&quot;&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">legline</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">orig_handle.get_fill() </span><span class="s2">or </span><span class="s1">(orig_handle.get_hatch() </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">p = self._create_patch(orig_handle</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">,</span>
                                   <span class="s1">height)</span>
            <span class="s1">self.update_prop(p</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">p = self._create_line(orig_handle</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">p.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">[p]</span>


<span class="s2">class </span><span class="s1">HandlerLineCollection(HandlerLine2D):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for `.LineCollection` instances. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">get_numpoints(self</span><span class="s2">, </span><span class="s1">legend):</span>
        <span class="s2">if </span><span class="s1">self._numpoints </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">legend.scatterpoints</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._numpoints</span>

    <span class="s2">def </span><span class="s1">_default_update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle):</span>
        <span class="s1">lw = orig_handle.get_linewidths()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">dashes = orig_handle._us_linestyles[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">color = orig_handle.get_colors()[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">legend_handle.set_color(color)</span>
        <span class="s1">legend_handle.set_linestyle(dashes)</span>
        <span class="s1">legend_handle.set_linewidth(lw)</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>
        <span class="s1">ydata = np.full_like(xdata</span><span class="s2">, </span><span class="s1">(height - ydescent) / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">legline = Line2D(xdata</span><span class="s2">, </span><span class="s1">ydata)</span>

        <span class="s1">self.update_prop(legline</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">legline.set_transform(trans)</span>

        <span class="s2">return </span><span class="s1">[legline]</span>


<span class="s2">class </span><span class="s1">HandlerRegularPolyCollection(HandlerNpointsYoffsets):</span>
    <span class="s0">r&quot;&quot;&quot;Handler for `.RegularPolyCollection`\s.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">yoffsets=</span><span class="s2">None, </span><span class="s1">sizes=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(yoffsets=yoffsets</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self._sizes = sizes</span>

    <span class="s2">def </span><span class="s1">get_numpoints(self</span><span class="s2">, </span><span class="s1">legend):</span>
        <span class="s2">if </span><span class="s1">self._numpoints </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">legend.scatterpoints</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._numpoints</span>

    <span class="s2">def </span><span class="s1">get_sizes(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                  <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s2">if </span><span class="s1">self._sizes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">handle_sizes = orig_handle.get_sizes()</span>
            <span class="s2">if not </span><span class="s1">len(handle_sizes):</span>
                <span class="s1">handle_sizes = [</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">size_max = max(handle_sizes) * legend.markerscale ** </span><span class="s3">2</span>
            <span class="s1">size_min = min(handle_sizes) * legend.markerscale ** </span><span class="s3">2</span>

            <span class="s1">numpoints = self.get_numpoints(legend)</span>
            <span class="s2">if </span><span class="s1">numpoints &lt; </span><span class="s3">4</span><span class="s1">:</span>
                <span class="s1">sizes = [</span><span class="s3">.5 </span><span class="s1">* (size_max + size_min)</span><span class="s2">, </span><span class="s1">size_max</span><span class="s2">,</span>
                         <span class="s1">size_min][:numpoints]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">rng = (size_max - size_min)</span>
                <span class="s1">sizes = rng * np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">numpoints) + size_min</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sizes = self._sizes</span>

        <span class="s2">return </span><span class="s1">sizes</span>

    <span class="s2">def </span><span class="s1">update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend):</span>

        <span class="s1">self._update_prop(legend_handle</span><span class="s2">, </span><span class="s1">orig_handle)</span>

        <span class="s1">legend_handle.set_figure(legend.figure)</span>
        <span class="s4"># legend._set_artist_props(legend_handle)</span>
        <span class="s1">legend_handle.set_clip_box(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">legend_handle.set_clip_path(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s5">&quot;3.6&quot;</span><span class="s2">, </span><span class="s5">&quot;transOffset&quot;</span><span class="s2">, </span><span class="s5">&quot;offset_transform&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">create_collection(self</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_transform):</span>
        <span class="s2">return </span><span class="s1">type(orig_handle)(</span>
            <span class="s1">orig_handle.get_numsides()</span><span class="s2">,</span>
            <span class="s1">rotation=orig_handle.get_rotation()</span><span class="s2">, </span><span class="s1">sizes=sizes</span><span class="s2">,</span>
            <span class="s1">offsets=offsets</span><span class="s2">, </span><span class="s1">offset_transform=offset_transform</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">ydata = self.get_ydata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                               <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">sizes = self.get_sizes(legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                               <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">p = self.create_collection(</span>
            <span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">,</span>
            <span class="s1">offsets=list(zip(xdata_marker</span><span class="s2">, </span><span class="s1">ydata))</span><span class="s2">, </span><span class="s1">offset_transform=trans)</span>

        <span class="s1">self.update_prop(p</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">p.set_offset_transform(trans)</span>
        <span class="s2">return </span><span class="s1">[p]</span>


<span class="s2">class </span><span class="s1">HandlerPathCollection(HandlerRegularPolyCollection):</span>
    <span class="s0">r&quot;&quot;&quot;Handler for `.PathCollection`\s, which are used by `~.Axes.scatter`.&quot;&quot;&quot;</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s5">&quot;3.6&quot;</span><span class="s2">, </span><span class="s5">&quot;transOffset&quot;</span><span class="s2">, </span><span class="s5">&quot;offset_transform&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">create_collection(self</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_transform):</span>
        <span class="s2">return </span><span class="s1">type(orig_handle)(</span>
            <span class="s1">[orig_handle.get_paths()[</span><span class="s3">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">sizes=sizes</span><span class="s2">,</span>
            <span class="s1">offsets=offsets</span><span class="s2">, </span><span class="s1">offset_transform=offset_transform</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">HandlerCircleCollection(HandlerRegularPolyCollection):</span>
    <span class="s0">r&quot;&quot;&quot;Handler for `.CircleCollection`\s.&quot;&quot;&quot;</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s5">&quot;3.6&quot;</span><span class="s2">, </span><span class="s5">&quot;transOffset&quot;</span><span class="s2">, </span><span class="s5">&quot;offset_transform&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">create_collection(self</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">sizes</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_transform):</span>
        <span class="s2">return </span><span class="s1">type(orig_handle)(</span>
            <span class="s1">sizes</span><span class="s2">, </span><span class="s1">offsets=offsets</span><span class="s2">, </span><span class="s1">offset_transform=offset_transform)</span>


<span class="s2">class </span><span class="s1">HandlerErrorbar(HandlerLine2D):</span>
    <span class="s0">&quot;&quot;&quot;Handler for Errorbars.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xerr_size=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">yerr_size=</span><span class="s2">None,</span>
                 <span class="s1">marker_pad=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">numpoints=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>

        <span class="s1">self._xerr_size = xerr_size</span>
        <span class="s1">self._yerr_size = yerr_size</span>

        <span class="s1">super().__init__(marker_pad=marker_pad</span><span class="s2">, </span><span class="s1">numpoints=numpoints</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">get_err_size(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                     <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s1">xerr_size = self._xerr_size * fontsize</span>

        <span class="s2">if </span><span class="s1">self._yerr_size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">yerr_size = xerr_size</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">yerr_size = self._yerr_size * fontsize</span>

        <span class="s2">return </span><span class="s1">xerr_size</span><span class="s2">, </span><span class="s1">yerr_size</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">plotlines</span><span class="s2">, </span><span class="s1">caplines</span><span class="s2">, </span><span class="s1">barlinecols = orig_handle</span>

        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">ydata = np.full_like(xdata</span><span class="s2">, </span><span class="s1">(height - ydescent) / </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">legline = Line2D(xdata</span><span class="s2">, </span><span class="s1">ydata)</span>

        <span class="s1">xdata_marker = np.asarray(xdata_marker)</span>
        <span class="s1">ydata_marker = np.asarray(ydata[:len(xdata_marker)])</span>

        <span class="s1">xerr_size</span><span class="s2">, </span><span class="s1">yerr_size = self.get_err_size(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                                 <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">legline_marker = Line2D(xdata_marker</span><span class="s2">, </span><span class="s1">ydata_marker)</span>

        <span class="s4"># when plotlines are None (only errorbars are drawn), we just</span>
        <span class="s4"># make legline invisible.</span>
        <span class="s2">if </span><span class="s1">plotlines </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">legline.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">legline_marker.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.update_prop(legline</span><span class="s2">, </span><span class="s1">plotlines</span><span class="s2">, </span><span class="s1">legend)</span>

            <span class="s1">legline.set_drawstyle(</span><span class="s5">'default'</span><span class="s1">)</span>
            <span class="s1">legline.set_marker(</span><span class="s5">'none'</span><span class="s1">)</span>

            <span class="s1">self.update_prop(legline_marker</span><span class="s2">, </span><span class="s1">plotlines</span><span class="s2">, </span><span class="s1">legend)</span>
            <span class="s1">legline_marker.set_linestyle(</span><span class="s5">'None'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">legend.markerscale != </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">newsz = legline_marker.get_markersize() * legend.markerscale</span>
                <span class="s1">legline_marker.set_markersize(newsz)</span>

        <span class="s1">handle_barlinecols = []</span>
        <span class="s1">handle_caplines = []</span>

        <span class="s2">if </span><span class="s1">orig_handle.has_xerr:</span>
            <span class="s1">verts = [((x - xerr_size</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">(x + xerr_size</span><span class="s2">, </span><span class="s1">y))</span>
                     <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(xdata_marker</span><span class="s2">, </span><span class="s1">ydata_marker)]</span>
            <span class="s1">coll = mcoll.LineCollection(verts)</span>
            <span class="s1">self.update_prop(coll</span><span class="s2">, </span><span class="s1">barlinecols[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
            <span class="s1">handle_barlinecols.append(coll)</span>

            <span class="s2">if </span><span class="s1">caplines:</span>
                <span class="s1">capline_left = Line2D(xdata_marker - xerr_size</span><span class="s2">, </span><span class="s1">ydata_marker)</span>
                <span class="s1">capline_right = Line2D(xdata_marker + xerr_size</span><span class="s2">, </span><span class="s1">ydata_marker)</span>
                <span class="s1">self.update_prop(capline_left</span><span class="s2">, </span><span class="s1">caplines[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
                <span class="s1">self.update_prop(capline_right</span><span class="s2">, </span><span class="s1">caplines[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
                <span class="s1">capline_left.set_marker(</span><span class="s5">&quot;|&quot;</span><span class="s1">)</span>
                <span class="s1">capline_right.set_marker(</span><span class="s5">&quot;|&quot;</span><span class="s1">)</span>

                <span class="s1">handle_caplines.append(capline_left)</span>
                <span class="s1">handle_caplines.append(capline_right)</span>

        <span class="s2">if </span><span class="s1">orig_handle.has_yerr:</span>
            <span class="s1">verts = [((x</span><span class="s2">, </span><span class="s1">y - yerr_size)</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">y + yerr_size))</span>
                     <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(xdata_marker</span><span class="s2">, </span><span class="s1">ydata_marker)]</span>
            <span class="s1">coll = mcoll.LineCollection(verts)</span>
            <span class="s1">self.update_prop(coll</span><span class="s2">, </span><span class="s1">barlinecols[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
            <span class="s1">handle_barlinecols.append(coll)</span>

            <span class="s2">if </span><span class="s1">caplines:</span>
                <span class="s1">capline_left = Line2D(xdata_marker</span><span class="s2">, </span><span class="s1">ydata_marker - yerr_size)</span>
                <span class="s1">capline_right = Line2D(xdata_marker</span><span class="s2">, </span><span class="s1">ydata_marker + yerr_size)</span>
                <span class="s1">self.update_prop(capline_left</span><span class="s2">, </span><span class="s1">caplines[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
                <span class="s1">self.update_prop(capline_right</span><span class="s2">, </span><span class="s1">caplines[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">legend)</span>
                <span class="s1">capline_left.set_marker(</span><span class="s5">&quot;_&quot;</span><span class="s1">)</span>
                <span class="s1">capline_right.set_marker(</span><span class="s5">&quot;_&quot;</span><span class="s1">)</span>

                <span class="s1">handle_caplines.append(capline_left)</span>
                <span class="s1">handle_caplines.append(capline_right)</span>

        <span class="s1">artists = [</span>
            <span class="s1">*handle_barlinecols</span><span class="s2">, </span><span class="s1">*handle_caplines</span><span class="s2">, </span><span class="s1">legline</span><span class="s2">, </span><span class="s1">legline_marker</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s1">artist.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">artists</span>


<span class="s2">class </span><span class="s1">HandlerStem(HandlerNpointsYoffsets):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for plots produced by `~.Axes.stem`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">marker_pad=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">numpoints=</span><span class="s2">None,</span>
                 <span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">yoffsets=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        marker_pad : float, default: 0.3 
            Padding between points in legend entry. 
        numpoints : int, optional 
            Number of points to show in legend entry. 
        bottom : float, optional 
 
        yoffsets : array of floats, optional 
            Length *numpoints* list of y offsets for each point in 
            legend entry. 
        **kwargs 
            Keyword arguments forwarded to `.HandlerNpointsYoffsets`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(marker_pad=marker_pad</span><span class="s2">, </span><span class="s1">numpoints=numpoints</span><span class="s2">,</span>
                         <span class="s1">yoffsets=yoffsets</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._bottom = bottom</span>

    <span class="s2">def </span><span class="s1">get_ydata(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s2">if </span><span class="s1">self._yoffsets </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ydata = height * (</span><span class="s3">0.5 </span><span class="s1">* legend._scatteryoffsets + </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ydata = height * np.asarray(self._yoffsets)</span>

        <span class="s2">return </span><span class="s1">ydata</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">markerline</span><span class="s2">, </span><span class="s1">stemlines</span><span class="s2">, </span><span class="s1">baseline = orig_handle</span>
        <span class="s4"># Check to see if the stemcontainer is storing lines as a list or a</span>
        <span class="s4"># LineCollection. Eventually using a list will be removed, and this</span>
        <span class="s4"># logic can also be removed.</span>
        <span class="s1">using_linecoll = isinstance(stemlines</span><span class="s2">, </span><span class="s1">mcoll.LineCollection)</span>

        <span class="s1">xdata</span><span class="s2">, </span><span class="s1">xdata_marker = self.get_xdata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                                             <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s1">ydata = self.get_ydata(legend</span><span class="s2">, </span><span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">,</span>
                               <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize)</span>

        <span class="s2">if </span><span class="s1">self._bottom </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bottom = </span><span class="s3">0.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bottom = self._bottom</span>

        <span class="s1">leg_markerline = Line2D(xdata_marker</span><span class="s2">, </span><span class="s1">ydata[:len(xdata_marker)])</span>
        <span class="s1">self.update_prop(leg_markerline</span><span class="s2">, </span><span class="s1">markerline</span><span class="s2">, </span><span class="s1">legend)</span>

        <span class="s1">leg_stemlines = [Line2D([x</span><span class="s2">, </span><span class="s1">x]</span><span class="s2">, </span><span class="s1">[bottom</span><span class="s2">, </span><span class="s1">y])</span>
                         <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(xdata_marker</span><span class="s2">, </span><span class="s1">ydata)]</span>

        <span class="s2">if </span><span class="s1">using_linecoll:</span>
            <span class="s4"># change the function used by update_prop() from the default</span>
            <span class="s4"># to one that handles LineCollection</span>
            <span class="s2">with </span><span class="s1">cbook._setattr_cm(</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">_update_prop_func=self._copy_collection_props):</span>
                <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">leg_stemlines:</span>
                    <span class="s1">self.update_prop(line</span><span class="s2">, </span><span class="s1">stemlines</span><span class="s2">, </span><span class="s1">legend)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">lm</span><span class="s2">, </span><span class="s1">m </span><span class="s2">in </span><span class="s1">zip(leg_stemlines</span><span class="s2">, </span><span class="s1">stemlines):</span>
                <span class="s1">self.update_prop(lm</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">legend)</span>

        <span class="s1">leg_baseline = Line2D([np.min(xdata)</span><span class="s2">, </span><span class="s1">np.max(xdata)]</span><span class="s2">,</span>
                              <span class="s1">[bottom</span><span class="s2">, </span><span class="s1">bottom])</span>
        <span class="s1">self.update_prop(leg_baseline</span><span class="s2">, </span><span class="s1">baseline</span><span class="s2">, </span><span class="s1">legend)</span>

        <span class="s1">artists = [*leg_stemlines</span><span class="s2">, </span><span class="s1">leg_baseline</span><span class="s2">, </span><span class="s1">leg_markerline]</span>
        <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s1">artist.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">artists</span>

    <span class="s2">def </span><span class="s1">_copy_collection_props(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy properties from the `.LineCollection` *orig_handle* to the 
        `.Line2D` *legend_handle*. 
        &quot;&quot;&quot;</span>
        <span class="s1">legend_handle.set_color(orig_handle.get_color()[</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">legend_handle.set_linestyle(orig_handle.get_linestyle()[</span><span class="s3">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">HandlerTuple(HandlerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for Tuple. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ndivide=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">pad=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        ndivide : int, default: 1 
            The number of sections to divide the legend area into.  If None, 
            use the length of the input tuple. 
        pad : float, default: :rc:`legend.borderpad` 
            Padding in units of fraction of font size. 
        **kwargs 
            Keyword arguments forwarded to `.HandlerBase`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._ndivide = ndivide</span>
        <span class="s1">self._pad = pad</span>
        <span class="s1">super().__init__(**kwargs)</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                       <span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">handler_map = legend.get_legend_handler_map()</span>

        <span class="s2">if </span><span class="s1">self._ndivide </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ndivide = len(orig_handle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ndivide = self._ndivide</span>

        <span class="s2">if </span><span class="s1">self._pad </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">pad = legend.borderpad * fontsize</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pad = self._pad * fontsize</span>

        <span class="s2">if </span><span class="s1">ndivide &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">width = (width - pad * (ndivide - </span><span class="s3">1</span><span class="s1">)) / ndivide</span>

        <span class="s1">xds_cycle = cycle(xdescent - (width + pad) * np.arange(ndivide))</span>

        <span class="s1">a_list = []</span>
        <span class="s2">for </span><span class="s1">handle1 </span><span class="s2">in </span><span class="s1">orig_handle:</span>
            <span class="s1">handler = legend.get_legend_handler(handler_map</span><span class="s2">, </span><span class="s1">handle1)</span>
            <span class="s1">_a_list = handler.create_artists(</span>
                <span class="s1">legend</span><span class="s2">, </span><span class="s1">handle1</span><span class="s2">,</span>
                <span class="s1">next(xds_cycle)</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">trans)</span>
            <span class="s1">a_list.extend(_a_list)</span>

        <span class="s2">return </span><span class="s1">a_list</span>


<span class="s2">class </span><span class="s1">HandlerPolyCollection(HandlerBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Handler for `.PolyCollection` used in `~.Axes.fill_between` and 
    `~.Axes.stackplot`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">_update_prop(self</span><span class="s2">, </span><span class="s1">legend_handle</span><span class="s2">, </span><span class="s1">orig_handle):</span>
        <span class="s2">def </span><span class="s1">first_color(colors):</span>
            <span class="s2">if </span><span class="s1">colors.size == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">tuple(colors[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">get_first(prop_array):</span>
            <span class="s2">if </span><span class="s1">len(prop_array):</span>
                <span class="s2">return </span><span class="s1">prop_array[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return None</span>

        <span class="s4"># orig_handle is a PolyCollection and legend_handle is a Patch.</span>
        <span class="s4"># Directly set Patch color attributes (must be RGBA tuples).</span>
        <span class="s1">legend_handle._facecolor = first_color(orig_handle.get_facecolor())</span>
        <span class="s1">legend_handle._edgecolor = first_color(orig_handle.get_edgecolor())</span>
        <span class="s1">legend_handle._original_facecolor = orig_handle._original_facecolor</span>
        <span class="s1">legend_handle._original_edgecolor = orig_handle._original_edgecolor</span>
        <span class="s1">legend_handle._fill = orig_handle.get_fill()</span>
        <span class="s1">legend_handle._hatch = orig_handle.get_hatch()</span>
        <span class="s4"># Hatch color is anomalous in having no getters and setters.</span>
        <span class="s1">legend_handle._hatch_color = orig_handle._hatch_color</span>
        <span class="s4"># Setters are fine for the remaining attributes.</span>
        <span class="s1">legend_handle.set_linewidth(get_first(orig_handle.get_linewidths()))</span>
        <span class="s1">legend_handle.set_linestyle(get_first(orig_handle.get_linestyles()))</span>
        <span class="s1">legend_handle.set_transform(get_first(orig_handle.get_transforms()))</span>
        <span class="s1">legend_handle.set_figure(orig_handle.get_figure())</span>
        <span class="s4"># Alpha is already taken into account by the color attributes.</span>

    <span class="s2">def </span><span class="s1">create_artists(self</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">,</span>
                       <span class="s1">xdescent</span><span class="s2">, </span><span class="s1">ydescent</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">p = Rectangle(xy=(-xdescent</span><span class="s2">, </span><span class="s1">-ydescent)</span><span class="s2">,</span>
                      <span class="s1">width=width</span><span class="s2">, </span><span class="s1">height=height)</span>
        <span class="s1">self.update_prop(p</span><span class="s2">, </span><span class="s1">orig_handle</span><span class="s2">, </span><span class="s1">legend)</span>
        <span class="s1">p.set_transform(trans)</span>
        <span class="s2">return </span><span class="s1">[p]</span>
</pre>
</body>
</html>