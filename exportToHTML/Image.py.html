<html>
<head>
<title>image.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
image.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The image module supports basic image loading, rescaling and display 
operations. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">PIL.PngImagePlugin</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">cm</span>
<span class="s3"># For clarity, names from _image are given explicitly in this module</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_image</span>
<span class="s3"># For user convenience, the names from _image are also imported into</span>
<span class="s3"># the image namespace</span>
<span class="s2">from </span><span class="s1">matplotlib._image </span><span class="s2">import </span><span class="s1">*</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">from </span><span class="s1">matplotlib.backend_bases </span><span class="s2">import </span><span class="s1">FigureCanvasBase</span>
<span class="s2">import </span><span class="s1">matplotlib.colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Affine2D</span><span class="s2">, </span><span class="s1">BboxBase</span><span class="s2">, </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxTransform</span><span class="s2">, </span><span class="s1">BboxTransformTo</span><span class="s2">,</span>
    <span class="s1">IdentityTransform</span><span class="s2">, </span><span class="s1">TransformedBbox)</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s3"># map interpolation strings to module constants</span>
<span class="s1">_interpd_ = {</span>
    <span class="s4">'antialiased'</span><span class="s1">: _image.NEAREST</span><span class="s2">,  </span><span class="s3"># this will use nearest or Hanning...</span>
    <span class="s4">'none'</span><span class="s1">: _image.NEAREST</span><span class="s2">,  </span><span class="s3"># fall back to nearest when not supported</span>
    <span class="s4">'nearest'</span><span class="s1">: _image.NEAREST</span><span class="s2">,</span>
    <span class="s4">'bilinear'</span><span class="s1">: _image.BILINEAR</span><span class="s2">,</span>
    <span class="s4">'bicubic'</span><span class="s1">: _image.BICUBIC</span><span class="s2">,</span>
    <span class="s4">'spline16'</span><span class="s1">: _image.SPLINE16</span><span class="s2">,</span>
    <span class="s4">'spline36'</span><span class="s1">: _image.SPLINE36</span><span class="s2">,</span>
    <span class="s4">'hanning'</span><span class="s1">: _image.HANNING</span><span class="s2">,</span>
    <span class="s4">'hamming'</span><span class="s1">: _image.HAMMING</span><span class="s2">,</span>
    <span class="s4">'hermite'</span><span class="s1">: _image.HERMITE</span><span class="s2">,</span>
    <span class="s4">'kaiser'</span><span class="s1">: _image.KAISER</span><span class="s2">,</span>
    <span class="s4">'quadric'</span><span class="s1">: _image.QUADRIC</span><span class="s2">,</span>
    <span class="s4">'catrom'</span><span class="s1">: _image.CATROM</span><span class="s2">,</span>
    <span class="s4">'gaussian'</span><span class="s1">: _image.GAUSSIAN</span><span class="s2">,</span>
    <span class="s4">'bessel'</span><span class="s1">: _image.BESSEL</span><span class="s2">,</span>
    <span class="s4">'mitchell'</span><span class="s1">: _image.MITCHELL</span><span class="s2">,</span>
    <span class="s4">'sinc'</span><span class="s1">: _image.SINC</span><span class="s2">,</span>
    <span class="s4">'lanczos'</span><span class="s1">: _image.LANCZOS</span><span class="s2">,</span>
    <span class="s4">'blackman'</span><span class="s1">: _image.BLACKMAN</span><span class="s2">,</span>
<span class="s1">}</span>

<span class="s1">interpolations_names = set(_interpd_)</span>


<span class="s2">def </span><span class="s1">composite_images(images</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Composite a number of RGBA images into one.  The images are 
    composited in the order in which they appear in the *images* list. 
 
    Parameters 
    ---------- 
    images : list of Images 
        Each must have a `make_image` method.  For each image, 
        `can_composite` should return `True`, though this is not 
        enforced by this function.  Each image must have a purely 
        affine transformation with no shear. 
 
    renderer : `.RendererBase` 
 
    magnification : float, default: 1 
        The additional magnification to apply for the renderer in use. 
 
    Returns 
    ------- 
    image : uint8 array (M, N, 4) 
        The composited RGBA image. 
    offset_x, offset_y : float 
        The (left, bottom) offset where the composited image should be placed 
        in the output figure. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(images) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>

    <span class="s1">parts = []</span>
    <span class="s1">bboxes = []</span>
    <span class="s2">for </span><span class="s1">image </span><span class="s2">in </span><span class="s1">images:</span>
        <span class="s1">data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">trans = image.make_image(renderer</span><span class="s2">, </span><span class="s1">magnification)</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">x *= magnification</span>
            <span class="s1">y *= magnification</span>
            <span class="s1">parts.append((data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">image._get_scalar_alpha()))</span>
            <span class="s1">bboxes.append(</span>
                <span class="s1">Bbox([[x</span><span class="s2">, </span><span class="s1">y]</span><span class="s2">, </span><span class="s1">[x + data.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y + data.shape[</span><span class="s5">0</span><span class="s1">]]]))</span>

    <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>

    <span class="s1">bbox = Bbox.union(bboxes)</span>

    <span class="s1">output = np.zeros(</span>
        <span class="s1">(int(bbox.height)</span><span class="s2">, </span><span class="s1">int(bbox.width)</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>

    <span class="s2">for </span><span class="s1">data</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">alpha </span><span class="s2">in </span><span class="s1">parts:</span>
        <span class="s1">trans = Affine2D().translate(x - bbox.x0</span><span class="s2">, </span><span class="s1">y - bbox.y0)</span>
        <span class="s1">_image.resample(data</span><span class="s2">, </span><span class="s1">output</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">_image.NEAREST</span><span class="s2">,</span>
                        <span class="s1">resample=</span><span class="s2">False, </span><span class="s1">alpha=alpha)</span>

    <span class="s2">return </span><span class="s1">output</span><span class="s2">, </span><span class="s1">bbox.x0 / magnification</span><span class="s2">, </span><span class="s1">bbox.y0 / magnification</span>


<span class="s2">def </span><span class="s1">_draw_list_compositing_images(</span>
        <span class="s1">renderer</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">artists</span><span class="s2">, </span><span class="s1">suppress_composite=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Draw a sorted list of artists, compositing images into a single 
    image where possible. 
 
    For internal Matplotlib use only: It is here to reduce duplication 
    between `Figure.draw` and `Axes.draw`, but otherwise should not be 
    generally useful. 
    &quot;&quot;&quot;</span>
    <span class="s1">has_images = any(isinstance(x</span><span class="s2">, </span><span class="s1">_ImageBase) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">artists)</span>

    <span class="s3"># override the renderer default if suppressComposite is not None</span>
    <span class="s1">not_composite = (suppress_composite </span><span class="s2">if </span><span class="s1">suppress_composite </span><span class="s2">is not None</span>
                     <span class="s2">else </span><span class="s1">renderer.option_image_nocomposite())</span>

    <span class="s2">if </span><span class="s1">not_composite </span><span class="s2">or not </span><span class="s1">has_images:</span>
        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s1">a.draw(renderer)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Composite any adjacent images together</span>
        <span class="s1">image_group = []</span>
        <span class="s1">mag = renderer.get_image_magnification()</span>

        <span class="s2">def </span><span class="s1">flush_images():</span>
            <span class="s2">if </span><span class="s1">len(image_group) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">image_group[</span><span class="s5">0</span><span class="s1">].draw(renderer)</span>
            <span class="s2">elif </span><span class="s1">len(image_group) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b = composite_images(image_group</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">mag)</span>
                <span class="s2">if </span><span class="s1">data.size != </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">gc = renderer.new_gc()</span>
                    <span class="s1">gc.set_clip_rectangle(parent.bbox)</span>
                    <span class="s1">gc.set_clip_path(parent.get_clip_path())</span>
                    <span class="s1">renderer.draw_image(gc</span><span class="s2">, </span><span class="s1">round(l)</span><span class="s2">, </span><span class="s1">round(b)</span><span class="s2">, </span><span class="s1">data)</span>
                    <span class="s1">gc.restore()</span>
            <span class="s2">del </span><span class="s1">image_group[:]</span>

        <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">artists:</span>
            <span class="s2">if </span><span class="s1">(isinstance(a</span><span class="s2">, </span><span class="s1">_ImageBase) </span><span class="s2">and </span><span class="s1">a.can_composite() </span><span class="s2">and</span>
                    <span class="s1">a.get_clip_on() </span><span class="s2">and not </span><span class="s1">a.get_clip_path()):</span>
                <span class="s1">image_group.append(a)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">flush_images()</span>
                <span class="s1">a.draw(renderer)</span>
        <span class="s1">flush_images()</span>


<span class="s2">def </span><span class="s1">_resample(</span>
        <span class="s1">image_obj</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">resample=</span><span class="s2">None, </span><span class="s1">alpha=</span><span class="s5">1</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convenience wrapper around `._image.resample` to resample *data* to 
    *out_shape* (with a third dimension if *data* is RGBA) that takes care of 
    allocating the output array and fetching the relevant properties from the 
    Image object *image_obj*. 
    &quot;&quot;&quot;</span>
    <span class="s3"># AGG can only handle coordinates smaller than 24-bit signed integers,</span>
    <span class="s3"># so raise errors if the input data is larger than _image.resample can</span>
    <span class="s3"># handle.</span>
    <span class="s1">msg = (</span><span class="s4">'Data with more than {n} cannot be accurately displayed. '</span>
           <span class="s4">'Downsampling to less than {n} before displaying. '</span>
           <span class="s4">'To remove this warning, manually downsample your data.'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">data.shape[</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">23</span><span class="s1">:</span>
        <span class="s1">warnings.warn(msg.format(n=</span><span class="s4">'2**23 columns'</span><span class="s1">))</span>
        <span class="s1">step = int(np.ceil(data.shape[</span><span class="s5">1</span><span class="s1">] / </span><span class="s5">2</span><span class="s1">**</span><span class="s5">23</span><span class="s1">))</span>
        <span class="s1">data = data[:</span><span class="s2">, </span><span class="s1">::step]</span>
        <span class="s1">transform = Affine2D().scale(step</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) + transform</span>
    <span class="s2">if </span><span class="s1">data.shape[</span><span class="s5">0</span><span class="s1">] &gt; </span><span class="s5">2</span><span class="s1">**</span><span class="s5">24</span><span class="s1">:</span>
        <span class="s1">warnings.warn(msg.format(n=</span><span class="s4">'2**24 rows'</span><span class="s1">))</span>
        <span class="s1">step = int(np.ceil(data.shape[</span><span class="s5">0</span><span class="s1">] / </span><span class="s5">2</span><span class="s1">**</span><span class="s5">24</span><span class="s1">))</span>
        <span class="s1">data = data[::step</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">transform = Affine2D().scale(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">step) + transform</span>
    <span class="s3"># decide if we need to apply anti-aliasing if the data is upsampled:</span>
    <span class="s3"># compare the number of displayed pixels to the number of</span>
    <span class="s3"># the data pixels.</span>
    <span class="s1">interpolation = image_obj.get_interpolation()</span>
    <span class="s2">if </span><span class="s1">interpolation == </span><span class="s4">'antialiased'</span><span class="s1">:</span>
        <span class="s3"># don't antialias if upsampling by an integer number or</span>
        <span class="s3"># if zooming in more than a factor of 3</span>
        <span class="s1">pos = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[data.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data.shape[</span><span class="s5">0</span><span class="s1">]]])</span>
        <span class="s1">disp = transform.transform(pos)</span>
        <span class="s1">dispx = np.abs(np.diff(disp[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">dispy = np.abs(np.diff(disp[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s2">if </span><span class="s1">((dispx &gt; </span><span class="s5">3 </span><span class="s1">* data.shape[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">dispx == data.shape[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">dispx == </span><span class="s5">2 </span><span class="s1">* data.shape[</span><span class="s5">1</span><span class="s1">]) </span><span class="s2">and</span>
            <span class="s1">(dispy &gt; </span><span class="s5">3 </span><span class="s1">* data.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">dispy == data.shape[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">dispy == </span><span class="s5">2 </span><span class="s1">* data.shape[</span><span class="s5">0</span><span class="s1">])):</span>
            <span class="s1">interpolation = </span><span class="s4">'nearest'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">interpolation = </span><span class="s4">'hanning'</span>
    <span class="s1">out = np.zeros(out_shape + data.shape[</span><span class="s5">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">data.dtype)  </span><span class="s3"># 2D-&gt;2D, 3D-&gt;3D.</span>
    <span class="s2">if </span><span class="s1">resample </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">resample = image_obj.get_resample()</span>
    <span class="s1">_image.resample(data</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">,</span>
                    <span class="s1">_interpd_[interpolation]</span><span class="s2">,</span>
                    <span class="s1">resample</span><span class="s2">,</span>
                    <span class="s1">alpha</span><span class="s2">,</span>
                    <span class="s1">image_obj.get_filternorm()</span><span class="s2">,</span>
                    <span class="s1">image_obj.get_filterrad())</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">_rgb_to_rgba(A):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert an RGB image to RGBA, as required by the image resample C++ 
    extension. 
    &quot;&quot;&quot;</span>
    <span class="s1">rgba = np.zeros((A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=A.dtype)</span>
    <span class="s1">rgba[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">] = A</span>
    <span class="s2">if </span><span class="s1">rgba.dtype == np.uint8:</span>
        <span class="s1">rgba[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">255</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">rgba[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">1.0</span>
    <span class="s2">return </span><span class="s1">rgba</span>


<span class="s2">class </span><span class="s1">_ImageBase(martist.Artist</span><span class="s2">, </span><span class="s1">cm.ScalarMappable):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for images. 
 
    interpolation and cmap default to their rc settings 
 
    cmap is a colors.Colormap instance 
    norm is a colors.Normalize instance to map luminance to 0-1 
 
    extent is data axes (left, right, bottom, top) for making image plots 
    registered with data plots.  Default is to label the pixel 
    centers with the zero-based row and column indices. 
 
    Additional kwargs are matplotlib.artist properties 
    &quot;&quot;&quot;</span>
    <span class="s1">zorder = </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">interpolation=</span><span class="s2">None,</span>
                 <span class="s1">origin=</span><span class="s2">None,</span>
                 <span class="s1">filternorm=</span><span class="s2">True,</span>
                 <span class="s1">filterrad=</span><span class="s5">4.0</span><span class="s2">,</span>
                 <span class="s1">resample=</span><span class="s2">False,</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">interpolation_stage=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s1">martist.Artist.__init__(self)</span>
        <span class="s1">cm.ScalarMappable.__init__(self</span><span class="s2">, </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">cmap)</span>
        <span class="s2">if </span><span class="s1">origin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">origin = mpl.rcParams[</span><span class="s4">'image.origin'</span><span class="s1">]</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">&quot;upper&quot;</span><span class="s2">, </span><span class="s4">&quot;lower&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">origin=origin)</span>
        <span class="s1">self.origin = origin</span>
        <span class="s1">self.set_filternorm(filternorm)</span>
        <span class="s1">self.set_filterrad(filterrad)</span>
        <span class="s1">self.set_interpolation(interpolation)</span>
        <span class="s1">self.set_interpolation_stage(interpolation_stage)</span>
        <span class="s1">self.set_resample(resample)</span>
        <span class="s1">self.axes = ax</span>

        <span class="s1">self._imcache = </span><span class="s2">None</span>

        <span class="s1">self._internal_update(kwargs)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">size = self.get_size()</span>
            <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s4">(size=</span><span class="s2">{</span><span class="s1">size</span><span class="s2">!r}</span><span class="s4">)&quot;</span>
        <span class="s2">except </span><span class="s1">RuntimeError:</span>
            <span class="s2">return </span><span class="s1">type(self).__name__</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s3"># Save some space on the pickle by not saving the cache.</span>
        <span class="s2">return </span><span class="s1">{**super().__getstate__()</span><span class="s2">, </span><span class="s4">&quot;_imcache&quot;</span><span class="s1">: </span><span class="s2">None</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">get_size(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the size of the image as tuple (numrows, numcols).&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first set the image array'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._A.shape[:</span><span class="s5">2</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">set_alpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the alpha value used for blending - not supported on all backends. 
 
        Parameters 
        ---------- 
        alpha : float or 2D array-like or None 
        &quot;&quot;&quot;</span>
        <span class="s1">martist.Artist._set_alpha_for_array(self</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">if </span><span class="s1">np.ndim(alpha) </span><span class="s2">not in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">'alpha must be a float, two-dimensional '</span>
                            <span class="s4">'array, or None'</span><span class="s1">)</span>
        <span class="s1">self._imcache = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_get_scalar_alpha(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get a scalar alpha value to be applied to the artist as a whole. 
 
        If the alpha value is a matrix, the method returns 1.0 because pixels 
        have individual alpha values (see `~._ImageBase._make_image` for 
        details). If the alpha value is a scalar, the method returns said value 
        to be applied to the artist as a whole because pixels do not have 
        individual alpha values. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">1.0 </span><span class="s2">if </span><span class="s1">self._alpha </span><span class="s2">is None or </span><span class="s1">np.ndim(self._alpha) &gt; </span><span class="s5">0 </span><span class="s1">\</span>
            <span class="s2">else </span><span class="s1">self._alpha</span>

    <span class="s2">def </span><span class="s1">changed(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Call this whenever the mappable is changed so observers can update. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._imcache = </span><span class="s2">None</span>
        <span class="s1">cm.ScalarMappable.changed(self)</span>

    <span class="s2">def </span><span class="s1">_make_image(self</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">in_bbox</span><span class="s2">, </span><span class="s1">out_bbox</span><span class="s2">, </span><span class="s1">clip_bbox</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">,</span>
                    <span class="s1">unsampled=</span><span class="s2">False, </span><span class="s1">round_to_pixel_border=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize, rescale, and colormap the image *A* from the given *in_bbox* 
        (in data space), to the given *out_bbox* (in pixel space) clipped to 
        the given *clip_bbox* (also in pixel space), and magnified by the 
        *magnification* factor. 
 
        *A* may be a greyscale image (M, N) with a dtype of float32, float64, 
        float128, uint16 or uint8, or an (M, N, 4) RGBA image with a dtype of 
        float32, float64, float128, or uint8. 
 
        If *unsampled* is True, the image will not be scaled, but an 
        appropriate affine transformation will be returned instead. 
 
        If *round_to_pixel_border* is True, the output image size will be 
        rounded to the nearest pixel boundary.  This makes the images align 
        correctly with the axes.  It should not be used if exact scaling is 
        needed, such as for `FigureImage`. 
 
        Returns 
        ------- 
        image : (M, N, 4) uint8 array 
            The RGBA image, resampled unless *unsampled* is True. 
        x, y : float 
            The upper left corner where the image should be drawn, in pixel 
            space. 
        trans : Affine2D 
            The affine transformation from image to pixel space. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">A </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first set the image '</span>
                               <span class="s4">'array or the image attribute'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;_make_image must get a non-empty image. &quot;</span>
                               <span class="s4">&quot;Your Artist's draw method must filter before &quot;</span>
                               <span class="s4">&quot;this method is called.&quot;</span><span class="s1">)</span>

        <span class="s1">clipped_bbox = Bbox.intersection(out_bbox</span><span class="s2">, </span><span class="s1">clip_bbox)</span>

        <span class="s2">if </span><span class="s1">clipped_bbox </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, None</span>

        <span class="s1">out_width_base = clipped_bbox.width * magnification</span>
        <span class="s1">out_height_base = clipped_bbox.height * magnification</span>

        <span class="s2">if </span><span class="s1">out_width_base == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">out_height_base == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return None, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, None</span>

        <span class="s2">if </span><span class="s1">self.origin == </span><span class="s4">'upper'</span><span class="s1">:</span>
            <span class="s3"># Flip the input image using a transform.  This avoids the</span>
            <span class="s3"># problem with flipping the array, which results in a copy</span>
            <span class="s3"># when it is converted to contiguous in the C wrapper</span>
            <span class="s1">t0 = Affine2D().translate(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-A.shape[</span><span class="s5">0</span><span class="s1">]).scale(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">t0 = IdentityTransform()</span>

        <span class="s1">t0 += (</span>
            <span class="s1">Affine2D()</span>
            <span class="s1">.scale(</span>
                <span class="s1">in_bbox.width / A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">in_bbox.height / A.shape[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">.translate(in_bbox.x0</span><span class="s2">, </span><span class="s1">in_bbox.y0)</span>
            <span class="s1">+ self.get_transform())</span>

        <span class="s1">t = (t0</span>
             <span class="s1">+ (Affine2D()</span>
                <span class="s1">.translate(-clipped_bbox.x0</span><span class="s2">, </span><span class="s1">-clipped_bbox.y0)</span>
                <span class="s1">.scale(magnification)))</span>

        <span class="s3"># So that the image is aligned with the edge of the axes, we want to</span>
        <span class="s3"># round up the output width to the next integer.  This also means</span>
        <span class="s3"># scaling the transform slightly to account for the extra subpixel.</span>
        <span class="s2">if </span><span class="s1">(t.is_affine </span><span class="s2">and </span><span class="s1">round_to_pixel_border </span><span class="s2">and</span>
                <span class="s1">(out_width_base % </span><span class="s5">1.0 </span><span class="s1">!= </span><span class="s5">0.0 </span><span class="s2">or </span><span class="s1">out_height_base % </span><span class="s5">1.0 </span><span class="s1">!= </span><span class="s5">0.0</span><span class="s1">)):</span>
            <span class="s1">out_width = math.ceil(out_width_base)</span>
            <span class="s1">out_height = math.ceil(out_height_base)</span>
            <span class="s1">extra_width = (out_width - out_width_base) / out_width_base</span>
            <span class="s1">extra_height = (out_height - out_height_base) / out_height_base</span>
            <span class="s1">t += Affine2D().scale(</span><span class="s5">1.0 </span><span class="s1">+ extra_width</span><span class="s2">, </span><span class="s5">1.0 </span><span class="s1">+ extra_height)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">out_width = int(out_width_base)</span>
            <span class="s1">out_height = int(out_height_base)</span>
        <span class="s1">out_shape = (out_height</span><span class="s2">, </span><span class="s1">out_width)</span>

        <span class="s2">if not </span><span class="s1">unsampled:</span>
            <span class="s2">if not </span><span class="s1">(A.ndim == </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">A.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">A.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid shape </span><span class="s2">{</span><span class="s1">A.shape</span><span class="s2">} </span><span class="s4">for image data&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">self._interpolation_stage != </span><span class="s4">'rgba'</span><span class="s1">:</span>
                <span class="s3"># if we are a 2D array, then we are running through the</span>
                <span class="s3"># norm + colormap transformation.  However, in general the</span>
                <span class="s3"># input data is not going to match the size on the screen so we</span>
                <span class="s3"># have to resample to the correct number of pixels</span>

                <span class="s3"># TODO slice input array first</span>
                <span class="s1">a_min = A.min()</span>
                <span class="s1">a_max = A.max()</span>
                <span class="s2">if </span><span class="s1">a_min </span><span class="s2">is </span><span class="s1">np.ma.masked:  </span><span class="s3"># All masked; values don't matter.</span>
                    <span class="s1">a_min</span><span class="s2">, </span><span class="s1">a_max = np.int32(</span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.int32(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">A.dtype.kind == </span><span class="s4">'f'</span><span class="s1">:  </span><span class="s3"># Float dtype: scale to same dtype.</span>
                    <span class="s1">scaled_dtype = np.dtype(</span>
                        <span class="s1">np.float64 </span><span class="s2">if </span><span class="s1">A.dtype.itemsize &gt; </span><span class="s5">4 </span><span class="s2">else </span><span class="s1">np.float32)</span>
                    <span class="s2">if </span><span class="s1">scaled_dtype.itemsize &lt; A.dtype.itemsize:</span>
                        <span class="s1">_api.warn_external(</span><span class="s4">f&quot;Casting input data from </span><span class="s2">{</span><span class="s1">A.dtype</span><span class="s2">}</span><span class="s4">&quot;</span>
                                           <span class="s4">f&quot; to </span><span class="s2">{</span><span class="s1">scaled_dtype</span><span class="s2">} </span><span class="s4">for imshow.&quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:  </span><span class="s3"># Int dtype, likely.</span>
                    <span class="s3"># Scale to appropriately sized float: use float32 if the</span>
                    <span class="s3"># dynamic range is small, to limit the memory footprint.</span>
                    <span class="s1">da = a_max.astype(np.float64) - a_min.astype(np.float64)</span>
                    <span class="s1">scaled_dtype = np.float64 </span><span class="s2">if </span><span class="s1">da &gt; </span><span class="s5">1e8 </span><span class="s2">else </span><span class="s1">np.float32</span>

                <span class="s3"># Scale the input data to [.1, .9].  The Agg interpolators clip</span>
                <span class="s3"># to [0, 1] internally, and we use a smaller input scale to</span>
                <span class="s3"># identify the interpolated points that need to be flagged as</span>
                <span class="s3"># over/under.  This may introduce numeric instabilities in very</span>
                <span class="s3"># broadly scaled data.</span>

                <span class="s3"># Always copy, and don't allow array subtypes.</span>
                <span class="s1">A_scaled = np.array(A</span><span class="s2">, </span><span class="s1">dtype=scaled_dtype)</span>
                <span class="s3"># Clip scaled data around norm if necessary.  This is necessary</span>
                <span class="s3"># for big numbers at the edge of float64's ability to represent</span>
                <span class="s3"># changes.  Applying a norm first would be good, but ruins the</span>
                <span class="s3"># interpolation of over numbers.</span>
                <span class="s1">self.norm.autoscale_None(A)</span>
                <span class="s1">dv = np.float64(self.norm.vmax) - np.float64(self.norm.vmin)</span>
                <span class="s1">vmid = np.float64(self.norm.vmin) + dv / </span><span class="s5">2</span>
                <span class="s1">fact = </span><span class="s5">1e7 </span><span class="s2">if </span><span class="s1">scaled_dtype == np.float64 </span><span class="s2">else </span><span class="s5">1e4</span>
                <span class="s1">newmin = vmid - dv * fact</span>
                <span class="s2">if </span><span class="s1">newmin &lt; a_min:</span>
                    <span class="s1">newmin = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">a_min = np.float64(newmin)</span>
                <span class="s1">newmax = vmid + dv * fact</span>
                <span class="s2">if </span><span class="s1">newmax &gt; a_max:</span>
                    <span class="s1">newmax = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">a_max = np.float64(newmax)</span>
                <span class="s2">if </span><span class="s1">newmax </span><span class="s2">is not None or </span><span class="s1">newmin </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">np.clip(A_scaled</span><span class="s2">, </span><span class="s1">newmin</span><span class="s2">, </span><span class="s1">newmax</span><span class="s2">, </span><span class="s1">out=A_scaled)</span>

                <span class="s3"># Rescale the raw data to [offset, 1-offset] so that the</span>
                <span class="s3"># resampling code will run cleanly.  Using dyadic numbers here</span>
                <span class="s3"># could reduce the error, but would not fully eliminate it and</span>
                <span class="s3"># breaks a number of tests (due to the slightly different</span>
                <span class="s3"># error bouncing some pixels across a boundary in the (very</span>
                <span class="s3"># quantized) colormapping step).</span>
                <span class="s1">offset = </span><span class="s5">.1</span>
                <span class="s1">frac = </span><span class="s5">.8</span>
                <span class="s3"># Run vmin/vmax through the same rescaling as the raw data;</span>
                <span class="s3"># otherwise, data values close or equal to the boundaries can</span>
                <span class="s3"># end up on the wrong side due to floating point error.</span>
                <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax</span>
                <span class="s2">if </span><span class="s1">vmin </span><span class="s2">is </span><span class="s1">np.ma.masked:</span>
                    <span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax = a_min</span><span class="s2">, </span><span class="s1">a_max</span>
                <span class="s1">vrange = np.array([vmin</span><span class="s2">, </span><span class="s1">vmax]</span><span class="s2">, </span><span class="s1">dtype=scaled_dtype)</span>

                <span class="s1">A_scaled -= a_min</span>
                <span class="s1">vrange -= a_min</span>
                <span class="s3"># .item() handles a_min/a_max being ndarray subclasses.</span>
                <span class="s1">a_min = a_min.astype(scaled_dtype).item()</span>
                <span class="s1">a_max = a_max.astype(scaled_dtype).item()</span>

                <span class="s2">if </span><span class="s1">a_min != a_max:</span>
                    <span class="s1">A_scaled /= ((a_max - a_min) / frac)</span>
                    <span class="s1">vrange /= ((a_max - a_min) / frac)</span>
                <span class="s1">A_scaled += offset</span>
                <span class="s1">vrange += offset</span>
                <span class="s3"># resample the input data to the correct resolution and shape</span>
                <span class="s1">A_resampled = _resample(self</span><span class="s2">, </span><span class="s1">A_scaled</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">, </span><span class="s1">t)</span>
                <span class="s2">del </span><span class="s1">A_scaled  </span><span class="s3"># Make sure we don't use A_scaled anymore!</span>
                <span class="s3"># Un-scale the resampled data to approximately the original</span>
                <span class="s3"># range. Things that interpolated to outside the original range</span>
                <span class="s3"># will still be outside, but possibly clipped in the case of</span>
                <span class="s3"># higher order interpolation + drastically changing data.</span>
                <span class="s1">A_resampled -= offset</span>
                <span class="s1">vrange -= offset</span>
                <span class="s2">if </span><span class="s1">a_min != a_max:</span>
                    <span class="s1">A_resampled *= ((a_max - a_min) / frac)</span>
                    <span class="s1">vrange *= ((a_max - a_min) / frac)</span>
                <span class="s1">A_resampled += a_min</span>
                <span class="s1">vrange += a_min</span>
                <span class="s3"># if using NoNorm, cast back to the original datatype</span>
                <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">mcolors.NoNorm):</span>
                    <span class="s1">A_resampled = A_resampled.astype(A.dtype)</span>

                <span class="s1">mask = (np.where(A.mask</span><span class="s2">, </span><span class="s1">np.float32(np.nan)</span><span class="s2">, </span><span class="s1">np.float32(</span><span class="s5">1</span><span class="s1">))</span>
                        <span class="s2">if </span><span class="s1">A.mask.shape == A.shape  </span><span class="s3"># nontrivial mask</span>
                        <span class="s2">else </span><span class="s1">np.ones_like(A</span><span class="s2">, </span><span class="s1">np.float32))</span>
                <span class="s3"># we always have to interpolate the mask to account for</span>
                <span class="s3"># non-affine transformations</span>
                <span class="s1">out_alpha = _resample(self</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">resample=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">del </span><span class="s1">mask  </span><span class="s3"># Make sure we don't use mask anymore!</span>
                <span class="s3"># Agg updates out_alpha in place.  If the pixel has no image</span>
                <span class="s3"># data it will not be updated (and still be 0 as we initialized</span>
                <span class="s3"># it), if input data that would go into that output pixel than</span>
                <span class="s3"># it will be `nan`, if all the input data for a pixel is good</span>
                <span class="s3"># it will be 1, and if there is _some_ good data in that output</span>
                <span class="s3"># pixel it will be between [0, 1] (such as a rotated image).</span>
                <span class="s1">out_mask = np.isnan(out_alpha)</span>
                <span class="s1">out_alpha[out_mask] = </span><span class="s5">1</span>
                <span class="s3"># Apply the pixel-by-pixel alpha values if present</span>
                <span class="s1">alpha = self.get_alpha()</span>
                <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None and </span><span class="s1">np.ndim(alpha) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">out_alpha *= _resample(self</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">,</span>
                                           <span class="s1">t</span><span class="s2">, </span><span class="s1">resample=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s3"># mask and run through the norm</span>
                <span class="s1">resampled_masked = np.ma.masked_array(A_resampled</span><span class="s2">, </span><span class="s1">out_mask)</span>
                <span class="s3"># we have re-set the vmin/vmax to account for small errors</span>
                <span class="s3"># that may have moved input values in/out of range</span>
                <span class="s1">s_vmin</span><span class="s2">, </span><span class="s1">s_vmax = vrange</span>
                <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">mcolors.LogNorm) </span><span class="s2">and </span><span class="s1">s_vmin &lt;= </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s3"># Don't give 0 or negative values to LogNorm</span>
                    <span class="s1">s_vmin = np.finfo(scaled_dtype).eps</span>
                <span class="s3"># Block the norm from sending an update signal during the</span>
                <span class="s3"># temporary vmin/vmax change</span>
                <span class="s2">with </span><span class="s1">self.norm.callbacks.blocked()</span><span class="s2">, </span><span class="s1">\</span>
                     <span class="s1">cbook._setattr_cm(self.norm</span><span class="s2">, </span><span class="s1">vmin=s_vmin</span><span class="s2">, </span><span class="s1">vmax=s_vmax):</span>
                    <span class="s1">output = self.norm(resampled_masked)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">2</span><span class="s1">:  </span><span class="s3"># _interpolation_stage == 'rgba'</span>
                    <span class="s1">self.norm.autoscale_None(A)</span>
                    <span class="s1">A = self.to_rgba(A)</span>
                <span class="s2">if </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s1">A = _rgb_to_rgba(A)</span>
                <span class="s1">alpha = self._get_scalar_alpha()</span>
                <span class="s1">output_alpha = _resample(  </span><span class="s3"># resample alpha channel</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">A[...</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">alpha=alpha)</span>
                <span class="s1">output = _resample(  </span><span class="s3"># resample rgb channels</span>
                    <span class="s1">self</span><span class="s2">, </span><span class="s1">_rgb_to_rgba(A[...</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">])</span><span class="s2">, </span><span class="s1">out_shape</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">alpha=alpha)</span>
                <span class="s1">output[...</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = output_alpha  </span><span class="s3"># recombine rgb and alpha</span>

            <span class="s3"># output is now either a 2D array of normed (int or float) data</span>
            <span class="s3"># or an RGBA array of re-sampled input</span>
            <span class="s1">output = self.to_rgba(output</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True, </span><span class="s1">norm=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s3"># output is now a correctly sized RGBA array of uint8</span>

            <span class="s3"># Apply alpha *after* if the input was greyscale without a mask</span>
            <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">alpha = self._get_scalar_alpha()</span>
                <span class="s1">alpha_channel = output[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span>
                <span class="s1">alpha_channel[:] = (  </span><span class="s3"># Assignment will cast to uint8.</span>
                    <span class="s1">alpha_channel.astype(np.float32) * out_alpha * alpha)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._imcache </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._imcache = self.to_rgba(A</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True, </span><span class="s1">norm=(A.ndim == </span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">output = self._imcache</span>

            <span class="s3"># Subset the input image to only the part that will be displayed.</span>
            <span class="s1">subset = TransformedBbox(clip_bbox</span><span class="s2">, </span><span class="s1">t0.inverted()).frozen()</span>
            <span class="s1">output = output[</span>
                <span class="s1">int(max(subset.ymin</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)):</span>
                <span class="s1">int(min(subset.ymax + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">output.shape[</span><span class="s5">0</span><span class="s1">]))</span><span class="s2">,</span>
                <span class="s1">int(max(subset.xmin</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)):</span>
                <span class="s1">int(min(subset.xmax + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">output.shape[</span><span class="s5">1</span><span class="s1">]))]</span>

            <span class="s1">t = Affine2D().translate(</span>
                <span class="s1">int(max(subset.xmin</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">int(max(subset.ymin</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))) + t</span>

        <span class="s2">return </span><span class="s1">output</span><span class="s2">, </span><span class="s1">clipped_bbox.x0</span><span class="s2">, </span><span class="s1">clipped_bbox.y0</span><span class="s2">, </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Normalize, rescale, and colormap this image's data for rendering using 
        *renderer*, with the given *magnification*. 
 
        If *unsampled* is True, the image will not be scaled, but an 
        appropriate affine transformation will be returned instead. 
 
        Returns 
        ------- 
        image : (M, N, 4) uint8 array 
            The RGBA image, resampled unless *unsampled* is True. 
        x, y : float 
            The upper left corner where the image should be drawn, in pixel 
            space. 
        trans : Affine2D 
            The affine transformation from image to pixel space. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'The make_image method must be overridden'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_unsampled_image(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the image is better to be drawn unsampled. 
 
        The derived class needs to override it. 
        &quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># if not visible, declare victory and return</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s1">self.stale = </span><span class="s2">False</span>
            <span class="s2">return</span>
        <span class="s3"># for empty images, there is nothing to draw!</span>
        <span class="s2">if </span><span class="s1">self.get_array().size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.stale = </span><span class="s2">False</span>
            <span class="s2">return</span>
        <span class="s3"># actually render the image.</span>
        <span class="s1">gc = renderer.new_gc()</span>
        <span class="s1">self._set_gc_clip(gc)</span>
        <span class="s1">gc.set_alpha(self._get_scalar_alpha())</span>
        <span class="s1">gc.set_url(self.get_url())</span>
        <span class="s1">gc.set_gid(self.get_gid())</span>
        <span class="s2">if </span><span class="s1">(renderer.option_scale_image()  </span><span class="s3"># Renderer supports transform kwarg.</span>
                <span class="s2">and </span><span class="s1">self._check_unsampled_image()</span>
                <span class="s2">and </span><span class="s1">self.get_transform().is_affine):</span>
            <span class="s1">im</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">trans = self.make_image(renderer</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">im </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">trans = Affine2D().scale(im.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">im.shape[</span><span class="s5">0</span><span class="s1">]) + trans</span>
                <span class="s1">renderer.draw_image(gc</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">trans)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">im</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">trans = self.make_image(</span>
                <span class="s1">renderer</span><span class="s2">, </span><span class="s1">renderer.get_image_magnification())</span>
            <span class="s2">if </span><span class="s1">im </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">renderer.draw_image(gc</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">im)</span>
        <span class="s1">gc.restore()</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot;Test whether the mouse event occurred within the image.&quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s3"># 1) This doesn't work for figimage; but figimage also needs a fix</span>
        <span class="s3">#    below (as the check cannot use x/ydata and extents).</span>
        <span class="s3"># 2) As long as the check below uses x/ydata, we need to test axes</span>
        <span class="s3">#    identity instead of `self.axes.contains(event)` because even if</span>
        <span class="s3">#    axes overlap, x/ydata is only valid for event.inaxes anyways.</span>
        <span class="s2">if </span><span class="s1">self.axes </span><span class="s2">is not </span><span class="s1">mouseevent.inaxes:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>
        <span class="s3"># TODO: make sure this is consistent with patch and patch</span>
        <span class="s3"># collection on nonlinear transformed coordinates.</span>
        <span class="s3"># TODO: consider returning image coordinates (shouldn't</span>
        <span class="s3"># be too difficult given that the image is rectilinear</span>
        <span class="s1">trans = self.get_transform().inverted()</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = trans.transform([mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y])</span>
        <span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = self.get_extent()</span>
        <span class="s2">if </span><span class="s1">xmin &gt; xmax:</span>
            <span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax = xmax</span><span class="s2">, </span><span class="s1">xmin</span>
        <span class="s2">if </span><span class="s1">ymin &gt; ymax:</span>
            <span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = ymax</span><span class="s2">, </span><span class="s1">ymin</span>

        <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None and </span><span class="s1">y </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">inside = (xmin &lt;= x &lt;= xmax) </span><span class="s2">and </span><span class="s1">(ymin &lt;= y &lt;= ymax)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">inside = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">write_png(self</span><span class="s2">, </span><span class="s1">fname):</span>
        <span class="s0">&quot;&quot;&quot;Write the image to png file *fname*.&quot;&quot;&quot;</span>
        <span class="s1">im = self.to_rgba(self._A[::-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self.origin == </span><span class="s4">'lower' </span><span class="s2">else </span><span class="s1">self._A</span><span class="s2">,</span>
                          <span class="s1">bytes=</span><span class="s2">True, </span><span class="s1">norm=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">PIL.Image.fromarray(im).save(fname</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">&quot;png&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the image array. 
 
        Note that this function does *not* update the normalization used. 
 
        Parameters 
        ---------- 
        A : array-like or `PIL.Image.Image` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(A</span><span class="s2">, </span><span class="s1">PIL.Image.Image):</span>
            <span class="s1">A = pil_to_array(A)  </span><span class="s3"># Needed e.g. to apply png palette.</span>
        <span class="s1">self._A = cbook.safe_masked_invalid(A</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(self._A.dtype != np.uint8 </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">np.can_cast(self._A.dtype</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s4">&quot;same_kind&quot;</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Image data of dtype {} cannot be converted to &quot;</span>
                            <span class="s4">&quot;float&quot;</span><span class="s1">.format(self._A.dtype))</span>

        <span class="s2">if </span><span class="s1">self._A.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">self._A.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3"># If just one dimension assume scalar and apply colormap</span>
            <span class="s1">self._A = self._A[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">if not </span><span class="s1">(self._A.ndim == </span><span class="s5">2</span>
                <span class="s2">or </span><span class="s1">self._A.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">self._A.shape[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">in </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Invalid shape {} for image data&quot;</span>
                            <span class="s1">.format(self._A.shape))</span>

        <span class="s2">if </span><span class="s1">self._A.ndim == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3"># If the input data has values outside the valid range (after</span>
            <span class="s3"># normalisation), we issue a warning and then clip X to the bounds</span>
            <span class="s3"># - otherwise casting wraps extreme values, hiding outliers and</span>
            <span class="s3"># making reliable interpretation impossible.</span>
            <span class="s1">high = </span><span class="s5">255 </span><span class="s2">if </span><span class="s1">np.issubdtype(self._A.dtype</span><span class="s2">, </span><span class="s1">np.integer) </span><span class="s2">else </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">self._A.min() &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">high &lt; self._A.max():</span>
                <span class="s1">_log.warning(</span>
                    <span class="s4">'Clipping input data to the valid range for imshow with '</span>
                    <span class="s4">'RGB data ([0..1] for floats or [0..255] for integers).'</span>
                <span class="s1">)</span>
                <span class="s1">self._A = np.clip(self._A</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s3"># Cast unsupported integer types to uint8</span>
            <span class="s2">if </span><span class="s1">self._A.dtype != np.uint8 </span><span class="s2">and </span><span class="s1">np.issubdtype(self._A.dtype</span><span class="s2">,</span>
                                                           <span class="s1">np.integer):</span>
                <span class="s1">self._A = self._A.astype(np.uint8)</span>

        <span class="s1">self._imcache = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_array(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Retained for backwards compatibility - use set_data instead. 
 
        Parameters 
        ---------- 
        A : array-like 
        &quot;&quot;&quot;</span>
        <span class="s3"># This also needs to be here to override the inherited</span>
        <span class="s3"># cm.ScalarMappable.set_array method so it is not invoked by mistake.</span>
        <span class="s1">self.set_data(A)</span>

    <span class="s2">def </span><span class="s1">get_interpolation(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the interpolation method the image uses when resizing. 
 
        One of 'antialiased', 'nearest', 'bilinear', 'bicubic', 'spline16', 
        'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 
        'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos', 
        or 'none'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._interpolation</span>

    <span class="s2">def </span><span class="s1">set_interpolation(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the interpolation method the image uses when resizing. 
 
        If None, use :rc:`image.interpolation`. If 'none', the image is 
        shown as is without interpolating. 'none' is only supported in 
        agg, ps and pdf backends and will fall back to 'nearest' mode 
        for other backends. 
 
        Parameters 
        ---------- 
        s : {'antialiased', 'nearest', 'bilinear', 'bicubic', 'spline16', \ 
'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom', \ 
'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos', 'none'} or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">s = mpl.rcParams[</span><span class="s4">'image.interpolation'</span><span class="s1">]</span>
        <span class="s1">s = s.lower()</span>
        <span class="s1">_api.check_in_list(_interpd_</span><span class="s2">, </span><span class="s1">interpolation=s)</span>
        <span class="s1">self._interpolation = s</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_interpolation_stage(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set when interpolation happens during the transform to RGBA. 
 
        Parameters 
        ---------- 
        s : {'data', 'rgba'} or None 
            Whether to apply up/downsampling interpolation in data or rgba 
            space. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s4">&quot;data&quot;  </span><span class="s3"># placeholder for maybe having rcParam</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'data'</span><span class="s2">, </span><span class="s4">'rgba'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">s=s)</span>
        <span class="s1">self._interpolation_stage = s</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">can_composite(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the image can be composited with its neighbors.&quot;&quot;&quot;</span>
        <span class="s1">trans = self.get_transform()</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._interpolation != </span><span class="s4">'none' </span><span class="s2">and</span>
            <span class="s1">trans.is_affine </span><span class="s2">and</span>
            <span class="s1">trans.is_separable)</span>

    <span class="s2">def </span><span class="s1">set_resample(self</span><span class="s2">, </span><span class="s1">v):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether image resampling is used. 
 
        Parameters 
        ---------- 
        v : bool or None 
            If None, use :rc:`image.resample`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">v = mpl.rcParams[</span><span class="s4">'image.resample'</span><span class="s1">]</span>
        <span class="s1">self._resample = v</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_resample(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether image resampling is used.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._resample</span>

    <span class="s2">def </span><span class="s1">set_filternorm(self</span><span class="s2">, </span><span class="s1">filternorm):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the resize filter normalizes the weights. 
 
        See help for `~.Axes.imshow`. 
 
        Parameters 
        ---------- 
        filternorm : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._filternorm = bool(filternorm)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_filternorm(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the resize filter normalizes the weights.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filternorm</span>

    <span class="s2">def </span><span class="s1">set_filterrad(self</span><span class="s2">, </span><span class="s1">filterrad):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the resize filter radius only applicable to some 
        interpolation schemes -- see help for imshow 
 
        Parameters 
        ---------- 
        filterrad : positive float 
        &quot;&quot;&quot;</span>
        <span class="s1">r = float(filterrad)</span>
        <span class="s2">if </span><span class="s1">r &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The filter radius must be a positive number&quot;</span><span class="s1">)</span>
        <span class="s1">self._filterrad = r</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_filterrad(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the filterrad setting.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._filterrad</span>


<span class="s2">class </span><span class="s1">AxesImage(_ImageBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    An image attached to an Axes. 
 
    Parameters 
    ---------- 
    ax : `~.axes.Axes` 
        The axes the image will belong to. 
    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap` 
        The Colormap instance or registered colormap name used to map scalar 
        data to colors. 
    norm : str or `~matplotlib.colors.Normalize` 
        Maps luminance to 0-1. 
    interpolation : str, default: :rc:`image.interpolation` 
        Supported values are 'none', 'antialiased', 'nearest', 'bilinear', 
        'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 
        'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 
        'sinc', 'lanczos', 'blackman'. 
    interpolation_stage : {'data', 'rgba'}, default: 'data' 
        If 'data', interpolation 
        is carried out on the data provided by the user.  If 'rgba', the 
        interpolation is carried out after the colormapping has been 
        applied (visual interpolation). 
    origin : {'upper', 'lower'}, default: :rc:`image.origin` 
        Place the [0, 0] index of the array in the upper left or lower left 
        corner of the axes. The convention 'upper' is typically used for 
        matrices and images. 
    extent : tuple, optional 
        The data axes (left, right, bottom, top) for making image plots 
        registered with data plots.  Default is to label the pixel 
        centers with the zero-based row and column indices. 
    filternorm : bool, default: True 
        A parameter for the antigrain image resize filter 
        (see the antigrain documentation). 
        If filternorm is set, the filter normalizes integer values and corrects 
        the rounding errors. It doesn't do anything with the source floating 
        point values, it corrects only integers according to the rule of 1.0 
        which means that any sum of pixel weights must be equal to 1.0. So, 
        the filter function must produce a graph of the proper shape. 
    filterrad : float &gt; 0, default: 4 
        The filter radius for filters that have a radius parameter, i.e. when 
        interpolation is one of: 'sinc', 'lanczos' or 'blackman'. 
    resample : bool, default: False 
        When True, use a full resampling method. When False, only resample when 
        the output image is larger than the input image. 
    **kwargs : `.Artist` properties 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;cmap&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">interpolation=</span><span class="s2">None,</span>
                 <span class="s1">origin=</span><span class="s2">None,</span>
                 <span class="s1">extent=</span><span class="s2">None,</span>
                 <span class="s1">filternorm=</span><span class="s2">True,</span>
                 <span class="s1">filterrad=</span><span class="s5">4.0</span><span class="s2">,</span>
                 <span class="s1">resample=</span><span class="s2">False,</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">interpolation_stage=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>

        <span class="s1">self._extent = extent</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">ax</span><span class="s2">,</span>
            <span class="s1">cmap=cmap</span><span class="s2">,</span>
            <span class="s1">norm=norm</span><span class="s2">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
            <span class="s1">origin=origin</span><span class="s2">,</span>
            <span class="s1">filternorm=filternorm</span><span class="s2">,</span>
            <span class="s1">filterrad=filterrad</span><span class="s2">,</span>
            <span class="s1">resample=resample</span><span class="s2">,</span>
            <span class="s1">interpolation_stage=interpolation_stage</span><span class="s2">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y1 = self._extent</span>
        <span class="s1">bbox = Bbox.from_extents([x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1])</span>
        <span class="s2">return </span><span class="s1">bbox.transformed(self.get_transform())</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">trans = self.get_transform()</span>
        <span class="s3"># image is created in the canvas coordinate.</span>
        <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">y2 = self.get_extent()</span>
        <span class="s1">bbox = Bbox(np.array([[x1</span><span class="s2">, </span><span class="s1">y1]</span><span class="s2">, </span><span class="s1">[x2</span><span class="s2">, </span><span class="s1">y2]]))</span>
        <span class="s1">transformed_bbox = TransformedBbox(bbox</span><span class="s2">, </span><span class="s1">trans)</span>
        <span class="s1">clip = ((self.get_clip_box() </span><span class="s2">or </span><span class="s1">self.axes.bbox) </span><span class="s2">if </span><span class="s1">self.get_clip_on()</span>
                <span class="s2">else </span><span class="s1">self.figure.bbox)</span>
        <span class="s2">return </span><span class="s1">self._make_image(self._A</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">transformed_bbox</span><span class="s2">, </span><span class="s1">clip</span><span class="s2">,</span>
                                <span class="s1">magnification</span><span class="s2">, </span><span class="s1">unsampled=unsampled)</span>

    <span class="s2">def </span><span class="s1">_check_unsampled_image(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the image would be better drawn unsampled.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_interpolation() == </span><span class="s4">&quot;none&quot;</span>

    <span class="s2">def </span><span class="s1">set_extent(self</span><span class="s2">, </span><span class="s1">extent</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the image extent. 
 
        Parameters 
        ---------- 
        extent : 4-tuple of float 
            The position and size of the image as tuple 
            ``(left, right, bottom, top)`` in data coordinates. 
        **kwargs 
            Other parameters from which unit info (i.e., the *xunits*, 
            *yunits*, *zunits* (for 3D axes), *runits* and *thetaunits* (for 
            polar axes) entries are applied, if present. 
 
        Notes 
        ----- 
        This updates ``ax.dataLim``, and, if autoscaling, sets ``ax.viewLim`` 
        to tightly fit the image, regardless of ``dataLim``.  Autoscaling 
        state is not changed, so following this with ``ax.autoscale_view()`` 
        will redo the autoscaling in accord with ``dataLim``. 
        &quot;&quot;&quot;</span>
        <span class="s1">(xmin</span><span class="s2">, </span><span class="s1">xmax)</span><span class="s2">, </span><span class="s1">(ymin</span><span class="s2">, </span><span class="s1">ymax) = self.axes._process_unit_info(</span>
            <span class="s1">[(</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s1">[extent[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">extent[</span><span class="s5">1</span><span class="s1">]])</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">&quot;y&quot;</span><span class="s2">, </span><span class="s1">[extent[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">extent[</span><span class="s5">3</span><span class="s1">]])]</span><span class="s2">,</span>
            <span class="s1">kwargs)</span>
        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">_api.kwarg_error(</span><span class="s4">&quot;set_extent&quot;</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s1">xmin = self.axes._validate_converted_limits(</span>
            <span class="s1">xmin</span><span class="s2">, </span><span class="s1">self.convert_xunits)</span>
        <span class="s1">xmax = self.axes._validate_converted_limits(</span>
            <span class="s1">xmax</span><span class="s2">, </span><span class="s1">self.convert_xunits)</span>
        <span class="s1">ymin = self.axes._validate_converted_limits(</span>
            <span class="s1">ymin</span><span class="s2">, </span><span class="s1">self.convert_yunits)</span>
        <span class="s1">ymax = self.axes._validate_converted_limits(</span>
            <span class="s1">ymax</span><span class="s2">, </span><span class="s1">self.convert_yunits)</span>
        <span class="s1">extent = [xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax]</span>

        <span class="s1">self._extent = extent</span>
        <span class="s1">corners = (xmin</span><span class="s2">, </span><span class="s1">ymin)</span><span class="s2">, </span><span class="s1">(xmax</span><span class="s2">, </span><span class="s1">ymax)</span>
        <span class="s1">self.axes.update_datalim(corners)</span>
        <span class="s1">self.sticky_edges.x[:] = [xmin</span><span class="s2">, </span><span class="s1">xmax]</span>
        <span class="s1">self.sticky_edges.y[:] = [ymin</span><span class="s2">, </span><span class="s1">ymax]</span>
        <span class="s2">if </span><span class="s1">self.axes.get_autoscalex_on():</span>
            <span class="s1">self.axes.set_xlim((xmin</span><span class="s2">, </span><span class="s1">xmax)</span><span class="s2">, </span><span class="s1">auto=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.axes.get_autoscaley_on():</span>
            <span class="s1">self.axes.set_ylim((ymin</span><span class="s2">, </span><span class="s1">ymax)</span><span class="s2">, </span><span class="s1">auto=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_extent(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the image extent as tuple (left, right, bottom, top).&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._extent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._extent</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sz = self.get_size()</span>
            <span class="s1">numrows</span><span class="s2">, </span><span class="s1">numcols = sz</span>
            <span class="s2">if </span><span class="s1">self.origin == </span><span class="s4">'upper'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">numcols-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">numrows-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">numcols-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">numrows-</span><span class="s5">0.5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_cursor_data(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the image value at the event position or *None* if the event is 
        outside the image. 
 
        See Also 
        -------- 
        matplotlib.artist.Artist.get_cursor_data 
        &quot;&quot;&quot;</span>
        <span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = self.get_extent()</span>
        <span class="s2">if </span><span class="s1">self.origin == </span><span class="s4">'upper'</span><span class="s1">:</span>
            <span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = ymax</span><span class="s2">, </span><span class="s1">ymin</span>
        <span class="s1">arr = self.get_array()</span>
        <span class="s1">data_extent = Bbox([[xmin</span><span class="s2">, </span><span class="s1">ymin]</span><span class="s2">, </span><span class="s1">[xmax</span><span class="s2">, </span><span class="s1">ymax]])</span>
        <span class="s1">array_extent = Bbox([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[arr.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr.shape[</span><span class="s5">0</span><span class="s1">]]])</span>
        <span class="s1">trans = self.get_transform().inverted()</span>
        <span class="s1">trans += BboxTransform(boxin=data_extent</span><span class="s2">, </span><span class="s1">boxout=array_extent)</span>
        <span class="s1">point = trans.transform([event.x</span><span class="s2">, </span><span class="s1">event.y])</span>
        <span class="s2">if </span><span class="s1">any(np.isnan(point)):</span>
            <span class="s2">return None</span>
        <span class="s1">j</span><span class="s2">, </span><span class="s1">i = point.astype(int)</span>
        <span class="s3"># Clip the coordinates at array bounds</span>
        <span class="s2">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= i &lt; arr.shape[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">or not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= j &lt; arr.shape[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">arr[i</span><span class="s2">, </span><span class="s1">j]</span>


<span class="s2">class </span><span class="s1">NonUniformImage(AxesImage):</span>
    <span class="s1">mouseover = </span><span class="s2">False  </span><span class="s3"># This class still needs its own get_cursor_data impl.</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">interpolation=</span><span class="s4">'nearest'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        interpolation : {'nearest', 'bilinear'}, default: 'nearest' 
 
        **kwargs 
            All other keyword arguments are identical to those of `.AxesImage`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(ax</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_interpolation(interpolation)</span>

    <span class="s2">def </span><span class="s1">_check_unsampled_image(self):</span>
        <span class="s0">&quot;&quot;&quot;Return False. Do not use unsampled image.&quot;&quot;&quot;</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first set the image array'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">unsampled:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'unsampled not supported on NonUniformImage'</span><span class="s1">)</span>
        <span class="s1">A = self._A</span>
        <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">A.dtype != np.uint8:</span>
                <span class="s1">A = self.to_rgba(A</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">A = np.repeat(A[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">np.newaxis]</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">A[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">255</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">A.dtype != np.uint8:</span>
                <span class="s1">A = (</span><span class="s5">255</span><span class="s1">*A).astype(np.uint8)</span>
            <span class="s2">if </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">B = np.zeros(tuple([*A.shape[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s5">4</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.uint8)</span>
                <span class="s1">B[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">] = A</span>
                <span class="s1">B[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] = </span><span class="s5">255</span>
                <span class="s1">A = B</span>
        <span class="s1">vl = self.axes.viewLim</span>
        <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t = self.axes.bbox.extents</span>
        <span class="s1">width = int(((round(r) + </span><span class="s5">0.5</span><span class="s1">) - (round(l) - </span><span class="s5">0.5</span><span class="s1">)) * magnification)</span>
        <span class="s1">height = int(((round(t) + </span><span class="s5">0.5</span><span class="s1">) - (round(b) - </span><span class="s5">0.5</span><span class="s1">)) * magnification)</span>
        <span class="s1">x_pix = np.linspace(vl.x0</span><span class="s2">, </span><span class="s1">vl.x1</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s1">y_pix = np.linspace(vl.y0</span><span class="s2">, </span><span class="s1">vl.y1</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s2">if </span><span class="s1">self._interpolation == </span><span class="s4">&quot;nearest&quot;</span><span class="s1">:</span>
            <span class="s1">x_mid = (self._Ax[:-</span><span class="s5">1</span><span class="s1">] + self._Ax[</span><span class="s5">1</span><span class="s1">:]) / </span><span class="s5">2</span>
            <span class="s1">y_mid = (self._Ay[:-</span><span class="s5">1</span><span class="s1">] + self._Ay[</span><span class="s5">1</span><span class="s1">:]) / </span><span class="s5">2</span>
            <span class="s1">x_int = x_mid.searchsorted(x_pix)</span>
            <span class="s1">y_int = y_mid.searchsorted(y_pix)</span>
            <span class="s3"># The following is equal to `A[y_int[:, None], x_int[None, :]]`,</span>
            <span class="s3"># but many times faster.  Both casting to uint32 (to have an</span>
            <span class="s3"># effectively 1D array) and manual index flattening matter.</span>
            <span class="s1">im = (</span>
                <span class="s1">np.ascontiguousarray(A).view(np.uint32).ravel()[</span>
                    <span class="s1">np.add.outer(y_int * A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x_int)]</span>
                <span class="s1">.view(np.uint8).reshape((height</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)))</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s3"># self._interpolation == &quot;bilinear&quot;</span>
            <span class="s3"># Use np.interp to compute x_int/x_float has similar speed.</span>
            <span class="s1">x_int = np.clip(</span>
                <span class="s1">self._Ax.searchsorted(x_pix) - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(self._Ax) - </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">y_int = np.clip(</span>
                <span class="s1">self._Ay.searchsorted(y_pix) - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(self._Ay) - </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">idx_int = np.add.outer(y_int * A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x_int)</span>
            <span class="s1">x_frac = np.clip(</span>
                <span class="s1">np.divide(x_pix - self._Ax[x_int]</span><span class="s2">, </span><span class="s1">np.diff(self._Ax)[x_int]</span><span class="s2">,</span>
                          <span class="s1">dtype=np.float32)</span><span class="s2">,  </span><span class="s3"># Downcasting helps with speed.</span>
                <span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">y_frac = np.clip(</span>
                <span class="s1">np.divide(y_pix - self._Ay[y_int]</span><span class="s2">, </span><span class="s1">np.diff(self._Ay)[y_int]</span><span class="s2">,</span>
                          <span class="s1">dtype=np.float32)</span><span class="s2">,</span>
                <span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">f00 = np.outer(</span><span class="s5">1 </span><span class="s1">- y_frac</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- x_frac)</span>
            <span class="s1">f10 = np.outer(y_frac</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- x_frac)</span>
            <span class="s1">f01 = np.outer(</span><span class="s5">1 </span><span class="s1">- y_frac</span><span class="s2">, </span><span class="s1">x_frac)</span>
            <span class="s1">f11 = np.outer(y_frac</span><span class="s2">, </span><span class="s1">x_frac)</span>
            <span class="s1">im = np.empty((height</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.uint8)</span>
            <span class="s2">for </span><span class="s1">chan </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
                <span class="s1">ac = A[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">chan].reshape(-</span><span class="s5">1</span><span class="s1">)  </span><span class="s3"># reshape(-1) avoids a copy.</span>
                <span class="s3"># Shifting the buffer start (`ac[offset:]`) avoids an array</span>
                <span class="s3"># addition (`ac[idx_int + offset]`).</span>
                <span class="s1">buf = f00 * ac[idx_int]</span>
                <span class="s1">buf += f10 * ac[A.shape[</span><span class="s5">1</span><span class="s1">]:][idx_int]</span>
                <span class="s1">buf += f01 * ac[</span><span class="s5">1</span><span class="s1">:][idx_int]</span>
                <span class="s1">buf += f11 * ac[A.shape[</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">:][idx_int]</span>
                <span class="s1">im[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">chan] = buf  </span><span class="s3"># Implicitly casts to uint8.</span>
        <span class="s2">return </span><span class="s1">im</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">IdentityTransform()</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the grid for the pixel centers, and the pixel values. 
 
        Parameters 
        ---------- 
        x, y : 1D array-like 
            Monotonic arrays of shapes (N,) and (M,), respectively, specifying 
            pixel centers. 
        A : array-like 
            (M, N) `~numpy.ndarray` or masked array of values to be 
            colormapped, or (M, N, 3) RGB array, or (M, N, 4) RGBA array. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">np.float32)</span>
        <span class="s1">y = np.array(y</span><span class="s2">, </span><span class="s1">np.float32)</span>
        <span class="s1">A = cbook.safe_masked_invalid(A</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(x.ndim == y.ndim == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">] == y.shape + x.shape):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Axes don't match array shape&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.ndim </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Can only plot 2D or 3D data&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;3D arrays must have three (RGB) &quot;</span>
                            <span class="s4">&quot;or four (RGBA) color components&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">A = A.squeeze(axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self._A = A</span>
        <span class="s1">self._Ax = x</span>
        <span class="s1">self._Ay = y</span>
        <span class="s1">self._imcache = </span><span class="s2">None</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_array(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Method not supported'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_interpolation(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        s : {'nearest', 'bilinear'} or None 
            If None, use :rc:`image.interpolation`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">is not None and </span><span class="s1">s </span><span class="s2">not in </span><span class="s1">(</span><span class="s4">'nearest'</span><span class="s2">, </span><span class="s4">'bilinear'</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Only nearest neighbor and '</span>
                                      <span class="s4">'bilinear interpolations are supported'</span><span class="s1">)</span>
        <span class="s1">super().set_interpolation(s)</span>

    <span class="s2">def </span><span class="s1">get_extent(self):</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Must set data first'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._Ax[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._Ax[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._Ay[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._Ay[-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">set_filternorm(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">set_filterrad(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">set_norm(self</span><span class="s2">, </span><span class="s1">norm):</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Cannot change colors after loading data'</span><span class="s1">)</span>
        <span class="s1">super().set_norm(norm)</span>

    <span class="s2">def </span><span class="s1">set_cmap(self</span><span class="s2">, </span><span class="s1">cmap):</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Cannot change colors after loading data'</span><span class="s1">)</span>
        <span class="s1">super().set_cmap(cmap)</span>


<span class="s2">class </span><span class="s1">PcolorImage(AxesImage):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make a pcolor-style plot with an irregular rectangular grid. 
 
    This uses a variation of the original irregular image code, 
    and it is used by pcolorfast for the corresponding grid type. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;cmap&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">,</span>
                 <span class="s1">x=</span><span class="s2">None,</span>
                 <span class="s1">y=</span><span class="s2">None,</span>
                 <span class="s1">A=</span><span class="s2">None,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        ax : `~.axes.Axes` 
            The axes the image will belong to. 
        x, y : 1D array-like, optional 
            Monotonic arrays of length N+1 and M+1, respectively, specifying 
            rectangle boundaries.  If not given, will default to 
            ``range(N + 1)`` and ``range(M + 1)``, respectively. 
        A : array-like 
            The data to be color-coded. The interpretation depends on the 
            shape: 
 
            - (M, N) `~numpy.ndarray` or masked array: values to be colormapped 
            - (M, N, 3): RGB array 
            - (M, N, 4): RGBA array 
 
        cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap` 
            The Colormap instance or registered colormap name used to map 
            scalar data to colors. 
        norm : str or `~matplotlib.colors.Normalize` 
            Maps luminance to 0-1. 
        **kwargs : `.Artist` properties 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(ax</span><span class="s2">, </span><span class="s1">norm=norm</span><span class="s2">, </span><span class="s1">cmap=cmap)</span>
        <span class="s1">self._internal_update(kwargs)</span>
        <span class="s2">if </span><span class="s1">A </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_data(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">A)</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">self._A </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first set the image array'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">unsampled:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'unsampled not supported on PColorImage'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._imcache </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">A = self.to_rgba(self._A</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self._imcache = np.pad(A</span><span class="s2">, </span><span class="s1">[(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">, </span><span class="s4">&quot;constant&quot;</span><span class="s1">)</span>
        <span class="s1">padded_A = self._imcache</span>
        <span class="s1">bg = mcolors.to_rgba(self.axes.patch.get_facecolor()</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">bg = (np.array(bg) * </span><span class="s5">255</span><span class="s1">).astype(np.uint8)</span>
        <span class="s2">if </span><span class="s1">(padded_A[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] != bg).all():</span>
            <span class="s1">padded_A[[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:] = padded_A[:</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]] = bg</span>

        <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">t = self.axes.bbox.extents</span>
        <span class="s1">width = (round(r) + </span><span class="s5">0.5</span><span class="s1">) - (round(l) - </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">height = (round(t) + </span><span class="s5">0.5</span><span class="s1">) - (round(b) - </span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">width = round(width * magnification)</span>
        <span class="s1">height = round(height * magnification)</span>
        <span class="s1">vl = self.axes.viewLim</span>

        <span class="s1">x_pix = np.linspace(vl.x0</span><span class="s2">, </span><span class="s1">vl.x1</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s1">y_pix = np.linspace(vl.y0</span><span class="s2">, </span><span class="s1">vl.y1</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">x_int = self._Ax.searchsorted(x_pix)</span>
        <span class="s1">y_int = self._Ay.searchsorted(y_pix)</span>
        <span class="s1">im = (  </span><span class="s3"># See comment in NonUniformImage.make_image re: performance.</span>
            <span class="s1">padded_A.view(np.uint32).ravel()[</span>
                <span class="s1">np.add.outer(y_int * padded_A.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x_int)]</span>
            <span class="s1">.view(np.uint8).reshape((height</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)))</span>
        <span class="s2">return </span><span class="s1">im</span><span class="s2">, </span><span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">IdentityTransform()</span>

    <span class="s2">def </span><span class="s1">_check_unsampled_image(self):</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the grid for the rectangle boundaries, and the data values. 
 
        Parameters 
        ---------- 
        x, y : 1D array-like, optional 
            Monotonic arrays of length N+1 and M+1, respectively, specifying 
            rectangle boundaries.  If not given, will default to 
            ``range(N + 1)`` and ``range(M + 1)``, respectively. 
        A : array-like 
            The data to be color-coded. The interpretation depends on the 
            shape: 
 
            - (M, N) `~numpy.ndarray` or masked array: values to be colormapped 
            - (M, N, 3): RGB array 
            - (M, N, 4): RGBA array 
        &quot;&quot;&quot;</span>
        <span class="s1">A = cbook.safe_masked_invalid(A</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x = np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">1</span><span class="s1">]+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">np.float64).ravel()</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">y = np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">A.shape[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = np.array(y</span><span class="s2">, </span><span class="s1">np.float64).ravel()</span>

        <span class="s2">if </span><span class="s1">A.shape[:</span><span class="s5">2</span><span class="s1">] != (y.size-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">x.size-</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Axes don't match array shape. Got %s, expected %s.&quot; </span><span class="s1">%</span>
                <span class="s1">(A.shape[:</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(y.size - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">x.size - </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s2">if </span><span class="s1">A.ndim </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;A must be 2D or 3D&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">A.ndim == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">A = A.squeeze(axis=-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">A.shape[</span><span class="s5">2</span><span class="s1">] </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;3D arrays must have RGB or RGBA as last dim&quot;</span><span class="s1">)</span>

        <span class="s3"># For efficient cursor readout, ensure x and y are increasing.</span>
        <span class="s2">if </span><span class="s1">x[-</span><span class="s5">1</span><span class="s1">] &lt; x[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">x = x[::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">A = A[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">y[-</span><span class="s5">1</span><span class="s1">] &lt; y[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s1">y = y[::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">A = A[::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">self._A = A</span>
        <span class="s1">self._Ax = x</span>
        <span class="s1">self._Ay = y</span>
        <span class="s1">self._imcache = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_array(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Method not supported'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_cursor_data(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = event.xdata</span><span class="s2">, </span><span class="s1">event.ydata</span>
        <span class="s2">if </span><span class="s1">(x &lt; self._Ax[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">or </span><span class="s1">x &gt; self._Ax[-</span><span class="s5">1</span><span class="s1">] </span><span class="s2">or</span>
                <span class="s1">y &lt; self._Ay[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">or </span><span class="s1">y &gt; self._Ay[-</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s2">return None</span>
        <span class="s1">j = np.searchsorted(self._Ax</span><span class="s2">, </span><span class="s1">x) - </span><span class="s5">1</span>
        <span class="s1">i = np.searchsorted(self._Ay</span><span class="s2">, </span><span class="s1">y) - </span><span class="s5">1</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._A[i</span><span class="s2">, </span><span class="s1">j]</span>
        <span class="s2">except </span><span class="s1">IndexError:</span>
            <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">FigureImage(_ImageBase):</span>
    <span class="s0">&quot;&quot;&quot;An image attached to a figure.&quot;&quot;&quot;</span>

    <span class="s1">zorder = </span><span class="s5">0</span>

    <span class="s1">_interpolation = </span><span class="s4">'nearest'</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;cmap&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fig</span><span class="s2">,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">offsetx=</span><span class="s5">0</span><span class="s2">,</span>
                 <span class="s1">offsety=</span><span class="s5">0</span><span class="s2">,</span>
                 <span class="s1">origin=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        cmap is a colors.Colormap instance 
        norm is a colors.Normalize instance to map luminance to 0-1 
 
        kwargs are an optional list of Artist keyword args 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(</span>
            <span class="s2">None,</span>
            <span class="s1">norm=norm</span><span class="s2">,</span>
            <span class="s1">cmap=cmap</span><span class="s2">,</span>
            <span class="s1">origin=origin</span>
        <span class="s1">)</span>
        <span class="s1">self.figure = fig</span>
        <span class="s1">self.ox = offsetx</span>
        <span class="s1">self.oy = offsety</span>
        <span class="s1">self._internal_update(kwargs)</span>
        <span class="s1">self.magnification = </span><span class="s5">1.0</span>

    <span class="s2">def </span><span class="s1">get_extent(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the image extent as tuple (left, right, bottom, top).&quot;&quot;&quot;</span>
        <span class="s1">numrows</span><span class="s2">, </span><span class="s1">numcols = self.get_size()</span>
        <span class="s2">return </span><span class="s1">(-</span><span class="s5">0.5 </span><span class="s1">+ self.ox</span><span class="s2">, </span><span class="s1">numcols-</span><span class="s5">0.5 </span><span class="s1">+ self.ox</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s5">0.5 </span><span class="s1">+ self.oy</span><span class="s2">, </span><span class="s1">numrows-</span><span class="s5">0.5 </span><span class="s1">+ self.oy)</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">fac = renderer.dpi/self.figure.dpi</span>
        <span class="s3"># fac here is to account for pdf, eps, svg backends where</span>
        <span class="s3"># figure.dpi is set to 72.  This means we need to scale the</span>
        <span class="s3"># image (using magnification) and offset it appropriately.</span>
        <span class="s1">bbox = Bbox([[self.ox/fac</span><span class="s2">, </span><span class="s1">self.oy/fac]</span><span class="s2">,</span>
                     <span class="s1">[(self.ox/fac + self._A.shape[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">(self.oy/fac + self._A.shape[</span><span class="s5">0</span><span class="s1">])]])</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">height = self.figure.get_size_inches()</span>
        <span class="s1">width *= renderer.dpi</span>
        <span class="s1">height *= renderer.dpi</span>
        <span class="s1">clip = Bbox([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[width</span><span class="s2">, </span><span class="s1">height]])</span>
        <span class="s2">return </span><span class="s1">self._make_image(</span>
            <span class="s1">self._A</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">clip</span><span class="s2">, </span><span class="s1">magnification=magnification / fac</span><span class="s2">,</span>
            <span class="s1">unsampled=unsampled</span><span class="s2">, </span><span class="s1">round_to_pixel_border=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">A):</span>
        <span class="s0">&quot;&quot;&quot;Set the image array.&quot;&quot;&quot;</span>
        <span class="s1">cm.ScalarMappable.set_array(self</span><span class="s2">, </span><span class="s1">A)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">BboxImage(_ImageBase):</span>
    <span class="s0">&quot;&quot;&quot;The Image class whose size is determined by the given bbox.&quot;&quot;&quot;</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;cmap&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">,</span>
                 <span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">interpolation=</span><span class="s2">None,</span>
                 <span class="s1">origin=</span><span class="s2">None,</span>
                 <span class="s1">filternorm=</span><span class="s2">True,</span>
                 <span class="s1">filterrad=</span><span class="s5">4.0</span><span class="s2">,</span>
                 <span class="s1">resample=</span><span class="s2">False,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        cmap is a colors.Colormap instance 
        norm is a colors.Normalize instance to map luminance to 0-1 
 
        kwargs are an optional list of Artist keyword args 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(</span>
            <span class="s2">None,</span>
            <span class="s1">cmap=cmap</span><span class="s2">,</span>
            <span class="s1">norm=norm</span><span class="s2">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
            <span class="s1">origin=origin</span><span class="s2">,</span>
            <span class="s1">filternorm=filternorm</span><span class="s2">,</span>
            <span class="s1">filterrad=filterrad</span><span class="s2">,</span>
            <span class="s1">resample=resample</span><span class="s2">,</span>
            <span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s1">self.bbox = bbox</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.get_figure()._get_renderer()</span>

        <span class="s2">if </span><span class="s1">isinstance(self.bbox</span><span class="s2">, </span><span class="s1">BboxBase):</span>
            <span class="s2">return </span><span class="s1">self.bbox</span>
        <span class="s2">elif </span><span class="s1">callable(self.bbox):</span>
            <span class="s2">return </span><span class="s1">self.bbox(renderer)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown type of bbox&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot;Test whether the mouse event occurred within the image.&quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s2">if not </span><span class="s1">self.get_visible():  </span><span class="s3"># or self.get_figure()._renderer is None:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y</span>
        <span class="s1">inside = self.get_window_extent().contains(x</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">make_image(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">magnification=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unsampled=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">height = renderer.get_canvas_width_height()</span>
        <span class="s1">bbox_in = self.get_window_extent(renderer).frozen()</span>
        <span class="s1">bbox_in._points /= [width</span><span class="s2">, </span><span class="s1">height]</span>
        <span class="s1">bbox_out = self.get_window_extent(renderer)</span>
        <span class="s1">clip = Bbox([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[width</span><span class="s2">, </span><span class="s1">height]])</span>
        <span class="s1">self._transform = BboxTransformTo(clip)</span>
        <span class="s2">return </span><span class="s1">self._make_image(</span>
            <span class="s1">self._A</span><span class="s2">,</span>
            <span class="s1">bbox_in</span><span class="s2">, </span><span class="s1">bbox_out</span><span class="s2">, </span><span class="s1">clip</span><span class="s2">, </span><span class="s1">magnification</span><span class="s2">, </span><span class="s1">unsampled=unsampled)</span>


<span class="s2">def </span><span class="s1">imread(fname</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Read an image from a file into an array. 
 
    .. note:: 
 
        This function exists for historical reasons.  It is recommended to 
        use `PIL.Image.open` instead for loading images. 
 
    Parameters 
    ---------- 
    fname : str or file-like 
        The image file to read: a filename, a URL or a file-like object opened 
        in read-binary mode. 
 
        Passing a URL is deprecated.  Please open the URL 
        for reading and pass the result to Pillow, e.g. with 
        ``np.array(PIL.Image.open(urllib.request.urlopen(url)))``. 
    format : str, optional 
        The image file format assumed for reading the data.  The image is 
        loaded as a PNG file if *format* is set to &quot;png&quot;, if *fname* is a path 
        or opened file with a &quot;.png&quot; extension, or if it is a URL.  In all 
        other cases, *format* is ignored and the format is auto-detected by 
        `PIL.Image.open`. 
 
    Returns 
    ------- 
    `numpy.array` 
        The image data. The returned array has shape 
 
        - (M, N) for grayscale images. 
        - (M, N, 3) for RGB images. 
        - (M, N, 4) for RGBA images. 
 
        PNG images are returned as float arrays (0-1).  All other formats are 
        returned as int arrays, with a bit depth determined by the file's 
        contents. 
    &quot;&quot;&quot;</span>
    <span class="s3"># hide imports to speed initial import on systems with slow linkers</span>
    <span class="s2">from </span><span class="s1">urllib </span><span class="s2">import </span><span class="s1">parse</span>

    <span class="s2">if </span><span class="s1">format </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">parsed = parse.urlparse(fname)</span>
            <span class="s3"># If the string is a URL (Windows paths appear as if they have a</span>
            <span class="s3"># length-1 scheme), assume png.</span>
            <span class="s2">if </span><span class="s1">len(parsed.scheme) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">ext = </span><span class="s4">'png'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">ext = Path(fname).suffix.lower()[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">elif </span><span class="s1">hasattr(fname</span><span class="s2">, </span><span class="s4">'geturl'</span><span class="s1">):  </span><span class="s3"># Returned by urlopen().</span>
            <span class="s3"># We could try to parse the url's path and use the extension, but</span>
            <span class="s3"># returning png is consistent with the block above.  Note that this</span>
            <span class="s3"># if clause has to come before checking for fname.name as</span>
            <span class="s3"># urlopen(&quot;file:///...&quot;) also has a name attribute (with the fixed</span>
            <span class="s3"># value &quot;&lt;urllib response&gt;&quot;).</span>
            <span class="s1">ext = </span><span class="s4">'png'</span>
        <span class="s2">elif </span><span class="s1">hasattr(fname</span><span class="s2">, </span><span class="s4">'name'</span><span class="s1">):</span>
            <span class="s1">ext = Path(fname.name).suffix.lower()[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ext = </span><span class="s4">'png'</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ext = format</span>
    <span class="s1">img_open = (</span>
        <span class="s1">PIL.PngImagePlugin.PngImageFile </span><span class="s2">if </span><span class="s1">ext == </span><span class="s4">'png' </span><span class="s2">else </span><span class="s1">PIL.Image.open)</span>
    <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">len(parse.urlparse(fname).scheme) &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3"># Pillow doesn't handle URLs directly.</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Please open the URL for reading and pass the &quot;</span>
            <span class="s4">&quot;result to Pillow, e.g. with &quot;</span>
            <span class="s4">&quot;``np.array(PIL.Image.open(urllib.request.urlopen(url)))``.&quot;</span>
            <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">img_open(fname) </span><span class="s2">as </span><span class="s1">image:</span>
        <span class="s2">return </span><span class="s1">(_pil_png_to_float_array(image)</span>
                <span class="s2">if </span><span class="s1">isinstance(image</span><span class="s2">, </span><span class="s1">PIL.PngImagePlugin.PngImageFile) </span><span class="s2">else</span>
                <span class="s1">pil_to_array(image))</span>


<span class="s2">def </span><span class="s1">imsave(fname</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">vmin=</span><span class="s2">None, </span><span class="s1">vmax=</span><span class="s2">None, </span><span class="s1">cmap=</span><span class="s2">None, </span><span class="s1">format=</span><span class="s2">None,</span>
           <span class="s1">origin=</span><span class="s2">None, </span><span class="s1">dpi=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None, </span><span class="s1">pil_kwargs=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Colormap and save an array as an image file. 
 
    RGB(A) images are passed through.  Single channel images will be 
    colormapped according to *cmap* and *norm*. 
 
    .. note:: 
 
       If you want to save a single channel image as gray scale please use an 
       image I/O library (such as pillow, tifffile, or imageio) directly. 
 
    Parameters 
    ---------- 
    fname : str or path-like or file-like 
        A path or a file-like object to store the image in. 
        If *format* is not set, then the output format is inferred from the 
        extension of *fname*, if any, and from :rc:`savefig.format` otherwise. 
        If *format* is set, it determines the output format. 
    arr : array-like 
        The image data. The shape can be one of 
        MxN (luminance), MxNx3 (RGB) or MxNx4 (RGBA). 
    vmin, vmax : float, optional 
        *vmin* and *vmax* set the color scaling for the image by fixing the 
        values that map to the colormap color limits. If either *vmin* 
        or *vmax* is None, that limit is determined from the *arr* 
        min/max value. 
    cmap : str or `~matplotlib.colors.Colormap`, default: :rc:`image.cmap` 
        A Colormap instance or registered colormap name. The colormap 
        maps scalar data to colors. It is ignored for RGB(A) data. 
    format : str, optional 
        The file format, e.g. 'png', 'pdf', 'svg', ...  The behavior when this 
        is unset is documented under *fname*. 
    origin : {'upper', 'lower'}, default: :rc:`image.origin` 
        Indicates whether the ``(0, 0)`` index of the array is in the upper 
        left or lower left corner of the axes. 
    dpi : float 
        The DPI to store in the metadata of the file.  This does not affect the 
        resolution of the output image.  Depending on file format, this may be 
        rounded to the nearest integer. 
    metadata : dict, optional 
        Metadata in the image file.  The supported keys depend on the output 
        format, see the documentation of the respective backends for more 
        information. 
    pil_kwargs : dict, optional 
        Keyword arguments passed to `PIL.Image.Image.save`.  If the 'pnginfo' 
        key is present, it completely overrides *metadata*, including the 
        default 'Software' key. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
    <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">os.PathLike):</span>
        <span class="s1">fname = os.fspath(fname)</span>
    <span class="s2">if </span><span class="s1">format </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">format = (Path(fname).suffix[</span><span class="s5">1</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">str)</span>
                  <span class="s2">else </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;savefig.format&quot;</span><span class="s1">]).lower()</span>
    <span class="s2">if </span><span class="s1">format </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;pdf&quot;</span><span class="s2">, </span><span class="s4">&quot;ps&quot;</span><span class="s2">, </span><span class="s4">&quot;eps&quot;</span><span class="s2">, </span><span class="s4">&quot;svg&quot;</span><span class="s1">]:</span>
        <span class="s3"># Vector formats that are not handled by PIL.</span>
        <span class="s2">if </span><span class="s1">pil_kwargs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Cannot use 'pil_kwargs' when saving to </span><span class="s2">{</span><span class="s1">format</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">fig = Figure(dpi=dpi</span><span class="s2">, </span><span class="s1">frameon=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">fig.figimage(arr</span><span class="s2">, </span><span class="s1">cmap=cmap</span><span class="s2">, </span><span class="s1">vmin=vmin</span><span class="s2">, </span><span class="s1">vmax=vmax</span><span class="s2">, </span><span class="s1">origin=origin</span><span class="s2">,</span>
                     <span class="s1">resize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">fig.savefig(fname</span><span class="s2">, </span><span class="s1">dpi=dpi</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">transparent=</span><span class="s2">True,</span>
                    <span class="s1">metadata=metadata)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Don't bother creating an image; this avoids rounding errors on the</span>
        <span class="s3"># size when dividing and then multiplying by dpi.</span>
        <span class="s2">if </span><span class="s1">origin </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">origin = mpl.rcParams[</span><span class="s4">&quot;image.origin&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">origin == </span><span class="s4">&quot;lower&quot;</span><span class="s1">:</span>
            <span class="s1">arr = arr[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">(isinstance(arr</span><span class="s2">, </span><span class="s1">memoryview) </span><span class="s2">and </span><span class="s1">arr.format == </span><span class="s4">&quot;B&quot;</span>
                <span class="s2">and </span><span class="s1">arr.ndim == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">arr.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">4</span><span class="s1">):</span>
            <span class="s3"># Such an ``arr`` would also be handled fine by sm.to_rgba below</span>
            <span class="s3"># (after casting with asarray), but it is useful to special-case it</span>
            <span class="s3"># because that's what backend_agg passes, and can be in fact used</span>
            <span class="s3"># as is, saving a few operations.</span>
            <span class="s1">rgba = arr</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sm = cm.ScalarMappable(cmap=cmap)</span>
            <span class="s1">sm.set_clim(vmin</span><span class="s2">, </span><span class="s1">vmax)</span>
            <span class="s1">rgba = sm.to_rgba(arr</span><span class="s2">, </span><span class="s1">bytes=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pil_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">pil_kwargs = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># we modify this below, so make a copy (don't modify caller's dict)</span>
            <span class="s1">pil_kwargs = pil_kwargs.copy()</span>
        <span class="s1">pil_shape = (rgba.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rgba.shape[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">image = PIL.Image.frombuffer(</span>
            <span class="s4">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s1">pil_shape</span><span class="s2">, </span><span class="s1">rgba</span><span class="s2">, </span><span class="s4">&quot;raw&quot;</span><span class="s2">, </span><span class="s4">&quot;RGBA&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">format == </span><span class="s4">&quot;png&quot;</span><span class="s1">:</span>
            <span class="s3"># Only use the metadata kwarg if pnginfo is not set, because the</span>
            <span class="s3"># semantics of duplicate keys in pnginfo is unclear.</span>
            <span class="s2">if </span><span class="s4">&quot;pnginfo&quot; </span><span class="s2">in </span><span class="s1">pil_kwargs:</span>
                <span class="s2">if </span><span class="s1">metadata:</span>
                    <span class="s1">_api.warn_external(</span><span class="s4">&quot;'metadata' is overridden by the &quot;</span>
                                       <span class="s4">&quot;'pnginfo' entry in 'pil_kwargs'.&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">metadata = {</span>
                    <span class="s4">&quot;Software&quot;</span><span class="s1">: (</span><span class="s4">f&quot;Matplotlib version</span><span class="s2">{</span><span class="s1">mpl.__version__</span><span class="s2">}</span><span class="s4">, &quot;</span>
                                 <span class="s4">f&quot;https://matplotlib.org/&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">**(metadata </span><span class="s2">if </span><span class="s1">metadata </span><span class="s2">is not None else </span><span class="s1">{})</span><span class="s2">,</span>
                <span class="s1">}</span>
                <span class="s1">pil_kwargs[</span><span class="s4">&quot;pnginfo&quot;</span><span class="s1">] = pnginfo = PIL.PngImagePlugin.PngInfo()</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">metadata.items():</span>
                    <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">pnginfo.add_text(k</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;jpg&quot;</span><span class="s2">, </span><span class="s4">&quot;jpeg&quot;</span><span class="s1">]:</span>
            <span class="s1">format = </span><span class="s4">&quot;jpeg&quot;  </span><span class="s3"># Pillow doesn't recognize &quot;jpg&quot;.</span>
            <span class="s1">facecolor = mpl.rcParams[</span><span class="s4">&quot;savefig.facecolor&quot;</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">cbook._str_equal(facecolor</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">):</span>
                <span class="s1">facecolor = mpl.rcParams[</span><span class="s4">&quot;figure.facecolor&quot;</span><span class="s1">]</span>
            <span class="s1">color = tuple(int(x * </span><span class="s5">255</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">mcolors.to_rgb(facecolor))</span>
            <span class="s1">background = PIL.Image.new(</span><span class="s4">&quot;RGB&quot;</span><span class="s2">, </span><span class="s1">pil_shape</span><span class="s2">, </span><span class="s1">color)</span>
            <span class="s1">background.paste(image</span><span class="s2">, </span><span class="s1">image)</span>
            <span class="s1">image = background</span>
        <span class="s1">pil_kwargs.setdefault(</span><span class="s4">&quot;format&quot;</span><span class="s2">, </span><span class="s1">format)</span>
        <span class="s1">pil_kwargs.setdefault(</span><span class="s4">&quot;dpi&quot;</span><span class="s2">, </span><span class="s1">(dpi</span><span class="s2">, </span><span class="s1">dpi))</span>
        <span class="s1">image.save(fname</span><span class="s2">, </span><span class="s1">**pil_kwargs)</span>


<span class="s2">def </span><span class="s1">pil_to_array(pilImage):</span>
    <span class="s0">&quot;&quot;&quot; 
    Load a `PIL image`_ and return it as a numpy int array. 
 
    .. _PIL image: https://pillow.readthedocs.io/en/latest/reference/Image.html 
 
    Returns 
    ------- 
    numpy.array 
 
        The array shape depends on the image type: 
 
        - (M, N) for grayscale images. 
        - (M, N, 3) for RGB images. 
        - (M, N, 4) for RGBA images. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">pilImage.mode </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'RGBA'</span><span class="s2">, </span><span class="s4">'RGBX'</span><span class="s2">, </span><span class="s4">'RGB'</span><span class="s2">, </span><span class="s4">'L'</span><span class="s1">]:</span>
        <span class="s3"># return MxNx4 RGBA, MxNx3 RBA, or MxN luminance array</span>
        <span class="s2">return </span><span class="s1">np.asarray(pilImage)</span>
    <span class="s2">elif </span><span class="s1">pilImage.mode.startswith(</span><span class="s4">'I;16'</span><span class="s1">):</span>
        <span class="s3"># return MxN luminance array of uint16</span>
        <span class="s1">raw = pilImage.tobytes(</span><span class="s4">'raw'</span><span class="s2">, </span><span class="s1">pilImage.mode)</span>
        <span class="s2">if </span><span class="s1">pilImage.mode.endswith(</span><span class="s4">'B'</span><span class="s1">):</span>
            <span class="s1">x = np.frombuffer(raw</span><span class="s2">, </span><span class="s4">'&gt;u2'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x = np.frombuffer(raw</span><span class="s2">, </span><span class="s4">'&lt;u2'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">x.reshape(pilImage.size[::-</span><span class="s5">1</span><span class="s1">]).astype(</span><span class="s4">'=u2'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:  </span><span class="s3"># try to convert to an rgba image</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">pilImage = pilImage.convert(</span><span class="s4">'RGBA'</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Unknown image mode'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">np.asarray(pilImage)  </span><span class="s3"># return MxNx4 RGBA array</span>


<span class="s2">def </span><span class="s1">_pil_png_to_float_array(pil_png):</span>
    <span class="s0">&quot;&quot;&quot;Convert a PIL `PNGImageFile` to a 0-1 float array.&quot;&quot;&quot;</span>
    <span class="s3"># Unlike pil_to_array this converts to 0-1 float32s for backcompat with the</span>
    <span class="s3"># old libpng-based loader.</span>
    <span class="s3"># The supported rawmodes are from PIL.PngImagePlugin._MODES.  When</span>
    <span class="s3"># mode == &quot;RGB(A)&quot;, the 16-bit raw data has already been coarsened to 8-bit</span>
    <span class="s3"># by Pillow.</span>
    <span class="s1">mode = pil_png.mode</span>
    <span class="s1">rawmode = pil_png.png.im_rawmode</span>
    <span class="s2">if </span><span class="s1">rawmode == </span><span class="s4">&quot;1&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale.</span>
        <span class="s2">return </span><span class="s1">np.asarray(pil_png</span><span class="s2">, </span><span class="s1">np.float32)</span>
    <span class="s2">if </span><span class="s1">rawmode == </span><span class="s4">&quot;L;2&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">rawmode == </span><span class="s4">&quot;L;4&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">4 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">rawmode == </span><span class="s4">&quot;L&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">8 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">rawmode == </span><span class="s4">&quot;I;16B&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">16 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s4">&quot;RGB&quot;</span><span class="s1">:  </span><span class="s3"># RGB.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">8 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s4">&quot;P&quot;</span><span class="s1">:  </span><span class="s3"># Palette.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png.convert(</span><span class="s4">&quot;RGBA&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">8 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s4">&quot;LA&quot;</span><span class="s1">:  </span><span class="s3"># Grayscale + alpha.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png.convert(</span><span class="s4">&quot;RGBA&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">8 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">if </span><span class="s1">mode == </span><span class="s4">&quot;RGBA&quot;</span><span class="s1">:  </span><span class="s3"># RGBA.</span>
        <span class="s2">return </span><span class="s1">np.divide(pil_png</span><span class="s2">, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">8 </span><span class="s1">- </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unknown PIL rawmode: </span><span class="s2">{</span><span class="s1">rawmode</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">thumbnail(infile</span><span class="s2">, </span><span class="s1">thumbfile</span><span class="s2">, </span><span class="s1">scale=</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">interpolation=</span><span class="s4">'bilinear'</span><span class="s2">,</span>
              <span class="s1">preview=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make a thumbnail of image in *infile* with output filename *thumbfile*. 
 
    See :doc:`/gallery/misc/image_thumbnail_sgskip`. 
 
    Parameters 
    ---------- 
    infile : str or file-like 
        The image file. Matplotlib relies on Pillow_ for image reading, and 
        thus supports a wide range of file formats, including PNG, JPG, TIFF 
        and others. 
 
        .. _Pillow: https://python-pillow.org/ 
 
    thumbfile : str or file-like 
        The thumbnail filename. 
 
    scale : float, default: 0.1 
        The scale factor for the thumbnail. 
 
    interpolation : str, default: 'bilinear' 
        The interpolation scheme used in the resampling. See the 
        *interpolation* parameter of `~.Axes.imshow` for possible values. 
 
    preview : bool, default: False 
        If True, the default backend (presumably a user interface 
        backend) will be used which will cause a figure to be raised if 
        `~matplotlib.pyplot.show` is called.  If it is False, the figure is 
        created using `.FigureCanvasBase` and the drawing backend is selected 
        as `.Figure.savefig` would normally do. 
 
    Returns 
    ------- 
    `.Figure` 
        The figure instance containing the thumbnail. 
    &quot;&quot;&quot;</span>

    <span class="s1">im = imread(infile)</span>
    <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">depth = im.shape</span>

    <span class="s3"># This doesn't really matter (it cancels in the end) but the API needs it.</span>
    <span class="s1">dpi = </span><span class="s5">100</span>

    <span class="s1">height = rows / dpi * scale</span>
    <span class="s1">width = cols / dpi * scale</span>

    <span class="s2">if </span><span class="s1">preview:</span>
        <span class="s3"># Let the UI backend do everything.</span>
        <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
        <span class="s1">fig = plt.figure(figsize=(width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">, </span><span class="s1">dpi=dpi)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
        <span class="s1">fig = Figure(figsize=(width</span><span class="s2">, </span><span class="s1">height)</span><span class="s2">, </span><span class="s1">dpi=dpi)</span>
        <span class="s1">FigureCanvasBase(fig)</span>

    <span class="s1">ax = fig.add_axes([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">aspect=</span><span class="s4">'auto'</span><span class="s2">,</span>
                      <span class="s1">frameon=</span><span class="s2">False, </span><span class="s1">xticks=[]</span><span class="s2">, </span><span class="s1">yticks=[])</span>
    <span class="s1">ax.imshow(im</span><span class="s2">, </span><span class="s1">aspect=</span><span class="s4">'auto'</span><span class="s2">, </span><span class="s1">resample=</span><span class="s2">True, </span><span class="s1">interpolation=interpolation)</span>
    <span class="s1">fig.savefig(thumbfile</span><span class="s2">, </span><span class="s1">dpi=dpi)</span>
    <span class="s2">return </span><span class="s1">fig</span>
</pre>
</body>
</html>