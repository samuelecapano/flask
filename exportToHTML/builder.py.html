<html>
<head>
<title>builder.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
builder.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2014 Google Inc. All rights reserved.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">number_types </span><span class="s2">as </span><span class="s1">N</span>
<span class="s2">from </span><span class="s1">.number_types </span><span class="s2">import </span><span class="s1">(UOffsetTFlags</span><span class="s2">, </span><span class="s1">SOffsetTFlags</span><span class="s2">, </span><span class="s1">VOffsetTFlags)</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">encode</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">packer</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">compat</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">range_func</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">memoryview_type</span>
<span class="s2">from </span><span class="s1">.compat </span><span class="s2">import </span><span class="s1">import_numpy</span><span class="s2">, </span><span class="s1">NumpyRequiredForThisFeature</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s1">np = import_numpy()</span>
<span class="s0">## @file</span>
<span class="s0">## @addtogroup flatbuffers_python_api</span>
<span class="s0">## @{</span>

<span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
<span class="s2">class </span><span class="s1">OffsetArithmeticError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by an Offset arithmetic error. Probably caused by bad 
    writing of fields. This is considered an unreachable situation in 
    normal circumstances. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">IsNotNestedError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by using a Builder to write Object data when not inside 
    an Object. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">IsNestedError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by using a Builder to begin an Object when an Object is 
    already being built. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">StructIsNotInlineError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by using a Builder to write a Struct at a location that 
    is not the current Offset. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">BuilderSizeError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by causing a Builder to exceed the hardcoded limit of 2 
    gigabytes. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">BuilderNotFinishedError(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    Error caused by not calling `Finish` before calling `Output`. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>

<span class="s2">class </span><span class="s1">EndVectorLengthMismatched(RuntimeError):</span>
    <span class="s3">&quot;&quot;&quot; 
    The number of elements passed to EndVector does not match the number  
    specified in StartVector. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s0"># VtableMetadataFields is the count of metadata fields in each vtable.</span>
<span class="s1">VtableMetadataFields = </span><span class="s4">2</span>
<span class="s0">## @endcond</span>

<span class="s2">class </span><span class="s1">Builder(object):</span>
    <span class="s3">&quot;&quot;&quot; A Builder is used to construct one or more FlatBuffers. 
 
    Typically, Builder objects will be used from code generated by the `flatc` 
    compiler. 
 
    A Builder constructs byte buffers in a last-first manner for simplicity and 
    performance during reading. 
 
    Internally, a Builder is a state machine for creating FlatBuffer objects. 
 
    It holds the following internal state: 
        - Bytes: an array of bytes. 
        - current_vtable: a list of integers. 
        - vtables: a hash of vtable entries. 
 
    Attributes: 
      Bytes: The internal `bytearray` for the Builder. 
      finished: A boolean determining if the Builder has been finalized. 
    &quot;&quot;&quot;</span>

    <span class="s0">## @cond FLATBUFFERS_INTENRAL</span>
    <span class="s1">__slots__ = (</span><span class="s5">&quot;Bytes&quot;</span><span class="s2">, </span><span class="s5">&quot;current_vtable&quot;</span><span class="s2">, </span><span class="s5">&quot;head&quot;</span><span class="s2">, </span><span class="s5">&quot;minalign&quot;</span><span class="s2">, </span><span class="s5">&quot;objectEnd&quot;</span><span class="s2">,</span>
                 <span class="s5">&quot;vtables&quot;</span><span class="s2">, </span><span class="s5">&quot;nested&quot;</span><span class="s2">, </span><span class="s5">&quot;forceDefaults&quot;</span><span class="s2">, </span><span class="s5">&quot;finished&quot;</span><span class="s2">, </span><span class="s5">&quot;vectorNumElems&quot;</span><span class="s2">,</span>
                 <span class="s5">&quot;sharedStrings&quot;</span><span class="s1">)</span>

    <span class="s5">&quot;&quot;&quot;Maximum buffer size constant, in bytes. 
 
    Builder will never allow it's buffer grow over this size. 
    Currently equals 2Gb. 
    &quot;&quot;&quot;</span>
    <span class="s1">MAX_BUFFER_SIZE = </span><span class="s4">2</span><span class="s1">**</span><span class="s4">31</span>
    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">initialSize=</span><span class="s4">1024</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Initializes a Builder of size `initial_size`. 
 
        The internal buffer is grown as needed. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">(</span><span class="s4">0 </span><span class="s1">&lt;= initialSize &lt;= Builder.MAX_BUFFER_SIZE):</span>
            <span class="s1">msg = </span><span class="s5">&quot;flatbuffers: Cannot create Builder larger than 2 gigabytes.&quot;</span>
            <span class="s2">raise </span><span class="s1">BuilderSizeError(msg)</span>

        <span class="s1">self.Bytes = bytearray(initialSize)</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.current_vtable = </span><span class="s2">None</span>
        <span class="s1">self.head = UOffsetTFlags.py_type(initialSize)</span>
        <span class="s1">self.minalign = </span><span class="s4">1</span>
        <span class="s1">self.objectEnd = </span><span class="s2">None</span>
        <span class="s1">self.vtables = {}</span>
        <span class="s1">self.nested = </span><span class="s2">False</span>
        <span class="s1">self.forceDefaults = </span><span class="s2">False</span>
        <span class="s1">self.sharedStrings = {}</span>
        <span class="s0">## @endcond</span>
        <span class="s1">self.finished = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">Output(self):</span>
        <span class="s3">&quot;&quot;&quot;Return the portion of the buffer that has been used for writing data. 
 
        This is the typical way to access the FlatBuffer data inside the 
        builder. If you try to access `Builder.Bytes` directly, you would need 
        to manually index it with `Head()`, since the buffer is constructed 
        backwards. 
 
        It raises BuilderNotFinishedError if the buffer has not been finished 
        with `Finish`. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">self.finished:</span>
            <span class="s2">raise </span><span class="s1">BuilderNotFinishedError()</span>

        <span class="s2">return </span><span class="s1">self.Bytes[self.Head():]</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">StartObject(self</span><span class="s2">, </span><span class="s1">numfields):</span>
        <span class="s3">&quot;&quot;&quot;StartObject initializes bookkeeping for writing a new object.&quot;&quot;&quot;</span>

        <span class="s1">self.assertNotNested()</span>

        <span class="s0"># use 32-bit offsets so that arithmetic doesn't overflow.</span>
        <span class="s1">self.current_vtable = [</span><span class="s4">0 </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range_func(numfields)]</span>
        <span class="s1">self.objectEnd = self.Offset()</span>
        <span class="s1">self.nested = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">WriteVtable(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        WriteVtable serializes the vtable for the current object, if needed. 
 
        Before writing out the vtable, this checks pre-existing vtables for 
        equality to this one. If an equal vtable is found, point the object to 
        the existing vtable and return. 
 
        Because vtable values are sensitive to alignment of object data, not 
        all logically-equal vtables will be deduplicated. 
 
        A vtable has the following format: 
          &lt;VOffsetT: size of the vtable in bytes, including this value&gt; 
          &lt;VOffsetT: size of the object in bytes, including the vtable offset&gt; 
          &lt;VOffsetT: offset for a field&gt; * N, where N is the number of fields 
                     in the schema for this type. Includes deprecated fields. 
        Thus, a vtable is made of 2 + N elements, each VOffsetT bytes wide. 
 
        An object has the following format: 
          &lt;SOffsetT: offset to this object's vtable (may be negative)&gt; 
          &lt;byte: data&gt;+ 
        &quot;&quot;&quot;</span>

        <span class="s0"># Prepend a zero scalar to the object. Later in this function we'll</span>
        <span class="s0"># write an offset here that points to the object's vtable:</span>
        <span class="s1">self.PrependSOffsetTRelative(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">objectOffset = self.Offset()</span>

        <span class="s1">vtKey = []</span>
        <span class="s1">trim = </span><span class="s2">True</span>
        <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">reversed(self.current_vtable):</span>
            <span class="s2">if </span><span class="s1">elem == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">trim:</span>
                    <span class="s2">continue</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">elem = objectOffset - elem</span>
                <span class="s1">trim = </span><span class="s2">False</span>

            <span class="s1">vtKey.append(elem)</span>

        <span class="s1">vtKey = tuple(vtKey)</span>
        <span class="s1">vt2Offset = self.vtables.get(vtKey)</span>
        <span class="s2">if </span><span class="s1">vt2Offset </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Did not find a vtable, so write this one to the buffer.</span>

            <span class="s0"># Write out the current vtable in reverse , because</span>
            <span class="s0"># serialization occurs in last-first order:</span>
            <span class="s1">i = len(self.current_vtable) - </span><span class="s4">1</span>
            <span class="s1">trailing = </span><span class="s4">0</span>
            <span class="s1">trim = </span><span class="s2">True</span>
            <span class="s2">while </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">off = </span><span class="s4">0</span>
                <span class="s1">elem = self.current_vtable[i]</span>
                <span class="s1">i -= </span><span class="s4">1</span>

                <span class="s2">if </span><span class="s1">elem == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">trim:</span>
                        <span class="s1">trailing += </span><span class="s4">1</span>
                        <span class="s2">continue</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s0"># Forward reference to field;</span>
                    <span class="s0"># use 32bit number to ensure no overflow:</span>
                    <span class="s1">off = objectOffset - elem</span>
                    <span class="s1">trim = </span><span class="s2">False</span>

                <span class="s1">self.PrependVOffsetT(off)</span>

            <span class="s0"># The two metadata fields are written last.</span>

            <span class="s0"># First, store the object bytesize:</span>
            <span class="s1">objectSize = UOffsetTFlags.py_type(objectOffset - self.objectEnd)</span>
            <span class="s1">self.PrependVOffsetT(VOffsetTFlags.py_type(objectSize))</span>

            <span class="s0"># Second, store the vtable bytesize:</span>
            <span class="s1">vBytes = len(self.current_vtable) - trailing + VtableMetadataFields</span>
            <span class="s1">vBytes *= N.VOffsetTFlags.bytewidth</span>
            <span class="s1">self.PrependVOffsetT(VOffsetTFlags.py_type(vBytes))</span>

            <span class="s0"># Next, write the offset to the new vtable in the</span>
            <span class="s0"># already-allocated SOffsetT at the beginning of this object:</span>
            <span class="s1">objectStart = SOffsetTFlags.py_type(len(self.Bytes) - objectOffset)</span>
            <span class="s1">encode.Write(packer.soffset</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">objectStart</span><span class="s2">,</span>
                         <span class="s1">SOffsetTFlags.py_type(self.Offset() - objectOffset))</span>

            <span class="s0"># Finally, store this vtable in memory for future</span>
            <span class="s0"># deduplication:</span>
            <span class="s1">self.vtables[vtKey] = self.Offset()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Found a duplicate vtable.</span>
            <span class="s1">objectStart = SOffsetTFlags.py_type(len(self.Bytes) - objectOffset)</span>
            <span class="s1">self.head = UOffsetTFlags.py_type(objectStart)</span>

            <span class="s0"># Write the offset to the found vtable in the</span>
            <span class="s0"># already-allocated SOffsetT at the beginning of this object:</span>
            <span class="s1">encode.Write(packer.soffset</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">self.Head()</span><span class="s2">,</span>
                         <span class="s1">SOffsetTFlags.py_type(vt2Offset - objectOffset))</span>

        <span class="s1">self.current_vtable = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">objectOffset</span>

    <span class="s2">def </span><span class="s1">EndObject(self):</span>
        <span class="s3">&quot;&quot;&quot;EndObject writes data necessary to finish object construction.&quot;&quot;&quot;</span>
        <span class="s1">self.assertNested()</span>
        <span class="s1">self.nested = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">self.WriteVtable()</span>

    <span class="s2">def </span><span class="s1">growByteBuffer(self):</span>
        <span class="s3">&quot;&quot;&quot;Doubles the size of the byteslice, and copies the old data towards 
           the end of the new buffer (since we build the buffer backwards).&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(self.Bytes) == Builder.MAX_BUFFER_SIZE:</span>
            <span class="s1">msg = </span><span class="s5">&quot;flatbuffers: cannot grow buffer beyond 2 gigabytes&quot;</span>
            <span class="s2">raise </span><span class="s1">BuilderSizeError(msg)</span>

        <span class="s1">newSize = min(len(self.Bytes) * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">Builder.MAX_BUFFER_SIZE)</span>
        <span class="s2">if </span><span class="s1">newSize == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">newSize = </span><span class="s4">1</span>
        <span class="s1">bytes2 = bytearray(newSize)</span>
        <span class="s1">bytes2[newSize-len(self.Bytes):] = self.Bytes</span>
        <span class="s1">self.Bytes = bytes2</span>
    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">Head(self):</span>
        <span class="s3">&quot;&quot;&quot;Get the start of useful data in the underlying byte buffer. 
 
        Note: unlike other functions, this value is interpreted as from the 
        left. 
        &quot;&quot;&quot;</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s2">return </span><span class="s1">self.head</span>
        <span class="s0">## @endcond</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">Offset(self):</span>
        <span class="s3">&quot;&quot;&quot;Offset relative to the end of the buffer.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">UOffsetTFlags.py_type(len(self.Bytes) - self.Head())</span>

    <span class="s2">def </span><span class="s1">Pad(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s3">&quot;&quot;&quot;Pad places zeros at the current offset.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range_func(n):</span>
            <span class="s1">self.Place(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">N.Uint8Flags)</span>

    <span class="s2">def </span><span class="s1">Prep(self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">additionalBytes):</span>
        <span class="s3">&quot;&quot;&quot; 
        Prep prepares to write an element of `size` after `additional_bytes` 
        have been written, e.g. if you write a string, you need to align 
        such the int length field is aligned to SizeInt32, and the string 
        data follows it directly. 
        If all you need to do is align, `additionalBytes` will be 0. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Track the biggest thing we've ever aligned to.</span>
        <span class="s2">if </span><span class="s1">size &gt; self.minalign:</span>
            <span class="s1">self.minalign = size</span>

        <span class="s0"># Find the amount of alignment needed such that `size` is properly</span>
        <span class="s0"># aligned after `additionalBytes`:</span>
        <span class="s1">alignSize = (~(len(self.Bytes) - self.Head() + additionalBytes)) + </span><span class="s4">1</span>
        <span class="s1">alignSize &amp;= (size - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0"># Reallocate the buffer if needed:</span>
        <span class="s2">while </span><span class="s1">self.Head() &lt; alignSize+size+additionalBytes:</span>
            <span class="s1">oldBufSize = len(self.Bytes)</span>
            <span class="s1">self.growByteBuffer()</span>
            <span class="s1">updated_head = self.head + len(self.Bytes) - oldBufSize</span>
            <span class="s1">self.head = UOffsetTFlags.py_type(updated_head)</span>
        <span class="s1">self.Pad(alignSize)</span>

    <span class="s2">def </span><span class="s1">PrependSOffsetTRelative(self</span><span class="s2">, </span><span class="s1">off):</span>
        <span class="s3">&quot;&quot;&quot; 
        PrependSOffsetTRelative prepends an SOffsetT, relative to where it 
        will be written. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Ensure alignment is already done:</span>
        <span class="s1">self.Prep(N.SOffsetTFlags.bytewidth</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(off &lt;= self.Offset()):</span>
            <span class="s1">msg = </span><span class="s5">&quot;flatbuffers: Offset arithmetic error.&quot;</span>
            <span class="s2">raise </span><span class="s1">OffsetArithmeticError(msg)</span>
        <span class="s1">off2 = self.Offset() - off + N.SOffsetTFlags.bytewidth</span>
        <span class="s1">self.PlaceSOffsetT(off2)</span>
    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">PrependUOffsetTRelative(self</span><span class="s2">, </span><span class="s1">off):</span>
        <span class="s3">&quot;&quot;&quot;Prepends an unsigned offset into vector data, relative to where it 
        will be written. 
        &quot;&quot;&quot;</span>

        <span class="s0"># Ensure alignment is already done:</span>
        <span class="s1">self.Prep(N.UOffsetTFlags.bytewidth</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">(off &lt;= self.Offset()):</span>
            <span class="s1">msg = </span><span class="s5">&quot;flatbuffers: Offset arithmetic error.&quot;</span>
            <span class="s2">raise </span><span class="s1">OffsetArithmeticError(msg)</span>
        <span class="s1">off2 = self.Offset() - off + N.UOffsetTFlags.bytewidth</span>
        <span class="s1">self.PlaceUOffsetT(off2)</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">StartVector(self</span><span class="s2">, </span><span class="s1">elemSize</span><span class="s2">, </span><span class="s1">numElems</span><span class="s2">, </span><span class="s1">alignment):</span>
        <span class="s3">&quot;&quot;&quot; 
        StartVector initializes bookkeeping for writing a new vector. 
 
        A vector has the following format: 
          - &lt;UOffsetT: number of elements in this vector&gt; 
          - &lt;T: data&gt;+, where T is the type of elements of this vector. 
        &quot;&quot;&quot;</span>

        <span class="s1">self.assertNotNested()</span>
        <span class="s1">self.nested = </span><span class="s2">True</span>
        <span class="s1">self.vectorNumElems = numElems</span>
        <span class="s1">self.Prep(N.Uint32Flags.bytewidth</span><span class="s2">, </span><span class="s1">elemSize*numElems)</span>
        <span class="s1">self.Prep(alignment</span><span class="s2">, </span><span class="s1">elemSize*numElems)  </span><span class="s0"># In case alignment &gt; int.</span>
        <span class="s2">return </span><span class="s1">self.Offset()</span>
    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">EndVector(self</span><span class="s2">, </span><span class="s1">numElems = </span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;EndVector writes data necessary to finish vector construction.&quot;&quot;&quot;</span>

        <span class="s1">self.assertNested()</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.nested = </span><span class="s2">False</span>
        <span class="s0">## @endcond</span>
               
        <span class="s2">if </span><span class="s1">numElems:</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;numElems is deprecated.&quot;</span><span class="s2">, </span>
                          <span class="s1">DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">numElems != self.vectorNumElems:</span>
                <span class="s2">raise </span><span class="s1">EndVectorLengthMismatched();</span>

        <span class="s0"># we already made space for this, so write without PrependUint32</span>
        <span class="s1">self.PlaceUOffsetT(self.vectorNumElems)</span>
        <span class="s1">self.vectorNumElems = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">self.Offset()</span>

    <span class="s2">def </span><span class="s1">CreateSharedString(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s5">'utf-8'</span><span class="s2">, </span><span class="s1">errors=</span><span class="s5">'strict'</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        CreateSharedString checks if the string is already written to the buffer 
        before calling CreateString. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">self.sharedStrings:</span>
            <span class="s2">return </span><span class="s1">self.sharedStrings[s]</span>

        <span class="s1">off = self.CreateString(s</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s1">self.sharedStrings[s] = off</span>

        <span class="s2">return </span><span class="s1">off</span>

    <span class="s2">def </span><span class="s1">CreateString(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s5">'utf-8'</span><span class="s2">, </span><span class="s1">errors=</span><span class="s5">'strict'</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;CreateString writes a null-terminated byte string as a vector.&quot;&quot;&quot;</span>

        <span class="s1">self.assertNotNested()</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.nested = </span><span class="s2">True</span>
        <span class="s0">## @endcond</span>

        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">compat.string_types):</span>
            <span class="s1">x = s.encode(encoding</span><span class="s2">, </span><span class="s1">errors)</span>
        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">compat.binary_types):</span>
            <span class="s1">x = s</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;non-string passed to CreateString&quot;</span><span class="s1">)</span>

        <span class="s1">self.Prep(N.UOffsetTFlags.bytewidth</span><span class="s2">, </span><span class="s1">(len(x)+</span><span class="s4">1</span><span class="s1">)*N.Uint8Flags.bytewidth)</span>
        <span class="s1">self.Place(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">N.Uint8Flags)</span>

        <span class="s1">l = UOffsetTFlags.py_type(len(s))</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.head = UOffsetTFlags.py_type(self.Head() - l)</span>
        <span class="s0">## @endcond</span>
        <span class="s1">self.Bytes[self.Head():self.Head()+l] = x</span>

        <span class="s1">self.vectorNumElems = len(x)</span>
        <span class="s2">return </span><span class="s1">self.EndVector()</span>

    <span class="s2">def </span><span class="s1">CreateByteVector(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;CreateString writes a byte vector.&quot;&quot;&quot;</span>

        <span class="s1">self.assertNotNested()</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.nested = </span><span class="s2">True</span>
        <span class="s0">## @endcond</span>

        <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">compat.binary_types):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;non-byte vector passed to CreateByteVector&quot;</span><span class="s1">)</span>

        <span class="s1">self.Prep(N.UOffsetTFlags.bytewidth</span><span class="s2">, </span><span class="s1">len(x)*N.Uint8Flags.bytewidth)</span>

        <span class="s1">l = UOffsetTFlags.py_type(len(x))</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.head = UOffsetTFlags.py_type(self.Head() - l)</span>
        <span class="s0">## @endcond</span>
        <span class="s1">self.Bytes[self.Head():self.Head()+l] = x</span>

        <span class="s1">self.vectorNumElems = len(x)</span>
        <span class="s2">return </span><span class="s1">self.EndVector()</span>

    <span class="s2">def </span><span class="s1">CreateNumpyVector(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;CreateNumpyVector writes a numpy array into the buffer.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">np </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s0"># Numpy is required for this feature</span>
            <span class="s2">raise </span><span class="s1">NumpyRequiredForThisFeature(</span><span class="s5">&quot;Numpy was not found.&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;non-numpy-ndarray passed to CreateNumpyVector&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">x.dtype.kind </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">'b'</span><span class="s2">, </span><span class="s5">'i'</span><span class="s2">, </span><span class="s5">'u'</span><span class="s2">, </span><span class="s5">'f'</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;numpy-ndarray holds elements of unsupported datatype&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;multidimensional-ndarray passed to CreateNumpyVector&quot;</span><span class="s1">)</span>

        <span class="s1">self.StartVector(x.itemsize</span><span class="s2">, </span><span class="s1">x.size</span><span class="s2">, </span><span class="s1">x.dtype.alignment)</span>

        <span class="s0"># Ensure little endian byte ordering</span>
        <span class="s2">if </span><span class="s1">x.dtype.str[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">&quot;&lt;&quot;</span><span class="s1">:</span>
            <span class="s1">x_lend = x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x_lend = x.byteswap(inplace=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s0"># Calculate total length</span>
        <span class="s1">l = UOffsetTFlags.py_type(x_lend.itemsize * x_lend.size)</span>
        <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
        <span class="s1">self.head = UOffsetTFlags.py_type(self.Head() - l)</span>
        <span class="s0">## @endcond</span>

        <span class="s0"># tobytes ensures c_contiguous ordering</span>
        <span class="s1">self.Bytes[self.Head():self.Head()+l] = x_lend.tobytes(order=</span><span class="s5">'C'</span><span class="s1">)</span>

        <span class="s1">self.vectorNumElems = x.size</span>
        <span class="s2">return </span><span class="s1">self.EndVector()</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">assertNested(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check that we are in the process of building an object. 
        &quot;&quot;&quot;</span>

        <span class="s2">if not </span><span class="s1">self.nested:</span>
            <span class="s2">raise </span><span class="s1">IsNotNestedError()</span>

    <span class="s2">def </span><span class="s1">assertNotNested(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        Check that no other objects are being built while making this 
        object. If not, raise an exception. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.nested:</span>
            <span class="s2">raise </span><span class="s1">IsNestedError()</span>

    <span class="s2">def </span><span class="s1">assertStructIsInline(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s3">&quot;&quot;&quot; 
        Structs are always stored inline, so need to be created right 
        where they are used. You'll get this error if you created it 
        elsewhere. 
        &quot;&quot;&quot;</span>

        <span class="s1">N.enforce_number(obj</span><span class="s2">, </span><span class="s1">N.UOffsetTFlags)</span>
        <span class="s2">if </span><span class="s1">obj != self.Offset():</span>
            <span class="s1">msg = (</span><span class="s5">&quot;flatbuffers: Tried to write a Struct at an Offset that &quot;</span>
                   <span class="s5">&quot;is different from the current Offset of the Builder.&quot;</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">StructIsNotInlineError(msg)</span>

    <span class="s2">def </span><span class="s1">Slot(self</span><span class="s2">, </span><span class="s1">slotnum):</span>
        <span class="s3">&quot;&quot;&quot; 
        Slot sets the vtable key `voffset` to the current location in the 
        buffer. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.assertNested()</span>
        <span class="s1">self.current_vtable[slotnum] = self.Offset()</span>
    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">__Finish(self</span><span class="s2">, </span><span class="s1">rootTable</span><span class="s2">, </span><span class="s1">sizePrefix</span><span class="s2">, </span><span class="s1">file_identifier=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Finish finalizes a buffer, pointing to the given `rootTable`.&quot;&quot;&quot;</span>
        <span class="s1">N.enforce_number(rootTable</span><span class="s2">, </span><span class="s1">N.UOffsetTFlags)</span>

        <span class="s1">prepSize = N.UOffsetTFlags.bytewidth</span>
        <span class="s2">if </span><span class="s1">file_identifier </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">prepSize += N.Int32Flags.bytewidth</span>
        <span class="s2">if </span><span class="s1">sizePrefix:</span>
            <span class="s1">prepSize += N.Int32Flags.bytewidth</span>
        <span class="s1">self.Prep(self.minalign</span><span class="s2">, </span><span class="s1">prepSize)</span>

        <span class="s2">if </span><span class="s1">file_identifier </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.Prep(N.UOffsetTFlags.bytewidth</span><span class="s2">, </span><span class="s1">encode.FILE_IDENTIFIER_LENGTH)</span>

            <span class="s0"># Convert bytes object file_identifier to an array of 4 8-bit integers,</span>
            <span class="s0"># and use big-endian to enforce size compliance.</span>
            <span class="s0"># https://docs.python.org/2/library/struct.html#format-characters</span>
            <span class="s1">file_identifier = N.struct.unpack(</span><span class="s5">&quot;&gt;BBBB&quot;</span><span class="s2">, </span><span class="s1">file_identifier)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(encode.FILE_IDENTIFIER_LENGTH-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s0"># Place the bytes of the file_identifer in reverse order:</span>
                <span class="s1">self.Place(file_identifier[i]</span><span class="s2">, </span><span class="s1">N.Uint8Flags)</span>

        <span class="s1">self.PrependUOffsetTRelative(rootTable)</span>
        <span class="s2">if </span><span class="s1">sizePrefix:</span>
            <span class="s1">size = len(self.Bytes) - self.Head()</span>
            <span class="s1">N.enforce_number(size</span><span class="s2">, </span><span class="s1">N.Int32Flags)</span>
            <span class="s1">self.PrependInt32(size)</span>
        <span class="s1">self.finished = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self.Head()</span>

    <span class="s2">def </span><span class="s1">Finish(self</span><span class="s2">, </span><span class="s1">rootTable</span><span class="s2">, </span><span class="s1">file_identifier=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Finish finalizes a buffer, pointing to the given `rootTable`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__Finish(rootTable</span><span class="s2">, False, </span><span class="s1">file_identifier=file_identifier)</span>

    <span class="s2">def </span><span class="s1">FinishSizePrefixed(self</span><span class="s2">, </span><span class="s1">rootTable</span><span class="s2">, </span><span class="s1">file_identifier=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Finish finalizes a buffer, pointing to the given `rootTable`, 
        with the size prefixed. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__Finish(rootTable</span><span class="s2">, True, </span><span class="s1">file_identifier=file_identifier)</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">Prepend(self</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">off):</span>
        <span class="s1">self.Prep(flags.bytewidth</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.Place(off</span><span class="s2">, </span><span class="s1">flags)</span>

    <span class="s2">def </span><span class="s1">PrependSlot(self</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d):</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">N.enforce_number(x</span><span class="s2">, </span><span class="s1">flags)</span>
        <span class="s2">if </span><span class="s1">d </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">N.enforce_number(d</span><span class="s2">, </span><span class="s1">flags)</span>
        <span class="s2">if </span><span class="s1">x != d </span><span class="s2">or </span><span class="s1">(self.forceDefaults </span><span class="s2">and </span><span class="s1">d </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">self.Prepend(flags</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s1">self.Slot(o)</span>

    <span class="s2">def </span><span class="s1">PrependBoolSlot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.BoolFlags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependByteSlot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Uint8Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependUint8Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Uint8Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependUint16Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Uint16Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependUint32Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Uint32Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependUint64Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Uint64Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependInt8Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Int8Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependInt16Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Int16Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependInt32Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Int32Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependInt64Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Int64Flags</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependFloat32Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Float32Flags</span><span class="s2">,</span>
                                                          <span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependFloat64Slot(self</span><span class="s2">, </span><span class="s1">*args): self.PrependSlot(N.Float64Flags</span><span class="s2">,</span>
                                                          <span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">PrependUOffsetTRelativeSlot(self</span><span class="s2">, </span><span class="s1">o</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d):</span>
        <span class="s3">&quot;&quot;&quot; 
        PrependUOffsetTRelativeSlot prepends an UOffsetT onto the object at 
        vtable slot `o`. If value `x` equals default `d`, then the slot will 
        be set to zero and no other data will be written. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">x != d </span><span class="s2">or </span><span class="s1">self.forceDefaults:</span>
            <span class="s1">self.PrependUOffsetTRelative(x)</span>
            <span class="s1">self.Slot(o)</span>

    <span class="s2">def </span><span class="s1">PrependStructSlot(self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d):</span>
        <span class="s3">&quot;&quot;&quot; 
        PrependStructSlot prepends a struct onto the object at vtable slot `o`. 
        Structs are stored inline, so nothing additional is being added. 
        In generated code, `d` is always 0. 
        &quot;&quot;&quot;</span>

        <span class="s1">N.enforce_number(d</span><span class="s2">, </span><span class="s1">N.UOffsetTFlags)</span>
        <span class="s2">if </span><span class="s1">x != d:</span>
            <span class="s1">self.assertStructIsInline(x)</span>
            <span class="s1">self.Slot(v)</span>

    <span class="s0">## @endcond</span>

    <span class="s2">def </span><span class="s1">PrependBool(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend a `bool` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.BoolFlags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependByte(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend a `byte` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Uint8Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependUint8(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `uint8` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Uint8Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependUint16(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `uint16` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Uint16Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependUint32(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `uint32` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Uint32Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependUint64(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `uint64` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Uint64Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependInt8(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `int8` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Int8Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependInt16(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `int16` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Int16Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependInt32(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `int32` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Int32Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependInt64(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend an `int64` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Int64Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependFloat32(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend a `float32` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Float32Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PrependFloat64(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;Prepend a `float64` to the Builder buffer. 
 
        Note: aligns and checks for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.Prepend(N.Float64Flags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">ForceDefaults(self</span><span class="s2">, </span><span class="s1">forceDefaults):</span>
        <span class="s3">&quot;&quot;&quot; 
        In order to save space, fields that are set to their default value 
        don't get serialized into the buffer. Forcing defaults provides a 
        way to manually disable this optimization. When set to `True`, will 
        always serialize default values. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.forceDefaults = forceDefaults</span>

<span class="s0">##############################################################</span>

    <span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
    <span class="s2">def </span><span class="s1">PrependVOffsetT(self</span><span class="s2">, </span><span class="s1">x): self.Prepend(N.VOffsetTFlags</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">Place(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">flags):</span>
        <span class="s3">&quot;&quot;&quot; 
        Place prepends a value specified by `flags` to the Builder, 
        without checking for available space. 
        &quot;&quot;&quot;</span>

        <span class="s1">N.enforce_number(x</span><span class="s2">, </span><span class="s1">flags)</span>
        <span class="s1">self.head = self.head - flags.bytewidth</span>
        <span class="s1">encode.Write(flags.packer_type</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">self.Head()</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PlaceVOffsetT(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;PlaceVOffsetT prepends a VOffsetT to the Builder, without checking 
        for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">N.enforce_number(x</span><span class="s2">, </span><span class="s1">N.VOffsetTFlags)</span>
        <span class="s1">self.head = self.head - N.VOffsetTFlags.bytewidth</span>
        <span class="s1">encode.Write(packer.voffset</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">self.Head()</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PlaceSOffsetT(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;PlaceSOffsetT prepends a SOffsetT to the Builder, without checking 
        for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">N.enforce_number(x</span><span class="s2">, </span><span class="s1">N.SOffsetTFlags)</span>
        <span class="s1">self.head = self.head - N.SOffsetTFlags.bytewidth</span>
        <span class="s1">encode.Write(packer.soffset</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">self.Head()</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">PlaceUOffsetT(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s3">&quot;&quot;&quot;PlaceUOffsetT prepends a UOffsetT to the Builder, without checking 
        for space. 
        &quot;&quot;&quot;</span>
        <span class="s1">N.enforce_number(x</span><span class="s2">, </span><span class="s1">N.UOffsetTFlags)</span>
        <span class="s1">self.head = self.head - N.UOffsetTFlags.bytewidth</span>
        <span class="s1">encode.Write(packer.uoffset</span><span class="s2">, </span><span class="s1">self.Bytes</span><span class="s2">, </span><span class="s1">self.Head()</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s0">## @endcond</span>

<span class="s0">## @cond FLATBUFFERS_INTERNAL</span>
<span class="s2">def </span><span class="s1">vtableEqual(a</span><span class="s2">, </span><span class="s1">objectStart</span><span class="s2">, </span><span class="s1">b):</span>
    <span class="s3">&quot;&quot;&quot;vtableEqual compares an unwritten vtable to a written vtable.&quot;&quot;&quot;</span>

    <span class="s1">N.enforce_number(objectStart</span><span class="s2">, </span><span class="s1">N.UOffsetTFlags)</span>

    <span class="s2">if </span><span class="s1">len(a) * N.VOffsetTFlags.bytewidth != len(b):</span>
        <span class="s2">return False</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">enumerate(a):</span>
        <span class="s1">x = encode.Get(packer.voffset</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">i * N.VOffsetTFlags.bytewidth)</span>

        <span class="s0"># Skip vtable entries that indicate a default value.</span>
        <span class="s2">if </span><span class="s1">x == </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">elem == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">pass</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = objectStart - elem</span>
            <span class="s2">if </span><span class="s1">x != y:</span>
                <span class="s2">return False</span>
    <span class="s2">return True</span>
<span class="s0">## @endcond</span>
<span class="s0">## @}</span>
</pre>
</body>
</html>