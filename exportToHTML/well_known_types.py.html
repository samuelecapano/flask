<html>
<head>
<title>well_known_types.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
well_known_types.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0"># https://developers.google.com/protocol-buffers/</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0">#     * Redistributions of source code must retain the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#     * Redistributions in binary form must reproduce the above</span>
<span class="s0"># copyright notice, this list of conditions and the following disclaimer</span>
<span class="s0"># in the documentation and/or other materials provided with the</span>
<span class="s0"># distribution.</span>
<span class="s0">#     * Neither the name of Google Inc. nor the names of its</span>
<span class="s0"># contributors may be used to endorse or promote products derived from</span>
<span class="s0"># this software without specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">&quot;&quot;&quot;Contains well known classes. 
 
This files defines well known classes which need extra maintenance including: 
  - Any 
  - Duration 
  - FieldMask 
  - Struct 
  - Timestamp 
&quot;&quot;&quot;</span>

<span class="s1">__author__ = </span><span class="s3">'jieluo@google.com (Jie Luo)'</span>

<span class="s4">import </span><span class="s1">calendar</span>
<span class="s4">import </span><span class="s1">collections.abc</span>
<span class="s4">import </span><span class="s1">datetime</span>

<span class="s4">from </span><span class="s1">google.protobuf.descriptor </span><span class="s4">import </span><span class="s1">FieldDescriptor</span>

<span class="s1">_TIMESTAMPFOMAT = </span><span class="s3">'%Y-%m-%dT%H:%M:%S'</span>
<span class="s1">_NANOS_PER_SECOND = </span><span class="s5">1000000000</span>
<span class="s1">_NANOS_PER_MILLISECOND = </span><span class="s5">1000000</span>
<span class="s1">_NANOS_PER_MICROSECOND = </span><span class="s5">1000</span>
<span class="s1">_MILLIS_PER_SECOND = </span><span class="s5">1000</span>
<span class="s1">_MICROS_PER_SECOND = </span><span class="s5">1000000</span>
<span class="s1">_SECONDS_PER_DAY = </span><span class="s5">24 </span><span class="s1">* </span><span class="s5">3600</span>
<span class="s1">_DURATION_SECONDS_MAX = </span><span class="s5">315576000000</span>


<span class="s4">class </span><span class="s1">Any(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for Any Message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">Pack(self</span><span class="s4">, </span><span class="s1">msg</span><span class="s4">, </span><span class="s1">type_url_prefix=</span><span class="s3">'type.googleapis.com/'</span><span class="s4">,</span>
           <span class="s1">deterministic=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Packs the specified message into current Any message.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">len(type_url_prefix) &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">type_url_prefix[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s3">'/'</span><span class="s1">:</span>
      <span class="s1">self.type_url = </span><span class="s3">'%s/%s' </span><span class="s1">% (type_url_prefix</span><span class="s4">, </span><span class="s1">msg.DESCRIPTOR.full_name)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">self.type_url = </span><span class="s3">'%s%s' </span><span class="s1">% (type_url_prefix</span><span class="s4">, </span><span class="s1">msg.DESCRIPTOR.full_name)</span>
    <span class="s1">self.value = msg.SerializeToString(deterministic=deterministic)</span>

  <span class="s4">def </span><span class="s1">Unpack(self</span><span class="s4">, </span><span class="s1">msg):</span>
    <span class="s2">&quot;&quot;&quot;Unpacks the current Any message into specified message.&quot;&quot;&quot;</span>
    <span class="s1">descriptor = msg.DESCRIPTOR</span>
    <span class="s4">if not </span><span class="s1">self.Is(descriptor):</span>
      <span class="s4">return False</span>
    <span class="s1">msg.ParseFromString(self.value)</span>
    <span class="s4">return True</span>

  <span class="s4">def </span><span class="s1">TypeName(self):</span>
    <span class="s2">&quot;&quot;&quot;Returns the protobuf type name of the inner message.&quot;&quot;&quot;</span>
    <span class="s0"># Only last part is to be used: b/25630112</span>
    <span class="s4">return </span><span class="s1">self.type_url.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

  <span class="s4">def </span><span class="s1">Is(self</span><span class="s4">, </span><span class="s1">descriptor):</span>
    <span class="s2">&quot;&quot;&quot;Checks if this Any represents the given protobuf type.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s3">'/' </span><span class="s4">in </span><span class="s1">self.type_url </span><span class="s4">and </span><span class="s1">self.TypeName() == descriptor.full_name</span>


<span class="s1">_EPOCH_DATETIME_NAIVE = datetime.datetime.utcfromtimestamp(</span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">_EPOCH_DATETIME_AWARE = datetime.datetime.fromtimestamp(</span>
    <span class="s5">0</span><span class="s4">, </span><span class="s1">tz=datetime.timezone.utc)</span>


<span class="s4">class </span><span class="s1">Timestamp(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for Timestamp message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">ToJsonString(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to RFC 3339 date string format. 
 
    Returns: 
      A string converted from timestamp. The string is always Z-normalized 
      and uses 3, 6 or 9 fractional digits as required to represent the 
      exact time. Example of the return format: '1972-01-01T10:00:20.021Z' 
    &quot;&quot;&quot;</span>
    <span class="s1">nanos = self.nanos % _NANOS_PER_SECOND</span>
    <span class="s1">total_sec = self.seconds + (self.nanos - nanos) // _NANOS_PER_SECOND</span>
    <span class="s1">seconds = total_sec % _SECONDS_PER_DAY</span>
    <span class="s1">days = (total_sec - seconds) // _SECONDS_PER_DAY</span>
    <span class="s1">dt = datetime.datetime(</span><span class="s5">1970</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">) + datetime.timedelta(days</span><span class="s4">, </span><span class="s1">seconds)</span>

    <span class="s1">result = dt.isoformat()</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e9</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># If there are 0 fractional digits, the fractional</span>
      <span class="s0"># point '.' should be omitted when serializing.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'Z'</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e6</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># Serialize 3 fractional digits.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%03dZ' </span><span class="s1">% (nanos / </span><span class="s5">1e6</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e3</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># Serialize 6 fractional digits.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%06dZ' </span><span class="s1">% (nanos / </span><span class="s5">1e3</span><span class="s1">)</span>
    <span class="s0"># Serialize 9 fractional digits.</span>
    <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%09dZ' </span><span class="s1">% nanos</span>

  <span class="s4">def </span><span class="s1">FromJsonString(self</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Parse a RFC 3339 date string format to Timestamp. 
 
    Args: 
      value: A date string. Any fractional digits (or none) and any offset are 
          accepted as long as they fit into nano-seconds precision. 
          Example of accepted format: '1972-01-01T10:00:20.021-05:00' 
 
    Raises: 
      ValueError: On parsing problems. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Timestamp JSON value not a string: {!r}'</span><span class="s1">.format(value))</span>
    <span class="s1">timezone_offset = value.find(</span><span class="s3">'Z'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">timezone_offset == -</span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">timezone_offset = value.find(</span><span class="s3">'+'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">timezone_offset == -</span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">timezone_offset = value.rfind(</span><span class="s3">'-'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">timezone_offset == -</span><span class="s5">1</span><span class="s1">:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Failed to parse timestamp: missing valid timezone offset.'</span><span class="s1">)</span>
    <span class="s1">time_value = value[</span><span class="s5">0</span><span class="s1">:timezone_offset]</span>
    <span class="s0"># Parse datetime and nanos.</span>
    <span class="s1">point_position = time_value.find(</span><span class="s3">'.'</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">point_position == -</span><span class="s5">1</span><span class="s1">:</span>
      <span class="s1">second_value = time_value</span>
      <span class="s1">nano_value = </span><span class="s3">''</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">second_value = time_value[:point_position]</span>
      <span class="s1">nano_value = time_value[point_position + </span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s4">if </span><span class="s3">'t' </span><span class="s4">in </span><span class="s1">second_value:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'time data </span><span class="s4">\'</span><span class="s3">{0}</span><span class="s4">\' </span><span class="s3">does not match format </span><span class="s4">\'</span><span class="s3">%Y-%m-%dT%H:%M:%S</span><span class="s4">\'</span><span class="s3">, '</span>
          <span class="s3">'lowercase </span><span class="s4">\'</span><span class="s3">t</span><span class="s4">\' </span><span class="s3">is not accepted'</span><span class="s1">.format(second_value))</span>
    <span class="s1">date_object = datetime.datetime.strptime(second_value</span><span class="s4">, </span><span class="s1">_TIMESTAMPFOMAT)</span>
    <span class="s1">td = date_object - datetime.datetime(</span><span class="s5">1970</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">seconds = td.seconds + td.days * _SECONDS_PER_DAY</span>
    <span class="s4">if </span><span class="s1">len(nano_value) &gt; </span><span class="s5">9</span><span class="s1">:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Failed to parse Timestamp: nanos {0} more than '</span>
          <span class="s3">'9 fractional digits.'</span><span class="s1">.format(nano_value))</span>
    <span class="s4">if </span><span class="s1">nano_value:</span>
      <span class="s1">nanos = round(float(</span><span class="s3">'0.' </span><span class="s1">+ nano_value) * </span><span class="s5">1e9</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">nanos = </span><span class="s5">0</span>
    <span class="s0"># Parse timezone offsets.</span>
    <span class="s4">if </span><span class="s1">value[timezone_offset] == </span><span class="s3">'Z'</span><span class="s1">:</span>
      <span class="s4">if </span><span class="s1">len(value) != timezone_offset + </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Failed to parse timestamp: invalid trailing'</span>
                         <span class="s3">' data {0}.'</span><span class="s1">.format(value))</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">timezone = value[timezone_offset:]</span>
      <span class="s1">pos = timezone.find(</span><span class="s3">':'</span><span class="s1">)</span>
      <span class="s4">if </span><span class="s1">pos == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span>
            <span class="s3">'Invalid timezone offset value: {0}.'</span><span class="s1">.format(timezone))</span>
      <span class="s4">if </span><span class="s1">timezone[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'+'</span><span class="s1">:</span>
        <span class="s1">seconds -= (int(timezone[</span><span class="s5">1</span><span class="s1">:pos])*</span><span class="s5">60</span><span class="s1">+int(timezone[pos+</span><span class="s5">1</span><span class="s1">:]))*</span><span class="s5">60</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">seconds += (int(timezone[</span><span class="s5">1</span><span class="s1">:pos])*</span><span class="s5">60</span><span class="s1">+int(timezone[pos+</span><span class="s5">1</span><span class="s1">:]))*</span><span class="s5">60</span>
    <span class="s0"># Set seconds and nanos</span>
    <span class="s1">self.seconds = int(seconds)</span>
    <span class="s1">self.nanos = int(nanos)</span>

  <span class="s4">def </span><span class="s1">GetCurrentTime(self):</span>
    <span class="s2">&quot;&quot;&quot;Get the current UTC into Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self.FromDatetime(datetime.datetime.utcnow())</span>

  <span class="s4">def </span><span class="s1">ToNanoseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to nanoseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">self.seconds * _NANOS_PER_SECOND + self.nanos</span>

  <span class="s4">def </span><span class="s1">ToMicroseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to microseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">(self.seconds * _MICROS_PER_SECOND +</span>
            <span class="s1">self.nanos // _NANOS_PER_MICROSECOND)</span>

  <span class="s4">def </span><span class="s1">ToMilliseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to milliseconds since epoch.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">(self.seconds * _MILLIS_PER_SECOND +</span>
            <span class="s1">self.nanos // _NANOS_PER_MILLISECOND)</span>

  <span class="s4">def </span><span class="s1">ToSeconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to seconds since epoch.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">self.seconds</span>

  <span class="s4">def </span><span class="s1">FromNanoseconds(self</span><span class="s4">, </span><span class="s1">nanos):</span>
    <span class="s2">&quot;&quot;&quot;Converts nanoseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self.seconds = nanos // _NANOS_PER_SECOND</span>
    <span class="s1">self.nanos = nanos % _NANOS_PER_SECOND</span>

  <span class="s4">def </span><span class="s1">FromMicroseconds(self</span><span class="s4">, </span><span class="s1">micros):</span>
    <span class="s2">&quot;&quot;&quot;Converts microseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self.seconds = micros // _MICROS_PER_SECOND</span>
    <span class="s1">self.nanos = (micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND</span>

  <span class="s4">def </span><span class="s1">FromMilliseconds(self</span><span class="s4">, </span><span class="s1">millis):</span>
    <span class="s2">&quot;&quot;&quot;Converts milliseconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self.seconds = millis // _MILLIS_PER_SECOND</span>
    <span class="s1">self.nanos = (millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND</span>

  <span class="s4">def </span><span class="s1">FromSeconds(self</span><span class="s4">, </span><span class="s1">seconds):</span>
    <span class="s2">&quot;&quot;&quot;Converts seconds since epoch to Timestamp.&quot;&quot;&quot;</span>
    <span class="s1">self.seconds = seconds</span>
    <span class="s1">self.nanos = </span><span class="s5">0</span>

  <span class="s4">def </span><span class="s1">ToDatetime(self</span><span class="s4">, </span><span class="s1">tzinfo=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Converts Timestamp to a datetime. 
 
    Args: 
      tzinfo: A datetime.tzinfo subclass; defaults to None. 
 
    Returns: 
      If tzinfo is None, returns a timezone-naive UTC datetime (with no timezone 
      information, i.e. not aware that it's UTC). 
 
      Otherwise, returns a timezone-aware datetime in the input timezone. 
    &quot;&quot;&quot;</span>
    <span class="s1">delta = datetime.timedelta(</span>
        <span class="s1">seconds=self.seconds</span><span class="s4">,</span>
        <span class="s1">microseconds=_RoundTowardZero(self.nanos</span><span class="s4">, </span><span class="s1">_NANOS_PER_MICROSECOND))</span>
    <span class="s4">if </span><span class="s1">tzinfo </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">_EPOCH_DATETIME_NAIVE + delta</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">_EPOCH_DATETIME_AWARE.astimezone(tzinfo) + delta</span>

  <span class="s4">def </span><span class="s1">FromDatetime(self</span><span class="s4">, </span><span class="s1">dt):</span>
    <span class="s2">&quot;&quot;&quot;Converts datetime to Timestamp. 
 
    Args: 
      dt: A datetime. If it's timezone-naive, it's assumed to be in UTC. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Using this guide: http://wiki.python.org/moin/WorkingWithTime</span>
    <span class="s0"># And this conversion guide: http://docs.python.org/library/time.html</span>

    <span class="s0"># Turn the date parameter into a tuple (struct_time) that can then be</span>
    <span class="s0"># manipulated into a long value of seconds.  During the conversion from</span>
    <span class="s0"># struct_time to long, the source date in UTC, and so it follows that the</span>
    <span class="s0"># correct transformation is calendar.timegm()</span>
    <span class="s1">self.seconds = calendar.timegm(dt.utctimetuple())</span>
    <span class="s1">self.nanos = dt.microsecond * _NANOS_PER_MICROSECOND</span>


<span class="s4">class </span><span class="s1">Duration(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for Duration message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">ToJsonString(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Duration to string format. 
 
    Returns: 
      A string converted from self. The string format will contains 
      3, 6, or 9 fractional digits depending on the precision required to 
      represent the exact Duration value. For example: &quot;1s&quot;, &quot;1.010s&quot;, 
      &quot;1.000000100s&quot;, &quot;-3.100s&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">_CheckDurationValid(self.seconds</span><span class="s4">, </span><span class="s1">self.nanos)</span>
    <span class="s4">if </span><span class="s1">self.seconds &lt; </span><span class="s5">0 </span><span class="s4">or </span><span class="s1">self.nanos &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">result = </span><span class="s3">'-'</span>
      <span class="s1">seconds = - self.seconds + int((</span><span class="s5">0 </span><span class="s1">- self.nanos) // </span><span class="s5">1e9</span><span class="s1">)</span>
      <span class="s1">nanos = (</span><span class="s5">0 </span><span class="s1">- self.nanos) % </span><span class="s5">1e9</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">result = </span><span class="s3">''</span>
      <span class="s1">seconds = self.seconds + int(self.nanos // </span><span class="s5">1e9</span><span class="s1">)</span>
      <span class="s1">nanos = self.nanos % </span><span class="s5">1e9</span>
    <span class="s1">result += </span><span class="s3">'%d' </span><span class="s1">% seconds</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e9</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># If there are 0 fractional digits, the fractional</span>
      <span class="s0"># point '.' should be omitted when serializing.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'s'</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e6</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># Serialize 3 fractional digits.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%03ds' </span><span class="s1">% (nanos / </span><span class="s5">1e6</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">(nanos % </span><span class="s5">1e3</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s0"># Serialize 6 fractional digits.</span>
      <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%06ds' </span><span class="s1">% (nanos / </span><span class="s5">1e3</span><span class="s1">)</span>
    <span class="s0"># Serialize 9 fractional digits.</span>
    <span class="s4">return </span><span class="s1">result + </span><span class="s3">'.%09ds' </span><span class="s1">% nanos</span>

  <span class="s4">def </span><span class="s1">FromJsonString(self</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Converts a string to Duration. 
 
    Args: 
      value: A string to be converted. The string must end with 's'. Any 
          fractional digits (or none) are accepted as long as they fit into 
          precision. For example: &quot;1s&quot;, &quot;1.01s&quot;, &quot;1.0000001s&quot;, &quot;-3.100s 
 
    Raises: 
      ValueError: On parsing problems. 
    &quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Duration JSON value not a string: {!r}'</span><span class="s1">.format(value))</span>
    <span class="s4">if </span><span class="s1">len(value) &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">value[-</span><span class="s5">1</span><span class="s1">] != </span><span class="s3">'s'</span><span class="s1">:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Duration must end with letter &quot;s&quot;: {0}.'</span><span class="s1">.format(value))</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">pos = value.find(</span><span class="s3">'.'</span><span class="s1">)</span>
      <span class="s4">if </span><span class="s1">pos == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">seconds = int(value[:-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">nanos = </span><span class="s5">0</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">seconds = int(value[:pos])</span>
        <span class="s4">if </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'-'</span><span class="s1">:</span>
          <span class="s1">nanos = int(round(float(</span><span class="s3">'-0{0}'</span><span class="s1">.format(value[pos: -</span><span class="s5">1</span><span class="s1">])) *</span><span class="s5">1e9</span><span class="s1">))</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s1">nanos = int(round(float(</span><span class="s3">'0{0}'</span><span class="s1">.format(value[pos: -</span><span class="s5">1</span><span class="s1">])) *</span><span class="s5">1e9</span><span class="s1">))</span>
      <span class="s1">_CheckDurationValid(seconds</span><span class="s4">, </span><span class="s1">nanos)</span>
      <span class="s1">self.seconds = seconds</span>
      <span class="s1">self.nanos = nanos</span>
    <span class="s4">except </span><span class="s1">ValueError </span><span class="s4">as </span><span class="s1">e:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Couldn</span><span class="s4">\'</span><span class="s3">t parse duration: {0} : {1}.'</span><span class="s1">.format(value</span><span class="s4">, </span><span class="s1">e))</span>

  <span class="s4">def </span><span class="s1">ToNanoseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to nanoseconds.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">self.seconds * _NANOS_PER_SECOND + self.nanos</span>

  <span class="s4">def </span><span class="s1">ToMicroseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to microseconds.&quot;&quot;&quot;</span>
    <span class="s1">micros = _RoundTowardZero(self.nanos</span><span class="s4">, </span><span class="s1">_NANOS_PER_MICROSECOND)</span>
    <span class="s4">return </span><span class="s1">self.seconds * _MICROS_PER_SECOND + micros</span>

  <span class="s4">def </span><span class="s1">ToMilliseconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to milliseconds.&quot;&quot;&quot;</span>
    <span class="s1">millis = _RoundTowardZero(self.nanos</span><span class="s4">, </span><span class="s1">_NANOS_PER_MILLISECOND)</span>
    <span class="s4">return </span><span class="s1">self.seconds * _MILLIS_PER_SECOND + millis</span>

  <span class="s4">def </span><span class="s1">ToSeconds(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts a Duration to seconds.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">self.seconds</span>

  <span class="s4">def </span><span class="s1">FromNanoseconds(self</span><span class="s4">, </span><span class="s1">nanos):</span>
    <span class="s2">&quot;&quot;&quot;Converts nanoseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self._NormalizeDuration(nanos // _NANOS_PER_SECOND</span><span class="s4">,</span>
                            <span class="s1">nanos % _NANOS_PER_SECOND)</span>

  <span class="s4">def </span><span class="s1">FromMicroseconds(self</span><span class="s4">, </span><span class="s1">micros):</span>
    <span class="s2">&quot;&quot;&quot;Converts microseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self._NormalizeDuration(</span>
        <span class="s1">micros // _MICROS_PER_SECOND</span><span class="s4">,</span>
        <span class="s1">(micros % _MICROS_PER_SECOND) * _NANOS_PER_MICROSECOND)</span>

  <span class="s4">def </span><span class="s1">FromMilliseconds(self</span><span class="s4">, </span><span class="s1">millis):</span>
    <span class="s2">&quot;&quot;&quot;Converts milliseconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self._NormalizeDuration(</span>
        <span class="s1">millis // _MILLIS_PER_SECOND</span><span class="s4">,</span>
        <span class="s1">(millis % _MILLIS_PER_SECOND) * _NANOS_PER_MILLISECOND)</span>

  <span class="s4">def </span><span class="s1">FromSeconds(self</span><span class="s4">, </span><span class="s1">seconds):</span>
    <span class="s2">&quot;&quot;&quot;Converts seconds to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self.seconds = seconds</span>
    <span class="s1">self.nanos = </span><span class="s5">0</span>

  <span class="s4">def </span><span class="s1">ToTimedelta(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts Duration to timedelta.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">datetime.timedelta(</span>
        <span class="s1">seconds=self.seconds</span><span class="s4">, </span><span class="s1">microseconds=_RoundTowardZero(</span>
            <span class="s1">self.nanos</span><span class="s4">, </span><span class="s1">_NANOS_PER_MICROSECOND))</span>

  <span class="s4">def </span><span class="s1">FromTimedelta(self</span><span class="s4">, </span><span class="s1">td):</span>
    <span class="s2">&quot;&quot;&quot;Converts timedelta to Duration.&quot;&quot;&quot;</span>
    <span class="s1">self._NormalizeDuration(td.seconds + td.days * _SECONDS_PER_DAY</span><span class="s4">,</span>
                            <span class="s1">td.microseconds * _NANOS_PER_MICROSECOND)</span>

  <span class="s4">def </span><span class="s1">_NormalizeDuration(self</span><span class="s4">, </span><span class="s1">seconds</span><span class="s4">, </span><span class="s1">nanos):</span>
    <span class="s2">&quot;&quot;&quot;Set Duration by seconds and nanos.&quot;&quot;&quot;</span>
    <span class="s0"># Force nanos to be negative if the duration is negative.</span>
    <span class="s4">if </span><span class="s1">seconds &lt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">nanos &gt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">seconds += </span><span class="s5">1</span>
      <span class="s1">nanos -= _NANOS_PER_SECOND</span>
    <span class="s1">self.seconds = seconds</span>
    <span class="s1">self.nanos = nanos</span>


<span class="s4">def </span><span class="s1">_CheckDurationValid(seconds</span><span class="s4">, </span><span class="s1">nanos):</span>
  <span class="s4">if </span><span class="s1">seconds &lt; -_DURATION_SECONDS_MAX </span><span class="s4">or </span><span class="s1">seconds &gt; _DURATION_SECONDS_MAX:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'Duration is not valid: Seconds {0} must be in range '</span>
        <span class="s3">'[-315576000000, 315576000000].'</span><span class="s1">.format(seconds))</span>
  <span class="s4">if </span><span class="s1">nanos &lt;= -_NANOS_PER_SECOND </span><span class="s4">or </span><span class="s1">nanos &gt;= _NANOS_PER_SECOND:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'Duration is not valid: Nanos {0} must be in range '</span>
        <span class="s3">'[-999999999, 999999999].'</span><span class="s1">.format(nanos))</span>
  <span class="s4">if </span><span class="s1">(nanos &lt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">seconds &gt; </span><span class="s5">0</span><span class="s1">) </span><span class="s4">or </span><span class="s1">(nanos &gt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">seconds &lt; </span><span class="s5">0</span><span class="s1">):</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span>
        <span class="s3">'Duration is not valid: Sign mismatch.'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_RoundTowardZero(value</span><span class="s4">, </span><span class="s1">divider):</span>
  <span class="s2">&quot;&quot;&quot;Truncates the remainder part after division.&quot;&quot;&quot;</span>
  <span class="s0"># For some languages, the sign of the remainder is implementation</span>
  <span class="s0"># dependent if any of the operands is negative. Here we enforce</span>
  <span class="s0"># &quot;rounded toward zero&quot; semantics. For example, for (-5) / 2 an</span>
  <span class="s0"># implementation may give -3 as the result with the remainder being</span>
  <span class="s0"># 1. This function ensures we always return -2 (closer to zero).</span>
  <span class="s1">result = value // divider</span>
  <span class="s1">remainder = value % divider</span>
  <span class="s4">if </span><span class="s1">result &lt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">remainder &gt; </span><span class="s5">0</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">result + </span><span class="s5">1</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">result</span>


<span class="s4">class </span><span class="s1">FieldMask(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for FieldMask message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">ToJsonString(self):</span>
    <span class="s2">&quot;&quot;&quot;Converts FieldMask to string according to proto3 JSON spec.&quot;&quot;&quot;</span>
    <span class="s1">camelcase_paths = []</span>
    <span class="s4">for </span><span class="s1">path </span><span class="s4">in </span><span class="s1">self.paths:</span>
      <span class="s1">camelcase_paths.append(_SnakeCaseToCamelCase(path))</span>
    <span class="s4">return </span><span class="s3">','</span><span class="s1">.join(camelcase_paths)</span>

  <span class="s4">def </span><span class="s1">FromJsonString(self</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Converts string to FieldMask according to proto3 JSON spec.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'FieldMask JSON value not a string: {!r}'</span><span class="s1">.format(value))</span>
    <span class="s1">self.Clear()</span>
    <span class="s4">if </span><span class="s1">value:</span>
      <span class="s4">for </span><span class="s1">path </span><span class="s4">in </span><span class="s1">value.split(</span><span class="s3">','</span><span class="s1">):</span>
        <span class="s1">self.paths.append(_CamelCaseToSnakeCase(path))</span>

  <span class="s4">def </span><span class="s1">IsValidForDescriptor(self</span><span class="s4">, </span><span class="s1">message_descriptor):</span>
    <span class="s2">&quot;&quot;&quot;Checks whether the FieldMask is valid for Message Descriptor.&quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">path </span><span class="s4">in </span><span class="s1">self.paths:</span>
      <span class="s4">if not </span><span class="s1">_IsValidPath(message_descriptor</span><span class="s4">, </span><span class="s1">path):</span>
        <span class="s4">return False</span>
    <span class="s4">return True</span>

  <span class="s4">def </span><span class="s1">AllFieldsFromDescriptor(self</span><span class="s4">, </span><span class="s1">message_descriptor):</span>
    <span class="s2">&quot;&quot;&quot;Gets all direct fields of Message Descriptor to FieldMask.&quot;&quot;&quot;</span>
    <span class="s1">self.Clear()</span>
    <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">message_descriptor.fields:</span>
      <span class="s1">self.paths.append(field.name)</span>

  <span class="s4">def </span><span class="s1">CanonicalFormFromMask(self</span><span class="s4">, </span><span class="s1">mask):</span>
    <span class="s2">&quot;&quot;&quot;Converts a FieldMask to the canonical form. 
 
    Removes paths that are covered by another path. For example, 
    &quot;foo.bar&quot; is covered by &quot;foo&quot; and will be removed if &quot;foo&quot; 
    is also in the FieldMask. Then sorts all paths in alphabetical order. 
 
    Args: 
      mask: The original FieldMask to be converted. 
    &quot;&quot;&quot;</span>
    <span class="s1">tree = _FieldMaskTree(mask)</span>
    <span class="s1">tree.ToFieldMask(self)</span>

  <span class="s4">def </span><span class="s1">Union(self</span><span class="s4">, </span><span class="s1">mask1</span><span class="s4">, </span><span class="s1">mask2):</span>
    <span class="s2">&quot;&quot;&quot;Merges mask1 and mask2 into this FieldMask.&quot;&quot;&quot;</span>
    <span class="s1">_CheckFieldMaskMessage(mask1)</span>
    <span class="s1">_CheckFieldMaskMessage(mask2)</span>
    <span class="s1">tree = _FieldMaskTree(mask1)</span>
    <span class="s1">tree.MergeFromFieldMask(mask2)</span>
    <span class="s1">tree.ToFieldMask(self)</span>

  <span class="s4">def </span><span class="s1">Intersect(self</span><span class="s4">, </span><span class="s1">mask1</span><span class="s4">, </span><span class="s1">mask2):</span>
    <span class="s2">&quot;&quot;&quot;Intersects mask1 and mask2 into this FieldMask.&quot;&quot;&quot;</span>
    <span class="s1">_CheckFieldMaskMessage(mask1)</span>
    <span class="s1">_CheckFieldMaskMessage(mask2)</span>
    <span class="s1">tree = _FieldMaskTree(mask1)</span>
    <span class="s1">intersection = _FieldMaskTree()</span>
    <span class="s4">for </span><span class="s1">path </span><span class="s4">in </span><span class="s1">mask2.paths:</span>
      <span class="s1">tree.IntersectPath(path</span><span class="s4">, </span><span class="s1">intersection)</span>
    <span class="s1">intersection.ToFieldMask(self)</span>

  <span class="s4">def </span><span class="s1">MergeMessage(</span>
      <span class="s1">self</span><span class="s4">, </span><span class="s1">source</span><span class="s4">, </span><span class="s1">destination</span><span class="s4">,</span>
      <span class="s1">replace_message_field=</span><span class="s4">False, </span><span class="s1">replace_repeated_field=</span><span class="s4">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Merges fields specified in FieldMask from source to destination. 
 
    Args: 
      source: Source message. 
      destination: The destination message to be merged into. 
      replace_message_field: Replace message field if True. Merge message 
          field if False. 
      replace_repeated_field: Replace repeated field if True. Append 
          elements of repeated field if False. 
    &quot;&quot;&quot;</span>
    <span class="s1">tree = _FieldMaskTree(self)</span>
    <span class="s1">tree.MergeMessage(</span>
        <span class="s1">source</span><span class="s4">, </span><span class="s1">destination</span><span class="s4">, </span><span class="s1">replace_message_field</span><span class="s4">, </span><span class="s1">replace_repeated_field)</span>


<span class="s4">def </span><span class="s1">_IsValidPath(message_descriptor</span><span class="s4">, </span><span class="s1">path):</span>
  <span class="s2">&quot;&quot;&quot;Checks whether the path is valid for Message Descriptor.&quot;&quot;&quot;</span>
  <span class="s1">parts = path.split(</span><span class="s3">'.'</span><span class="s1">)</span>
  <span class="s1">last = parts.pop()</span>
  <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">parts:</span>
    <span class="s1">field = message_descriptor.fields_by_name.get(name)</span>
    <span class="s4">if </span><span class="s1">(field </span><span class="s4">is None or</span>
        <span class="s1">field.label == FieldDescriptor.LABEL_REPEATED </span><span class="s4">or</span>
        <span class="s1">field.type != FieldDescriptor.TYPE_MESSAGE):</span>
      <span class="s4">return False</span>
    <span class="s1">message_descriptor = field.message_type</span>
  <span class="s4">return </span><span class="s1">last </span><span class="s4">in </span><span class="s1">message_descriptor.fields_by_name</span>


<span class="s4">def </span><span class="s1">_CheckFieldMaskMessage(message):</span>
  <span class="s2">&quot;&quot;&quot;Raises ValueError if message is not a FieldMask.&quot;&quot;&quot;</span>
  <span class="s1">message_descriptor = message.DESCRIPTOR</span>
  <span class="s4">if </span><span class="s1">(message_descriptor.name != </span><span class="s3">'FieldMask' </span><span class="s4">or</span>
      <span class="s1">message_descriptor.file.name != </span><span class="s3">'google/protobuf/field_mask.proto'</span><span class="s1">):</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Message {0} is not a FieldMask.'</span><span class="s1">.format(</span>
        <span class="s1">message_descriptor.full_name))</span>


<span class="s4">def </span><span class="s1">_SnakeCaseToCamelCase(path_name):</span>
  <span class="s2">&quot;&quot;&quot;Converts a path name from snake_case to camelCase.&quot;&quot;&quot;</span>
  <span class="s1">result = []</span>
  <span class="s1">after_underscore = </span><span class="s4">False</span>
  <span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">path_name:</span>
    <span class="s4">if </span><span class="s1">c.isupper():</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Fail to print FieldMask to Json string: Path name '</span>
          <span class="s3">'{0} must not contain uppercase letters.'</span><span class="s1">.format(path_name))</span>
    <span class="s4">if </span><span class="s1">after_underscore:</span>
      <span class="s4">if </span><span class="s1">c.islower():</span>
        <span class="s1">result.append(c.upper())</span>
        <span class="s1">after_underscore = </span><span class="s4">False</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span>
            <span class="s3">'Fail to print FieldMask to Json string: The '</span>
            <span class="s3">'character after a &quot;_&quot; must be a lowercase letter '</span>
            <span class="s3">'in path name {0}.'</span><span class="s1">.format(path_name))</span>
    <span class="s4">elif </span><span class="s1">c == </span><span class="s3">'_'</span><span class="s1">:</span>
      <span class="s1">after_underscore = </span><span class="s4">True</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">result += c</span>

  <span class="s4">if </span><span class="s1">after_underscore:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Fail to print FieldMask to Json string: Trailing &quot;_&quot; '</span>
                     <span class="s3">'in path name {0}.'</span><span class="s1">.format(path_name))</span>
  <span class="s4">return </span><span class="s3">''</span><span class="s1">.join(result)</span>


<span class="s4">def </span><span class="s1">_CamelCaseToSnakeCase(path_name):</span>
  <span class="s2">&quot;&quot;&quot;Converts a field name from camelCase to snake_case.&quot;&quot;&quot;</span>
  <span class="s1">result = []</span>
  <span class="s4">for </span><span class="s1">c </span><span class="s4">in </span><span class="s1">path_name:</span>
    <span class="s4">if </span><span class="s1">c == </span><span class="s3">'_'</span><span class="s1">:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Fail to parse FieldMask: Path name '</span>
                       <span class="s3">'{0} must not contain &quot;_&quot;s.'</span><span class="s1">.format(path_name))</span>
    <span class="s4">if </span><span class="s1">c.isupper():</span>
      <span class="s1">result += </span><span class="s3">'_'</span>
      <span class="s1">result += c.lower()</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">result += c</span>
  <span class="s4">return </span><span class="s3">''</span><span class="s1">.join(result)</span>


<span class="s4">class </span><span class="s1">_FieldMaskTree(object):</span>
  <span class="s2">&quot;&quot;&quot;Represents a FieldMask in a tree structure. 
 
  For example, given a FieldMask &quot;foo.bar,foo.baz,bar.baz&quot;, 
  the FieldMaskTree will be: 
      [_root] -+- foo -+- bar 
            |       | 
            |       +- baz 
            | 
            +- bar --- baz 
  In the tree, each leaf node represents a field path. 
  &quot;&quot;&quot;</span>

  <span class="s1">__slots__ = (</span><span class="s3">'_root'</span><span class="s4">,</span><span class="s1">)</span>

  <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">field_mask=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes the tree by FieldMask.&quot;&quot;&quot;</span>
    <span class="s1">self._root = {}</span>
    <span class="s4">if </span><span class="s1">field_mask:</span>
      <span class="s1">self.MergeFromFieldMask(field_mask)</span>

  <span class="s4">def </span><span class="s1">MergeFromFieldMask(self</span><span class="s4">, </span><span class="s1">field_mask):</span>
    <span class="s2">&quot;&quot;&quot;Merges a FieldMask to the tree.&quot;&quot;&quot;</span>
    <span class="s4">for </span><span class="s1">path </span><span class="s4">in </span><span class="s1">field_mask.paths:</span>
      <span class="s1">self.AddPath(path)</span>

  <span class="s4">def </span><span class="s1">AddPath(self</span><span class="s4">, </span><span class="s1">path):</span>
    <span class="s2">&quot;&quot;&quot;Adds a field path into the tree. 
 
    If the field path to add is a sub-path of an existing field path 
    in the tree (i.e., a leaf node), it means the tree already matches 
    the given path so nothing will be added to the tree. If the path 
    matches an existing non-leaf node in the tree, that non-leaf node 
    will be turned into a leaf node with all its children removed because 
    the path matches all the node's children. Otherwise, a new path will 
    be added. 
 
    Args: 
      path: The field path to add. 
    &quot;&quot;&quot;</span>
    <span class="s1">node = self._root</span>
    <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">path.split(</span><span class="s3">'.'</span><span class="s1">):</span>
      <span class="s4">if </span><span class="s1">name </span><span class="s4">not in </span><span class="s1">node:</span>
        <span class="s1">node[name] = {}</span>
      <span class="s4">elif not </span><span class="s1">node[name]:</span>
        <span class="s0"># Pre-existing empty node implies we already have this entire tree.</span>
        <span class="s4">return</span>
      <span class="s1">node = node[name]</span>
    <span class="s0"># Remove any sub-trees we might have had.</span>
    <span class="s1">node.clear()</span>

  <span class="s4">def </span><span class="s1">ToFieldMask(self</span><span class="s4">, </span><span class="s1">field_mask):</span>
    <span class="s2">&quot;&quot;&quot;Converts the tree to a FieldMask.&quot;&quot;&quot;</span>
    <span class="s1">field_mask.Clear()</span>
    <span class="s1">_AddFieldPaths(self._root</span><span class="s4">, </span><span class="s3">''</span><span class="s4">, </span><span class="s1">field_mask)</span>

  <span class="s4">def </span><span class="s1">IntersectPath(self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">, </span><span class="s1">intersection):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the intersection part of a field path with this tree. 
 
    Args: 
      path: The field path to calculates. 
      intersection: The out tree to record the intersection part. 
    &quot;&quot;&quot;</span>
    <span class="s1">node = self._root</span>
    <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">path.split(</span><span class="s3">'.'</span><span class="s1">):</span>
      <span class="s4">if </span><span class="s1">name </span><span class="s4">not in </span><span class="s1">node:</span>
        <span class="s4">return</span>
      <span class="s4">elif not </span><span class="s1">node[name]:</span>
        <span class="s1">intersection.AddPath(path)</span>
        <span class="s4">return</span>
      <span class="s1">node = node[name]</span>
    <span class="s1">intersection.AddLeafNodes(path</span><span class="s4">, </span><span class="s1">node)</span>

  <span class="s4">def </span><span class="s1">AddLeafNodes(self</span><span class="s4">, </span><span class="s1">prefix</span><span class="s4">, </span><span class="s1">node):</span>
    <span class="s2">&quot;&quot;&quot;Adds leaf nodes begin with prefix to this tree.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">node:</span>
      <span class="s1">self.AddPath(prefix)</span>
    <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">node:</span>
      <span class="s1">child_path = prefix + </span><span class="s3">'.' </span><span class="s1">+ name</span>
      <span class="s1">self.AddLeafNodes(child_path</span><span class="s4">, </span><span class="s1">node[name])</span>

  <span class="s4">def </span><span class="s1">MergeMessage(</span>
      <span class="s1">self</span><span class="s4">, </span><span class="s1">source</span><span class="s4">, </span><span class="s1">destination</span><span class="s4">,</span>
      <span class="s1">replace_message</span><span class="s4">, </span><span class="s1">replace_repeated):</span>
    <span class="s2">&quot;&quot;&quot;Merge all fields specified by this tree from source to destination.&quot;&quot;&quot;</span>
    <span class="s1">_MergeMessage(</span>
        <span class="s1">self._root</span><span class="s4">, </span><span class="s1">source</span><span class="s4">, </span><span class="s1">destination</span><span class="s4">, </span><span class="s1">replace_message</span><span class="s4">, </span><span class="s1">replace_repeated)</span>


<span class="s4">def </span><span class="s1">_StrConvert(value):</span>
  <span class="s2">&quot;&quot;&quot;Converts value to str if it is not.&quot;&quot;&quot;</span>
  <span class="s0"># This file is imported by c extension and some methods like ClearField</span>
  <span class="s0"># requires string for the field name. py2/py3 has different text</span>
  <span class="s0"># type and may use unicode.</span>
  <span class="s4">if not </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
    <span class="s4">return </span><span class="s1">value.encode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
  <span class="s4">return </span><span class="s1">value</span>


<span class="s4">def </span><span class="s1">_MergeMessage(</span>
    <span class="s1">node</span><span class="s4">, </span><span class="s1">source</span><span class="s4">, </span><span class="s1">destination</span><span class="s4">, </span><span class="s1">replace_message</span><span class="s4">, </span><span class="s1">replace_repeated):</span>
  <span class="s2">&quot;&quot;&quot;Merge all fields specified by a sub-tree from source to destination.&quot;&quot;&quot;</span>
  <span class="s1">source_descriptor = source.DESCRIPTOR</span>
  <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">node:</span>
    <span class="s1">child = node[name]</span>
    <span class="s1">field = source_descriptor.fields_by_name[name]</span>
    <span class="s4">if </span><span class="s1">field </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Error: Can</span><span class="s4">\'</span><span class="s3">t find field {0} in message {1}.'</span><span class="s1">.format(</span>
          <span class="s1">name</span><span class="s4">, </span><span class="s1">source_descriptor.full_name))</span>
    <span class="s4">if </span><span class="s1">child:</span>
      <span class="s0"># Sub-paths are only allowed for singular message fields.</span>
      <span class="s4">if </span><span class="s1">(field.label == FieldDescriptor.LABEL_REPEATED </span><span class="s4">or</span>
          <span class="s1">field.cpp_type != FieldDescriptor.CPPTYPE_MESSAGE):</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Error: Field {0} in message {1} is not a singular '</span>
                         <span class="s3">'message field and cannot have sub-fields.'</span><span class="s1">.format(</span>
                             <span class="s1">name</span><span class="s4">, </span><span class="s1">source_descriptor.full_name))</span>
      <span class="s4">if </span><span class="s1">source.HasField(name):</span>
        <span class="s1">_MergeMessage(</span>
            <span class="s1">child</span><span class="s4">, </span><span class="s1">getattr(source</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">, </span><span class="s1">getattr(destination</span><span class="s4">, </span><span class="s1">name)</span><span class="s4">,</span>
            <span class="s1">replace_message</span><span class="s4">, </span><span class="s1">replace_repeated)</span>
      <span class="s4">continue</span>
    <span class="s4">if </span><span class="s1">field.label == FieldDescriptor.LABEL_REPEATED:</span>
      <span class="s4">if </span><span class="s1">replace_repeated:</span>
        <span class="s1">destination.ClearField(_StrConvert(name))</span>
      <span class="s1">repeated_source = getattr(source</span><span class="s4">, </span><span class="s1">name)</span>
      <span class="s1">repeated_destination = getattr(destination</span><span class="s4">, </span><span class="s1">name)</span>
      <span class="s1">repeated_destination.MergeFrom(repeated_source)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">if </span><span class="s1">field.cpp_type == FieldDescriptor.CPPTYPE_MESSAGE:</span>
        <span class="s4">if </span><span class="s1">replace_message:</span>
          <span class="s1">destination.ClearField(_StrConvert(name))</span>
        <span class="s4">if </span><span class="s1">source.HasField(name):</span>
          <span class="s1">getattr(destination</span><span class="s4">, </span><span class="s1">name).MergeFrom(getattr(source</span><span class="s4">, </span><span class="s1">name))</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">setattr(destination</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">getattr(source</span><span class="s4">, </span><span class="s1">name))</span>


<span class="s4">def </span><span class="s1">_AddFieldPaths(node</span><span class="s4">, </span><span class="s1">prefix</span><span class="s4">, </span><span class="s1">field_mask):</span>
  <span class="s2">&quot;&quot;&quot;Adds the field paths descended from node to field_mask.&quot;&quot;&quot;</span>
  <span class="s4">if not </span><span class="s1">node </span><span class="s4">and </span><span class="s1">prefix:</span>
    <span class="s1">field_mask.paths.append(prefix)</span>
    <span class="s4">return</span>
  <span class="s4">for </span><span class="s1">name </span><span class="s4">in </span><span class="s1">sorted(node):</span>
    <span class="s4">if </span><span class="s1">prefix:</span>
      <span class="s1">child_path = prefix + </span><span class="s3">'.' </span><span class="s1">+ name</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">child_path = name</span>
    <span class="s1">_AddFieldPaths(node[name]</span><span class="s4">, </span><span class="s1">child_path</span><span class="s4">, </span><span class="s1">field_mask)</span>


<span class="s4">def </span><span class="s1">_SetStructValue(struct_value</span><span class="s4">, </span><span class="s1">value):</span>
  <span class="s4">if </span><span class="s1">value </span><span class="s4">is None</span><span class="s1">:</span>
    <span class="s1">struct_value.null_value = </span><span class="s5">0</span>
  <span class="s4">elif </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">bool):</span>
    <span class="s0"># Note: this check must come before the number check because in Python</span>
    <span class="s0"># True and False are also considered numbers.</span>
    <span class="s1">struct_value.bool_value = value</span>
  <span class="s4">elif </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
    <span class="s1">struct_value.string_value = value</span>
  <span class="s4">elif </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(int</span><span class="s4">, </span><span class="s1">float)):</span>
    <span class="s1">struct_value.number_value = value</span>
  <span class="s4">elif </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(dict</span><span class="s4">, </span><span class="s1">Struct)):</span>
    <span class="s1">struct_value.struct_value.Clear()</span>
    <span class="s1">struct_value.struct_value.update(value)</span>
  <span class="s4">elif </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">(list</span><span class="s4">, </span><span class="s1">ListValue)):</span>
    <span class="s1">struct_value.list_value.Clear()</span>
    <span class="s1">struct_value.list_value.extend(value)</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Unexpected type'</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_GetStructValue(struct_value):</span>
  <span class="s1">which = struct_value.WhichOneof(</span><span class="s3">'kind'</span><span class="s1">)</span>
  <span class="s4">if </span><span class="s1">which == </span><span class="s3">'struct_value'</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">struct_value.struct_value</span>
  <span class="s4">elif </span><span class="s1">which == </span><span class="s3">'null_value'</span><span class="s1">:</span>
    <span class="s4">return None</span>
  <span class="s4">elif </span><span class="s1">which == </span><span class="s3">'number_value'</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">struct_value.number_value</span>
  <span class="s4">elif </span><span class="s1">which == </span><span class="s3">'string_value'</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">struct_value.string_value</span>
  <span class="s4">elif </span><span class="s1">which == </span><span class="s3">'bool_value'</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">struct_value.bool_value</span>
  <span class="s4">elif </span><span class="s1">which == </span><span class="s3">'list_value'</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">struct_value.list_value</span>
  <span class="s4">elif </span><span class="s1">which </span><span class="s4">is None</span><span class="s1">:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Value not set'</span><span class="s1">)</span>


<span class="s4">class </span><span class="s1">Struct(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for Struct message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">key):</span>
    <span class="s4">return </span><span class="s1">_GetStructValue(self.fields[key])</span>

  <span class="s4">def </span><span class="s1">__contains__(self</span><span class="s4">, </span><span class="s1">item):</span>
    <span class="s4">return </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self.fields</span>

  <span class="s4">def </span><span class="s1">__setitem__(self</span><span class="s4">, </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s1">_SetStructValue(self.fields[key]</span><span class="s4">, </span><span class="s1">value)</span>

  <span class="s4">def </span><span class="s1">__delitem__(self</span><span class="s4">, </span><span class="s1">key):</span>
    <span class="s4">del </span><span class="s1">self.fields[key]</span>

  <span class="s4">def </span><span class="s1">__len__(self):</span>
    <span class="s4">return </span><span class="s1">len(self.fields)</span>

  <span class="s4">def </span><span class="s1">__iter__(self):</span>
    <span class="s4">return </span><span class="s1">iter(self.fields)</span>

  <span class="s4">def </span><span class="s1">keys(self):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s4">return </span><span class="s1">self.fields.keys()</span>

  <span class="s4">def </span><span class="s1">values(self):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s4">return </span><span class="s1">[self[key] </span><span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">self]</span>

  <span class="s4">def </span><span class="s1">items(self):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s4">return </span><span class="s1">[(key</span><span class="s4">, </span><span class="s1">self[key]) </span><span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">self]</span>

  <span class="s4">def </span><span class="s1">get_or_create_list(self</span><span class="s4">, </span><span class="s1">key):</span>
    <span class="s2">&quot;&quot;&quot;Returns a list for this key, creating if it didn't exist already.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">self.fields[key].HasField(</span><span class="s3">'list_value'</span><span class="s1">):</span>
      <span class="s0"># Clear will mark list_value modified which will indeed create a list.</span>
      <span class="s1">self.fields[key].list_value.Clear()</span>
    <span class="s4">return </span><span class="s1">self.fields[key].list_value</span>

  <span class="s4">def </span><span class="s1">get_or_create_struct(self</span><span class="s4">, </span><span class="s1">key):</span>
    <span class="s2">&quot;&quot;&quot;Returns a struct for this key, creating if it didn't exist already.&quot;&quot;&quot;</span>
    <span class="s4">if not </span><span class="s1">self.fields[key].HasField(</span><span class="s3">'struct_value'</span><span class="s1">):</span>
      <span class="s0"># Clear will mark struct_value modified which will indeed create a struct.</span>
      <span class="s1">self.fields[key].struct_value.Clear()</span>
    <span class="s4">return </span><span class="s1">self.fields[key].struct_value</span>

  <span class="s4">def </span><span class="s1">update(self</span><span class="s4">, </span><span class="s1">dictionary):  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s4">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">dictionary.items():</span>
      <span class="s1">_SetStructValue(self.fields[key]</span><span class="s4">, </span><span class="s1">value)</span>

<span class="s1">collections.abc.MutableMapping.register(Struct)</span>


<span class="s4">class </span><span class="s1">ListValue(object):</span>
  <span class="s2">&quot;&quot;&quot;Class for ListValue message type.&quot;&quot;&quot;</span>

  <span class="s1">__slots__ = ()</span>

  <span class="s4">def </span><span class="s1">__len__(self):</span>
    <span class="s4">return </span><span class="s1">len(self.values)</span>

  <span class="s4">def </span><span class="s1">append(self</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s1">_SetStructValue(self.values.add()</span><span class="s4">, </span><span class="s1">value)</span>

  <span class="s4">def </span><span class="s1">extend(self</span><span class="s4">, </span><span class="s1">elem_seq):</span>
    <span class="s4">for </span><span class="s1">value </span><span class="s4">in </span><span class="s1">elem_seq:</span>
      <span class="s1">self.append(value)</span>

  <span class="s4">def </span><span class="s1">__getitem__(self</span><span class="s4">, </span><span class="s1">index):</span>
    <span class="s2">&quot;&quot;&quot;Retrieves item by the specified index.&quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">_GetStructValue(self.values.__getitem__(index))</span>

  <span class="s4">def </span><span class="s1">__setitem__(self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s1">_SetStructValue(self.values.__getitem__(index)</span><span class="s4">, </span><span class="s1">value)</span>

  <span class="s4">def </span><span class="s1">__delitem__(self</span><span class="s4">, </span><span class="s1">key):</span>
    <span class="s4">del </span><span class="s1">self.values[key]</span>

  <span class="s4">def </span><span class="s1">items(self):</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(self)):</span>
      <span class="s4">yield </span><span class="s1">self[i]</span>

  <span class="s4">def </span><span class="s1">add_struct(self):</span>
    <span class="s2">&quot;&quot;&quot;Appends and returns a struct value as the next value in the list.&quot;&quot;&quot;</span>
    <span class="s1">struct_value = self.values.add().struct_value</span>
    <span class="s0"># Clear will mark struct_value modified which will indeed create a struct.</span>
    <span class="s1">struct_value.Clear()</span>
    <span class="s4">return </span><span class="s1">struct_value</span>

  <span class="s4">def </span><span class="s1">add_list(self):</span>
    <span class="s2">&quot;&quot;&quot;Appends and returns a list value as the next value in the list.&quot;&quot;&quot;</span>
    <span class="s1">list_value = self.values.add().list_value</span>
    <span class="s0"># Clear will mark list_value modified which will indeed create a list.</span>
    <span class="s1">list_value.Clear()</span>
    <span class="s4">return </span><span class="s1">list_value</span>

<span class="s1">collections.abc.MutableSequence.register(ListValue)</span>


<span class="s1">WKTBASES = {</span>
    <span class="s3">'google.protobuf.Any'</span><span class="s1">: Any</span><span class="s4">,</span>
    <span class="s3">'google.protobuf.Duration'</span><span class="s1">: Duration</span><span class="s4">,</span>
    <span class="s3">'google.protobuf.FieldMask'</span><span class="s1">: FieldMask</span><span class="s4">,</span>
    <span class="s3">'google.protobuf.ListValue'</span><span class="s1">: ListValue</span><span class="s4">,</span>
    <span class="s3">'google.protobuf.Struct'</span><span class="s1">: Struct</span><span class="s4">,</span>
    <span class="s3">'google.protobuf.Timestamp'</span><span class="s1">: Timestamp</span><span class="s4">,</span>
<span class="s1">}</span>
</pre>
</body>
</html>