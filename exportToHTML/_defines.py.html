<html>
<head>
<title>_defines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_defines.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2017 The Abseil Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s2">&quot;&quot;&quot;This modules contains flags DEFINE functions. 
 
Do NOT import this module directly. Import the flags package and use the 
aliases defined at the package level instead. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">types</span>

<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_argument_parser</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_exceptions</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_flag</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_flagvalues</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_helpers</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_validators</span>

<span class="s0"># pylint: disable=unused-import</span>
<span class="s3">try</span><span class="s1">:</span>
  <span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Text</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Any</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
  <span class="s3">pass</span>

<span class="s3">try</span><span class="s1">:</span>
  <span class="s3">import </span><span class="s1">enum</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
  <span class="s3">pass</span>
<span class="s0"># pylint: enable=unused-import</span>

<span class="s1">_helpers.disclaim_module_ids.add(id(sys.modules[__name__]))</span>


<span class="s3">def </span><span class="s1">_register_bounds_validator_if_needed(parser</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">flag_values):</span>
  <span class="s2">&quot;&quot;&quot;Enforces lower and upper bounds for numeric flags. 
 
  Args: 
    parser: NumericParser (either FloatParser or IntegerParser), provides lower 
      and upper bounds, and help text to display. 
    name: str, name of the flag 
    flag_values: FlagValues. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">parser.lower_bound </span><span class="s3">is not None or </span><span class="s1">parser.upper_bound </span><span class="s3">is not None</span><span class="s1">:</span>

    <span class="s3">def </span><span class="s1">checker(value):</span>
      <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None and </span><span class="s1">parser.is_outside_bounds(value):</span>
        <span class="s1">message = </span><span class="s4">'%s is not %s' </span><span class="s1">% (value</span><span class="s3">, </span><span class="s1">parser.syntactic_help)</span>
        <span class="s3">raise </span><span class="s1">_exceptions.ValidationError(message)</span>
      <span class="s3">return True</span>

    <span class="s1">_validators.register_validator(name</span><span class="s3">, </span><span class="s1">checker</span><span class="s3">, </span><span class="s1">flag_values=flag_values)</span>


<span class="s3">def </span><span class="s1">DEFINE(  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s1">parser</span><span class="s3">,</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,  </span><span class="s0"># pylint: disable=redefined-builtin</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">serializer=</span><span class="s3">None,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a generic Flag object. 
 
  NOTE: in the docstrings of all DEFINE* functions, &quot;registers&quot; is short 
  for &quot;creates a new flag and registers it&quot;. 
 
  Auxiliary function: clients should use the specialized ``DEFINE_&lt;type&gt;`` 
  function instead. 
 
  Args: 
    parser: :class:`ArgumentParser`, used to parse the flag arguments. 
    name: str, the flag name. 
    default: The default value of the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    serializer: :class:`ArgumentSerializer`, the flag serializer instance. 
    module_name: str, the name of the Python module declaring this flag. If not 
      provided, it will be computed using the stack trace of this call. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.Flag(parser</span><span class="s3">, </span><span class="s1">serializer</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">**args)</span><span class="s3">, </span><span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">module_name</span><span class="s3">, </span><span class="s1">required)</span>


<span class="s3">def </span><span class="s1">DEFINE_flag(  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s1">flag</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">required=</span><span class="s3">False</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Registers a :class:`Flag` object with a :class:`FlagValues` object. 
 
  By default, the global :const:`FLAGS` ``FlagValue`` object is used. 
 
  Typical users will use one of the more specialized DEFINE_xxx 
  functions, such as :func:`DEFINE_string` or :func:`DEFINE_integer`.  But 
  developers who need to create :class:`Flag` objects themselves should use 
  this function to register their flags. 
 
  Args: 
    flag: :class:`Flag`, a flag that is key to the module. 
    flag_values: :class:`FlagValues`, the ``FlagValues`` instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: str, the name of the Python module declaring this flag. If not 
      provided, it will be computed using the stack trace of this call. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">required </span><span class="s3">and </span><span class="s1">flag.default </span><span class="s3">is not None</span><span class="s1">:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Required flag --%s cannot have a non-None default' </span><span class="s1">%</span>
                     <span class="s1">flag.name)</span>
  <span class="s0"># Copying the reference to flag_values prevents pychecker warnings.</span>
  <span class="s1">fv = flag_values</span>
  <span class="s1">fv[flag.name] = flag</span>
  <span class="s0"># Tell flag_values who's defining the flag.</span>
  <span class="s3">if </span><span class="s1">module_name:</span>
    <span class="s1">module = sys.modules.get(module_name)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">module</span><span class="s3">, </span><span class="s1">module_name = _helpers.get_calling_module_object_and_name()</span>
  <span class="s1">flag_values.register_flag_by_module(module_name</span><span class="s3">, </span><span class="s1">flag)</span>
  <span class="s1">flag_values.register_flag_by_module_id(id(module)</span><span class="s3">, </span><span class="s1">flag)</span>
  <span class="s3">if </span><span class="s1">required:</span>
    <span class="s1">_validators.mark_flag_as_required(flag.name</span><span class="s3">, </span><span class="s1">fv)</span>
  <span class="s1">ensure_non_none_value = (flag.default </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">or </span><span class="s1">required</span>
  <span class="s3">return </span><span class="s1">_flagvalues.FlagHolder(</span>
      <span class="s1">fv</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">ensure_non_none_value=ensure_non_none_value)</span>


<span class="s3">def </span><span class="s1">set_default(flag_holder</span><span class="s3">, </span><span class="s1">value):</span>
  <span class="s2">&quot;&quot;&quot;Changes the default value of the provided flag object. 
 
  The flag's current value is also updated if the flag is currently using 
  the default value, i.e. not specified in the command line, and not set 
  by FLAGS.name = value. 
 
  Args: 
    flag_holder: FlagHolder, the flag to modify. 
    value: The new default value. 
 
  Raises: 
    IllegalFlagValueError: Raised when value is not valid. 
  &quot;&quot;&quot;</span>
  <span class="s1">flag_holder._flagvalues.set_default(flag_holder.name</span><span class="s3">, </span><span class="s1">value)  </span><span class="s0"># pylint: disable=protected-access</span>


<span class="s3">def </span><span class="s1">_internal_declare_key_flags(flag_names</span><span class="s3">,</span>
                                <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
                                <span class="s1">key_flag_values=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Declares a flag as key for the calling module. 
 
  Internal function.  User code should call declare_key_flag or 
  adopt_module_key_flags instead. 
 
  Args: 
    flag_names: [str], a list of names of already-registered Flag objects. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flags listed in flag_names have registered (the value of the flag_values 
      argument from the ``DEFINE_*`` calls that defined those flags). This 
      should almost never need to be overridden. 
    key_flag_values: :class:`FlagValues`, the FlagValues instance that (among 
      possibly many other things) keeps track of the key flags for each module. 
      Default ``None`` means &quot;same as flag_values&quot;.  This should almost never 
      need to be overridden. 
 
  Raises: 
    UnrecognizedFlagError: Raised when the flag is not defined. 
  &quot;&quot;&quot;</span>
  <span class="s1">key_flag_values = key_flag_values </span><span class="s3">or </span><span class="s1">flag_values</span>

  <span class="s1">module = _helpers.get_calling_module()</span>

  <span class="s3">for </span><span class="s1">flag_name </span><span class="s3">in </span><span class="s1">flag_names:</span>
    <span class="s1">key_flag_values.register_key_flag_for_module(module</span><span class="s3">, </span><span class="s1">flag_values[flag_name])</span>


<span class="s3">def </span><span class="s1">declare_key_flag(flag_name</span><span class="s3">, </span><span class="s1">flag_values=_flagvalues.FLAGS):</span>
  <span class="s2">&quot;&quot;&quot;Declares one flag as key to the current module. 
 
  Key flags are flags that are deemed really important for a module. 
  They are important when listing help messages; e.g., if the 
  --helpshort command-line flag is used, then only the key flags of the 
  main module are listed (instead of all flags, as in the case of 
  --helpfull). 
 
  Sample usage:: 
 
      flags.declare_key_flag('flag_1') 
 
  Args: 
    flag_name: str | :class:`FlagHolder`, the name or holder of an already 
      declared flag. (Redeclaring flags as key, including flags implicitly key 
      because they were declared in this module, is a no-op.) 
      Positional-only parameter. 
    flag_values: :class:`FlagValues`, the FlagValues instance in which the 
      flag will be declared as a key flag. This should almost never need to be 
      overridden. 
 
  Raises: 
    ValueError: Raised if flag_name not defined as a Python flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">flag_name</span><span class="s3">, </span><span class="s1">flag_values = _flagvalues.resolve_flag_ref(flag_name</span><span class="s3">, </span><span class="s1">flag_values)</span>
  <span class="s3">if </span><span class="s1">flag_name </span><span class="s3">in </span><span class="s1">_helpers.SPECIAL_FLAGS:</span>
    <span class="s0"># Take care of the special flags, e.g., --flagfile, --undefok.</span>
    <span class="s0"># These flags are defined in SPECIAL_FLAGS, and are treated</span>
    <span class="s0"># specially during flag parsing, taking precedence over the</span>
    <span class="s0"># user-defined flags.</span>
    <span class="s1">_internal_declare_key_flags([flag_name]</span><span class="s3">,</span>
                                <span class="s1">flag_values=_helpers.SPECIAL_FLAGS</span><span class="s3">,</span>
                                <span class="s1">key_flag_values=flag_values)</span>
    <span class="s3">return</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">_internal_declare_key_flags([flag_name]</span><span class="s3">, </span><span class="s1">flag_values=flag_values)</span>
  <span class="s3">except </span><span class="s1">KeyError:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Flag --%s is undefined. To set a flag as a key flag '</span>
                     <span class="s4">'first define it in Python.' </span><span class="s1">% flag_name)</span>


<span class="s3">def </span><span class="s1">adopt_module_key_flags(module</span><span class="s3">, </span><span class="s1">flag_values=_flagvalues.FLAGS):</span>
  <span class="s2">&quot;&quot;&quot;Declares that all flags key to a module are key to the current module. 
 
  Args: 
    module: module, the module object from which all key flags will be declared 
      as key flags to the current module. 
    flag_values: :class:`FlagValues`, the FlagValues instance in which the 
      flags will be declared as key flags. This should almost never need to be 
      overridden. 
 
  Raises: 
    Error: Raised when given an argument that is a module name (a string), 
        instead of a module object. 
  &quot;&quot;&quot;</span>
  <span class="s3">if not </span><span class="s1">isinstance(module</span><span class="s3">, </span><span class="s1">types.ModuleType):</span>
    <span class="s3">raise </span><span class="s1">_exceptions.Error(</span><span class="s4">'Expected a module object, not %r.' </span><span class="s1">% (module</span><span class="s3">,</span><span class="s1">))</span>
  <span class="s1">_internal_declare_key_flags(</span>
      <span class="s1">[f.name </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">flag_values.get_key_flags_for_module(module.__name__)]</span><span class="s3">,</span>
      <span class="s1">flag_values=flag_values)</span>
  <span class="s0"># If module is this flag module, take _helpers.SPECIAL_FLAGS into account.</span>
  <span class="s3">if </span><span class="s1">module == _helpers.FLAGS_MODULE:</span>
    <span class="s1">_internal_declare_key_flags(</span>
        <span class="s0"># As we associate flags with get_calling_module_object_and_name(), the</span>
        <span class="s0"># special flags defined in this module are incorrectly registered with</span>
        <span class="s0"># a different module.  So, we can't use get_key_flags_for_module.</span>
        <span class="s0"># Instead, we take all flags from _helpers.SPECIAL_FLAGS (a private</span>
        <span class="s0"># FlagValues, where no other module should register flags).</span>
        <span class="s1">[_helpers.SPECIAL_FLAGS[name].name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">_helpers.SPECIAL_FLAGS]</span><span class="s3">,</span>
        <span class="s1">flag_values=_helpers.SPECIAL_FLAGS</span><span class="s3">,</span>
        <span class="s1">key_flag_values=flag_values)</span>


<span class="s3">def </span><span class="s1">disclaim_key_flags():</span>
  <span class="s2">&quot;&quot;&quot;Declares that the current module will not define any more key flags. 
 
  Normally, the module that calls the DEFINE_xxx functions claims the 
  flag to be its key flag.  This is undesirable for modules that 
  define additional DEFINE_yyy functions with its own flag parsers and 
  serializers, since that module will accidentally claim flags defined 
  by DEFINE_yyy as its key flags.  After calling this function, the 
  module disclaims flag definitions thereafter, so the key flags will 
  be correctly attributed to the caller of DEFINE_yyy. 
 
  After calling this function, the module will not be able to define 
  any more flags.  This function will affect all FlagValues objects. 
  &quot;&quot;&quot;</span>
  <span class="s1">globals_for_caller = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals  </span><span class="s0"># pylint: disable=protected-access</span>
  <span class="s1">module</span><span class="s3">, </span><span class="s1">_ = _helpers.get_module_object_and_name(globals_for_caller)</span>
  <span class="s1">_helpers.disclaim_module_ids.add(id(module))</span>


<span class="s3">def </span><span class="s1">DEFINE_string(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be any string.&quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.ArgumentParser()</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s3">return </span><span class="s1">DEFINE(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_boolean(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a boolean flag. 
 
  Such a boolean flag does not take an argument.  If a user wants to 
  specify a false value explicitly, the long option beginning with 'no' 
  must be used: i.e. --noflag 
 
  This flag will have a value of None, True or False.  None is possible 
  if default=None and the user does not specify the flag on the command 
  line. 
 
  Args: 
    name: str, the flag name. 
    default: bool|str|None, the default value of the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: str, the name of the Python module declaring this flag. If not 
      provided, it will be computed using the stack trace of this call. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.BooleanFlag(name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">**args)</span><span class="s3">, </span><span class="s1">flag_values</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">,</span>
      <span class="s1">required)</span>


<span class="s3">def </span><span class="s1">DEFINE_float(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">lower_bound=</span><span class="s3">None,</span>
    <span class="s1">upper_bound=</span><span class="s3">None,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value must be a float. 
 
  If ``lower_bound`` or ``upper_bound`` are set, then this flag must be 
  within the given range. 
 
  Args: 
    name: str, the flag name. 
    default: float|str|None, the default value of the flag. 
    help: str, the help message. 
    lower_bound: float, min value of the flag. 
    upper_bound: float, max value of the flag. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to :func:`DEFINE`. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.FloatParser(lower_bound</span><span class="s3">, </span><span class="s1">upper_bound)</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s1">result = DEFINE(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>
  <span class="s1">_register_bounds_validator_if_needed(parser</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">flag_values=flag_values)</span>
  <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">DEFINE_integer(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">lower_bound=</span><span class="s3">None,</span>
    <span class="s1">upper_bound=</span><span class="s3">None,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value must be an integer. 
 
  If ``lower_bound``, or ``upper_bound`` are set, then this flag must be 
  within the given range. 
 
  Args: 
    name: str, the flag name. 
    default: int|str|None, the default value of the flag. 
    help: str, the help message. 
    lower_bound: int, min value of the flag. 
    upper_bound: int, max value of the flag. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to :func:`DEFINE`. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.IntegerParser(lower_bound</span><span class="s3">, </span><span class="s1">upper_bound)</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s1">result = DEFINE(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>
  <span class="s1">_register_bounds_validator_if_needed(parser</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">flag_values=flag_values)</span>
  <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">DEFINE_enum(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">enum_values</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be any string from enum_values. 
 
  Instead of a string enum, prefer `DEFINE_enum_class`, which allows 
  defining enums from an `enum.Enum` class. 
 
  Args: 
    name: str, the flag name. 
    default: str|None, the default value of the flag. 
    enum_values: [str], a non-empty list of strings with the possible values for 
      the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: str, the name of the Python module declaring this flag. If not 
      provided, it will be computed using the stack trace of this call. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.EnumFlag(name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">enum_values</span><span class="s3">, </span><span class="s1">**args)</span><span class="s3">, </span><span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">module_name</span><span class="s3">, </span><span class="s1">required)</span>


<span class="s3">def </span><span class="s1">DEFINE_enum_class(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">enum_class</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">case_sensitive=</span><span class="s3">False,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be the name of enum members. 
 
  Args: 
    name: str, the flag name. 
    default: Enum|str|None, the default value of the flag. 
    enum_class: class, the Enum class with all the possible values for the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: str, the name of the Python module declaring this flag. If not 
      provided, it will be computed using the stack trace of this call. 
    case_sensitive: bool, whether to map strings to members of the enum_class 
      without considering case. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: dict, the extra keyword args that are passed to ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.EnumClassFlag(</span>
          <span class="s1">name</span><span class="s3">,</span>
          <span class="s1">default</span><span class="s3">,</span>
          <span class="s1">help</span><span class="s3">,</span>
          <span class="s1">enum_class</span><span class="s3">,</span>
          <span class="s1">case_sensitive=case_sensitive</span><span class="s3">,</span>
          <span class="s1">**args)</span><span class="s3">, </span><span class="s1">flag_values</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">required)</span>


<span class="s3">def </span><span class="s1">DEFINE_list(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value is a comma-separated list of strings. 
 
  The flag value is parsed with a CSV parser. 
 
  Args: 
    name: str, the flag name. 
    default: list|str|None, the default value of the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.ListParser()</span>
  <span class="s1">serializer = _argument_parser.CsvListSerializer(</span><span class="s4">','</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">DEFINE(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_spaceseplist(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">comma_compat=</span><span class="s3">False,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value is a whitespace-separated list of strings. 
 
  Any whitespace can be used as a separator. 
 
  Args: 
    name: str, the flag name. 
    default: list|str|None, the default value of the flag. 
    help: str, the help message. 
    comma_compat: bool - Whether to support comma as an additional separator. If 
      false then only whitespace is supported.  This is intended only for 
      backwards compatibility with flags that used to be comma-separated. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.WhitespaceSeparatedListParser(</span>
      <span class="s1">comma_compat=comma_compat)</span>
  <span class="s1">serializer = _argument_parser.ListSerializer(</span><span class="s4">' '</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">DEFINE(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">parser</span><span class="s3">,</span>
    <span class="s1">serializer</span><span class="s3">,</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a generic MultiFlag that parses its args with a given parser. 
 
  Auxiliary function.  Normal users should NOT use it directly. 
 
  Developers who need to create their own 'Parser' classes for options 
  which can appear multiple times can call this module function to 
  register their flags. 
 
  Args: 
    parser: ArgumentParser, used to parse the flag arguments. 
    serializer: ArgumentSerializer, the flag serializer instance. 
    name: str, the flag name. 
    default: Union[Iterable[T], Text, None], the default value of the flag. If 
      the value is text, it will be parsed as if it was provided from the 
      command line. If the value is a non-string iterable, it will be iterated 
      over to create a shallow copy of the values. If it is None, it is left 
      as-is. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: A string, the name of the Python module declaring this flag. If 
      not provided, it will be computed using the stack trace of this call. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.MultiFlag(parser</span><span class="s3">, </span><span class="s1">serializer</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">**args)</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">required)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi_string(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be a list of any strings. 
 
  Use the flag on the command line multiple times to place multiple 
  string values into the list.  The 'default' may be a single string 
  (which will be converted into a single-element list) or a list of 
  strings. 
 
 
  Args: 
    name: str, the flag name. 
    default: Union[Iterable[Text], Text, None], the default value of the flag; 
      see :func:`DEFINE_multi`. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.ArgumentParser()</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s3">return </span><span class="s1">DEFINE_multi(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi_integer(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">lower_bound=</span><span class="s3">None,</span>
    <span class="s1">upper_bound=</span><span class="s3">None,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be a list of arbitrary integers. 
 
  Use the flag on the command line multiple times to place multiple 
  integer values into the list.  The 'default' may be a single integer 
  (which will be converted into a single-element list) or a list of 
  integers. 
 
  Args: 
    name: str, the flag name. 
    default: Union[Iterable[int], Text, None], the default value of the flag; 
      see `DEFINE_multi`. 
    help: str, the help message. 
    lower_bound: int, min values of the flag. 
    upper_bound: int, max values of the flag. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.IntegerParser(lower_bound</span><span class="s3">, </span><span class="s1">upper_bound)</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s3">return </span><span class="s1">DEFINE_multi(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi_float(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">lower_bound=</span><span class="s3">None,</span>
    <span class="s1">upper_bound=</span><span class="s3">None,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be a list of arbitrary floats. 
 
  Use the flag on the command line multiple times to place multiple 
  float values into the list.  The 'default' may be a single float 
  (which will be converted into a single-element list) or a list of 
  floats. 
 
  Args: 
    name: str, the flag name. 
    default: Union[Iterable[float], Text, None], the default value of the flag; 
      see `DEFINE_multi`. 
    help: str, the help message. 
    lower_bound: float, min values of the flag. 
    upper_bound: float, max values of the flag. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.FloatParser(lower_bound</span><span class="s3">, </span><span class="s1">upper_bound)</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s3">return </span><span class="s1">DEFINE_multi(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi_enum(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">enum_values</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">case_sensitive=</span><span class="s3">True,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be a list strings from enum_values. 
 
  Use the flag on the command line multiple times to place multiple 
  enum values into the list.  The 'default' may be a single string 
  (which will be converted into a single-element list) or a list of 
  strings. 
 
  Args: 
    name: str, the flag name. 
    default: Union[Iterable[Text], Text, None], the default value of the flag; 
      see `DEFINE_multi`. 
    enum_values: [str], a non-empty list of strings with the possible values for 
      the flag. 
    help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    case_sensitive: Whether or not the enum is to be case-sensitive. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s1">parser = _argument_parser.EnumParser(enum_values</span><span class="s3">, </span><span class="s1">case_sensitive)</span>
  <span class="s1">serializer = _argument_parser.ArgumentSerializer()</span>
  <span class="s3">return </span><span class="s1">DEFINE_multi(</span>
      <span class="s1">parser</span><span class="s3">,</span>
      <span class="s1">serializer</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s4">'&lt;%s&gt;: %s' </span><span class="s1">% (</span><span class="s4">'|'</span><span class="s1">.join(enum_values)</span><span class="s3">, </span><span class="s1">help)</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
      <span class="s1">**args)</span>


<span class="s3">def </span><span class="s1">DEFINE_multi_enum_class(  </span><span class="s0"># pylint: disable=invalid-name,redefined-builtin</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">default</span><span class="s3">,</span>
    <span class="s1">enum_class</span><span class="s3">,</span>
    <span class="s1">help</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None,</span>
    <span class="s1">case_sensitive=</span><span class="s3">False,</span>
    <span class="s1">required=</span><span class="s3">False,</span>
    <span class="s1">**args):</span>
  <span class="s2">&quot;&quot;&quot;Registers a flag whose value can be a list of enum members. 
 
  Use the flag on the command line multiple times to place multiple 
  enum values into the list. 
 
  Args: 
    name: str, the flag name. 
    default: Union[Iterable[Enum], Iterable[Text], Enum, Text, None], the 
      default value of the flag; see `DEFINE_multi`; only differences are 
      documented here. If the value is a single Enum, it is treated as a 
      single-item list of that Enum value. If it is an iterable, text values 
      within the iterable will be converted to the equivalent Enum objects. 
    enum_class: class, the Enum class with all the possible values for the flag. 
        help: str, the help message. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: A string, the name of the Python module declaring this flag. If 
      not provided, it will be computed using the stack trace of this call. 
    case_sensitive: bool, whether to map strings to members of the enum_class 
      without considering case. 
    required: bool, is this a required flag. This must be used as a keyword 
      argument. 
    **args: Dictionary with extra keyword args that are passed to the 
      ``Flag.__init__``. 
 
  Returns: 
    a handle to defined flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_flag.MultiEnumClassFlag(</span>
          <span class="s1">name</span><span class="s3">,</span>
          <span class="s1">default</span><span class="s3">,</span>
          <span class="s1">help</span><span class="s3">,</span>
          <span class="s1">enum_class</span><span class="s3">,</span>
          <span class="s1">case_sensitive=case_sensitive</span><span class="s3">,</span>
          <span class="s1">**args</span><span class="s3">,</span>
      <span class="s1">)</span><span class="s3">,</span>
      <span class="s1">flag_values</span><span class="s3">,</span>
      <span class="s1">module_name</span><span class="s3">,</span>
      <span class="s1">required=required</span><span class="s3">,</span>
  <span class="s1">)</span>


<span class="s3">def </span><span class="s1">DEFINE_alias(  </span><span class="s0"># pylint: disable=invalid-name</span>
    <span class="s1">name</span><span class="s3">,</span>
    <span class="s1">original_name</span><span class="s3">,</span>
    <span class="s1">flag_values=_flagvalues.FLAGS</span><span class="s3">,</span>
    <span class="s1">module_name=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Defines an alias flag for an existing one. 
 
  Args: 
    name: str, the flag name. 
    original_name: str, the original flag name. 
    flag_values: :class:`FlagValues`, the FlagValues instance with which the 
      flag will be registered. This should almost never need to be overridden. 
    module_name: A string, the name of the module that defines this flag. 
 
  Returns: 
    a handle to defined flag. 
 
  Raises: 
    flags.FlagError: 
      UnrecognizedFlagError: if the referenced flag doesn't exist. 
      DuplicateFlagError: if the alias name has been used by some existing flag. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">original_name </span><span class="s3">not in </span><span class="s1">flag_values:</span>
    <span class="s3">raise </span><span class="s1">_exceptions.UnrecognizedFlagError(original_name)</span>
  <span class="s1">flag = flag_values[original_name]</span>

  <span class="s3">class </span><span class="s1">_FlagAlias(_flag.Flag):</span>
    <span class="s2">&quot;&quot;&quot;Overrides Flag class so alias value is copy of original flag value.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">argument):</span>
      <span class="s1">flag.parse(argument)</span>
      <span class="s1">self.present += </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">_parse_from_default(self</span><span class="s3">, </span><span class="s1">value):</span>
      <span class="s0"># The value was already parsed by the aliased flag, so there is no</span>
      <span class="s0"># need to call the parser on it a second time.</span>
      <span class="s0"># Additionally, because of how MultiFlag parses and merges values,</span>
      <span class="s0"># it isn't possible to delegate to the aliased flag and still get</span>
      <span class="s0"># the correct values.</span>
      <span class="s3">return </span><span class="s1">value</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">value(self):</span>
      <span class="s3">return </span><span class="s1">flag.value</span>

    <span class="s1">@value.setter</span>
    <span class="s3">def </span><span class="s1">value(self</span><span class="s3">, </span><span class="s1">value):</span>
      <span class="s1">flag.value = value</span>

  <span class="s1">help_msg = </span><span class="s4">'Alias for --%s.' </span><span class="s1">% flag.name</span>
  <span class="s0"># If alias_name has been used, flags.DuplicatedFlag will be raised.</span>
  <span class="s3">return </span><span class="s1">DEFINE_flag(</span>
      <span class="s1">_FlagAlias(</span>
          <span class="s1">flag.parser</span><span class="s3">,</span>
          <span class="s1">flag.serializer</span><span class="s3">,</span>
          <span class="s1">name</span><span class="s3">,</span>
          <span class="s1">flag.default</span><span class="s3">,</span>
          <span class="s1">help_msg</span><span class="s3">,</span>
          <span class="s1">boolean=flag.boolean)</span><span class="s3">, </span><span class="s1">flag_values</span><span class="s3">, </span><span class="s1">module_name)</span>
</pre>
</body>
</html>