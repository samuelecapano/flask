<html>
<head>
<title>test_backends_interactive.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_backends_interactive.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">importlib</span>
<span class="s0">import </span><span class="s1">importlib.util</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">json</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">signal</span>
<span class="s0">import </span><span class="s1">subprocess</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">urllib.request</span>

<span class="s0">from </span><span class="s1">PIL </span><span class="s0">import </span><span class="s1">Image</span>

<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_c_internal_utils</span>
<span class="s0">from </span><span class="s1">matplotlib.backend_tools </span><span class="s0">import </span><span class="s1">ToolToggleBase</span>
<span class="s0">from </span><span class="s1">matplotlib.testing </span><span class="s0">import </span><span class="s1">subprocess_run_helper </span><span class="s0">as </span><span class="s1">_run_helper</span>


<span class="s2"># Minimal smoke-testing of the backends for which the dependencies are</span>
<span class="s2"># PyPI-installable on CI.  They are not available for all tested Python</span>
<span class="s2"># versions so we don't fail on missing backends.</span>

<span class="s0">def </span><span class="s1">_get_testable_interactive_backends():</span>
    <span class="s1">envs = []</span>
    <span class="s0">for </span><span class="s1">deps</span><span class="s0">, </span><span class="s1">env </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">*[([qt_api]</span><span class="s0">,</span>
               <span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;qtagg&quot;</span><span class="s0">, </span><span class="s3">&quot;QT_API&quot;</span><span class="s1">: qt_api})</span>
              <span class="s0">for </span><span class="s1">qt_api </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;PyQt6&quot;</span><span class="s0">, </span><span class="s3">&quot;PySide6&quot;</span><span class="s0">, </span><span class="s3">&quot;PyQt5&quot;</span><span class="s0">, </span><span class="s3">&quot;PySide2&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">*[([qt_api</span><span class="s0">, </span><span class="s3">&quot;cairocffi&quot;</span><span class="s1">]</span><span class="s0">,</span>
               <span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;qtcairo&quot;</span><span class="s0">, </span><span class="s3">&quot;QT_API&quot;</span><span class="s1">: qt_api})</span>
              <span class="s0">for </span><span class="s1">qt_api </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;PyQt6&quot;</span><span class="s0">, </span><span class="s3">&quot;PySide6&quot;</span><span class="s0">, </span><span class="s3">&quot;PyQt5&quot;</span><span class="s0">, </span><span class="s3">&quot;PySide2&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">*[([</span><span class="s3">&quot;cairo&quot;</span><span class="s0">, </span><span class="s3">&quot;gi&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">f&quot;gtk</span><span class="s0">{</span><span class="s1">version</span><span class="s0">}{</span><span class="s1">renderer</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">})</span>
              <span class="s0">for </span><span class="s1">version </span><span class="s0">in </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">] </span><span class="s0">for </span><span class="s1">renderer </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;agg&quot;</span><span class="s0">, </span><span class="s3">&quot;cairo&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s3">&quot;tkinter&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;tkagg&quot;</span><span class="s1">})</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s3">&quot;wx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;wx&quot;</span><span class="s1">})</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s3">&quot;wx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;wxagg&quot;</span><span class="s1">})</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s3">&quot;matplotlib.backends._macosx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;macosx&quot;</span><span class="s1">})</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s1">reason = </span><span class="s0">None</span>
        <span class="s1">missing = [dep </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">deps </span><span class="s0">if not </span><span class="s1">importlib.util.find_spec(dep)]</span>
        <span class="s0">if </span><span class="s1">(sys.platform == </span><span class="s3">&quot;linux&quot; </span><span class="s0">and</span>
                <span class="s0">not </span><span class="s1">_c_internal_utils.display_is_valid()):</span>
            <span class="s1">reason = </span><span class="s3">&quot;$DISPLAY and $WAYLAND_DISPLAY are unset&quot;</span>
        <span class="s0">elif </span><span class="s1">missing:</span>
            <span class="s1">reason = </span><span class="s3">&quot;{} cannot be imported&quot;</span><span class="s1">.format(</span><span class="s3">&quot;, &quot;</span><span class="s1">.join(missing))</span>
        <span class="s0">elif </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">'macosx' </span><span class="s0">and </span><span class="s1">os.environ.get(</span><span class="s3">'TF_BUILD'</span><span class="s1">):</span>
            <span class="s1">reason = </span><span class="s3">&quot;macosx backend fails on Azure&quot;</span>
        <span class="s0">elif </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">].startswith(</span><span class="s3">'gtk'</span><span class="s1">):</span>
            <span class="s0">import </span><span class="s1">gi</span>
            <span class="s1">version = env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">][</span><span class="s4">3</span><span class="s1">]</span>
            <span class="s1">repo = gi.Repository.get_default()</span>
            <span class="s0">if </span><span class="s3">f'</span><span class="s0">{</span><span class="s1">version</span><span class="s0">}</span><span class="s3">.0' </span><span class="s0">not in </span><span class="s1">repo.enumerate_versions(</span><span class="s3">'Gtk'</span><span class="s1">):</span>
                <span class="s1">reason = </span><span class="s3">&quot;no usable GTK bindings&quot;</span>
        <span class="s1">marks = []</span>
        <span class="s0">if </span><span class="s1">reason:</span>
            <span class="s1">marks.append(pytest.mark.skip(</span>
                <span class="s1">reason=</span><span class="s3">f&quot;Skipping </span><span class="s0">{</span><span class="s1">env</span><span class="s0">} </span><span class="s3">because </span><span class="s0">{</span><span class="s1">reason</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">))</span>
        <span class="s0">elif </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">].startswith(</span><span class="s3">'wx'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.platform == </span><span class="s3">'darwin'</span><span class="s1">:</span>
            <span class="s2"># ignore on OSX because that's currently broken (github #16849)</span>
            <span class="s1">marks.append(pytest.mark.xfail(reason=</span><span class="s3">'github #16849'</span><span class="s1">))</span>
        <span class="s1">envs.append(</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">{**env</span><span class="s0">, </span><span class="s3">'BACKEND_DEPS'</span><span class="s1">: </span><span class="s3">','</span><span class="s1">.join(deps)}</span><span class="s0">,</span>
                <span class="s1">marks=marks</span><span class="s0">, </span><span class="s1">id=str(env)</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">envs</span>


<span class="s1">_test_timeout = </span><span class="s4">60  </span><span class="s2"># A reasonably safe value for slower architectures.</span>


<span class="s0">def </span><span class="s1">_test_toolbar_button_la_mode_icon(fig):</span>
    <span class="s2"># test a toolbar button icon using an image in LA mode (GH issue 25174)</span>
    <span class="s2"># create an icon in LA mode</span>
    <span class="s0">with </span><span class="s1">tempfile.TemporaryDirectory() </span><span class="s0">as </span><span class="s1">tempdir:</span>
        <span class="s1">img = Image.new(</span><span class="s3">&quot;LA&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s4">26</span><span class="s0">, </span><span class="s4">26</span><span class="s1">))</span>
        <span class="s1">tmp_img_path = os.path.join(tempdir</span><span class="s0">, </span><span class="s3">&quot;test_la_icon.png&quot;</span><span class="s1">)</span>
        <span class="s1">img.save(tmp_img_path)</span>

        <span class="s0">class </span><span class="s1">CustomTool(ToolToggleBase):</span>
            <span class="s1">image = tmp_img_path</span>
            <span class="s1">description = </span><span class="s3">&quot;&quot;  </span><span class="s2"># gtk3 backend does not allow None</span>

        <span class="s1">toolmanager = fig.canvas.manager.toolmanager</span>
        <span class="s1">toolbar = fig.canvas.manager.toolbar</span>
        <span class="s1">toolmanager.add_tool(</span><span class="s3">&quot;test&quot;</span><span class="s0">, </span><span class="s1">CustomTool)</span>
        <span class="s1">toolbar.add_tool(</span><span class="s3">&quot;test&quot;</span><span class="s0">, </span><span class="s3">&quot;group&quot;</span><span class="s1">)</span>


<span class="s2"># The source of this function gets extracted and run in another process, so it</span>
<span class="s2"># must be fully self-contained.</span>
<span class="s2"># Using a timer not only allows testing of timers (on other backends), but is</span>
<span class="s2"># also necessary on gtk3 and wx, where directly processing a KeyEvent() for &quot;q&quot;</span>
<span class="s2"># from draw_event causes breakage as the canvas widget gets deleted too early.</span>
<span class="s0">def </span><span class="s1">_test_interactive_impl():</span>
    <span class="s0">import </span><span class="s1">importlib.util</span>
    <span class="s0">import </span><span class="s1">io</span>
    <span class="s0">import </span><span class="s1">json</span>
    <span class="s0">import </span><span class="s1">sys</span>
    <span class="s0">from </span><span class="s1">unittest </span><span class="s0">import </span><span class="s1">TestCase</span>

    <span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
    <span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">pyplot </span><span class="s0">as </span><span class="s1">plt</span>
    <span class="s0">from </span><span class="s1">matplotlib.backend_bases </span><span class="s0">import </span><span class="s1">KeyEvent</span>
    <span class="s1">mpl.rcParams.update({</span>
        <span class="s3">&quot;webagg.open_in_browser&quot;</span><span class="s1">: </span><span class="s0">False,</span>
        <span class="s3">&quot;webagg.port_retries&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">})</span>

    <span class="s1">mpl.rcParams.update(json.loads(sys.argv[</span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s1">backend = plt.rcParams[</span><span class="s3">&quot;backend&quot;</span><span class="s1">].lower()</span>
    <span class="s1">assert_equal = TestCase().assertEqual</span>
    <span class="s1">assert_raises = TestCase().assertRaises</span>

    <span class="s0">if </span><span class="s1">backend.endswith(</span><span class="s3">&quot;agg&quot;</span><span class="s1">) </span><span class="s0">and not </span><span class="s1">backend.startswith((</span><span class="s3">&quot;gtk&quot;</span><span class="s0">, </span><span class="s3">&quot;web&quot;</span><span class="s1">)):</span>
        <span class="s2"># Force interactive framework setup.</span>
        <span class="s1">plt.figure()</span>

        <span class="s2"># Check that we cannot switch to a backend using another interactive</span>
        <span class="s2"># framework, but can switch to a backend using cairo instead of agg,</span>
        <span class="s2"># or a non-interactive backend.  In the first case, we use tkagg as</span>
        <span class="s2"># the &quot;other&quot; interactive backend as it is (essentially) guaranteed</span>
        <span class="s2"># to be present.  Moreover, don't test switching away from gtk3 (as</span>
        <span class="s2"># Gtk.main_level() is not set up at this point yet) and webagg (which</span>
        <span class="s2"># uses no interactive framework).</span>

        <span class="s0">if </span><span class="s1">backend != </span><span class="s3">&quot;tkagg&quot;</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">assert_raises(ImportError):</span>
                <span class="s1">mpl.use(</span><span class="s3">&quot;tkagg&quot;</span><span class="s0">, </span><span class="s1">force=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">check_alt_backend(alt_backend):</span>
            <span class="s1">mpl.use(alt_backend</span><span class="s0">, </span><span class="s1">force=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">fig = plt.figure()</span>
            <span class="s1">assert_equal(</span>
                <span class="s1">type(fig.canvas).__module__</span><span class="s0">,</span>
                <span class="s3">&quot;matplotlib.backends.backend_{}&quot;</span><span class="s1">.format(alt_backend))</span>

        <span class="s0">if </span><span class="s1">importlib.util.find_spec(</span><span class="s3">&quot;cairocffi&quot;</span><span class="s1">):</span>
            <span class="s1">check_alt_backend(backend[:-</span><span class="s4">3</span><span class="s1">] + </span><span class="s3">&quot;cairo&quot;</span><span class="s1">)</span>
        <span class="s1">check_alt_backend(</span><span class="s3">&quot;svg&quot;</span><span class="s1">)</span>
    <span class="s1">mpl.use(backend</span><span class="s0">, </span><span class="s1">force=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">assert_equal(</span>
        <span class="s1">type(fig.canvas).__module__</span><span class="s0">,</span>
        <span class="s3">&quot;matplotlib.backends.backend_{}&quot;</span><span class="s1">.format(backend))</span>

    <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s3">&quot;toolbar&quot;</span><span class="s1">] == </span><span class="s3">&quot;toolmanager&quot;</span><span class="s1">:</span>
        <span class="s2"># test toolbar button icon LA mode see GH issue 25174</span>
        <span class="s1">_test_toolbar_button_la_mode_icon(fig)</span>

    <span class="s1">ax.plot([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">fig.canvas.toolbar:  </span><span class="s2"># i.e toolbar2.</span>
        <span class="s1">fig.canvas.toolbar.draw_rubberband(</span><span class="s0">None, </span><span class="s4">1.</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">timer = fig.canvas.new_timer(</span><span class="s4">1.</span><span class="s1">)  </span><span class="s2"># Test that floats are cast to int.</span>
    <span class="s1">timer.add_callback(KeyEvent(</span><span class="s3">&quot;key_press_event&quot;</span><span class="s0">, </span><span class="s1">fig.canvas</span><span class="s0">, </span><span class="s3">&quot;q&quot;</span><span class="s1">)._process)</span>
    <span class="s2"># Trigger quitting upon draw.</span>
    <span class="s1">fig.canvas.mpl_connect(</span><span class="s3">&quot;draw_event&quot;</span><span class="s0">, lambda </span><span class="s1">event: timer.start())</span>
    <span class="s1">fig.canvas.mpl_connect(</span><span class="s3">&quot;close_event&quot;</span><span class="s0">, </span><span class="s1">print)</span>

    <span class="s1">result = io.BytesIO()</span>
    <span class="s1">fig.savefig(result</span><span class="s0">, </span><span class="s1">format=</span><span class="s3">'png'</span><span class="s1">)</span>

    <span class="s1">plt.show()</span>

    <span class="s2"># Ensure that the window is really closed.</span>
    <span class="s1">plt.pause(</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s2"># Test that saving works after interactive window is closed, but the figure</span>
    <span class="s2"># is not deleted.</span>
    <span class="s1">result_after = io.BytesIO()</span>
    <span class="s1">fig.savefig(result_after</span><span class="s0">, </span><span class="s1">format=</span><span class="s3">'png'</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">backend.startswith(</span><span class="s3">'qt5'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sys.platform == </span><span class="s3">'darwin'</span><span class="s1">:</span>
        <span class="s2"># FIXME: This should be enabled everywhere once Qt5 is fixed on macOS</span>
        <span class="s2"># to not resize incorrectly.</span>
        <span class="s1">assert_equal(result.getvalue()</span><span class="s0">, </span><span class="s1">result_after.getvalue())</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;env&quot;</span><span class="s0">, </span><span class="s1">_get_testable_interactive_backends())</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;toolbar&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;toolbar2&quot;</span><span class="s0">, </span><span class="s3">&quot;toolmanager&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.flaky(reruns=</span><span class="s4">3</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_interactive_backend(env</span><span class="s0">, </span><span class="s1">toolbar):</span>
    <span class="s0">if </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">&quot;macosx&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">toolbar == </span><span class="s3">&quot;toolmanager&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;toolmanager is not implemented for macosx.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">&quot;wx&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;wx backend is deprecated; tests failed on appveyor&quot;</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">proc = _run_helper(</span>
                <span class="s1">_test_interactive_impl</span><span class="s0">,</span>
                <span class="s1">json.dumps({</span><span class="s3">&quot;toolbar&quot;</span><span class="s1">: toolbar})</span><span class="s0">,</span>
                <span class="s1">timeout=_test_timeout</span><span class="s0">,</span>
                <span class="s1">extra_env=env</span><span class="s0">,</span>
                <span class="s1">)</span>
    <span class="s0">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">pytest.fail(</span>
                <span class="s3">&quot;Subprocess failed to test intended behavior</span><span class="s0">\n</span><span class="s3">&quot;</span>
                <span class="s1">+ str(err.stderr))</span>
    <span class="s0">assert </span><span class="s1">proc.stdout.count(</span><span class="s3">&quot;CloseEvent&quot;</span><span class="s1">) == </span><span class="s4">1</span>


<span class="s0">def </span><span class="s1">_test_thread_impl():</span>
    <span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ThreadPoolExecutor</span>

    <span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
    <span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">pyplot </span><span class="s0">as </span><span class="s1">plt</span>

    <span class="s1">mpl.rcParams.update({</span>
        <span class="s3">&quot;webagg.open_in_browser&quot;</span><span class="s1">: </span><span class="s0">False,</span>
        <span class="s3">&quot;webagg.port_retries&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">})</span>

    <span class="s2"># Test artist creation and drawing does not crash from thread</span>
    <span class="s2"># No other guarantees!</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s2"># plt.pause needed vs plt.show(block=False) at least on toolbar2-tkagg</span>
    <span class="s1">plt.pause(</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s1">future = ThreadPoolExecutor().submit(ax.plot</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s1">])</span>
    <span class="s1">future.result()  </span><span class="s2"># Joins the thread; rethrows any exception.</span>

    <span class="s1">fig.canvas.mpl_connect(</span><span class="s3">&quot;close_event&quot;</span><span class="s0">, </span><span class="s1">print)</span>
    <span class="s1">future = ThreadPoolExecutor().submit(fig.canvas.draw)</span>
    <span class="s1">plt.pause(</span><span class="s4">0.5</span><span class="s1">)  </span><span class="s2"># flush_events fails here on at least Tkagg (bpo-41176)</span>
    <span class="s1">future.result()  </span><span class="s2"># Joins the thread; rethrows any exception.</span>
    <span class="s1">plt.close()  </span><span class="s2"># backend is responsible for flushing any events here</span>
    <span class="s0">if </span><span class="s1">plt.rcParams[</span><span class="s3">&quot;backend&quot;</span><span class="s1">].startswith(</span><span class="s3">&quot;WX&quot;</span><span class="s1">):</span>
        <span class="s2"># TODO: debug why WX needs this only on py3.8</span>
        <span class="s1">fig.canvas.flush_events()</span>


<span class="s1">_thread_safe_backends = _get_testable_interactive_backends()</span>
<span class="s2"># Known unsafe backends. Remove the xfails if they start to pass!</span>
<span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">_thread_safe_backends:</span>
    <span class="s1">backend = param.values[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s3">&quot;cairo&quot; </span><span class="s0">in </span><span class="s1">backend:</span>
        <span class="s2"># Cairo backends save a cairo_t on the graphics context, and sharing</span>
        <span class="s2"># these is not threadsafe.</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.xfail(raises=subprocess.CalledProcessError))</span>
    <span class="s0">elif </span><span class="s1">backend == </span><span class="s3">&quot;wx&quot;</span><span class="s1">:</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.xfail(raises=subprocess.CalledProcessError))</span>
    <span class="s0">elif </span><span class="s1">backend == </span><span class="s3">&quot;macosx&quot;</span><span class="s1">:</span>
        <span class="s0">from </span><span class="s1">packaging.version </span><span class="s0">import </span><span class="s1">parse</span>
        <span class="s1">mac_ver = platform.mac_ver()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2"># Note, macOS Big Sur is both 11 and 10.16, depending on SDK that</span>
        <span class="s2"># Python was compiled against.</span>
        <span class="s0">if </span><span class="s1">mac_ver </span><span class="s0">and </span><span class="s1">parse(mac_ver) &lt; parse(</span><span class="s3">'10.16'</span><span class="s1">):</span>
            <span class="s1">param.marks.append(</span>
                <span class="s1">pytest.mark.xfail(raises=subprocess.TimeoutExpired</span><span class="s0">,</span>
                                  <span class="s1">strict=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">param.values[</span><span class="s4">0</span><span class="s1">].get(</span><span class="s3">&quot;QT_API&quot;</span><span class="s1">) == </span><span class="s3">&quot;PySide2&quot;</span><span class="s1">:</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.xfail(raises=subprocess.CalledProcessError))</span>
    <span class="s0">elif </span><span class="s1">backend == </span><span class="s3">&quot;tkagg&quot; </span><span class="s0">and </span><span class="s1">platform.python_implementation() != </span><span class="s3">'CPython'</span><span class="s1">:</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.xfail(</span>
                <span class="s1">reason=</span><span class="s3">'PyPy does not support Tkinter threading: '</span>
                       <span class="s3">'https://foss.heptapod.net/pypy/pypy/-/issues/1929'</span><span class="s0">,</span>
                <span class="s1">strict=</span><span class="s0">True</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;env&quot;</span><span class="s0">, </span><span class="s1">_thread_safe_backends)</span>
<span class="s1">@pytest.mark.flaky(reruns=</span><span class="s4">3</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_interactive_thread_safety(env):</span>
    <span class="s1">proc = _run_helper(_test_thread_impl</span><span class="s0">, </span><span class="s1">timeout=_test_timeout</span><span class="s0">, </span><span class="s1">extra_env=env)</span>
    <span class="s0">assert </span><span class="s1">proc.stdout.count(</span><span class="s3">&quot;CloseEvent&quot;</span><span class="s1">) == </span><span class="s4">1</span>


<span class="s0">def </span><span class="s1">_impl_test_lazy_auto_backend_selection():</span>
    <span class="s0">import </span><span class="s1">matplotlib</span>
    <span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
    <span class="s2"># just importing pyplot should not be enough to trigger resolution</span>
    <span class="s1">bk = matplotlib.rcParams._get(</span><span class="s3">'backend'</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">isinstance(bk</span><span class="s0">, </span><span class="s1">str)</span>
    <span class="s0">assert </span><span class="s1">plt._backend_mod </span><span class="s0">is None</span>
    <span class="s2"># but actually plotting should</span>
    <span class="s1">plt.plot(</span><span class="s4">5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">plt._backend_mod </span><span class="s0">is not None</span>
    <span class="s1">bk = matplotlib.rcParams._get(</span><span class="s3">'backend'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(bk</span><span class="s0">, </span><span class="s1">str)</span>


<span class="s0">def </span><span class="s1">test_lazy_auto_backend_selection():</span>
    <span class="s1">_run_helper(_impl_test_lazy_auto_backend_selection</span><span class="s0">,</span>
                <span class="s1">timeout=_test_timeout)</span>


<span class="s0">def </span><span class="s1">_implqt5agg():</span>
    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt5agg  </span><span class="s2"># noqa</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s0">assert </span><span class="s3">'PyQt6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'pyside6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'PyQt5' </span><span class="s0">in </span><span class="s1">sys.modules </span><span class="s0">or </span><span class="s3">'pyside2' </span><span class="s0">in </span><span class="s1">sys.modules</span>

    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt5</span>
    <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                      <span class="s1">match=</span><span class="s3">&quot;QtWidgets.QApplication.instance&quot;</span><span class="s1">):</span>
        <span class="s1">matplotlib.backends.backend_qt5.qApp</span>


<span class="s0">def </span><span class="s1">_implcairo():</span>
    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt5cairo </span><span class="s2"># noqa</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s0">assert </span><span class="s3">'PyQt6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'pyside6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'PyQt5' </span><span class="s0">in </span><span class="s1">sys.modules </span><span class="s0">or </span><span class="s3">'pyside2' </span><span class="s0">in </span><span class="s1">sys.modules</span>

    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt5</span>
    <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                      <span class="s1">match=</span><span class="s3">&quot;QtWidgets.QApplication.instance&quot;</span><span class="s1">):</span>
        <span class="s1">matplotlib.backends.backend_qt5.qApp</span>


<span class="s0">def </span><span class="s1">_implcore():</span>
    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt5</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s0">assert </span><span class="s3">'PyQt6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'pyside6' </span><span class="s0">not in </span><span class="s1">sys.modules</span>
    <span class="s0">assert </span><span class="s3">'PyQt5' </span><span class="s0">in </span><span class="s1">sys.modules </span><span class="s0">or </span><span class="s3">'pyside2' </span><span class="s0">in </span><span class="s1">sys.modules</span>

    <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">,</span>
                      <span class="s1">match=</span><span class="s3">&quot;QtWidgets.QApplication.instance&quot;</span><span class="s1">):</span>
        <span class="s1">matplotlib.backends.backend_qt5.qApp</span>


<span class="s0">def </span><span class="s1">test_qt5backends_uses_qt5():</span>
    <span class="s1">qt5_bindings = [</span>
        <span class="s1">dep </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'PyQt5'</span><span class="s0">, </span><span class="s3">'pyside2'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">importlib.util.find_spec(dep) </span><span class="s0">is not None</span>
    <span class="s1">]</span>
    <span class="s1">qt6_bindings = [</span>
        <span class="s1">dep </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'PyQt6'</span><span class="s0">, </span><span class="s3">'pyside6'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">importlib.util.find_spec(dep) </span><span class="s0">is not None</span>
    <span class="s1">]</span>
    <span class="s0">if </span><span class="s1">len(qt5_bindings) == </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">len(qt6_bindings) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s3">'need both QT6 and QT5 bindings'</span><span class="s1">)</span>
    <span class="s1">_run_helper(_implqt5agg</span><span class="s0">, </span><span class="s1">timeout=_test_timeout)</span>
    <span class="s0">if </span><span class="s1">importlib.util.find_spec(</span><span class="s3">'pycairo'</span><span class="s1">) </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">_run_helper(_implcairo</span><span class="s0">, </span><span class="s1">timeout=_test_timeout)</span>
    <span class="s1">_run_helper(_implcore</span><span class="s0">, </span><span class="s1">timeout=_test_timeout)</span>


<span class="s0">def </span><span class="s1">_impl_test_cross_Qt_imports():</span>
    <span class="s0">import </span><span class="s1">sys</span>
    <span class="s0">import </span><span class="s1">importlib</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">host_binding</span><span class="s0">, </span><span class="s1">mpl_binding = sys.argv</span>
    <span class="s2"># import the mpl binding.  This will force us to use that binding</span>
    <span class="s1">importlib.import_module(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">mpl_binding</span><span class="s0">}</span><span class="s3">.QtCore'</span><span class="s1">)</span>
    <span class="s1">mpl_binding_qwidgets = importlib.import_module(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">mpl_binding</span><span class="s0">}</span><span class="s3">.QtWidgets'</span><span class="s1">)</span>
    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt</span>
    <span class="s1">host_qwidgets = importlib.import_module(</span><span class="s3">f'</span><span class="s0">{</span><span class="s1">host_binding</span><span class="s0">}</span><span class="s3">.QtWidgets'</span><span class="s1">)</span>

    <span class="s1">host_app = host_qwidgets.QApplication([</span><span class="s3">&quot;mpl testing&quot;</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Mixing Qt major&quot;</span><span class="s1">):</span>
        <span class="s1">matplotlib.backends.backend_qt._create_qApp()</span>


<span class="s0">def </span><span class="s1">test_cross_Qt_imports():</span>
    <span class="s1">qt5_bindings = [</span>
        <span class="s1">dep </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'PyQt5'</span><span class="s0">, </span><span class="s3">'PySide2'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">importlib.util.find_spec(dep) </span><span class="s0">is not None</span>
    <span class="s1">]</span>
    <span class="s1">qt6_bindings = [</span>
        <span class="s1">dep </span><span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'PyQt6'</span><span class="s0">, </span><span class="s3">'PySide6'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">importlib.util.find_spec(dep) </span><span class="s0">is not None</span>
    <span class="s1">]</span>
    <span class="s0">if </span><span class="s1">len(qt5_bindings) == </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">len(qt6_bindings) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s3">'need both QT6 and QT5 bindings'</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">qt5 </span><span class="s0">in </span><span class="s1">qt5_bindings:</span>
        <span class="s0">for </span><span class="s1">qt6 </span><span class="s0">in </span><span class="s1">qt6_bindings:</span>
            <span class="s0">for </span><span class="s1">pair </span><span class="s0">in </span><span class="s1">([qt5</span><span class="s0">, </span><span class="s1">qt6]</span><span class="s0">, </span><span class="s1">[qt6</span><span class="s0">, </span><span class="s1">qt5]):</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">_run_helper(_impl_test_cross_Qt_imports</span><span class="s0">,</span>
                                <span class="s1">*pair</span><span class="s0">,</span>
                                <span class="s1">timeout=_test_timeout)</span>
                <span class="s0">except </span><span class="s1">subprocess.CalledProcessError </span><span class="s0">as </span><span class="s1">ex:</span>
                    <span class="s2"># if segfault, carry on.  We do try to warn the user they</span>
                    <span class="s2"># are doing something that we do not expect to work</span>
                    <span class="s0">if </span><span class="s1">ex.returncode == -signal.SIGSEGV:</span>
                        <span class="s0">continue</span>
                    <span class="s2"># We got the abort signal which is likely because the Qt5 /</span>
                    <span class="s2"># Qt6 cross import is unhappy, carry on.</span>
                    <span class="s0">elif </span><span class="s1">ex.returncode == -signal.SIGABRT:</span>
                        <span class="s0">continue</span>
                    <span class="s0">raise</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s3">'TF_BUILD' </span><span class="s0">in </span><span class="s1">os.environ</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;this test fails an azure for unknown reasons&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.skipif(os.name == </span><span class="s3">&quot;nt&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;Cannot send SIGINT on Windows.&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_webagg():</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;tornado&quot;</span><span class="s1">)</span>
    <span class="s1">proc = subprocess.Popen(</span>
        <span class="s1">[sys.executable</span><span class="s0">, </span><span class="s3">&quot;-c&quot;</span><span class="s0">,</span>
         <span class="s1">inspect.getsource(_test_interactive_impl)</span>
         <span class="s1">+ </span><span class="s3">&quot;</span><span class="s0">\n</span><span class="s3">_test_interactive_impl()&quot;</span><span class="s0">, </span><span class="s3">&quot;{}&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">env={**os.environ</span><span class="s0">, </span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">: </span><span class="s3">&quot;webagg&quot;</span><span class="s0">, </span><span class="s3">&quot;SOURCE_DATE_EPOCH&quot;</span><span class="s1">: </span><span class="s3">&quot;0&quot;</span><span class="s1">})</span>
    <span class="s1">url = </span><span class="s3">&quot;http://{}:{}&quot;</span><span class="s1">.format(</span>
        <span class="s1">mpl.rcParams[</span><span class="s3">&quot;webagg.address&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mpl.rcParams[</span><span class="s3">&quot;webagg.port&quot;</span><span class="s1">])</span>
    <span class="s1">timeout = time.perf_counter() + _test_timeout</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">retcode = proc.poll()</span>
            <span class="s2"># check that the subprocess for the server is not dead</span>
            <span class="s0">assert </span><span class="s1">retcode </span><span class="s0">is None</span>
            <span class="s1">conn = urllib.request.urlopen(url)</span>
            <span class="s0">break</span>
        <span class="s0">except </span><span class="s1">urllib.error.URLError:</span>
            <span class="s0">if </span><span class="s1">time.perf_counter() &gt; timeout:</span>
                <span class="s1">pytest.fail(</span><span class="s3">&quot;Failed to connect to the webagg server.&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">continue</span>
    <span class="s1">conn.close()</span>
    <span class="s1">proc.send_signal(signal.SIGINT)</span>
    <span class="s0">assert </span><span class="s1">proc.wait(timeout=_test_timeout) == </span><span class="s4">0</span>


<span class="s0">def </span><span class="s1">_lazy_headless():</span>
    <span class="s0">import </span><span class="s1">os</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s1">backend</span><span class="s0">, </span><span class="s1">deps = sys.argv[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s1">deps = deps.split(</span><span class="s3">','</span><span class="s1">)</span>

    <span class="s2"># make it look headless</span>
    <span class="s1">os.environ.pop(</span><span class="s3">'DISPLAY'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">os.environ.pop(</span><span class="s3">'WAYLAND_DISPLAY'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">deps:</span>
        <span class="s0">assert </span><span class="s1">dep </span><span class="s0">not in </span><span class="s1">sys.modules</span>

    <span class="s2"># we should fast-track to Agg</span>
    <span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
    <span class="s0">assert </span><span class="s1">plt.get_backend() == </span><span class="s3">'agg'</span>
    <span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">deps:</span>
        <span class="s0">assert </span><span class="s1">dep </span><span class="s0">not in </span><span class="s1">sys.modules</span>

    <span class="s2"># make sure we really have dependencies installed</span>
    <span class="s0">for </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">deps:</span>
        <span class="s1">importlib.import_module(dep)</span>
        <span class="s0">assert </span><span class="s1">dep </span><span class="s0">in </span><span class="s1">sys.modules</span>

    <span class="s2"># try to switch and make sure we fail with ImportError</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">plt.switch_backend(backend)</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">...</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(sys.platform != </span><span class="s3">&quot;linux&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;this a linux-only test&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;env&quot;</span><span class="s0">, </span><span class="s1">_get_testable_interactive_backends())</span>
<span class="s0">def </span><span class="s1">test_lazy_linux_headless(env):</span>
    <span class="s1">proc = _run_helper(</span>
        <span class="s1">_lazy_headless</span><span class="s0">,</span>
        <span class="s1">env.pop(</span><span class="s3">'MPLBACKEND'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">env.pop(</span><span class="s3">&quot;BACKEND_DEPS&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">timeout=_test_timeout</span><span class="s0">,</span>
        <span class="s1">extra_env={**env</span><span class="s0">, </span><span class="s3">'DISPLAY'</span><span class="s1">: </span><span class="s3">''</span><span class="s0">, </span><span class="s3">'WAYLAND_DISPLAY'</span><span class="s1">: </span><span class="s3">''</span><span class="s1">}</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_qApp_warn_impl():</span>
    <span class="s0">import </span><span class="s1">matplotlib.backends.backend_qt</span>
    <span class="s0">import </span><span class="s1">pytest</span>

    <span class="s0">with </span><span class="s1">pytest.warns(</span>
            <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;QtWidgets.QApplication.instance&quot;</span><span class="s1">):</span>
        <span class="s1">matplotlib.backends.backend_qt.qApp</span>


<span class="s1">@pytest.mark.backend(</span><span class="s3">'QtAgg'</span><span class="s0">, </span><span class="s1">skip_on_importerror=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_qApp_warn():</span>
    <span class="s1">_run_helper(_qApp_warn_impl</span><span class="s0">, </span><span class="s1">timeout=_test_timeout)</span>


<span class="s0">def </span><span class="s1">_test_number_of_draws_script():</span>
    <span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>

    <span class="s2"># animated=True tells matplotlib to only draw the artist when we</span>
    <span class="s2"># explicitly request it</span>
    <span class="s1">ln</span><span class="s0">, </span><span class="s1">= ax.plot([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">animated=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s2"># make sure the window is raised, but the script keeps going</span>
    <span class="s1">plt.show(block=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">plt.pause(</span><span class="s4">0.3</span><span class="s1">)</span>
    <span class="s2"># Connect to draw_event to count the occurrences</span>
    <span class="s1">fig.canvas.mpl_connect(</span><span class="s3">'draw_event'</span><span class="s0">, </span><span class="s1">print)</span>

    <span class="s2"># get copy of entire figure (everything inside fig.bbox)</span>
    <span class="s2"># sans animated artist</span>
    <span class="s1">bg = fig.canvas.copy_from_bbox(fig.bbox)</span>
    <span class="s2"># draw the animated artist, this uses a cached renderer</span>
    <span class="s1">ax.draw_artist(ln)</span>
    <span class="s2"># show the result to the screen</span>
    <span class="s1">fig.canvas.blit(fig.bbox)</span>

    <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s2"># reset the background back in the canvas state, screen unchanged</span>
        <span class="s1">fig.canvas.restore_region(bg)</span>
        <span class="s2"># Create a **new** artist here, this is poor usage of blitting</span>
        <span class="s2"># but good for testing to make sure that this doesn't create</span>
        <span class="s2"># excessive draws</span>
        <span class="s1">ln</span><span class="s0">, </span><span class="s1">= ax.plot([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2"># render the artist, updating the canvas state, but not the screen</span>
        <span class="s1">ax.draw_artist(ln)</span>
        <span class="s2"># copy the image to the GUI state, but screen might not changed yet</span>
        <span class="s1">fig.canvas.blit(fig.bbox)</span>
        <span class="s2"># flush any pending GUI events, re-painting the screen if needed</span>
        <span class="s1">fig.canvas.flush_events()</span>

    <span class="s2"># Let the event loop process everything before leaving</span>
    <span class="s1">plt.pause(</span><span class="s4">0.1</span><span class="s1">)</span>


<span class="s1">_blit_backends = _get_testable_interactive_backends()</span>
<span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">_blit_backends:</span>
    <span class="s1">backend = param.values[</span><span class="s4">0</span><span class="s1">][</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">backend == </span><span class="s3">&quot;gtk3cairo&quot;</span><span class="s1">:</span>
        <span class="s2"># copy_from_bbox only works when rendering to an ImageSurface</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.skip(</span><span class="s3">&quot;gtk3cairo does not support blitting&quot;</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">backend == </span><span class="s3">&quot;gtk4cairo&quot;</span><span class="s1">:</span>
        <span class="s2"># copy_from_bbox only works when rendering to an ImageSurface</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.skip(</span><span class="s3">&quot;gtk4cairo does not support blitting&quot;</span><span class="s1">))</span>
    <span class="s0">elif </span><span class="s1">backend == </span><span class="s3">&quot;wx&quot;</span><span class="s1">:</span>
        <span class="s1">param.marks.append(</span>
            <span class="s1">pytest.mark.skip(</span><span class="s3">&quot;wx does not support blitting&quot;</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;env&quot;</span><span class="s0">, </span><span class="s1">_blit_backends)</span>
<span class="s2"># subprocesses can struggle to get the display, so rerun a few times</span>
<span class="s1">@pytest.mark.flaky(reruns=</span><span class="s4">4</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_blitting_events(env):</span>
    <span class="s1">proc = _run_helper(</span>
        <span class="s1">_test_number_of_draws_script</span><span class="s0">, </span><span class="s1">timeout=_test_timeout</span><span class="s0">, </span><span class="s1">extra_env=env)</span>
    <span class="s2"># Count the number of draw_events we got. We could count some initial</span>
    <span class="s2"># canvas draws (which vary in number by backend), but the critical</span>
    <span class="s2"># check here is that it isn't 10 draws, which would be called if</span>
    <span class="s2"># blitting is not properly implemented</span>
    <span class="s1">ndraws = proc.stdout.count(</span><span class="s3">&quot;DrawEvent&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s4">0 </span><span class="s1">&lt; ndraws &lt; </span><span class="s4">5</span>


<span class="s2"># The source of this function gets extracted and run in another process, so it</span>
<span class="s2"># must be fully self-contained.</span>
<span class="s0">def </span><span class="s1">_test_figure_leak():</span>
    <span class="s0">import </span><span class="s1">gc</span>
    <span class="s0">import </span><span class="s1">sys</span>

    <span class="s0">import </span><span class="s1">psutil</span>
    <span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">pyplot </span><span class="s0">as </span><span class="s1">plt</span>
    <span class="s2"># Second argument is pause length, but if zero we should skip pausing</span>
    <span class="s1">t = float(sys.argv[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">p = psutil.Process()</span>

    <span class="s2"># Warmup cycle, this reasonably allocates a lot</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s0">if </span><span class="s1">t:</span>
            <span class="s1">plt.pause(t)</span>
        <span class="s1">plt.close(fig)</span>
    <span class="s1">mem = p.memory_info().rss</span>
    <span class="s1">gc.collect()</span>

    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s0">if </span><span class="s1">t:</span>
            <span class="s1">plt.pause(t)</span>
        <span class="s1">plt.close(fig)</span>
        <span class="s1">gc.collect()</span>
    <span class="s1">growth = p.memory_info().rss - mem</span>

    <span class="s1">print(growth)</span>


<span class="s2"># TODO: &quot;0.1&quot; memory threshold could be reduced 10x by fixing tkagg</span>
<span class="s1">@pytest.mark.skipif(sys.platform == </span><span class="s3">&quot;win32&quot;</span><span class="s0">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;appveyor tests fail; gh-22988 suggests reworking&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;env&quot;</span><span class="s0">, </span><span class="s1">_get_testable_interactive_backends())</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;time_mem&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">2_000_000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">30_000_000</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_figure_leak_20490(env</span><span class="s0">, </span><span class="s1">time_mem):</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;psutil&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;psutil needed to run this test&quot;</span><span class="s1">)</span>

    <span class="s2"># We haven't yet directly identified the leaks so test with a memory growth</span>
    <span class="s2"># threshold.</span>
    <span class="s1">pause_time</span><span class="s0">, </span><span class="s1">acceptable_memory_leakage = time_mem</span>
    <span class="s0">if </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">&quot;wx&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;wx backend is deprecated; tests failed on appveyor&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">&quot;macosx&quot; </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">env[</span><span class="s3">&quot;MPLBACKEND&quot;</span><span class="s1">] == </span><span class="s3">&quot;tkagg&quot; </span><span class="s0">and </span><span class="s1">sys.platform == </span><span class="s3">'darwin'</span>
    <span class="s1">):</span>
        <span class="s1">acceptable_memory_leakage += </span><span class="s4">11_000_000</span>

    <span class="s1">result = _run_helper(</span>
        <span class="s1">_test_figure_leak</span><span class="s0">, </span><span class="s1">str(pause_time)</span><span class="s0">,</span>
        <span class="s1">timeout=_test_timeout</span><span class="s0">, </span><span class="s1">extra_env=env)</span>

    <span class="s1">growth = int(result.stdout)</span>
    <span class="s0">assert </span><span class="s1">growth &lt;= acceptable_memory_leakage</span>
</pre>
</body>
</html>