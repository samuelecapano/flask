<html>
<head>
<title>containers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
containers.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0"># https://developers.google.com/protocol-buffers/</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0">#     * Redistributions of source code must retain the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#     * Redistributions in binary form must reproduce the above</span>
<span class="s0"># copyright notice, this list of conditions and the following disclaimer</span>
<span class="s0"># in the documentation and/or other materials provided with the</span>
<span class="s0"># distribution.</span>
<span class="s0">#     * Neither the name of Google Inc. nor the names of its</span>
<span class="s0"># contributors may be used to endorse or promote products derived from</span>
<span class="s0"># this software without specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s2">&quot;&quot;&quot;Contains container classes to represent different protocol buffer types. 
 
This file defines container classes which represent categories of protocol 
buffer field types which need extra maintenance. Currently these categories 
are: 
 
-   Repeated scalar fields - These are all repeated fields which aren't 
    composite (e.g. they are of simple types like int32, string, etc). 
-   Repeated composite fields - Repeated fields which are composite. This 
    includes groups and nested messages. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">collections.abc</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">pickle</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s3">,</span>
    <span class="s1">Iterable</span><span class="s3">,</span>
    <span class="s1">Iterator</span><span class="s3">,</span>
    <span class="s1">List</span><span class="s3">,</span>
    <span class="s1">MutableMapping</span><span class="s3">,</span>
    <span class="s1">MutableSequence</span><span class="s3">,</span>
    <span class="s1">NoReturn</span><span class="s3">,</span>
    <span class="s1">Optional</span><span class="s3">,</span>
    <span class="s1">Sequence</span><span class="s3">,</span>
    <span class="s1">TypeVar</span><span class="s3">,</span>
    <span class="s1">Union</span><span class="s3">,</span>
    <span class="s1">overload</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s1">_T = TypeVar(</span><span class="s4">'_T'</span><span class="s1">)</span>
<span class="s1">_K = TypeVar(</span><span class="s4">'_K'</span><span class="s1">)</span>
<span class="s1">_V = TypeVar(</span><span class="s4">'_V'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BaseContainer(Sequence[_T]):</span>
  <span class="s2">&quot;&quot;&quot;Base container class.&quot;&quot;&quot;</span>

  <span class="s0"># Minimizes memory usage and disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_message_listener'</span><span class="s3">, </span><span class="s4">'_values'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">message_listener: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Args: 
      message_listener: A MessageListener implementation. 
        The RepeatedScalarFieldContainer will call this object's 
        Modified() method when it is modified. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._message_listener = message_listener</span>
    <span class="s1">self._values = []</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key: int) -&gt; _T:</span>
    <span class="s1">...</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key: slice) -&gt; List[_T]:</span>
    <span class="s1">...</span>

  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
    <span class="s2">&quot;&quot;&quot;Retrieves item by the specified key.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self._values[key]</span>

  <span class="s3">def </span><span class="s1">__len__(self) -&gt; int:</span>
    <span class="s2">&quot;&quot;&quot;Returns the number of elements in the container.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">len(self._values)</span>

  <span class="s3">def </span><span class="s1">__ne__(self</span><span class="s3">, </span><span class="s1">other: Any) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Checks if another instance isn't equal to this one.&quot;&quot;&quot;</span>
    <span class="s0"># The concrete classes should define __eq__.</span>
    <span class="s3">return not </span><span class="s1">self == other</span>

  <span class="s1">__hash__ = </span><span class="s3">None</span>

  <span class="s3">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s3">return </span><span class="s1">repr(self._values)</span>

  <span class="s3">def </span><span class="s1">sort(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># Continue to support the old sort_function keyword argument.</span>
    <span class="s0"># This is expected to be a rare occurrence, so use LBYL to avoid</span>
    <span class="s0"># the overhead of actually catching KeyError.</span>
    <span class="s3">if </span><span class="s4">'sort_function' </span><span class="s3">in </span><span class="s1">kwargs:</span>
      <span class="s1">kwargs[</span><span class="s4">'cmp'</span><span class="s1">] = kwargs.pop(</span><span class="s4">'sort_function'</span><span class="s1">)</span>
    <span class="s1">self._values.sort(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

  <span class="s3">def </span><span class="s1">reverse(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self._values.reverse()</span>


<span class="s0"># TODO(slebedev): Remove this. BaseContainer does *not* conform to</span>
<span class="s0"># MutableSequence, only its subclasses do.</span>
<span class="s1">collections.abc.MutableSequence.register(BaseContainer)</span>


<span class="s3">class </span><span class="s1">RepeatedScalarFieldContainer(BaseContainer[_T]</span><span class="s3">, </span><span class="s1">MutableSequence[_T]):</span>
  <span class="s2">&quot;&quot;&quot;Simple, type-checked, list-like container for holding repeated scalars.&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_type_checker'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">message_listener: Any</span><span class="s3">,</span>
      <span class="s1">type_checker: Any</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Args: 
 
      message_listener: A MessageListener implementation. The 
      RepeatedScalarFieldContainer will call this object's Modified() method 
      when it is modified. 
      type_checker: A type_checkers.ValueChecker instance to run on elements 
      inserted into this container. 
    &quot;&quot;&quot;</span>
    <span class="s1">super().__init__(message_listener)</span>
    <span class="s1">self._type_checker = type_checker</span>

  <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Appends an item to the list. Similar to list.append().&quot;&quot;&quot;</span>
    <span class="s1">self._values.append(self._type_checker.CheckValue(value))</span>
    <span class="s3">if not </span><span class="s1">self._message_listener.dirty:</span>
      <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">key: int</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Inserts the item at the specified position. Similar to list.insert().&quot;&quot;&quot;</span>
    <span class="s1">self._values.insert(key</span><span class="s3">, </span><span class="s1">self._type_checker.CheckValue(value))</span>
    <span class="s3">if not </span><span class="s1">self._message_listener.dirty:</span>
      <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">elem_seq: Iterable[_T]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Extends by appending the given iterable. Similar to list.extend().&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">elem_seq </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">elem_seq_iter = iter(elem_seq)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s3">if not </span><span class="s1">elem_seq:</span>
        <span class="s0"># silently ignore falsy inputs :-/.</span>
        <span class="s0"># TODO(ptucker): Deprecate this behavior. b/18413862</span>
        <span class="s3">return</span>
      <span class="s3">raise</span>

    <span class="s1">new_values = [self._type_checker.CheckValue(elem) </span><span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">elem_seq_iter]</span>
    <span class="s3">if </span><span class="s1">new_values:</span>
      <span class="s1">self._values.extend(new_values)</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">MergeFrom(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">other: Union[</span><span class="s4">'RepeatedScalarFieldContainer[_T]'</span><span class="s3">, </span><span class="s1">Iterable[_T]]</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Appends the contents of another repeated field of the same type to this 
    one. We do not check the types of the individual fields. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._values.extend(other)</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">elem: _T):</span>
    <span class="s2">&quot;&quot;&quot;Removes an item from the list. Similar to list.remove().&quot;&quot;&quot;</span>
    <span class="s1">self._values.remove(elem)</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">key: Optional[int] = -</span><span class="s5">1</span><span class="s1">) -&gt; _T:</span>
    <span class="s2">&quot;&quot;&quot;Removes and returns an item at a given index. Similar to list.pop().&quot;&quot;&quot;</span>
    <span class="s1">value = self._values[key]</span>
    <span class="s1">self.__delitem__(key)</span>
    <span class="s3">return </span><span class="s1">value</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: int</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">...</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: slice</span><span class="s3">, </span><span class="s1">value: Iterable[_T]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">...</span>

  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Sets the item on the specified position.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">slice):</span>
      <span class="s3">if </span><span class="s1">key.step </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Extended slices not supported'</span><span class="s1">)</span>
      <span class="s1">self._values[key] = map(self._type_checker.CheckValue</span><span class="s3">, </span><span class="s1">value)</span>
      <span class="s1">self._message_listener.Modified()</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">self._values[key] = self._type_checker.CheckValue(value)</span>
      <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key: Union[int</span><span class="s3">, </span><span class="s1">slice]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Deletes the item at the specified position.&quot;&quot;&quot;</span>
    <span class="s3">del </span><span class="s1">self._values[key]</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other: Any) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Compares the current instance with another one.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
      <span class="s3">return True</span>
    <span class="s0"># Special case for the same type which should be common and fast.</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">self.__class__):</span>
      <span class="s3">return </span><span class="s1">other._values == self._values</span>
    <span class="s0"># We are presumably comparing against some other sequence type.</span>
    <span class="s3">return </span><span class="s1">other == self._values</span>

  <span class="s3">def </span><span class="s1">__deepcopy__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">unused_memo: Any = </span><span class="s3">None,</span>
  <span class="s1">) -&gt; </span><span class="s4">'RepeatedScalarFieldContainer[_T]'</span><span class="s1">:</span>
    <span class="s1">clone = RepeatedScalarFieldContainer(</span>
        <span class="s1">copy.deepcopy(self._message_listener)</span><span class="s3">, </span><span class="s1">self._type_checker)</span>
    <span class="s1">clone.MergeFrom(self)</span>
    <span class="s3">return </span><span class="s1">clone</span>

  <span class="s3">def </span><span class="s1">__reduce__(self</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; NoReturn:</span>
    <span class="s3">raise </span><span class="s1">pickle.PickleError(</span>
        <span class="s4">&quot;Can't pickle repeated scalar fields, convert to list first&quot;</span><span class="s1">)</span>


<span class="s0"># TODO(slebedev): Constrain T to be a subtype of Message.</span>
<span class="s3">class </span><span class="s1">RepeatedCompositeFieldContainer(BaseContainer[_T]</span><span class="s3">, </span><span class="s1">MutableSequence[_T]):</span>
  <span class="s2">&quot;&quot;&quot;Simple, list-like container for holding repeated composite fields.&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_message_descriptor'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">message_listener: Any</span><span class="s3">, </span><span class="s1">message_descriptor: Any) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Note that we pass in a descriptor instead of the generated directly, 
    since at the time we construct a _RepeatedCompositeFieldContainer we 
    haven't yet necessarily initialized the type that will be contained in the 
    container. 
 
    Args: 
      message_listener: A MessageListener implementation. 
        The RepeatedCompositeFieldContainer will call this object's 
        Modified() method when it is modified. 
      message_descriptor: A Descriptor instance describing the protocol type 
        that should be present in this container.  We'll use the 
        _concrete_class field of this descriptor when the client calls add(). 
    &quot;&quot;&quot;</span>
    <span class="s1">super().__init__(message_listener)</span>
    <span class="s1">self._message_descriptor = message_descriptor</span>

  <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">**kwargs: Any) -&gt; _T:</span>
    <span class="s2">&quot;&quot;&quot;Adds a new element at the end of the list and returns it. Keyword 
    arguments may be used to initialize the element. 
    &quot;&quot;&quot;</span>
    <span class="s1">new_element = self._message_descriptor._concrete_class(**kwargs)</span>
    <span class="s1">new_element._SetListener(self._message_listener)</span>
    <span class="s1">self._values.append(new_element)</span>
    <span class="s3">if not </span><span class="s1">self._message_listener.dirty:</span>
      <span class="s1">self._message_listener.Modified()</span>
    <span class="s3">return </span><span class="s1">new_element</span>

  <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Appends one element by copying the message.&quot;&quot;&quot;</span>
    <span class="s1">new_element = self._message_descriptor._concrete_class()</span>
    <span class="s1">new_element._SetListener(self._message_listener)</span>
    <span class="s1">new_element.CopyFrom(value)</span>
    <span class="s1">self._values.append(new_element)</span>
    <span class="s3">if not </span><span class="s1">self._message_listener.dirty:</span>
      <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">key: int</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Inserts the item at the specified position by copying.&quot;&quot;&quot;</span>
    <span class="s1">new_element = self._message_descriptor._concrete_class()</span>
    <span class="s1">new_element._SetListener(self._message_listener)</span>
    <span class="s1">new_element.CopyFrom(value)</span>
    <span class="s1">self._values.insert(key</span><span class="s3">, </span><span class="s1">new_element)</span>
    <span class="s3">if not </span><span class="s1">self._message_listener.dirty:</span>
      <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">elem_seq: Iterable[_T]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Extends by appending the given sequence of elements of the same type 
 
    as this one, copying each individual message. 
    &quot;&quot;&quot;</span>
    <span class="s1">message_class = self._message_descriptor._concrete_class</span>
    <span class="s1">listener = self._message_listener</span>
    <span class="s1">values = self._values</span>
    <span class="s3">for </span><span class="s1">message </span><span class="s3">in </span><span class="s1">elem_seq:</span>
      <span class="s1">new_element = message_class()</span>
      <span class="s1">new_element._SetListener(listener)</span>
      <span class="s1">new_element.MergeFrom(message)</span>
      <span class="s1">values.append(new_element)</span>
    <span class="s1">listener.Modified()</span>

  <span class="s3">def </span><span class="s1">MergeFrom(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">other: Union[</span><span class="s4">'RepeatedCompositeFieldContainer[_T]'</span><span class="s3">, </span><span class="s1">Iterable[_T]]</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Appends the contents of another repeated field of the same type to this 
    one, copying each individual message. 
    &quot;&quot;&quot;</span>
    <span class="s1">self.extend(other)</span>

  <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">elem: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Removes an item from the list. Similar to list.remove().&quot;&quot;&quot;</span>
    <span class="s1">self._values.remove(elem)</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">key: Optional[int] = -</span><span class="s5">1</span><span class="s1">) -&gt; _T:</span>
    <span class="s2">&quot;&quot;&quot;Removes and returns an item at a given index. Similar to list.pop().&quot;&quot;&quot;</span>
    <span class="s1">value = self._values[key]</span>
    <span class="s1">self.__delitem__(key)</span>
    <span class="s3">return </span><span class="s1">value</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: int</span><span class="s3">, </span><span class="s1">value: _T) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">...</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: slice</span><span class="s3">, </span><span class="s1">value: Iterable[_T]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">...</span>

  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s0"># This method is implemented to make RepeatedCompositeFieldContainer</span>
    <span class="s0"># structurally compatible with typing.MutableSequence. It is</span>
    <span class="s0"># otherwise unsupported and will always raise an error.</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span>
        <span class="s4">f'</span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">} </span><span class="s4">object does not support item assignment'</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key: Union[int</span><span class="s3">, </span><span class="s1">slice]) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Deletes the item at the specified position.&quot;&quot;&quot;</span>
    <span class="s3">del </span><span class="s1">self._values[key]</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other: Any) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Compares the current instance with another one.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
      <span class="s3">return True</span>
    <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">self.__class__):</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Can only compare repeated composite fields against '</span>
                      <span class="s4">'other repeated composite fields.'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">self._values == other._values</span>


<span class="s3">class </span><span class="s1">ScalarMap(MutableMapping[_K</span><span class="s3">, </span><span class="s1">_V]):</span>
  <span class="s2">&quot;&quot;&quot;Simple, type-checked, dict-like container for holding repeated scalars.&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_key_checker'</span><span class="s3">, </span><span class="s4">'_value_checker'</span><span class="s3">, </span><span class="s4">'_values'</span><span class="s3">, </span><span class="s4">'_message_listener'</span><span class="s3">,</span>
               <span class="s4">'_entry_descriptor'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">message_listener: Any</span><span class="s3">,</span>
      <span class="s1">key_checker: Any</span><span class="s3">,</span>
      <span class="s1">value_checker: Any</span><span class="s3">,</span>
      <span class="s1">entry_descriptor: Any</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Args: 
      message_listener: A MessageListener implementation. 
        The ScalarMap will call this object's Modified() method when it 
        is modified. 
      key_checker: A type_checkers.ValueChecker instance to run on keys 
        inserted into this container. 
      value_checker: A type_checkers.ValueChecker instance to run on values 
        inserted into this container. 
      entry_descriptor: The MessageDescriptor of a map entry: key and value. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._message_listener = message_listener</span>
    <span class="s1">self._key_checker = key_checker</span>
    <span class="s1">self._value_checker = value_checker</span>
    <span class="s1">self._entry_descriptor = entry_descriptor</span>
    <span class="s1">self._values = {}</span>

  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; _V:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self._values[key]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
      <span class="s1">key = self._key_checker.CheckValue(key)</span>
      <span class="s1">val = self._value_checker.DefaultValue()</span>
      <span class="s1">self._values[key] = val</span>
      <span class="s3">return </span><span class="s1">val</span>

  <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">item: _K) -&gt; bool:</span>
    <span class="s0"># We check the key's type to match the strong-typing flavor of the API.</span>
    <span class="s0"># Also this makes it easier to match the behavior of the C++ implementation.</span>
    <span class="s1">self._key_checker.CheckValue(item)</span>
    <span class="s3">return </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self._values</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; Optional[_V]:</span>
    <span class="s1">...</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key: _K</span><span class="s3">, </span><span class="s1">default: _T) -&gt; Union[_V</span><span class="s3">, </span><span class="s1">_T]:</span>
    <span class="s1">...</span>

  <span class="s0"># We need to override this explicitly, because our defaultdict-like behavior</span>
  <span class="s0"># will make the default implementation (from our base class) always insert</span>
  <span class="s0"># the key.</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
      <span class="s3">return </span><span class="s1">self[key]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">default</span>

  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: _K</span><span class="s3">, </span><span class="s1">value: _V) -&gt; _T:</span>
    <span class="s1">checked_key = self._key_checker.CheckValue(key)</span>
    <span class="s1">checked_value = self._value_checker.CheckValue(value)</span>
    <span class="s1">self._values[checked_key] = checked_value</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s3">del </span><span class="s1">self._values[key]</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__len__(self) -&gt; int:</span>
    <span class="s3">return </span><span class="s1">len(self._values)</span>

  <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[_K]:</span>
    <span class="s3">return </span><span class="s1">iter(self._values)</span>

  <span class="s3">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s3">return </span><span class="s1">repr(self._values)</span>

  <span class="s3">def </span><span class="s1">MergeFrom(self</span><span class="s3">, </span><span class="s1">other: </span><span class="s4">'ScalarMap[_K, _V]'</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self._values.update(other._values)</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">InvalidateIterators(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># It appears that the only way to reliably invalidate iterators to</span>
    <span class="s0"># self._values is to ensure that its size changes.</span>
    <span class="s1">original = self._values</span>
    <span class="s1">self._values = original.copy()</span>
    <span class="s1">original[</span><span class="s3">None</span><span class="s1">] = </span><span class="s3">None</span>

  <span class="s0"># This is defined in the abstract base, but we can do it much more cheaply.</span>
  <span class="s3">def </span><span class="s1">clear(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self._values.clear()</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">GetEntryClass(self) -&gt; Any:</span>
    <span class="s3">return </span><span class="s1">self._entry_descriptor._concrete_class</span>


<span class="s3">class </span><span class="s1">MessageMap(MutableMapping[_K</span><span class="s3">, </span><span class="s1">_V]):</span>
  <span class="s2">&quot;&quot;&quot;Simple, type-checked, dict-like container for with submessage values.&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_key_checker'</span><span class="s3">, </span><span class="s4">'_values'</span><span class="s3">, </span><span class="s4">'_message_listener'</span><span class="s3">,</span>
               <span class="s4">'_message_descriptor'</span><span class="s3">, </span><span class="s4">'_entry_descriptor'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">message_listener: Any</span><span class="s3">,</span>
      <span class="s1">message_descriptor: Any</span><span class="s3">,</span>
      <span class="s1">key_checker: Any</span><span class="s3">,</span>
      <span class="s1">entry_descriptor: Any</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Args: 
      message_listener: A MessageListener implementation. 
        The ScalarMap will call this object's Modified() method when it 
        is modified. 
      key_checker: A type_checkers.ValueChecker instance to run on keys 
        inserted into this container. 
      value_checker: A type_checkers.ValueChecker instance to run on values 
        inserted into this container. 
      entry_descriptor: The MessageDescriptor of a map entry: key and value. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._message_listener = message_listener</span>
    <span class="s1">self._message_descriptor = message_descriptor</span>
    <span class="s1">self._key_checker = key_checker</span>
    <span class="s1">self._entry_descriptor = entry_descriptor</span>
    <span class="s1">self._values = {}</span>

  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; _V:</span>
    <span class="s1">key = self._key_checker.CheckValue(key)</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self._values[key]</span>
    <span class="s3">except </span><span class="s1">KeyError:</span>
      <span class="s1">new_element = self._message_descriptor._concrete_class()</span>
      <span class="s1">new_element._SetListener(self._message_listener)</span>
      <span class="s1">self._values[key] = new_element</span>
      <span class="s1">self._message_listener.Modified()</span>
      <span class="s3">return </span><span class="s1">new_element</span>

  <span class="s3">def </span><span class="s1">get_or_create(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; _V:</span>
    <span class="s2">&quot;&quot;&quot;get_or_create() is an alias for getitem (ie. map[key]). 
 
    Args: 
      key: The key to get or create in the map. 
 
    This is useful in cases where you want to be explicit that the call is 
    mutating the map.  This can avoid lint errors for statements like this 
    that otherwise would appear to be pointless statements: 
 
      msg.my_map[key] 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self[key]</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; Optional[_V]:</span>
    <span class="s1">...</span>

  <span class="s1">@overload</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key: _K</span><span class="s3">, </span><span class="s1">default: _T) -&gt; Union[_V</span><span class="s3">, </span><span class="s1">_T]:</span>
    <span class="s1">...</span>

  <span class="s0"># We need to override this explicitly, because our defaultdict-like behavior</span>
  <span class="s0"># will make the default implementation (from our base class) always insert</span>
  <span class="s0"># the key.</span>
  <span class="s3">def </span><span class="s1">get(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">default=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
      <span class="s3">return </span><span class="s1">self[key]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">default</span>

  <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">item: _K) -&gt; bool:</span>
    <span class="s1">item = self._key_checker.CheckValue(item)</span>
    <span class="s3">return </span><span class="s1">item </span><span class="s3">in </span><span class="s1">self._values</span>

  <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key: _K</span><span class="s3">, </span><span class="s1">value: _V) -&gt; NoReturn:</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'May not set values directly, call my_map[key].foo = 5'</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">key: _K) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">key = self._key_checker.CheckValue(key)</span>
    <span class="s3">del </span><span class="s1">self._values[key]</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">__len__(self) -&gt; int:</span>
    <span class="s3">return </span><span class="s1">len(self._values)</span>

  <span class="s3">def </span><span class="s1">__iter__(self) -&gt; Iterator[_K]:</span>
    <span class="s3">return </span><span class="s1">iter(self._values)</span>

  <span class="s3">def </span><span class="s1">__repr__(self) -&gt; str:</span>
    <span class="s3">return </span><span class="s1">repr(self._values)</span>

  <span class="s3">def </span><span class="s1">MergeFrom(self</span><span class="s3">, </span><span class="s1">other: </span><span class="s4">'MessageMap[_K, _V]'</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">other._values:</span>
      <span class="s0"># According to documentation: &quot;When parsing from the wire or when merging,</span>
      <span class="s0"># if there are duplicate map keys the last key seen is used&quot;.</span>
      <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self:</span>
        <span class="s3">del </span><span class="s1">self[key]</span>
      <span class="s1">self[key].CopyFrom(other[key])</span>
    <span class="s0"># self._message_listener.Modified() not required here, because</span>
    <span class="s0"># mutations to submessages already propagate.</span>

  <span class="s3">def </span><span class="s1">InvalidateIterators(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># It appears that the only way to reliably invalidate iterators to</span>
    <span class="s0"># self._values is to ensure that its size changes.</span>
    <span class="s1">original = self._values</span>
    <span class="s1">self._values = original.copy()</span>
    <span class="s1">original[</span><span class="s3">None</span><span class="s1">] = </span><span class="s3">None</span>

  <span class="s0"># This is defined in the abstract base, but we can do it much more cheaply.</span>
  <span class="s3">def </span><span class="s1">clear(self) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self._values.clear()</span>
    <span class="s1">self._message_listener.Modified()</span>

  <span class="s3">def </span><span class="s1">GetEntryClass(self) -&gt; Any:</span>
    <span class="s3">return </span><span class="s1">self._entry_descriptor._concrete_class</span>


<span class="s3">class </span><span class="s1">_UnknownField:</span>
  <span class="s2">&quot;&quot;&quot;A parsed unknown field.&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_field_number'</span><span class="s3">, </span><span class="s4">'_wire_type'</span><span class="s3">, </span><span class="s4">'_data'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">field_number</span><span class="s3">, </span><span class="s1">wire_type</span><span class="s3">, </span><span class="s1">data):</span>
    <span class="s1">self._field_number = field_number</span>
    <span class="s1">self._wire_type = wire_type</span>
    <span class="s1">self._data = data</span>
    <span class="s3">return</span>

  <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">return </span><span class="s1">self._field_number &lt; other._field_number</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
      <span class="s3">return True</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">return </span><span class="s1">(self._field_number == other._field_number </span><span class="s3">and</span>
            <span class="s1">self._wire_type == other._wire_type </span><span class="s3">and</span>
            <span class="s1">self._data == other._data)</span>


<span class="s3">class </span><span class="s1">UnknownFieldRef:  </span><span class="s0"># pylint: disable=missing-class-docstring</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">parent</span><span class="s3">, </span><span class="s1">index):</span>
    <span class="s1">self._parent = parent</span>
    <span class="s1">self._index = index</span>

  <span class="s3">def </span><span class="s1">_check_valid(self):</span>
    <span class="s3">if not </span><span class="s1">self._parent:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'UnknownField does not exist. '</span>
                       <span class="s4">'The parent message might be cleared.'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">self._index &gt;= len(self._parent):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'UnknownField does not exist. '</span>
                       <span class="s4">'The parent message might be cleared.'</span><span class="s1">)</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">field_number(self):</span>
    <span class="s1">self._check_valid()</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">return </span><span class="s1">self._parent._internal_get(self._index)._field_number</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">wire_type(self):</span>
    <span class="s1">self._check_valid()</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">return </span><span class="s1">self._parent._internal_get(self._index)._wire_type</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">data(self):</span>
    <span class="s1">self._check_valid()</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s3">return </span><span class="s1">self._parent._internal_get(self._index)._data</span>


<span class="s3">class </span><span class="s1">UnknownFieldSet:</span>
  <span class="s2">&quot;&quot;&quot;UnknownField container&quot;&quot;&quot;</span>

  <span class="s0"># Disallows assignment to other attributes.</span>
  <span class="s1">__slots__ = [</span><span class="s4">'_values'</span><span class="s1">]</span>

  <span class="s3">def </span><span class="s1">__init__(self):</span>
    <span class="s1">self._values = []</span>

  <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">index):</span>
    <span class="s3">if </span><span class="s1">self._values </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'UnknownFields does not exist. '</span>
                       <span class="s4">'The parent message might be cleared.'</span><span class="s1">)</span>
    <span class="s1">size = len(self._values)</span>
    <span class="s3">if </span><span class="s1">index &lt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s1">index += size</span>
    <span class="s3">if </span><span class="s1">index &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">index &gt;= size:</span>
      <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s4">'index %d out of range'</span><span class="s1">.index)</span>

    <span class="s3">return </span><span class="s1">UnknownFieldRef(self</span><span class="s3">, </span><span class="s1">index)</span>

  <span class="s3">def </span><span class="s1">_internal_get(self</span><span class="s3">, </span><span class="s1">index):</span>
    <span class="s3">return </span><span class="s1">self._values[index]</span>

  <span class="s3">def </span><span class="s1">__len__(self):</span>
    <span class="s3">if </span><span class="s1">self._values </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'UnknownFields does not exist. '</span>
                       <span class="s4">'The parent message might be cleared.'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">len(self._values)</span>

  <span class="s3">def </span><span class="s1">_add(self</span><span class="s3">, </span><span class="s1">field_number</span><span class="s3">, </span><span class="s1">wire_type</span><span class="s3">, </span><span class="s1">data):</span>
    <span class="s1">unknown_field = _UnknownField(field_number</span><span class="s3">, </span><span class="s1">wire_type</span><span class="s3">, </span><span class="s1">data)</span>
    <span class="s1">self._values.append(unknown_field)</span>
    <span class="s3">return </span><span class="s1">unknown_field</span>

  <span class="s3">def </span><span class="s1">__iter__(self):</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(self)):</span>
      <span class="s3">yield </span><span class="s1">UnknownFieldRef(self</span><span class="s3">, </span><span class="s1">i)</span>

  <span class="s3">def </span><span class="s1">_extend(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">other </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">self._values.extend(other._values)</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other:</span>
      <span class="s3">return True</span>
    <span class="s0"># Sort unknown fields because their order shouldn't</span>
    <span class="s0"># affect equality test.</span>
    <span class="s1">values = list(self._values)</span>
    <span class="s3">if </span><span class="s1">other </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return not </span><span class="s1">values</span>
    <span class="s1">values.sort()</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">other_values = sorted(other._values)</span>
    <span class="s3">return </span><span class="s1">values == other_values</span>

  <span class="s3">def </span><span class="s1">_clear(self):</span>
    <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">self._values:</span>
      <span class="s0"># pylint: disable=protected-access</span>
      <span class="s3">if </span><span class="s1">isinstance(value._data</span><span class="s3">, </span><span class="s1">UnknownFieldSet):</span>
        <span class="s1">value._data._clear()  </span><span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">self._values = </span><span class="s3">None</span>
</pre>
</body>
</html>