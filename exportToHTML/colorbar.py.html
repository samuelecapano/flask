<html>
<head>
<title>colorbar.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
colorbar.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Colorbars are a visualization of the mapping from scalar values to colors. 
In Matplotlib they are drawn into a dedicated `~.axes.Axes`. 
 
.. note:: 
   Colorbars are typically created through `.Figure.colorbar` or its pyplot 
   wrapper `.pyplot.colorbar`, which internally use `.Colorbar` together with 
   `.make_axes_gridspec` (for `.GridSpec`-positioned axes) or `.make_axes` (for 
   non-`.GridSpec`-positioned axes). 
 
   End-users most likely won't need to directly use this module's API. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">collections</span><span class="s2">, </span><span class="s1">cm</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">contour</span><span class="s2">, </span><span class="s1">ticker</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">import </span><span class="s1">matplotlib.patches </span><span class="s2">as </span><span class="s1">mpatches</span>
<span class="s2">import </span><span class="s1">matplotlib.path </span><span class="s2">as </span><span class="s1">mpath</span>
<span class="s2">import </span><span class="s1">matplotlib.spines </span><span class="s2">as </span><span class="s1">mspines</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_docstring</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s1">_docstring.interpd.update(</span>
    <span class="s1">_make_axes_kw_doc=</span><span class="s3">&quot;&quot;&quot; 
location : None or {'left', 'right', 'top', 'bottom'} 
    The location, relative to the parent axes, where the colorbar axes 
    is created.  It also determines the *orientation* of the colorbar 
    (colorbars on the left and right are vertical, colorbars at the top 
    and bottom are horizontal).  If None, the location will come from the 
    *orientation* if it is set (vertical colorbars on the right, horizontal 
    ones at the bottom), or default to 'right' if *orientation* is unset. 
 
orientation : None or {'vertical', 'horizontal'} 
    The orientation of the colorbar.  It is preferable to set the *location* 
    of the colorbar, as that also determines the *orientation*; passing 
    incompatible values for *location* and *orientation* raises an exception. 
 
fraction : float, default: 0.15 
    Fraction of original axes to use for colorbar. 
 
shrink : float, default: 1.0 
    Fraction by which to multiply the size of the colorbar. 
 
aspect : float, default: 20 
    Ratio of long to short dimensions. 
 
pad : float, default: 0.05 if vertical, 0.15 if horizontal 
    Fraction of original axes between colorbar and new image axes. 
 
anchor : (float, float), optional 
    The anchor point of the colorbar axes. 
    Defaults to (0.0, 0.5) if vertical; (0.5, 1.0) if horizontal. 
 
panchor : (float, float), or *False*, optional 
    The anchor point of the colorbar parent axes. If *False*, the parent 
    axes' anchor will be unchanged. 
    Defaults to (1.0, 0.5) if vertical; (0.5, 0.0) if horizontal.&quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">_colormap_kw_doc=</span><span class="s3">&quot;&quot;&quot; 
extend : {'neither', 'both', 'min', 'max'} 
    Make pointed end(s) for out-of-range values (unless 'neither').  These are 
    set for a given colormap using the colormap set_under and set_over methods. 
 
extendfrac : {*None*, 'auto', length, lengths} 
    If set to *None*, both the minimum and maximum triangular colorbar 
    extensions will have a length of 5% of the interior colorbar length (this 
    is the default setting). 
 
    If set to 'auto', makes the triangular colorbar extensions the same lengths 
    as the interior boxes (when *spacing* is set to 'uniform') or the same 
    lengths as the respective adjacent interior boxes (when *spacing* is set to 
    'proportional'). 
 
    If a scalar, indicates the length of both the minimum and maximum 
    triangular colorbar extensions as a fraction of the interior colorbar 
    length.  A two-element sequence of fractions may also be given, indicating 
    the lengths of the minimum and maximum colorbar extensions respectively as 
    a fraction of the interior colorbar length. 
 
extendrect : bool 
    If *False* the minimum and maximum colorbar extensions will be triangular 
    (the default).  If *True* the extensions will be rectangular. 
 
spacing : {'uniform', 'proportional'} 
    For discrete colorbars (`.BoundaryNorm` or contours), 'uniform' gives each 
    color the same space; 'proportional' makes the space proportional to the 
    data interval. 
 
ticks : None or list of ticks or Locator 
    If None, ticks are determined automatically from the input. 
 
format : None or str or Formatter 
    If None, `~.ticker.ScalarFormatter` is used. 
    Format strings, e.g., ``&quot;%4.2e&quot;`` or ``&quot;{x:.2e}&quot;``, are supported. 
    An alternative `~.ticker.Formatter` may be given instead. 
 
drawedges : bool 
    Whether to draw lines at color boundaries. 
 
label : str 
    The label on the colorbar's long axis. 
 
boundaries, values : None or a sequence 
    If unset, the colormap will be displayed on a 0-1 scale. 
    If sequences, *values* must have a length 1 less than *boundaries*.  For 
    each region delimited by adjacent entries in *boundaries*, the color mapped 
    to the corresponding value in values will be used. 
    Normally only useful for indexed colors (i.e. ``norm=NoNorm()``) or other 
    unusual circumstances.&quot;&quot;&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_set_ticks_on_axis_warn(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s4"># a top level function which gets put in at the axes'</span>
    <span class="s4"># set_xticks and set_yticks by Colorbar.__init__.</span>
    <span class="s1">_api.warn_external(</span><span class="s3">&quot;Use the colorbar set_ticks() method instead.&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">_ColorbarSpine(mspines.Spine):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axes):</span>
        <span class="s1">self._ax = axes</span>
        <span class="s1">super().__init__(axes</span><span class="s2">, </span><span class="s3">'colorbar'</span><span class="s2">, </span><span class="s1">mpath.Path(np.empty((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))))</span>
        <span class="s1">mpatches.Patch.set_transform(self</span><span class="s2">, </span><span class="s1">axes.transAxes)</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># This Spine has no Axis associated with it, and doesn't need to adjust</span>
        <span class="s4"># its location, so we can directly get the window extent from the</span>
        <span class="s4"># super-super-class.</span>
        <span class="s2">return </span><span class="s1">mpatches.Patch.get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=renderer)</span>

    <span class="s2">def </span><span class="s1">set_xy(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s1">self._path = mpath.Path(xy</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self._xy = xy</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">ret = mpatches.Patch.draw(self</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">ret</span>


<span class="s2">class </span><span class="s1">_ColorbarAxesLocator:</span>
    <span class="s0">&quot;&quot;&quot; 
    Shrink the axes if there are triangular or rectangular extends. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">cbar):</span>
        <span class="s1">self._cbar = cbar</span>
        <span class="s1">self._orig_locator = cbar.ax._axes_locator</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if </span><span class="s1">self._orig_locator </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">pos = self._orig_locator(ax</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pos = ax.get_position(original=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._cbar.extend == </span><span class="s3">'neither'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">pos</span>

        <span class="s1">y</span><span class="s2">, </span><span class="s1">extendlen = self._cbar._proportional_y()</span>
        <span class="s2">if not </span><span class="s1">self._cbar._extend_lower():</span>
            <span class="s1">extendlen[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s2">if not </span><span class="s1">self._cbar._extend_upper():</span>
            <span class="s1">extendlen[</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s1">len = sum(extendlen) + </span><span class="s5">1</span>
        <span class="s1">shrink = </span><span class="s5">1 </span><span class="s1">/ len</span>
        <span class="s1">offset = extendlen[</span><span class="s5">0</span><span class="s1">] / len</span>
        <span class="s4"># we need to reset the aspect ratio of the axes to account</span>
        <span class="s4"># of the extends...</span>
        <span class="s2">if </span><span class="s1">hasattr(ax</span><span class="s2">, </span><span class="s3">'_colorbar_info'</span><span class="s1">):</span>
            <span class="s1">aspect = ax._colorbar_info[</span><span class="s3">'aspect'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">aspect = </span><span class="s2">False</span>
        <span class="s4"># now shrink and/or offset to take into account the</span>
        <span class="s4"># extend tri/rectangles.</span>
        <span class="s2">if </span><span class="s1">self._cbar.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">aspect:</span>
                <span class="s1">self._cbar.ax.set_box_aspect(aspect*shrink)</span>
            <span class="s1">pos = pos.shrunk(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">shrink).translated(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">offset * pos.height)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">aspect:</span>
                <span class="s1">self._cbar.ax.set_box_aspect(</span><span class="s5">1</span><span class="s1">/(aspect * shrink))</span>
            <span class="s1">pos = pos.shrunk(shrink</span><span class="s2">, </span><span class="s5">1</span><span class="s1">).translated(offset * pos.width</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">pos</span>

    <span class="s2">def </span><span class="s1">get_subplotspec(self):</span>
        <span class="s4"># make tight_layout happy..</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._cbar.ax.get_subplotspec()</span>
            <span class="s2">or </span><span class="s1">getattr(self._orig_locator</span><span class="s2">, </span><span class="s3">&quot;get_subplotspec&quot;</span><span class="s2">, lambda</span><span class="s1">: </span><span class="s2">None</span><span class="s1">)())</span>


<span class="s1">@_docstring.interpd</span>
<span class="s2">class </span><span class="s1">Colorbar:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Draw a colorbar in an existing axes. 
 
    Typically, colorbars are created using `.Figure.colorbar` or 
    `.pyplot.colorbar` and associated with `.ScalarMappable`\s (such as an 
    `.AxesImage` generated via `~.axes.Axes.imshow`). 
 
    In order to draw a colorbar not associated with other elements in the 
    figure, e.g. when showing a colormap by itself, one can create an empty 
    `.ScalarMappable`, or directly pass *cmap* and *norm* instead of *mappable* 
    to `Colorbar`. 
 
    Useful public methods are :meth:`set_label` and :meth:`add_lines`. 
 
    Attributes 
    ---------- 
    ax : `~matplotlib.axes.Axes` 
        The `~.axes.Axes` instance in which the colorbar is drawn. 
    lines : list 
        A list of `.LineCollection` (empty if no lines were drawn). 
    dividers : `.LineCollection` 
        A LineCollection (empty if *drawedges* is ``False``). 
 
    Parameters 
    ---------- 
    ax : `~matplotlib.axes.Axes` 
        The `~.axes.Axes` instance in which the colorbar is drawn. 
 
    mappable : `.ScalarMappable` 
        The mappable whose colormap and norm will be used. 
 
        To show the under- and over- value colors, the mappable's norm should 
        be specified as :: 
 
            norm = colors.Normalize(clip=False) 
 
        To show the colors versus index instead of on a 0-1 scale, use:: 
 
            norm=colors.NoNorm() 
 
    cmap : `~matplotlib.colors.Colormap`, default: :rc:`image.cmap` 
        The colormap to use.  This parameter is ignored, unless *mappable* is 
        None. 
 
    norm : `~matplotlib.colors.Normalize` 
        The normalization to use.  This parameter is ignored, unless *mappable* 
        is None. 
 
    alpha : float 
        The colorbar transparency between 0 (transparent) and 1 (opaque). 
 
    orientation : None or {'vertical', 'horizontal'} 
        If None, use the value determined by *location*. If both 
        *orientation* and *location* are None then defaults to 'vertical'. 
 
    ticklocation : {'auto', 'left', 'right', 'top', 'bottom'} 
        The location of the colorbar ticks. The *ticklocation* must match 
        *orientation*. For example, a horizontal colorbar can only have ticks 
        at the top or the bottom. If 'auto', the ticks will be the same as 
        *location*, so a colorbar to the left will have ticks to the left. If 
        *location* is None, the ticks will be at the bottom for a horizontal 
        colorbar and at the right for a vertical. 
 
    drawedges : bool 
        Whether to draw lines at color boundaries. 
 
    filled : bool 
 
    %(_colormap_kw_doc)s 
 
    location : None or {'left', 'right', 'top', 'bottom'} 
        Set the *orientation* and *ticklocation* of the colorbar using a 
        single argument. Colorbars on the left and right are vertical, 
        colorbars at the top and bottom are horizontal. The *ticklocation* is 
        the same as *location*, so if *location* is 'top', the ticks are on 
        the top. *orientation* and/or *ticklocation* can be provided as well 
        and overrides the value set by *location*, but there will be an error 
        for incompatible combinations. 
 
        .. versionadded:: 3.7 
    &quot;&quot;&quot;</span>

    <span class="s1">n_rasterize = </span><span class="s5">50  </span><span class="s4"># rasterize solids if number of colors &gt;= n_rasterize</span>

    <span class="s1">@_api.delete_parameter(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s3">&quot;filled&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">mappable=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">cmap=</span><span class="s2">None,</span>
                 <span class="s1">norm=</span><span class="s2">None,</span>
                 <span class="s1">alpha=</span><span class="s2">None,</span>
                 <span class="s1">values=</span><span class="s2">None,</span>
                 <span class="s1">boundaries=</span><span class="s2">None,</span>
                 <span class="s1">orientation=</span><span class="s2">None,</span>
                 <span class="s1">ticklocation=</span><span class="s3">'auto'</span><span class="s2">,</span>
                 <span class="s1">extend=</span><span class="s2">None,</span>
                 <span class="s1">spacing=</span><span class="s3">'uniform'</span><span class="s2">,  </span><span class="s4"># uniform or proportional</span>
                 <span class="s1">ticks=</span><span class="s2">None,</span>
                 <span class="s1">format=</span><span class="s2">None,</span>
                 <span class="s1">drawedges=</span><span class="s2">False,</span>
                 <span class="s1">filled=</span><span class="s2">True,</span>
                 <span class="s1">extendfrac=</span><span class="s2">None,</span>
                 <span class="s1">extendrect=</span><span class="s2">False,</span>
                 <span class="s1">label=</span><span class="s3">''</span><span class="s2">,</span>
                 <span class="s1">location=</span><span class="s2">None,</span>
                 <span class="s1">):</span>

        <span class="s2">if </span><span class="s1">mappable </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">mappable = cm.ScalarMappable(norm=norm</span><span class="s2">, </span><span class="s1">cmap=cmap)</span>

        <span class="s4"># Ensure the given mappable's norm has appropriate vmin and vmax</span>
        <span class="s4"># set even if mappable.draw has not yet been called.</span>
        <span class="s2">if </span><span class="s1">mappable.get_array() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">mappable.autoscale_None()</span>

        <span class="s1">self.mappable = mappable</span>
        <span class="s1">cmap = mappable.cmap</span>
        <span class="s1">norm = mappable.norm</span>

        <span class="s2">if </span><span class="s1">isinstance(mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet):</span>
            <span class="s1">cs = mappable</span>
            <span class="s1">alpha = cs.get_alpha()</span>
            <span class="s1">boundaries = cs._levels</span>
            <span class="s1">values = cs.cvalues</span>
            <span class="s1">extend = cs.extend</span>
            <span class="s1">filled = cs.filled</span>
            <span class="s2">if </span><span class="s1">ticks </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">ticks = ticker.FixedLocator(cs.levels</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(mappable</span><span class="s2">, </span><span class="s1">martist.Artist):</span>
            <span class="s1">alpha = mappable.get_alpha()</span>

        <span class="s1">mappable.colorbar = self</span>
        <span class="s1">mappable.colorbar_cid = mappable.callbacks.connect(</span>
            <span class="s3">'changed'</span><span class="s2">, </span><span class="s1">self.update_normal)</span>

        <span class="s1">location_orientation = _get_orientation_from_location(location)</span>

        <span class="s1">_api.check_in_list(</span>
            <span class="s1">[</span><span class="s2">None, </span><span class="s3">'vertical'</span><span class="s2">, </span><span class="s3">'horizontal'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">orientation=orientation)</span>
        <span class="s1">_api.check_in_list(</span>
            <span class="s1">[</span><span class="s3">'auto'</span><span class="s2">, </span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'right'</span><span class="s2">, </span><span class="s3">'top'</span><span class="s2">, </span><span class="s3">'bottom'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">ticklocation=ticklocation)</span>
        <span class="s1">_api.check_in_list(</span>
            <span class="s1">[</span><span class="s3">'uniform'</span><span class="s2">, </span><span class="s3">'proportional'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">spacing=spacing)</span>

        <span class="s2">if </span><span class="s1">location_orientation </span><span class="s2">is not None and </span><span class="s1">orientation </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">location_orientation != orientation:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;location and orientation are mutually exclusive&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">orientation = orientation </span><span class="s2">or </span><span class="s1">location_orientation </span><span class="s2">or </span><span class="s3">&quot;vertical&quot;</span>

        <span class="s1">self.ax = ax</span>
        <span class="s1">self.ax._axes_locator = _ColorbarAxesLocator(self)</span>

        <span class="s2">if </span><span class="s1">extend </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet)</span>
                    <span class="s2">and </span><span class="s1">getattr(cmap</span><span class="s2">, </span><span class="s3">'colorbar_extend'</span><span class="s2">, False</span><span class="s1">) </span><span class="s2">is not False</span><span class="s1">):</span>
                <span class="s1">extend = cmap.colorbar_extend</span>
            <span class="s2">elif </span><span class="s1">hasattr(norm</span><span class="s2">, </span><span class="s3">'extend'</span><span class="s1">):</span>
                <span class="s1">extend = norm.extend</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">extend = </span><span class="s3">'neither'</span>
        <span class="s1">self.alpha = </span><span class="s2">None</span>
        <span class="s4"># Call set_alpha to handle array-like alphas properly</span>
        <span class="s1">self.set_alpha(alpha)</span>
        <span class="s1">self.cmap = cmap</span>
        <span class="s1">self.norm = norm</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.boundaries = boundaries</span>
        <span class="s1">self.extend = extend</span>
        <span class="s1">self._inside = _api.check_getitem(</span>
            <span class="s1">{</span><span class="s3">'neither'</span><span class="s1">: slice(</span><span class="s5">0</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'both'</span><span class="s1">: slice(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s3">'min'</span><span class="s1">: slice(</span><span class="s5">1</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'max'</span><span class="s1">: slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)}</span><span class="s2">,</span>
            <span class="s1">extend=extend)</span>
        <span class="s1">self.spacing = spacing</span>
        <span class="s1">self.orientation = orientation</span>
        <span class="s1">self.drawedges = drawedges</span>
        <span class="s1">self._filled = filled</span>
        <span class="s1">self.extendfrac = extendfrac</span>
        <span class="s1">self.extendrect = extendrect</span>
        <span class="s1">self._extend_patches = []</span>
        <span class="s1">self.solids = </span><span class="s2">None</span>
        <span class="s1">self.solids_patches = []</span>
        <span class="s1">self.lines = []</span>

        <span class="s2">for </span><span class="s1">spine </span><span class="s2">in </span><span class="s1">self.ax.spines.values():</span>
            <span class="s1">spine.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.outline = self.ax.spines[</span><span class="s3">'outline'</span><span class="s1">] = _ColorbarSpine(self.ax)</span>

        <span class="s1">self.dividers = collections.LineCollection(</span>
            <span class="s1">[]</span><span class="s2">,</span>
            <span class="s1">colors=[mpl.rcParams[</span><span class="s3">'axes.edgecolor'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">linewidths=[</span><span class="s5">0.5 </span><span class="s1">* mpl.rcParams[</span><span class="s3">'axes.linewidth'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">clip_on=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.ax.add_collection(self.dividers)</span>

        <span class="s1">self._locator = </span><span class="s2">None</span>
        <span class="s1">self._minorlocator = </span><span class="s2">None</span>
        <span class="s1">self._formatter = </span><span class="s2">None</span>
        <span class="s1">self._minorformatter = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">ticklocation == </span><span class="s3">'auto'</span><span class="s1">:</span>
            <span class="s1">ticklocation = _get_ticklocation_from_orientation(</span>
                <span class="s1">orientation) </span><span class="s2">if </span><span class="s1">location </span><span class="s2">is None else </span><span class="s1">location</span>
        <span class="s1">self.ticklocation = ticklocation</span>

        <span class="s1">self.set_label(label)</span>
        <span class="s1">self._reset_locator_formatter_scale()</span>

        <span class="s2">if </span><span class="s1">np.iterable(ticks):</span>
            <span class="s1">self._locator = ticker.FixedLocator(ticks</span><span class="s2">, </span><span class="s1">nbins=len(ticks))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._locator = ticks</span>

        <span class="s2">if </span><span class="s1">isinstance(format</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s4"># Check format between FormatStrFormatter and StrMethodFormatter</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self._formatter = ticker.FormatStrFormatter(format)</span>
                <span class="s1">_ = self._formatter(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">self._formatter = ticker.StrMethodFormatter(format)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._formatter = format  </span><span class="s4"># Assume it is a Formatter or None</span>
        <span class="s1">self._draw_all()</span>

        <span class="s2">if </span><span class="s1">isinstance(mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet) </span><span class="s2">and not </span><span class="s1">mappable.filled:</span>
            <span class="s1">self.add_lines(mappable)</span>

        <span class="s4"># Link the Axes and Colorbar for interactive use</span>
        <span class="s1">self.ax._colorbar = self</span>
        <span class="s4"># Don't navigate on any of these types of mappables</span>
        <span class="s2">if </span><span class="s1">(isinstance(self.norm</span><span class="s2">, </span><span class="s1">(colors.BoundaryNorm</span><span class="s2">, </span><span class="s1">colors.NoNorm)) </span><span class="s2">or</span>
                <span class="s1">isinstance(self.mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet)):</span>
            <span class="s1">self.ax.set_navigate(</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s4"># These are the functions that set up interactivity on this colorbar</span>
        <span class="s1">self._interactive_funcs = [</span><span class="s3">&quot;_get_view&quot;</span><span class="s2">, </span><span class="s3">&quot;_set_view&quot;</span><span class="s2">,</span>
                                   <span class="s3">&quot;_set_view_from_bbox&quot;</span><span class="s2">, </span><span class="s3">&quot;drag_pan&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._interactive_funcs:</span>
            <span class="s1">setattr(self.ax</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">x))</span>
        <span class="s4"># Set the cla function to the cbar's method to override it</span>
        <span class="s1">self.ax.cla = self._cbar_cla</span>
        <span class="s4"># Callbacks for the extend calculations to handle inverting the axis</span>
        <span class="s1">self._extend_cid1 = self.ax.callbacks.connect(</span>
            <span class="s3">&quot;xlim_changed&quot;</span><span class="s2">, </span><span class="s1">self._do_extends)</span>
        <span class="s1">self._extend_cid2 = self.ax.callbacks.connect(</span>
            <span class="s3">&quot;ylim_changed&quot;</span><span class="s2">, </span><span class="s1">self._do_extends)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">locator(self):</span>
        <span class="s0">&quot;&quot;&quot;Major tick `.Locator` for the colorbar.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._long_axis().get_major_locator()</span>

    <span class="s1">@locator.setter</span>
    <span class="s2">def </span><span class="s1">locator(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s1">self._long_axis().set_major_locator(loc)</span>
        <span class="s1">self._locator = loc</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">minorlocator(self):</span>
        <span class="s0">&quot;&quot;&quot;Minor tick `.Locator` for the colorbar.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._long_axis().get_minor_locator()</span>

    <span class="s1">@minorlocator.setter</span>
    <span class="s2">def </span><span class="s1">minorlocator(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s1">self._long_axis().set_minor_locator(loc)</span>
        <span class="s1">self._minorlocator = loc</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">formatter(self):</span>
        <span class="s0">&quot;&quot;&quot;Major tick label `.Formatter` for the colorbar.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._long_axis().get_major_formatter()</span>

    <span class="s1">@formatter.setter</span>
    <span class="s2">def </span><span class="s1">formatter(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s1">self._long_axis().set_major_formatter(fmt)</span>
        <span class="s1">self._formatter = fmt</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">minorformatter(self):</span>
        <span class="s0">&quot;&quot;&quot;Minor tick `.Formatter` for the colorbar.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._long_axis().get_minor_formatter()</span>

    <span class="s1">@minorformatter.setter</span>
    <span class="s2">def </span><span class="s1">minorformatter(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s1">self._long_axis().set_minor_formatter(fmt)</span>
        <span class="s1">self._minorformatter = fmt</span>

    <span class="s2">def </span><span class="s1">_cbar_cla(self):</span>
        <span class="s0">&quot;&quot;&quot;Function to clear the interactive colorbar state.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self._interactive_funcs:</span>
            <span class="s1">delattr(self.ax</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s4"># We now restore the old cla() back and can call it directly</span>
        <span class="s2">del </span><span class="s1">self.ax.cla</span>
        <span class="s1">self.ax.cla()</span>

    <span class="s1">filled = _api.deprecate_privatize_attribute(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">update_normal(self</span><span class="s2">, </span><span class="s1">mappable):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update solid patches, lines, etc. 
 
        This is meant to be called when the norm of the image or contour plot 
        to which this colorbar belongs changes. 
 
        If the norm on the mappable is different than before, this resets the 
        locator and formatter for the axis, so if these have been customized, 
        they will need to be customized again.  However, if the norm only 
        changes values of *vmin*, *vmax* or *cmap* then the old formatter 
        and locator will be preserved. 
        &quot;&quot;&quot;</span>
        <span class="s1">_log.debug(</span><span class="s3">'colorbar update normal %r %r'</span><span class="s2">, </span><span class="s1">mappable.norm</span><span class="s2">, </span><span class="s1">self.norm)</span>
        <span class="s1">self.mappable = mappable</span>
        <span class="s1">self.set_alpha(mappable.get_alpha())</span>
        <span class="s1">self.cmap = mappable.cmap</span>
        <span class="s2">if </span><span class="s1">mappable.norm != self.norm:</span>
            <span class="s1">self.norm = mappable.norm</span>
            <span class="s1">self._reset_locator_formatter_scale()</span>

        <span class="s1">self._draw_all()</span>
        <span class="s2">if </span><span class="s1">isinstance(self.mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet):</span>
            <span class="s1">CS = self.mappable</span>
            <span class="s2">if not </span><span class="s1">CS.filled:</span>
                <span class="s1">self.add_lines(CS)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;fig.draw_without_rendering()&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">draw_all(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate any free parameters based on the current cmap and norm, 
        and do all the drawing. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._draw_all()</span>

    <span class="s2">def </span><span class="s1">_draw_all(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate any free parameters based on the current cmap and norm, 
        and do all the drawing. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'ytick.minor.visible'</span><span class="s1">]:</span>
                <span class="s1">self.minorticks_on()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'xtick.minor.visible'</span><span class="s1">]:</span>
                <span class="s1">self.minorticks_on()</span>
        <span class="s1">self._long_axis().set(label_position=self.ticklocation</span><span class="s2">,</span>
                              <span class="s1">ticks_position=self.ticklocation)</span>
        <span class="s1">self._short_axis().set_ticks([])</span>
        <span class="s1">self._short_axis().set_ticks([]</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s4"># Set self._boundaries and self._values, including extensions.</span>
        <span class="s4"># self._boundaries are the edges of each square of color, and</span>
        <span class="s4"># self._values are the value to map into the norm to get the</span>
        <span class="s4"># color:</span>
        <span class="s1">self._process_values()</span>
        <span class="s4"># Set self.vmin and self.vmax to first and last boundary, excluding</span>
        <span class="s4"># extensions:</span>
        <span class="s1">self.vmin</span><span class="s2">, </span><span class="s1">self.vmax = self._boundaries[self._inside][[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s4"># Compute the X/Y mesh.</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = self._mesh()</span>
        <span class="s4"># draw the extend triangles, and shrink the inner axes to accommodate.</span>
        <span class="s4"># also adds the outline path to self.outline spine:</span>
        <span class="s1">self._do_extends()</span>
        <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = self.vmin</span><span class="s2">, </span><span class="s1">self.vmax</span>
        <span class="s2">if </span><span class="s1">self._long_axis().get_inverted():</span>
            <span class="s4"># If the axis is inverted, we need to swap the vmin/vmax</span>
            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = upper</span><span class="s2">, </span><span class="s1">lower</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s1">self.ax.set_xlim(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.ax.set_ylim(lower</span><span class="s2">, </span><span class="s1">upper)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ax.set_ylim(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.ax.set_xlim(lower</span><span class="s2">, </span><span class="s1">upper)</span>

        <span class="s4"># set up the tick locators and formatters.  A bit complicated because</span>
        <span class="s4"># boundary norms + uniform spacing requires a manual locator.</span>
        <span class="s1">self.update_ticks()</span>

        <span class="s2">if </span><span class="s1">self._filled:</span>
            <span class="s1">ind = np.arange(len(self._values))</span>
            <span class="s2">if </span><span class="s1">self._extend_lower():</span>
                <span class="s1">ind = ind[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s2">if </span><span class="s1">self._extend_upper():</span>
                <span class="s1">ind = ind[:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self._add_solids(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">self._values[ind</span><span class="s2">, </span><span class="s1">np.newaxis])</span>

    <span class="s2">def </span><span class="s1">_add_solids(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">C):</span>
        <span class="s0">&quot;&quot;&quot;Draw the colors; optionally add separators.&quot;&quot;&quot;</span>
        <span class="s4"># Cleanup previously set artists.</span>
        <span class="s2">if </span><span class="s1">self.solids </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.solids.remove()</span>
        <span class="s2">for </span><span class="s1">solid </span><span class="s2">in </span><span class="s1">self.solids_patches:</span>
            <span class="s1">solid.remove()</span>
        <span class="s4"># Add new artist(s), based on mappable type.  Use individual patches if</span>
        <span class="s4"># hatching is needed, pcolormesh otherwise.</span>
        <span class="s1">mappable = getattr(self</span><span class="s2">, </span><span class="s3">'mappable'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(isinstance(mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet)</span>
                <span class="s2">and </span><span class="s1">any(hatch </span><span class="s2">is not None for </span><span class="s1">hatch </span><span class="s2">in </span><span class="s1">mappable.hatches)):</span>
            <span class="s1">self._add_solids_patches(X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">mappable)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.solids = self.ax.pcolormesh(</span>
                <span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">cmap=self.cmap</span><span class="s2">, </span><span class="s1">norm=self.norm</span><span class="s2">, </span><span class="s1">alpha=self.alpha</span><span class="s2">,</span>
                <span class="s1">edgecolors=</span><span class="s3">'none'</span><span class="s2">, </span><span class="s1">shading=</span><span class="s3">'flat'</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">self.drawedges:</span>
                <span class="s2">if </span><span class="s1">len(self._y) &gt;= self.n_rasterize:</span>
                    <span class="s1">self.solids.set_rasterized(</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self._update_dividers()</span>

    <span class="s2">def </span><span class="s1">_update_dividers(self):</span>
        <span class="s2">if not </span><span class="s1">self.drawedges:</span>
            <span class="s1">self.dividers.set_segments([])</span>
            <span class="s2">return</span>
        <span class="s4"># Place all *internal* dividers.</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s1">lims = self.ax.get_ylim()</span>
            <span class="s1">bounds = (lims[</span><span class="s5">0</span><span class="s1">] &lt; self._y) &amp; (self._y &lt; lims[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lims = self.ax.get_xlim()</span>
            <span class="s1">bounds = (lims[</span><span class="s5">0</span><span class="s1">] &lt; self._y) &amp; (self._y &lt; lims[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">y = self._y[bounds]</span>
        <span class="s4"># And then add outer dividers if extensions are on.</span>
        <span class="s2">if </span><span class="s1">self._extend_lower():</span>
            <span class="s1">y = np.insert(y</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">lims[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">self._extend_upper():</span>
            <span class="s1">y = np.append(y</span><span class="s2">, </span><span class="s1">lims[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = np.meshgrid([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s1">segments = np.dstack([X</span><span class="s2">, </span><span class="s1">Y])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">segments = np.dstack([Y</span><span class="s2">, </span><span class="s1">X])</span>
        <span class="s1">self.dividers.set_segments(segments)</span>

    <span class="s2">def </span><span class="s1">_add_solids_patches(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">Y</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">mappable):</span>
        <span class="s1">hatches = mappable.hatches * (len(C) + </span><span class="s5">1</span><span class="s1">)  </span><span class="s4"># Have enough hatches.</span>
        <span class="s2">if </span><span class="s1">self._extend_lower():</span>
            <span class="s4"># remove first hatch that goes into the extend patch</span>
            <span class="s1">hatches = hatches[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s1">patches = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(X) - </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">xy = np.array([[X[i</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Y[i</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s2">,</span>
                           <span class="s1">[X[i</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Y[i</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">,</span>
                           <span class="s1">[X[i + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Y[i + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">,</span>
                           <span class="s1">[X[i + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Y[i + </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]])</span>
            <span class="s1">patch = mpatches.PathPatch(mpath.Path(xy)</span><span class="s2">,</span>
                                       <span class="s1">facecolor=self.cmap(self.norm(C[i][</span><span class="s5">0</span><span class="s1">]))</span><span class="s2">,</span>
                                       <span class="s1">hatch=hatches[i]</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s5">0</span><span class="s2">,</span>
                                       <span class="s1">antialiased=</span><span class="s2">False, </span><span class="s1">alpha=self.alpha)</span>
            <span class="s1">self.ax.add_patch(patch)</span>
            <span class="s1">patches.append(patch)</span>
        <span class="s1">self.solids_patches = patches</span>

    <span class="s2">def </span><span class="s1">_do_extends(self</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the extend tri/rectangles on the outside of the axes. 
 
        ax is unused, but required due to the callbacks on xlim/ylim changed 
        &quot;&quot;&quot;</span>
        <span class="s4"># Clean up any previous extend patches</span>
        <span class="s2">for </span><span class="s1">patch </span><span class="s2">in </span><span class="s1">self._extend_patches:</span>
            <span class="s1">patch.remove()</span>
        <span class="s1">self._extend_patches = []</span>
        <span class="s4"># extend lengths are fraction of the *inner* part of colorbar,</span>
        <span class="s4"># not the total colorbar:</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">extendlen = self._proportional_y()</span>
        <span class="s1">bot = </span><span class="s5">0 </span><span class="s1">- (extendlen[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self._extend_lower() </span><span class="s2">else </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">top = </span><span class="s5">1 </span><span class="s1">+ (extendlen[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">if </span><span class="s1">self._extend_upper() </span><span class="s2">else </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s4"># xyout is the outline of the colorbar including the extend patches:</span>
        <span class="s2">if not </span><span class="s1">self.extendrect:</span>
            <span class="s4"># triangle:</span>
            <span class="s1">xyout = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># rectangle:</span>
            <span class="s1">xyout = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>

        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'horizontal'</span><span class="s1">:</span>
            <span class="s1">xyout = xyout[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s4"># xyout is the path for the spine:</span>
        <span class="s1">self.outline.set_xy(xyout)</span>
        <span class="s2">if not </span><span class="s1">self._filled:</span>
            <span class="s2">return</span>

        <span class="s4"># Make extend triangles or rectangles filled patches.  These are</span>
        <span class="s4"># defined in the outer parent axes' coordinates:</span>
        <span class="s1">mappable = getattr(self</span><span class="s2">, </span><span class="s3">'mappable'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(isinstance(mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet)</span>
                <span class="s2">and </span><span class="s1">any(hatch </span><span class="s2">is not None for </span><span class="s1">hatch </span><span class="s2">in </span><span class="s1">mappable.hatches)):</span>
            <span class="s1">hatches = mappable.hatches * (len(self._y) + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">hatches = [</span><span class="s2">None</span><span class="s1">] * (len(self._y) + </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self._extend_lower():</span>
            <span class="s2">if not </span><span class="s1">self.extendrect:</span>
                <span class="s4"># triangle</span>
                <span class="s1">xy = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># rectangle</span>
                <span class="s1">xy = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.</span><span class="s2">, </span><span class="s1">bot]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
            <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'horizontal'</span><span class="s1">:</span>
                <span class="s1">xy = xy[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s4"># add the patch</span>
            <span class="s1">val = -</span><span class="s5">1 </span><span class="s2">if </span><span class="s1">self._long_axis().get_inverted() </span><span class="s2">else </span><span class="s5">0</span>
            <span class="s1">color = self.cmap(self.norm(self._values[val]))</span>
            <span class="s1">patch = mpatches.PathPatch(</span>
                <span class="s1">mpath.Path(xy)</span><span class="s2">, </span><span class="s1">facecolor=color</span><span class="s2">, </span><span class="s1">alpha=self.alpha</span><span class="s2">,</span>
                <span class="s1">linewidth=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">antialiased=</span><span class="s2">False,</span>
                <span class="s1">transform=self.ax.transAxes</span><span class="s2">,</span>
                <span class="s1">hatch=hatches[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">clip_on=</span><span class="s2">False,</span>
                <span class="s4"># Place it right behind the standard patches, which is</span>
                <span class="s4"># needed if we updated the extends</span>
                <span class="s1">zorder=np.nextafter(self.ax.patch.zorder</span><span class="s2">, </span><span class="s1">-np.inf))</span>
            <span class="s1">self.ax.add_patch(patch)</span>
            <span class="s1">self._extend_patches.append(patch)</span>
            <span class="s4"># remove first hatch that goes into the extend patch</span>
            <span class="s1">hatches = hatches[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">self._extend_upper():</span>
            <span class="s2">if not </span><span class="s1">self.extendrect:</span>
                <span class="s4"># triangle</span>
                <span class="s1">xy = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># rectangle</span>
                <span class="s1">xy = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">top]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'horizontal'</span><span class="s1">:</span>
                <span class="s1">xy = xy[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s4"># add the patch</span>
            <span class="s1">val = </span><span class="s5">0 </span><span class="s2">if </span><span class="s1">self._long_axis().get_inverted() </span><span class="s2">else </span><span class="s1">-</span><span class="s5">1</span>
            <span class="s1">color = self.cmap(self.norm(self._values[val]))</span>
            <span class="s1">hatch_idx = len(self._y) - </span><span class="s5">1</span>
            <span class="s1">patch = mpatches.PathPatch(</span>
                <span class="s1">mpath.Path(xy)</span><span class="s2">, </span><span class="s1">facecolor=color</span><span class="s2">, </span><span class="s1">alpha=self.alpha</span><span class="s2">,</span>
                <span class="s1">linewidth=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">antialiased=</span><span class="s2">False,</span>
                <span class="s1">transform=self.ax.transAxes</span><span class="s2">, </span><span class="s1">hatch=hatches[hatch_idx]</span><span class="s2">,</span>
                <span class="s1">clip_on=</span><span class="s2">False,</span>
                <span class="s4"># Place it right behind the standard patches, which is</span>
                <span class="s4"># needed if we updated the extends</span>
                <span class="s1">zorder=np.nextafter(self.ax.patch.zorder</span><span class="s2">, </span><span class="s1">-np.inf))</span>
            <span class="s1">self.ax.add_patch(patch)</span>
            <span class="s1">self._extend_patches.append(patch)</span>

        <span class="s1">self._update_dividers()</span>

    <span class="s2">def </span><span class="s1">add_lines(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw lines on the colorbar. 
 
        The lines are appended to the list :attr:`lines`. 
 
        Parameters 
        ---------- 
        levels : array-like 
            The positions of the lines. 
        colors : color or list of colors 
            Either a single color applying to all lines or one color value for 
            each line. 
        linewidths : float or array-like 
            Either a single linewidth applying to all lines or one linewidth 
            for each line. 
        erase : bool, default: True 
            Whether to remove any previously added lines. 
 
        Notes 
        ----- 
        Alternatively, this method can also be called with the signature 
        ``colorbar.add_lines(contour_set, erase=True)``, in which case 
        *levels*, *colors*, and *linewidths* are taken from *contour_set*. 
        &quot;&quot;&quot;</span>
        <span class="s1">params = _api.select_matching_signature(</span>
            <span class="s1">[</span><span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">CS</span><span class="s2">, </span><span class="s1">erase=</span><span class="s2">True</span><span class="s1">: locals()</span><span class="s2">,</span>
             <span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">erase=</span><span class="s2">True</span><span class="s1">: locals()]</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s3">&quot;CS&quot; </span><span class="s2">in </span><span class="s1">params:</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">CS</span><span class="s2">, </span><span class="s1">erase = params.values()</span>
            <span class="s2">if not </span><span class="s1">isinstance(CS</span><span class="s2">, </span><span class="s1">contour.ContourSet) </span><span class="s2">or </span><span class="s1">CS.filled:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;If a single artist is passed to add_lines, &quot;</span>
                                 <span class="s3">&quot;it must be a ContourSet of lines&quot;</span><span class="s1">)</span>
            <span class="s4"># TODO: Make colorbar lines auto-follow changes in contour lines.</span>
            <span class="s2">return </span><span class="s1">self.add_lines(</span>
                <span class="s1">CS.levels</span><span class="s2">,</span>
                <span class="s1">[c[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">CS.tcolors]</span><span class="s2">,</span>
                <span class="s1">[t[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">CS.tlinewidths]</span><span class="s2">,</span>
                <span class="s1">erase=erase)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">erase = params.values()</span>

        <span class="s1">y = self._locate(levels)</span>
        <span class="s1">rtol = (self._y[-</span><span class="s5">1</span><span class="s1">] - self._y[</span><span class="s5">0</span><span class="s1">]) * </span><span class="s5">1e-10</span>
        <span class="s1">igood = (y &lt; self._y[-</span><span class="s5">1</span><span class="s1">] + rtol) &amp; (y &gt; self._y[</span><span class="s5">0</span><span class="s1">] - rtol)</span>
        <span class="s1">y = y[igood]</span>
        <span class="s2">if </span><span class="s1">np.iterable(colors):</span>
            <span class="s1">colors = np.asarray(colors)[igood]</span>
        <span class="s2">if </span><span class="s1">np.iterable(linewidths):</span>
            <span class="s1">linewidths = np.asarray(linewidths)[igood]</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = np.meshgrid([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s1">xy = np.stack([X</span><span class="s2">, </span><span class="s1">Y]</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xy = np.stack([Y</span><span class="s2">, </span><span class="s1">X]</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">col = collections.LineCollection(xy</span><span class="s2">, </span><span class="s1">linewidths=linewidths</span><span class="s2">,</span>
                                         <span class="s1">colors=colors)</span>

        <span class="s2">if </span><span class="s1">erase </span><span class="s2">and </span><span class="s1">self.lines:</span>
            <span class="s2">for </span><span class="s1">lc </span><span class="s2">in </span><span class="s1">self.lines:</span>
                <span class="s1">lc.remove()</span>
            <span class="s1">self.lines = []</span>
        <span class="s1">self.lines.append(col)</span>

        <span class="s4"># make a clip path that is just a linewidth bigger than the axes...</span>
        <span class="s1">fac = np.max(linewidths) / </span><span class="s5">72</span>
        <span class="s1">xy = np.array([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]])</span>
        <span class="s1">inches = self.ax.get_figure().dpi_scale_trans</span>
        <span class="s4"># do in inches:</span>
        <span class="s1">xy = inches.inverted().transform(self.ax.transAxes.transform(xy))</span>
        <span class="s1">xy[[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] -= fac</span>
        <span class="s1">xy[[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] += fac</span>
        <span class="s4"># back to axes units...</span>
        <span class="s1">xy = self.ax.transAxes.inverted().transform(inches.transform(xy))</span>
        <span class="s1">col.set_clip_path(mpath.Path(xy</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">self.ax.transAxes)</span>
        <span class="s1">self.ax.add_collection(col)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">update_ticks(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set up the ticks and ticklabels. This should not be needed by users. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Get the locator and formatter; defaults to self._locator if not None.</span>
        <span class="s1">self._get_ticker_locator_formatter()</span>
        <span class="s1">self._long_axis().set_major_locator(self._locator)</span>
        <span class="s1">self._long_axis().set_minor_locator(self._minorlocator)</span>
        <span class="s1">self._long_axis().set_major_formatter(self._formatter)</span>

    <span class="s2">def </span><span class="s1">_get_ticker_locator_formatter(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ``locator`` and ``formatter`` of the colorbar. 
 
        If they have not been defined (i.e. are *None*), the formatter and 
        locator are retrieved from the axis, or from the value of the 
        boundaries for a boundary norm. 
 
        Called by update_ticks... 
        &quot;&quot;&quot;</span>
        <span class="s1">locator = self._locator</span>
        <span class="s1">formatter = self._formatter</span>
        <span class="s1">minorlocator = self._minorlocator</span>
        <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm):</span>
            <span class="s1">b = self.norm.boundaries</span>
            <span class="s2">if </span><span class="s1">locator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">locator = ticker.FixedLocator(b</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s5">10</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">minorlocator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">minorlocator = ticker.FixedLocator(b)</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.NoNorm):</span>
            <span class="s2">if </span><span class="s1">locator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s4"># put ticks on integers between the boundaries of NoNorm</span>
                <span class="s1">nv = len(self._values)</span>
                <span class="s1">base = </span><span class="s5">1 </span><span class="s1">+ int(nv / </span><span class="s5">10</span><span class="s1">)</span>
                <span class="s1">locator = ticker.IndexLocator(base=base</span><span class="s2">, </span><span class="s1">offset=</span><span class="s5">.5</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">self.boundaries </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">b = self._boundaries[self._inside]</span>
            <span class="s2">if </span><span class="s1">locator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">locator = ticker.FixedLocator(b</span><span class="s2">, </span><span class="s1">nbins=</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># most cases:</span>
            <span class="s2">if </span><span class="s1">locator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s4"># we haven't set the locator explicitly, so use the default</span>
                <span class="s4"># for this axis:</span>
                <span class="s1">locator = self._long_axis().get_major_locator()</span>
            <span class="s2">if </span><span class="s1">minorlocator </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">minorlocator = self._long_axis().get_minor_locator()</span>

        <span class="s2">if </span><span class="s1">minorlocator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">minorlocator = ticker.NullLocator()</span>

        <span class="s2">if </span><span class="s1">formatter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">formatter = self._long_axis().get_major_formatter()</span>

        <span class="s1">self._locator = locator</span>
        <span class="s1">self._formatter = formatter</span>
        <span class="s1">self._minorlocator = minorlocator</span>
        <span class="s1">_log.debug(</span><span class="s3">'locator: %r'</span><span class="s2">, </span><span class="s1">locator)</span>

    <span class="s2">def </span><span class="s1">set_ticks(self</span><span class="s2">, </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">labels=</span><span class="s2">None, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set tick locations. 
 
        Parameters 
        ---------- 
        ticks : list of floats 
            List of tick locations. 
        labels : list of str, optional 
            List of tick labels. If not set, the labels show the data value. 
        minor : bool, default: False 
            If ``False``, set the major ticks; if ``True``, the minor ticks. 
        **kwargs 
            `.Text` properties for the labels. These take effect only if you 
            pass *labels*. In other cases, please use `~.Axes.tick_params`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">np.iterable(ticks):</span>
            <span class="s1">self._long_axis().set_ticks(ticks</span><span class="s2">, </span><span class="s1">labels=labels</span><span class="s2">, </span><span class="s1">minor=minor</span><span class="s2">,</span>
                                        <span class="s1">**kwargs)</span>
            <span class="s1">self._locator = self._long_axis().get_major_locator()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._locator = ticks</span>
            <span class="s1">self._long_axis().set_major_locator(self._locator)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_ticks(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ticks as a list of locations. 
 
        Parameters 
        ---------- 
        minor : boolean, default: False 
            if True return the minor ticks. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s2">return </span><span class="s1">self._long_axis().get_minorticklocs()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._long_axis().get_majorticklocs()</span>

    <span class="s2">def </span><span class="s1">set_ticklabels(self</span><span class="s2">, </span><span class="s1">ticklabels</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        [*Discouraged*] Set tick labels. 
 
        .. admonition:: Discouraged 
 
            The use of this method is discouraged, because of the dependency 
            on tick positions. In most cases, you'll want to use 
            ``set_ticks(positions, labels=labels)`` instead. 
 
            If you are using this method, you should always fix the tick 
            positions before, e.g. by using `.Colorbar.set_ticks` or by 
            explicitly setting a `~.ticker.FixedLocator` on the long axis 
            of the colorbar. Otherwise, ticks are free to move and the 
            labels may end up in unexpected positions. 
 
        Parameters 
        ---------- 
        ticklabels : sequence of str or of `.Text` 
            Texts for labeling each tick location in the sequence set by 
            `.Colorbar.set_ticks`; the number of labels must match the number 
            of locations. 
 
        update_ticks : bool, default: True 
            This keyword argument is ignored and will be removed. 
            Deprecated 
 
         minor : bool 
            If True, set minor ticks instead of major ticks. 
 
        **kwargs 
            `.Text` properties for the labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._long_axis().set_ticklabels(ticklabels</span><span class="s2">, </span><span class="s1">minor=minor</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">minorticks_on(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Turn on colorbar minor ticks. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ax.minorticks_on()</span>
        <span class="s1">self._short_axis().set_minor_locator(ticker.NullLocator())</span>

    <span class="s2">def </span><span class="s1">minorticks_off(self):</span>
        <span class="s0">&quot;&quot;&quot;Turn the minor ticks of the colorbar off.&quot;&quot;&quot;</span>
        <span class="s1">self._minorlocator = ticker.NullLocator()</span>
        <span class="s1">self._long_axis().set_minor_locator(self._minorlocator)</span>

    <span class="s2">def </span><span class="s1">set_label(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">loc=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a label to the long axis of the colorbar. 
 
        Parameters 
        ---------- 
        label : str 
            The label text. 
        loc : str, optional 
            The location of the label. 
 
            - For horizontal orientation one of {'left', 'center', 'right'} 
            - For vertical orientation one of {'bottom', 'center', 'top'} 
 
            Defaults to :rc:`xaxis.labellocation` or :rc:`yaxis.labellocation` 
            depending on the orientation. 
        **kwargs 
            Keyword arguments are passed to `~.Axes.set_xlabel` / 
            `~.Axes.set_ylabel`. 
            Supported keywords are *labelpad* and `.Text` properties. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">&quot;vertical&quot;</span><span class="s1">:</span>
            <span class="s1">self.ax.set_ylabel(label</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.ax.set_xlabel(label</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_alpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the transparency between 0 (transparent) and 1 (opaque). 
 
        If an array is provided, *alpha* will be set to None to use the 
        transparency values associated with the colormap. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.alpha = </span><span class="s2">None if </span><span class="s1">isinstance(alpha</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">else </span><span class="s1">alpha</span>

    <span class="s2">def </span><span class="s1">_set_scale(self</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the colorbar long axis scale. 
 
        Parameters 
        ---------- 
        value : {&quot;linear&quot;, &quot;log&quot;, &quot;symlog&quot;, &quot;logit&quot;, ...} or `.ScaleBase` 
            The axis scale type to apply. 
 
        **kwargs 
            Different keyword arguments are accepted, depending on the scale. 
            See the respective class keyword arguments: 
 
            - `matplotlib.scale.LinearScale` 
            - `matplotlib.scale.LogScale` 
            - `matplotlib.scale.SymmetricalLogScale` 
            - `matplotlib.scale.LogitScale` 
            - `matplotlib.scale.FuncScale` 
 
        Notes 
        ----- 
        By default, Matplotlib supports the above-mentioned scales. 
        Additionally, custom scales may be registered using 
        `matplotlib.scale.register_scale`. These scales can then also 
        be used here. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._long_axis()._set_axes_scale(scale</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">remove(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove this colorbar from the figure. 
 
        If the colorbar was created with ``use_gridspec=True`` the previous 
        gridspec is restored. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(self.ax</span><span class="s2">, </span><span class="s3">'_colorbar_info'</span><span class="s1">):</span>
            <span class="s1">parents = self.ax._colorbar_info[</span><span class="s3">'parents'</span><span class="s1">]</span>
            <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">parents:</span>
                <span class="s2">if </span><span class="s1">self.ax </span><span class="s2">in </span><span class="s1">a._colorbars:</span>
                    <span class="s1">a._colorbars.remove(self.ax)</span>

        <span class="s1">self.ax.remove()</span>

        <span class="s1">self.mappable.callbacks.disconnect(self.mappable.colorbar_cid)</span>
        <span class="s1">self.mappable.colorbar = </span><span class="s2">None</span>
        <span class="s1">self.mappable.colorbar_cid = </span><span class="s2">None</span>
        <span class="s4"># Remove the extension callbacks</span>
        <span class="s1">self.ax.callbacks.disconnect(self._extend_cid1)</span>
        <span class="s1">self.ax.callbacks.disconnect(self._extend_cid2)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ax = self.mappable.axes</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">return</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">gs = ax.get_subplotspec().get_gridspec()</span>
            <span class="s1">subplotspec = gs.get_topmost_subplotspec()</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s4"># use_gridspec was False</span>
            <span class="s1">pos = ax.get_position(original=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">ax._set_position(pos)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># use_gridspec was True</span>
            <span class="s1">ax.set_subplotspec(subplotspec)</span>

    <span class="s2">def </span><span class="s1">_process_values(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set `_boundaries` and `_values` based on the self.boundaries and 
        self.values if not None, or based on the size of the colormap and 
        the vmin/vmax of the norm. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.values </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># set self._boundaries from the values...</span>
            <span class="s1">self._values = np.array(self.values)</span>
            <span class="s2">if </span><span class="s1">self.boundaries </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s4"># bracket values by 1/2 dv:</span>
                <span class="s1">b = np.zeros(len(self.values) + </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">b[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.5 </span><span class="s1">* (self._values[:-</span><span class="s5">1</span><span class="s1">] + self._values[</span><span class="s5">1</span><span class="s1">:])</span>
                <span class="s1">b[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">2.0 </span><span class="s1">* b[</span><span class="s5">1</span><span class="s1">] - b[</span><span class="s5">2</span><span class="s1">]</span>
                <span class="s1">b[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">2.0 </span><span class="s1">* b[-</span><span class="s5">2</span><span class="s1">] - b[-</span><span class="s5">3</span><span class="s1">]</span>
                <span class="s1">self._boundaries = b</span>
                <span class="s2">return</span>
            <span class="s1">self._boundaries = np.array(self.boundaries)</span>
            <span class="s2">return</span>

        <span class="s4"># otherwise values are set from the boundaries</span>
        <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm):</span>
            <span class="s1">b = self.norm.boundaries</span>
        <span class="s2">elif </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.NoNorm):</span>
            <span class="s4"># NoNorm has N blocks, so N+1 boundaries, centered on integers:</span>
            <span class="s1">b = np.arange(self.cmap.N + </span><span class="s5">1</span><span class="s1">) - </span><span class="s5">.5</span>
        <span class="s2">elif </span><span class="s1">self.boundaries </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">b = self.boundaries</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># otherwise make the boundaries from the size of the cmap:</span>
            <span class="s1">N = self.cmap.N + </span><span class="s5">1</span>
            <span class="s1">b</span><span class="s2">, </span><span class="s1">_ = self._uniform_y(N)</span>
        <span class="s4"># add extra boundaries if needed:</span>
        <span class="s2">if </span><span class="s1">self._extend_lower():</span>
            <span class="s1">b = np.hstack((b[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">b))</span>
        <span class="s2">if </span><span class="s1">self._extend_upper():</span>
            <span class="s1">b = np.hstack((b</span><span class="s2">, </span><span class="s1">b[-</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s4"># transform from 0-1 to vmin-vmax:</span>
        <span class="s2">if not </span><span class="s1">self.norm.scaled():</span>
            <span class="s1">self.norm.vmin = </span><span class="s5">0</span>
            <span class="s1">self.norm.vmax = </span><span class="s5">1</span>
        <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = mtransforms.nonsingular(</span>
            <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax</span><span class="s2">, </span><span class="s1">expander=</span><span class="s5">0.1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm) </span><span class="s2">and</span>
                <span class="s1">(self.boundaries </span><span class="s2">is None</span><span class="s1">)):</span>
            <span class="s1">b = self.norm.inverse(b)</span>

        <span class="s1">self._boundaries = np.asarray(b</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">self._values = </span><span class="s5">0.5 </span><span class="s1">* (self._boundaries[:-</span><span class="s5">1</span><span class="s1">] + self._boundaries[</span><span class="s5">1</span><span class="s1">:])</span>
        <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.NoNorm):</span>
            <span class="s1">self._values = (self._values + </span><span class="s5">0.00001</span><span class="s1">).astype(np.int16)</span>

    <span class="s2">def </span><span class="s1">_mesh(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the coordinate arrays for the colorbar pcolormesh/patches. 
 
        These are scaled between vmin and vmax, and already handle colorbar 
        orientation. 
        &quot;&quot;&quot;</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">_ = self._proportional_y()</span>
        <span class="s4"># Use the vmin and vmax of the colorbar, which may not be the same</span>
        <span class="s4"># as the norm. There are situations where the colormap has a</span>
        <span class="s4"># narrower range than the colorbar and we want to accommodate the</span>
        <span class="s4"># extra contours.</span>
        <span class="s2">if </span><span class="s1">(isinstance(self.norm</span><span class="s2">, </span><span class="s1">(colors.BoundaryNorm</span><span class="s2">, </span><span class="s1">colors.NoNorm))</span>
                <span class="s2">or </span><span class="s1">self.boundaries </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s4"># not using a norm.</span>
            <span class="s1">y = y * (self.vmax - self.vmin) + self.vmin</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Update the norm values in a context manager as it is only</span>
            <span class="s4"># a temporary change and we don't want to propagate any signals</span>
            <span class="s4"># attached to the norm (callbacks.blocked).</span>
            <span class="s2">with </span><span class="s1">self.norm.callbacks.blocked()</span><span class="s2">, </span><span class="s1">\</span>
                    <span class="s1">cbook._setattr_cm(self.norm</span><span class="s2">,</span>
                                      <span class="s1">vmin=self.vmin</span><span class="s2">,</span>
                                      <span class="s1">vmax=self.vmax):</span>
                <span class="s1">y = self.norm.inverse(y)</span>
        <span class="s1">self._y = y</span>
        <span class="s1">X</span><span class="s2">, </span><span class="s1">Y = np.meshgrid([</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(X</span><span class="s2">, </span><span class="s1">Y)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">(Y</span><span class="s2">, </span><span class="s1">X)</span>

    <span class="s2">def </span><span class="s1">_forward_boundaries(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s4"># map boundaries equally between 0 and 1...</span>
        <span class="s1">b = self._boundaries</span>
        <span class="s1">y = np.interp(x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(b)))</span>
        <span class="s4"># the following avoids ticks in the extends:</span>
        <span class="s1">eps = (b[-</span><span class="s5">1</span><span class="s1">] - b[</span><span class="s5">0</span><span class="s1">]) * </span><span class="s5">1e-6</span>
        <span class="s4"># map these _well_ out of bounds to keep any ticks out</span>
        <span class="s4"># of the extends region...</span>
        <span class="s1">y[x &lt; b[</span><span class="s5">0</span><span class="s1">]-eps] = -</span><span class="s5">1</span>
        <span class="s1">y[x &gt; b[-</span><span class="s5">1</span><span class="s1">]+eps] = </span><span class="s5">2</span>
        <span class="s2">return </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">_inverse_boundaries(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s4"># invert the above...</span>
        <span class="s1">b = self._boundaries</span>
        <span class="s2">return </span><span class="s1">np.interp(x</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(b))</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s2">def </span><span class="s1">_reset_locator_formatter_scale(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reset the locator et al to defaults.  Any user-hardcoded changes 
        need to be re-entered if this gets called (either at init, or when 
        the mappable normal gets changed: Colorbar.update_normal) 
        &quot;&quot;&quot;</span>
        <span class="s1">self._process_values()</span>
        <span class="s1">self._locator = </span><span class="s2">None</span>
        <span class="s1">self._minorlocator = </span><span class="s2">None</span>
        <span class="s1">self._formatter = </span><span class="s2">None</span>
        <span class="s1">self._minorformatter = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">(isinstance(self.mappable</span><span class="s2">, </span><span class="s1">contour.ContourSet) </span><span class="s2">and</span>
                <span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.LogNorm)):</span>
            <span class="s4"># if contours have lognorm, give them a log scale...</span>
            <span class="s1">self._set_scale(</span><span class="s3">'log'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">(self.boundaries </span><span class="s2">is not None or</span>
                <span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm)):</span>
            <span class="s2">if </span><span class="s1">self.spacing == </span><span class="s3">'uniform'</span><span class="s1">:</span>
                <span class="s1">funcs = (self._forward_boundaries</span><span class="s2">, </span><span class="s1">self._inverse_boundaries)</span>
                <span class="s1">self._set_scale(</span><span class="s3">'function'</span><span class="s2">, </span><span class="s1">functions=funcs)</span>
            <span class="s2">elif </span><span class="s1">self.spacing == </span><span class="s3">'proportional'</span><span class="s1">:</span>
                <span class="s1">self._set_scale(</span><span class="s3">'linear'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">getattr(self.norm</span><span class="s2">, </span><span class="s3">'_scale'</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s4"># use the norm's scale (if it exists and is not None):</span>
            <span class="s1">self._set_scale(self.norm._scale)</span>
        <span class="s2">elif </span><span class="s1">type(self.norm) </span><span class="s2">is </span><span class="s1">colors.Normalize:</span>
            <span class="s4"># plain Normalize:</span>
            <span class="s1">self._set_scale(</span><span class="s3">'linear'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># norm._scale is None or not an attr: derive the scale from</span>
            <span class="s4"># the Norm:</span>
            <span class="s1">funcs = (self.norm</span><span class="s2">, </span><span class="s1">self.norm.inverse)</span>
            <span class="s1">self._set_scale(</span><span class="s3">'function'</span><span class="s2">, </span><span class="s1">functions=funcs)</span>

    <span class="s2">def </span><span class="s1">_locate(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a set of color data values, return their 
        corresponding colorbar data coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.norm</span><span class="s2">, </span><span class="s1">(colors.NoNorm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm)):</span>
            <span class="s1">b = self._boundaries</span>
            <span class="s1">xn = x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Do calculations using normalized coordinates so</span>
            <span class="s4"># as to make the interpolation more accurate.</span>
            <span class="s1">b = self.norm(self._boundaries</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">).filled()</span>
            <span class="s1">xn = self.norm(x</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False</span><span class="s1">).filled()</span>

        <span class="s1">bunique = b[self._inside]</span>
        <span class="s1">yunique = self._y</span>

        <span class="s1">z = np.interp(xn</span><span class="s2">, </span><span class="s1">bunique</span><span class="s2">, </span><span class="s1">yunique)</span>
        <span class="s2">return </span><span class="s1">z</span>

    <span class="s4"># trivial helpers</span>

    <span class="s2">def </span><span class="s1">_uniform_y(self</span><span class="s2">, </span><span class="s1">N):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return colorbar data coordinates for *N* uniformly 
        spaced boundaries, plus extension lengths if required. 
        &quot;&quot;&quot;</span>
        <span class="s1">automin = automax = </span><span class="s5">1. </span><span class="s1">/ (N - </span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">extendlength = self._get_extension_lengths(self.extendfrac</span><span class="s2">,</span>
                                                   <span class="s1">automin</span><span class="s2">, </span><span class="s1">automax</span><span class="s2">,</span>
                                                   <span class="s1">default=</span><span class="s5">0.05</span><span class="s1">)</span>
        <span class="s1">y = np.linspace(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">extendlength</span>

    <span class="s2">def </span><span class="s1">_proportional_y(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return colorbar data coordinates for the boundaries of 
        a proportional colorbar, plus extension lengths if required: 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(isinstance(self.norm</span><span class="s2">, </span><span class="s1">colors.BoundaryNorm) </span><span class="s2">or</span>
                <span class="s1">self.boundaries </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">y = (self._boundaries - self._boundaries[self._inside][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">y = y / (self._boundaries[self._inside][-</span><span class="s5">1</span><span class="s1">] -</span>
                     <span class="s1">self._boundaries[self._inside][</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s4"># need yscaled the same as the axes scale to get</span>
            <span class="s4"># the extend lengths.</span>
            <span class="s2">if </span><span class="s1">self.spacing == </span><span class="s3">'uniform'</span><span class="s1">:</span>
                <span class="s1">yscaled = self._forward_boundaries(self._boundaries)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">yscaled = y</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = self.norm(self._boundaries.copy())</span>
            <span class="s1">y = np.ma.filled(y</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s4"># the norm and the scale should be the same...</span>
            <span class="s1">yscaled = y</span>
        <span class="s1">y = y[self._inside]</span>
        <span class="s1">yscaled = yscaled[self._inside]</span>
        <span class="s4"># normalize from 0..1:</span>
        <span class="s1">norm = colors.Normalize(y[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">y = np.ma.filled(norm(y)</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">norm = colors.Normalize(yscaled[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">yscaled[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">yscaled = np.ma.filled(norm(yscaled)</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s4"># make the lower and upper extend lengths proportional to the lengths</span>
        <span class="s4"># of the first and last boundary spacing (if extendfrac='auto'):</span>
        <span class="s1">automin = yscaled[</span><span class="s5">1</span><span class="s1">] - yscaled[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">automax = yscaled[-</span><span class="s5">1</span><span class="s1">] - yscaled[-</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">extendlength = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">self._extend_lower() </span><span class="s2">or </span><span class="s1">self._extend_upper():</span>
            <span class="s1">extendlength = self._get_extension_lengths(</span>
                    <span class="s1">self.extendfrac</span><span class="s2">, </span><span class="s1">automin</span><span class="s2">, </span><span class="s1">automax</span><span class="s2">, </span><span class="s1">default=</span><span class="s5">0.05</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">extendlength</span>

    <span class="s2">def </span><span class="s1">_get_extension_lengths(self</span><span class="s2">, </span><span class="s1">frac</span><span class="s2">, </span><span class="s1">automin</span><span class="s2">, </span><span class="s1">automax</span><span class="s2">, </span><span class="s1">default=</span><span class="s5">0.05</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the lengths of colorbar extensions. 
 
        This is a helper method for _uniform_y and _proportional_y. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Set the default value.</span>
        <span class="s1">extendlength = np.array([default</span><span class="s2">, </span><span class="s1">default])</span>
        <span class="s2">if </span><span class="s1">isinstance(frac</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">_api.check_in_list([</span><span class="s3">'auto'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">extendfrac=frac.lower())</span>
            <span class="s4"># Use the provided values when 'auto' is required.</span>
            <span class="s1">extendlength[:] = [automin</span><span class="s2">, </span><span class="s1">automax]</span>
        <span class="s2">elif </span><span class="s1">frac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># Try to set min and max extension fractions directly.</span>
                <span class="s1">extendlength[:] = frac</span>
                <span class="s4"># If frac is a sequence containing None then NaN may</span>
                <span class="s4"># be encountered. This is an error.</span>
                <span class="s2">if </span><span class="s1">np.isnan(extendlength).any():</span>
                    <span class="s2">raise </span><span class="s1">ValueError()</span>
            <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s4"># Raise an error on encountering an invalid value for frac.</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'invalid value for extendfrac'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">extendlength</span>

    <span class="s2">def </span><span class="s1">_extend_lower(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the lower limit is open ended.&quot;&quot;&quot;</span>
        <span class="s1">minmax = </span><span class="s3">&quot;max&quot; </span><span class="s2">if </span><span class="s1">self._long_axis().get_inverted() </span><span class="s2">else </span><span class="s3">&quot;min&quot;</span>
        <span class="s2">return </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s1">minmax)</span>

    <span class="s2">def </span><span class="s1">_extend_upper(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the upper limit is open ended.&quot;&quot;&quot;</span>
        <span class="s1">minmax = </span><span class="s3">&quot;min&quot; </span><span class="s2">if </span><span class="s1">self._long_axis().get_inverted() </span><span class="s2">else </span><span class="s3">&quot;max&quot;</span>
        <span class="s2">return </span><span class="s1">self.extend </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'both'</span><span class="s2">, </span><span class="s1">minmax)</span>

    <span class="s2">def </span><span class="s1">_long_axis(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the long axis&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.ax.yaxis</span>
        <span class="s2">return </span><span class="s1">self.ax.xaxis</span>

    <span class="s2">def </span><span class="s1">_short_axis(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the short axis&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.ax.xaxis</span>
        <span class="s2">return </span><span class="s1">self.ax.yaxis</span>

    <span class="s2">def </span><span class="s1">_get_view(self):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># An interactive view for a colorbar is the norm's vmin/vmax</span>
        <span class="s2">return </span><span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax</span>

    <span class="s2">def </span><span class="s1">_set_view(self</span><span class="s2">, </span><span class="s1">view):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># An interactive view for a colorbar is the norm's vmin/vmax</span>
        <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = view</span>

    <span class="s2">def </span><span class="s1">_set_view_from_bbox(self</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">direction=</span><span class="s3">'in'</span><span class="s2">,</span>
                            <span class="s1">mode=</span><span class="s2">None, </span><span class="s1">twinx=</span><span class="s2">False, </span><span class="s1">twiny=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># For colorbars, we use the zoom bbox to scale the norm's vmin/vmax</span>
        <span class="s1">new_xbound</span><span class="s2">, </span><span class="s1">new_ybound = self.ax._prepare_view_from_bbox(</span>
            <span class="s1">bbox</span><span class="s2">, </span><span class="s1">direction=direction</span><span class="s2">, </span><span class="s1">mode=mode</span><span class="s2">, </span><span class="s1">twinx=twinx</span><span class="s2">, </span><span class="s1">twiny=twiny)</span>
        <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'horizontal'</span><span class="s1">:</span>
            <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = new_xbound</span>
        <span class="s2">elif </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
            <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = new_ybound</span>

    <span class="s2">def </span><span class="s1">drag_pan(self</span><span class="s2">, </span><span class="s1">button</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">points = self.ax._get_pan_points(button</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">if </span><span class="s1">points </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'horizontal'</span><span class="s1">:</span>
                <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = points[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
                <span class="s1">self.norm.vmin</span><span class="s2">, </span><span class="s1">self.norm.vmax = points[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>


<span class="s1">ColorbarBase = Colorbar  </span><span class="s4"># Backcompat API</span>


<span class="s2">def </span><span class="s1">_normalize_location_orientation(location</span><span class="s2">, </span><span class="s1">orientation):</span>
    <span class="s2">if </span><span class="s1">location </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">location = _get_ticklocation_from_orientation(orientation)</span>
    <span class="s1">loc_settings = _api.check_getitem({</span>
        <span class="s3">&quot;left&quot;</span><span class="s1">:   {</span><span class="s3">&quot;location&quot;</span><span class="s1">: </span><span class="s3">&quot;left&quot;</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: (</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">&quot;panchor&quot;</span><span class="s1">: (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;pad&quot;</span><span class="s1">: </span><span class="s5">0.10</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s3">&quot;right&quot;</span><span class="s1">:  {</span><span class="s3">&quot;location&quot;</span><span class="s1">: </span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">&quot;panchor&quot;</span><span class="s1">: (</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;pad&quot;</span><span class="s1">: </span><span class="s5">0.05</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s3">&quot;top&quot;</span><span class="s1">:    {</span><span class="s3">&quot;location&quot;</span><span class="s1">: </span><span class="s3">&quot;top&quot;</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: (</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">&quot;panchor&quot;</span><span class="s1">: (</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;pad&quot;</span><span class="s1">: </span><span class="s5">0.05</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s3">&quot;bottom&quot;</span><span class="s1">: {</span><span class="s3">&quot;location&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s2">, </span><span class="s3">&quot;anchor&quot;</span><span class="s1">: (</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s3">&quot;panchor&quot;</span><span class="s1">: (</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;pad&quot;</span><span class="s1">: </span><span class="s5">0.15</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">, </span><span class="s1">location=location)</span>
    <span class="s1">loc_settings[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">] = _get_orientation_from_location(location)</span>
    <span class="s2">if </span><span class="s1">orientation </span><span class="s2">is not None and </span><span class="s1">orientation != loc_settings[</span><span class="s3">&quot;orientation&quot;</span><span class="s1">]:</span>
        <span class="s4"># Allow the user to pass both if they are consistent.</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;location and orientation are mutually exclusive&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">loc_settings</span>


<span class="s2">def </span><span class="s1">_get_orientation_from_location(location):</span>
    <span class="s2">return </span><span class="s1">_api.check_getitem(</span>
        <span class="s1">{</span><span class="s2">None</span><span class="s1">: </span><span class="s2">None, </span><span class="s3">&quot;left&quot;</span><span class="s1">: </span><span class="s3">&quot;vertical&quot;</span><span class="s2">, </span><span class="s3">&quot;right&quot;</span><span class="s1">: </span><span class="s3">&quot;vertical&quot;</span><span class="s2">,</span>
         <span class="s3">&quot;top&quot;</span><span class="s1">: </span><span class="s3">&quot;horizontal&quot;</span><span class="s2">, </span><span class="s3">&quot;bottom&quot;</span><span class="s1">: </span><span class="s3">&quot;horizontal&quot;</span><span class="s1">}</span><span class="s2">, </span><span class="s1">location=location)</span>


<span class="s2">def </span><span class="s1">_get_ticklocation_from_orientation(orientation):</span>
    <span class="s2">return </span><span class="s1">_api.check_getitem(</span>
        <span class="s1">{</span><span class="s2">None</span><span class="s1">: </span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;vertical&quot;</span><span class="s1">: </span><span class="s3">&quot;right&quot;</span><span class="s2">, </span><span class="s3">&quot;horizontal&quot;</span><span class="s1">: </span><span class="s3">&quot;bottom&quot;</span><span class="s1">}</span><span class="s2">,</span>
        <span class="s1">orientation=orientation)</span>


<span class="s1">@_docstring.interpd</span>
<span class="s2">def </span><span class="s1">make_axes(parents</span><span class="s2">, </span><span class="s1">location=</span><span class="s2">None, </span><span class="s1">orientation=</span><span class="s2">None, </span><span class="s1">fraction=</span><span class="s5">0.15</span><span class="s2">,</span>
              <span class="s1">shrink=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">aspect=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an `~.axes.Axes` suitable for a colorbar. 
 
    The axes is placed in the figure of the *parents* axes, by resizing and 
    repositioning *parents*. 
 
    Parameters 
    ---------- 
    parents : `~.axes.Axes` or iterable or `numpy.ndarray` of `~.axes.Axes` 
        The Axes to use as parents for placing the colorbar. 
    %(_make_axes_kw_doc)s 
 
    Returns 
    ------- 
    cax : `~.axes.Axes` 
        The child axes. 
    kwargs : dict 
        The reduced keyword dictionary to be passed when creating the colorbar 
        instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">loc_settings = _normalize_location_orientation(location</span><span class="s2">, </span><span class="s1">orientation)</span>
    <span class="s4"># put appropriate values into the kwargs dict for passing back to</span>
    <span class="s4"># the Colorbar class</span>
    <span class="s1">kwargs[</span><span class="s3">'orientation'</span><span class="s1">] = loc_settings[</span><span class="s3">'orientation'</span><span class="s1">]</span>
    <span class="s1">location = kwargs[</span><span class="s3">'ticklocation'</span><span class="s1">] = loc_settings[</span><span class="s3">'location'</span><span class="s1">]</span>

    <span class="s1">anchor = kwargs.pop(</span><span class="s3">'anchor'</span><span class="s2">, </span><span class="s1">loc_settings[</span><span class="s3">'anchor'</span><span class="s1">])</span>
    <span class="s1">panchor = kwargs.pop(</span><span class="s3">'panchor'</span><span class="s2">, </span><span class="s1">loc_settings[</span><span class="s3">'panchor'</span><span class="s1">])</span>
    <span class="s1">aspect0 = aspect</span>
    <span class="s4"># turn parents into a list if it is not already.  Note we cannot</span>
    <span class="s4"># use .flatten or .ravel as these copy the references rather than</span>
    <span class="s4"># reuse them, leading to a memory leak</span>
    <span class="s2">if </span><span class="s1">isinstance(parents</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">parents = list(parents.flat)</span>
    <span class="s2">elif </span><span class="s1">np.iterable(parents):</span>
        <span class="s1">parents = list(parents)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">parents = [parents]</span>

    <span class="s1">fig = parents[</span><span class="s5">0</span><span class="s1">].get_figure()</span>

    <span class="s1">pad0 = </span><span class="s5">0.05 </span><span class="s2">if </span><span class="s1">fig.get_constrained_layout() </span><span class="s2">else </span><span class="s1">loc_settings[</span><span class="s3">'pad'</span><span class="s1">]</span>
    <span class="s1">pad = kwargs.pop(</span><span class="s3">'pad'</span><span class="s2">, </span><span class="s1">pad0)</span>

    <span class="s2">if not </span><span class="s1">all(fig </span><span class="s2">is </span><span class="s1">ax.get_figure() </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">parents):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Unable to create a colorbar axes as not all '</span>
                         <span class="s3">'parents share the same figure.'</span><span class="s1">)</span>

    <span class="s4"># take a bounding box around all of the given axes</span>
    <span class="s1">parents_bbox = mtransforms.Bbox.union(</span>
        <span class="s1">[ax.get_position(original=</span><span class="s2">True</span><span class="s1">).frozen() </span><span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">parents])</span>

    <span class="s1">pb = parents_bbox</span>
    <span class="s2">if </span><span class="s1">location </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'right'</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">location == </span><span class="s3">'left'</span><span class="s1">:</span>
            <span class="s1">pbcb</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">pb1 = pb.splitx(fraction</span><span class="s2">, </span><span class="s1">fraction + pad)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pb1</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">pbcb = pb.splitx(</span><span class="s5">1 </span><span class="s1">- fraction - pad</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- fraction)</span>
        <span class="s1">pbcb = pbcb.shrunk(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">shrink).anchored(anchor</span><span class="s2">, </span><span class="s1">pbcb)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">location == </span><span class="s3">'bottom'</span><span class="s1">:</span>
            <span class="s1">pbcb</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">pb1 = pb.splity(fraction</span><span class="s2">, </span><span class="s1">fraction + pad)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pb1</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">pbcb = pb.splity(</span><span class="s5">1 </span><span class="s1">- fraction - pad</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- fraction)</span>
        <span class="s1">pbcb = pbcb.shrunk(shrink</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">).anchored(anchor</span><span class="s2">, </span><span class="s1">pbcb)</span>

        <span class="s4"># define the aspect ratio in terms of y's per x rather than x's per y</span>
        <span class="s1">aspect = </span><span class="s5">1.0 </span><span class="s1">/ aspect</span>

    <span class="s4"># define a transform which takes us from old axes coordinates to</span>
    <span class="s4"># new axes coordinates</span>
    <span class="s1">shrinking_trans = mtransforms.BboxTransform(parents_bbox</span><span class="s2">, </span><span class="s1">pb1)</span>

    <span class="s4"># transform each of the axes in parents using the new transform</span>
    <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">parents:</span>
        <span class="s1">new_posn = shrinking_trans.transform(ax.get_position(original=</span><span class="s2">True</span><span class="s1">))</span>
        <span class="s1">new_posn = mtransforms.Bbox(new_posn)</span>
        <span class="s1">ax._set_position(new_posn)</span>
        <span class="s2">if </span><span class="s1">panchor </span><span class="s2">is not False</span><span class="s1">:</span>
            <span class="s1">ax.set_anchor(panchor)</span>

    <span class="s1">cax = fig.add_axes(pbcb</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">&quot;&lt;colorbar&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">parents:</span>
        <span class="s4"># tell the parent it has a colorbar</span>
        <span class="s1">a._colorbars += [cax]</span>
    <span class="s1">cax._colorbar_info = dict(</span>
        <span class="s1">parents=parents</span><span class="s2">,</span>
        <span class="s1">location=location</span><span class="s2">,</span>
        <span class="s1">shrink=shrink</span><span class="s2">,</span>
        <span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">panchor=panchor</span><span class="s2">,</span>
        <span class="s1">fraction=fraction</span><span class="s2">,</span>
        <span class="s1">aspect=aspect0</span><span class="s2">,</span>
        <span class="s1">pad=pad)</span>
    <span class="s4"># and we need to set the aspect ratio by hand...</span>
    <span class="s1">cax.set_anchor(anchor)</span>
    <span class="s1">cax.set_box_aspect(aspect)</span>
    <span class="s1">cax.set_aspect(</span><span class="s3">'auto'</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">cax</span><span class="s2">, </span><span class="s1">kwargs</span>


<span class="s1">@_docstring.interpd</span>
<span class="s2">def </span><span class="s1">make_axes_gridspec(parent</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">location=</span><span class="s2">None, </span><span class="s1">orientation=</span><span class="s2">None,</span>
                       <span class="s1">fraction=</span><span class="s5">0.15</span><span class="s2">, </span><span class="s1">shrink=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">aspect=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create an `~.axes.Axes` suitable for a colorbar. 
 
    The axes is placed in the figure of the *parent* axes, by resizing and 
    repositioning *parent*. 
 
    This function is similar to `.make_axes` and mostly compatible with it. 
    Primary differences are 
 
    - `.make_axes_gridspec` requires the *parent* to have a subplotspec. 
    - `.make_axes` positions the axes in figure coordinates; 
      `.make_axes_gridspec` positions it using a subplotspec. 
    - `.make_axes` updates the position of the parent.  `.make_axes_gridspec` 
      replaces the parent gridspec with a new one. 
 
    Parameters 
    ---------- 
    parent : `~.axes.Axes` 
        The Axes to use as parent for placing the colorbar. 
    %(_make_axes_kw_doc)s 
 
    Returns 
    ------- 
    cax : `~.axes.Axes` 
        The child axes. 
    kwargs : dict 
        The reduced keyword dictionary to be passed when creating the colorbar 
        instance. 
    &quot;&quot;&quot;</span>

    <span class="s1">loc_settings = _normalize_location_orientation(location</span><span class="s2">, </span><span class="s1">orientation)</span>
    <span class="s1">kwargs[</span><span class="s3">'orientation'</span><span class="s1">] = loc_settings[</span><span class="s3">'orientation'</span><span class="s1">]</span>
    <span class="s1">location = kwargs[</span><span class="s3">'ticklocation'</span><span class="s1">] = loc_settings[</span><span class="s3">'location'</span><span class="s1">]</span>

    <span class="s1">aspect0 = aspect</span>
    <span class="s1">anchor = kwargs.pop(</span><span class="s3">'anchor'</span><span class="s2">, </span><span class="s1">loc_settings[</span><span class="s3">'anchor'</span><span class="s1">])</span>
    <span class="s1">panchor = kwargs.pop(</span><span class="s3">'panchor'</span><span class="s2">, </span><span class="s1">loc_settings[</span><span class="s3">'panchor'</span><span class="s1">])</span>
    <span class="s1">pad = kwargs.pop(</span><span class="s3">'pad'</span><span class="s2">, </span><span class="s1">loc_settings[</span><span class="s3">&quot;pad&quot;</span><span class="s1">])</span>
    <span class="s1">wh_space = </span><span class="s5">2 </span><span class="s1">* pad / (</span><span class="s5">1 </span><span class="s1">- pad)</span>

    <span class="s2">if </span><span class="s1">location </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'left'</span><span class="s2">, </span><span class="s3">'right'</span><span class="s1">):</span>
        <span class="s4"># for shrinking</span>
        <span class="s1">height_ratios = [</span>
                <span class="s1">(</span><span class="s5">1</span><span class="s1">-anchor[</span><span class="s5">1</span><span class="s1">])*(</span><span class="s5">1</span><span class="s1">-shrink)</span><span class="s2">, </span><span class="s1">shrink</span><span class="s2">, </span><span class="s1">anchor[</span><span class="s5">1</span><span class="s1">]*(</span><span class="s5">1</span><span class="s1">-shrink)]</span>

        <span class="s2">if </span><span class="s1">location == </span><span class="s3">'left'</span><span class="s1">:</span>
            <span class="s1">gs = parent.get_subplotspec().subgridspec(</span>
                    <span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">wspace=wh_space</span><span class="s2">,</span>
                    <span class="s1">width_ratios=[fraction</span><span class="s2">, </span><span class="s5">1</span><span class="s1">-fraction-pad])</span>
            <span class="s1">ss_main = gs[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">ss_cb = gs[</span><span class="s5">0</span><span class="s1">].subgridspec(</span>
                    <span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">hspace=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height_ratios=height_ratios)[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">gs = parent.get_subplotspec().subgridspec(</span>
                    <span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">wspace=wh_space</span><span class="s2">,</span>
                    <span class="s1">width_ratios=[</span><span class="s5">1</span><span class="s1">-fraction-pad</span><span class="s2">, </span><span class="s1">fraction])</span>
            <span class="s1">ss_main = gs[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">ss_cb = gs[</span><span class="s5">1</span><span class="s1">].subgridspec(</span>
                    <span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">hspace=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height_ratios=height_ratios)[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># for shrinking</span>
        <span class="s1">width_ratios = [</span>
                <span class="s1">anchor[</span><span class="s5">0</span><span class="s1">]*(</span><span class="s5">1</span><span class="s1">-shrink)</span><span class="s2">, </span><span class="s1">shrink</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s1">-anchor[</span><span class="s5">0</span><span class="s1">])*(</span><span class="s5">1</span><span class="s1">-shrink)]</span>

        <span class="s2">if </span><span class="s1">location == </span><span class="s3">'bottom'</span><span class="s1">:</span>
            <span class="s1">gs = parent.get_subplotspec().subgridspec(</span>
                    <span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">hspace=wh_space</span><span class="s2">,</span>
                    <span class="s1">height_ratios=[</span><span class="s5">1</span><span class="s1">-fraction-pad</span><span class="s2">, </span><span class="s1">fraction])</span>
            <span class="s1">ss_main = gs[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">ss_cb = gs[</span><span class="s5">1</span><span class="s1">].subgridspec(</span>
                    <span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">wspace=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">width_ratios=width_ratios)[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">aspect = </span><span class="s5">1 </span><span class="s1">/ aspect</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">gs = parent.get_subplotspec().subgridspec(</span>
                    <span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">hspace=wh_space</span><span class="s2">,</span>
                    <span class="s1">height_ratios=[fraction</span><span class="s2">, </span><span class="s5">1</span><span class="s1">-fraction-pad])</span>
            <span class="s1">ss_main = gs[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">ss_cb = gs[</span><span class="s5">0</span><span class="s1">].subgridspec(</span>
                    <span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">wspace=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">width_ratios=width_ratios)[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">aspect = </span><span class="s5">1 </span><span class="s1">/ aspect</span>

    <span class="s1">parent.set_subplotspec(ss_main)</span>
    <span class="s2">if </span><span class="s1">panchor </span><span class="s2">is not False</span><span class="s1">:</span>
        <span class="s1">parent.set_anchor(panchor)</span>

    <span class="s1">fig = parent.get_figure()</span>
    <span class="s1">cax = fig.add_subplot(ss_cb</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">&quot;&lt;colorbar&gt;&quot;</span><span class="s1">)</span>
    <span class="s1">cax.set_anchor(anchor)</span>
    <span class="s1">cax.set_box_aspect(aspect)</span>
    <span class="s1">cax.set_aspect(</span><span class="s3">'auto'</span><span class="s1">)</span>
    <span class="s1">cax._colorbar_info = dict(</span>
        <span class="s1">location=location</span><span class="s2">,</span>
        <span class="s1">parents=[parent]</span><span class="s2">,</span>
        <span class="s1">shrink=shrink</span><span class="s2">,</span>
        <span class="s1">anchor=anchor</span><span class="s2">,</span>
        <span class="s1">panchor=panchor</span><span class="s2">,</span>
        <span class="s1">fraction=fraction</span><span class="s2">,</span>
        <span class="s1">aspect=aspect0</span><span class="s2">,</span>
        <span class="s1">pad=pad)</span>

    <span class="s2">return </span><span class="s1">cax</span><span class="s2">, </span><span class="s1">kwargs</span>
</pre>
</body>
</html>