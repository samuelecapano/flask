<html>
<head>
<title>patheffects.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
patheffects.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Defines classes for path effects. The path effects are supported in `.Text`, 
`.Line2D` and `.Patch`. 
 
.. seealso:: 
   :doc:`/tutorials/advanced/patheffects_guide` 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">matplotlib.backend_bases </span><span class="s2">import </span><span class="s1">RendererBase</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">patches </span><span class="s2">as </span><span class="s1">mpatches</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>


<span class="s2">class </span><span class="s1">AbstractPathEffect:</span>
    <span class="s0">&quot;&quot;&quot; 
    A base class for path effects. 
 
    Subclasses should override the ``draw_path`` method to add effect 
    functionality. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offset : (float, float), default: (0, 0) 
            The (x, y) offset to apply to the path, measured in points. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._offset = offset</span>

    <span class="s2">def </span><span class="s1">_offset_transform(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Apply the offset to the given transform.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">mtransforms.Affine2D().translate(</span>
            <span class="s1">*map(renderer.points_to_pixels</span><span class="s2">, </span><span class="s1">self._offset))</span>

    <span class="s2">def </span><span class="s1">_update_gc(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">new_gc_dict):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the given GraphicsContext with the given dict of properties. 
 
        The keys in the dictionary are used to identify the appropriate 
        ``set_`` method on the *gc*. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_gc_dict = new_gc_dict.copy()</span>

        <span class="s1">dashes = new_gc_dict.pop(</span><span class="s4">&quot;dashes&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">dashes:</span>
            <span class="s1">gc.set_dashes(**dashes)</span>

        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">new_gc_dict.items():</span>
            <span class="s1">set_method = getattr(gc</span><span class="s2">, </span><span class="s4">'set_' </span><span class="s1">+ k</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">callable(set_method):</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">'Unknown property {0}'</span><span class="s1">.format(k))</span>
            <span class="s1">set_method(v)</span>
        <span class="s2">return </span><span class="s1">gc</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Derived should override this method. The arguments are the same 
        as :meth:`matplotlib.backend_bases.RendererBase.draw_path` 
        except the first argument is a renderer. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Get the real renderer, not a PathEffectRenderer.</span>
        <span class="s2">if </span><span class="s1">isinstance(renderer</span><span class="s2">, </span><span class="s1">PathEffectRenderer):</span>
            <span class="s1">renderer = renderer._renderer</span>
        <span class="s2">return </span><span class="s1">renderer.draw_path(gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace)</span>


<span class="s2">class </span><span class="s1">PathEffectRenderer(RendererBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    Implements a Renderer which contains another renderer. 
 
    This proxy then intercepts draw calls, calling the appropriate 
    :class:`AbstractPathEffect` draw method. 
 
    .. note:: 
        Not all methods have been overridden on this RendererBase subclass. 
        It may be necessary to add further methods to extend the PathEffects 
        capabilities further. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path_effects</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        path_effects : iterable of :class:`AbstractPathEffect` 
            The path effects which this renderer represents. 
        renderer : `matplotlib.backend_bases.RendererBase` subclass 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._path_effects = path_effects</span>
        <span class="s1">self._renderer = renderer</span>

    <span class="s2">def </span><span class="s1">copy_with_path_effect(self</span><span class="s2">, </span><span class="s1">path_effects):</span>
        <span class="s2">return </span><span class="s1">self.__class__(path_effects</span><span class="s2">, </span><span class="s1">self._renderer)</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">path_effect </span><span class="s2">in </span><span class="s1">self._path_effects:</span>
            <span class="s1">path_effect.draw_path(self._renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">,</span>
                                  <span class="s1">rgbFace)</span>

    <span class="s2">def </span><span class="s1">draw_markers(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s5"># We do a little shimmy so that all markers are drawn for each path</span>
        <span class="s5"># effect in turn. Essentially, we induce recursion (depth 1) which is</span>
        <span class="s5"># terminated once we have just a single path effect to work with.</span>
        <span class="s2">if </span><span class="s1">len(self._path_effects) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s5"># Call the base path effect function - this uses the unoptimised</span>
            <span class="s5"># approach of calling &quot;draw_path&quot; multiple times.</span>
            <span class="s2">return </span><span class="s1">super().draw_markers(gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">path</span><span class="s2">,</span>
                                        <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">for </span><span class="s1">path_effect </span><span class="s2">in </span><span class="s1">self._path_effects:</span>
            <span class="s1">renderer = self.copy_with_path_effect([path_effect])</span>
            <span class="s5"># Recursively call this method, only next time we will only have</span>
            <span class="s5"># one path effect.</span>
            <span class="s1">renderer.draw_markers(gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">path</span><span class="s2">,</span>
                                  <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">draw_path_collection(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                             <span class="s1">**kwargs):</span>
        <span class="s5"># We do a little shimmy so that all paths are drawn for each path</span>
        <span class="s5"># effect in turn. Essentially, we induce recursion (depth 1) which is</span>
        <span class="s5"># terminated once we have just a single path effect to work with.</span>
        <span class="s2">if </span><span class="s1">len(self._path_effects) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s5"># Call the base path effect function - this uses the unoptimised</span>
            <span class="s5"># approach of calling &quot;draw_path&quot; multiple times.</span>
            <span class="s2">return </span><span class="s1">super().draw_path_collection(gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">,</span>
                                                <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">for </span><span class="s1">path_effect </span><span class="s2">in </span><span class="s1">self._path_effects:</span>
            <span class="s1">renderer = self.copy_with_path_effect([path_effect])</span>
            <span class="s5"># Recursively call this method, only next time we will only have</span>
            <span class="s5"># one path effect.</span>
            <span class="s1">renderer.draw_path_collection(gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">,</span>
                                          <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_draw_text_as_path(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath):</span>
        <span class="s5"># Implements the naive text drawing as is found in RendererBase.</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">transform = self._get_text_path_transform(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">,</span>
                                                        <span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath)</span>
        <span class="s1">color = gc.get_rgb()</span>
        <span class="s1">gc.set_linewidth(</span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">self.draw_path(gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">rgbFace=color)</span>

    <span class="s2">def </span><span class="s1">__getattribute__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'flipy'</span><span class="s2">, </span><span class="s4">'get_canvas_width_height'</span><span class="s2">, </span><span class="s4">'new_gc'</span><span class="s2">,</span>
                    <span class="s4">'points_to_pixels'</span><span class="s2">, </span><span class="s4">'_text2path'</span><span class="s2">, </span><span class="s4">'height'</span><span class="s2">, </span><span class="s4">'width'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">getattr(self._renderer</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">object.__getattribute__(self</span><span class="s2">, </span><span class="s1">name)</span>


<span class="s2">class </span><span class="s1">Normal(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot; 
    The &quot;identity&quot; PathEffect. 
 
    The Normal PathEffect's sole purpose is to draw the original artist with 
    no special path effect. 
    &quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_subclass_with_normal(effect_class):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a PathEffect class combining *effect_class* and a normal draw. 
    &quot;&quot;&quot;</span>

    <span class="s2">class </span><span class="s1">withEffect(effect_class):</span>
        <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
            <span class="s1">super().draw_path(renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace)</span>
            <span class="s1">renderer.draw_path(gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace)</span>

    <span class="s1">withEffect.__name__ = </span><span class="s4">f&quot;with</span><span class="s2">{</span><span class="s1">effect_class.__name__</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s1">withEffect.__qualname__ = </span><span class="s4">f&quot;with</span><span class="s2">{</span><span class="s1">effect_class.__name__</span><span class="s2">}</span><span class="s4">&quot;</span>
    <span class="s1">withEffect.__doc__ = </span><span class="s4">f&quot;&quot;&quot;</span>
    <span class="s4">A shortcut PathEffect for applying `.</span><span class="s2">{</span><span class="s1">effect_class.__name__</span><span class="s2">}</span><span class="s4">` and then</span>
    <span class="s4">drawing the original Artist.</span>

    <span class="s4">With this class you can use ::</span>

        <span class="s4">artist.set_path_effects([path_effects.with</span><span class="s2">{</span><span class="s1">effect_class.__name__</span><span class="s2">}</span><span class="s4">()])</span>

    <span class="s4">as a shortcut for ::</span>

        <span class="s4">artist.set_path_effects([path_effects.</span><span class="s2">{</span><span class="s1">effect_class.__name__</span><span class="s2">}</span><span class="s4">(),</span>
                                 <span class="s4">path_effects.Normal()])</span>
    <span class="s4">&quot;&quot;&quot;</span>
    <span class="s5"># Docstring inheritance doesn't work for locally-defined subclasses.</span>
    <span class="s1">withEffect.draw_path.__doc__ = effect_class.draw_path.__doc__</span>
    <span class="s2">return </span><span class="s1">withEffect</span>


<span class="s2">class </span><span class="s1">Stroke(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot;A line based PathEffect which re-draws a stroke.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        The path will be stroked with its gc updated with the given 
        keyword arguments, i.e., the keyword arguments should be valid 
        gc parameter values. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(offset)</span>
        <span class="s1">self._gc = kwargs</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
        <span class="s0">&quot;&quot;&quot;Draw the path with updated gc.&quot;&quot;&quot;</span>
        <span class="s1">gc0 = renderer.new_gc()  </span><span class="s5"># Don't modify gc, but a copy!</span>
        <span class="s1">gc0.copy_properties(gc)</span>
        <span class="s1">gc0 = self._update_gc(gc0</span><span class="s2">, </span><span class="s1">self._gc)</span>
        <span class="s1">renderer.draw_path(</span>
            <span class="s1">gc0</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine + self._offset_transform(renderer)</span><span class="s2">, </span><span class="s1">rgbFace)</span>
        <span class="s1">gc0.restore()</span>


<span class="s1">withStroke = _subclass_with_normal(effect_class=Stroke)</span>


<span class="s2">class </span><span class="s1">SimplePatchShadow(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot;A simple shadow via a filled patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">shadow_rgbFace=</span><span class="s2">None, </span><span class="s1">alpha=</span><span class="s2">None,</span>
                 <span class="s1">rho=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offset : (float, float), default: (2, -2) 
            The (x, y) offset of the shadow in points. 
        shadow_rgbFace : color 
            The shadow color. 
        alpha : float, default: 0.3 
            The alpha transparency of the created shadow patch. 
        rho : float, default: 0.3 
            A scale factor to apply to the rgbFace color if *shadow_rgbFace* 
            is not specified. 
        **kwargs 
            Extra keywords are stored and passed through to 
            :meth:`AbstractPathEffect._update_gc`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(offset)</span>

        <span class="s2">if </span><span class="s1">shadow_rgbFace </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._shadow_rgbFace = shadow_rgbFace</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._shadow_rgbFace = mcolors.to_rgba(shadow_rgbFace)</span>

        <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">alpha = </span><span class="s3">0.3</span>

        <span class="s1">self._alpha = alpha</span>
        <span class="s1">self._rho = rho</span>

        <span class="s5">#: The dictionary of keywords to update the graphics collection with.</span>
        <span class="s1">self._gc = kwargs</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
        <span class="s0">&quot;&quot;&quot; 
        Overrides the standard draw_path to add the shadow offset and 
        necessary color changes for the shadow. 
        &quot;&quot;&quot;</span>
        <span class="s1">gc0 = renderer.new_gc()  </span><span class="s5"># Don't modify gc, but a copy!</span>
        <span class="s1">gc0.copy_properties(gc)</span>

        <span class="s2">if </span><span class="s1">self._shadow_rgbFace </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b = (rgbFace </span><span class="s2">or </span><span class="s1">(</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">))[:</span><span class="s3">3</span><span class="s1">]</span>
            <span class="s5"># Scale the colors by a factor to improve the shadow effect.</span>
            <span class="s1">shadow_rgbFace = (r * self._rho</span><span class="s2">, </span><span class="s1">g * self._rho</span><span class="s2">, </span><span class="s1">b * self._rho)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">shadow_rgbFace = self._shadow_rgbFace</span>

        <span class="s1">gc0.set_foreground(</span><span class="s4">&quot;none&quot;</span><span class="s1">)</span>
        <span class="s1">gc0.set_alpha(self._alpha)</span>
        <span class="s1">gc0.set_linewidth(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">gc0 = self._update_gc(gc0</span><span class="s2">, </span><span class="s1">self._gc)</span>
        <span class="s1">renderer.draw_path(</span>
            <span class="s1">gc0</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine + self._offset_transform(renderer)</span><span class="s2">,</span>
            <span class="s1">shadow_rgbFace)</span>
        <span class="s1">gc0.restore()</span>


<span class="s1">withSimplePatchShadow = _subclass_with_normal(effect_class=SimplePatchShadow)</span>


<span class="s2">class </span><span class="s1">SimpleLineShadow(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot;A simple shadow via a line.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">shadow_color=</span><span class="s4">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">rho=</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offset : (float, float), default: (2, -2) 
            The (x, y) offset to apply to the path, in points. 
        shadow_color : color, default: 'black' 
            The shadow color. 
            A value of ``None`` takes the original artist's color 
            with a scale factor of *rho*. 
        alpha : float, default: 0.3 
            The alpha transparency of the created shadow patch. 
        rho : float, default: 0.3 
            A scale factor to apply to the rgbFace color if *shadow_color* 
            is ``None``. 
        **kwargs 
            Extra keywords are stored and passed through to 
            :meth:`AbstractPathEffect._update_gc`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(offset)</span>
        <span class="s2">if </span><span class="s1">shadow_color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._shadow_color = shadow_color</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._shadow_color = mcolors.to_rgba(shadow_color)</span>
        <span class="s1">self._alpha = alpha</span>
        <span class="s1">self._rho = rho</span>
        <span class="s5">#: The dictionary of keywords to update the graphics collection with.</span>
        <span class="s1">self._gc = kwargs</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
        <span class="s0">&quot;&quot;&quot; 
        Overrides the standard draw_path to add the shadow offset and 
        necessary color changes for the shadow. 
        &quot;&quot;&quot;</span>
        <span class="s1">gc0 = renderer.new_gc()  </span><span class="s5"># Don't modify gc, but a copy!</span>
        <span class="s1">gc0.copy_properties(gc)</span>

        <span class="s2">if </span><span class="s1">self._shadow_color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b = (gc0.get_foreground() </span><span class="s2">or </span><span class="s1">(</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">))[:</span><span class="s3">3</span><span class="s1">]</span>
            <span class="s5"># Scale the colors by a factor to improve the shadow effect.</span>
            <span class="s1">shadow_rgbFace = (r * self._rho</span><span class="s2">, </span><span class="s1">g * self._rho</span><span class="s2">, </span><span class="s1">b * self._rho)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">shadow_rgbFace = self._shadow_color</span>

        <span class="s1">gc0.set_foreground(shadow_rgbFace)</span>
        <span class="s1">gc0.set_alpha(self._alpha)</span>

        <span class="s1">gc0 = self._update_gc(gc0</span><span class="s2">, </span><span class="s1">self._gc)</span>
        <span class="s1">renderer.draw_path(</span>
            <span class="s1">gc0</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine + self._offset_transform(renderer))</span>
        <span class="s1">gc0.restore()</span>


<span class="s2">class </span><span class="s1">PathPatchEffect(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot; 
    Draws a `.PathPatch` instance whose Path comes from the original 
    PathEffect artist. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offset : (float, float), default: (0, 0) 
            The (x, y) offset to apply to the path, in points. 
        **kwargs 
            All keyword arguments are passed through to the 
            :class:`~matplotlib.patches.PathPatch` constructor. The 
            properties which cannot be overridden are &quot;path&quot;, &quot;clip_box&quot; 
            &quot;transform&quot; and &quot;clip_path&quot;. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(offset=offset)</span>
        <span class="s1">self.patch = mpatches.PathPatch([]</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
        <span class="s1">self.patch._path = tpath</span>
        <span class="s1">self.patch.set_transform(affine + self._offset_transform(renderer))</span>
        <span class="s1">self.patch.set_clip_box(gc.get_clip_rectangle())</span>
        <span class="s1">clip_path = gc.get_clip_path()</span>
        <span class="s2">if </span><span class="s1">clip_path:</span>
            <span class="s1">self.patch.set_clip_path(*clip_path)</span>
        <span class="s1">self.patch.draw(renderer)</span>


<span class="s2">class </span><span class="s1">TickedStroke(AbstractPathEffect):</span>
    <span class="s0">&quot;&quot;&quot; 
    A line-based PathEffect which draws a path with a ticked style. 
 
    This line style is frequently used to represent constraints in 
    optimization.  The ticks may be used to indicate that one side 
    of the line is invalid or to represent a closed boundary of a 
    domain (i.e. a wall or the edge of a pipe). 
 
    The spacing, length, and angle of ticks can be controlled. 
 
    This line style is sometimes referred to as a hatched line. 
 
    See also the :doc:`contour demo example 
    &lt;/gallery/lines_bars_and_markers/lines_with_ticks_demo&gt;`. 
 
    See also the :doc:`contours in optimization example 
    &lt;/gallery/images_contours_and_fields/contours_in_optimization_demo&gt;`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">offset=(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">spacing=</span><span class="s3">10.0</span><span class="s2">, </span><span class="s1">angle=</span><span class="s3">45.0</span><span class="s2">, </span><span class="s1">length=np.sqrt(</span><span class="s3">2</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        offset : (float, float), default: (0, 0) 
            The (x, y) offset to apply to the path, in points. 
        spacing : float, default: 10.0 
            The spacing between ticks in points. 
        angle : float, default: 45.0 
            The angle between the path and the tick in degrees.  The angle 
            is measured as if you were an ant walking along the curve, with 
            zero degrees pointing directly ahead, 90 to your left, -90 
            to your right, and 180 behind you. 
        length : float, default: 1.414 
            The length of the tick relative to spacing. 
            Recommended length = 1.414 (sqrt(2)) when angle=45, length=1.0 
            when angle=90 and length=2.0 when angle=60. 
        **kwargs 
            Extra keywords are stored and passed through to 
            :meth:`AbstractPathEffect._update_gc`. 
 
        Examples 
        -------- 
        See :doc:`/gallery/misc/tickedstroke_demo`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(offset)</span>

        <span class="s1">self._spacing = spacing</span>
        <span class="s1">self._angle = angle</span>
        <span class="s1">self._length = length</span>
        <span class="s1">self._gc = kwargs</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">rgbFace):</span>
        <span class="s0">&quot;&quot;&quot;Draw the path with updated gc.&quot;&quot;&quot;</span>
        <span class="s5"># Do not modify the input! Use copy instead.</span>
        <span class="s1">gc0 = renderer.new_gc()</span>
        <span class="s1">gc0.copy_properties(gc)</span>

        <span class="s1">gc0 = self._update_gc(gc0</span><span class="s2">, </span><span class="s1">self._gc)</span>
        <span class="s1">trans = affine + self._offset_transform(renderer)</span>

        <span class="s1">theta = -np.radians(self._angle)</span>
        <span class="s1">trans_matrix = np.array([[np.cos(theta)</span><span class="s2">, </span><span class="s1">-np.sin(theta)]</span><span class="s2">,</span>
                                 <span class="s1">[np.sin(theta)</span><span class="s2">, </span><span class="s1">np.cos(theta)]])</span>

        <span class="s5"># Convert spacing parameter to pixels.</span>
        <span class="s1">spacing_px = renderer.points_to_pixels(self._spacing)</span>

        <span class="s5"># Transform before evaluation because to_polygons works at resolution</span>
        <span class="s5"># of one -- assuming it is working in pixel space.</span>
        <span class="s1">transpath = affine.transform_path(tpath)</span>

        <span class="s5"># Evaluate path to straight line segments that can be used to</span>
        <span class="s5"># construct line ticks.</span>
        <span class="s1">polys = transpath.to_polygons(closed_only=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">polys:</span>
            <span class="s1">x = p[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">y = p[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>

            <span class="s5"># Can not interpolate points or draw line if only one point in</span>
            <span class="s5"># polyline.</span>
            <span class="s2">if </span><span class="s1">x.size &lt; </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s2">continue</span>

            <span class="s5"># Find distance between points on the line</span>
            <span class="s1">ds = np.hypot(x[</span><span class="s3">1</span><span class="s1">:] - x[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[</span><span class="s3">1</span><span class="s1">:] - y[:-</span><span class="s3">1</span><span class="s1">])</span>

            <span class="s5"># Build parametric coordinate along curve</span>
            <span class="s1">s = np.concatenate(([</span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.cumsum(ds)))</span>
            <span class="s1">s_total = s[-</span><span class="s3">1</span><span class="s1">]</span>

            <span class="s1">num = int(np.ceil(s_total / spacing_px)) - </span><span class="s3">1</span>
            <span class="s5"># Pick parameter values for ticks.</span>
            <span class="s1">s_tick = np.linspace(spacing_px/</span><span class="s3">2</span><span class="s2">, </span><span class="s1">s_total - spacing_px/</span><span class="s3">2</span><span class="s2">, </span><span class="s1">num)</span>

            <span class="s5"># Find points along the parameterized curve</span>
            <span class="s1">x_tick = np.interp(s_tick</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s1">y_tick = np.interp(s_tick</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">y)</span>

            <span class="s5"># Find unit vectors in local direction of curve</span>
            <span class="s1">delta_s = self._spacing * </span><span class="s3">.001</span>
            <span class="s1">u = (np.interp(s_tick + delta_s</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">x) - x_tick) / delta_s</span>
            <span class="s1">v = (np.interp(s_tick + delta_s</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">y) - y_tick) / delta_s</span>

            <span class="s5"># Normalize slope into unit slope vector.</span>
            <span class="s1">n = np.hypot(u</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">mask = n == </span><span class="s3">0</span>
            <span class="s1">n[mask] = </span><span class="s3">1.0</span>

            <span class="s1">uv = np.array([u / n</span><span class="s2">, </span><span class="s1">v / n]).T</span>
            <span class="s1">uv[mask] = np.array([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]).T</span>

            <span class="s5"># Rotate and scale unit vector into tick vector</span>
            <span class="s1">dxy = np.dot(uv</span><span class="s2">, </span><span class="s1">trans_matrix) * self._length * spacing_px</span>

            <span class="s5"># Build tick endpoints</span>
            <span class="s1">x_end = x_tick + dxy[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">y_end = y_tick + dxy[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>

            <span class="s5"># Interleave ticks to form Path vertices</span>
            <span class="s1">xyt = np.empty((</span><span class="s3">2 </span><span class="s1">* num</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=x_tick.dtype)</span>
            <span class="s1">xyt[</span><span class="s3">0</span><span class="s1">::</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = x_tick</span>
            <span class="s1">xyt[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = x_end</span>
            <span class="s1">xyt[</span><span class="s3">0</span><span class="s1">::</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] = y_tick</span>
            <span class="s1">xyt[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] = y_end</span>

            <span class="s5"># Build up vector of Path codes</span>
            <span class="s1">codes = np.tile([Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.LINETO]</span><span class="s2">, </span><span class="s1">num)</span>

            <span class="s5"># Construct and draw resulting path</span>
            <span class="s1">h = Path(xyt</span><span class="s2">, </span><span class="s1">codes)</span>
            <span class="s5"># Transform back to data space during render</span>
            <span class="s1">renderer.draw_path(gc0</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">affine.inverted() + trans</span><span class="s2">, </span><span class="s1">rgbFace)</span>

        <span class="s1">gc0.restore()</span>


<span class="s1">withTickedStroke = _subclass_with_normal(effect_class=TickedStroke)</span>
</pre>
</body>
</html>