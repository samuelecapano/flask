<html>
<head>
<title>_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_base.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Iterable</span><span class="s0">, </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">ExitStack</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Real</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">attrgetter</span>
<span class="s0">import </span><span class="s1">types</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">cbook</span><span class="s0">, </span><span class="s1">_docstring</span><span class="s0">, </span><span class="s1">offsetbox</span>
<span class="s0">import </span><span class="s1">matplotlib.artist </span><span class="s0">as </span><span class="s1">martist</span>
<span class="s0">import </span><span class="s1">matplotlib.axis </span><span class="s0">as </span><span class="s1">maxis</span>
<span class="s0">from </span><span class="s1">matplotlib.cbook </span><span class="s0">import </span><span class="s1">_OrderedSet</span><span class="s0">, </span><span class="s1">_check_1d</span><span class="s0">, </span><span class="s1">index_of</span>
<span class="s0">import </span><span class="s1">matplotlib.collections </span><span class="s0">as </span><span class="s1">mcoll</span>
<span class="s0">import </span><span class="s1">matplotlib.colors </span><span class="s0">as </span><span class="s1">mcolors</span>
<span class="s0">import </span><span class="s1">matplotlib.font_manager </span><span class="s0">as </span><span class="s1">font_manager</span>
<span class="s0">from </span><span class="s1">matplotlib.gridspec </span><span class="s0">import </span><span class="s1">SubplotSpec</span>
<span class="s0">import </span><span class="s1">matplotlib.image </span><span class="s0">as </span><span class="s1">mimage</span>
<span class="s0">import </span><span class="s1">matplotlib.lines </span><span class="s0">as </span><span class="s1">mlines</span>
<span class="s0">import </span><span class="s1">matplotlib.patches </span><span class="s0">as </span><span class="s1">mpatches</span>
<span class="s0">from </span><span class="s1">matplotlib.rcsetup </span><span class="s0">import </span><span class="s1">cycler</span><span class="s0">, </span><span class="s1">validate_axisbelow</span>
<span class="s0">import </span><span class="s1">matplotlib.spines </span><span class="s0">as </span><span class="s1">mspines</span>
<span class="s0">import </span><span class="s1">matplotlib.table </span><span class="s0">as </span><span class="s1">mtable</span>
<span class="s0">import </span><span class="s1">matplotlib.text </span><span class="s0">as </span><span class="s1">mtext</span>
<span class="s0">import </span><span class="s1">matplotlib.ticker </span><span class="s0">as </span><span class="s1">mticker</span>
<span class="s0">import </span><span class="s1">matplotlib.transforms </span><span class="s0">as </span><span class="s1">mtransforms</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s0">class </span><span class="s1">_axis_method_wrapper:</span>
    <span class="s2">&quot;&quot;&quot; 
    Helper to generate Axes methods wrapping Axis methods. 
 
    After :: 
 
        get_foo = _axis_method_wrapper(&quot;xaxis&quot;, &quot;get_bar&quot;) 
 
    (in the body of a class) ``get_foo`` is a method that forwards it arguments 
    to the ``get_bar`` method of the ``xaxis`` attribute, and gets its 
    signature and docstring from ``Axis.get_bar``. 
 
    The docstring of ``get_foo`` is built by replacing &quot;this Axis&quot; by &quot;the 
    {attr_name}&quot; (i.e., &quot;the xaxis&quot;, &quot;the yaxis&quot;) in the wrapped method's 
    dedented docstring; additional replacements can be given in *doc_sub*. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">attr_name</span><span class="s0">, </span><span class="s1">method_name</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">doc_sub=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.attr_name = attr_name</span>
        <span class="s1">self.method_name = method_name</span>
        <span class="s3"># Immediately put the docstring in ``self.__doc__`` so that docstring</span>
        <span class="s3"># manipulations within the class body work as expected.</span>
        <span class="s1">doc = inspect.getdoc(getattr(maxis.Axis</span><span class="s0">, </span><span class="s1">method_name))</span>
        <span class="s1">self._missing_subs = []</span>
        <span class="s0">if </span><span class="s1">doc:</span>
            <span class="s1">doc_sub = {</span><span class="s4">&quot;this Axis&quot;</span><span class="s1">: </span><span class="s4">f&quot;the </span><span class="s0">{</span><span class="s1">self.attr_name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s0">, </span><span class="s1">**(doc_sub </span><span class="s0">or </span><span class="s1">{})}</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">doc_sub.items():</span>
                <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">doc:  </span><span class="s3"># Delay raising error until we know qualname.</span>
                    <span class="s1">self._missing_subs.append(k)</span>
                <span class="s1">doc = doc.replace(k</span><span class="s0">, </span><span class="s1">v)</span>
        <span class="s1">self.__doc__ = doc</span>

    <span class="s0">def </span><span class="s1">__set_name__(self</span><span class="s0">, </span><span class="s1">owner</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s3"># This is called at the end of the class body as</span>
        <span class="s3"># ``self.__set_name__(cls, name_under_which_self_is_assigned)``; we</span>
        <span class="s3"># rely on that to give the wrapper the correct __name__/__qualname__.</span>
        <span class="s1">get_method = attrgetter(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">self.attr_name</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">self.method_name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">wrapper(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s0">return </span><span class="s1">get_method(self)(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s1">wrapper.__module__ = owner.__module__</span>
        <span class="s1">wrapper.__name__ = name</span>
        <span class="s1">wrapper.__qualname__ = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">owner.__qualname__</span><span class="s0">}</span><span class="s4">.</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">wrapper.__doc__ = self.__doc__</span>
        <span class="s3"># Manually copy the signature instead of using functools.wraps because</span>
        <span class="s3"># displaying the Axis method source when asking for the Axes method</span>
        <span class="s3"># source would be confusing.</span>
        <span class="s1">wrapper.__signature__ = inspect.signature(</span>
            <span class="s1">getattr(maxis.Axis</span><span class="s0">, </span><span class="s1">self.method_name))</span>

        <span class="s0">if </span><span class="s1">self._missing_subs:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The definition of {} expected that the docstring of Axis.{} &quot;</span>
                <span class="s4">&quot;contains {!r} as substrings&quot;</span><span class="s1">.format(</span>
                    <span class="s1">wrapper.__qualname__</span><span class="s0">, </span><span class="s1">self.method_name</span><span class="s0">,</span>
                    <span class="s4">&quot;, &quot;</span><span class="s1">.join(map(repr</span><span class="s0">, </span><span class="s1">self._missing_subs))))</span>

        <span class="s1">setattr(owner</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">wrapper)</span>


<span class="s0">class </span><span class="s1">_TransformedBoundsLocator:</span>
    <span class="s2">&quot;&quot;&quot; 
    Axes locator for `.Axes.inset_axes` and similarly positioned Axes. 
 
    The locator is a callable object used in `.Axes.set_aspect` to compute the 
    Axes location depending on the renderer. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">bounds</span><span class="s0">, </span><span class="s1">transform):</span>
        <span class="s2">&quot;&quot;&quot; 
        *bounds* (a ``[l, b, w, h]`` rectangle) and *transform* together 
        specify the position of the inset Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._bounds = bounds</span>
        <span class="s1">self._transform = transform</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s3"># Subtracting transSubfigure will typically rely on inverted(),</span>
        <span class="s3"># freezing the transform; thus, this needs to be delayed until draw</span>
        <span class="s3"># time as transSubfigure may otherwise change after this is evaluated.</span>
        <span class="s0">return </span><span class="s1">mtransforms.TransformedBbox(</span>
            <span class="s1">mtransforms.Bbox.from_bounds(*self._bounds)</span><span class="s0">,</span>
            <span class="s1">self._transform - ax.figure.transSubfigure)</span>


<span class="s0">def </span><span class="s1">_process_plot_format(fmt</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">ambiguous_fmt_datakey=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a MATLAB style color/line style format string to a (*linestyle*, 
    *marker*, *color*) tuple. 
 
    Example format strings include: 
 
    * 'ko': black circles 
    * '.b': blue dots 
    * 'r--': red dashed lines 
    * 'C2--': the third color in the color cycle, dashed lines 
 
    The format is absolute in the sense that if a linestyle or marker is not 
    defined in *fmt*, there is no line or marker. This is expressed by 
    returning 'None' for the respective quantity. 
 
    See Also 
    -------- 
    matplotlib.Line2D.lineStyles, matplotlib.colors.cnames 
        All possible styles and color format strings. 
    &quot;&quot;&quot;</span>

    <span class="s1">linestyle = </span><span class="s0">None</span>
    <span class="s1">marker = </span><span class="s0">None</span>
    <span class="s1">color = </span><span class="s0">None</span>

    <span class="s3"># Is fmt just a colorspec?</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">color = mcolors.to_rgba(fmt)</span>

        <span class="s3"># We need to differentiate grayscale '1.0' from tri_down marker '1'</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">fmtint = str(int(fmt))</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">return </span><span class="s1">linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color  </span><span class="s3"># Yes</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">fmt != fmtint:</span>
                <span class="s3"># user definitely doesn't want tri_down marker</span>
                <span class="s0">return </span><span class="s1">linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color  </span><span class="s3"># Yes</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># ignore converted color</span>
                <span class="s1">color = </span><span class="s0">None</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s0">pass  </span><span class="s3"># No, not just a color.</span>

    <span class="s1">errfmt = (</span><span class="s4">&quot;{!r} is neither a data key nor a valid format string ({})&quot;</span>
              <span class="s0">if </span><span class="s1">ambiguous_fmt_datakey </span><span class="s0">else</span>
              <span class="s4">&quot;{!r} is not a valid format string ({})&quot;</span><span class="s1">)</span>

    <span class="s1">i = </span><span class="s5">0</span>
    <span class="s0">while </span><span class="s1">i &lt; len(fmt):</span>
        <span class="s1">c = fmt[i]</span>
        <span class="s0">if </span><span class="s1">fmt[i:i+</span><span class="s5">2</span><span class="s1">] </span><span class="s0">in </span><span class="s1">mlines.lineStyles:  </span><span class="s3"># First, the two-char styles.</span>
            <span class="s0">if </span><span class="s1">linestyle </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(errfmt.format(fmt</span><span class="s0">, </span><span class="s4">&quot;two linestyle symbols&quot;</span><span class="s1">))</span>
            <span class="s1">linestyle = fmt[i:i+</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">i += </span><span class="s5">2</span>
        <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">mlines.lineStyles:</span>
            <span class="s0">if </span><span class="s1">linestyle </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(errfmt.format(fmt</span><span class="s0">, </span><span class="s4">&quot;two linestyle symbols&quot;</span><span class="s1">))</span>
            <span class="s1">linestyle = c</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">mlines.lineMarkers:</span>
            <span class="s0">if </span><span class="s1">marker </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(errfmt.format(fmt</span><span class="s0">, </span><span class="s4">&quot;two marker symbols&quot;</span><span class="s1">))</span>
            <span class="s1">marker = c</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s0">elif </span><span class="s1">c </span><span class="s0">in </span><span class="s1">mcolors.get_named_colors_mapping():</span>
            <span class="s0">if </span><span class="s1">color </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(errfmt.format(fmt</span><span class="s0">, </span><span class="s4">&quot;two color symbols&quot;</span><span class="s1">))</span>
            <span class="s1">color = c</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s0">elif </span><span class="s1">c == </span><span class="s4">'C' </span><span class="s0">and </span><span class="s1">i &lt; len(fmt) - </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">color_cycle_number = int(fmt[i + </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">color = mcolors.to_rgba(</span><span class="s4">&quot;C{}&quot;</span><span class="s1">.format(color_cycle_number))</span>
            <span class="s1">i += </span><span class="s5">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s1">errfmt.format(fmt</span><span class="s0">, </span><span class="s4">f&quot;unrecognized character </span><span class="s0">{</span><span class="s1">c</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">))</span>

    <span class="s0">if </span><span class="s1">linestyle </span><span class="s0">is None and </span><span class="s1">marker </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">linestyle = mpl.rcParams[</span><span class="s4">'lines.linestyle'</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">linestyle </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">linestyle = </span><span class="s4">'None'</span>
    <span class="s0">if </span><span class="s1">marker </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">marker = </span><span class="s4">'None'</span>

    <span class="s0">return </span><span class="s1">linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color</span>


<span class="s0">class </span><span class="s1">_process_plot_var_args:</span>
    <span class="s2">&quot;&quot;&quot; 
    Process variable length arguments to `~.Axes.plot`, to support :: 
 
      plot(t, s) 
      plot(t1, s1, t2, s2) 
      plot(t1, s1, 'ko', t2, s2) 
      plot(t1, s1, 'ko', t2, s2, 'r--', t3, e3) 
 
    an arbitrary number of *x*, *y*, *fmt* are allowed 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">command=</span><span class="s4">'plot'</span><span class="s1">):</span>
        <span class="s1">self.axes = axes</span>
        <span class="s1">self.command = command</span>
        <span class="s1">self.set_prop_cycle(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s3"># note: it is not possible to pickle a generator (and thus a cycler).</span>
        <span class="s0">return </span><span class="s1">{</span><span class="s4">'axes'</span><span class="s1">: self.axes</span><span class="s0">, </span><span class="s4">'command'</span><span class="s1">: self.command}</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s1">self.__dict__ = state.copy()</span>
        <span class="s1">self.set_prop_cycle(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_prop_cycle(self</span><span class="s0">, </span><span class="s1">cycler):</span>
        <span class="s0">if </span><span class="s1">cycler </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cycler = mpl.rcParams[</span><span class="s4">'axes.prop_cycle'</span><span class="s1">]</span>
        <span class="s1">self.prop_cycler = itertools.cycle(cycler)</span>
        <span class="s1">self._prop_keys = cycler.keys  </span><span class="s3"># This should make a copy</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">data=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.axes._process_unit_info(kwargs=kwargs)</span>

        <span class="s0">for </span><span class="s1">pos_only </span><span class="s0">in </span><span class="s4">&quot;xy&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">pos_only </span><span class="s0">in </span><span class="s1">kwargs:</span>
                <span class="s0">raise </span><span class="s1">_api.kwarg_error(self.command</span><span class="s0">, </span><span class="s1">pos_only)</span>

        <span class="s0">if not </span><span class="s1">args:</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">data </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># Process dict views</span>
            <span class="s1">args = [cbook.sanitize_sequence(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args]</span>
        <span class="s0">else</span><span class="s1">:  </span><span class="s3"># Process the 'data' kwarg.</span>
            <span class="s1">replaced = [mpl._replacer(data</span><span class="s0">, </span><span class="s1">arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">args]</span>
            <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">label_namer_idx = </span><span class="s5">0</span>
            <span class="s0">elif </span><span class="s1">len(args) == </span><span class="s5">2</span><span class="s1">:  </span><span class="s3"># Can be x, y or y, c.</span>
                <span class="s3"># Figure out what the second argument is.</span>
                <span class="s3"># 1) If the second argument cannot be a format shorthand, the</span>
                <span class="s3">#    second argument is the label_namer.</span>
                <span class="s3"># 2) Otherwise (it could have been a format shorthand),</span>
                <span class="s3">#    a) if we did perform a substitution, emit a warning, and</span>
                <span class="s3">#       use it as label_namer.</span>
                <span class="s3">#    b) otherwise, it is indeed a format shorthand; use the</span>
                <span class="s3">#       first argument as label_namer.</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">_process_plot_format(args[</span><span class="s5">1</span><span class="s1">])</span>
                <span class="s0">except </span><span class="s1">ValueError:  </span><span class="s3"># case 1)</span>
                    <span class="s1">label_namer_idx = </span><span class="s5">1</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">replaced[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">args[</span><span class="s5">1</span><span class="s1">]:  </span><span class="s3"># case 2a)</span>
                        <span class="s1">_api.warn_external(</span>
                            <span class="s4">f&quot;Second argument </span><span class="s0">{</span><span class="s1">args[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">!r} </span><span class="s4">is ambiguous: could &quot;</span>
                            <span class="s4">f&quot;be a format string but is in 'data'; using as &quot;</span>
                            <span class="s4">f&quot;data.  If it was intended as data, set the &quot;</span>
                            <span class="s4">f&quot;format string to an empty string to suppress &quot;</span>
                            <span class="s4">f&quot;this warning.  If it was intended as a format &quot;</span>
                            <span class="s4">f&quot;string, explicitly pass the x-values as well.  &quot;</span>
                            <span class="s4">f&quot;Alternatively, rename the entry in 'data'.&quot;</span><span class="s0">,</span>
                            <span class="s1">RuntimeWarning)</span>
                        <span class="s1">label_namer_idx = </span><span class="s5">1</span>
                    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># case 2b)</span>
                        <span class="s1">label_namer_idx = </span><span class="s5">0</span>
            <span class="s0">elif </span><span class="s1">len(args) == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s1">label_namer_idx = </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Using arbitrary long args with data is not supported due &quot;</span>
                    <span class="s4">&quot;to ambiguity of arguments; use multiple plotting calls &quot;</span>
                    <span class="s4">&quot;instead&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">kwargs.get(</span><span class="s4">&quot;label&quot;</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;label&quot;</span><span class="s1">] = mpl._label_from_arg(</span>
                    <span class="s1">replaced[label_namer_idx]</span><span class="s0">, </span><span class="s1">args[label_namer_idx])</span>
            <span class="s1">args = replaced</span>
        <span class="s1">ambiguous_fmt_datakey = data </span><span class="s0">is not None and </span><span class="s1">len(args) == </span><span class="s5">2</span>

        <span class="s0">if </span><span class="s1">len(args) &gt;= </span><span class="s5">4 </span><span class="s0">and not </span><span class="s1">cbook.is_scalar_or_string(</span>
                <span class="s1">kwargs.get(</span><span class="s4">&quot;label&quot;</span><span class="s1">)):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;plot() with multiple groups of data (i.e., &quot;</span>
                             <span class="s4">&quot;pairs of x and y) does not support multiple &quot;</span>
                             <span class="s4">&quot;labels&quot;</span><span class="s1">)</span>

        <span class="s3"># Repeatedly grab (x, y) or (x, y, format) from the front of args and</span>
        <span class="s3"># massage them into arguments to plot() or fill().</span>

        <span class="s0">while </span><span class="s1">args:</span>
            <span class="s1">this</span><span class="s0">, </span><span class="s1">args = args[:</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s5">2</span><span class="s1">:]</span>
            <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">this += args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">args = args[</span><span class="s5">1</span><span class="s1">:]</span>
            <span class="s0">yield from </span><span class="s1">self._plot_args(</span>
                <span class="s1">this</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">ambiguous_fmt_datakey=ambiguous_fmt_datakey)</span>

    <span class="s0">def </span><span class="s1">get_next_color(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the next color in the cycle.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">'color' </span><span class="s0">not in </span><span class="s1">self._prop_keys:</span>
            <span class="s0">return </span><span class="s4">'k'</span>
        <span class="s0">return </span><span class="s1">next(self.prop_cycler)[</span><span class="s4">'color'</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_getdefaults(self</span><span class="s0">, </span><span class="s1">ignore</span><span class="s0">, </span><span class="s1">kw):</span>
        <span class="s2">&quot;&quot;&quot; 
        If some keys in the property cycle (excluding those in the set 
        *ignore*) are absent or set to None in the dict *kw*, return a copy 
        of the next entry in the property cycle, excluding keys in *ignore*. 
        Otherwise, don't advance the property cycle, and return an empty dict. 
        &quot;&quot;&quot;</span>
        <span class="s1">prop_keys = self._prop_keys - ignore</span>
        <span class="s0">if </span><span class="s1">any(kw.get(k</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">prop_keys):</span>
            <span class="s3"># Need to copy this dictionary or else the next time around</span>
            <span class="s3"># in the cycle, the dictionary could be missing entries.</span>
            <span class="s1">default_dict = next(self.prop_cycler).copy()</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">ignore:</span>
                <span class="s1">default_dict.pop(p</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">default_dict = {}</span>
        <span class="s0">return </span><span class="s1">default_dict</span>

    <span class="s0">def </span><span class="s1">_setdefaults(self</span><span class="s0">, </span><span class="s1">defaults</span><span class="s0">, </span><span class="s1">kw):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add to the dict *kw* the entries in the dict *default* that are absent 
        or set to None in *kw*. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">defaults:</span>
            <span class="s0">if </span><span class="s1">kw.get(k</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">kw[k] = defaults[k]</span>

    <span class="s0">def </span><span class="s1">_makeline(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">kw</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s1">kw = {**kw</span><span class="s0">, </span><span class="s1">**kwargs}  </span><span class="s3"># Don't modify the original kw.</span>
        <span class="s1">default_dict = self._getdefaults(set()</span><span class="s0">, </span><span class="s1">kw)</span>
        <span class="s1">self._setdefaults(default_dict</span><span class="s0">, </span><span class="s1">kw)</span>
        <span class="s1">seg = mlines.Line2D(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">return </span><span class="s1">seg</span><span class="s0">, </span><span class="s1">kw</span>

    <span class="s0">def </span><span class="s1">_makefill(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">kw</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s3"># Polygon doesn't directly support unitized inputs.</span>
        <span class="s1">x = self.axes.convert_xunits(x)</span>
        <span class="s1">y = self.axes.convert_yunits(y)</span>

        <span class="s1">kw = kw.copy()  </span><span class="s3"># Don't modify the original kw.</span>
        <span class="s1">kwargs = kwargs.copy()</span>

        <span class="s3"># Ignore 'marker'-related properties as they aren't Polygon</span>
        <span class="s3"># properties, but they are Line2D properties, and so they are</span>
        <span class="s3"># likely to appear in the default cycler construction.</span>
        <span class="s3"># This is done here to the defaults dictionary as opposed to the</span>
        <span class="s3"># other two dictionaries because we do want to capture when a</span>
        <span class="s3"># *user* explicitly specifies a marker which should be an error.</span>
        <span class="s3"># We also want to prevent advancing the cycler if there are no</span>
        <span class="s3"># defaults needed after ignoring the given properties.</span>
        <span class="s1">ignores = {</span><span class="s4">'marker'</span><span class="s0">, </span><span class="s4">'markersize'</span><span class="s0">, </span><span class="s4">'markeredgecolor'</span><span class="s0">,</span>
                   <span class="s4">'markerfacecolor'</span><span class="s0">, </span><span class="s4">'markeredgewidth'</span><span class="s1">}</span>
        <span class="s3"># Also ignore anything provided by *kwargs*.</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kwargs.items():</span>
            <span class="s0">if </span><span class="s1">v </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">ignores.add(k)</span>

        <span class="s3"># Only using the first dictionary to use as basis</span>
        <span class="s3"># for getting defaults for back-compat reasons.</span>
        <span class="s3"># Doing it with both seems to mess things up in</span>
        <span class="s3"># various places (probably due to logic bugs elsewhere).</span>
        <span class="s1">default_dict = self._getdefaults(ignores</span><span class="s0">, </span><span class="s1">kw)</span>
        <span class="s1">self._setdefaults(default_dict</span><span class="s0">, </span><span class="s1">kw)</span>

        <span class="s3"># Looks like we don't want &quot;color&quot; to be interpreted to</span>
        <span class="s3"># mean both facecolor and edgecolor for some reason.</span>
        <span class="s3"># So the &quot;kw&quot; dictionary is thrown out, and only its</span>
        <span class="s3"># 'color' value is kept and translated as a 'facecolor'.</span>
        <span class="s3"># This design should probably be revisited as it increases</span>
        <span class="s3"># complexity.</span>
        <span class="s1">facecolor = kw.get(</span><span class="s4">'color'</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s3"># Throw out 'color' as it is now handled as a facecolor</span>
        <span class="s1">default_dict.pop(</span><span class="s4">'color'</span><span class="s0">, None</span><span class="s1">)</span>

        <span class="s3"># To get other properties set from the cycler</span>
        <span class="s3"># modify the kwargs dictionary.</span>
        <span class="s1">self._setdefaults(default_dict</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">seg = mpatches.Polygon(np.column_stack((x</span><span class="s0">, </span><span class="s1">y))</span><span class="s0">,</span>
                               <span class="s1">facecolor=facecolor</span><span class="s0">,</span>
                               <span class="s1">fill=kwargs.get(</span><span class="s4">'fill'</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
                               <span class="s1">closed=kw[</span><span class="s4">'closed'</span><span class="s1">])</span>
        <span class="s1">seg.set(**kwargs)</span>
        <span class="s0">return </span><span class="s1">seg</span><span class="s0">, </span><span class="s1">kwargs</span>

    <span class="s0">def </span><span class="s1">_plot_args(self</span><span class="s0">, </span><span class="s1">tup</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">*</span><span class="s0">,</span>
                   <span class="s1">return_kwargs=</span><span class="s0">False, </span><span class="s1">ambiguous_fmt_datakey=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process the arguments of ``plot([x], y, [fmt], **kwargs)`` calls. 
 
        This processes a single set of ([x], y, [fmt]) parameters; i.e. for 
        ``plot(x, y, x2, y2)`` it will be called twice. Once for (x, y) and 
        once for (x2, y2). 
 
        x and y may be 2D and thus can still represent multiple datasets. 
 
        For multiple datasets, if the keyword argument *label* is a list, this 
        will unpack the list and assign the individual labels to the datasets. 
 
        Parameters 
        ---------- 
        tup : tuple 
            A tuple of the positional parameters. This can be one of 
 
            - (y,) 
            - (x, y) 
            - (y, fmt) 
            - (x, y, fmt) 
 
        kwargs : dict 
            The keyword arguments passed to ``plot()``. 
 
        return_kwargs : bool 
            Whether to also return the effective keyword arguments after label 
            unpacking as well. 
 
        ambiguous_fmt_datakey : bool 
            Whether the format string in *tup* could also have been a 
            misspelled data key. 
 
        Returns 
        ------- 
        result 
            If *return_kwargs* is false, a list of Artists representing the 
            dataset(s). 
            If *return_kwargs* is true, a list of (Artist, effective_kwargs) 
            representing the dataset(s). See *return_kwargs*. 
            The Artist is either `.Line2D` (if called from ``plot()``) or 
            `.Polygon` otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(tup) &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance(tup[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s3"># xy is tup with fmt stripped (could still be (y,) only)</span>
            <span class="s1">*xy</span><span class="s0">, </span><span class="s1">fmt = tup</span>
            <span class="s1">linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color = _process_plot_format(</span>
                <span class="s1">fmt</span><span class="s0">, </span><span class="s1">ambiguous_fmt_datakey=ambiguous_fmt_datakey)</span>
        <span class="s0">elif </span><span class="s1">len(tup) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'third arg must be a format string'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">xy = tup</span>
            <span class="s1">linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color = </span><span class="s0">None, None, None</span>

        <span class="s3"># Don't allow any None value; these would be up-converted to one</span>
        <span class="s3"># element array of None which causes problems downstream.</span>
        <span class="s0">if </span><span class="s1">any(v </span><span class="s0">is None for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">tup):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x, y, and format string must not be None&quot;</span><span class="s1">)</span>

        <span class="s1">kw = {}</span>
        <span class="s0">for </span><span class="s1">prop_name</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip((</span><span class="s4">'linestyle'</span><span class="s0">, </span><span class="s4">'marker'</span><span class="s0">, </span><span class="s4">'color'</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">(linestyle</span><span class="s0">, </span><span class="s1">marker</span><span class="s0">, </span><span class="s1">color)):</span>
            <span class="s0">if </span><span class="s1">val </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s3"># check for conflicts between fmt and kwargs</span>
                <span class="s0">if </span><span class="s1">(fmt.lower() != </span><span class="s4">'none'</span>
                        <span class="s0">and </span><span class="s1">prop_name </span><span class="s0">in </span><span class="s1">kwargs</span>
                        <span class="s0">and </span><span class="s1">val != </span><span class="s4">'None'</span><span class="s1">):</span>
                    <span class="s3"># Technically ``plot(x, y, 'o', ls='--')`` is a conflict</span>
                    <span class="s3"># because 'o' implicitly unsets the linestyle</span>
                    <span class="s3"># (linestyle='None').</span>
                    <span class="s3"># We'll gracefully not warn in this case because an</span>
                    <span class="s3"># explicit set via kwargs can be seen as intention to</span>
                    <span class="s3"># override an implicit unset.</span>
                    <span class="s3"># Note: We don't val.lower() != 'none' because val is not</span>
                    <span class="s3"># necessarily a string (can be a tuple for colors). This</span>
                    <span class="s3"># is safe, because *val* comes from _process_plot_format()</span>
                    <span class="s3"># which only returns 'None'.</span>
                    <span class="s1">_api.warn_external(</span>
                        <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">prop_name</span><span class="s0">} </span><span class="s4">is redundantly defined by the &quot;</span>
                        <span class="s4">f&quot;'</span><span class="s0">{</span><span class="s1">prop_name</span><span class="s0">}</span><span class="s4">' keyword argument and the fmt string &quot;</span>
                        <span class="s4">f'&quot;</span><span class="s0">{</span><span class="s1">fmt</span><span class="s0">}</span><span class="s4">&quot; (-&gt; </span><span class="s0">{</span><span class="s1">prop_name</span><span class="s0">}</span><span class="s4">=</span><span class="s0">{</span><span class="s1">val</span><span class="s0">!r}</span><span class="s4">). The keyword '</span>
                        <span class="s4">f&quot;argument will take precedence.&quot;</span><span class="s1">)</span>
                <span class="s1">kw[prop_name] = val</span>

        <span class="s0">if </span><span class="s1">len(xy) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">x = _check_1d(xy[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">y = _check_1d(xy[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = index_of(xy[-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s0">if </span><span class="s1">self.axes.xaxis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.axes.xaxis.update_units(x)</span>
        <span class="s0">if </span><span class="s1">self.axes.yaxis </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.axes.yaxis.update_units(y)</span>

        <span class="s0">if </span><span class="s1">x.shape[</span><span class="s5">0</span><span class="s1">] != y.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;x and y must have same first dimension, but &quot;</span>
                             <span class="s4">f&quot;have shapes </span><span class="s0">{</span><span class="s1">x.shape</span><span class="s0">} </span><span class="s4">and </span><span class="s0">{</span><span class="s1">y.shape</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">x.ndim &gt; </span><span class="s5">2 </span><span class="s0">or </span><span class="s1">y.ndim &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;x and y can be no greater than 2D, but have &quot;</span>
                             <span class="s4">f&quot;shapes </span><span class="s0">{</span><span class="s1">x.shape</span><span class="s0">} </span><span class="s4">and </span><span class="s0">{</span><span class="s1">y.shape</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
        <span class="s0">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">y = y[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

        <span class="s0">if </span><span class="s1">self.command == </span><span class="s4">'plot'</span><span class="s1">:</span>
            <span class="s1">make_artist = self._makeline</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">kw[</span><span class="s4">'closed'</span><span class="s1">] = kwargs.get(</span><span class="s4">'closed'</span><span class="s0">, True</span><span class="s1">)</span>
            <span class="s1">make_artist = self._makefill</span>

        <span class="s1">ncx</span><span class="s0">, </span><span class="s1">ncy = x.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">ncx &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">ncy &gt; </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">ncx != ncy:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;x has </span><span class="s0">{</span><span class="s1">ncx</span><span class="s0">} </span><span class="s4">columns but y has </span><span class="s0">{</span><span class="s1">ncy</span><span class="s0">} </span><span class="s4">columns&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">ncx == </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">ncy == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[]</span>

        <span class="s1">label = kwargs.get(</span><span class="s4">'label'</span><span class="s1">)</span>
        <span class="s1">n_datasets = max(ncx</span><span class="s0">, </span><span class="s1">ncy)</span>
        <span class="s0">if </span><span class="s1">n_datasets &gt; </span><span class="s5">1 </span><span class="s0">and not </span><span class="s1">cbook.is_scalar_or_string(label):</span>
            <span class="s0">if </span><span class="s1">len(label) != n_datasets:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;label must be scalar or have the same &quot;</span>
                                 <span class="s4">f&quot;length as the input data, but found &quot;</span>
                                 <span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">len(label)</span><span class="s0">} </span><span class="s4">for </span><span class="s0">{</span><span class="s1">n_datasets</span><span class="s0">} </span><span class="s4">datasets.&quot;</span><span class="s1">)</span>
            <span class="s1">labels = label</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">labels = [label] * n_datasets</span>

        <span class="s1">result = (make_artist(x[:</span><span class="s0">, </span><span class="s1">j % ncx]</span><span class="s0">, </span><span class="s1">y[:</span><span class="s0">, </span><span class="s1">j % ncy]</span><span class="s0">, </span><span class="s1">kw</span><span class="s0">,</span>
                              <span class="s1">{**kwargs</span><span class="s0">, </span><span class="s4">'label'</span><span class="s1">: label})</span>
                  <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">enumerate(labels))</span>

        <span class="s0">if </span><span class="s1">return_kwargs:</span>
            <span class="s0">return </span><span class="s1">list(result)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[l[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">result]</span>


<span class="s1">@_api.define_aliases({</span><span class="s4">&quot;facecolor&quot;</span><span class="s1">: [</span><span class="s4">&quot;fc&quot;</span><span class="s1">]})</span>
<span class="s0">class </span><span class="s1">_AxesBase(martist.Artist):</span>
    <span class="s1">name = </span><span class="s4">&quot;rectilinear&quot;</span>

    <span class="s3"># axis names are the prefixes for the attributes that contain the</span>
    <span class="s3"># respective axis; e.g. 'x' &lt;-&gt; self.xaxis, containing an XAxis.</span>
    <span class="s3"># Note that PolarAxes uses these attributes as well, so that we have</span>
    <span class="s3"># 'x' &lt;-&gt; self.xaxis, containing a ThetaAxis. In particular we do not</span>
    <span class="s3"># have 'theta' in _axis_names.</span>
    <span class="s3"># In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')</span>
    <span class="s3"># for Axes3D.</span>
    <span class="s1">_axis_names = (</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s1">_shared_axes = {name: cbook.Grouper() </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_axis_names}</span>
    <span class="s1">_twinned_axes = cbook.Grouper()</span>

    <span class="s1">_subclass_uses_cla = </span><span class="s0">False</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_axis_map(self):</span>
        <span class="s2">&quot;&quot;&quot;A mapping of axis names, e.g. 'x', to `Axis` instances.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">{name: getattr(self</span><span class="s0">, </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">axis&quot;</span><span class="s1">)</span>
                <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names}</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s4">&quot;{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})&quot;</span><span class="s1">.format(</span>
            <span class="s1">type(self).__name__</span><span class="s0">, </span><span class="s1">self._position.bounds)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">fig</span><span class="s0">,</span>
                 <span class="s1">*args</span><span class="s0">,</span>
                 <span class="s1">facecolor=</span><span class="s0">None,  </span><span class="s3"># defaults to rc axes.facecolor</span>
                 <span class="s1">frameon=</span><span class="s0">True,</span>
                 <span class="s1">sharex=</span><span class="s0">None,  </span><span class="s3"># use Axes instance's xaxis info</span>
                 <span class="s1">sharey=</span><span class="s0">None,  </span><span class="s3"># use Axes instance's yaxis info</span>
                 <span class="s1">label=</span><span class="s4">''</span><span class="s0">,</span>
                 <span class="s1">xscale=</span><span class="s0">None,</span>
                 <span class="s1">yscale=</span><span class="s0">None,</span>
                 <span class="s1">box_aspect=</span><span class="s0">None,</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Build an Axes in a figure. 
 
        Parameters 
        ---------- 
        fig : `~matplotlib.figure.Figure` 
            The Axes is built in the `.Figure` *fig*. 
 
        *args 
            ``*args`` can be a single ``(left, bottom, width, height)`` 
            rectangle or a single `.Bbox`.  This specifies the rectangle (in 
            figure coordinates) where the Axes is positioned. 
 
            ``*args`` can also consist of three numbers or a single three-digit 
            number; in the latter case, the digits are considered as 
            independent numbers.  The numbers are interpreted as ``(nrows, 
            ncols, index)``: ``(nrows, ncols)`` specifies the size of an array 
            of subplots, and ``index`` is the 1-based index of the subplot 
            being created.  Finally, ``*args`` can also directly be a 
            `.SubplotSpec` instance. 
 
        sharex, sharey : `~.axes.Axes`, optional 
            The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in 
            the input `~.axes.Axes`. 
 
        frameon : bool, default: True 
            Whether the Axes frame is visible. 
 
        box_aspect : float, optional 
            Set a fixed aspect for the Axes box, i.e. the ratio of height to 
            width. See `~.axes.Axes.set_box_aspect` for details. 
 
        **kwargs 
            Other optional keyword arguments: 
 
            %(Axes:kwdoc)s 
 
        Returns 
        ------- 
        `~.axes.Axes` 
            The new `~.axes.Axes` object. 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__()</span>
        <span class="s0">if </span><span class="s4">&quot;rect&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s0">if </span><span class="s1">args:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;'rect' cannot be used together with positional arguments&quot;</span><span class="s1">)</span>
            <span class="s1">rect = kwargs.pop(</span><span class="s4">&quot;rect&quot;</span><span class="s1">)</span>
            <span class="s1">_api.check_isinstance((mtransforms.Bbox</span><span class="s0">, </span><span class="s1">Iterable)</span><span class="s0">, </span><span class="s1">rect=rect)</span>
            <span class="s1">args = (rect</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">subplotspec = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance(args[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mtransforms.Bbox):</span>
            <span class="s1">self._position = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">len(args) == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">np.iterable(args[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">self._position = mtransforms.Bbox.from_bounds(*args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._position = self._originalPosition = mtransforms.Bbox.unit()</span>
            <span class="s1">subplotspec = SubplotSpec._from_subplot_args(fig</span><span class="s0">, </span><span class="s1">args)</span>
        <span class="s0">if </span><span class="s1">self._position.width &lt; </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">self._position.height &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'Width and height specified must be non-negative'</span><span class="s1">)</span>
        <span class="s1">self._originalPosition = self._position.frozen()</span>
        <span class="s1">self.axes = self</span>
        <span class="s1">self._aspect = </span><span class="s4">'auto'</span>
        <span class="s1">self._adjustable = </span><span class="s4">'box'</span>
        <span class="s1">self._anchor = </span><span class="s4">'C'</span>
        <span class="s1">self._stale_viewlims = {name: </span><span class="s0">False for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names}</span>
        <span class="s1">self._sharex = sharex</span>
        <span class="s1">self._sharey = sharey</span>
        <span class="s1">self.set_label(label)</span>
        <span class="s1">self.set_figure(fig)</span>
        <span class="s3"># The subplotspec needs to be set after the figure (so that</span>
        <span class="s3"># figure-level subplotpars are taken into account), but the figure</span>
        <span class="s3"># needs to be set after self._position is initialized.</span>
        <span class="s0">if </span><span class="s1">subplotspec:</span>
            <span class="s1">self.set_subplotspec(subplotspec)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._subplotspec = </span><span class="s0">None</span>
        <span class="s1">self.set_box_aspect(box_aspect)</span>
        <span class="s1">self._axes_locator = </span><span class="s0">None  </span><span class="s3"># Optionally set via update(kwargs).</span>

        <span class="s1">self._children = []</span>

        <span class="s3"># placeholder for any colorbars added that use this Axes.</span>
        <span class="s3"># (see colorbar.py):</span>
        <span class="s1">self._colorbars = []</span>
        <span class="s1">self.spines = mspines.Spines.from_dict(self._gen_axes_spines())</span>

        <span class="s3"># this call may differ for non-sep axes, e.g., polar</span>
        <span class="s1">self._init_axis()</span>
        <span class="s0">if </span><span class="s1">facecolor </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">facecolor = mpl.rcParams[</span><span class="s4">'axes.facecolor'</span><span class="s1">]</span>
        <span class="s1">self._facecolor = facecolor</span>
        <span class="s1">self._frameon = frameon</span>
        <span class="s1">self.set_axisbelow(mpl.rcParams[</span><span class="s4">'axes.axisbelow'</span><span class="s1">])</span>

        <span class="s1">self._rasterization_zorder = </span><span class="s0">None</span>
        <span class="s1">self.clear()</span>

        <span class="s3"># funcs used to format x and y - fall back on major formatters</span>
        <span class="s1">self.fmt_xdata = </span><span class="s0">None</span>
        <span class="s1">self.fmt_ydata = </span><span class="s0">None</span>

        <span class="s1">self.set_navigate(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.set_navigate_mode(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">xscale:</span>
            <span class="s1">self.set_xscale(xscale)</span>
        <span class="s0">if </span><span class="s1">yscale:</span>
            <span class="s1">self.set_yscale(yscale)</span>

        <span class="s1">self._internal_update(kwargs)</span>

        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.items():</span>
            <span class="s1">axis.callbacks._connect_picklable(</span>
                <span class="s4">'units'</span><span class="s0">, </span><span class="s1">self._unit_change_handler(name))</span>

        <span class="s1">rcParams = mpl.rcParams</span>
        <span class="s1">self.tick_params(</span>
            <span class="s1">top=rcParams[</span><span class="s4">'xtick.top'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'xtick.minor.top'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">bottom=rcParams[</span><span class="s4">'xtick.bottom'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'xtick.minor.bottom'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">labeltop=(rcParams[</span><span class="s4">'xtick.labeltop'</span><span class="s1">] </span><span class="s0">and</span>
                      <span class="s1">rcParams[</span><span class="s4">'xtick.minor.top'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">labelbottom=(rcParams[</span><span class="s4">'xtick.labelbottom'</span><span class="s1">] </span><span class="s0">and</span>
                         <span class="s1">rcParams[</span><span class="s4">'xtick.minor.bottom'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">left=rcParams[</span><span class="s4">'ytick.left'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'ytick.minor.left'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">right=rcParams[</span><span class="s4">'ytick.right'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'ytick.minor.right'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">labelleft=(rcParams[</span><span class="s4">'ytick.labelleft'</span><span class="s1">] </span><span class="s0">and</span>
                       <span class="s1">rcParams[</span><span class="s4">'ytick.minor.left'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">labelright=(rcParams[</span><span class="s4">'ytick.labelright'</span><span class="s1">] </span><span class="s0">and</span>
                        <span class="s1">rcParams[</span><span class="s4">'ytick.minor.right'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">which=</span><span class="s4">'minor'</span><span class="s1">)</span>

        <span class="s1">self.tick_params(</span>
            <span class="s1">top=rcParams[</span><span class="s4">'xtick.top'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'xtick.major.top'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">bottom=rcParams[</span><span class="s4">'xtick.bottom'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'xtick.major.bottom'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">labeltop=(rcParams[</span><span class="s4">'xtick.labeltop'</span><span class="s1">] </span><span class="s0">and</span>
                      <span class="s1">rcParams[</span><span class="s4">'xtick.major.top'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">labelbottom=(rcParams[</span><span class="s4">'xtick.labelbottom'</span><span class="s1">] </span><span class="s0">and</span>
                         <span class="s1">rcParams[</span><span class="s4">'xtick.major.bottom'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">left=rcParams[</span><span class="s4">'ytick.left'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'ytick.major.left'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">right=rcParams[</span><span class="s4">'ytick.right'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">rcParams[</span><span class="s4">'ytick.major.right'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">labelleft=(rcParams[</span><span class="s4">'ytick.labelleft'</span><span class="s1">] </span><span class="s0">and</span>
                       <span class="s1">rcParams[</span><span class="s4">'ytick.major.left'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">labelright=(rcParams[</span><span class="s4">'ytick.labelright'</span><span class="s1">] </span><span class="s0">and</span>
                        <span class="s1">rcParams[</span><span class="s4">'ytick.major.right'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">which=</span><span class="s4">'major'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init_subclass__(cls</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">parent_uses_cla = super(cls</span><span class="s0">, </span><span class="s1">cls)._subclass_uses_cla</span>
        <span class="s0">if </span><span class="s4">'cla' </span><span class="s0">in </span><span class="s1">cls.__dict__:</span>
            <span class="s1">_api.warn_deprecated(</span>
                <span class="s4">'3.6'</span><span class="s0">,</span>
                <span class="s1">pending=</span><span class="s0">True,</span>
                <span class="s1">message=</span><span class="s4">f'Overriding `Axes.cla` in </span><span class="s0">{</span><span class="s1">cls.__qualname__</span><span class="s0">} </span><span class="s4">is '</span>
                <span class="s4">'pending deprecation in %(since)s and will be fully '</span>
                <span class="s4">'deprecated in favor of `Axes.clear` in the future. '</span>
                <span class="s4">'Please report '</span>
                <span class="s4">f'this to the </span><span class="s0">{</span><span class="s1">cls.__module__</span><span class="s0">!r} </span><span class="s4">author.'</span><span class="s1">)</span>
        <span class="s1">cls._subclass_uses_cla = </span><span class="s4">'cla' </span><span class="s0">in </span><span class="s1">cls.__dict__ </span><span class="s0">or </span><span class="s1">parent_uses_cla</span>
        <span class="s1">super().__init_subclass__(**kwargs)</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">state = super().__getstate__()</span>
        <span class="s3"># Prune the sharing &amp; twinning info to only contain the current group.</span>
        <span class="s1">state[</span><span class="s4">&quot;_shared_axes&quot;</span><span class="s1">] = {</span>
            <span class="s1">name: self._shared_axes[name].get_siblings(self)</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names </span><span class="s0">if </span><span class="s1">self </span><span class="s0">in </span><span class="s1">self._shared_axes[name]}</span>
        <span class="s1">state[</span><span class="s4">&quot;_twinned_axes&quot;</span><span class="s1">] = (self._twinned_axes.get_siblings(self)</span>
                                  <span class="s0">if </span><span class="s1">self </span><span class="s0">in </span><span class="s1">self._twinned_axes </span><span class="s0">else None</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">state</span>

    <span class="s0">def </span><span class="s1">__setstate__(self</span><span class="s0">, </span><span class="s1">state):</span>
        <span class="s3"># Merge the grouping info back into the global groupers.</span>
        <span class="s1">shared_axes = state.pop(</span><span class="s4">&quot;_shared_axes&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">shared_siblings </span><span class="s0">in </span><span class="s1">shared_axes.items():</span>
            <span class="s1">self._shared_axes[name].join(*shared_siblings)</span>
        <span class="s1">twinned_siblings = state.pop(</span><span class="s4">&quot;_twinned_axes&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">twinned_siblings:</span>
            <span class="s1">self._twinned_axes.join(*twinned_siblings)</span>
        <span class="s1">self.__dict__ = state</span>
        <span class="s1">self._stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">fields = []</span>
        <span class="s0">if </span><span class="s1">self.get_label():</span>
            <span class="s1">fields += [</span><span class="s4">f&quot;label=</span><span class="s0">{</span><span class="s1">self.get_label()</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">&quot;get_title&quot;</span><span class="s1">):</span>
            <span class="s1">titles = {}</span>
            <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s4">&quot;center&quot;</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s1">]:</span>
                <span class="s1">title = self.get_title(loc=k)</span>
                <span class="s0">if </span><span class="s1">title:</span>
                    <span class="s1">titles[k] = title</span>
            <span class="s0">if </span><span class="s1">titles:</span>
                <span class="s1">fields += [</span><span class="s4">f&quot;title=</span><span class="s0">{</span><span class="s1">titles</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.items():</span>
            <span class="s0">if </span><span class="s1">axis.get_label() </span><span class="s0">and </span><span class="s1">axis.get_label().get_text():</span>
                <span class="s1">fields += [</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">label=</span><span class="s0">{</span><span class="s1">axis.get_label().get_text()</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s4">f&quot;&lt;</span><span class="s0">{</span><span class="s1">self.__class__.__name__</span><span class="s0">}</span><span class="s4">: &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(fields) + </span><span class="s4">&quot;&gt;&quot;</span>

    <span class="s0">def </span><span class="s1">get_subplotspec(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the `.SubplotSpec` associated with the subplot, or None.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._subplotspec</span>

    <span class="s0">def </span><span class="s1">set_subplotspec(self</span><span class="s0">, </span><span class="s1">subplotspec):</span>
        <span class="s2">&quot;&quot;&quot;Set the `.SubplotSpec`. associated with the subplot.&quot;&quot;&quot;</span>
        <span class="s1">self._subplotspec = subplotspec</span>
        <span class="s1">self._set_position(subplotspec.get_position(self.figure))</span>

    <span class="s0">def </span><span class="s1">get_gridspec(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the `.GridSpec` associated with the subplot, or None.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._subplotspec.get_gridspec() </span><span class="s0">if </span><span class="s1">self._subplotspec </span><span class="s0">else None</span>

    <span class="s1">@_api.delete_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s4">&quot;args&quot;</span><span class="s1">)</span>
    <span class="s1">@_api.delete_parameter(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s4">&quot;kwargs&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">get_window_extent(self</span><span class="s0">, </span><span class="s1">renderer=</span><span class="s0">None, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the Axes bounding box in display space; *args* and *kwargs* 
        are empty. 
 
        This bounding box does not include the spines, ticks, ticklabels, 
        or other labels.  For a bounding box including these elements use 
        `~matplotlib.axes.Axes.get_tightbbox`. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.get_tightbbox 
        matplotlib.axis.Axis.get_tightbbox 
        matplotlib.spines.Spine.get_window_extent 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.bbox</span>

    <span class="s0">def </span><span class="s1">_init_axis(self):</span>
        <span class="s3"># This is moved out of __init__ because non-separable axes don't use it</span>
        <span class="s1">self.xaxis = maxis.XAxis(self)</span>
        <span class="s1">self.spines.bottom.register_axis(self.xaxis)</span>
        <span class="s1">self.spines.top.register_axis(self.xaxis)</span>
        <span class="s1">self.yaxis = maxis.YAxis(self)</span>
        <span class="s1">self.spines.left.register_axis(self.yaxis)</span>
        <span class="s1">self.spines.right.register_axis(self.yaxis)</span>

    <span class="s0">def </span><span class="s1">set_figure(self</span><span class="s0">, </span><span class="s1">fig):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">super().set_figure(fig)</span>

        <span class="s1">self.bbox = mtransforms.TransformedBbox(self._position</span><span class="s0">,</span>
                                                <span class="s1">fig.transSubfigure)</span>
        <span class="s3"># these will be updated later as data is added</span>
        <span class="s1">self.dataLim = mtransforms.Bbox.null()</span>
        <span class="s1">self._viewLim = mtransforms.Bbox.unit()</span>
        <span class="s1">self.transScale = mtransforms.TransformWrapper(</span>
            <span class="s1">mtransforms.IdentityTransform())</span>

        <span class="s1">self._set_lim_and_transforms()</span>

    <span class="s0">def </span><span class="s1">_unstale_viewLim(self):</span>
        <span class="s3"># We should arrange to store this information once per share-group</span>
        <span class="s3"># instead of on every axis.</span>
        <span class="s1">need_scale = {</span>
            <span class="s1">name: any(ax._stale_viewlims[name]</span>
                      <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._shared_axes[name].get_siblings(self))</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names}</span>
        <span class="s0">if </span><span class="s1">any(need_scale.values()):</span>
            <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">need_scale:</span>
                <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._shared_axes[name].get_siblings(self):</span>
                    <span class="s1">ax._stale_viewlims[name] = </span><span class="s0">False</span>
            <span class="s1">self.autoscale_view(**{</span><span class="s4">f&quot;scale</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">: scale</span>
                                   <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">scale </span><span class="s0">in </span><span class="s1">need_scale.items()})</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">viewLim(self):</span>
        <span class="s1">self._unstale_viewLim()</span>
        <span class="s0">return </span><span class="s1">self._viewLim</span>

    <span class="s0">def </span><span class="s1">_request_autoscale_view(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s1">tight=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Mark a single axis, or all of them, as stale wrt. autoscaling. 
 
        No computation is performed until the next autoscaling; thus, separate 
        calls to control individual axises incur negligible performance cost. 
 
        Parameters 
        ---------- 
        axis : str, default: &quot;all&quot; 
            Either an element of ``self._axis_names``, or &quot;all&quot;. 
        tight : bool or None, default: None 
        &quot;&quot;&quot;</span>
        <span class="s1">axis_names = _api.check_getitem(</span>
            <span class="s1">{**{k: [k] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self._axis_names}</span><span class="s0">, </span><span class="s4">&quot;all&quot;</span><span class="s1">: self._axis_names}</span><span class="s0">,</span>
            <span class="s1">axis=axis)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">axis_names:</span>
            <span class="s1">self._stale_viewlims[name] = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">tight </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._tight = tight</span>

    <span class="s0">def </span><span class="s1">_set_lim_and_transforms(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*, 
        *transData*, *transLimits* and *transAxes* transformations. 
 
        .. note:: 
 
            This method is primarily used by rectilinear projections of the 
            `~matplotlib.axes.Axes` class, and is meant to be overridden by 
            new kinds of projection Axes that need different transformations 
            and limits. (See `~matplotlib.projections.polar.PolarAxes` for an 
            example.) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.transAxes = mtransforms.BboxTransformTo(self.bbox)</span>

        <span class="s3"># Transforms the x and y axis separately by a scale factor.</span>
        <span class="s3"># It is assumed that this part will have non-linear components</span>
        <span class="s3"># (e.g., for a log scale).</span>
        <span class="s1">self.transScale = mtransforms.TransformWrapper(</span>
            <span class="s1">mtransforms.IdentityTransform())</span>

        <span class="s3"># An affine transformation on the data, generally to limit the</span>
        <span class="s3"># range of the axes</span>
        <span class="s1">self.transLimits = mtransforms.BboxTransformFrom(</span>
            <span class="s1">mtransforms.TransformedBbox(self._viewLim</span><span class="s0">, </span><span class="s1">self.transScale))</span>

        <span class="s3"># The parentheses are important for efficiency here -- they</span>
        <span class="s3"># group the last two (which are usually affines) separately</span>
        <span class="s3"># from the first (which, with log-scaling can be non-affine).</span>
        <span class="s1">self.transData = self.transScale + (self.transLimits + self.transAxes)</span>

        <span class="s1">self._xaxis_transform = mtransforms.blended_transform_factory(</span>
            <span class="s1">self.transData</span><span class="s0">, </span><span class="s1">self.transAxes)</span>
        <span class="s1">self._yaxis_transform = mtransforms.blended_transform_factory(</span>
            <span class="s1">self.transAxes</span><span class="s0">, </span><span class="s1">self.transData)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the transformation used for drawing x-axis labels, ticks 
        and gridlines.  The x-direction is in data coordinates and the 
        y-direction is in axis coordinates. 
 
        .. note:: 
 
            This transformation is primarily used by the 
            `~matplotlib.axis.Axis` class, and is meant to be 
            overridden by new kinds of projections that may need to 
            place axis elements in different locations. 
 
        Parameters 
        ---------- 
        which : {'grid', 'tick1', 'tick2'} 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">which == </span><span class="s4">'grid'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._xaxis_transform</span>
        <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'tick1'</span><span class="s1">:</span>
            <span class="s3"># for cartesian projection, this is bottom spine</span>
            <span class="s0">return </span><span class="s1">self.spines.bottom.get_spine_transform()</span>
        <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'tick2'</span><span class="s1">:</span>
            <span class="s3"># for cartesian projection, this is top spine</span>
            <span class="s0">return </span><span class="s1">self.spines.top.get_spine_transform()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f'unknown value for which: </span><span class="s0">{</span><span class="s1">which</span><span class="s0">!r}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad_points):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        transform : Transform 
            The transform used for drawing x-axis labels, which will add 
            *pad_points* of padding (in points) between the axis and the label. 
            The x-direction is in data coordinates and the y-direction is in 
            axis coordinates 
        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'} 
            The text vertical alignment. 
        halign : {'center', 'left', 'right'} 
            The text horizontal alignment. 
 
        Notes 
        ----- 
        This transformation is primarily used by the `~matplotlib.axis.Axis` 
        class, and is meant to be overridden by new kinds of projections that 
        may need to place axis elements in different locations. 
        &quot;&quot;&quot;</span>
        <span class="s1">labels_align = mpl.rcParams[</span><span class="s4">&quot;xtick.alignment&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">(self.get_xaxis_transform(which=</span><span class="s4">'tick1'</span><span class="s1">) +</span>
                <span class="s1">mtransforms.ScaledTranslation(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1 </span><span class="s1">* pad_points / </span><span class="s5">72</span><span class="s0">,</span>
                                              <span class="s1">self.figure.dpi_scale_trans)</span><span class="s0">,</span>
                <span class="s4">&quot;top&quot;</span><span class="s0">, </span><span class="s1">labels_align)</span>

    <span class="s0">def </span><span class="s1">get_xaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad_points):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        transform : Transform 
            The transform used for drawing secondary x-axis labels, which will 
            add *pad_points* of padding (in points) between the axis and the 
            label.  The x-direction is in data coordinates and the y-direction 
            is in axis coordinates 
        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'} 
            The text vertical alignment. 
        halign : {'center', 'left', 'right'} 
            The text horizontal alignment. 
 
        Notes 
        ----- 
        This transformation is primarily used by the `~matplotlib.axis.Axis` 
        class, and is meant to be overridden by new kinds of projections that 
        may need to place axis elements in different locations. 
        &quot;&quot;&quot;</span>
        <span class="s1">labels_align = mpl.rcParams[</span><span class="s4">&quot;xtick.alignment&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">(self.get_xaxis_transform(which=</span><span class="s4">'tick2'</span><span class="s1">) +</span>
                <span class="s1">mtransforms.ScaledTranslation(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">pad_points / </span><span class="s5">72</span><span class="s0">,</span>
                                              <span class="s1">self.figure.dpi_scale_trans)</span><span class="s0">,</span>
                <span class="s4">&quot;bottom&quot;</span><span class="s0">, </span><span class="s1">labels_align)</span>

    <span class="s0">def </span><span class="s1">get_yaxis_transform(self</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'grid'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the transformation used for drawing y-axis labels, ticks 
        and gridlines.  The x-direction is in axis coordinates and the 
        y-direction is in data coordinates. 
 
        .. note:: 
 
            This transformation is primarily used by the 
            `~matplotlib.axis.Axis` class, and is meant to be 
            overridden by new kinds of projections that may need to 
            place axis elements in different locations. 
 
        Parameters 
        ---------- 
        which : {'grid', 'tick1', 'tick2'} 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">which == </span><span class="s4">'grid'</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._yaxis_transform</span>
        <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'tick1'</span><span class="s1">:</span>
            <span class="s3"># for cartesian projection, this is bottom spine</span>
            <span class="s0">return </span><span class="s1">self.spines.left.get_spine_transform()</span>
        <span class="s0">elif </span><span class="s1">which == </span><span class="s4">'tick2'</span><span class="s1">:</span>
            <span class="s3"># for cartesian projection, this is top spine</span>
            <span class="s0">return </span><span class="s1">self.spines.right.get_spine_transform()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f'unknown value for which: </span><span class="s0">{</span><span class="s1">which</span><span class="s0">!r}</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text1_transform(self</span><span class="s0">, </span><span class="s1">pad_points):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        transform : Transform 
            The transform used for drawing y-axis labels, which will add 
            *pad_points* of padding (in points) between the axis and the label. 
            The x-direction is in axis coordinates and the y-direction is in 
            data coordinates 
        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'} 
            The text vertical alignment. 
        halign : {'center', 'left', 'right'} 
            The text horizontal alignment. 
 
        Notes 
        ----- 
        This transformation is primarily used by the `~matplotlib.axis.Axis` 
        class, and is meant to be overridden by new kinds of projections that 
        may need to place axis elements in different locations. 
        &quot;&quot;&quot;</span>
        <span class="s1">labels_align = mpl.rcParams[</span><span class="s4">&quot;ytick.alignment&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">(self.get_yaxis_transform(which=</span><span class="s4">'tick1'</span><span class="s1">) +</span>
                <span class="s1">mtransforms.ScaledTranslation(-</span><span class="s5">1 </span><span class="s1">* pad_points / </span><span class="s5">72</span><span class="s0">, </span><span class="s5">0</span><span class="s0">,</span>
                                              <span class="s1">self.figure.dpi_scale_trans)</span><span class="s0">,</span>
                <span class="s1">labels_align</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_yaxis_text2_transform(self</span><span class="s0">, </span><span class="s1">pad_points):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        transform : Transform 
            The transform used for drawing secondart y-axis labels, which will 
            add *pad_points* of padding (in points) between the axis and the 
            label.  The x-direction is in axis coordinates and the y-direction 
            is in data coordinates 
        valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'} 
            The text vertical alignment. 
        halign : {'center', 'left', 'right'} 
            The text horizontal alignment. 
 
        Notes 
        ----- 
        This transformation is primarily used by the `~matplotlib.axis.Axis` 
        class, and is meant to be overridden by new kinds of projections that 
        may need to place axis elements in different locations. 
        &quot;&quot;&quot;</span>
        <span class="s1">labels_align = mpl.rcParams[</span><span class="s4">&quot;ytick.alignment&quot;</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">(self.get_yaxis_transform(which=</span><span class="s4">'tick2'</span><span class="s1">) +</span>
                <span class="s1">mtransforms.ScaledTranslation(pad_points / </span><span class="s5">72</span><span class="s0">, </span><span class="s5">0</span><span class="s0">,</span>
                                              <span class="s1">self.figure.dpi_scale_trans)</span><span class="s0">,</span>
                <span class="s1">labels_align</span><span class="s0">, </span><span class="s4">&quot;left&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_update_transScale(self):</span>
        <span class="s1">self.transScale.set(</span>
            <span class="s1">mtransforms.blended_transform_factory(</span>
                <span class="s1">self.xaxis.get_transform()</span><span class="s0">, </span><span class="s1">self.yaxis.get_transform()))</span>

    <span class="s0">def </span><span class="s1">get_position(self</span><span class="s0">, </span><span class="s1">original=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the position of the Axes within the figure as a `.Bbox`. 
 
        Parameters 
        ---------- 
        original : bool 
            If ``True``, return the original position. Otherwise, return the 
            active position. For an explanation of the positions see 
            `.set_position`. 
 
        Returns 
        ------- 
        `.Bbox` 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">original:</span>
            <span class="s0">return </span><span class="s1">self._originalPosition.frozen()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">locator = self.get_axes_locator()</span>
            <span class="s0">if not </span><span class="s1">locator:</span>
                <span class="s1">self.apply_aspect()</span>
            <span class="s0">return </span><span class="s1">self._position.frozen()</span>

    <span class="s0">def </span><span class="s1">set_position(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'both'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the Axes position. 
 
        Axes have two position attributes. The 'original' position is the 
        position allocated for the Axes. The 'active' position is the 
        position the Axes is actually drawn at. These positions are usually 
        the same unless a fixed aspect is set to the Axes. See 
        `.Axes.set_aspect` for details. 
 
        Parameters 
        ---------- 
        pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox` 
            The new position of the Axes in `.Figure` coordinates. 
 
        which : {'both', 'active', 'original'}, default: 'both' 
            Determines which position variables to change. 
 
        See Also 
        -------- 
        matplotlib.transforms.Bbox.from_bounds 
        matplotlib.transforms.Bbox.from_extents 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_position(pos</span><span class="s0">, </span><span class="s1">which=which)</span>
        <span class="s3"># because this is being called externally to the library we</span>
        <span class="s3"># don't let it be in the layout.</span>
        <span class="s1">self.set_in_layout(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_set_position(self</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'both'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Private version of set_position. 
 
        Call this internally to get the same functionality of `set_position`, 
        but not to take the axis out of the constrained_layout hierarchy. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(pos</span><span class="s0">, </span><span class="s1">mtransforms.BboxBase):</span>
            <span class="s1">pos = mtransforms.Bbox.from_bounds(*pos)</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._twinned_axes.get_siblings(self):</span>
            <span class="s0">if </span><span class="s1">which </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'both'</span><span class="s0">, </span><span class="s4">'active'</span><span class="s1">):</span>
                <span class="s1">ax._position.set(pos)</span>
            <span class="s0">if </span><span class="s1">which </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'both'</span><span class="s0">, </span><span class="s4">'original'</span><span class="s1">):</span>
                <span class="s1">ax._originalPosition.set(pos)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">reset_position(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Reset the active position to the original position. 
 
        This undoes changes to the active position (as defined in 
        `.set_position`) which may have been performed to satisfy fixed-aspect 
        constraints. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._twinned_axes.get_siblings(self):</span>
            <span class="s1">pos = ax.get_position(original=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">ax.set_position(pos</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'active'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_axes_locator(self</span><span class="s0">, </span><span class="s1">locator):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the Axes locator. 
 
        Parameters 
        ---------- 
        locator : Callable[[Axes, Renderer], Bbox] 
        &quot;&quot;&quot;</span>
        <span class="s1">self._axes_locator = locator</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_axes_locator(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the axes_locator. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._axes_locator</span>

    <span class="s0">def </span><span class="s1">_set_artist_props(self</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s2">&quot;&quot;&quot;Set the boilerplate props for artists added to Axes.&quot;&quot;&quot;</span>
        <span class="s1">a.set_figure(self.figure)</span>
        <span class="s0">if not </span><span class="s1">a.is_transform_set():</span>
            <span class="s1">a.set_transform(self.transData)</span>

        <span class="s1">a.axes = self</span>
        <span class="s0">if </span><span class="s1">a.get_mouseover():</span>
            <span class="s1">self._mouseover_set.add(a)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_patch(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        Patch 
            The patch used to draw the background of the Axes.  It is also used 
            as the clipping path for any data elements on the Axes. 
 
            In the standard Axes, this is a rectangle, but in other projections 
            it may not be. 
 
        Notes 
        ----- 
        Intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">mpatches.Rectangle((</span><span class="s5">0.0</span><span class="s0">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s0">, </span><span class="s5">1.0</span><span class="s0">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_gen_axes_spines(self</span><span class="s0">, </span><span class="s1">locations=</span><span class="s0">None, </span><span class="s1">offset=</span><span class="s5">0.0</span><span class="s0">, </span><span class="s1">units=</span><span class="s4">'inches'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns 
        ------- 
        dict 
            Mapping of spine names to `.Line2D` or `.Patch` instances that are 
            used to draw Axes spines. 
 
            In the standard Axes, spines are single line segments, but in other 
            projections they may not be. 
 
        Notes 
        ----- 
        Intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">{side: mspines.Spine.linear_spine(self</span><span class="s0">, </span><span class="s1">side)</span>
                <span class="s0">for </span><span class="s1">side </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'right'</span><span class="s0">, </span><span class="s4">'bottom'</span><span class="s0">, </span><span class="s4">'top'</span><span class="s1">]}</span>

    <span class="s0">def </span><span class="s1">sharex(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot; 
        Share the x-axis with *other*. 
 
        This is equivalent to passing ``sharex=other`` when constructing the 
        Axes, and cannot be used if the x-axis is already being shared with 
        another Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(_AxesBase</span><span class="s0">, </span><span class="s1">other=other)</span>
        <span class="s0">if </span><span class="s1">self._sharex </span><span class="s0">is not None and </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">self._sharex:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;x-axis is already shared&quot;</span><span class="s1">)</span>
        <span class="s1">self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">].join(self</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s1">self._sharex = other</span>
        <span class="s1">self.xaxis.major = other.xaxis.major  </span><span class="s3"># Ticker instances holding</span>
        <span class="s1">self.xaxis.minor = other.xaxis.minor  </span><span class="s3"># locator and formatter.</span>
        <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = other.get_xlim()</span>
        <span class="s1">self.set_xlim(x0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">emit=</span><span class="s0">False, </span><span class="s1">auto=other.get_autoscalex_on())</span>
        <span class="s1">self.xaxis._scale = other.xaxis._scale</span>

    <span class="s0">def </span><span class="s1">sharey(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s2">&quot;&quot;&quot; 
        Share the y-axis with *other*. 
 
        This is equivalent to passing ``sharey=other`` when constructing the 
        Axes, and cannot be used if the y-axis is already being shared with 
        another Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(_AxesBase</span><span class="s0">, </span><span class="s1">other=other)</span>
        <span class="s0">if </span><span class="s1">self._sharey </span><span class="s0">is not None and </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">self._sharey:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;y-axis is already shared&quot;</span><span class="s1">)</span>
        <span class="s1">self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">].join(self</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s1">self._sharey = other</span>
        <span class="s1">self.yaxis.major = other.yaxis.major  </span><span class="s3"># Ticker instances holding</span>
        <span class="s1">self.yaxis.minor = other.yaxis.minor  </span><span class="s3"># locator and formatter.</span>
        <span class="s1">y0</span><span class="s0">, </span><span class="s1">y1 = other.get_ylim()</span>
        <span class="s1">self.set_ylim(y0</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">emit=</span><span class="s0">False, </span><span class="s1">auto=other.get_autoscaley_on())</span>
        <span class="s1">self.yaxis._scale = other.yaxis._scale</span>

    <span class="s0">def </span><span class="s1">__clear(self):</span>
        <span class="s2">&quot;&quot;&quot;Clear the Axes.&quot;&quot;&quot;</span>
        <span class="s3"># The actual implementation of clear() as long as clear() has to be</span>
        <span class="s3"># an adapter delegating to the correct implementation.</span>
        <span class="s3"># The implementation can move back into clear() when the</span>
        <span class="s3"># deprecation on cla() subclassing expires.</span>

        <span class="s3"># stash the current visibility state</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s4">'patch'</span><span class="s1">):</span>
            <span class="s1">patch_visible = self.patch.get_visible()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">patch_visible = </span><span class="s0">True</span>

        <span class="s1">xaxis_visible = self.xaxis.get_visible()</span>
        <span class="s1">yaxis_visible = self.yaxis.get_visible()</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
            <span class="s1">axis.clear()  </span><span class="s3"># Also resets the scale to linear.</span>
        <span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">self.spines.values():</span>
            <span class="s1">spine.clear()</span>

        <span class="s1">self.ignore_existing_data_limits = </span><span class="s0">True</span>
        <span class="s1">self.callbacks = cbook.CallbackRegistry(</span>
            <span class="s1">signals=[</span><span class="s4">&quot;xlim_changed&quot;</span><span class="s0">, </span><span class="s4">&quot;ylim_changed&quot;</span><span class="s0">, </span><span class="s4">&quot;zlim_changed&quot;</span><span class="s1">])</span>

        <span class="s3"># update the minor locator for x and y axis based on rcParams</span>
        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'xtick.minor.visible'</span><span class="s1">]:</span>
            <span class="s1">self.xaxis.set_minor_locator(mticker.AutoMinorLocator())</span>
        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'ytick.minor.visible'</span><span class="s1">]:</span>
            <span class="s1">self.yaxis.set_minor_locator(mticker.AutoMinorLocator())</span>

        <span class="s1">self._xmargin = mpl.rcParams[</span><span class="s4">'axes.xmargin'</span><span class="s1">]</span>
        <span class="s1">self._ymargin = mpl.rcParams[</span><span class="s4">'axes.ymargin'</span><span class="s1">]</span>
        <span class="s1">self._tight = </span><span class="s0">None</span>
        <span class="s1">self._use_sticky_edges = </span><span class="s0">True</span>

        <span class="s1">self._get_lines = _process_plot_var_args(self)</span>
        <span class="s1">self._get_patches_for_fill = _process_plot_var_args(self</span><span class="s0">, </span><span class="s4">'fill'</span><span class="s1">)</span>

        <span class="s1">self._gridOn = mpl.rcParams[</span><span class="s4">'axes.grid'</span><span class="s1">]</span>
        <span class="s1">old_children</span><span class="s0">, </span><span class="s1">self._children = self._children</span><span class="s0">, </span><span class="s1">[]</span>
        <span class="s0">for </span><span class="s1">chld </span><span class="s0">in </span><span class="s1">old_children:</span>
            <span class="s1">chld.axes = chld.figure = </span><span class="s0">None</span>
        <span class="s1">self._mouseover_set = _OrderedSet()</span>
        <span class="s1">self.child_axes = []</span>
        <span class="s1">self._current_image = </span><span class="s0">None  </span><span class="s3"># strictly for pyplot via _sci, _gci</span>
        <span class="s1">self._projection_init = </span><span class="s0">None  </span><span class="s3"># strictly for pyplot.subplot</span>
        <span class="s1">self.legend_ = </span><span class="s0">None</span>
        <span class="s1">self.containers = []</span>

        <span class="s1">self.grid(</span><span class="s0">False</span><span class="s1">)  </span><span class="s3"># Disable grid on init to use rcParameter</span>
        <span class="s1">self.grid(self._gridOn</span><span class="s0">, </span><span class="s1">which=mpl.rcParams[</span><span class="s4">'axes.grid.which'</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">axis=mpl.rcParams[</span><span class="s4">'axes.grid.axis'</span><span class="s1">])</span>
        <span class="s1">props = font_manager.FontProperties(</span>
            <span class="s1">size=mpl.rcParams[</span><span class="s4">'axes.titlesize'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">weight=mpl.rcParams[</span><span class="s4">'axes.titleweight'</span><span class="s1">])</span>

        <span class="s1">y = mpl.rcParams[</span><span class="s4">'axes.titley'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">y = </span><span class="s5">1.0</span>
            <span class="s1">self._autotitlepos = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._autotitlepos = </span><span class="s0">False</span>

        <span class="s1">self.title = mtext.Text(</span>
            <span class="s1">x=</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">text=</span><span class="s4">''</span><span class="s0">,</span>
            <span class="s1">fontproperties=props</span><span class="s0">,</span>
            <span class="s1">verticalalignment=</span><span class="s4">'baseline'</span><span class="s0">,</span>
            <span class="s1">horizontalalignment=</span><span class="s4">'center'</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">self._left_title = mtext.Text(</span>
            <span class="s1">x=</span><span class="s5">0.0</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">text=</span><span class="s4">''</span><span class="s0">,</span>
            <span class="s1">fontproperties=props.copy()</span><span class="s0">,</span>
            <span class="s1">verticalalignment=</span><span class="s4">'baseline'</span><span class="s0">,</span>
            <span class="s1">horizontalalignment=</span><span class="s4">'left'</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s1">self._right_title = mtext.Text(</span>
            <span class="s1">x=</span><span class="s5">1.0</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">text=</span><span class="s4">''</span><span class="s0">,</span>
            <span class="s1">fontproperties=props.copy()</span><span class="s0">,</span>
            <span class="s1">verticalalignment=</span><span class="s4">'baseline'</span><span class="s0">,</span>
            <span class="s1">horizontalalignment=</span><span class="s4">'right'</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">title_offset_points = mpl.rcParams[</span><span class="s4">'axes.titlepad'</span><span class="s1">]</span>
        <span class="s3"># refactor this out so it can be called in ax.set_title if</span>
        <span class="s3"># pad argument used...</span>
        <span class="s1">self._set_title_offset_trans(title_offset_points)</span>

        <span class="s0">for </span><span class="s1">_title </span><span class="s0">in </span><span class="s1">(self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title):</span>
            <span class="s1">self._set_artist_props(_title)</span>

        <span class="s3"># The patch draws the background of the Axes.  We want this to be below</span>
        <span class="s3"># the other artists.  We use the frame to draw the edges so we are</span>
        <span class="s3"># setting the edgecolor to None.</span>
        <span class="s1">self.patch = self._gen_axes_patch()</span>
        <span class="s1">self.patch.set_figure(self.figure)</span>
        <span class="s1">self.patch.set_facecolor(self._facecolor)</span>
        <span class="s1">self.patch.set_edgecolor(</span><span class="s4">'none'</span><span class="s1">)</span>
        <span class="s1">self.patch.set_linewidth(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">self.patch.set_transform(self.transAxes)</span>

        <span class="s1">self.set_axis_on()</span>

        <span class="s1">self.xaxis.set_clip_path(self.patch)</span>
        <span class="s1">self.yaxis.set_clip_path(self.patch)</span>

        <span class="s1">self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">].clean()</span>
        <span class="s1">self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">].clean()</span>
        <span class="s0">if </span><span class="s1">self._sharex </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.xaxis.set_visible(xaxis_visible)</span>
            <span class="s1">self.patch.set_visible(patch_visible)</span>
        <span class="s0">if </span><span class="s1">self._sharey </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.yaxis.set_visible(yaxis_visible)</span>
            <span class="s1">self.patch.set_visible(patch_visible)</span>

        <span class="s3"># This comes last, as the call to _set_lim may trigger an autoscale (in</span>
        <span class="s3"># case of shared axes), requiring children to be already set up.</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.items():</span>
            <span class="s1">share = getattr(self</span><span class="s0">, </span><span class="s4">f&quot;_share</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">share </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">getattr(self</span><span class="s0">, </span><span class="s4">f&quot;share</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)(share)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">axis._set_scale(</span><span class="s4">&quot;linear&quot;</span><span class="s1">)</span>
                <span class="s1">axis._set_lim(</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self._update_transScale()</span>

        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s2">&quot;&quot;&quot;Clear the Axes.&quot;&quot;&quot;</span>
        <span class="s3"># Act as an alias, or as the superclass implementation depending on the</span>
        <span class="s3"># subclass implementation.</span>
        <span class="s0">if </span><span class="s1">self._subclass_uses_cla:</span>
            <span class="s1">self.cla()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.__clear()</span>

    <span class="s0">def </span><span class="s1">cla(self):</span>
        <span class="s2">&quot;&quot;&quot;Clear the Axes.&quot;&quot;&quot;</span>
        <span class="s3"># Act as an alias, or as the superclass implementation depending on the</span>
        <span class="s3"># subclass implementation.</span>
        <span class="s0">if </span><span class="s1">self._subclass_uses_cla:</span>
            <span class="s1">self.__clear()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.clear()</span>

    <span class="s0">class </span><span class="s1">ArtistList(Sequence):</span>
        <span class="s2">&quot;&quot;&quot; 
        A sublist of Axes children based on their type. 
 
        The type-specific children sublists were made immutable in Matplotlib 
        3.7.  In the future these artist lists may be replaced by tuples. Use 
        as if this is a tuple already. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">prop_name</span><span class="s0">,</span>
                     <span class="s1">valid_types=</span><span class="s0">None, </span><span class="s1">invalid_types=</span><span class="s0">None</span><span class="s1">):</span>
            <span class="s2">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            axes : `~matplotlib.axes.Axes` 
                The Axes from which this sublist will pull the children 
                Artists. 
            prop_name : str 
                The property name used to access this sublist from the Axes; 
                used to generate deprecation warnings. 
            valid_types : list of type, optional 
                A list of types that determine which children will be returned 
                by this sublist. If specified, then the Artists in the sublist 
                must be instances of any of these types. If unspecified, then 
                any type of Artist is valid (unless limited by 
                *invalid_types*.) 
            invalid_types : tuple, optional 
                A list of types that determine which children will *not* be 
                returned by this sublist. If specified, then Artists in the 
                sublist will never be an instance of these types. Otherwise, no 
                types will be excluded. 
            &quot;&quot;&quot;</span>
            <span class="s1">self._axes = axes</span>
            <span class="s1">self._prop_name = prop_name</span>
            <span class="s1">self._type_check = </span><span class="s0">lambda </span><span class="s1">artist: (</span>
                <span class="s1">(</span><span class="s0">not </span><span class="s1">valid_types </span><span class="s0">or </span><span class="s1">isinstance(artist</span><span class="s0">, </span><span class="s1">valid_types)) </span><span class="s0">and</span>
                <span class="s1">(</span><span class="s0">not </span><span class="s1">invalid_types </span><span class="s0">or not </span><span class="s1">isinstance(artist</span><span class="s0">, </span><span class="s1">invalid_types))</span>
            <span class="s1">)</span>

        <span class="s0">def </span><span class="s1">__repr__(self):</span>
            <span class="s0">return </span><span class="s4">f'&lt;Axes.ArtistList of </span><span class="s0">{</span><span class="s1">len(self)</span><span class="s0">} {</span><span class="s1">self._prop_name</span><span class="s0">}</span><span class="s4">&gt;'</span>

        <span class="s0">def </span><span class="s1">__len__(self):</span>
            <span class="s0">return </span><span class="s1">sum(self._type_check(artist)</span>
                       <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">self._axes._children)</span>

        <span class="s0">def </span><span class="s1">__iter__(self):</span>
            <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">list(self._axes._children):</span>
                <span class="s0">if </span><span class="s1">self._type_check(artist):</span>
                    <span class="s0">yield </span><span class="s1">artist</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key):</span>
            <span class="s0">return </span><span class="s1">[artist</span>
                    <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">self._axes._children</span>
                    <span class="s0">if </span><span class="s1">self._type_check(artist)][key]</span>

        <span class="s0">def </span><span class="s1">__add__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">_AxesBase.ArtistList)):</span>
                <span class="s0">return </span><span class="s1">[*self</span><span class="s0">, </span><span class="s1">*other]</span>
            <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">_AxesBase.ArtistList)):</span>
                <span class="s0">return </span><span class="s1">(*self</span><span class="s0">, </span><span class="s1">*other)</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s0">def </span><span class="s1">__radd__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">return </span><span class="s1">other + list(self)</span>
            <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s0">return </span><span class="s1">other + tuple(self)</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">artists(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'artists'</span><span class="s0">, </span><span class="s1">invalid_types=(</span>
            <span class="s1">mcoll.Collection</span><span class="s0">, </span><span class="s1">mimage.AxesImage</span><span class="s0">, </span><span class="s1">mlines.Line2D</span><span class="s0">, </span><span class="s1">mpatches.Patch</span><span class="s0">,</span>
            <span class="s1">mtable.Table</span><span class="s0">, </span><span class="s1">mtext.Text))</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">collections(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'collections'</span><span class="s0">,</span>
                               <span class="s1">valid_types=mcoll.Collection)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">images(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'images'</span><span class="s0">, </span><span class="s1">valid_types=mimage.AxesImage)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">lines(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'lines'</span><span class="s0">, </span><span class="s1">valid_types=mlines.Line2D)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">patches(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'patches'</span><span class="s0">, </span><span class="s1">valid_types=mpatches.Patch)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">tables(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'tables'</span><span class="s0">, </span><span class="s1">valid_types=mtable.Table)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">texts(self):</span>
        <span class="s0">return </span><span class="s1">self.ArtistList(self</span><span class="s0">, </span><span class="s4">'texts'</span><span class="s0">, </span><span class="s1">valid_types=mtext.Text)</span>

    <span class="s0">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s2">&quot;&quot;&quot;Get the facecolor of the Axes.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.patch.get_facecolor()</span>

    <span class="s0">def </span><span class="s1">set_facecolor(self</span><span class="s0">, </span><span class="s1">color):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the facecolor of the Axes. 
 
        Parameters 
        ---------- 
        color : color 
        &quot;&quot;&quot;</span>
        <span class="s1">self._facecolor = color</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">self.patch.set_facecolor(color)</span>

    <span class="s0">def </span><span class="s1">_set_title_offset_trans(self</span><span class="s0">, </span><span class="s1">title_offset_points):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the offset for the title either from :rc:`axes.titlepad` 
        or from set_title kwarg ``pad``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.titleOffsetTrans = mtransforms.ScaledTranslation(</span>
                <span class="s5">0.0</span><span class="s0">, </span><span class="s1">title_offset_points / </span><span class="s5">72</span><span class="s0">,</span>
                <span class="s1">self.figure.dpi_scale_trans)</span>
        <span class="s0">for </span><span class="s1">_title </span><span class="s0">in </span><span class="s1">(self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title):</span>
            <span class="s1">_title.set_transform(self.transAxes + self.titleOffsetTrans)</span>
            <span class="s1">_title.set_clip_box(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_prop_cycle(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the property cycle of the Axes. 
 
        The property cycle controls the style properties such as color, 
        marker and linestyle of future plot commands. The style properties 
        of data already added to the Axes are not modified. 
 
        Call signatures:: 
 
          set_prop_cycle(cycler) 
          set_prop_cycle(label=values[, label2=values2[, ...]]) 
          set_prop_cycle(label, values) 
 
        Form 1 sets given `~cycler.Cycler` object. 
 
        Form 2 creates a `~cycler.Cycler` which cycles over one or more 
        properties simultaneously and set it as the property cycle of the 
        Axes. If multiple properties are given, their value lists must have 
        the same length. This is just a shortcut for explicitly creating a 
        cycler and passing it to the function, i.e. it's short for 
        ``set_prop_cycle(cycler(label=values label2=values2, ...))``. 
 
        Form 3 creates a `~cycler.Cycler` for a single property and set it 
        as the property cycle of the Axes. This form exists for compatibility 
        with the original `cycler.cycler` interface. Its use is discouraged 
        in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``. 
 
        Parameters 
        ---------- 
        cycler : Cycler 
            Set the given Cycler. *None* resets to the cycle defined by the 
            current style. 
 
        label : str 
            The property key. Must be a valid `.Artist` property. 
            For example, 'color' or 'linestyle'. Aliases are allowed, 
            such as 'c' for 'color' and 'lw' for 'linewidth'. 
 
        values : iterable 
            Finite-length iterable of the property values. These values 
            are validated and will raise a ValueError if invalid. 
 
        See Also 
        -------- 
        matplotlib.rcsetup.cycler 
            Convenience function for creating validated cyclers for properties. 
        cycler.cycler 
            The original function for creating unvalidated cyclers. 
 
        Examples 
        -------- 
        Setting the property cycle for a single property: 
 
        &gt;&gt;&gt; ax.set_prop_cycle(color=['red', 'green', 'blue']) 
 
        Setting the property cycle for simultaneously cycling over multiple 
        properties (e.g. red circle, green plus, blue cross): 
 
        &gt;&gt;&gt; ax.set_prop_cycle(color=['red', 'green', 'blue'], 
        ...                   marker=['o', '+', 'x']) 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">args </span><span class="s0">and </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot supply both positional and keyword &quot;</span>
                            <span class="s4">&quot;arguments to this method.&quot;</span><span class="s1">)</span>
        <span class="s3"># Can't do `args == (None,)` as that crashes cycler.</span>
        <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">args[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">prop_cycle = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">prop_cycle = cycler(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._get_lines.set_prop_cycle(prop_cycle)</span>
        <span class="s1">self._get_patches_for_fill.set_prop_cycle(prop_cycle)</span>

    <span class="s0">def </span><span class="s1">get_aspect(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the aspect ratio of the axes scaling. 
 
        This is either &quot;auto&quot; or a float giving the ratio of y/x-scale. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._aspect</span>

    <span class="s0">def </span><span class="s1">set_aspect(self</span><span class="s0">, </span><span class="s1">aspect</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s0">None, </span><span class="s1">anchor=</span><span class="s0">None, </span><span class="s1">share=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the aspect ratio of the axes scaling, i.e. y/x-scale. 
 
        Parameters 
        ---------- 
        aspect : {'auto', 'equal'} or float 
            Possible values: 
 
            - 'auto': fill the position rectangle with data. 
            - 'equal': same as ``aspect=1``, i.e. same scaling for x and y. 
            - *float*: The displayed size of 1 unit in y-data coordinates will 
              be *aspect* times the displayed size of 1 unit in x-data 
              coordinates; e.g. for ``aspect=2`` a square in data coordinates 
              will be rendered with a height of twice its width. 
 
        adjustable : None or {'box', 'datalim'}, optional 
            If not ``None``, this defines which parameter will be adjusted to 
            meet the required aspect. See `.set_adjustable` for further 
            details. 
 
        anchor : None or str or (float, float), optional 
            If not ``None``, this defines where the Axes will be drawn if there 
            is extra space due to aspect constraints. The most common way 
            to specify the anchor are abbreviations of cardinal directions: 
 
            =====   ===================== 
            value   description 
            =====   ===================== 
            'C'     centered 
            'SW'    lower left corner 
            'S'     middle of bottom edge 
            'SE'    lower right corner 
            etc. 
            =====   ===================== 
 
            See `~.Axes.set_anchor` for further details. 
 
        share : bool, default: False 
            If ``True``, apply the settings to all shared Axes. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_adjustable 
            Set how the Axes adjusts to achieve the required aspect ratio. 
        matplotlib.axes.Axes.set_anchor 
            Set the position in case of extra space. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cbook._str_equal(aspect</span><span class="s0">, </span><span class="s4">'equal'</span><span class="s1">):</span>
            <span class="s1">aspect = </span><span class="s5">1</span>
        <span class="s0">if not </span><span class="s1">cbook._str_equal(aspect</span><span class="s0">, </span><span class="s4">'auto'</span><span class="s1">):</span>
            <span class="s1">aspect = float(aspect)  </span><span class="s3"># raise ValueError if necessary</span>
            <span class="s0">if </span><span class="s1">aspect &lt;= </span><span class="s5">0 </span><span class="s0">or not </span><span class="s1">np.isfinite(aspect):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;aspect must be finite and positive &quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">share:</span>
            <span class="s1">axes = {sibling </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names</span>
                    <span class="s0">for </span><span class="s1">sibling </span><span class="s0">in </span><span class="s1">self._shared_axes[name].get_siblings(self)}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = [self]</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes:</span>
            <span class="s1">ax._aspect = aspect</span>

        <span class="s0">if </span><span class="s1">adjustable </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">adjustable = self._adjustable</span>
        <span class="s1">self.set_adjustable(adjustable</span><span class="s0">, </span><span class="s1">share=share)  </span><span class="s3"># Handle sharing.</span>

        <span class="s0">if </span><span class="s1">anchor </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_anchor(anchor</span><span class="s0">, </span><span class="s1">share=share)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_adjustable(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether the Axes will adjust its physical dimension ('box') or 
        its data limits ('datalim') to achieve the desired aspect ratio. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_adjustable 
            Set how the Axes adjusts to achieve the required aspect ratio. 
        matplotlib.axes.Axes.set_aspect 
            For a description of aspect handling. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._adjustable</span>

    <span class="s0">def </span><span class="s1">set_adjustable(self</span><span class="s0">, </span><span class="s1">adjustable</span><span class="s0">, </span><span class="s1">share=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set how the Axes adjusts to achieve the required aspect ratio. 
 
        Parameters 
        ---------- 
        adjustable : {'box', 'datalim'} 
            If 'box', change the physical dimensions of the Axes. 
            If 'datalim', change the ``x`` or ``y`` data limits. 
 
        share : bool, default: False 
            If ``True``, apply the settings to all shared Axes. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_aspect 
            For a description of aspect handling. 
 
        Notes 
        ----- 
        Shared Axes (of which twinned Axes are a special case) 
        impose restrictions on how aspect ratios can be imposed. 
        For twinned Axes, use 'datalim'.  For Axes that share both 
        x and y, use 'box'.  Otherwise, either 'datalim' or 'box' 
        may be used.  These limitations are partly a requirement 
        to avoid over-specification, and partly a result of the 
        particular implementation we are currently using, in 
        which the adjustments for aspect ratios are done sequentially 
        and independently on each Axes as it is drawn. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">&quot;box&quot;</span><span class="s0">, </span><span class="s4">&quot;datalim&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">adjustable=adjustable)</span>
        <span class="s0">if </span><span class="s1">share:</span>
            <span class="s1">axs = {sibling </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names</span>
                   <span class="s0">for </span><span class="s1">sibling </span><span class="s0">in </span><span class="s1">self._shared_axes[name].get_siblings(self)}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axs = [self]</span>
        <span class="s0">if </span><span class="s1">(adjustable == </span><span class="s4">&quot;datalim&quot;</span>
                <span class="s0">and </span><span class="s1">any(getattr(ax.get_data_ratio</span><span class="s0">, </span><span class="s4">&quot;__func__&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                        <span class="s1">!= _AxesBase.get_data_ratio</span>
                        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axs)):</span>
            <span class="s3"># Limits adjustment by apply_aspect assumes that the axes' aspect</span>
            <span class="s3"># ratio can be computed from the data limits and scales.</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Cannot set Axes adjustable to 'datalim' for &quot;</span>
                             <span class="s4">&quot;Axes which override 'get_data_ratio'&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axs:</span>
            <span class="s1">ax._adjustable = adjustable</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_box_aspect(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the Axes box aspect, i.e. the ratio of height to width. 
 
        The box aspect is ``None`` (i.e. chosen depending on the available 
        figure space) unless explicitly specified. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_box_aspect 
            for a description of box aspect. 
        matplotlib.axes.Axes.set_aspect 
            for a description of aspect handling. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._box_aspect</span>

    <span class="s0">def </span><span class="s1">set_box_aspect(self</span><span class="s0">, </span><span class="s1">aspect=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the Axes box aspect, i.e. the ratio of height to width. 
 
        This defines the aspect of the Axes in figure space and is not to be 
        confused with the data aspect (see `~.Axes.set_aspect`). 
 
        Parameters 
        ---------- 
        aspect : float or None 
            Changes the physical dimensions of the Axes, such that the ratio 
            of the Axes height to the Axes width in physical units is equal to 
            *aspect*. Defining a box aspect will change the *adjustable* 
            property to 'datalim' (see `~.Axes.set_adjustable`). 
 
            *None* will disable a fixed box aspect so that height and width 
            of the Axes are chosen independently. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_aspect 
            for a description of aspect handling. 
        &quot;&quot;&quot;</span>
        <span class="s1">axs = {*self._twinned_axes.get_siblings(self)</span><span class="s0">,</span>
               <span class="s1">*self._twinned_axes.get_siblings(self)}</span>

        <span class="s0">if </span><span class="s1">aspect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">aspect = float(aspect)</span>
            <span class="s3"># when box_aspect is set to other than None`,</span>
            <span class="s3"># adjustable must be &quot;datalim&quot;</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axs:</span>
                <span class="s1">ax.set_adjustable(</span><span class="s4">&quot;datalim&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axs:</span>
            <span class="s1">ax._box_aspect = aspect</span>
            <span class="s1">ax.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_anchor(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the anchor location. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_anchor 
            for a description of the anchor. 
        matplotlib.axes.Axes.set_aspect 
            for a description of aspect handling. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._anchor</span>

    <span class="s0">def </span><span class="s1">set_anchor(self</span><span class="s0">, </span><span class="s1">anchor</span><span class="s0">, </span><span class="s1">share=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Define the anchor location. 
 
        The actual drawing area (active position) of the Axes may be smaller 
        than the Bbox (original position) when a fixed aspect is required. The 
        anchor defines where the drawing area will be located within the 
        available space. 
 
        Parameters 
        ---------- 
        anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...} 
            Either an (*x*, *y*) pair of relative coordinates (0 is left or 
            bottom, 1 is right or top), 'C' (center), or a cardinal direction 
            ('SW', southwest, is bottom left, etc.).  str inputs are shorthands 
            for (*x*, *y*) coordinates, as shown in the following diagram:: 
 
                
                'NW' (0.0, 1.0)  'N' (0.5, 1.0)   'NE' (1.0, 1.0)  
                
                'W'  (0.0, 0.5)  'C' (0.5, 0.5)   'E'  (1.0, 0.5)  
                
                'SW' (0.0, 0.0)  'S' (0.5, 0.0)   'SE' (1.0, 0.0)  
                
 
        share : bool, default: False 
            If ``True``, apply the settings to all shared Axes. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_aspect 
            for a description of aspect handling. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">(anchor </span><span class="s0">in </span><span class="s1">mtransforms.Bbox.coefs </span><span class="s0">or </span><span class="s1">len(anchor) == </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">'argument must be among %s' </span><span class="s1">%</span>
                             <span class="s4">', '</span><span class="s1">.join(mtransforms.Bbox.coefs))</span>
        <span class="s0">if </span><span class="s1">share:</span>
            <span class="s1">axes = {sibling </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names</span>
                    <span class="s0">for </span><span class="s1">sibling </span><span class="s0">in </span><span class="s1">self._shared_axes[name].get_siblings(self)}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">axes = [self]</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axes:</span>
            <span class="s1">ax._anchor = anchor</span>

        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_data_ratio(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the aspect ratio of the scaled data. 
 
        Notes 
        ----- 
        This method is intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s1">txmin</span><span class="s0">, </span><span class="s1">txmax = self.xaxis.get_transform().transform(self.get_xbound())</span>
        <span class="s1">tymin</span><span class="s0">, </span><span class="s1">tymax = self.yaxis.get_transform().transform(self.get_ybound())</span>
        <span class="s1">xsize = max(abs(txmax - txmin)</span><span class="s0">, </span><span class="s5">1e-30</span><span class="s1">)</span>
        <span class="s1">ysize = max(abs(tymax - tymin)</span><span class="s0">, </span><span class="s5">1e-30</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">ysize / xsize</span>

    <span class="s0">def </span><span class="s1">apply_aspect(self</span><span class="s0">, </span><span class="s1">position=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Adjust the Axes for a specified data aspect ratio. 
 
        Depending on `.get_adjustable` this will modify either the 
        Axes box (position) or the view limits. In the former case, 
        `~matplotlib.axes.Axes.get_anchor` will affect the position. 
 
        Parameters 
        ---------- 
        position : None or .Bbox 
            If not ``None``, this defines the position of the 
            Axes within the figure as a Bbox. See `~.Axes.get_position` 
            for further details. 
 
        Notes 
        ----- 
        This is called automatically when each Axes is drawn.  You may need 
        to call it yourself if you need to update the Axes position and/or 
        view limits before the Figure is drawn. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_aspect 
            For a description of aspect ratio handling. 
        matplotlib.axes.Axes.set_adjustable 
            Set how the Axes adjusts to achieve the required aspect ratio. 
        matplotlib.axes.Axes.set_anchor 
            Set the position in case of extra space. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">position </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">position = self.get_position(original=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">aspect = self.get_aspect()</span>

        <span class="s0">if </span><span class="s1">aspect == </span><span class="s4">'auto' </span><span class="s0">and </span><span class="s1">self._box_aspect </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._set_position(position</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'active'</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s1">trans = self.get_figure().transSubfigure</span>
        <span class="s1">bb = mtransforms.Bbox.unit().transformed(trans)</span>
        <span class="s3"># this is the physical aspect of the panel (or figure):</span>
        <span class="s1">fig_aspect = bb.height / bb.width</span>

        <span class="s0">if </span><span class="s1">self._adjustable == </span><span class="s4">'box'</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">in </span><span class="s1">self._twinned_axes:</span>
                <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Adjustable 'box' is not allowed in a &quot;</span>
                                   <span class="s4">&quot;twinned Axes; use 'datalim' instead&quot;</span><span class="s1">)</span>
            <span class="s1">box_aspect = aspect * self.get_data_ratio()</span>
            <span class="s1">pb = position.frozen()</span>
            <span class="s1">pb1 = pb.shrunk_to_aspect(box_aspect</span><span class="s0">, </span><span class="s1">pb</span><span class="s0">, </span><span class="s1">fig_aspect)</span>
            <span class="s1">self._set_position(pb1.anchored(self.get_anchor()</span><span class="s0">, </span><span class="s1">pb)</span><span class="s0">, </span><span class="s4">'active'</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s3"># The following is only seen if self._adjustable == 'datalim'</span>
        <span class="s0">if </span><span class="s1">self._box_aspect </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">pb = position.frozen()</span>
            <span class="s1">pb1 = pb.shrunk_to_aspect(self._box_aspect</span><span class="s0">, </span><span class="s1">pb</span><span class="s0">, </span><span class="s1">fig_aspect)</span>
            <span class="s1">self._set_position(pb1.anchored(self.get_anchor()</span><span class="s0">, </span><span class="s1">pb)</span><span class="s0">, </span><span class="s4">'active'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">aspect == </span><span class="s4">&quot;auto&quot;</span><span class="s1">:</span>
                <span class="s0">return</span>

        <span class="s3"># reset active to original in case it had been changed by prior use</span>
        <span class="s3"># of 'box'</span>
        <span class="s0">if </span><span class="s1">self._box_aspect </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._set_position(position</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'active'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">position = pb1.anchored(self.get_anchor()</span><span class="s0">, </span><span class="s1">pb)</span>

        <span class="s1">x_trf = self.xaxis.get_transform()</span>
        <span class="s1">y_trf = self.yaxis.get_transform()</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = x_trf.transform(self.get_xbound())</span>
        <span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = y_trf.transform(self.get_ybound())</span>
        <span class="s1">xsize = max(abs(xmax - xmin)</span><span class="s0">, </span><span class="s5">1e-30</span><span class="s1">)</span>
        <span class="s1">ysize = max(abs(ymax - ymin)</span><span class="s0">, </span><span class="s5">1e-30</span><span class="s1">)</span>

        <span class="s1">box_aspect = fig_aspect * (position.height / position.width)</span>
        <span class="s1">data_ratio = box_aspect / aspect</span>

        <span class="s1">y_expander = data_ratio * xsize / ysize - </span><span class="s5">1</span>
        <span class="s3"># If y_expander &gt; 0, the dy/dx viewLim ratio needs to increase</span>
        <span class="s0">if </span><span class="s1">abs(y_expander) &lt; </span><span class="s5">0.005</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">dL = self.dataLim</span>
        <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = x_trf.transform(dL.intervalx)</span>
        <span class="s1">y0</span><span class="s0">, </span><span class="s1">y1 = y_trf.transform(dL.intervaly)</span>
        <span class="s1">xr = </span><span class="s5">1.05 </span><span class="s1">* (x1 - x0)</span>
        <span class="s1">yr = </span><span class="s5">1.05 </span><span class="s1">* (y1 - y0)</span>

        <span class="s1">xmarg = xsize - xr</span>
        <span class="s1">ymarg = ysize - yr</span>
        <span class="s1">Ysize = data_ratio * xsize</span>
        <span class="s1">Xsize = ysize / data_ratio</span>
        <span class="s1">Xmarg = Xsize - xr</span>
        <span class="s1">Ymarg = Ysize - yr</span>
        <span class="s3"># Setting these targets to, e.g., 0.05*xr does not seem to help.</span>
        <span class="s1">xm = </span><span class="s5">0</span>
        <span class="s1">ym = </span><span class="s5">0</span>

        <span class="s1">shared_x = self </span><span class="s0">in </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s1">shared_y = self </span><span class="s0">in </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">shared_x </span><span class="s0">and </span><span class="s1">shared_y:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;set_aspect(..., adjustable='datalim') or &quot;</span>
                               <span class="s4">&quot;axis('equal') are not allowed when both axes &quot;</span>
                               <span class="s4">&quot;are shared.  Try set_aspect(..., &quot;</span>
                               <span class="s4">&quot;adjustable='box').&quot;</span><span class="s1">)</span>

        <span class="s3"># If y is shared, then we are only allowed to change x, etc.</span>
        <span class="s0">if </span><span class="s1">shared_y:</span>
            <span class="s1">adjust_y = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">xmarg &gt; xm </span><span class="s0">and </span><span class="s1">ymarg &gt; ym:</span>
                <span class="s1">adjy = ((Ymarg &gt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">y_expander &lt; </span><span class="s5">0</span><span class="s1">) </span><span class="s0">or</span>
                        <span class="s1">(Xmarg &lt; </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">y_expander &gt; </span><span class="s5">0</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">adjy = y_expander &gt; </span><span class="s5">0</span>
            <span class="s1">adjust_y = shared_x </span><span class="s0">or </span><span class="s1">adjy  </span><span class="s3"># (Ymarg &gt; xmarg)</span>

        <span class="s0">if </span><span class="s1">adjust_y:</span>
            <span class="s1">yc = </span><span class="s5">0.5 </span><span class="s1">* (ymin + ymax)</span>
            <span class="s1">y0 = yc - Ysize / </span><span class="s5">2.0</span>
            <span class="s1">y1 = yc + Ysize / </span><span class="s5">2.0</span>
            <span class="s1">self.set_ybound(y_trf.inverted().transform([y0</span><span class="s0">, </span><span class="s1">y1]))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">xc = </span><span class="s5">0.5 </span><span class="s1">* (xmin + xmax)</span>
            <span class="s1">x0 = xc - Xsize / </span><span class="s5">2.0</span>
            <span class="s1">x1 = xc + Xsize / </span><span class="s5">2.0</span>
            <span class="s1">self.set_xbound(x_trf.inverted().transform([x0</span><span class="s0">, </span><span class="s1">x1]))</span>

    <span class="s0">def </span><span class="s1">axis(self</span><span class="s0">, </span><span class="s1">arg=</span><span class="s0">None, </span><span class="s1">/</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">emit=</span><span class="s0">True, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Convenience method to get or set some axis properties. 
 
        Call signatures:: 
 
          xmin, xmax, ymin, ymax = axis() 
          xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax]) 
          xmin, xmax, ymin, ymax = axis(option) 
          xmin, xmax, ymin, ymax = axis(**kwargs) 
 
        Parameters 
        ---------- 
        xmin, xmax, ymin, ymax : float, optional 
            The axis limits to be set.  This can also be achieved using :: 
 
                ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax)) 
 
        option : bool or str 
            If a bool, turns axis lines and labels on or off. If a string, 
            possible values are: 
 
            ======== ========================================================== 
            Value    Description 
            ======== ========================================================== 
            'on'     Turn on axis lines and labels. Same as ``True``. 
            'off'    Turn off axis lines and labels. Same as ``False``. 
            'equal'  Set equal scaling (i.e., make circles circular) by 
                     changing axis limits. This is the same as 
                     ``ax.set_aspect('equal', adjustable='datalim')``. 
                     Explicit data limits may not be respected in this case. 
            'scaled' Set equal scaling (i.e., make circles circular) by 
                     changing dimensions of the plot box. This is the same as 
                     ``ax.set_aspect('equal', adjustable='box', anchor='C')``. 
                     Additionally, further autoscaling will be disabled. 
            'tight'  Set limits just large enough to show all data, then 
                     disable further autoscaling. 
            'auto'   Automatic scaling (fill plot box with data). 
            'image'  'scaled' with axis limits equal to data limits. 
            'square' Square plot; similar to 'scaled', but initially forcing 
                     ``xmax-xmin == ymax-ymin``. 
            ======== ========================================================== 
 
        emit : bool, default: True 
            Whether observers are notified of the axis limit change. 
            This option is passed on to `~.Axes.set_xlim` and 
            `~.Axes.set_ylim`. 
 
        Returns 
        ------- 
        xmin, xmax, ymin, ymax : float 
            The axis limits. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.set_xlim 
        matplotlib.axes.Axes.set_ylim 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">(str</span><span class="s0">, </span><span class="s1">bool)):</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is True</span><span class="s1">:</span>
                <span class="s1">arg = </span><span class="s4">'on'</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is False</span><span class="s1">:</span>
                <span class="s1">arg = </span><span class="s4">'off'</span>
            <span class="s1">arg = arg.lower()</span>
            <span class="s0">if </span><span class="s1">arg == </span><span class="s4">'on'</span><span class="s1">:</span>
                <span class="s1">self.set_axis_on()</span>
            <span class="s0">elif </span><span class="s1">arg == </span><span class="s4">'off'</span><span class="s1">:</span>
                <span class="s1">self.set_axis_off()</span>
            <span class="s0">elif </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">[</span>
                    <span class="s4">'equal'</span><span class="s0">, </span><span class="s4">'tight'</span><span class="s0">, </span><span class="s4">'scaled'</span><span class="s0">, </span><span class="s4">'auto'</span><span class="s0">, </span><span class="s4">'image'</span><span class="s0">, </span><span class="s4">'square'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscale_on(</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">self.set_aspect(</span><span class="s4">'auto'</span><span class="s1">)</span>
                <span class="s1">self.autoscale_view(tight=</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">arg == </span><span class="s4">'equal'</span><span class="s1">:</span>
                    <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'datalim'</span><span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">arg == </span><span class="s4">'scaled'</span><span class="s1">:</span>
                    <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
                    <span class="s1">self.set_autoscale_on(</span><span class="s0">False</span><span class="s1">)  </span><span class="s3"># Req. by Mark Bakker</span>
                <span class="s0">elif </span><span class="s1">arg == </span><span class="s4">'tight'</span><span class="s1">:</span>
                    <span class="s1">self.autoscale_view(tight=</span><span class="s0">True</span><span class="s1">)</span>
                    <span class="s1">self.set_autoscale_on(</span><span class="s0">False</span><span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">arg == </span><span class="s4">'image'</span><span class="s1">:</span>
                    <span class="s1">self.autoscale_view(tight=</span><span class="s0">True</span><span class="s1">)</span>
                    <span class="s1">self.set_autoscale_on(</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
                <span class="s0">elif </span><span class="s1">arg == </span><span class="s4">'square'</span><span class="s1">:</span>
                    <span class="s1">self.set_aspect(</span><span class="s4">'equal'</span><span class="s0">, </span><span class="s1">adjustable=</span><span class="s4">'box'</span><span class="s0">, </span><span class="s1">anchor=</span><span class="s4">'C'</span><span class="s1">)</span>
                    <span class="s1">self.set_autoscale_on(</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">xlim = self.get_xlim()</span>
                    <span class="s1">ylim = self.get_ylim()</span>
                    <span class="s1">edge_size = max(np.diff(xlim)</span><span class="s0">, </span><span class="s1">np.diff(ylim))[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">self.set_xlim([xlim[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xlim[</span><span class="s5">0</span><span class="s1">] + edge_size]</span><span class="s0">,</span>
                                  <span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">self.set_ylim([ylim[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ylim[</span><span class="s5">0</span><span class="s1">] + edge_size]</span><span class="s0">,</span>
                                  <span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unrecognized string </span><span class="s0">{</span><span class="s1">arg</span><span class="s0">!r} </span><span class="s4">to axis; &quot;</span>
                                 <span class="s4">&quot;try 'on' or 'off'&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">arg </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = arg</span>
                <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">ValueError) </span><span class="s0">as </span><span class="s1">err:</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'the first argument to axis() must be an '</span>
                                    <span class="s4">'iterable of the form '</span>
                                    <span class="s4">'[xmin, xmax, ymin, ymax]'</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">xmin = kwargs.pop(</span><span class="s4">'xmin'</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">xmax = kwargs.pop(</span><span class="s4">'xmax'</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">ymin = kwargs.pop(</span><span class="s4">'ymin'</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">ymax = kwargs.pop(</span><span class="s4">'ymax'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">xauto = (</span><span class="s0">None  </span><span class="s3"># Keep autoscale state as is.</span>
                     <span class="s0">if </span><span class="s1">xmin </span><span class="s0">is None and </span><span class="s1">xmax </span><span class="s0">is None</span>
                     <span class="s0">else False</span><span class="s1">)  </span><span class="s3"># Turn off autoscale.</span>
            <span class="s1">yauto = (</span><span class="s0">None</span>
                     <span class="s0">if </span><span class="s1">ymin </span><span class="s0">is None and </span><span class="s1">ymax </span><span class="s0">is None</span>
                     <span class="s0">else False</span><span class="s1">)</span>
            <span class="s1">self.set_xlim(xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=xauto)</span>
            <span class="s1">self.set_ylim(ymin</span><span class="s0">, </span><span class="s1">ymax</span><span class="s0">, </span><span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=yauto)</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s0">raise </span><span class="s1">_api.kwarg_error(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">return </span><span class="s1">(*self.get_xlim()</span><span class="s0">, </span><span class="s1">*self.get_ylim())</span>

    <span class="s0">def </span><span class="s1">get_legend(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the `.Legend` instance, or None if no legend is defined.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.legend_</span>

    <span class="s0">def </span><span class="s1">get_images(self):</span>
        <span class="s2">r&quot;&quot;&quot;Return a list of `.AxesImage`\s contained by the Axes.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cbook.silent_list(</span><span class="s4">'AxesImage'</span><span class="s0">, </span><span class="s1">self.images)</span>

    <span class="s0">def </span><span class="s1">get_lines(self):</span>
        <span class="s2">&quot;&quot;&quot;Return a list of lines contained by the Axes.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cbook.silent_list(</span><span class="s4">'Line2D'</span><span class="s0">, </span><span class="s1">self.lines)</span>

    <span class="s0">def </span><span class="s1">get_xaxis(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        [*Discouraged*] Return the XAxis instance. 
 
        .. admonition:: Discouraged 
 
            The use of this function is discouraged. You should instead 
            directly access the attribute ``ax.xaxis``. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.xaxis</span>

    <span class="s0">def </span><span class="s1">get_yaxis(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        [*Discouraged*] Return the YAxis instance. 
 
        .. admonition:: Discouraged 
 
            The use of this function is discouraged. You should instead 
            directly access the attribute ``ax.yaxis``. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.yaxis</span>

    <span class="s1">get_xgridlines = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_gridlines&quot;</span><span class="s1">)</span>
    <span class="s1">get_xticklines = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklines&quot;</span><span class="s1">)</span>
    <span class="s1">get_ygridlines = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_gridlines&quot;</span><span class="s1">)</span>
    <span class="s1">get_yticklines = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklines&quot;</span><span class="s1">)</span>

    <span class="s3"># Adding and tracking artists</span>

    <span class="s0">def </span><span class="s1">_sci(self</span><span class="s0">, </span><span class="s1">im):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the current image. 
 
        This image will be the target of colormap functions like 
        ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The 
        current image is an attribute of the current Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(</span>
            <span class="s1">(mpl.contour.ContourSet</span><span class="s0">, </span><span class="s1">mcoll.Collection</span><span class="s0">, </span><span class="s1">mimage.AxesImage)</span><span class="s0">,</span>
            <span class="s1">im=im)</span>
        <span class="s0">if </span><span class="s1">isinstance(im</span><span class="s0">, </span><span class="s1">mpl.contour.ContourSet):</span>
            <span class="s0">if </span><span class="s1">im.collections[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">self._children:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ContourSet must be in current Axes&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">im </span><span class="s0">not in </span><span class="s1">self._children:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Argument must be an image, collection, or &quot;</span>
                             <span class="s4">&quot;ContourSet in this Axes&quot;</span><span class="s1">)</span>
        <span class="s1">self._current_image = im</span>

    <span class="s0">def </span><span class="s1">_gci(self):</span>
        <span class="s2">&quot;&quot;&quot;Helper for `~matplotlib.pyplot.gci`; do not use elsewhere.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._current_image</span>

    <span class="s0">def </span><span class="s1">has_data(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether any artists have been added to the Axes. 
 
        This should not be used to determine whether the *dataLim* 
        need to be updated, and may not actually be useful for 
        anything. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">any(isinstance(a</span><span class="s0">, </span><span class="s1">(mcoll.Collection</span><span class="s0">, </span><span class="s1">mimage.AxesImage</span><span class="s0">,</span>
                                  <span class="s1">mlines.Line2D</span><span class="s0">, </span><span class="s1">mpatches.Patch))</span>
                   <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self._children)</span>

    <span class="s0">def </span><span class="s1">add_artist(self</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add an `.Artist` to the Axes; return the artist. 
 
        Use `add_artist` only for artists for which there is no dedicated 
        &quot;add&quot; method; and if necessary, use a method such as `update_datalim` 
        to manually update the dataLim if the artist is to be included in 
        autoscaling. 
 
        If no ``transform`` has been specified when creating the artist (e.g. 
        ``artist.get_transform() == None``) then the transform is set to 
        ``ax.transData``. 
        &quot;&quot;&quot;</span>
        <span class="s1">a.axes = self</span>
        <span class="s1">self._children.append(a)</span>
        <span class="s1">a._remove_method = self._children.remove</span>
        <span class="s1">self._set_artist_props(a)</span>
        <span class="s1">a.set_clip_path(self.patch)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">a</span>

    <span class="s0">def </span><span class="s1">add_child_axes(self</span><span class="s0">, </span><span class="s1">ax):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add an `.AxesBase` to the Axes' children; return the child Axes. 
 
        This is the lowlevel version.  See `.axes.Axes.inset_axes`. 
        &quot;&quot;&quot;</span>

        <span class="s3"># normally Axes have themselves as the Axes, but these need to have</span>
        <span class="s3"># their parent...</span>
        <span class="s3"># Need to bypass the getter...</span>
        <span class="s1">ax._axes = self</span>
        <span class="s1">ax.stale_callback = martist._stale_axes_callback</span>

        <span class="s1">self.child_axes.append(ax)</span>
        <span class="s1">ax._remove_method = self.child_axes.remove</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">ax</span>

    <span class="s0">def </span><span class="s1">add_collection(self</span><span class="s0">, </span><span class="s1">collection</span><span class="s0">, </span><span class="s1">autolim=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Collection` to the Axes; return the collection. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mcoll.Collection</span><span class="s0">, </span><span class="s1">collection=collection)</span>
        <span class="s1">label = collection.get_label()</span>
        <span class="s0">if not </span><span class="s1">label:</span>
            <span class="s1">collection.set_label(</span><span class="s4">f'_child</span><span class="s0">{</span><span class="s1">len(self._children)</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self._children.append(collection)</span>
        <span class="s1">collection._remove_method = self._children.remove</span>
        <span class="s1">self._set_artist_props(collection)</span>

        <span class="s0">if </span><span class="s1">collection.get_clip_path() </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">collection.set_clip_path(self.patch)</span>

        <span class="s0">if </span><span class="s1">autolim:</span>
            <span class="s3"># Make sure viewLim is not stale (mostly to match</span>
            <span class="s3"># pre-lazy-autoscale behavior, which is not really better).</span>
            <span class="s1">self._unstale_viewLim()</span>
            <span class="s1">datalim = collection.get_datalim(self.transData)</span>
            <span class="s1">points = datalim.get_points()</span>
            <span class="s0">if not </span><span class="s1">np.isinf(datalim.minpos).all():</span>
                <span class="s3"># By definition, if minpos (minimum positive value) is set</span>
                <span class="s3"># (i.e., non-inf), then min(points) &lt;= minpos &lt;= max(points),</span>
                <span class="s3"># and minpos would be superfluous. However, we add minpos to</span>
                <span class="s3"># the call so that self.dataLim will update its own minpos.</span>
                <span class="s3"># This ensures that log scales see the correct minimum.</span>
                <span class="s1">points = np.concatenate([points</span><span class="s0">, </span><span class="s1">[datalim.minpos]])</span>
            <span class="s1">self.update_datalim(points)</span>

        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">collection</span>

    <span class="s0">def </span><span class="s1">add_image(self</span><span class="s0">, </span><span class="s1">image):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add an `.AxesImage` to the Axes; return the image. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mimage.AxesImage</span><span class="s0">, </span><span class="s1">image=image)</span>
        <span class="s1">self._set_artist_props(image)</span>
        <span class="s0">if not </span><span class="s1">image.get_label():</span>
            <span class="s1">image.set_label(</span><span class="s4">f'_child</span><span class="s0">{</span><span class="s1">len(self._children)</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self._children.append(image)</span>
        <span class="s1">image._remove_method = self._children.remove</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">image</span>

    <span class="s0">def </span><span class="s1">_update_image_limits(self</span><span class="s0">, </span><span class="s1">image):</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = image.get_extent()</span>
        <span class="s1">self.axes.update_datalim(((xmin</span><span class="s0">, </span><span class="s1">ymin)</span><span class="s0">, </span><span class="s1">(xmax</span><span class="s0">, </span><span class="s1">ymax)))</span>

    <span class="s0">def </span><span class="s1">add_line(self</span><span class="s0">, </span><span class="s1">line):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Line2D` to the Axes; return the line. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mlines.Line2D</span><span class="s0">, </span><span class="s1">line=line)</span>
        <span class="s1">self._set_artist_props(line)</span>
        <span class="s0">if </span><span class="s1">line.get_clip_path() </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">line.set_clip_path(self.patch)</span>

        <span class="s1">self._update_line_limits(line)</span>
        <span class="s0">if not </span><span class="s1">line.get_label():</span>
            <span class="s1">line.set_label(</span><span class="s4">f'_child</span><span class="s0">{</span><span class="s1">len(self._children)</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self._children.append(line)</span>
        <span class="s1">line._remove_method = self._children.remove</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">line</span>

    <span class="s0">def </span><span class="s1">_add_text(self</span><span class="s0">, </span><span class="s1">txt):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Text` to the Axes; return the text. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mtext.Text</span><span class="s0">, </span><span class="s1">txt=txt)</span>
        <span class="s1">self._set_artist_props(txt)</span>
        <span class="s1">self._children.append(txt)</span>
        <span class="s1">txt._remove_method = self._children.remove</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">txt</span>

    <span class="s0">def </span><span class="s1">_update_line_limits(self</span><span class="s0">, </span><span class="s1">line):</span>
        <span class="s2">&quot;&quot;&quot; 
        Figures out the data limit of the given line, updating self.dataLim. 
        &quot;&quot;&quot;</span>
        <span class="s1">path = line.get_path()</span>
        <span class="s0">if </span><span class="s1">path.vertices.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">line_trf = line.get_transform()</span>

        <span class="s0">if </span><span class="s1">line_trf == self.transData:</span>
            <span class="s1">data_path = path</span>
        <span class="s0">elif </span><span class="s1">any(line_trf.contains_branch_seperately(self.transData)):</span>
            <span class="s3"># Compute the transform from line coordinates to data coordinates.</span>
            <span class="s1">trf_to_data = line_trf - self.transData</span>
            <span class="s3"># If transData is affine we can use the cached non-affine component</span>
            <span class="s3"># of line's path (since the non-affine part of line_trf is</span>
            <span class="s3"># entirely encapsulated in trf_to_data).</span>
            <span class="s0">if </span><span class="s1">self.transData.is_affine:</span>
                <span class="s1">line_trans_path = line._get_transformed_path()</span>
                <span class="s1">na_path</span><span class="s0">, </span><span class="s1">_ = line_trans_path.get_transformed_path_and_affine()</span>
                <span class="s1">data_path = trf_to_data.transform_path_affine(na_path)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">data_path = trf_to_data.transform_path(path)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># For backwards compatibility we update the dataLim with the</span>
            <span class="s3"># coordinate range of the given path, even though the coordinate</span>
            <span class="s3"># systems are completely different. This may occur in situations</span>
            <span class="s3"># such as when ax.transAxes is passed through for absolute</span>
            <span class="s3"># positioning.</span>
            <span class="s1">data_path = path</span>

        <span class="s0">if not </span><span class="s1">data_path.vertices.size:</span>
            <span class="s0">return</span>

        <span class="s1">updatex</span><span class="s0">, </span><span class="s1">updatey = line_trf.contains_branch_seperately(self.transData)</span>
        <span class="s0">if </span><span class="s1">self.name != </span><span class="s4">&quot;rectilinear&quot;</span><span class="s1">:</span>
            <span class="s3"># This block is mostly intended to handle axvline in polar plots,</span>
            <span class="s3"># for which updatey would otherwise be True.</span>
            <span class="s0">if </span><span class="s1">updatex </span><span class="s0">and </span><span class="s1">line_trf == self.get_yaxis_transform():</span>
                <span class="s1">updatex = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">updatey </span><span class="s0">and </span><span class="s1">line_trf == self.get_xaxis_transform():</span>
                <span class="s1">updatey = </span><span class="s0">False</span>
        <span class="s1">self.dataLim.update_from_path(data_path</span><span class="s0">,</span>
                                      <span class="s1">self.ignore_existing_data_limits</span><span class="s0">,</span>
                                      <span class="s1">updatex=updatex</span><span class="s0">, </span><span class="s1">updatey=updatey)</span>
        <span class="s1">self.ignore_existing_data_limits = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">add_patch(self</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Patch` to the Axes; return the patch. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mpatches.Patch</span><span class="s0">, </span><span class="s1">p=p)</span>
        <span class="s1">self._set_artist_props(p)</span>
        <span class="s0">if </span><span class="s1">p.get_clip_path() </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">p.set_clip_path(self.patch)</span>
        <span class="s1">self._update_patch_limits(p)</span>
        <span class="s1">self._children.append(p)</span>
        <span class="s1">p._remove_method = self._children.remove</span>
        <span class="s0">return </span><span class="s1">p</span>

    <span class="s0">def </span><span class="s1">_update_patch_limits(self</span><span class="s0">, </span><span class="s1">patch):</span>
        <span class="s2">&quot;&quot;&quot;Update the data limits for the given patch.&quot;&quot;&quot;</span>
        <span class="s3"># hist can add zero height Rectangles, which is useful to keep</span>
        <span class="s3"># the bins, counts and patches lined up, but it throws off log</span>
        <span class="s3"># scaling.  We'll ignore rects with zero height or width in</span>
        <span class="s3"># the auto-scaling</span>

        <span class="s3"># cannot check for '==0' since unitized data may not compare to zero</span>
        <span class="s3"># issue #2150 - we update the limits if patch has non zero width</span>
        <span class="s3"># or height.</span>
        <span class="s0">if </span><span class="s1">(isinstance(patch</span><span class="s0">, </span><span class="s1">mpatches.Rectangle) </span><span class="s0">and</span>
                <span class="s1">((</span><span class="s0">not </span><span class="s1">patch.get_width()) </span><span class="s0">and </span><span class="s1">(</span><span class="s0">not </span><span class="s1">patch.get_height()))):</span>
            <span class="s0">return</span>
        <span class="s1">p = patch.get_path()</span>
        <span class="s3"># Get all vertices on the path</span>
        <span class="s3"># Loop through each segment to get extrema for Bezier curve sections</span>
        <span class="s1">vertices = []</span>
        <span class="s0">for </span><span class="s1">curve</span><span class="s0">, </span><span class="s1">code </span><span class="s0">in </span><span class="s1">p.iter_bezier(simplify=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s3"># Get distance along the curve of any extrema</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">dzeros = curve.axis_aligned_extrema()</span>
            <span class="s3"># Calculate vertices of start, end and any extrema in between</span>
            <span class="s1">vertices.append(curve([</span><span class="s5">0</span><span class="s0">, </span><span class="s1">*dzeros</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]))</span>

        <span class="s0">if </span><span class="s1">len(vertices):</span>
            <span class="s1">vertices = np.row_stack(vertices)</span>

        <span class="s1">patch_trf = patch.get_transform()</span>
        <span class="s1">updatex</span><span class="s0">, </span><span class="s1">updatey = patch_trf.contains_branch_seperately(self.transData)</span>
        <span class="s0">if not </span><span class="s1">(updatex </span><span class="s0">or </span><span class="s1">updatey):</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">self.name != </span><span class="s4">&quot;rectilinear&quot;</span><span class="s1">:</span>
            <span class="s3"># As in _update_line_limits, but for axvspan.</span>
            <span class="s0">if </span><span class="s1">updatex </span><span class="s0">and </span><span class="s1">patch_trf == self.get_yaxis_transform():</span>
                <span class="s1">updatex = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">updatey </span><span class="s0">and </span><span class="s1">patch_trf == self.get_xaxis_transform():</span>
                <span class="s1">updatey = </span><span class="s0">False</span>
        <span class="s1">trf_to_data = patch_trf - self.transData</span>
        <span class="s1">xys = trf_to_data.transform(vertices)</span>
        <span class="s1">self.update_datalim(xys</span><span class="s0">, </span><span class="s1">updatex=updatex</span><span class="s0">, </span><span class="s1">updatey=updatey)</span>

    <span class="s0">def </span><span class="s1">add_table(self</span><span class="s0">, </span><span class="s1">tab):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Table` to the Axes; return the table. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mtable.Table</span><span class="s0">, </span><span class="s1">tab=tab)</span>
        <span class="s1">self._set_artist_props(tab)</span>
        <span class="s1">self._children.append(tab)</span>
        <span class="s1">tab.set_clip_path(self.patch)</span>
        <span class="s1">tab._remove_method = self._children.remove</span>
        <span class="s0">return </span><span class="s1">tab</span>

    <span class="s0">def </span><span class="s1">add_container(self</span><span class="s0">, </span><span class="s1">container):</span>
        <span class="s2">&quot;&quot;&quot; 
        Add a `.Container` to the Axes' containers; return the container. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = container.get_label()</span>
        <span class="s0">if not </span><span class="s1">label:</span>
            <span class="s1">container.set_label(</span><span class="s4">'_container%d' </span><span class="s1">% len(self.containers))</span>
        <span class="s1">self.containers.append(container)</span>
        <span class="s1">container._remove_method = self.containers.remove</span>
        <span class="s0">return </span><span class="s1">container</span>

    <span class="s0">def </span><span class="s1">_unit_change_handler(self</span><span class="s0">, </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">event=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Process axis units changes: requests updates to data and view limits. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">event </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># Allow connecting `self._unit_change_handler(name)`</span>
            <span class="s0">return </span><span class="s1">functools.partial(</span>
                <span class="s1">self._unit_change_handler</span><span class="s0">, </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">event=object())</span>
        <span class="s1">_api.check_in_list(self._axis_map</span><span class="s0">, </span><span class="s1">axis_name=axis_name)</span>
        <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self.lines:</span>
            <span class="s1">line.recache_always()</span>
        <span class="s1">self.relim()</span>
        <span class="s1">self._request_autoscale_view(axis_name)</span>

    <span class="s0">def </span><span class="s1">relim(self</span><span class="s0">, </span><span class="s1">visible_only=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Recompute the data limits based on current artists. 
 
        At present, `.Collection` instances are not supported. 
 
        Parameters 
        ---------- 
        visible_only : bool, default: False 
            Whether to exclude invisible artists. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Collections are deliberately not supported (yet); see</span>
        <span class="s3"># the TODO note in artists.py.</span>
        <span class="s1">self.dataLim.ignore(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self.dataLim.set_points(mtransforms.Bbox.null().get_points())</span>
        <span class="s1">self.ignore_existing_data_limits = </span><span class="s0">True</span>

        <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">self._children:</span>
            <span class="s0">if not </span><span class="s1">visible_only </span><span class="s0">or </span><span class="s1">artist.get_visible():</span>
                <span class="s0">if </span><span class="s1">isinstance(artist</span><span class="s0">, </span><span class="s1">mlines.Line2D):</span>
                    <span class="s1">self._update_line_limits(artist)</span>
                <span class="s0">elif </span><span class="s1">isinstance(artist</span><span class="s0">, </span><span class="s1">mpatches.Patch):</span>
                    <span class="s1">self._update_patch_limits(artist)</span>
                <span class="s0">elif </span><span class="s1">isinstance(artist</span><span class="s0">, </span><span class="s1">mimage.AxesImage):</span>
                    <span class="s1">self._update_image_limits(artist)</span>

    <span class="s0">def </span><span class="s1">update_datalim(self</span><span class="s0">, </span><span class="s1">xys</span><span class="s0">, </span><span class="s1">updatex=</span><span class="s0">True, </span><span class="s1">updatey=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Extend the `~.Axes.dataLim` Bbox to include the given points. 
 
        If no data is set currently, the Bbox will ignore its limits and set 
        the bound to be the bounds of the xydata (*xys*). Otherwise, it will 
        compute the bounds of the union of its current data and the data in 
        *xys*. 
 
        Parameters 
        ---------- 
        xys : 2D array-like 
            The points to include in the data limits Bbox. This can be either 
            a list of (x, y) tuples or a Nx2 array. 
 
        updatex, updatey : bool, default: True 
            Whether to update the x/y limits. 
        &quot;&quot;&quot;</span>
        <span class="s1">xys = np.asarray(xys)</span>
        <span class="s0">if not </span><span class="s1">np.any(np.isfinite(xys)):</span>
            <span class="s0">return</span>
        <span class="s1">self.dataLim.update_from_data_xy(xys</span><span class="s0">, </span><span class="s1">self.ignore_existing_data_limits</span><span class="s0">,</span>
                                         <span class="s1">updatex=updatex</span><span class="s0">, </span><span class="s1">updatey=updatey)</span>
        <span class="s1">self.ignore_existing_data_limits = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">_process_unit_info(self</span><span class="s0">, </span><span class="s1">datasets=</span><span class="s0">None, </span><span class="s1">kwargs=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">convert=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set axis units based on *datasets* and *kwargs*, and optionally apply 
        unit conversions to *datasets*. 
 
        Parameters 
        ---------- 
        datasets : list 
            List of (axis_name, dataset) pairs (where the axis name is defined 
            as in `._axis_map`).  Individual datasets can also be None 
            (which gets passed through). 
        kwargs : dict 
            Other parameters from which unit info (i.e., the *xunits*, 
            *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for 
            polar) entries) is popped, if present.  Note that this dict is 
            mutated in-place! 
        convert : bool, default: True 
            Whether to return the original datasets or the converted ones. 
 
        Returns 
        ------- 
        list 
            Either the original datasets if *convert* is False, or the 
            converted ones if *convert* is True (the default). 
        &quot;&quot;&quot;</span>
        <span class="s3"># The API makes datasets a list of pairs rather than an axis_name to</span>
        <span class="s3"># dataset mapping because it is sometimes necessary to process multiple</span>
        <span class="s3"># datasets for a single axis, and concatenating them may be tricky</span>
        <span class="s3"># (e.g. if some are scalars, etc.).</span>
        <span class="s1">datasets = datasets </span><span class="s0">or </span><span class="s1">[]</span>
        <span class="s1">kwargs = kwargs </span><span class="s0">or </span><span class="s1">{}</span>
        <span class="s1">axis_map = self._axis_map</span>
        <span class="s0">for </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">datasets:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">axis = axis_map[axis_name]</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Invalid axis name: </span><span class="s0">{</span><span class="s1">axis_name</span><span class="s0">!r}</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s0">from None</span>
            <span class="s3"># Update from data if axis is already set but no unit is set yet.</span>
            <span class="s0">if </span><span class="s1">(axis </span><span class="s0">is not None and</span>
                    <span class="s1">data </span><span class="s0">is not None and</span>
                    <span class="s0">not </span><span class="s1">axis._have_units_and_converter()):</span>
                <span class="s1">axis.update_units(data)</span>
        <span class="s0">for </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axis_map.items():</span>
            <span class="s3"># Return if no axis is set.</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s3"># Check for units in the kwargs, and if present update axis.</span>
            <span class="s1">units = kwargs.pop(</span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">axis_name</span><span class="s0">}</span><span class="s4">units&quot;</span><span class="s0">, </span><span class="s1">axis.units)</span>
            <span class="s0">if </span><span class="s1">self.name == </span><span class="s4">&quot;polar&quot;</span><span class="s1">:</span>
                <span class="s3"># Special case: polar supports &quot;thetaunits&quot;/&quot;runits&quot;.</span>
                <span class="s1">polar_units = {</span><span class="s4">&quot;x&quot;</span><span class="s1">: </span><span class="s4">&quot;thetaunits&quot;</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s1">: </span><span class="s4">&quot;runits&quot;</span><span class="s1">}</span>
                <span class="s1">units = kwargs.pop(polar_units[axis_name]</span><span class="s0">, </span><span class="s1">units)</span>
            <span class="s0">if </span><span class="s1">units != axis.units </span><span class="s0">and </span><span class="s1">units </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">axis.set_units(units)</span>
                <span class="s3"># If the units being set imply a different converter,</span>
                <span class="s3"># we need to update again.</span>
                <span class="s0">for </span><span class="s1">dataset_axis_name</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">datasets:</span>
                    <span class="s0">if </span><span class="s1">dataset_axis_name == axis_name </span><span class="s0">and </span><span class="s1">data </span><span class="s0">is not None</span><span class="s1">:</span>
                        <span class="s1">axis.update_units(data)</span>
        <span class="s0">return </span><span class="s1">[axis_map[axis_name].convert_units(data)</span>
                <span class="s0">if </span><span class="s1">convert </span><span class="s0">and </span><span class="s1">data </span><span class="s0">is not None else </span><span class="s1">data</span>
                <span class="s0">for </span><span class="s1">axis_name</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">datasets]</span>

    <span class="s0">def </span><span class="s1">in_axes(self</span><span class="s0">, </span><span class="s1">mouseevent):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether the given event (in display coords) is in the Axes. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.patch.contains(mouseevent)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">get_autoscalex_on = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_get_autoscale_on&quot;</span><span class="s1">)</span>
    <span class="s1">get_autoscaley_on = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_get_autoscale_on&quot;</span><span class="s1">)</span>
    <span class="s1">set_autoscalex_on = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_set_autoscale_on&quot;</span><span class="s1">)</span>
    <span class="s1">set_autoscaley_on = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_set_autoscale_on&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_autoscale_on(self):</span>
        <span class="s2">&quot;&quot;&quot;Return True if each axis is autoscaled, False otherwise.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">all(axis._get_autoscale_on()</span>
                   <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values())</span>

    <span class="s0">def </span><span class="s1">set_autoscale_on(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether autoscaling is applied to each axis on the next draw or 
        call to `.Axes.autoscale_view`. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
            <span class="s1">axis._set_autoscale_on(b)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">use_sticky_edges(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        When autoscaling, whether to obey all `Artist.sticky_edges`. 
 
        Default is ``True``. 
 
        Setting this to ``False`` ensures that the specified margins 
        will be applied, even if the plot includes an image, for 
        example, which would otherwise force a view limit to coincide 
        with its data limit. 
 
        The changing this property does not change the plot until 
        `autoscale` or `autoscale_view` is called. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._use_sticky_edges</span>

    <span class="s1">@use_sticky_edges.setter</span>
    <span class="s0">def </span><span class="s1">use_sticky_edges(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s1">self._use_sticky_edges = bool(b)</span>
        <span class="s3"># No effect until next autoscaling, which will mark the Axes as stale.</span>

    <span class="s0">def </span><span class="s1">set_xmargin(self</span><span class="s0">, </span><span class="s1">m):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set padding of X data limits prior to autoscaling. 
 
        *m* times the data interval will be added to each end of that interval 
        before it is used in autoscaling.  If *m* is negative, this will clip 
        the data range instead of expanding it. 
 
        For example, if your data is in the range [0, 2], a margin of 0.1 will 
        result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range 
        of [0.2, 1.8]. 
 
        Parameters 
        ---------- 
        m : float greater than -0.5 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">m &lt;= -</span><span class="s5">0.5</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;margin must be greater than -0.5&quot;</span><span class="s1">)</span>
        <span class="s1">self._xmargin = m</span>
        <span class="s1">self._request_autoscale_view(</span><span class="s4">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_ymargin(self</span><span class="s0">, </span><span class="s1">m):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set padding of Y data limits prior to autoscaling. 
 
        *m* times the data interval will be added to each end of that interval 
        before it is used in autoscaling.  If *m* is negative, this will clip 
        the data range instead of expanding it. 
 
        For example, if your data is in the range [0, 2], a margin of 0.1 will 
        result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range 
        of [0.2, 1.8]. 
 
        Parameters 
        ---------- 
        m : float greater than -0.5 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">m &lt;= -</span><span class="s5">0.5</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;margin must be greater than -0.5&quot;</span><span class="s1">)</span>
        <span class="s1">self._ymargin = m</span>
        <span class="s1">self._request_autoscale_view(</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">margins(self</span><span class="s0">, </span><span class="s1">*margins</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">tight=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set or retrieve autoscaling margins. 
 
        The padding added to each limit of the Axes is the *margin* 
        times the data interval. All input parameters must be floats 
        within the range [0, 1]. Passing both positional and keyword 
        arguments is invalid and will raise a TypeError. If no 
        arguments (positional or otherwise) are provided, the current 
        margins will remain in place and simply be returned. 
 
        Specifying any margin changes only the autoscaling; for example, 
        if *xmargin* is not None, then *xmargin* times the X data 
        interval will be added to each end of that interval before 
        it is used in autoscaling. 
 
        Parameters 
        ---------- 
        *margins : float, optional 
            If a single positional argument is provided, it specifies 
            both margins of the x-axis and y-axis limits. If two 
            positional arguments are provided, they will be interpreted 
            as *xmargin*, *ymargin*. If setting the margin on a single 
            axis is desired, use the keyword arguments described below. 
 
        x, y : float, optional 
            Specific margin values for the x-axis and y-axis, 
            respectively. These cannot be used with positional 
            arguments, but can be used individually to alter on e.g., 
            only the y-axis. 
 
        tight : bool or None, default: True 
            The *tight* parameter is passed to `~.axes.Axes.autoscale_view`, 
            which is executed after a margin is changed; the default 
            here is *True*, on the assumption that when margins are 
            specified, no additional padding to match tick marks is 
            usually desired.  Setting *tight* to *None* preserves 
            the previous setting. 
 
        Returns 
        ------- 
        xmargin, ymargin : float 
 
        Notes 
        ----- 
        If a previously used Axes method such as :meth:`pcolor` has set 
        :attr:`use_sticky_edges` to `True`, only the limits not set by 
        the &quot;sticky artists&quot; will be modified. To force all of the 
        margins to be set, set :attr:`use_sticky_edges` to `False` 
        before calling :meth:`margins`. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">margins </span><span class="s0">and </span><span class="s1">(x </span><span class="s0">is not None or </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Cannot pass both positional and keyword '</span>
                            <span class="s4">'arguments for x and/or y.'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">len(margins) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">x = y = margins[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">len(margins) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">y = margins</span>
        <span class="s0">elif </span><span class="s1">margins:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">'Must pass a single positional argument for all '</span>
                            <span class="s4">'margins, or one for each margin (x, y).'</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">x </span><span class="s0">is None and </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">tight </span><span class="s0">is not True</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s4">f'ignoring tight=</span><span class="s0">{</span><span class="s1">tight</span><span class="s0">!r} </span><span class="s4">in get mode'</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">self._xmargin</span><span class="s0">, </span><span class="s1">self._ymargin</span>

        <span class="s0">if </span><span class="s1">tight </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._tight = tight</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_xmargin(x)</span>
        <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_ymargin(y)</span>

    <span class="s0">def </span><span class="s1">set_rasterization_zorder(self</span><span class="s0">, </span><span class="s1">z):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the zorder threshold for rasterization for vector graphics output. 
 
        All artists with a zorder below the given value will be rasterized if 
        they support rasterization. 
 
        This setting is ignored for pixel-based output. 
 
        See also :doc:`/gallery/misc/rasterization_demo`. 
 
        Parameters 
        ---------- 
        z : float or None 
            The zorder below which artists are rasterized. 
            If ``None`` rasterization based on zorder is deactivated. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._rasterization_zorder = z</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_rasterization_zorder(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the zorder value below which artists will be rasterized.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._rasterization_zorder</span>

    <span class="s0">def </span><span class="s1">autoscale(self</span><span class="s0">, </span><span class="s1">enable=</span><span class="s0">True, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s0">, </span><span class="s1">tight=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Autoscale the axis view to the data (toggle). 
 
        Convenience method for simple axis view autoscaling. 
        It turns autoscaling on or off, and then, 
        if autoscaling for either axis is on, it performs 
        the autoscaling on the specified axis or Axes. 
 
        Parameters 
        ---------- 
        enable : bool or None, default: True 
            True turns autoscaling on, False turns it off. 
            None leaves the autoscaling state unchanged. 
        axis : {'both', 'x', 'y'}, default: 'both' 
            The axis on which to operate.  (For 3D Axes, *axis* can also be set 
            to 'z', and 'both' refers to all three axes.) 
        tight : bool or None, default: None 
            If True, first set the margins to zero.  Then, this argument is 
            forwarded to `~.axes.Axes.autoscale_view` (regardless of 
            its value); see the description of its behavior there. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">enable </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">scalex = </span><span class="s0">True</span>
            <span class="s1">scaley = </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscalex_on(bool(enable))</span>
                <span class="s1">scalex = self.get_autoscalex_on()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">scalex = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
                <span class="s1">self.set_autoscaley_on(bool(enable))</span>
                <span class="s1">scaley = self.get_autoscaley_on()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">scaley = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">tight </span><span class="s0">and </span><span class="s1">scalex:</span>
            <span class="s1">self._xmargin = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">tight </span><span class="s0">and </span><span class="s1">scaley:</span>
            <span class="s1">self._ymargin = </span><span class="s5">0</span>
        <span class="s0">if </span><span class="s1">scalex:</span>
            <span class="s1">self._request_autoscale_view(</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s1">tight=tight)</span>
        <span class="s0">if </span><span class="s1">scaley:</span>
            <span class="s1">self._request_autoscale_view(</span><span class="s4">&quot;y&quot;</span><span class="s0">, </span><span class="s1">tight=tight)</span>

    <span class="s0">def </span><span class="s1">autoscale_view(self</span><span class="s0">, </span><span class="s1">tight=</span><span class="s0">None, </span><span class="s1">scalex=</span><span class="s0">True, </span><span class="s1">scaley=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Autoscale the view limits using the data limits. 
 
        Parameters 
        ---------- 
        tight : bool or None 
            If *True*, only expand the axis limits using the margins.  Note 
            that unlike for `autoscale`, ``tight=True`` does *not* set the 
            margins to zero. 
 
            If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then 
            after expansion by the margins, further expand the axis limits 
            using the axis major locator. 
 
            If None (the default), reuse the value set in the previous call to 
            `autoscale_view` (the initial value is False, but the default style 
            sets :rc:`axes.autolimit_mode` to 'data', in which case this 
            behaves like True). 
 
        scalex : bool, default: True 
            Whether to autoscale the x-axis. 
 
        scaley : bool, default: True 
            Whether to autoscale the y-axis. 
 
        Notes 
        ----- 
        The autoscaling preserves any preexisting axis direction reversal. 
 
        The data limits are not updated automatically when artist data are 
        changed after the artist has been added to an Axes instance.  In that 
        case, use :meth:`matplotlib.axes.Axes.relim` prior to calling 
        autoscale_view. 
 
        If the views of the Axes are fixed, e.g. via `set_xlim`, they will 
        not be changed by autoscale_view(). 
        See :meth:`matplotlib.axes.Axes.autoscale` for an alternative. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">tight </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._tight = bool(tight)</span>

        <span class="s1">x_stickies = y_stickies = np.array([])</span>
        <span class="s0">if </span><span class="s1">self.use_sticky_edges:</span>
            <span class="s0">if </span><span class="s1">self._xmargin </span><span class="s0">and </span><span class="s1">scalex </span><span class="s0">and </span><span class="s1">self.get_autoscalex_on():</span>
                <span class="s1">x_stickies = np.sort(np.concatenate([</span>
                    <span class="s1">artist.sticky_edges.x</span>
                    <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">].get_siblings(self)</span>
                    <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">ax.get_children()]))</span>
            <span class="s0">if </span><span class="s1">self._ymargin </span><span class="s0">and </span><span class="s1">scaley </span><span class="s0">and </span><span class="s1">self.get_autoscaley_on():</span>
                <span class="s1">y_stickies = np.sort(np.concatenate([</span>
                    <span class="s1">artist.sticky_edges.y</span>
                    <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">].get_siblings(self)</span>
                    <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">ax.get_children()]))</span>
        <span class="s0">if </span><span class="s1">self.get_xscale() == </span><span class="s4">'log'</span><span class="s1">:</span>
            <span class="s1">x_stickies = x_stickies[x_stickies &gt; </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">self.get_yscale() == </span><span class="s4">'log'</span><span class="s1">:</span>
            <span class="s1">y_stickies = y_stickies[y_stickies &gt; </span><span class="s5">0</span><span class="s1">]</span>

        <span class="s0">def </span><span class="s1">handle_single_axis(</span>
                <span class="s1">scale</span><span class="s0">, </span><span class="s1">shared_axes</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">margin</span><span class="s0">, </span><span class="s1">stickies</span><span class="s0">, </span><span class="s1">set_bound):</span>

            <span class="s0">if not </span><span class="s1">(scale </span><span class="s0">and </span><span class="s1">axis._get_autoscale_on()):</span>
                <span class="s0">return  </span><span class="s3"># nothing to do...</span>

            <span class="s1">shared = shared_axes.get_siblings(self)</span>
            <span class="s3"># Base autoscaling on finite data limits when there is at least one</span>
            <span class="s3"># finite data limit among all the shared_axes and intervals.</span>
            <span class="s1">values = [val </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">shared</span>
                      <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">getattr(ax.dataLim</span><span class="s0">, </span><span class="s4">f&quot;interval</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                      <span class="s0">if </span><span class="s1">np.isfinite(val)]</span>
            <span class="s0">if </span><span class="s1">values:</span>
                <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = (min(values)</span><span class="s0">, </span><span class="s1">max(values))</span>
            <span class="s0">elif </span><span class="s1">getattr(self._viewLim</span><span class="s0">, </span><span class="s4">f&quot;mutated</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)():</span>
                <span class="s3"># No data, but explicit viewLims already set:</span>
                <span class="s3"># in mutatedx or mutatedy.</span>
                <span class="s0">return</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = (-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span>
            <span class="s3"># If x0 and x1 are nonfinite, get default limits from the locator.</span>
            <span class="s1">locator = axis.get_major_locator()</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = locator.nonsingular(x0</span><span class="s0">, </span><span class="s1">x1)</span>
            <span class="s3"># Find the minimum minpos for use in the margin calculation.</span>
            <span class="s1">minimum_minpos = min(</span>
                <span class="s1">getattr(ax.dataLim</span><span class="s0">, </span><span class="s4">f&quot;minpos</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">shared)</span>

            <span class="s3"># Prevent margin addition from crossing a sticky value.  A small</span>
            <span class="s3"># tolerance must be added due to floating point issues with</span>
            <span class="s3"># streamplot; it is defined relative to x0, x1, x1-x0 but has</span>
            <span class="s3"># no absolute term (e.g. &quot;+1e-8&quot;) to avoid issues when working with</span>
            <span class="s3"># datasets where all values are tiny (less than 1e-8).</span>
            <span class="s1">tol = </span><span class="s5">1e-5 </span><span class="s1">* max(abs(x0)</span><span class="s0">, </span><span class="s1">abs(x1)</span><span class="s0">, </span><span class="s1">abs(x1 - x0))</span>
            <span class="s3"># Index of largest element &lt; x0 + tol, if any.</span>
            <span class="s1">i0 = stickies.searchsorted(x0 + tol) - </span><span class="s5">1</span>
            <span class="s1">x0bound = stickies[i0] </span><span class="s0">if </span><span class="s1">i0 != -</span><span class="s5">1 </span><span class="s0">else None</span>
            <span class="s3"># Index of smallest element &gt; x1 - tol, if any.</span>
            <span class="s1">i1 = stickies.searchsorted(x1 - tol)</span>
            <span class="s1">x1bound = stickies[i1] </span><span class="s0">if </span><span class="s1">i1 != len(stickies) </span><span class="s0">else None</span>

            <span class="s3"># Add the margin in figure space and then transform back, to handle</span>
            <span class="s3"># non-linear scales.</span>
            <span class="s1">transform = axis.get_transform()</span>
            <span class="s1">inverse_trans = transform.inverted()</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = axis._scale.limit_range_for_scale(x0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">minimum_minpos)</span>
            <span class="s1">x0t</span><span class="s0">, </span><span class="s1">x1t = transform.transform([x0</span><span class="s0">, </span><span class="s1">x1])</span>
            <span class="s1">delta = (x1t - x0t) * margin</span>
            <span class="s0">if not </span><span class="s1">np.isfinite(delta):</span>
                <span class="s1">delta = </span><span class="s5">0  </span><span class="s3"># If a bound isn't finite, set margin to zero.</span>
            <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = inverse_trans.transform([x0t - delta</span><span class="s0">, </span><span class="s1">x1t + delta])</span>

            <span class="s3"># Apply sticky bounds.</span>
            <span class="s0">if </span><span class="s1">x0bound </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">x0 = max(x0</span><span class="s0">, </span><span class="s1">x0bound)</span>
            <span class="s0">if </span><span class="s1">x1bound </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">x1 = min(x1</span><span class="s0">, </span><span class="s1">x1bound)</span>

            <span class="s0">if not </span><span class="s1">self._tight:</span>
                <span class="s1">x0</span><span class="s0">, </span><span class="s1">x1 = locator.view_limits(x0</span><span class="s0">, </span><span class="s1">x1)</span>
            <span class="s1">set_bound(x0</span><span class="s0">, </span><span class="s1">x1)</span>
            <span class="s3"># End of definition of internal function 'handle_single_axis'.</span>

        <span class="s1">handle_single_axis(</span>
            <span class="s1">scalex</span><span class="s0">, </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s4">'x'</span><span class="s0">, </span><span class="s1">self.xaxis</span><span class="s0">, </span><span class="s1">self._xmargin</span><span class="s0">,</span>
            <span class="s1">x_stickies</span><span class="s0">, </span><span class="s1">self.set_xbound)</span>
        <span class="s1">handle_single_axis(</span>
            <span class="s1">scaley</span><span class="s0">, </span><span class="s1">self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s4">'y'</span><span class="s0">, </span><span class="s1">self.yaxis</span><span class="s0">, </span><span class="s1">self._ymargin</span><span class="s0">,</span>
            <span class="s1">y_stickies</span><span class="s0">, </span><span class="s1">self.set_ybound)</span>

    <span class="s0">def </span><span class="s1">_update_title_position(self</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update the title position based on the bounding box enclosing 
        all the ticklabels and x-axis spine and xlabel... 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._autotitlepos </span><span class="s0">is not None and not </span><span class="s1">self._autotitlepos:</span>
            <span class="s1">_log.debug(</span><span class="s4">'title position was updated manually, not adjusting'</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s1">titles = (self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title)</span>

        <span class="s3"># Need to check all our twins too, and all the children as well.</span>
        <span class="s1">axs = self._twinned_axes.get_siblings(self) + self.child_axes</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">self.child_axes:  </span><span class="s3"># Child positions must be updated first.</span>
            <span class="s1">locator = ax.get_axes_locator()</span>
            <span class="s1">ax.apply_aspect(locator(self</span><span class="s0">, </span><span class="s1">renderer) </span><span class="s0">if </span><span class="s1">locator </span><span class="s0">else None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">title </span><span class="s0">in </span><span class="s1">titles:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">_ = title.get_position()</span>
            <span class="s3"># need to start again in case of window resizing</span>
            <span class="s1">title.set_position((x</span><span class="s0">, </span><span class="s5">1.0</span><span class="s1">))</span>
            <span class="s1">top = -np.inf</span>
            <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axs:</span>
                <span class="s1">bb = </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">(ax.xaxis.get_ticks_position() </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'top'</span><span class="s0">, </span><span class="s4">'unknown'</span><span class="s1">]</span>
                        <span class="s0">or </span><span class="s1">ax.xaxis.get_label_position() == </span><span class="s4">'top'</span><span class="s1">):</span>
                    <span class="s1">bb = ax.xaxis.get_tightbbox(renderer)</span>
                <span class="s0">if </span><span class="s1">bb </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s4">'outline' </span><span class="s0">in </span><span class="s1">ax.spines:</span>
                        <span class="s3"># Special case for colorbars:</span>
                        <span class="s1">bb = ax.spines[</span><span class="s4">'outline'</span><span class="s1">].get_window_extent()</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">bb = ax.get_window_extent(renderer)</span>
                <span class="s1">top = max(top</span><span class="s0">, </span><span class="s1">bb.ymax)</span>
                <span class="s0">if </span><span class="s1">title.get_text():</span>
                    <span class="s1">ax.yaxis.get_tightbbox(renderer)  </span><span class="s3"># update offsetText</span>
                    <span class="s0">if </span><span class="s1">ax.yaxis.offsetText.get_text():</span>
                        <span class="s1">bb = ax.yaxis.offsetText.get_tightbbox(renderer)</span>
                        <span class="s0">if </span><span class="s1">bb.intersection(title.get_tightbbox(renderer)</span><span class="s0">, </span><span class="s1">bb):</span>
                            <span class="s1">top = bb.ymax</span>
            <span class="s0">if </span><span class="s1">top &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3"># the top of Axes is not even on the figure, so don't try and</span>
                <span class="s3"># automatically place it.</span>
                <span class="s1">_log.debug(</span><span class="s4">'top of Axes not in the figure, so title not moved'</span><span class="s1">)</span>
                <span class="s0">return</span>
            <span class="s0">if </span><span class="s1">title.get_window_extent(renderer).ymin &lt; top:</span>
                <span class="s1">_</span><span class="s0">, </span><span class="s1">y = self.transAxes.inverted().transform((</span><span class="s5">0</span><span class="s0">, </span><span class="s1">top))</span>
                <span class="s1">title.set_position((x</span><span class="s0">, </span><span class="s1">y))</span>
                <span class="s3"># empirically, this doesn't always get the min to top,</span>
                <span class="s3"># so we need to adjust again.</span>
                <span class="s0">if </span><span class="s1">title.get_window_extent(renderer).ymin &lt; top:</span>
                    <span class="s1">_</span><span class="s0">, </span><span class="s1">y = self.transAxes.inverted().transform(</span>
                        <span class="s1">(</span><span class="s5">0.</span><span class="s0">, </span><span class="s5">2 </span><span class="s1">* top - title.get_window_extent(renderer).ymin))</span>
                    <span class="s1">title.set_position((x</span><span class="s0">, </span><span class="s1">y))</span>

        <span class="s1">ymax = max(title.get_position()[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">title </span><span class="s0">in </span><span class="s1">titles)</span>
        <span class="s0">for </span><span class="s1">title </span><span class="s0">in </span><span class="s1">titles:</span>
            <span class="s3"># now line up all the titles at the highest baseline.</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">_ = title.get_position()</span>
            <span class="s1">title.set_position((x</span><span class="s0">, </span><span class="s1">ymax))</span>

    <span class="s3"># Drawing</span>
    <span class="s1">@martist.allow_rasterization</span>
    <span class="s0">def </span><span class="s1">draw(self</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">renderer </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s4">'No renderer defined'</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">self.get_visible():</span>
            <span class="s0">return</span>
        <span class="s1">self._unstale_viewLim()</span>

        <span class="s1">renderer.open_group(</span><span class="s4">'axes'</span><span class="s0">, </span><span class="s1">gid=self.get_gid())</span>

        <span class="s3"># prevent triggering call backs during the draw process</span>
        <span class="s1">self._stale = </span><span class="s0">True</span>

        <span class="s3"># loop over self and child Axes...</span>
        <span class="s1">locator = self.get_axes_locator()</span>
        <span class="s1">self.apply_aspect(locator(self</span><span class="s0">, </span><span class="s1">renderer) </span><span class="s0">if </span><span class="s1">locator </span><span class="s0">else None</span><span class="s1">)</span>

        <span class="s1">artists = self.get_children()</span>
        <span class="s1">artists.remove(self.patch)</span>

        <span class="s3"># the frame draws the edges around the Axes patch -- we</span>
        <span class="s3"># decouple these so the patch can be in the background and the</span>
        <span class="s3"># frame in the foreground. Do this before drawing the axis</span>
        <span class="s3"># objects so that the spine has the opportunity to update them.</span>
        <span class="s0">if not </span><span class="s1">(self.axison </span><span class="s0">and </span><span class="s1">self._frameon):</span>
            <span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">self.spines.values():</span>
                <span class="s1">artists.remove(spine)</span>

        <span class="s1">self._update_title_position(renderer)</span>

        <span class="s0">if not </span><span class="s1">self.axison:</span>
            <span class="s0">for </span><span class="s1">_axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
                <span class="s1">artists.remove(_axis)</span>

        <span class="s0">if not </span><span class="s1">self.figure.canvas.is_saving():</span>
            <span class="s1">artists = [</span>
                <span class="s1">a </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">artists</span>
                <span class="s0">if not </span><span class="s1">a.get_animated() </span><span class="s0">or </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">mimage.AxesImage)]</span>
        <span class="s1">artists = sorted(artists</span><span class="s0">, </span><span class="s1">key=attrgetter(</span><span class="s4">'zorder'</span><span class="s1">))</span>

        <span class="s3"># rasterize artists with negative zorder</span>
        <span class="s3"># if the minimum zorder is negative, start rasterization</span>
        <span class="s1">rasterization_zorder = self._rasterization_zorder</span>

        <span class="s0">if </span><span class="s1">(rasterization_zorder </span><span class="s0">is not None and</span>
                <span class="s1">artists </span><span class="s0">and </span><span class="s1">artists[</span><span class="s5">0</span><span class="s1">].zorder &lt; rasterization_zorder):</span>
            <span class="s1">split_index = np.searchsorted(</span>
                <span class="s1">[art.zorder </span><span class="s0">for </span><span class="s1">art </span><span class="s0">in </span><span class="s1">artists]</span><span class="s0">,</span>
                <span class="s1">rasterization_zorder</span><span class="s0">, </span><span class="s1">side=</span><span class="s4">'right'</span>
            <span class="s1">)</span>
            <span class="s1">artists_rasterized = artists[:split_index]</span>
            <span class="s1">artists = artists[split_index:]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">artists_rasterized = []</span>

        <span class="s0">if </span><span class="s1">self.axison </span><span class="s0">and </span><span class="s1">self._frameon:</span>
            <span class="s0">if </span><span class="s1">artists_rasterized:</span>
                <span class="s1">artists_rasterized = [self.patch] + artists_rasterized</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">artists = [self.patch] + artists</span>

        <span class="s0">if </span><span class="s1">artists_rasterized:</span>
            <span class="s1">_draw_rasterized(self.figure</span><span class="s0">, </span><span class="s1">artists_rasterized</span><span class="s0">, </span><span class="s1">renderer)</span>

        <span class="s1">mimage._draw_list_compositing_images(</span>
            <span class="s1">renderer</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">artists</span><span class="s0">, </span><span class="s1">self.figure.suppressComposite)</span>

        <span class="s1">renderer.close_group(</span><span class="s4">'axes'</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">draw_artist(self</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s2">&quot;&quot;&quot; 
        Efficiently redraw a single artist. 
        &quot;&quot;&quot;</span>
        <span class="s1">a.draw(self.figure.canvas.get_renderer())</span>

    <span class="s0">def </span><span class="s1">redraw_in_frame(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Efficiently redraw Axes data, but not axis ticks, labels, etc. 
        &quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">ExitStack() </span><span class="s0">as </span><span class="s1">stack:</span>
            <span class="s0">for </span><span class="s1">artist </span><span class="s0">in </span><span class="s1">[*self._axis_map.values()</span><span class="s0">,</span>
                           <span class="s1">self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title]:</span>
                <span class="s1">stack.enter_context(artist._cm_set(visible=</span><span class="s0">False</span><span class="s1">))</span>
            <span class="s1">self.draw(self.figure.canvas.get_renderer())</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s4">&quot;Axes.figure.canvas.get_renderer()&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">get_renderer_cache(self):</span>
        <span class="s0">return </span><span class="s1">self.figure.canvas.get_renderer()</span>

    <span class="s3"># Axes rectangle characteristics</span>

    <span class="s0">def </span><span class="s1">get_frame_on(self):</span>
        <span class="s2">&quot;&quot;&quot;Get whether the Axes rectangle patch is drawn.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._frameon</span>

    <span class="s0">def </span><span class="s1">set_frame_on(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether the Axes rectangle patch is drawn. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._frameon = b</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_axisbelow(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get whether axis ticks and gridlines are above or below most artists. 
 
        Returns 
        ------- 
        bool or 'line' 
 
        See Also 
        -------- 
        set_axisbelow 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._axisbelow</span>

    <span class="s0">def </span><span class="s1">set_axisbelow(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether axis ticks and gridlines are above or below most artists. 
 
        This controls the zorder of the ticks and gridlines. For more 
        information on the zorder see :doc:`/gallery/misc/zorder_demo`. 
 
        Parameters 
        ---------- 
        b : bool or 'line' 
            Possible values: 
 
            - *True* (zorder = 0.5): Ticks and gridlines are below all Artists. 
            - 'line' (zorder = 1.5): Ticks and gridlines are above patches 
              (e.g. rectangles, with default zorder = 1) but still below lines 
              and markers (with their default zorder = 2). 
            - *False* (zorder = 2.5): Ticks and gridlines are above patches 
              and lines / markers. 
 
        See Also 
        -------- 
        get_axisbelow 
        &quot;&quot;&quot;</span>
        <span class="s3"># Check that b is True, False or 'line'</span>
        <span class="s1">self._axisbelow = axisbelow = validate_axisbelow(b)</span>
        <span class="s1">zorder = {</span>
            <span class="s0">True</span><span class="s1">: </span><span class="s5">0.5</span><span class="s0">,</span>
            <span class="s4">'line'</span><span class="s1">: </span><span class="s5">1.5</span><span class="s0">,</span>
            <span class="s0">False</span><span class="s1">: </span><span class="s5">2.5</span><span class="s0">,</span>
        <span class="s1">}[axisbelow]</span>
        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
            <span class="s1">axis.set_zorder(zorder)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s0">def </span><span class="s1">grid(self</span><span class="s0">, </span><span class="s1">visible=</span><span class="s0">None, </span><span class="s1">which=</span><span class="s4">'major'</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Configure the grid lines. 
 
        Parameters 
        ---------- 
        visible : bool or None, optional 
            Whether to show the grid lines.  If any *kwargs* are supplied, it 
            is assumed you want the grid on and *visible* will be set to True. 
 
            If *visible* is *None* and there are no *kwargs*, this toggles the 
            visibility of the lines. 
 
        which : {'major', 'minor', 'both'}, optional 
            The grid lines to apply the changes on. 
 
        axis : {'both', 'x', 'y'}, optional 
            The axis to apply the changes on. 
 
        **kwargs : `.Line2D` properties 
            Define the line properties of the grid, e.g.:: 
 
                grid(color='r', linestyle='-', linewidth=2) 
 
            Valid keyword arguments are: 
 
            %(Line2D:kwdoc)s 
 
        Notes 
        ----- 
        The axis is drawn as a unit, so the effective zorder for drawing the 
        grid is determined by the zorder of each axis, not by the zorder of the 
        `.Line2D` objects comprising the grid.  Therefore, to set grid zorder, 
        use `.set_axisbelow` or, for more control, call the 
        `~.Artist.set_zorder` method of each axis. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
            <span class="s1">self.xaxis.grid(visible</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
            <span class="s1">self.yaxis.grid(visible</span><span class="s0">, </span><span class="s1">which=which</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">ticklabel_format(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s0">, </span><span class="s1">style=</span><span class="s4">''</span><span class="s0">, </span><span class="s1">scilimits=</span><span class="s0">None,</span>
                         <span class="s1">useOffset=</span><span class="s0">None, </span><span class="s1">useLocale=</span><span class="s0">None, </span><span class="s1">useMathText=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">r&quot;&quot;&quot; 
        Configure the `.ScalarFormatter` used by default for linear Axes. 
 
        If a parameter is not set, the corresponding property of the formatter 
        is left unchanged. 
 
        Parameters 
        ---------- 
        axis : {'x', 'y', 'both'}, default: 'both' 
            The axis to configure.  Only major ticks are affected. 
 
        style : {'sci', 'scientific', 'plain'} 
            Whether to use scientific notation. 
            The formatter default is to use scientific notation. 
 
        scilimits : pair of ints (m, n) 
            Scientific notation is used only for numbers outside the range 
            10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is 
            configured to use scientific notation at all).  Use (0, 0) to 
            include all numbers.  Use (m, m) where m != 0 to fix the order of 
            magnitude to 10\ :sup:`m`. 
            The formatter default is :rc:`axes.formatter.limits`. 
 
        useOffset : bool or float 
            If True, the offset is calculated as needed. 
            If False, no offset is used. 
            If a numeric value, it sets the offset. 
            The formatter default is :rc:`axes.formatter.useoffset`. 
 
        useLocale : bool 
            Whether to format the number using the current locale or using the 
            C (English) locale.  This affects e.g. the decimal separator.  The 
            formatter default is :rc:`axes.formatter.use_locale`. 
 
        useMathText : bool 
            Render the offset and scientific notation in mathtext. 
            The formatter default is :rc:`axes.formatter.use_mathtext`. 
 
        Raises 
        ------ 
        AttributeError 
            If the current formatter is not a `.ScalarFormatter`. 
        &quot;&quot;&quot;</span>
        <span class="s1">style = style.lower()</span>
        <span class="s1">axis = axis.lower()</span>
        <span class="s0">if </span><span class="s1">scilimits </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">m</span><span class="s0">, </span><span class="s1">n = scilimits</span>
                <span class="s1">m + n + </span><span class="s5">1  </span><span class="s3"># check that both are numbers</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError) </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;scilimits must be a sequence of 2 integers&quot;</span>
                                 <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s1">STYLES = {</span><span class="s4">'sci'</span><span class="s1">: </span><span class="s0">True, </span><span class="s4">'scientific'</span><span class="s1">: </span><span class="s0">True, </span><span class="s4">'plain'</span><span class="s1">: </span><span class="s0">False, </span><span class="s4">''</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>
        <span class="s1">is_sci_style = _api.check_getitem(STYLES</span><span class="s0">, </span><span class="s1">style=style)</span>
        <span class="s1">axis_map = {**{k: [v] </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">self._axis_map.items()}</span><span class="s0">,</span>
                    <span class="s4">'both'</span><span class="s1">: list(self._axis_map.values())}</span>
        <span class="s1">axises = _api.check_getitem(axis_map</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">axises:</span>
                <span class="s0">if </span><span class="s1">is_sci_style </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.major.formatter.set_scientific(is_sci_style)</span>
                <span class="s0">if </span><span class="s1">scilimits </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.major.formatter.set_powerlimits(scilimits)</span>
                <span class="s0">if </span><span class="s1">useOffset </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.major.formatter.set_useOffset(useOffset)</span>
                <span class="s0">if </span><span class="s1">useLocale </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.major.formatter.set_useLocale(useLocale)</span>
                <span class="s0">if </span><span class="s1">useMathText </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">axis.major.formatter.set_useMathText(useMathText)</span>
        <span class="s0">except </span><span class="s1">AttributeError </span><span class="s0">as </span><span class="s1">err:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span>
                <span class="s4">&quot;This method only works with the ScalarFormatter&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>

    <span class="s0">def </span><span class="s1">locator_params(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s0">, </span><span class="s1">tight=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Control behavior of major tick locators. 
 
        Because the locator is involved in autoscaling, `~.Axes.autoscale_view` 
        is called automatically after the parameters are changed. 
 
        Parameters 
        ---------- 
        axis : {'both', 'x', 'y'}, default: 'both' 
            The axis on which to operate.  (For 3D Axes, *axis* can also be 
            set to 'z', and 'both' refers to all three axes.) 
        tight : bool or None, optional 
            Parameter passed to `~.Axes.autoscale_view`. 
            Default is None, for no change. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            Remaining keyword arguments are passed to directly to the 
            ``set_params()`` method of the locator. Supported keywords depend 
            on the type of the locator. See for example 
            `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator` 
            used by default for linear. 
 
        Examples 
        -------- 
        When plotting small subplots, one might want to reduce the maximum 
        number of ticks and use tight bounds, for example:: 
 
            ax.locator_params(tight=True, nbins=4) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([*self._axis_names</span><span class="s0">, </span><span class="s4">&quot;both&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._axis_names:</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[name</span><span class="s0">, </span><span class="s4">&quot;both&quot;</span><span class="s1">]:</span>
                <span class="s1">loc = self._axis_map[name].get_major_locator()</span>
                <span class="s1">loc.set_params(**kwargs)</span>
                <span class="s1">self._request_autoscale_view(name</span><span class="s0">, </span><span class="s1">tight=tight)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">tick_params(self</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">'both'</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Change the appearance of ticks, tick labels, and gridlines. 
 
        Tick properties that are not explicitly set using the keyword 
        arguments remain unchanged unless *reset* is True. For the current 
        style settings, see `.Axis.get_tick_params`. 
 
        Parameters 
        ---------- 
        axis : {'x', 'y', 'both'}, default: 'both' 
            The axis to which the parameters are applied. 
        which : {'major', 'minor', 'both'}, default: 'major' 
            The group of ticks to which the parameters are applied. 
        reset : bool, default: False 
            Whether to reset the ticks to defaults before updating them. 
 
        Other Parameters 
        ---------------- 
        direction : {'in', 'out', 'inout'} 
            Puts ticks inside the Axes, outside the Axes, or both. 
        length : float 
            Tick length in points. 
        width : float 
            Tick width in points. 
        color : color 
            Tick color. 
        pad : float 
            Distance in points between tick and label. 
        labelsize : float or str 
            Tick label font size in points or as a string (e.g., 'large'). 
        labelcolor : color 
            Tick label color. 
        colors : color 
            Tick color and label color. 
        zorder : float 
            Tick and label zorder. 
        bottom, top, left, right : bool 
            Whether to draw the respective ticks. 
        labelbottom, labeltop, labelleft, labelright : bool 
            Whether to draw the respective tick labels. 
        labelrotation : float 
            Tick label rotation 
        grid_color : color 
            Gridline color. 
        grid_alpha : float 
            Transparency of gridlines: 0 (transparent) to 1 (opaque). 
        grid_linewidth : float 
            Width of gridlines in points. 
        grid_linestyle : str 
            Any valid `.Line2D` line style spec. 
 
        Examples 
        -------- 
        :: 
 
            ax.tick_params(direction='out', length=6, width=2, colors='r', 
                           grid_color='r', grid_alpha=0.5) 
 
        This will make all major ticks be red, pointing out of the box, 
        and with dimensions 6 points by 2 points.  Tick labels will 
        also be red.  Gridlines will be red and translucent. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
            <span class="s1">xkw = dict(kwargs)</span>
            <span class="s1">xkw.pop(</span><span class="s4">'left'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">xkw.pop(</span><span class="s4">'right'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">xkw.pop(</span><span class="s4">'labelleft'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">xkw.pop(</span><span class="s4">'labelright'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">self.xaxis.set_tick_params(**xkw)</span>
        <span class="s0">if </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'both'</span><span class="s1">]:</span>
            <span class="s1">ykw = dict(kwargs)</span>
            <span class="s1">ykw.pop(</span><span class="s4">'top'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">ykw.pop(</span><span class="s4">'bottom'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">ykw.pop(</span><span class="s4">'labeltop'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">ykw.pop(</span><span class="s4">'labelbottom'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">self.yaxis.set_tick_params(**ykw)</span>

    <span class="s0">def </span><span class="s1">set_axis_off(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Turn the x- and y-axis off. 
 
        This affects the axis lines, ticks, ticklabels, grid and axis labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.axison = </span><span class="s0">False</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_axis_on(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Turn the x- and y-axis on. 
 
        This affects the axis lines, ticks, ticklabels, grid and axis labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.axison = </span><span class="s0">True</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s3"># data limits, ticks, tick labels, and formatting</span>

    <span class="s0">def </span><span class="s1">get_xlabel(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the xlabel text string. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = self.xaxis.get_label()</span>
        <span class="s0">return </span><span class="s1">label.get_text()</span>

    <span class="s0">def </span><span class="s1">set_xlabel(self</span><span class="s0">, </span><span class="s1">xlabel</span><span class="s0">, </span><span class="s1">fontdict=</span><span class="s0">None, </span><span class="s1">labelpad=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
                   <span class="s1">loc=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the label for the x-axis. 
 
        Parameters 
        ---------- 
        xlabel : str 
            The label text. 
 
        labelpad : float, default: :rc:`axes.labelpad` 
            Spacing in points from the Axes bounding box including ticks 
            and tick labels.  If None, the previous value is left as is. 
 
        loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation` 
            The label position. This is a high-level alternative for passing 
            parameters *x* and *horizontalalignment*. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Text` properties 
            `.Text` properties control the appearance of the label. 
 
        See Also 
        -------- 
        text : Documents the properties supported by `.Text`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">labelpad </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.xaxis.labelpad = labelpad</span>
        <span class="s1">protected_kw = [</span><span class="s4">'x'</span><span class="s0">, </span><span class="s4">'horizontalalignment'</span><span class="s0">, </span><span class="s4">'ha'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">{*kwargs} &amp; {*protected_kw}:</span>
            <span class="s0">if </span><span class="s1">loc </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Specifying 'loc' is disallowed when any of &quot;</span>
                                <span class="s4">f&quot;its corresponding low level keyword &quot;</span>
                                <span class="s4">f&quot;arguments (</span><span class="s0">{</span><span class="s1">protected_kw</span><span class="s0">}</span><span class="s4">) are also &quot;</span>
                                <span class="s4">f&quot;supplied&quot;</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">loc = (loc </span><span class="s0">if </span><span class="s1">loc </span><span class="s0">is not None</span>
                   <span class="s0">else </span><span class="s1">mpl.rcParams[</span><span class="s4">'xaxis.labellocation'</span><span class="s1">])</span>
            <span class="s1">_api.check_in_list((</span><span class="s4">'left'</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'right'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">loc=loc)</span>

            <span class="s1">x = {</span>
                <span class="s4">'left'</span><span class="s1">: </span><span class="s5">0</span><span class="s0">,</span>
                <span class="s4">'center'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s0">,</span>
                <span class="s4">'right'</span><span class="s1">: </span><span class="s5">1</span><span class="s0">,</span>
            <span class="s1">}[loc]</span>
            <span class="s1">kwargs.update(x=x</span><span class="s0">, </span><span class="s1">horizontalalignment=loc)</span>

        <span class="s0">return </span><span class="s1">self.xaxis.set_label_text(xlabel</span><span class="s0">, </span><span class="s1">fontdict</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">invert_xaxis(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Invert the x-axis. 
 
        See Also 
        -------- 
        xaxis_inverted 
        get_xlim, set_xlim 
        get_xbound, set_xbound 
        &quot;&quot;&quot;</span>
        <span class="s1">self.xaxis.set_inverted(</span><span class="s0">not </span><span class="s1">self.xaxis.get_inverted())</span>

    <span class="s1">xaxis_inverted = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_inverted&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_xbound(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the lower and upper x-axis bounds, in increasing order. 
 
        See Also 
        -------- 
        set_xbound 
        get_xlim, set_xlim 
        invert_xaxis, xaxis_inverted 
        &quot;&quot;&quot;</span>
        <span class="s1">left</span><span class="s0">, </span><span class="s1">right = self.get_xlim()</span>
        <span class="s0">if </span><span class="s1">left &lt; right:</span>
            <span class="s0">return </span><span class="s1">left</span><span class="s0">, </span><span class="s1">right</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">right</span><span class="s0">, </span><span class="s1">left</span>

    <span class="s0">def </span><span class="s1">set_xbound(self</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">None, </span><span class="s1">upper=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the lower and upper numerical bounds of the x-axis. 
 
        This method will honor axis inversion regardless of parameter order. 
        It will not change the autoscaling setting (`.get_autoscalex_on()`). 
 
        Parameters 
        ---------- 
        lower, upper : float or None 
            The lower and upper bounds. If *None*, the respective axis bound 
            is not modified. 
 
        See Also 
        -------- 
        get_xbound 
        get_xlim, set_xlim 
        invert_xaxis, xaxis_inverted 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">upper </span><span class="s0">is None and </span><span class="s1">np.iterable(lower):</span>
            <span class="s1">lower</span><span class="s0">, </span><span class="s1">upper = lower</span>

        <span class="s1">old_lower</span><span class="s0">, </span><span class="s1">old_upper = self.get_xbound()</span>
        <span class="s0">if </span><span class="s1">lower </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">lower = old_lower</span>
        <span class="s0">if </span><span class="s1">upper </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">upper = old_upper</span>

        <span class="s1">self.set_xlim(sorted((lower</span><span class="s0">, </span><span class="s1">upper)</span><span class="s0">,</span>
                             <span class="s1">reverse=bool(self.xaxis_inverted()))</span><span class="s0">,</span>
                      <span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_xlim(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the x-axis view limits. 
 
        Returns 
        ------- 
        left, right : (float, float) 
            The current x-axis limits in data coordinates. 
 
        See Also 
        -------- 
        .Axes.set_xlim 
        set_xbound, get_xbound 
        invert_xaxis, xaxis_inverted 
 
        Notes 
        ----- 
        The x-axis may be inverted, in which case the *left* value will 
        be greater than the *right* value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">tuple(self.viewLim.intervalx)</span>

    <span class="s0">def </span><span class="s1">_validate_converted_limits(self</span><span class="s0">, </span><span class="s1">limit</span><span class="s0">, </span><span class="s1">convert):</span>
        <span class="s2">&quot;&quot;&quot; 
        Raise ValueError if converted limits are non-finite. 
 
        Note that this function also accepts None as a limit argument. 
 
        Returns 
        ------- 
        The limit value after call to convert(), or None if limit is None. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">limit </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">converted_limit = convert(limit)</span>
            <span class="s0">if </span><span class="s1">(isinstance(converted_limit</span><span class="s0">, </span><span class="s1">Real)</span>
                    <span class="s0">and not </span><span class="s1">np.isfinite(converted_limit)):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Axis limits cannot be NaN or Inf&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">converted_limit</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s4">&quot;emit&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_xlim(self</span><span class="s0">, </span><span class="s1">left=</span><span class="s0">None, </span><span class="s1">right=</span><span class="s0">None, </span><span class="s1">emit=</span><span class="s0">True, </span><span class="s1">auto=</span><span class="s0">False,</span>
                 <span class="s1">*</span><span class="s0">, </span><span class="s1">xmin=</span><span class="s0">None, </span><span class="s1">xmax=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the x-axis view limits. 
 
        Parameters 
        ---------- 
        left : float, optional 
            The left xlim in data coordinates. Passing *None* leaves the 
            limit unchanged. 
 
            The left and right xlims may also be passed as the tuple 
            (*left*, *right*) as the first positional argument (or as 
            the *left* keyword argument). 
 
            .. ACCEPTS: (bottom: float, top: float) 
 
        right : float, optional 
            The right xlim in data coordinates. Passing *None* leaves the 
            limit unchanged. 
 
        emit : bool, default: True 
            Whether to notify observers of limit change. 
 
        auto : bool or None, default: False 
            Whether to turn on autoscaling of the x-axis. True turns on, 
            False turns off, None leaves unchanged. 
 
        xmin, xmax : float, optional 
            They are equivalent to left and right respectively, and it is an 
            error to pass both *xmin* and *left* or *xmax* and *right*. 
 
        Returns 
        ------- 
        left, right : (float, float) 
            The new x-axis limits in data coordinates. 
 
        See Also 
        -------- 
        get_xlim 
        set_xbound, get_xbound 
        invert_xaxis, xaxis_inverted 
 
        Notes 
        ----- 
        The *left* value may be greater than the *right* value, in which 
        case the x-axis values will decrease from left to right. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; set_xlim(left, right) 
        &gt;&gt;&gt; set_xlim((left, right)) 
        &gt;&gt;&gt; left, right = set_xlim(left, right) 
 
        One limit may be left unchanged. 
 
        &gt;&gt;&gt; set_xlim(right=right_lim) 
 
        Limits may be passed in reverse order to flip the direction of 
        the x-axis. For example, suppose *x* represents the number of 
        years before present. The x-axis limits might be set like the 
        following so 5000 years ago is on the left of the plot and the 
        present is on the right. 
 
        &gt;&gt;&gt; set_xlim(5000, 0) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">right </span><span class="s0">is None and </span><span class="s1">np.iterable(left):</span>
            <span class="s1">left</span><span class="s0">, </span><span class="s1">right = left</span>
        <span class="s0">if </span><span class="s1">xmin </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">left </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot pass both 'left' and 'xmin'&quot;</span><span class="s1">)</span>
            <span class="s1">left = xmin</span>
        <span class="s0">if </span><span class="s1">xmax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">right </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot pass both 'right' and 'xmax'&quot;</span><span class="s1">)</span>
            <span class="s1">right = xmax</span>
        <span class="s0">return </span><span class="s1">self.xaxis._set_lim(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=auto)</span>

    <span class="s1">get_xscale = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_scale&quot;</span><span class="s1">)</span>
    <span class="s1">set_xscale = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_set_axes_scale&quot;</span><span class="s1">)</span>
    <span class="s1">get_xticks = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklocs&quot;</span><span class="s1">)</span>
    <span class="s1">set_xticks = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;set_ticks&quot;</span><span class="s1">)</span>
    <span class="s1">get_xmajorticklabels = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_majorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_xminorticklabels = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_minorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_xticklabels = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">set_xticklabels = _axis_method_wrapper(</span>
        <span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;set_ticklabels&quot;</span><span class="s0">,</span>
        <span class="s1">doc_sub={</span><span class="s4">&quot;Axis.set_ticks&quot;</span><span class="s1">: </span><span class="s4">&quot;Axes.set_xticks&quot;</span><span class="s1">})</span>

    <span class="s0">def </span><span class="s1">get_ylabel(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the ylabel text string. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = self.yaxis.get_label()</span>
        <span class="s0">return </span><span class="s1">label.get_text()</span>

    <span class="s0">def </span><span class="s1">set_ylabel(self</span><span class="s0">, </span><span class="s1">ylabel</span><span class="s0">, </span><span class="s1">fontdict=</span><span class="s0">None, </span><span class="s1">labelpad=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">,</span>
                   <span class="s1">loc=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the label for the y-axis. 
 
        Parameters 
        ---------- 
        ylabel : str 
            The label text. 
 
        labelpad : float, default: :rc:`axes.labelpad` 
            Spacing in points from the Axes bounding box including ticks 
            and tick labels.  If None, the previous value is left as is. 
 
        loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation` 
            The label position. This is a high-level alternative for passing 
            parameters *y* and *horizontalalignment*. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Text` properties 
            `.Text` properties control the appearance of the label. 
 
        See Also 
        -------- 
        text : Documents the properties supported by `.Text`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">labelpad </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.yaxis.labelpad = labelpad</span>
        <span class="s1">protected_kw = [</span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'horizontalalignment'</span><span class="s0">, </span><span class="s4">'ha'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">{*kwargs} &amp; {*protected_kw}:</span>
            <span class="s0">if </span><span class="s1">loc </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Specifying 'loc' is disallowed when any of &quot;</span>
                                <span class="s4">f&quot;its corresponding low level keyword &quot;</span>
                                <span class="s4">f&quot;arguments (</span><span class="s0">{</span><span class="s1">protected_kw</span><span class="s0">}</span><span class="s4">) are also &quot;</span>
                                <span class="s4">f&quot;supplied&quot;</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">loc = (loc </span><span class="s0">if </span><span class="s1">loc </span><span class="s0">is not None</span>
                   <span class="s0">else </span><span class="s1">mpl.rcParams[</span><span class="s4">'yaxis.labellocation'</span><span class="s1">])</span>
            <span class="s1">_api.check_in_list((</span><span class="s4">'bottom'</span><span class="s0">, </span><span class="s4">'center'</span><span class="s0">, </span><span class="s4">'top'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">loc=loc)</span>

            <span class="s1">y</span><span class="s0">, </span><span class="s1">ha = {</span>
                <span class="s4">'bottom'</span><span class="s1">: (</span><span class="s5">0</span><span class="s0">, </span><span class="s4">'left'</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s4">'center'</span><span class="s1">: (</span><span class="s5">0.5</span><span class="s0">, </span><span class="s4">'center'</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s4">'top'</span><span class="s1">: (</span><span class="s5">1</span><span class="s0">, </span><span class="s4">'right'</span><span class="s1">)</span>
            <span class="s1">}[loc]</span>
            <span class="s1">kwargs.update(y=y</span><span class="s0">, </span><span class="s1">horizontalalignment=ha)</span>

        <span class="s0">return </span><span class="s1">self.yaxis.set_label_text(ylabel</span><span class="s0">, </span><span class="s1">fontdict</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">invert_yaxis(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Invert the y-axis. 
 
        See Also 
        -------- 
        yaxis_inverted 
        get_ylim, set_ylim 
        get_ybound, set_ybound 
        &quot;&quot;&quot;</span>
        <span class="s1">self.yaxis.set_inverted(</span><span class="s0">not </span><span class="s1">self.yaxis.get_inverted())</span>

    <span class="s1">yaxis_inverted = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_inverted&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_ybound(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the lower and upper y-axis bounds, in increasing order. 
 
        See Also 
        -------- 
        set_ybound 
        get_ylim, set_ylim 
        invert_yaxis, yaxis_inverted 
        &quot;&quot;&quot;</span>
        <span class="s1">bottom</span><span class="s0">, </span><span class="s1">top = self.get_ylim()</span>
        <span class="s0">if </span><span class="s1">bottom &lt; top:</span>
            <span class="s0">return </span><span class="s1">bottom</span><span class="s0">, </span><span class="s1">top</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">top</span><span class="s0">, </span><span class="s1">bottom</span>

    <span class="s0">def </span><span class="s1">set_ybound(self</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">None, </span><span class="s1">upper=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the lower and upper numerical bounds of the y-axis. 
 
        This method will honor axis inversion regardless of parameter order. 
        It will not change the autoscaling setting (`.get_autoscaley_on()`). 
 
        Parameters 
        ---------- 
        lower, upper : float or None 
            The lower and upper bounds. If *None*, the respective axis bound 
            is not modified. 
 
        See Also 
        -------- 
        get_ybound 
        get_ylim, set_ylim 
        invert_yaxis, yaxis_inverted 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">upper </span><span class="s0">is None and </span><span class="s1">np.iterable(lower):</span>
            <span class="s1">lower</span><span class="s0">, </span><span class="s1">upper = lower</span>

        <span class="s1">old_lower</span><span class="s0">, </span><span class="s1">old_upper = self.get_ybound()</span>
        <span class="s0">if </span><span class="s1">lower </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">lower = old_lower</span>
        <span class="s0">if </span><span class="s1">upper </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">upper = old_upper</span>

        <span class="s1">self.set_ylim(sorted((lower</span><span class="s0">, </span><span class="s1">upper)</span><span class="s0">,</span>
                             <span class="s1">reverse=bool(self.yaxis_inverted()))</span><span class="s0">,</span>
                      <span class="s1">auto=</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_ylim(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the y-axis view limits. 
 
        Returns 
        ------- 
        bottom, top : (float, float) 
            The current y-axis limits in data coordinates. 
 
        See Also 
        -------- 
        .Axes.set_ylim 
        set_ybound, get_ybound 
        invert_yaxis, yaxis_inverted 
 
        Notes 
        ----- 
        The y-axis may be inverted, in which case the *bottom* value 
        will be greater than the *top* value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">tuple(self.viewLim.intervaly)</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s0">, </span><span class="s4">&quot;emit&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">set_ylim(self</span><span class="s0">, </span><span class="s1">bottom=</span><span class="s0">None, </span><span class="s1">top=</span><span class="s0">None, </span><span class="s1">emit=</span><span class="s0">True, </span><span class="s1">auto=</span><span class="s0">False,</span>
                 <span class="s1">*</span><span class="s0">, </span><span class="s1">ymin=</span><span class="s0">None, </span><span class="s1">ymax=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the y-axis view limits. 
 
        Parameters 
        ---------- 
        bottom : float, optional 
            The bottom ylim in data coordinates. Passing *None* leaves the 
            limit unchanged. 
 
            The bottom and top ylims may also be passed as the tuple 
            (*bottom*, *top*) as the first positional argument (or as 
            the *bottom* keyword argument). 
 
            .. ACCEPTS: (bottom: float, top: float) 
 
        top : float, optional 
            The top ylim in data coordinates. Passing *None* leaves the 
            limit unchanged. 
 
        emit : bool, default: True 
            Whether to notify observers of limit change. 
 
        auto : bool or None, default: False 
            Whether to turn on autoscaling of the y-axis. *True* turns on, 
            *False* turns off, *None* leaves unchanged. 
 
        ymin, ymax : float, optional 
            They are equivalent to bottom and top respectively, and it is an 
            error to pass both *ymin* and *bottom* or *ymax* and *top*. 
 
        Returns 
        ------- 
        bottom, top : (float, float) 
            The new y-axis limits in data coordinates. 
 
        See Also 
        -------- 
        get_ylim 
        set_ybound, get_ybound 
        invert_yaxis, yaxis_inverted 
 
        Notes 
        ----- 
        The *bottom* value may be greater than the *top* value, in which 
        case the y-axis values will decrease from *bottom* to *top*. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; set_ylim(bottom, top) 
        &gt;&gt;&gt; set_ylim((bottom, top)) 
        &gt;&gt;&gt; bottom, top = set_ylim(bottom, top) 
 
        One limit may be left unchanged. 
 
        &gt;&gt;&gt; set_ylim(top=top_lim) 
 
        Limits may be passed in reverse order to flip the direction of 
        the y-axis. For example, suppose ``y`` represents depth of the 
        ocean in m. The y-axis limits might be set like the following 
        so 5000 m depth is at the bottom of the plot and the surface, 
        0 m, is at the top. 
 
        &gt;&gt;&gt; set_ylim(5000, 0) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">top </span><span class="s0">is None and </span><span class="s1">np.iterable(bottom):</span>
            <span class="s1">bottom</span><span class="s0">, </span><span class="s1">top = bottom</span>
        <span class="s0">if </span><span class="s1">ymin </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">bottom </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot pass both 'bottom' and 'ymin'&quot;</span><span class="s1">)</span>
            <span class="s1">bottom = ymin</span>
        <span class="s0">if </span><span class="s1">ymax </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">top </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot pass both 'top' and 'ymax'&quot;</span><span class="s1">)</span>
            <span class="s1">top = ymax</span>
        <span class="s0">return </span><span class="s1">self.yaxis._set_lim(bottom</span><span class="s0">, </span><span class="s1">top</span><span class="s0">, </span><span class="s1">emit=emit</span><span class="s0">, </span><span class="s1">auto=auto)</span>

    <span class="s1">get_yscale = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_scale&quot;</span><span class="s1">)</span>
    <span class="s1">set_yscale = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;_set_axes_scale&quot;</span><span class="s1">)</span>
    <span class="s1">get_yticks = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklocs&quot;</span><span class="s1">)</span>
    <span class="s1">set_yticks = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;set_ticks&quot;</span><span class="s1">)</span>
    <span class="s1">get_ymajorticklabels = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_majorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_yminorticklabels = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_minorticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">get_yticklabels = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;get_ticklabels&quot;</span><span class="s1">)</span>
    <span class="s1">set_yticklabels = _axis_method_wrapper(</span>
        <span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;set_ticklabels&quot;</span><span class="s0">,</span>
        <span class="s1">doc_sub={</span><span class="s4">&quot;Axis.set_ticks&quot;</span><span class="s1">: </span><span class="s4">&quot;Axes.set_yticks&quot;</span><span class="s1">})</span>

    <span class="s1">xaxis_date = _axis_method_wrapper(</span><span class="s4">&quot;xaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;axis_date&quot;</span><span class="s1">)</span>
    <span class="s1">yaxis_date = _axis_method_wrapper(</span><span class="s4">&quot;yaxis&quot;</span><span class="s0">, </span><span class="s4">&quot;axis_date&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">format_xdata(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return *x* formatted as an x-value. 
 
        This function will use the `.fmt_xdata` attribute if it is not None, 
        else will fall back on the xaxis major formatter. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(self.fmt_xdata </span><span class="s0">if </span><span class="s1">self.fmt_xdata </span><span class="s0">is not None</span>
                <span class="s0">else </span><span class="s1">self.xaxis.get_major_formatter().format_data_short)(x)</span>

    <span class="s0">def </span><span class="s1">format_ydata(self</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return *y* formatted as a y-value. 
 
        This function will use the `.fmt_ydata` attribute if it is not None, 
        else will fall back on the yaxis major formatter. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(self.fmt_ydata </span><span class="s0">if </span><span class="s1">self.fmt_ydata </span><span class="s0">is not None</span>
                <span class="s0">else </span><span class="s1">self.yaxis.get_major_formatter().format_data_short)(y)</span>

    <span class="s0">def </span><span class="s1">format_coord(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s2">&quot;&quot;&quot;Return a format string formatting the *x*, *y* coordinates.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s4">&quot;x={} y={}&quot;</span><span class="s1">.format(</span>
            <span class="s4">&quot;???&quot; </span><span class="s0">if </span><span class="s1">x </span><span class="s0">is None else </span><span class="s1">self.format_xdata(x)</span><span class="s0">,</span>
            <span class="s4">&quot;???&quot; </span><span class="s0">if </span><span class="s1">y </span><span class="s0">is None else </span><span class="s1">self.format_ydata(y)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">minorticks_on(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Display minor ticks on the Axes. 
 
        Displaying minor ticks may reduce performance; you may turn them off 
        using `minorticks_off()` if drawing speed is a problem. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">(self.xaxis</span><span class="s0">, </span><span class="s1">self.yaxis):</span>
            <span class="s1">scale = ax.get_scale()</span>
            <span class="s0">if </span><span class="s1">scale == </span><span class="s4">'log'</span><span class="s1">:</span>
                <span class="s1">s = ax._scale</span>
                <span class="s1">ax.set_minor_locator(mticker.LogLocator(s.base</span><span class="s0">, </span><span class="s1">s.subs))</span>
            <span class="s0">elif </span><span class="s1">scale == </span><span class="s4">'symlog'</span><span class="s1">:</span>
                <span class="s1">s = ax._scale</span>
                <span class="s1">ax.set_minor_locator(</span>
                    <span class="s1">mticker.SymmetricalLogLocator(s._transform</span><span class="s0">, </span><span class="s1">s.subs))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ax.set_minor_locator(mticker.AutoMinorLocator())</span>

    <span class="s0">def </span><span class="s1">minorticks_off(self):</span>
        <span class="s2">&quot;&quot;&quot;Remove minor ticks from the Axes.&quot;&quot;&quot;</span>
        <span class="s1">self.xaxis.set_minor_locator(mticker.NullLocator())</span>
        <span class="s1">self.yaxis.set_minor_locator(mticker.NullLocator())</span>

    <span class="s3"># Interactive manipulation</span>

    <span class="s0">def </span><span class="s1">can_zoom(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports the zoom box button functionality. 
        &quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">can_pan(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether this Axes supports any pan/zoom button functionality. 
        &quot;&quot;&quot;</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">get_navigate(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get whether the Axes responds to navigation commands. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._navigate</span>

    <span class="s0">def </span><span class="s1">set_navigate(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether the Axes responds to navigation toolbar commands. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._navigate = b</span>

    <span class="s0">def </span><span class="s1">get_navigate_mode(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the navigation toolbar button status: 'PAN', 'ZOOM', or None. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._navigate_mode</span>

    <span class="s0">def </span><span class="s1">set_navigate_mode(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the navigation toolbar button status. 
 
        .. warning:: 
            This is not a user-API function. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._navigate_mode = b</span>

    <span class="s0">def </span><span class="s1">_get_view(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Save information required to reproduce the current view. 
 
        Called before a view is changed, such as during a pan or zoom 
        initiated by the user. You may return any information you deem 
        necessary to describe the view. 
 
        .. note:: 
 
            Intended to be overridden by new projection types, but if not, the 
            default implementation saves the view limits. You *must* implement 
            :meth:`_set_view` if you implement this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = self.get_xlim()</span>
        <span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = self.get_ylim()</span>
        <span class="s0">return </span><span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax</span>

    <span class="s0">def </span><span class="s1">_set_view(self</span><span class="s0">, </span><span class="s1">view):</span>
        <span class="s2">&quot;&quot;&quot; 
        Apply a previously saved view. 
 
        Called when restoring a view, such as with the navigation buttons. 
 
        .. note:: 
 
            Intended to be overridden by new projection types, but if not, the 
            default implementation restores the view limits. You *must* 
            implement :meth:`_get_view` if you implement this method. 
        &quot;&quot;&quot;</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax</span><span class="s0">, </span><span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = view</span>
        <span class="s1">self.set_xlim((xmin</span><span class="s0">, </span><span class="s1">xmax))</span>
        <span class="s1">self.set_ylim((ymin</span><span class="s0">, </span><span class="s1">ymax))</span>

    <span class="s0">def </span><span class="s1">_prepare_view_from_bbox(self</span><span class="s0">, </span><span class="s1">bbox</span><span class="s0">, </span><span class="s1">direction=</span><span class="s4">'in'</span><span class="s0">,</span>
                                <span class="s1">mode=</span><span class="s0">None, </span><span class="s1">twinx=</span><span class="s0">False, </span><span class="s1">twiny=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Helper function to prepare the new bounds from a bbox. 
 
        This helper function returns the new x and y bounds from the zoom 
        bbox. This a convenience method to abstract the bbox logic 
        out of the base setter. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(bbox) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">xp</span><span class="s0">, </span><span class="s1">yp</span><span class="s0">, </span><span class="s1">scl = bbox  </span><span class="s3"># Zooming code</span>
            <span class="s0">if </span><span class="s1">scl == </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># Should not happen</span>
                <span class="s1">scl = </span><span class="s5">1.</span>
            <span class="s0">if </span><span class="s1">scl &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">direction = </span><span class="s4">'in'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">direction = </span><span class="s4">'out'</span>
                <span class="s1">scl = </span><span class="s5">1</span><span class="s1">/scl</span>
            <span class="s3"># get the limits of the axes</span>
            <span class="s1">(xmin</span><span class="s0">, </span><span class="s1">ymin)</span><span class="s0">, </span><span class="s1">(xmax</span><span class="s0">, </span><span class="s1">ymax) = self.transData.transform(</span>
                <span class="s1">np.transpose([self.get_xlim()</span><span class="s0">, </span><span class="s1">self.get_ylim()]))</span>
            <span class="s3"># set the range</span>
            <span class="s1">xwidth = xmax - xmin</span>
            <span class="s1">ywidth = ymax - ymin</span>
            <span class="s1">xcen = (xmax + xmin)*</span><span class="s5">.5</span>
            <span class="s1">ycen = (ymax + ymin)*</span><span class="s5">.5</span>
            <span class="s1">xzc = (xp*(scl - </span><span class="s5">1</span><span class="s1">) + xcen)/scl</span>
            <span class="s1">yzc = (yp*(scl - </span><span class="s5">1</span><span class="s1">) + ycen)/scl</span>
            <span class="s1">bbox = [xzc - xwidth/</span><span class="s5">2.</span><span class="s1">/scl</span><span class="s0">, </span><span class="s1">yzc - ywidth/</span><span class="s5">2.</span><span class="s1">/scl</span><span class="s0">,</span>
                    <span class="s1">xzc + xwidth/</span><span class="s5">2.</span><span class="s1">/scl</span><span class="s0">, </span><span class="s1">yzc + ywidth/</span><span class="s5">2.</span><span class="s1">/scl]</span>
        <span class="s0">elif </span><span class="s1">len(bbox) != </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s3"># should be len 3 or 4 but nothing else</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s4">&quot;Warning in _set_view_from_bbox: bounding box is not a tuple &quot;</span>
                <span class="s4">&quot;of length 3 or 4. Ignoring the view change.&quot;</span><span class="s1">)</span>
            <span class="s0">return</span>

        <span class="s3"># Original limits.</span>
        <span class="s1">xmin0</span><span class="s0">, </span><span class="s1">xmax0 = self.get_xbound()</span>
        <span class="s1">ymin0</span><span class="s0">, </span><span class="s1">ymax0 = self.get_ybound()</span>
        <span class="s3"># The zoom box in screen coords.</span>
        <span class="s1">startx</span><span class="s0">, </span><span class="s1">starty</span><span class="s0">, </span><span class="s1">stopx</span><span class="s0">, </span><span class="s1">stopy = bbox</span>
        <span class="s3"># Convert to data coords.</span>
        <span class="s1">(startx</span><span class="s0">, </span><span class="s1">starty)</span><span class="s0">, </span><span class="s1">(stopx</span><span class="s0">, </span><span class="s1">stopy) = self.transData.inverted().transform(</span>
            <span class="s1">[(startx</span><span class="s0">, </span><span class="s1">starty)</span><span class="s0">, </span><span class="s1">(stopx</span><span class="s0">, </span><span class="s1">stopy)])</span>
        <span class="s3"># Clip to axes limits.</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = np.clip(sorted([startx</span><span class="s0">, </span><span class="s1">stopx])</span><span class="s0">, </span><span class="s1">xmin0</span><span class="s0">, </span><span class="s1">xmax0)</span>
        <span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = np.clip(sorted([starty</span><span class="s0">, </span><span class="s1">stopy])</span><span class="s0">, </span><span class="s1">ymin0</span><span class="s0">, </span><span class="s1">ymax0)</span>
        <span class="s3"># Don't double-zoom twinned axes or if zooming only the other axis.</span>
        <span class="s0">if </span><span class="s1">twinx </span><span class="s0">or </span><span class="s1">mode == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = xmin0</span><span class="s0">, </span><span class="s1">xmax0</span>
        <span class="s0">if </span><span class="s1">twiny </span><span class="s0">or </span><span class="s1">mode == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax = ymin0</span><span class="s0">, </span><span class="s1">ymax0</span>

        <span class="s0">if </span><span class="s1">direction == </span><span class="s4">&quot;in&quot;</span><span class="s1">:</span>
            <span class="s1">new_xbound = xmin</span><span class="s0">, </span><span class="s1">xmax</span>
            <span class="s1">new_ybound = ymin</span><span class="s0">, </span><span class="s1">ymax</span>

        <span class="s0">elif </span><span class="s1">direction == </span><span class="s4">&quot;out&quot;</span><span class="s1">:</span>
            <span class="s1">x_trf = self.xaxis.get_transform()</span>
            <span class="s1">sxmin0</span><span class="s0">, </span><span class="s1">sxmax0</span><span class="s0">, </span><span class="s1">sxmin</span><span class="s0">, </span><span class="s1">sxmax = x_trf.transform(</span>
                <span class="s1">[xmin0</span><span class="s0">, </span><span class="s1">xmax0</span><span class="s0">, </span><span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax])  </span><span class="s3"># To screen space.</span>
            <span class="s1">factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  </span><span class="s3"># Unzoom factor.</span>
            <span class="s3"># Move original bounds away by</span>
            <span class="s3"># (factor) x (distance between unzoom box and Axes bbox).</span>
            <span class="s1">sxmin1 = sxmin0 - factor * (sxmin - sxmin0)</span>
            <span class="s1">sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)</span>
            <span class="s3"># And back to data space.</span>
            <span class="s1">new_xbound = x_trf.inverted().transform([sxmin1</span><span class="s0">, </span><span class="s1">sxmax1])</span>

            <span class="s1">y_trf = self.yaxis.get_transform()</span>
            <span class="s1">symin0</span><span class="s0">, </span><span class="s1">symax0</span><span class="s0">, </span><span class="s1">symin</span><span class="s0">, </span><span class="s1">symax = y_trf.transform(</span>
                <span class="s1">[ymin0</span><span class="s0">, </span><span class="s1">ymax0</span><span class="s0">, </span><span class="s1">ymin</span><span class="s0">, </span><span class="s1">ymax])</span>
            <span class="s1">factor = (symax0 - symin0) / (symax - symin)</span>
            <span class="s1">symin1 = symin0 - factor * (symin - symin0)</span>
            <span class="s1">symax1 = symax0 + factor * (symax0 - symax)</span>
            <span class="s1">new_ybound = y_trf.inverted().transform([symin1</span><span class="s0">, </span><span class="s1">symax1])</span>

        <span class="s0">return </span><span class="s1">new_xbound</span><span class="s0">, </span><span class="s1">new_ybound</span>

    <span class="s0">def </span><span class="s1">_set_view_from_bbox(self</span><span class="s0">, </span><span class="s1">bbox</span><span class="s0">, </span><span class="s1">direction=</span><span class="s4">'in'</span><span class="s0">,</span>
                            <span class="s1">mode=</span><span class="s0">None, </span><span class="s1">twinx=</span><span class="s0">False, </span><span class="s1">twiny=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Update view from a selection bbox. 
 
        .. note:: 
 
            Intended to be overridden by new projection types, but if not, the 
            default implementation sets the view limits to the bbox directly. 
 
        Parameters 
        ---------- 
        bbox : 4-tuple or 3 tuple 
            * If bbox is a 4 tuple, it is the selected bounding box limits, 
              in *display* coordinates. 
            * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where 
              (xp, yp) is the center of zooming and scl the scale factor to 
              zoom by. 
 
        direction : str 
            The direction to apply the bounding box. 
                * `'in'` - The bounding box describes the view directly, i.e., 
                           it zooms in. 
                * `'out'` - The bounding box describes the size to make the 
                            existing view, i.e., it zooms out. 
 
        mode : str or None 
            The selection mode, whether to apply the bounding box in only the 
            `'x'` direction, `'y'` direction or both (`None`). 
 
        twinx : bool 
            Whether this axis is twinned in the *x*-direction. 
 
        twiny : bool 
            Whether this axis is twinned in the *y*-direction. 
        &quot;&quot;&quot;</span>
        <span class="s1">new_xbound</span><span class="s0">, </span><span class="s1">new_ybound = self._prepare_view_from_bbox(</span>
            <span class="s1">bbox</span><span class="s0">, </span><span class="s1">direction=direction</span><span class="s0">, </span><span class="s1">mode=mode</span><span class="s0">, </span><span class="s1">twinx=twinx</span><span class="s0">, </span><span class="s1">twiny=twiny)</span>
        <span class="s0">if not </span><span class="s1">twinx </span><span class="s0">and </span><span class="s1">mode != </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">self.set_xbound(new_xbound)</span>
            <span class="s1">self.set_autoscalex_on(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">twiny </span><span class="s0">and </span><span class="s1">mode != </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">self.set_ybound(new_ybound)</span>
            <span class="s1">self.set_autoscaley_on(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">start_pan(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">button):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called when a pan operation has started. 
 
        Parameters 
        ---------- 
        x, y : float 
            The mouse coordinates in display coords. 
        button : `.MouseButton` 
            The pressed mouse button. 
 
        Notes 
        ----- 
        This is intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._pan_start = types.SimpleNamespace(</span>
            <span class="s1">lim=self.viewLim.frozen()</span><span class="s0">,</span>
            <span class="s1">trans=self.transData.frozen()</span><span class="s0">,</span>
            <span class="s1">trans_inverse=self.transData.inverted().frozen()</span><span class="s0">,</span>
            <span class="s1">bbox=self.bbox.frozen()</span><span class="s0">,</span>
            <span class="s1">x=x</span><span class="s0">,</span>
            <span class="s1">y=y)</span>

    <span class="s0">def </span><span class="s1">end_pan(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called when a pan operation completes (when the mouse button is up.) 
 
        Notes 
        ----- 
        This is intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s0">del </span><span class="s1">self._pan_start</span>

    <span class="s0">def </span><span class="s1">_get_pan_points(self</span><span class="s0">, </span><span class="s1">button</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s2">&quot;&quot;&quot; 
        Helper function to return the new points after a pan. 
 
        This helper function returns the points on the axis after a pan has 
        occurred. This is a convenience method to abstract the pan logic 
        out of the base setter. 
        &quot;&quot;&quot;</span>
        <span class="s0">def </span><span class="s1">format_deltas(key</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy):</span>
            <span class="s0">if </span><span class="s1">key == </span><span class="s4">'control'</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">abs(dx) &gt; abs(dy):</span>
                    <span class="s1">dy = dx</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">dx = dy</span>
            <span class="s0">elif </span><span class="s1">key == </span><span class="s4">'x'</span><span class="s1">:</span>
                <span class="s1">dy = </span><span class="s5">0</span>
            <span class="s0">elif </span><span class="s1">key == </span><span class="s4">'y'</span><span class="s1">:</span>
                <span class="s1">dx = </span><span class="s5">0</span>
            <span class="s0">elif </span><span class="s1">key == </span><span class="s4">'shift'</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s5">2 </span><span class="s1">* abs(dx) &lt; abs(dy):</span>
                    <span class="s1">dx = </span><span class="s5">0</span>
                <span class="s0">elif </span><span class="s5">2 </span><span class="s1">* abs(dy) &lt; abs(dx):</span>
                    <span class="s1">dy = </span><span class="s5">0</span>
                <span class="s0">elif </span><span class="s1">abs(dx) &gt; abs(dy):</span>
                    <span class="s1">dy = dy / abs(dy) * abs(dx)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">dx = dx / abs(dx) * abs(dy)</span>
            <span class="s0">return </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy</span>

        <span class="s1">p = self._pan_start</span>
        <span class="s1">dx = x - p.x</span>
        <span class="s1">dy = y - p.y</span>
        <span class="s0">if </span><span class="s1">dx == dy == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">button == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy = format_deltas(key</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy)</span>
            <span class="s1">result = p.bbox.translated(-dx</span><span class="s0">, </span><span class="s1">-dy).transformed(p.trans_inverse)</span>
        <span class="s0">elif </span><span class="s1">button == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">dx = -dx / self.bbox.width</span>
                <span class="s1">dy = -dy / self.bbox.height</span>
                <span class="s1">dx</span><span class="s0">, </span><span class="s1">dy = format_deltas(key</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy)</span>
                <span class="s0">if </span><span class="s1">self.get_aspect() != </span><span class="s4">'auto'</span><span class="s1">:</span>
                    <span class="s1">dx = dy = </span><span class="s5">0.5 </span><span class="s1">* (dx + dy)</span>
                <span class="s1">alpha = np.power(</span><span class="s5">10.0</span><span class="s0">, </span><span class="s1">(dx</span><span class="s0">, </span><span class="s1">dy))</span>
                <span class="s1">start = np.array([p.x</span><span class="s0">, </span><span class="s1">p.y])</span>
                <span class="s1">oldpoints = p.lim.transformed(p.trans)</span>
                <span class="s1">newpoints = start + alpha * (oldpoints - start)</span>
                <span class="s1">result = (mtransforms.Bbox(newpoints)</span>
                          <span class="s1">.transformed(p.trans_inverse))</span>
            <span class="s0">except </span><span class="s1">OverflowError:</span>
                <span class="s1">_api.warn_external(</span><span class="s4">'Overflow while panning'</span><span class="s1">)</span>
                <span class="s0">return</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s1">valid = np.isfinite(result.transformed(p.trans))</span>
        <span class="s1">points = result.get_points().astype(object)</span>
        <span class="s3"># Just ignore invalid limits (typically, underflow in log-scale).</span>
        <span class="s1">points[~valid] = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">points</span>

    <span class="s0">def </span><span class="s1">drag_pan(self</span><span class="s0">, </span><span class="s1">button</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s2">&quot;&quot;&quot; 
        Called when the mouse moves during a pan operation. 
 
        Parameters 
        ---------- 
        button : `.MouseButton` 
            The pressed mouse button. 
        key : str or None 
            The pressed key, if any. 
        x, y : float 
            The mouse coordinates in display coords. 
 
        Notes 
        ----- 
        This is intended to be overridden by new projection types. 
        &quot;&quot;&quot;</span>
        <span class="s1">points = self._get_pan_points(button</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_xlim(points[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">self.set_ylim(points[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">get_children(self):</span>
        <span class="s3"># docstring inherited.</span>
        <span class="s0">return </span><span class="s1">[</span>
            <span class="s1">*self._children</span><span class="s0">,</span>
            <span class="s1">*self.spines.values()</span><span class="s0">,</span>
            <span class="s1">*self._axis_map.values()</span><span class="s0">,</span>
            <span class="s1">self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title</span><span class="s0">,</span>
            <span class="s1">*self.child_axes</span><span class="s0">,</span>
            <span class="s1">*([self.legend_] </span><span class="s0">if </span><span class="s1">self.legend_ </span><span class="s0">is not None else </span><span class="s1">[])</span><span class="s0">,</span>
            <span class="s1">self.patch</span><span class="s0">,</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">contains(self</span><span class="s0">, </span><span class="s1">mouseevent):</span>
        <span class="s3"># docstring inherited.</span>
        <span class="s1">inside</span><span class="s0">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s0">if </span><span class="s1">inside </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">inside</span><span class="s0">, </span><span class="s1">info</span>
        <span class="s0">return </span><span class="s1">self.patch.contains(mouseevent)</span>

    <span class="s0">def </span><span class="s1">contains_point(self</span><span class="s0">, </span><span class="s1">point):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether *point* (pair of pixel coordinates) is inside the Axes 
        patch. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.patch.contains_point(point</span><span class="s0">, </span><span class="s1">radius=</span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_default_bbox_extra_artists(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a default list of artists that are used for the bounding box 
        calculation. 
 
        Artists are excluded either by not being visible or 
        ``artist.set_in_layout(False)``. 
        &quot;&quot;&quot;</span>

        <span class="s1">artists = self.get_children()</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
            <span class="s3"># axis tight bboxes are calculated separately inside</span>
            <span class="s3"># Axes.get_tightbbox() using for_layout_only=True</span>
            <span class="s1">artists.remove(axis)</span>
        <span class="s0">if not </span><span class="s1">(self.axison </span><span class="s0">and </span><span class="s1">self._frameon):</span>
            <span class="s3"># don't do bbox on spines if frame not on.</span>
            <span class="s0">for </span><span class="s1">spine </span><span class="s0">in </span><span class="s1">self.spines.values():</span>
                <span class="s1">artists.remove(spine)</span>

        <span class="s1">artists.remove(self.title)</span>
        <span class="s1">artists.remove(self._left_title)</span>
        <span class="s1">artists.remove(self._right_title)</span>

        <span class="s3"># always include types that do not internally implement clipping</span>
        <span class="s3"># to Axes. may have clip_on set to True and clip_box equivalent</span>
        <span class="s3"># to ax.bbox but then ignore these properties during draws.</span>
        <span class="s1">noclip = (_AxesBase</span><span class="s0">, </span><span class="s1">maxis.Axis</span><span class="s0">,</span>
                  <span class="s1">offsetbox.AnnotationBbox</span><span class="s0">, </span><span class="s1">offsetbox.OffsetBox)</span>
        <span class="s0">return </span><span class="s1">[a </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">artists </span><span class="s0">if </span><span class="s1">a.get_visible() </span><span class="s0">and </span><span class="s1">a.get_in_layout()</span>
                <span class="s0">and </span><span class="s1">(isinstance(a</span><span class="s0">, </span><span class="s1">noclip) </span><span class="s0">or not </span><span class="s1">a._fully_clipped_to_axes())]</span>

    <span class="s0">def </span><span class="s1">get_tightbbox(self</span><span class="s0">, </span><span class="s1">renderer=</span><span class="s0">None, </span><span class="s1">call_axes_locator=</span><span class="s0">True,</span>
                      <span class="s1">bbox_extra_artists=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">for_layout_only=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the tight bounding box of the Axes, including axis and their 
        decorators (xlabel, title, etc). 
 
        Artists that have ``artist.set_in_layout(False)`` are not included 
        in the bbox. 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass 
            renderer that will be used to draw the figures (i.e. 
            ``fig.canvas.get_renderer()``) 
 
        bbox_extra_artists : list of `.Artist` or ``None`` 
            List of artists to include in the tight bounding box.  If 
            ``None`` (default), then all artist children of the Axes are 
            included in the tight bounding box. 
 
        call_axes_locator : bool, default: True 
            If *call_axes_locator* is ``False``, it does not call the 
            ``_axes_locator`` attribute, which is necessary to get the correct 
            bounding box. ``call_axes_locator=False`` can be used if the 
            caller is only interested in the relative size of the tightbbox 
            compared to the Axes bbox. 
 
        for_layout_only : default: False 
            The bounding box will *not* include the x-extent of the title and 
            the xlabel, or the y-extent of the ylabel. 
 
        Returns 
        ------- 
        `.BboxBase` 
            Bounding box in figure pixel coordinates. 
 
        See Also 
        -------- 
        matplotlib.axes.Axes.get_window_extent 
        matplotlib.axis.Axis.get_tightbbox 
        matplotlib.spines.Spine.get_window_extent 
        &quot;&quot;&quot;</span>

        <span class="s1">bb = []</span>
        <span class="s0">if </span><span class="s1">renderer </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>

        <span class="s0">if not </span><span class="s1">self.get_visible():</span>
            <span class="s0">return None</span>

        <span class="s1">locator = self.get_axes_locator()</span>
        <span class="s1">self.apply_aspect(</span>
            <span class="s1">locator(self</span><span class="s0">, </span><span class="s1">renderer) </span><span class="s0">if </span><span class="s1">locator </span><span class="s0">and </span><span class="s1">call_axes_locator </span><span class="s0">else None</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">self._axis_map.values():</span>
            <span class="s0">if </span><span class="s1">self.axison </span><span class="s0">and </span><span class="s1">axis.get_visible():</span>
                <span class="s1">ba = martist._get_tightbbox_for_layout_only(axis</span><span class="s0">, </span><span class="s1">renderer)</span>
                <span class="s0">if </span><span class="s1">ba:</span>
                    <span class="s1">bb.append(ba)</span>
        <span class="s1">self._update_title_position(renderer)</span>
        <span class="s1">axbbox = self.get_window_extent(renderer)</span>
        <span class="s1">bb.append(axbbox)</span>

        <span class="s0">for </span><span class="s1">title </span><span class="s0">in </span><span class="s1">[self.title</span><span class="s0">, </span><span class="s1">self._left_title</span><span class="s0">, </span><span class="s1">self._right_title]:</span>
            <span class="s0">if </span><span class="s1">title.get_visible():</span>
                <span class="s1">bt = title.get_window_extent(renderer)</span>
                <span class="s0">if </span><span class="s1">for_layout_only </span><span class="s0">and </span><span class="s1">bt.width &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s3"># make the title bbox 1 pixel wide so its width</span>
                    <span class="s3"># is not accounted for in bbox calculations in</span>
                    <span class="s3"># tight/constrained_layout</span>
                    <span class="s1">bt.x0 = (bt.x0 + bt.x1) / </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">0.5</span>
                    <span class="s1">bt.x1 = bt.x0 + </span><span class="s5">1.0</span>
                <span class="s1">bb.append(bt)</span>

        <span class="s1">bbox_artists = bbox_extra_artists</span>
        <span class="s0">if </span><span class="s1">bbox_artists </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">bbox_artists = self.get_default_bbox_extra_artists()</span>

        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">bbox_artists:</span>
            <span class="s1">bbox = a.get_tightbbox(renderer)</span>
            <span class="s0">if </span><span class="s1">(bbox </span><span class="s0">is not None</span>
                    <span class="s0">and </span><span class="s5">0 </span><span class="s1">&lt; bbox.width &lt; np.inf</span>
                    <span class="s0">and </span><span class="s5">0 </span><span class="s1">&lt; bbox.height &lt; np.inf):</span>
                <span class="s1">bb.append(bbox)</span>
        <span class="s0">return </span><span class="s1">mtransforms.Bbox.union(</span>
            <span class="s1">[b </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bb </span><span class="s0">if </span><span class="s1">b.width != </span><span class="s5">0 </span><span class="s0">or </span><span class="s1">b.height != </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">_make_twin_axes(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot;Make a twinx Axes of self. This is used for twinx and twiny.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s4">'sharex' </span><span class="s0">in </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s4">'sharey' </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s3"># The following line is added in v2.2 to avoid breaking Seaborn,</span>
            <span class="s3"># which currently uses this internal API.</span>
            <span class="s0">if </span><span class="s1">kwargs[</span><span class="s4">&quot;sharex&quot;</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">self </span><span class="s0">and </span><span class="s1">kwargs[</span><span class="s4">&quot;sharey&quot;</span><span class="s1">] </span><span class="s0">is not </span><span class="s1">self:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Twinned Axes may share only one axis&quot;</span><span class="s1">)</span>
        <span class="s1">ss = self.get_subplotspec()</span>
        <span class="s0">if </span><span class="s1">ss:</span>
            <span class="s1">twin = self.figure.add_subplot(ss</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">twin = self.figure.add_axes(</span>
                <span class="s1">self.get_position(</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs</span><span class="s0">,</span>
                <span class="s1">axes_locator=_TransformedBoundsLocator(</span>
                    <span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.transAxes))</span>
        <span class="s1">self.set_adjustable(</span><span class="s4">'datalim'</span><span class="s1">)</span>
        <span class="s1">twin.set_adjustable(</span><span class="s4">'datalim'</span><span class="s1">)</span>
        <span class="s1">self._twinned_axes.join(self</span><span class="s0">, </span><span class="s1">twin)</span>
        <span class="s0">return </span><span class="s1">twin</span>

    <span class="s0">def </span><span class="s1">twinx(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a twin Axes sharing the xaxis. 
 
        Create a new Axes with an invisible x-axis and an independent 
        y-axis positioned opposite to the original one (i.e. at right). The 
        x-axis autoscale setting will be inherited from the original 
        Axes.  To ensure that the tick marks of both y-axes align, see 
        `~matplotlib.ticker.LinearLocator`. 
 
        Returns 
        ------- 
        Axes 
            The newly created Axes instance 
 
        Notes 
        ----- 
        For those who are 'picking' artists while using twinx, pick 
        events are only called for the artists in the top-most Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">ax2 = self._make_twin_axes(sharex=self)</span>
        <span class="s1">ax2.yaxis.tick_right()</span>
        <span class="s1">ax2.yaxis.set_label_position(</span><span class="s4">'right'</span><span class="s1">)</span>
        <span class="s1">ax2.yaxis.set_offset_position(</span><span class="s4">'right'</span><span class="s1">)</span>
        <span class="s1">ax2.set_autoscalex_on(self.get_autoscalex_on())</span>
        <span class="s1">self.yaxis.tick_left()</span>
        <span class="s1">ax2.xaxis.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">ax2.patch.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">ax2</span>

    <span class="s0">def </span><span class="s1">twiny(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a twin Axes sharing the yaxis. 
 
        Create a new Axes with an invisible y-axis and an independent 
        x-axis positioned opposite to the original one (i.e. at top). The 
        y-axis autoscale setting will be inherited from the original Axes. 
        To ensure that the tick marks of both x-axes align, see 
        `~matplotlib.ticker.LinearLocator`. 
 
        Returns 
        ------- 
        Axes 
            The newly created Axes instance 
 
        Notes 
        ----- 
        For those who are 'picking' artists while using twiny, pick 
        events are only called for the artists in the top-most Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">ax2 = self._make_twin_axes(sharey=self)</span>
        <span class="s1">ax2.xaxis.tick_top()</span>
        <span class="s1">ax2.xaxis.set_label_position(</span><span class="s4">'top'</span><span class="s1">)</span>
        <span class="s1">ax2.set_autoscaley_on(self.get_autoscaley_on())</span>
        <span class="s1">self.xaxis.tick_bottom()</span>
        <span class="s1">ax2.yaxis.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">ax2.patch.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">ax2</span>

    <span class="s0">def </span><span class="s1">get_shared_x_axes(self):</span>
        <span class="s2">&quot;&quot;&quot;Return an immutable view on the shared x-axes Grouper.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cbook.GrouperView(self._shared_axes[</span><span class="s4">&quot;x&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">get_shared_y_axes(self):</span>
        <span class="s2">&quot;&quot;&quot;Return an immutable view on the shared y-axes Grouper.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cbook.GrouperView(self._shared_axes[</span><span class="s4">&quot;y&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">label_outer(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Only show &quot;outer&quot; labels and tick labels. 
 
        x-labels are only kept for subplots on the last row (or first row, if 
        labels are on the top side); y-labels only for subplots on the first 
        column (or last column, if labels are on the right side). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._label_outer_xaxis(check_patch=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self._label_outer_yaxis(check_patch=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_label_outer_xaxis(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">check_patch):</span>
        <span class="s3"># see documentation in label_outer.</span>
        <span class="s0">if </span><span class="s1">check_patch </span><span class="s0">and not </span><span class="s1">isinstance(self.patch</span><span class="s0">, </span><span class="s1">mpl.patches.Rectangle):</span>
            <span class="s0">return</span>
        <span class="s1">ss = self.get_subplotspec()</span>
        <span class="s0">if not </span><span class="s1">ss:</span>
            <span class="s0">return</span>
        <span class="s1">label_position = self.xaxis.get_label_position()</span>
        <span class="s0">if not </span><span class="s1">ss.is_first_row():  </span><span class="s3"># Remove top label/ticklabels/offsettext.</span>
            <span class="s0">if </span><span class="s1">label_position == </span><span class="s4">&quot;top&quot;</span><span class="s1">:</span>
                <span class="s1">self.set_xlabel(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.xaxis.set_tick_params(which=</span><span class="s4">&quot;both&quot;</span><span class="s0">, </span><span class="s1">labeltop=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.xaxis.offsetText.get_position()[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.xaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">ss.is_last_row():  </span><span class="s3"># Remove bottom label/ticklabels/offsettext.</span>
            <span class="s0">if </span><span class="s1">label_position == </span><span class="s4">&quot;bottom&quot;</span><span class="s1">:</span>
                <span class="s1">self.set_xlabel(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.xaxis.set_tick_params(which=</span><span class="s4">&quot;both&quot;</span><span class="s0">, </span><span class="s1">labelbottom=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.xaxis.offsetText.get_position()[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.xaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_label_outer_yaxis(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">check_patch):</span>
        <span class="s3"># see documentation in label_outer.</span>
        <span class="s0">if </span><span class="s1">check_patch </span><span class="s0">and not </span><span class="s1">isinstance(self.patch</span><span class="s0">, </span><span class="s1">mpl.patches.Rectangle):</span>
            <span class="s0">return</span>
        <span class="s1">ss = self.get_subplotspec()</span>
        <span class="s0">if not </span><span class="s1">ss:</span>
            <span class="s0">return</span>
        <span class="s1">label_position = self.yaxis.get_label_position()</span>
        <span class="s0">if not </span><span class="s1">ss.is_first_col():  </span><span class="s3"># Remove left label/ticklabels/offsettext.</span>
            <span class="s0">if </span><span class="s1">label_position == </span><span class="s4">&quot;left&quot;</span><span class="s1">:</span>
                <span class="s1">self.set_ylabel(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.yaxis.set_tick_params(which=</span><span class="s4">&quot;both&quot;</span><span class="s0">, </span><span class="s1">labelleft=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.yaxis.offsetText.get_position()[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.yaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">ss.is_last_col():  </span><span class="s3"># Remove right label/ticklabels/offsettext.</span>
            <span class="s0">if </span><span class="s1">label_position == </span><span class="s4">&quot;right&quot;</span><span class="s1">:</span>
                <span class="s1">self.set_ylabel(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">self.yaxis.set_tick_params(which=</span><span class="s4">&quot;both&quot;</span><span class="s0">, </span><span class="s1">labelright=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">self.yaxis.offsetText.get_position()[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.yaxis.offsetText.set_visible(</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_draw_rasterized(figure</span><span class="s0">, </span><span class="s1">artists</span><span class="s0">, </span><span class="s1">renderer):</span>
    <span class="s2">&quot;&quot;&quot; 
    A helper function for rasterizing the list of artists. 
 
    The bookkeeping to track if we are or are not in rasterizing mode 
    with the mixed-mode backends is relatively complicated and is now 
    handled in the matplotlib.artist.allow_rasterization decorator. 
 
    This helper defines the absolute minimum methods and attributes on a 
    shim class to be compatible with that decorator and then uses it to 
    rasterize the list of artists. 
 
    This is maybe too-clever, but allows us to re-use the same code that is 
    used on normal artists to participate in the &quot;are we rasterizing&quot; 
    accounting. 
 
    Please do not use this outside of the &quot;rasterize below a given zorder&quot; 
    functionality of Axes. 
 
    Parameters 
    ---------- 
    figure : matplotlib.figure.Figure 
        The figure all of the artists belong to (not checked).  We need this 
        because we can at the figure level suppress composition and insert each 
        rasterized artist as its own image. 
 
    artists : List[matplotlib.artist.Artist] 
        The list of Artists to be rasterized.  These are assumed to all 
        be in the same Figure. 
 
    renderer : matplotlib.backendbases.RendererBase 
        The currently active renderer 
 
    Returns 
    ------- 
    None 
 
    &quot;&quot;&quot;</span>
    <span class="s0">class </span><span class="s1">_MinimalArtist:</span>
        <span class="s0">def </span><span class="s1">get_rasterized(self):</span>
            <span class="s0">return True</span>

        <span class="s0">def </span><span class="s1">get_agg_filter(self):</span>
            <span class="s0">return None</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">figure</span><span class="s0">, </span><span class="s1">artists):</span>
            <span class="s1">self.figure = figure</span>
            <span class="s1">self.artists = artists</span>

        <span class="s1">@martist.allow_rasterization</span>
        <span class="s0">def </span><span class="s1">draw(self</span><span class="s0">, </span><span class="s1">renderer):</span>
            <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self.artists:</span>
                <span class="s1">a.draw(renderer)</span>

    <span class="s0">return </span><span class="s1">_MinimalArtist(figure</span><span class="s0">, </span><span class="s1">artists).draw(renderer)</span>
</pre>
</body>
</html>