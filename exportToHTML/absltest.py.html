<html>
<head>
<title>absltest.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
absltest.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2017 The Abseil Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">&quot;&quot;&quot;Base functionality for Abseil Python tests. 
 
This module contains base classes and high-level functions for Abseil-style 
tests. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">abc</span>
<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">import </span><span class="s1">difflib</span>
<span class="s3">import </span><span class="s1">enum</span>
<span class="s3">import </span><span class="s1">errno</span>
<span class="s3">import </span><span class="s1">getpass</span>
<span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">import </span><span class="s1">io</span>
<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">json</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">random</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">shlex</span>
<span class="s3">import </span><span class="s1">shutil</span>
<span class="s3">import </span><span class="s1">signal</span>
<span class="s3">import </span><span class="s1">stat</span>
<span class="s3">import </span><span class="s1">subprocess</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">tempfile</span>
<span class="s3">import </span><span class="s1">textwrap</span>
<span class="s3">import </span><span class="s1">unittest</span>
<span class="s3">from </span><span class="s1">unittest </span><span class="s3">import </span><span class="s1">mock  </span><span class="s0"># pylint: disable=unused-import Allow absltest.mock.</span>
<span class="s3">from </span><span class="s1">urllib </span><span class="s3">import </span><span class="s1">parse</span>

<span class="s3">try</span><span class="s1">:</span>
  <span class="s0"># The faulthandler module isn't always available, and pytype doesn't</span>
  <span class="s0"># understand that we're catching ImportError, so suppress the error.</span>
  <span class="s0"># pytype: disable=import-error</span>
  <span class="s3">import </span><span class="s1">faulthandler</span>
  <span class="s0"># pytype: enable=import-error</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
  <span class="s0"># We use faulthandler if it is available.</span>
  <span class="s1">faulthandler = </span><span class="s3">None</span>

<span class="s3">from </span><span class="s1">absl </span><span class="s3">import </span><span class="s1">app</span>
<span class="s3">from </span><span class="s1">absl </span><span class="s3">import </span><span class="s1">flags</span>
<span class="s3">from </span><span class="s1">absl </span><span class="s3">import </span><span class="s1">logging</span>
<span class="s3">from </span><span class="s1">absl.testing </span><span class="s3">import </span><span class="s1">_pretty_print_reporter</span>
<span class="s3">from </span><span class="s1">absl.testing </span><span class="s3">import </span><span class="s1">xml_reporter</span>

<span class="s0"># Make typing an optional import to avoid it being a required dependency</span>
<span class="s0"># in Python 2. Type checkers will still understand the imports.</span>
<span class="s3">try</span><span class="s1">:</span>
  <span class="s0"># pylint: disable=unused-import</span>
  <span class="s3">import </span><span class="s1">typing</span>
  <span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">AnyStr</span><span class="s3">, </span><span class="s1">BinaryIO</span><span class="s3">, </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">ContextManager</span><span class="s3">, </span><span class="s1">IO</span><span class="s3">, </span><span class="s1">Iterator</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">MutableMapping</span><span class="s3">, </span><span class="s1">MutableSequence</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Text</span><span class="s3">, </span><span class="s1">TextIO</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">, </span><span class="s1">Union</span>
  <span class="s0"># pylint: enable=unused-import</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
  <span class="s3">pass</span>
<span class="s3">else</span><span class="s1">:</span>
  <span class="s0"># Use an if-type-checking block to prevent leakage of type-checking only</span>
  <span class="s0"># symbols. We don't want people relying on these at runtime.</span>
  <span class="s3">if </span><span class="s1">typing.TYPE_CHECKING:</span>
    <span class="s0"># Unbounded TypeVar for general usage</span>
    <span class="s1">_T = typing.TypeVar(</span><span class="s4">'_T'</span><span class="s1">)</span>

    <span class="s3">import </span><span class="s1">unittest.case</span>
    <span class="s1">_OutcomeType = unittest.case._Outcome  </span><span class="s0"># pytype: disable=module-attr</span>



<span class="s0"># Re-export a bunch of unittest functions we support so that people don't</span>
<span class="s0"># have to import unittest to get them</span>
<span class="s0"># pylint: disable=invalid-name</span>
<span class="s1">skip = unittest.skip</span>
<span class="s1">skipIf = unittest.skipIf</span>
<span class="s1">skipUnless = unittest.skipUnless</span>
<span class="s1">SkipTest = unittest.SkipTest</span>
<span class="s1">expectedFailure = unittest.expectedFailure</span>
<span class="s0"># pylint: enable=invalid-name</span>

<span class="s0"># End unittest re-exports</span>

<span class="s1">FLAGS = flags.FLAGS</span>

<span class="s1">_TEXT_OR_BINARY_TYPES = (str</span><span class="s3">, </span><span class="s1">bytes)</span>

<span class="s0"># Suppress surplus entries in AssertionError stack traces.</span>
<span class="s1">__unittest = </span><span class="s3">True  </span><span class="s0"># pylint: disable=invalid-name</span>


<span class="s3">def </span><span class="s1">expectedFailureIf(condition</span><span class="s3">, </span><span class="s1">reason):  </span><span class="s0"># pylint: disable=invalid-name</span>
  <span class="s2">&quot;&quot;&quot;Expects the test to fail if the run condition is True. 
 
  Example usage:: 
 
      @expectedFailureIf(sys.version.major == 2, &quot;Not yet working in py2&quot;) 
      def test_foo(self): 
        ... 
 
  Args: 
    condition: bool, whether to expect failure or not. 
    reason: Text, the reason to expect failure. 
  Returns: 
    Decorator function 
  &quot;&quot;&quot;</span>
  <span class="s3">del </span><span class="s1">reason  </span><span class="s0"># Unused</span>
  <span class="s3">if </span><span class="s1">condition:</span>
    <span class="s3">return </span><span class="s1">unittest.expectedFailure</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return lambda </span><span class="s1">f: f</span>


<span class="s3">class </span><span class="s1">TempFileCleanup(enum.Enum):</span>
  <span class="s0"># Always cleanup temp files when the test completes.</span>
  <span class="s1">ALWAYS = </span><span class="s4">'always'</span>
  <span class="s0"># Only cleanup temp file if the test passes. This allows easier inspection</span>
  <span class="s0"># of tempfile contents on test failure. absltest.TEST_TMPDIR.value determines</span>
  <span class="s0"># where tempfiles are created.</span>
  <span class="s1">SUCCESS = </span><span class="s4">'success'</span>
  <span class="s0"># Never cleanup temp files.</span>
  <span class="s1">OFF = </span><span class="s4">'never'</span>


<span class="s0"># Many of the methods in this module have names like assertSameElements.</span>
<span class="s0"># This kind of name does not comply with PEP8 style,</span>
<span class="s0"># but it is consistent with the naming of methods in unittest.py.</span>
<span class="s0"># pylint: disable=invalid-name</span>


<span class="s3">def </span><span class="s1">_get_default_test_random_seed():</span>
  <span class="s0"># type: () -&gt; int</span>
  <span class="s1">random_seed = </span><span class="s5">301</span>
  <span class="s1">value = os.environ.get(</span><span class="s4">'TEST_RANDOM_SEED'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">random_seed = int(value)</span>
  <span class="s3">except </span><span class="s1">ValueError:</span>
    <span class="s3">pass</span>
  <span class="s3">return </span><span class="s1">random_seed</span>


<span class="s3">def </span><span class="s1">get_default_test_srcdir():</span>
  <span class="s0"># type: () -&gt; Text</span>
  <span class="s2">&quot;&quot;&quot;Returns default test source dir.&quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">os.environ.get(</span><span class="s4">'TEST_SRCDIR'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">get_default_test_tmpdir():</span>
  <span class="s0"># type: () -&gt; Text</span>
  <span class="s2">&quot;&quot;&quot;Returns default test temp dir.&quot;&quot;&quot;</span>
  <span class="s1">tmpdir = os.environ.get(</span><span class="s4">'TEST_TMPDIR'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>
  <span class="s3">if not </span><span class="s1">tmpdir:</span>
    <span class="s1">tmpdir = os.path.join(tempfile.gettempdir()</span><span class="s3">, </span><span class="s4">'absl_testing'</span><span class="s1">)</span>

  <span class="s3">return </span><span class="s1">tmpdir</span>


<span class="s3">def </span><span class="s1">_get_default_randomize_ordering_seed():</span>
  <span class="s0"># type: () -&gt; int</span>
  <span class="s2">&quot;&quot;&quot;Returns default seed to use for randomizing test order. 
 
  This function first checks the --test_randomize_ordering_seed flag, and then 
  the TEST_RANDOMIZE_ORDERING_SEED environment variable. If the first value 
  we find is: 
    * (not set): disable test randomization 
    * 0: disable test randomization 
    * 'random': choose a random seed in [1, 4294967295] for test order 
      randomization 
    * positive integer: use this seed for test order randomization 
 
  (The values used are patterned after 
  https://docs.python.org/3/using/cmdline.html#envvar-PYTHONHASHSEED). 
 
  In principle, it would be simpler to return None if no override is provided; 
  however, the python random module has no `get_seed()`, only `getstate()`, 
  which returns far more data than we want to pass via an environment variable 
  or flag. 
 
  Returns: 
    A default value for test case randomization (int). 0 means do not randomize. 
 
  Raises: 
    ValueError: Raised when the flag or env value is not one of the options 
        above. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">FLAGS[</span><span class="s4">'test_randomize_ordering_seed'</span><span class="s1">].present:</span>
    <span class="s1">randomize = FLAGS.test_randomize_ordering_seed</span>
  <span class="s3">elif </span><span class="s4">'TEST_RANDOMIZE_ORDERING_SEED' </span><span class="s3">in </span><span class="s1">os.environ:</span>
    <span class="s1">randomize = os.environ[</span><span class="s4">'TEST_RANDOMIZE_ORDERING_SEED'</span><span class="s1">]</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">randomize = </span><span class="s4">''</span>
  <span class="s3">if not </span><span class="s1">randomize:</span>
    <span class="s3">return </span><span class="s5">0</span>
  <span class="s3">if </span><span class="s1">randomize == </span><span class="s4">'random'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">random.Random().randint(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4294967295</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">randomize == </span><span class="s4">'0'</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s5">0</span>
  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">seed = int(randomize)</span>
    <span class="s3">if </span><span class="s1">seed &gt; </span><span class="s5">0</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">seed</span>
  <span class="s3">except </span><span class="s1">ValueError:</span>
    <span class="s3">pass</span>
  <span class="s3">raise </span><span class="s1">ValueError(</span>
      <span class="s4">'Unknown test randomization seed value: {}'</span><span class="s1">.format(randomize))</span>


<span class="s1">TEST_SRCDIR = flags.DEFINE_string(</span>
    <span class="s4">'test_srcdir'</span><span class="s3">,</span>
    <span class="s1">get_default_test_srcdir()</span><span class="s3">,</span>
    <span class="s4">'Root of directory tree where source files live'</span><span class="s3">,</span>
    <span class="s1">allow_override_cpp=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s1">TEST_TMPDIR = flags.DEFINE_string(</span>
    <span class="s4">'test_tmpdir'</span><span class="s3">,</span>
    <span class="s1">get_default_test_tmpdir()</span><span class="s3">,</span>
    <span class="s4">'Directory for temporary testing files'</span><span class="s3">,</span>
    <span class="s1">allow_override_cpp=</span><span class="s3">True</span><span class="s1">)</span>

<span class="s1">flags.DEFINE_integer(</span>
    <span class="s4">'test_random_seed'</span><span class="s3">,</span>
    <span class="s1">_get_default_test_random_seed()</span><span class="s3">,</span>
    <span class="s4">'Random seed for testing. Some test frameworks may '</span>
    <span class="s4">'change the default value of this flag between runs, so '</span>
    <span class="s4">'it is not appropriate for seeding probabilistic tests.'</span><span class="s3">,</span>
    <span class="s1">allow_override_cpp=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_string(</span>
    <span class="s4">'test_randomize_ordering_seed'</span><span class="s3">,</span>
    <span class="s4">''</span><span class="s3">,</span>
    <span class="s4">'If positive, use this as a seed to randomize the '</span>
    <span class="s4">'execution order for test cases. If &quot;random&quot;, pick a '</span>
    <span class="s4">'random seed to use. If 0 or not set, do not randomize '</span>
    <span class="s4">'test case execution order. This flag also overrides '</span>
    <span class="s4">'the TEST_RANDOMIZE_ORDERING_SEED environment variable.'</span><span class="s3">,</span>
    <span class="s1">allow_override_cpp=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s1">flags.DEFINE_string(</span><span class="s4">'xml_output_file'</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s4">'File to store XML test results'</span><span class="s1">)</span>


<span class="s0"># We might need to monkey-patch TestResult so that it stops considering an</span>
<span class="s0"># unexpected pass as a as a &quot;successful result&quot;.  For details, see</span>
<span class="s0"># http://bugs.python.org/issue20165</span>
<span class="s3">def </span><span class="s1">_monkey_patch_test_result_for_unexpected_passes():</span>
  <span class="s0"># type: () -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Workaround for &lt;http://bugs.python.org/issue20165&gt;.&quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">wasSuccessful(self):</span>
    <span class="s0"># type: () -&gt; bool</span>
    <span class="s2">&quot;&quot;&quot;Tells whether or not this result was a success. 
 
    Any unexpected pass is to be counted as a non-success. 
 
    Args: 
      self: The TestResult instance. 
 
    Returns: 
      Whether or not this result was a success. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">(len(self.failures) == len(self.errors) ==</span>
            <span class="s1">len(self.unexpectedSuccesses) == </span><span class="s5">0</span><span class="s1">)</span>

  <span class="s1">test_result = unittest.TestResult()</span>
  <span class="s1">test_result.addUnexpectedSuccess(unittest.FunctionTestCase(</span><span class="s3">lambda</span><span class="s1">: </span><span class="s3">None</span><span class="s1">))</span>
  <span class="s3">if </span><span class="s1">test_result.wasSuccessful():  </span><span class="s0"># The bug is present.</span>
    <span class="s1">unittest.TestResult.wasSuccessful = wasSuccessful</span>
    <span class="s3">if </span><span class="s1">test_result.wasSuccessful():  </span><span class="s0"># Warn the user if our hot-fix failed.</span>
      <span class="s1">sys.stderr.write(</span><span class="s4">'unittest.result.TestResult monkey patch to report'</span>
                       <span class="s4">' unexpected passes as failures did not work.</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>


<span class="s1">_monkey_patch_test_result_for_unexpected_passes()</span>


<span class="s3">def </span><span class="s1">_open(filepath</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">_open_func=open):</span>
  <span class="s0"># type: (Text, Text, Callable[..., IO]) -&gt; IO</span>
  <span class="s2">&quot;&quot;&quot;Opens a file. 
 
  Like open(), but ensure that we can open real files even if tests stub out 
  open(). 
 
  Args: 
    filepath: A filepath. 
    mode: A mode. 
    _open_func: A built-in open() function. 
 
  Returns: 
    The opened file object. 
  &quot;&quot;&quot;</span>
  <span class="s3">return </span><span class="s1">_open_func(filepath</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf-8'</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">_TempDir(object):</span>
  <span class="s2">&quot;&quot;&quot;Represents a temporary directory for tests. 
 
  Creation of this class is internal. Using its public methods is OK. 
 
  This class implements the `os.PathLike` interface (specifically, 
  `os.PathLike[str]`). This means, in Python 3, it can be directly passed 
  to e.g. `os.path.join()`. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path):</span>
    <span class="s0"># type: (Text) -&gt; None</span>
    <span class="s2">&quot;&quot;&quot;Module-private: do not instantiate outside module.&quot;&quot;&quot;</span>
    <span class="s1">self._path = path</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">full_path(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;Returns the path, as a string, for the directory. 
 
    TIP: Instead of e.g. `os.path.join(temp_dir.full_path)`, you can simply 
    do `os.path.join(temp_dir)` because `__fspath__()` is implemented. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self._path</span>

  <span class="s3">def </span><span class="s1">__fspath__(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;See os.PathLike.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self.full_path</span>

  <span class="s3">def </span><span class="s1">create_file(self</span><span class="s3">, </span><span class="s1">file_path=</span><span class="s3">None, </span><span class="s1">content=</span><span class="s3">None, </span><span class="s1">mode=</span><span class="s4">'w'</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">,</span>
                  <span class="s1">errors=</span><span class="s4">'strict'</span><span class="s1">):</span>
    <span class="s0"># type: (Optional[Text], Optional[AnyStr], Text, Text, Text) -&gt; _TempFile</span>
    <span class="s2">&quot;&quot;&quot;Create a file in the directory. 
 
    NOTE: If the file already exists, it will be made writable and overwritten. 
 
    Args: 
      file_path: Optional file path for the temp file. If not given, a unique 
        file name will be generated and used. Slashes are allowed in the name; 
        any missing intermediate directories will be created. NOTE: This path 
        is the path that will be cleaned up, including any directories in the 
        path, e.g., 'foo/bar/baz.txt' will `rm -r foo` 
      content: Optional string or bytes to initially write to the file. If not 
        specified, then an empty file is created. 
      mode: Mode string to use when writing content. Only used if `content` is 
        non-empty. 
      encoding: Encoding to use when writing string content. Only used if 
        `content` is text. 
      errors: How to handle text to bytes encoding errors. Only used if 
        `content` is text. 
 
    Returns: 
      A _TempFile representing the created file. 
    &quot;&quot;&quot;</span>
    <span class="s1">tf</span><span class="s3">, </span><span class="s1">_ = _TempFile._create(self._path</span><span class="s3">, </span><span class="s1">file_path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">,</span>
                              <span class="s1">errors)</span>
    <span class="s3">return </span><span class="s1">tf</span>

  <span class="s3">def </span><span class="s1">mkdir(self</span><span class="s3">, </span><span class="s1">dir_path=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0"># type: (Optional[Text]) -&gt; _TempDir</span>
    <span class="s2">&quot;&quot;&quot;Create a directory in the directory. 
 
    Args: 
      dir_path: Optional path to the directory to create. If not given, 
        a unique name will be generated and used. 
 
    Returns: 
      A _TempDir representing the created directory. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">dir_path:</span>
      <span class="s1">path = os.path.join(self._path</span><span class="s3">, </span><span class="s1">dir_path)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">path = tempfile.mkdtemp(dir=self._path)</span>

    <span class="s0"># Note: there's no need to clear the directory since the containing</span>
    <span class="s0"># dir was cleared by the tempdir() function.</span>
    <span class="s1">os.makedirs(path</span><span class="s3">, </span><span class="s1">exist_ok=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_TempDir(path)</span>


<span class="s3">class </span><span class="s1">_TempFile(object):</span>
  <span class="s2">&quot;&quot;&quot;Represents a tempfile for tests. 
 
  Creation of this class is internal. Using its public methods is OK. 
 
  This class implements the `os.PathLike` interface (specifically, 
  `os.PathLike[str]`). This means, in Python 3, it can be directly passed 
  to e.g. `os.path.join()`. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path):</span>
    <span class="s0"># type: (Text) -&gt; None</span>
    <span class="s2">&quot;&quot;&quot;Private: use _create instead.&quot;&quot;&quot;</span>
    <span class="s1">self._path = path</span>

  <span class="s0"># pylint: disable=line-too-long</span>
  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">_create(cls</span><span class="s3">, </span><span class="s1">base_path</span><span class="s3">, </span><span class="s1">file_path</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors):</span>
    <span class="s0"># type: (Text, Optional[Text], AnyStr, Text, Text, Text) -&gt; Tuple[_TempFile, Text]</span>
    <span class="s0"># pylint: enable=line-too-long</span>
    <span class="s2">&quot;&quot;&quot;Module-private: create a tempfile instance.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">file_path:</span>
      <span class="s1">cleanup_path = os.path.join(base_path</span><span class="s3">, </span><span class="s1">_get_first_part(file_path))</span>
      <span class="s1">path = os.path.join(base_path</span><span class="s3">, </span><span class="s1">file_path)</span>
      <span class="s1">os.makedirs(os.path.dirname(path)</span><span class="s3">, </span><span class="s1">exist_ok=</span><span class="s3">True</span><span class="s1">)</span>
      <span class="s0"># The file may already exist, in which case, ensure it's writable so that</span>
      <span class="s0"># it can be truncated.</span>
      <span class="s3">if </span><span class="s1">os.path.exists(path) </span><span class="s3">and not </span><span class="s1">os.access(path</span><span class="s3">, </span><span class="s1">os.W_OK):</span>
        <span class="s1">stat_info = os.stat(path)</span>
        <span class="s1">os.chmod(path</span><span class="s3">, </span><span class="s1">stat_info.st_mode | stat.S_IWUSR)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">os.makedirs(base_path</span><span class="s3">, </span><span class="s1">exist_ok=</span><span class="s3">True</span><span class="s1">)</span>
      <span class="s1">fd</span><span class="s3">, </span><span class="s1">path = tempfile.mkstemp(dir=str(base_path))</span>
      <span class="s1">os.close(fd)</span>
      <span class="s1">cleanup_path = path</span>

    <span class="s1">tf = cls(path)</span>

    <span class="s3">if </span><span class="s1">content:</span>
      <span class="s3">if </span><span class="s1">isinstance(content</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">tf.write_text(content</span><span class="s3">, </span><span class="s1">mode=mode</span><span class="s3">, </span><span class="s1">encoding=encoding</span><span class="s3">, </span><span class="s1">errors=errors)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tf.write_bytes(content</span><span class="s3">, </span><span class="s1">mode)</span>

    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">tf.write_bytes(</span><span class="s6">b''</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">tf</span><span class="s3">, </span><span class="s1">cleanup_path</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">full_path(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;Returns the path, as a string, for the file. 
 
    TIP: Instead of e.g. `os.path.join(temp_file.full_path)`, you can simply 
    do `os.path.join(temp_file)` because `__fspath__()` is implemented. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self._path</span>

  <span class="s3">def </span><span class="s1">__fspath__(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;See os.PathLike.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self.full_path</span>

  <span class="s3">def </span><span class="s1">read_text(self</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">'strict'</span><span class="s1">):</span>
    <span class="s0"># type: (Text, Text) -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;Return the contents of the file as text.&quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">self.open_text(encoding=encoding</span><span class="s3">, </span><span class="s1">errors=errors) </span><span class="s3">as </span><span class="s1">fp:</span>
      <span class="s3">return </span><span class="s1">fp.read()</span>

  <span class="s3">def </span><span class="s1">read_bytes(self):</span>
    <span class="s0"># type: () -&gt; bytes</span>
    <span class="s2">&quot;&quot;&quot;Return the content of the file as bytes.&quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">self.open_bytes() </span><span class="s3">as </span><span class="s1">fp:</span>
      <span class="s3">return </span><span class="s1">fp.read()</span>

  <span class="s3">def </span><span class="s1">write_text(self</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'w'</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">'strict'</span><span class="s1">):</span>
    <span class="s0"># type: (Text, Text, Text, Text) -&gt; None</span>
    <span class="s2">&quot;&quot;&quot;Write text to the file. 
 
    Args: 
      text: Text to write. In Python 2, it can be bytes, which will be 
        decoded using the `encoding` arg (this is as an aid for code that 
        is 2 and 3 compatible). 
      mode: The mode to open the file for writing. 
      encoding: The encoding to use when writing the text to the file. 
      errors: The error handling strategy to use when converting text to bytes. 
    &quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">self.open_text(mode</span><span class="s3">, </span><span class="s1">encoding=encoding</span><span class="s3">, </span><span class="s1">errors=errors) </span><span class="s3">as </span><span class="s1">fp:</span>
      <span class="s1">fp.write(text)</span>

  <span class="s3">def </span><span class="s1">write_bytes(self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'wb'</span><span class="s1">):</span>
    <span class="s0"># type: (bytes, Text) -&gt; None</span>
    <span class="s2">&quot;&quot;&quot;Write bytes to the file. 
 
    Args: 
      data: bytes to write. 
      mode: Mode to open the file for writing. The &quot;b&quot; flag is implicit if 
        not already present. It must not have the &quot;t&quot; flag. 
    &quot;&quot;&quot;</span>
    <span class="s3">with </span><span class="s1">self.open_bytes(mode) </span><span class="s3">as </span><span class="s1">fp:</span>
      <span class="s1">fp.write(data)</span>

  <span class="s3">def </span><span class="s1">open_text(self</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'rt'</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">'strict'</span><span class="s1">):</span>
    <span class="s0"># type: (Text, Text, Text) -&gt; ContextManager[TextIO]</span>
    <span class="s2">&quot;&quot;&quot;Return a context manager for opening the file in text mode. 
 
    Args: 
      mode: The mode to open the file in. The &quot;t&quot; flag is implicit if not 
        already present. It must not have the &quot;b&quot; flag. 
      encoding: The encoding to use when opening the file. 
      errors: How to handle decoding errors. 
 
    Returns: 
      Context manager that yields an open file. 
 
    Raises: 
      ValueError: if invalid inputs are provided. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s4">'b' </span><span class="s3">in </span><span class="s1">mode:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Invalid mode {!r}: &quot;b&quot; flag not allowed when opening '</span>
                       <span class="s4">'file in text mode'</span><span class="s1">.format(mode))</span>
    <span class="s3">if </span><span class="s4">'t' </span><span class="s3">not in </span><span class="s1">mode:</span>
      <span class="s1">mode += </span><span class="s4">'t'</span>
    <span class="s1">cm = self._open(mode</span><span class="s3">, </span><span class="s1">encoding</span><span class="s3">, </span><span class="s1">errors)</span>
    <span class="s3">return </span><span class="s1">cm</span>

  <span class="s3">def </span><span class="s1">open_bytes(self</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">'rb'</span><span class="s1">):</span>
    <span class="s0"># type: (Text) -&gt; ContextManager[BinaryIO]</span>
    <span class="s2">&quot;&quot;&quot;Return a context manager for opening the file in binary mode. 
 
    Args: 
      mode: The mode to open the file in. The &quot;b&quot; mode is implicit if not 
        already present. It must not have the &quot;t&quot; flag. 
 
    Returns: 
      Context manager that yields an open file. 
 
    Raises: 
      ValueError: if invalid inputs are provided. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s4">'t' </span><span class="s3">in </span><span class="s1">mode:</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Invalid mode {!r}: &quot;t&quot; flag not allowed when opening '</span>
                       <span class="s4">'file in binary mode'</span><span class="s1">.format(mode))</span>
    <span class="s3">if </span><span class="s4">'b' </span><span class="s3">not in </span><span class="s1">mode:</span>
      <span class="s1">mode += </span><span class="s4">'b'</span>
    <span class="s1">cm = self._open(mode</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s3">None, </span><span class="s1">errors=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">cm</span>

  <span class="s0"># TODO(b/123775699): Once pytype supports typing.Literal, use overload and</span>
  <span class="s0"># Literal to express more precise return types. The contained type is</span>
  <span class="s0"># currently `Any` to avoid [bad-return-type] errors in the open_* methods.</span>
  <span class="s1">@contextlib.contextmanager</span>
  <span class="s3">def </span><span class="s1">_open(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">mode: str</span><span class="s3">,</span>
      <span class="s1">encoding: Optional[str] = </span><span class="s4">'utf8'</span><span class="s3">,</span>
      <span class="s1">errors: Optional[str] = </span><span class="s4">'strict'</span><span class="s3">,</span>
  <span class="s1">) -&gt; Iterator[Any]:</span>
    <span class="s3">with </span><span class="s1">io.open(</span>
        <span class="s1">self.full_path</span><span class="s3">, </span><span class="s1">mode=mode</span><span class="s3">, </span><span class="s1">encoding=encoding</span><span class="s3">, </span><span class="s1">errors=errors) </span><span class="s3">as </span><span class="s1">fp:</span>
      <span class="s3">yield </span><span class="s1">fp</span>


<span class="s3">class </span><span class="s1">_method(object):</span>
  <span class="s2">&quot;&quot;&quot;A decorator that supports both instance and classmethod invocations. 
 
  Using similar semantics to the @property builtin, this decorator can augment 
  an instance method to support conditional logic when invoked on a class 
  object. This breaks support for invoking an instance method via the class 
  (e.g. Cls.method(self, ...)) but is still situationally useful. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">finstancemethod):</span>
    <span class="s0"># type: (Callable[..., Any]) -&gt; None</span>
    <span class="s1">self._finstancemethod = finstancemethod</span>
    <span class="s1">self._fclassmethod = </span><span class="s3">None</span>

  <span class="s3">def </span><span class="s1">classmethod(self</span><span class="s3">, </span><span class="s1">fclassmethod):</span>
    <span class="s0"># type: (Callable[..., Any]) -&gt; _method</span>
    <span class="s1">self._fclassmethod = classmethod(fclassmethod)</span>
    <span class="s3">return </span><span class="s1">self</span>

  <span class="s3">def </span><span class="s1">__doc__(self):</span>
    <span class="s0"># type: () -&gt; str</span>
    <span class="s3">if </span><span class="s1">getattr(self._finstancemethod</span><span class="s3">, </span><span class="s4">'__doc__'</span><span class="s1">):</span>
      <span class="s3">return </span><span class="s1">self._finstancemethod.__doc__</span>
    <span class="s3">elif </span><span class="s1">getattr(self._fclassmethod</span><span class="s3">, </span><span class="s4">'__doc__'</span><span class="s1">):</span>
      <span class="s3">return </span><span class="s1">self._fclassmethod.__doc__</span>
    <span class="s3">return </span><span class="s4">''</span>

  <span class="s3">def </span><span class="s1">__get__(self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">type_):</span>
    <span class="s0"># type: (Optional[Any], Optional[Type[Any]]) -&gt; Callable[..., Any]</span>
    <span class="s1">func = self._fclassmethod </span><span class="s3">if </span><span class="s1">obj </span><span class="s3">is None else </span><span class="s1">self._finstancemethod</span>
    <span class="s3">return </span><span class="s1">func.__get__(obj</span><span class="s3">, </span><span class="s1">type_)  </span><span class="s0"># pytype: disable=attribute-error</span>


<span class="s3">class </span><span class="s1">TestCase(unittest.TestCase):</span>
  <span class="s2">&quot;&quot;&quot;Extension of unittest.TestCase providing more power.&quot;&quot;&quot;</span>

  <span class="s0"># When to cleanup files/directories created by our `create_tempfile()` and</span>
  <span class="s0"># `create_tempdir()` methods after each test case completes. This does *not*</span>
  <span class="s0"># affect e.g., files created outside of those methods, e.g., using the stdlib</span>
  <span class="s0"># tempfile module. This can be overridden at the class level, instance level,</span>
  <span class="s0"># or with the `cleanup` arg of `create_tempfile()` and `create_tempdir()`. See</span>
  <span class="s0"># `TempFileCleanup` for details on the different values.</span>
  <span class="s0"># TODO(b/70517332): Remove the type comment and the disable once pytype has</span>
  <span class="s0"># better support for enums.</span>
  <span class="s1">tempfile_cleanup = TempFileCleanup.ALWAYS  </span><span class="s0"># type: TempFileCleanup  # pytype: disable=annotation-type-mismatch</span>

  <span class="s1">maxDiff = </span><span class="s5">80 </span><span class="s1">* </span><span class="s5">20</span>
  <span class="s1">longMessage = </span><span class="s3">True</span>

  <span class="s0"># Exit stacks for per-test and per-class scopes.</span>
  <span class="s1">_exit_stack = </span><span class="s3">None</span>
  <span class="s1">_cls_exit_stack = </span><span class="s3">None</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self).__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s0"># This is to work around missing type stubs in unittest.pyi</span>
    <span class="s1">self._outcome = getattr(self</span><span class="s3">, </span><span class="s4">'_outcome'</span><span class="s1">)  </span><span class="s0"># type: Optional[_OutcomeType]</span>

  <span class="s3">def </span><span class="s1">setUp(self):</span>
    <span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self).setUp()</span>
    <span class="s0"># NOTE: Only Python 3 contextlib has ExitStack</span>
    <span class="s3">if </span><span class="s1">hasattr(contextlib</span><span class="s3">, </span><span class="s4">'ExitStack'</span><span class="s1">):</span>
      <span class="s1">self._exit_stack = contextlib.ExitStack()</span>
      <span class="s1">self.addCleanup(self._exit_stack.close)</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">setUpClass(cls):</span>
    <span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">cls).setUpClass()</span>
    <span class="s0"># NOTE: Only Python 3 contextlib has ExitStack and only Python 3.8+ has</span>
    <span class="s0"># addClassCleanup.</span>
    <span class="s3">if </span><span class="s1">hasattr(contextlib</span><span class="s3">, </span><span class="s4">'ExitStack'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(cls</span><span class="s3">, </span><span class="s4">'addClassCleanup'</span><span class="s1">):</span>
      <span class="s1">cls._cls_exit_stack = contextlib.ExitStack()</span>
      <span class="s1">cls.addClassCleanup(cls._cls_exit_stack.close)</span>

  <span class="s3">def </span><span class="s1">create_tempdir(self</span><span class="s3">, </span><span class="s1">name=</span><span class="s3">None, </span><span class="s1">cleanup=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0"># type: (Optional[Text], Optional[TempFileCleanup]) -&gt; _TempDir</span>
    <span class="s2">&quot;&quot;&quot;Create a temporary directory specific to the test. 
 
    NOTE: The directory and its contents will be recursively cleared before 
    creation. This ensures that there is no pre-existing state. 
 
    This creates a named directory on disk that is isolated to this test, and 
    will be properly cleaned up by the test. This avoids several pitfalls of 
    creating temporary directories for test purposes, as well as makes it easier 
    to setup directories and verify their contents. For example:: 
 
        def test_foo(self): 
          out_dir = self.create_tempdir() 
          out_log = out_dir.create_file('output.log') 
          expected_outputs = [ 
              os.path.join(out_dir, 'data-0.txt'), 
              os.path.join(out_dir, 'data-1.txt'), 
          ] 
          code_under_test(out_dir) 
          self.assertTrue(os.path.exists(expected_paths[0])) 
          self.assertTrue(os.path.exists(expected_paths[1])) 
          self.assertEqual('foo', out_log.read_text()) 
 
    See also: :meth:`create_tempfile` for creating temporary files. 
 
    Args: 
      name: Optional name of the directory. If not given, a unique 
        name will be generated and used. 
      cleanup: Optional cleanup policy on when/if to remove the directory (and 
        all its contents) at the end of the test. If None, then uses 
        :attr:`tempfile_cleanup`. 
 
    Returns: 
      A _TempDir representing the created directory; see _TempDir class docs 
      for usage. 
    &quot;&quot;&quot;</span>
    <span class="s1">test_path = self._get_tempdir_path_test()</span>

    <span class="s3">if </span><span class="s1">name:</span>
      <span class="s1">path = os.path.join(test_path</span><span class="s3">, </span><span class="s1">name)</span>
      <span class="s1">cleanup_path = os.path.join(test_path</span><span class="s3">, </span><span class="s1">_get_first_part(name))</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">os.makedirs(test_path</span><span class="s3">, </span><span class="s1">exist_ok=</span><span class="s3">True</span><span class="s1">)</span>
      <span class="s1">path = tempfile.mkdtemp(dir=test_path)</span>
      <span class="s1">cleanup_path = path</span>

    <span class="s1">_rmtree_ignore_errors(cleanup_path)</span>
    <span class="s1">os.makedirs(path</span><span class="s3">, </span><span class="s1">exist_ok=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s1">self._maybe_add_temp_path_cleanup(cleanup_path</span><span class="s3">, </span><span class="s1">cleanup)</span>

    <span class="s3">return </span><span class="s1">_TempDir(path)</span>

  <span class="s0"># pylint: disable=line-too-long</span>
  <span class="s3">def </span><span class="s1">create_tempfile(self</span><span class="s3">, </span><span class="s1">file_path=</span><span class="s3">None, </span><span class="s1">content=</span><span class="s3">None, </span><span class="s1">mode=</span><span class="s4">'w'</span><span class="s3">,</span>
                      <span class="s1">encoding=</span><span class="s4">'utf8'</span><span class="s3">, </span><span class="s1">errors=</span><span class="s4">'strict'</span><span class="s3">, </span><span class="s1">cleanup=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0"># type: (Optional[Text], Optional[AnyStr], Text, Text, Text, Optional[TempFileCleanup]) -&gt; _TempFile</span>
    <span class="s0"># pylint: enable=line-too-long</span>
    <span class="s2">&quot;&quot;&quot;Create a temporary file specific to the test. 
 
    This creates a named file on disk that is isolated to this test, and will 
    be properly cleaned up by the test. This avoids several pitfalls of 
    creating temporary files for test purposes, as well as makes it easier 
    to setup files, their data, read them back, and inspect them when 
    a test fails. For example:: 
 
        def test_foo(self): 
          output = self.create_tempfile() 
          code_under_test(output) 
          self.assertGreater(os.path.getsize(output), 0) 
          self.assertEqual('foo', output.read_text()) 
 
    NOTE: This will zero-out the file. This ensures there is no pre-existing 
    state. 
    NOTE: If the file already exists, it will be made writable and overwritten. 
 
    See also: :meth:`create_tempdir` for creating temporary directories, and 
    ``_TempDir.create_file`` for creating files within a temporary directory. 
 
    Args: 
      file_path: Optional file path for the temp file. If not given, a unique 
        file name will be generated and used. Slashes are allowed in the name; 
        any missing intermediate directories will be created. NOTE: This path is 
        the path that will be cleaned up, including any directories in the path, 
        e.g., ``'foo/bar/baz.txt'`` will ``rm -r foo``. 
      content: Optional string or 
        bytes to initially write to the file. If not 
        specified, then an empty file is created. 
      mode: Mode string to use when writing content. Only used if `content` is 
        non-empty. 
      encoding: Encoding to use when writing string content. Only used if 
        `content` is text. 
      errors: How to handle text to bytes encoding errors. Only used if 
        `content` is text. 
      cleanup: Optional cleanup policy on when/if to remove the directory (and 
        all its contents) at the end of the test. If None, then uses 
        :attr:`tempfile_cleanup`. 
 
    Returns: 
      A _TempFile representing the created file; see _TempFile class docs for 
      usage. 
    &quot;&quot;&quot;</span>
    <span class="s1">test_path = self._get_tempdir_path_test()</span>
    <span class="s1">tf</span><span class="s3">, </span><span class="s1">cleanup_path = _TempFile._create(test_path</span><span class="s3">, </span><span class="s1">file_path</span><span class="s3">, </span><span class="s1">content=content</span><span class="s3">,</span>
                                         <span class="s1">mode=mode</span><span class="s3">, </span><span class="s1">encoding=encoding</span><span class="s3">,</span>
                                         <span class="s1">errors=errors)</span>
    <span class="s1">self._maybe_add_temp_path_cleanup(cleanup_path</span><span class="s3">, </span><span class="s1">cleanup)</span>
    <span class="s3">return </span><span class="s1">tf</span>

  <span class="s1">@_method</span>
  <span class="s3">def </span><span class="s1">enter_context(self</span><span class="s3">, </span><span class="s1">manager):</span>
    <span class="s0"># type: (ContextManager[_T]) -&gt; _T</span>
    <span class="s2">&quot;&quot;&quot;Returns the CM's value after registering it with the exit stack. 
 
    Entering a context pushes it onto a stack of contexts. When `enter_context` 
    is called on the test instance (e.g. `self.enter_context`), the context is 
    exited after the test case's tearDown call. When called on the test class 
    (e.g. `TestCase.enter_context`), the context is exited after the test 
    class's tearDownClass call. 
 
    Contexts are exited in the reverse order of entering. They will always 
    be exited, regardless of test failure/success. 
 
    This is useful to eliminate per-test boilerplate when context managers 
    are used. For example, instead of decorating every test with `@mock.patch`, 
    simply do `self.foo = self.enter_context(mock.patch(...))' in `setUp()`. 
 
    NOTE: The context managers will always be exited without any error 
    information. This is an unfortunate implementation detail due to some 
    internals of how unittest runs tests. 
 
    Args: 
      manager: The context manager to enter. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">self._exit_stack:</span>
      <span class="s3">raise </span><span class="s1">AssertionError(</span>
          <span class="s4">'self._exit_stack is not set: enter_context is Py3-only; also make '</span>
          <span class="s4">'sure that AbslTest.setUp() is called.'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">self._exit_stack.enter_context(manager)</span>

  <span class="s1">@enter_context.classmethod</span>
  <span class="s3">def </span><span class="s1">enter_context(cls</span><span class="s3">, </span><span class="s1">manager):  </span><span class="s0"># pylint: disable=no-self-argument</span>
    <span class="s0"># type: (ContextManager[_T]) -&gt; _T</span>
    <span class="s3">if not </span><span class="s1">cls._cls_exit_stack:</span>
      <span class="s3">raise </span><span class="s1">AssertionError(</span>
          <span class="s4">'cls._cls_exit_stack is not set: cls.enter_context requires '</span>
          <span class="s4">'Python 3.8+; also make sure that AbslTest.setUpClass() is called.'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">cls._cls_exit_stack.enter_context(manager)</span>

  <span class="s1">@classmethod</span>
  <span class="s3">def </span><span class="s1">_get_tempdir_path_cls(cls):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s3">return </span><span class="s1">os.path.join(TEST_TMPDIR.value</span><span class="s3">,</span>
                        <span class="s1">cls.__qualname__.replace(</span><span class="s4">'__main__.'</span><span class="s3">, </span><span class="s4">''</span><span class="s1">))</span>

  <span class="s3">def </span><span class="s1">_get_tempdir_path_test(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s3">return </span><span class="s1">os.path.join(self._get_tempdir_path_cls()</span><span class="s3">, </span><span class="s1">self._testMethodName)</span>

  <span class="s3">def </span><span class="s1">_get_tempfile_cleanup(self</span><span class="s3">, </span><span class="s1">override):</span>
    <span class="s0"># type: (Optional[TempFileCleanup]) -&gt; TempFileCleanup</span>
    <span class="s3">if </span><span class="s1">override </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">override</span>
    <span class="s3">return </span><span class="s1">self.tempfile_cleanup</span>

  <span class="s3">def </span><span class="s1">_maybe_add_temp_path_cleanup(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">cleanup):</span>
    <span class="s0"># type: (Text, Optional[TempFileCleanup]) -&gt; None</span>
    <span class="s1">cleanup = self._get_tempfile_cleanup(cleanup)</span>
    <span class="s3">if </span><span class="s1">cleanup == TempFileCleanup.OFF:</span>
      <span class="s3">return</span>
    <span class="s3">elif </span><span class="s1">cleanup == TempFileCleanup.ALWAYS:</span>
      <span class="s1">self.addCleanup(_rmtree_ignore_errors</span><span class="s3">, </span><span class="s1">path)</span>
    <span class="s3">elif </span><span class="s1">cleanup == TempFileCleanup.SUCCESS:</span>
      <span class="s1">self._internal_add_cleanup_on_success(_rmtree_ignore_errors</span><span class="s3">, </span><span class="s1">path)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">raise </span><span class="s1">AssertionError(</span><span class="s4">'Unexpected cleanup value: {}'</span><span class="s1">.format(cleanup))</span>

  <span class="s3">def </span><span class="s1">_internal_add_cleanup_on_success(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">function: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">,</span>
      <span class="s1">*args: Any</span><span class="s3">,</span>
      <span class="s1">**kwargs: Any</span><span class="s3">,</span>
  <span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Adds `function` as cleanup when the test case succeeds.&quot;&quot;&quot;</span>
    <span class="s1">outcome = self._outcome</span>
    <span class="s1">previous_failure_count = (</span>
        <span class="s1">len(outcome.result.failures)</span>
        <span class="s1">+ len(outcome.result.errors)</span>
        <span class="s1">+ len(outcome.result.unexpectedSuccesses)</span>
    <span class="s1">)</span>
    <span class="s3">def </span><span class="s1">_call_cleaner_on_success(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
      <span class="s3">if not </span><span class="s1">self._internal_ran_and_passed_when_called_during_cleanup(</span>
          <span class="s1">previous_failure_count):</span>
        <span class="s3">return</span>
      <span class="s1">function(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">self.addCleanup(_call_cleaner_on_success</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

  <span class="s3">def </span><span class="s1">_internal_ran_and_passed_when_called_during_cleanup(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">previous_failure_count: int</span><span class="s3">,</span>
  <span class="s1">) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Returns whether test is passed. Expected to be called during cleanup.&quot;&quot;&quot;</span>
    <span class="s1">outcome = self._outcome</span>
    <span class="s3">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">11</span><span class="s1">):</span>
      <span class="s1">current_failure_count = (</span>
          <span class="s1">len(outcome.result.failures)</span>
          <span class="s1">+ len(outcome.result.errors)</span>
          <span class="s1">+ len(outcome.result.unexpectedSuccesses)</span>
      <span class="s1">)</span>
      <span class="s3">return </span><span class="s1">current_failure_count == previous_failure_count</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># Before Python 3.11 https://github.com/python/cpython/pull/28180, errors</span>
      <span class="s0"># were bufferred in _Outcome before calling cleanup.</span>
      <span class="s1">result = self.defaultTestResult()</span>
      <span class="s1">self._feedErrorsToResult(result</span><span class="s3">, </span><span class="s1">outcome.errors)  </span><span class="s0"># pytype: disable=attribute-error</span>
      <span class="s3">return </span><span class="s1">result.wasSuccessful()</span>

  <span class="s3">def </span><span class="s1">shortDescription(self):</span>
    <span class="s0"># type: () -&gt; Text</span>
    <span class="s2">&quot;&quot;&quot;Formats both the test method name and the first line of its docstring. 
 
    If no docstring is given, only returns the method name. 
 
    This method overrides unittest.TestCase.shortDescription(), which 
    only returns the first line of the docstring, obscuring the name 
    of the test upon failure. 
 
    Returns: 
      desc: A short description of a test method. 
    &quot;&quot;&quot;</span>
    <span class="s1">desc = self.id()</span>

    <span class="s0"># Omit the main name so that test name can be directly copy/pasted to</span>
    <span class="s0"># the command line.</span>
    <span class="s3">if </span><span class="s1">desc.startswith(</span><span class="s4">'__main__.'</span><span class="s1">):</span>
      <span class="s1">desc = desc[len(</span><span class="s4">'__main__.'</span><span class="s1">):]</span>

    <span class="s0"># NOTE: super() is used here instead of directly invoking</span>
    <span class="s0"># unittest.TestCase.shortDescription(self), because of the</span>
    <span class="s0"># following line that occurs later on:</span>
    <span class="s0">#       unittest.TestCase = TestCase</span>
    <span class="s0"># Because of this, direct invocation of what we think is the</span>
    <span class="s0"># superclass will actually cause infinite recursion.</span>
    <span class="s1">doc_first_line = super(TestCase</span><span class="s3">, </span><span class="s1">self).shortDescription()</span>
    <span class="s3">if </span><span class="s1">doc_first_line </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">desc = </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join((desc</span><span class="s3">, </span><span class="s1">doc_first_line))</span>
    <span class="s3">return </span><span class="s1">desc</span>

  <span class="s3">def </span><span class="s1">assertStartsWith(self</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">, </span><span class="s1">expected_start</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that actual.startswith(expected_start) is True. 
 
    Args: 
      actual: str 
      expected_start: str 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">actual.startswith(expected_start):</span>
      <span class="s1">self.fail(</span><span class="s4">'%r does not start with %r' </span><span class="s1">% (actual</span><span class="s3">, </span><span class="s1">expected_start)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertNotStartsWith(self</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">, </span><span class="s1">unexpected_start</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that actual.startswith(unexpected_start) is False. 
 
    Args: 
      actual: str 
      unexpected_start: str 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">actual.startswith(unexpected_start):</span>
      <span class="s1">self.fail(</span><span class="s4">'%r does start with %r' </span><span class="s1">% (actual</span><span class="s3">, </span><span class="s1">unexpected_start)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertEndsWith(self</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">, </span><span class="s1">expected_end</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that actual.endswith(expected_end) is True. 
 
    Args: 
      actual: str 
      expected_end: str 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">actual.endswith(expected_end):</span>
      <span class="s1">self.fail(</span><span class="s4">'%r does not end with %r' </span><span class="s1">% (actual</span><span class="s3">, </span><span class="s1">expected_end)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertNotEndsWith(self</span><span class="s3">, </span><span class="s1">actual</span><span class="s3">, </span><span class="s1">unexpected_end</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that actual.endswith(unexpected_end) is False. 
 
    Args: 
      actual: str 
      unexpected_end: str 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">actual.endswith(unexpected_end):</span>
      <span class="s1">self.fail(</span><span class="s4">'%r does end with %r' </span><span class="s1">% (actual</span><span class="s3">, </span><span class="s1">unexpected_end)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertSequenceStartsWith(self</span><span class="s3">, </span><span class="s1">prefix</span><span class="s3">, </span><span class="s1">whole</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;An equality assertion for the beginning of ordered sequences. 
 
    If prefix is an empty sequence, it will raise an error unless whole is also 
    an empty sequence. 
 
    If prefix is not a sequence, it will raise an error if the first element of 
    whole does not match. 
 
    Args: 
      prefix: A sequence expected at the beginning of the whole parameter. 
      whole: The sequence in which to look for prefix. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">prefix_len = len(prefix)</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">NotImplementedError):</span>
      <span class="s1">prefix = [prefix]</span>
      <span class="s1">prefix_len = </span><span class="s5">1</span>

    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">whole_len = len(whole)</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">NotImplementedError):</span>
      <span class="s1">self.fail(</span><span class="s4">'For whole: len(%s) is not supported, it appears to be type: '</span>
                <span class="s4">'%s' </span><span class="s1">% (whole</span><span class="s3">, </span><span class="s1">type(whole))</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s3">assert </span><span class="s1">prefix_len &lt;= whole_len</span><span class="s3">, </span><span class="s1">self._formatMessage(</span>
        <span class="s1">msg</span><span class="s3">,</span>
        <span class="s4">'Prefix length (%d) is longer than whole length (%d).' </span><span class="s1">%</span>
        <span class="s1">(prefix_len</span><span class="s3">, </span><span class="s1">whole_len)</span>
    <span class="s1">)</span>

    <span class="s3">if not </span><span class="s1">prefix_len </span><span class="s3">and </span><span class="s1">whole_len:</span>
      <span class="s1">self.fail(</span><span class="s4">'Prefix length is 0 but whole length is %d: %s' </span><span class="s1">%</span>
                <span class="s1">(len(whole)</span><span class="s3">, </span><span class="s1">whole)</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">self.assertSequenceEqual(prefix</span><span class="s3">, </span><span class="s1">whole[:prefix_len]</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s3">except </span><span class="s1">AssertionError:</span>
      <span class="s1">self.fail(</span><span class="s4">'prefix: %s not found at start of whole: %s.' </span><span class="s1">%</span>
                <span class="s1">(prefix</span><span class="s3">, </span><span class="s1">whole)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertEmpty(self</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that an object has zero length. 
 
    Args: 
      container: Anything that implements the collections.abc.Sized interface. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(container</span><span class="s3">, </span><span class="s1">abc.Sized):</span>
      <span class="s1">self.fail(</span><span class="s4">'Expected a Sized object, got: '</span>
                <span class="s4">'{!r}'</span><span class="s1">.format(type(container).__name__)</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s0"># explicitly check the length since some Sized objects (e.g. numpy.ndarray)</span>
    <span class="s0"># have strange __nonzero__/__bool__ behavior.</span>
    <span class="s3">if </span><span class="s1">len(container):  </span><span class="s0"># pylint: disable=g-explicit-length-test</span>
      <span class="s1">self.fail(</span><span class="s4">'{!r} has length of {}.'</span><span class="s1">.format(container</span><span class="s3">, </span><span class="s1">len(container))</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertNotEmpty(self</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that an object has non-zero length. 
 
    Args: 
      container: Anything that implements the collections.abc.Sized interface. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(container</span><span class="s3">, </span><span class="s1">abc.Sized):</span>
      <span class="s1">self.fail(</span><span class="s4">'Expected a Sized object, got: '</span>
                <span class="s4">'{!r}'</span><span class="s1">.format(type(container).__name__)</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s0"># explicitly check the length since some Sized objects (e.g. numpy.ndarray)</span>
    <span class="s0"># have strange __nonzero__/__bool__ behavior.</span>
    <span class="s3">if not </span><span class="s1">len(container):  </span><span class="s0"># pylint: disable=g-explicit-length-test</span>
      <span class="s1">self.fail(</span><span class="s4">'{!r} has length of 0.'</span><span class="s1">.format(container)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertLen(self</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">expected_len</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that an object has the expected length. 
 
    Args: 
      container: Anything that implements the collections.abc.Sized interface. 
      expected_len: The expected length of the container. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(container</span><span class="s3">, </span><span class="s1">abc.Sized):</span>
      <span class="s1">self.fail(</span><span class="s4">'Expected a Sized object, got: '</span>
                <span class="s4">'{!r}'</span><span class="s1">.format(type(container).__name__)</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s3">if </span><span class="s1">len(container) != expected_len:</span>
      <span class="s1">container_repr = unittest.util.safe_repr(container)  </span><span class="s0"># pytype: disable=module-attr</span>
      <span class="s1">self.fail(</span><span class="s4">'{} has length of {}, expected {}.'</span><span class="s1">.format(</span>
          <span class="s1">container_repr</span><span class="s3">, </span><span class="s1">len(container)</span><span class="s3">, </span><span class="s1">expected_len)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertSequenceAlmostEqual(self</span><span class="s3">, </span><span class="s1">expected_seq</span><span class="s3">, </span><span class="s1">actual_seq</span><span class="s3">, </span><span class="s1">places=</span><span class="s3">None,</span>
                                <span class="s1">msg=</span><span class="s3">None, </span><span class="s1">delta=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;An approximate equality assertion for ordered sequences. 
 
    Fail if the two sequences are unequal as determined by their value 
    differences rounded to the given number of decimal places (default 7) and 
    comparing to zero, or by comparing that the difference between each value 
    in the two sequences is more than the given delta. 
 
    Note that decimal places (from zero) are usually not the same as significant 
    digits (measured from the most significant digit). 
 
    If the two sequences compare equal then they will automatically compare 
    almost equal. 
 
    Args: 
      expected_seq: A sequence containing elements we are expecting. 
      actual_seq: The sequence that we are testing. 
      places: The number of decimal places to compare. 
      msg: The message to be printed if the test fails. 
      delta: The OK difference between compared values. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len(expected_seq) != len(actual_seq):</span>
      <span class="s1">self.fail(</span><span class="s4">'Sequence size mismatch: {} vs {}'</span><span class="s1">.format(</span>
          <span class="s1">len(expected_seq)</span><span class="s3">, </span><span class="s1">len(actual_seq))</span><span class="s3">, </span><span class="s1">msg)</span>

    <span class="s1">err_list = []</span>
    <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">(exp_elem</span><span class="s3">, </span><span class="s1">act_elem) </span><span class="s3">in </span><span class="s1">enumerate(zip(expected_seq</span><span class="s3">, </span><span class="s1">actual_seq)):</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s0"># assertAlmostEqual should be called with at most one of `places` and</span>
        <span class="s0"># `delta`. However, it's okay for assertSequenceAlmostEqual to pass</span>
        <span class="s0"># both because we want the latter to fail if the former does.</span>
        <span class="s0"># pytype: disable=wrong-keyword-args</span>
        <span class="s1">self.assertAlmostEqual(exp_elem</span><span class="s3">, </span><span class="s1">act_elem</span><span class="s3">, </span><span class="s1">places=places</span><span class="s3">, </span><span class="s1">msg=msg</span><span class="s3">,</span>
                               <span class="s1">delta=delta)</span>
        <span class="s0"># pytype: enable=wrong-keyword-args</span>
      <span class="s3">except </span><span class="s1">self.failureException </span><span class="s3">as </span><span class="s1">err:</span>
        <span class="s1">err_list.append(</span><span class="s4">'At index {}: {}'</span><span class="s1">.format(idx</span><span class="s3">, </span><span class="s1">err))</span>

    <span class="s3">if </span><span class="s1">err_list:</span>
      <span class="s3">if </span><span class="s1">len(err_list) &gt; </span><span class="s5">30</span><span class="s1">:</span>
        <span class="s1">err_list = err_list[:</span><span class="s5">30</span><span class="s1">] + [</span><span class="s4">'...'</span><span class="s1">]</span>
      <span class="s1">msg = self._formatMessage(msg</span><span class="s3">, </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(err_list))</span>
      <span class="s1">self.fail(msg)</span>

  <span class="s3">def </span><span class="s1">assertContainsSubset(self</span><span class="s3">, </span><span class="s1">expected_subset</span><span class="s3">, </span><span class="s1">actual_set</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Checks whether actual iterable is a superset of expected iterable.&quot;&quot;&quot;</span>
    <span class="s1">missing = set(expected_subset) - set(actual_set)</span>
    <span class="s3">if not </span><span class="s1">missing:</span>
      <span class="s3">return</span>

    <span class="s1">self.fail(</span><span class="s4">'Missing elements %s</span><span class="s3">\n</span><span class="s4">Expected: %s</span><span class="s3">\n</span><span class="s4">Actual: %s' </span><span class="s1">% (</span>
        <span class="s1">missing</span><span class="s3">, </span><span class="s1">expected_subset</span><span class="s3">, </span><span class="s1">actual_set)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertNoCommonElements(self</span><span class="s3">, </span><span class="s1">expected_seq</span><span class="s3">, </span><span class="s1">actual_seq</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Checks whether actual iterable and expected iterable are disjoint.&quot;&quot;&quot;</span>
    <span class="s1">common = set(expected_seq) &amp; set(actual_seq)</span>
    <span class="s3">if not </span><span class="s1">common:</span>
      <span class="s3">return</span>

    <span class="s1">self.fail(</span><span class="s4">'Common elements %s</span><span class="s3">\n</span><span class="s4">Expected: %s</span><span class="s3">\n</span><span class="s4">Actual: %s' </span><span class="s1">% (</span>
        <span class="s1">common</span><span class="s3">, </span><span class="s1">expected_seq</span><span class="s3">, </span><span class="s1">actual_seq)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertItemsEqual(self</span><span class="s3">, </span><span class="s1">expected_seq</span><span class="s3">, </span><span class="s1">actual_seq</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Deprecated, please use assertCountEqual instead. 
 
    This is equivalent to assertCountEqual. 
 
    Args: 
      expected_seq: A sequence containing elements we are expecting. 
      actual_seq: The sequence that we are testing. 
      msg: The message to be printed if the test fails. 
    &quot;&quot;&quot;</span>
    <span class="s1">super().assertCountEqual(expected_seq</span><span class="s3">, </span><span class="s1">actual_seq</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertSameElements(self</span><span class="s3">, </span><span class="s1">expected_seq</span><span class="s3">, </span><span class="s1">actual_seq</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that two sequences have the same elements (in any order). 
 
    This method, unlike assertCountEqual, doesn't care about any 
    duplicates in the expected and actual sequences:: 
 
        # Doesn't raise an AssertionError 
        assertSameElements([1, 1, 1, 0, 0, 0], [0, 1]) 
 
    If possible, you should use assertCountEqual instead of 
    assertSameElements. 
 
    Args: 
      expected_seq: A sequence containing elements we are expecting. 
      actual_seq: The sequence that we are testing. 
      msg: The message to be printed if the test fails. 
    &quot;&quot;&quot;</span>
    <span class="s0"># `unittest2.TestCase` used to have assertSameElements, but it was</span>
    <span class="s0"># removed in favor of assertItemsEqual. As there's a unit test</span>
    <span class="s0"># that explicitly checks this behavior, I am leaving this method</span>
    <span class="s0"># alone.</span>
    <span class="s0"># Fail on strings: empirically, passing strings to this test method</span>
    <span class="s0"># is almost always a bug. If comparing the character sets of two strings</span>
    <span class="s0"># is desired, cast the inputs to sets or lists explicitly.</span>
    <span class="s3">if </span><span class="s1">(isinstance(expected_seq</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES) </span><span class="s3">or</span>
        <span class="s1">isinstance(actual_seq</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES)):</span>
      <span class="s1">self.fail(</span><span class="s4">'Passing string/bytes to assertSameElements is usually a bug. '</span>
                <span class="s4">'Did you mean to use assertEqual?</span><span class="s3">\n</span><span class="s4">'</span>
                <span class="s4">'Expected: %s</span><span class="s3">\n</span><span class="s4">Actual: %s' </span><span class="s1">% (expected_seq</span><span class="s3">, </span><span class="s1">actual_seq))</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">expected = dict([(element</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">expected_seq])</span>
      <span class="s1">actual = dict([(element</span><span class="s3">, None</span><span class="s1">) </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">actual_seq])</span>
      <span class="s1">missing = [element </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">expected </span><span class="s3">if </span><span class="s1">element </span><span class="s3">not in </span><span class="s1">actual]</span>
      <span class="s1">unexpected = [element </span><span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">actual </span><span class="s3">if </span><span class="s1">element </span><span class="s3">not in </span><span class="s1">expected]</span>
      <span class="s1">missing.sort()</span>
      <span class="s1">unexpected.sort()</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
      <span class="s0"># Fall back to slower list-compare if any of the objects are</span>
      <span class="s0"># not hashable.</span>
      <span class="s1">expected = list(expected_seq)</span>
      <span class="s1">actual = list(actual_seq)</span>
      <span class="s1">expected.sort()</span>
      <span class="s1">actual.sort()</span>
      <span class="s1">missing</span><span class="s3">, </span><span class="s1">unexpected = _sorted_list_difference(expected</span><span class="s3">, </span><span class="s1">actual)</span>
    <span class="s1">errors = []</span>
    <span class="s3">if </span><span class="s1">msg:</span>
      <span class="s1">errors.extend((msg</span><span class="s3">, </span><span class="s4">':</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">))</span>
    <span class="s3">if </span><span class="s1">missing:</span>
      <span class="s1">errors.append(</span><span class="s4">'Expected, but missing:</span><span class="s3">\n  </span><span class="s4">%r</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% missing)</span>
    <span class="s3">if </span><span class="s1">unexpected:</span>
      <span class="s1">errors.append(</span><span class="s4">'Unexpected, but present:</span><span class="s3">\n  </span><span class="s4">%r</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% unexpected)</span>
    <span class="s3">if </span><span class="s1">missing </span><span class="s3">or </span><span class="s1">unexpected:</span>
      <span class="s1">self.fail(</span><span class="s4">''</span><span class="s1">.join(errors))</span>

  <span class="s0"># unittest.TestCase.assertMultiLineEqual works very similarly, but it</span>
  <span class="s0"># has a different error format. However, I find this slightly more readable.</span>
  <span class="s3">def </span><span class="s1">assertMultiLineEqual(self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that two multi-line strings are equal.&quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">isinstance(first</span><span class="s3">,</span>
                      <span class="s1">str)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'First argument is not a string: %r' </span><span class="s1">% (first</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s3">assert </span><span class="s1">isinstance(second</span><span class="s3">,</span>
                      <span class="s1">str)</span><span class="s3">, </span><span class="s1">(</span><span class="s4">'Second argument is not a string: %r' </span><span class="s1">% (second</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s1">line_limit = kwargs.pop(</span><span class="s4">'line_limit'</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">kwargs:</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Unexpected keyword args {}'</span><span class="s1">.format(tuple(kwargs)))</span>

    <span class="s3">if </span><span class="s1">first == second:</span>
      <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">msg:</span>
      <span class="s1">failure_message = [msg + </span><span class="s4">':</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">failure_message = [</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">line_limit:</span>
      <span class="s1">line_limit += len(failure_message)</span>
    <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">difflib.ndiff(first.splitlines(</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">second.splitlines(</span><span class="s3">True</span><span class="s1">)):</span>
      <span class="s1">failure_message.append(line)</span>
      <span class="s3">if not </span><span class="s1">line.endswith(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">):</span>
        <span class="s1">failure_message.append(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">line_limit </span><span class="s3">and </span><span class="s1">len(failure_message) &gt; line_limit:</span>
      <span class="s1">n_omitted = len(failure_message) - line_limit</span>
      <span class="s1">failure_message = failure_message[:line_limit]</span>
      <span class="s1">failure_message.append(</span>
          <span class="s4">'(... and {} more delta lines omitted for brevity.)</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.format(</span>
              <span class="s1">n_omitted))</span>

    <span class="s3">raise </span><span class="s1">self.failureException(</span><span class="s4">''</span><span class="s1">.join(failure_message))</span>

  <span class="s3">def </span><span class="s1">assertBetween(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">minv</span><span class="s3">, </span><span class="s1">maxv</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that value is between minv and maxv (inclusive).&quot;&quot;&quot;</span>
    <span class="s1">msg = self._formatMessage(msg</span><span class="s3">,</span>
                              <span class="s4">'&quot;%r&quot; unexpectedly not between &quot;%r&quot; and &quot;%r&quot;' </span><span class="s1">%</span>
                              <span class="s1">(value</span><span class="s3">, </span><span class="s1">minv</span><span class="s3">, </span><span class="s1">maxv))</span>
    <span class="s1">self.assertTrue(minv &lt;= value</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertTrue(maxv &gt;= value</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertRegexMatch(self</span><span class="s3">, </span><span class="s1">actual_str</span><span class="s3">, </span><span class="s1">regexes</span><span class="s3">, </span><span class="s1">message=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">r&quot;&quot;&quot;Asserts that at least one regex in regexes matches str. 
 
    If possible you should use `assertRegex`, which is a simpler 
    version of this method. `assertRegex` takes a single regular 
    expression (a string or re compiled object) instead of a list. 
 
    Notes: 
 
    1. This function uses substring matching, i.e. the matching 
       succeeds if *any* substring of the error message matches *any* 
       regex in the list.  This is more convenient for the user than 
       full-string matching. 
 
    2. If regexes is the empty list, the matching will always fail. 
 
    3. Use regexes=[''] for a regex that will always pass. 
 
    4. '.' matches any single character *except* the newline.  To 
       match any character, use '(.|\n)'. 
 
    5. '^' matches the beginning of each line, not just the beginning 
       of the string.  Similarly, '$' matches the end of each line. 
 
    6. An exception will be thrown if regexes contains an invalid 
       regex. 
 
    Args: 
      actual_str:  The string we try to match with the items in regexes. 
      regexes:  The regular expressions we want to match against str. 
          See &quot;Notes&quot; above for detailed notes on how this is interpreted. 
      message:  The message to be printed if the test fails. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(regexes</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES):</span>
      <span class="s1">self.fail(</span><span class="s4">'regexes is string or bytes; use assertRegex instead.'</span><span class="s3">,</span>
                <span class="s1">message)</span>
    <span class="s3">if not </span><span class="s1">regexes:</span>
      <span class="s1">self.fail(</span><span class="s4">'No regexes specified.'</span><span class="s3">, </span><span class="s1">message)</span>

    <span class="s1">regex_type = type(regexes[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">for </span><span class="s1">regex </span><span class="s3">in </span><span class="s1">regexes[</span><span class="s5">1</span><span class="s1">:]:</span>
      <span class="s3">if </span><span class="s1">type(regex) </span><span class="s3">is not </span><span class="s1">regex_type:  </span><span class="s0"># pylint: disable=unidiomatic-typecheck</span>
        <span class="s1">self.fail(</span><span class="s4">'regexes list must all be the same type.'</span><span class="s3">, </span><span class="s1">message)</span>

    <span class="s3">if </span><span class="s1">regex_type </span><span class="s3">is </span><span class="s1">bytes </span><span class="s3">and </span><span class="s1">isinstance(actual_str</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s1">regexes = [regex.decode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">regex </span><span class="s3">in </span><span class="s1">regexes]</span>
      <span class="s1">regex_type = str</span>
    <span class="s3">elif </span><span class="s1">regex_type </span><span class="s3">is </span><span class="s1">str </span><span class="s3">and </span><span class="s1">isinstance(actual_str</span><span class="s3">, </span><span class="s1">bytes):</span>
      <span class="s1">regexes = [regex.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">regex </span><span class="s3">in </span><span class="s1">regexes]</span>
      <span class="s1">regex_type = bytes</span>

    <span class="s3">if </span><span class="s1">regex_type </span><span class="s3">is </span><span class="s1">str:</span>
      <span class="s1">regex = </span><span class="s4">u'(?:%s)' </span><span class="s1">% </span><span class="s4">u')|(?:'</span><span class="s1">.join(regexes)</span>
    <span class="s3">elif </span><span class="s1">regex_type </span><span class="s3">is </span><span class="s1">bytes:</span>
      <span class="s1">regex = </span><span class="s6">b'(?:' </span><span class="s1">+ (</span><span class="s6">b')|(?:'</span><span class="s1">.join(regexes)) + </span><span class="s6">b')'</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">self.fail(</span><span class="s4">'Only know how to deal with unicode str or bytes regexes.'</span><span class="s3">,</span>
                <span class="s1">message)</span>

    <span class="s3">if not </span><span class="s1">re.search(regex</span><span class="s3">, </span><span class="s1">actual_str</span><span class="s3">, </span><span class="s1">re.MULTILINE):</span>
      <span class="s1">self.fail(</span><span class="s4">'&quot;%s&quot; does not contain any of these regexes: %s.' </span><span class="s1">%</span>
                <span class="s1">(actual_str</span><span class="s3">, </span><span class="s1">regexes)</span><span class="s3">, </span><span class="s1">message)</span>

  <span class="s3">def </span><span class="s1">assertCommandSucceeds(self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">, </span><span class="s1">regexes=(</span><span class="s6">b''</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">env=</span><span class="s3">None,</span>
                            <span class="s1">close_fds=</span><span class="s3">True, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that a shell command succeeds (i.e. exits with code 0). 
 
    Args: 
      command: List or string representing the command to run. 
      regexes: List of regular expression byte strings that match success. 
      env: Dictionary of environment variable settings. If None, no environment 
          variables will be set for the child process. This is to make tests 
          more hermetic. NOTE: this behavior is different than the standard 
          subprocess module. 
      close_fds: Whether or not to close all open fd's in the child after 
          forking. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s1">(ret_code</span><span class="s3">, </span><span class="s1">err) = get_command_stderr(command</span><span class="s3">, </span><span class="s1">env</span><span class="s3">, </span><span class="s1">close_fds)</span>

    <span class="s0"># We need bytes regexes here because `err` is bytes.</span>
    <span class="s0"># Accommodate code which listed their output regexes w/o the b'' prefix by</span>
    <span class="s0"># converting them to bytes for the user.</span>
    <span class="s3">if </span><span class="s1">isinstance(regexes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s1">regexes = [regex.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">regex </span><span class="s3">in </span><span class="s1">regexes]</span>

    <span class="s1">command_string = get_command_string(command)</span>
    <span class="s1">self.assertEqual(</span>
        <span class="s1">ret_code</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                            <span class="s4">'Running command</span><span class="s3">\n</span><span class="s4">'</span>
                            <span class="s4">'%s failed with error code %s and message</span><span class="s3">\n</span><span class="s4">'</span>
                            <span class="s4">'%s' </span><span class="s1">% (_quote_long_string(command_string)</span><span class="s3">,</span>
                                    <span class="s1">ret_code</span><span class="s3">,</span>
                                    <span class="s1">_quote_long_string(err)))</span>
    <span class="s1">)</span>
    <span class="s1">self.assertRegexMatch(</span>
        <span class="s1">err</span><span class="s3">,</span>
        <span class="s1">regexes</span><span class="s3">,</span>
        <span class="s1">message=self._formatMessage(</span>
            <span class="s1">msg</span><span class="s3">,</span>
            <span class="s4">'Running command</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s4">'%s failed with error code %s and message</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s4">'%s which matches no regex in %s' </span><span class="s1">% (</span>
                <span class="s1">_quote_long_string(command_string)</span><span class="s3">,</span>
                <span class="s1">ret_code</span><span class="s3">,</span>
                <span class="s1">_quote_long_string(err)</span><span class="s3">,</span>
                <span class="s1">regexes)))</span>

  <span class="s3">def </span><span class="s1">assertCommandFails(self</span><span class="s3">, </span><span class="s1">command</span><span class="s3">, </span><span class="s1">regexes</span><span class="s3">, </span><span class="s1">env=</span><span class="s3">None, </span><span class="s1">close_fds=</span><span class="s3">True,</span>
                         <span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts a shell command fails and the error matches a regex in a list. 
 
    Args: 
      command: List or string representing the command to run. 
      regexes: the list of regular expression strings. 
      env: Dictionary of environment variable settings. If None, no environment 
          variables will be set for the child process. This is to make tests 
          more hermetic. NOTE: this behavior is different than the standard 
          subprocess module. 
      close_fds: Whether or not to close all open fd's in the child after 
          forking. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s1">(ret_code</span><span class="s3">, </span><span class="s1">err) = get_command_stderr(command</span><span class="s3">, </span><span class="s1">env</span><span class="s3">, </span><span class="s1">close_fds)</span>

    <span class="s0"># We need bytes regexes here because `err` is bytes.</span>
    <span class="s0"># Accommodate code which listed their output regexes w/o the b'' prefix by</span>
    <span class="s0"># converting them to bytes for the user.</span>
    <span class="s3">if </span><span class="s1">isinstance(regexes[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s1">regexes = [regex.encode(</span><span class="s4">'utf-8'</span><span class="s1">) </span><span class="s3">for </span><span class="s1">regex </span><span class="s3">in </span><span class="s1">regexes]</span>

    <span class="s1">command_string = get_command_string(command)</span>
    <span class="s1">self.assertNotEqual(</span>
        <span class="s1">ret_code</span><span class="s3">, </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">self._formatMessage(msg</span><span class="s3">, </span><span class="s4">'The following command succeeded '</span>
                            <span class="s4">'while expected to fail:</span><span class="s3">\n</span><span class="s4">%s' </span><span class="s1">%</span>
                            <span class="s1">_quote_long_string(command_string)))</span>
    <span class="s1">self.assertRegexMatch(</span>
        <span class="s1">err</span><span class="s3">,</span>
        <span class="s1">regexes</span><span class="s3">,</span>
        <span class="s1">message=self._formatMessage(</span>
            <span class="s1">msg</span><span class="s3">,</span>
            <span class="s4">'Running command</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s4">'%s failed with error code %s and message</span><span class="s3">\n</span><span class="s4">'</span>
            <span class="s4">'%s which matches no regex in %s' </span><span class="s1">% (</span>
                <span class="s1">_quote_long_string(command_string)</span><span class="s3">,</span>
                <span class="s1">ret_code</span><span class="s3">,</span>
                <span class="s1">_quote_long_string(err)</span><span class="s3">,</span>
                <span class="s1">regexes)))</span>

  <span class="s3">class </span><span class="s1">_AssertRaisesContext(object):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">test_case</span><span class="s3">, </span><span class="s1">test_func</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
      <span class="s1">self.expected_exception = expected_exception</span>
      <span class="s1">self.test_case = test_case</span>
      <span class="s1">self.test_func = test_func</span>
      <span class="s1">self.msg = msg</span>

    <span class="s3">def </span><span class="s1">__enter__(self):</span>
      <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__exit__(self</span><span class="s3">, </span><span class="s1">exc_type</span><span class="s3">, </span><span class="s1">exc_value</span><span class="s3">, </span><span class="s1">tb):</span>
      <span class="s3">if </span><span class="s1">exc_type </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">self.test_case.fail(self.expected_exception.__name__ + </span><span class="s4">' not raised'</span><span class="s3">,</span>
                            <span class="s1">self.msg)</span>
      <span class="s3">if not </span><span class="s1">issubclass(exc_type</span><span class="s3">, </span><span class="s1">self.expected_exception):</span>
        <span class="s3">return False</span>
      <span class="s1">self.test_func(exc_value)</span>
      <span class="s3">if </span><span class="s1">exc_value:</span>
        <span class="s1">self.exception = exc_value.with_traceback(</span><span class="s3">None</span><span class="s1">)</span>
      <span class="s3">return True</span>

  <span class="s1">@typing.overload</span>
  <span class="s3">def </span><span class="s1">assertRaisesWithPredicateMatch(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">predicate) -&gt; _AssertRaisesContext:</span>
    <span class="s0"># The purpose of this return statement is to work around</span>
    <span class="s0"># https://github.com/PyCQA/pylint/issues/5273; it is otherwise ignored.</span>
    <span class="s3">return </span><span class="s1">self._AssertRaisesContext(</span><span class="s3">None, None, None</span><span class="s1">)</span>

  <span class="s1">@typing.overload</span>
  <span class="s3">def </span><span class="s1">assertRaisesWithPredicateMatch(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">callable_obj: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">,</span>
      <span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># The purpose of this return statement is to work around</span>
    <span class="s0"># https://github.com/PyCQA/pylint/issues/5273; it is otherwise ignored.</span>
    <span class="s3">return </span><span class="s1">self._AssertRaisesContext(</span><span class="s3">None, None, None</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">assertRaisesWithPredicateMatch(self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">,</span>
                                     <span class="s1">callable_obj=</span><span class="s3">None, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that exception is thrown and predicate(exception) is true. 
 
    Args: 
      expected_exception: Exception class expected to be raised. 
      predicate: Function of one argument that inspects the passed-in exception 
          and returns True (success) or False (please fail the test). 
      callable_obj: Function to be called. 
      *args: Extra args. 
      **kwargs: Extra keyword args. 
 
    Returns: 
      A context manager if callable_obj is None. Otherwise, None. 
 
    Raises: 
      self.failureException if callable_obj does not raise a matching exception. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">Check(err):</span>
      <span class="s1">self.assertTrue(predicate(err)</span><span class="s3">,</span>
                      <span class="s4">'%r does not match predicate %r' </span><span class="s1">% (err</span><span class="s3">, </span><span class="s1">predicate))</span>

    <span class="s1">context = self._AssertRaisesContext(expected_exception</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">Check)</span>
    <span class="s3">if </span><span class="s1">callable_obj </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">context</span>
    <span class="s3">with </span><span class="s1">context:</span>
      <span class="s1">callable_obj(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

  <span class="s1">@typing.overload</span>
  <span class="s3">def </span><span class="s1">assertRaisesWithLiteralMatch(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">expected_exception_message</span>
  <span class="s1">) -&gt; _AssertRaisesContext:</span>
    <span class="s0"># The purpose of this return statement is to work around</span>
    <span class="s0"># https://github.com/PyCQA/pylint/issues/5273; it is otherwise ignored.</span>
    <span class="s3">return </span><span class="s1">self._AssertRaisesContext(</span><span class="s3">None, None, None</span><span class="s1">)</span>

  <span class="s1">@typing.overload</span>
  <span class="s3">def </span><span class="s1">assertRaisesWithLiteralMatch(</span>
      <span class="s1">self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">, </span><span class="s1">expected_exception_message</span><span class="s3">,</span>
      <span class="s1">callable_obj: Callable[...</span><span class="s3">, </span><span class="s1">Any]</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s0"># The purpose of this return statement is to work around</span>
    <span class="s0"># https://github.com/PyCQA/pylint/issues/5273; it is otherwise ignored.</span>
    <span class="s3">return </span><span class="s1">self._AssertRaisesContext(</span><span class="s3">None, None, None</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">assertRaisesWithLiteralMatch(self</span><span class="s3">, </span><span class="s1">expected_exception</span><span class="s3">,</span>
                                   <span class="s1">expected_exception_message</span><span class="s3">,</span>
                                   <span class="s1">callable_obj=</span><span class="s3">None, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that the message in a raised exception equals the given string. 
 
    Unlike assertRaisesRegex, this method takes a literal string, not 
    a regular expression. 
 
    with self.assertRaisesWithLiteralMatch(ExType, 'message'): 
      DoSomething() 
 
    Args: 
      expected_exception: Exception class expected to be raised. 
      expected_exception_message: String message expected in the raised 
          exception.  For a raise exception e, expected_exception_message must 
          equal str(e). 
      callable_obj: Function to be called, or None to return a context. 
      *args: Extra args. 
      **kwargs: Extra kwargs. 
 
    Returns: 
      A context manager if callable_obj is None. Otherwise, None. 
 
    Raises: 
      self.failureException if callable_obj does not raise a matching exception. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">Check(err):</span>
      <span class="s1">actual_exception_message = str(err)</span>
      <span class="s1">self.assertTrue(expected_exception_message == actual_exception_message</span><span class="s3">,</span>
                      <span class="s4">'Exception message does not match.</span><span class="s3">\n</span><span class="s4">'</span>
                      <span class="s4">'Expected: %r</span><span class="s3">\n</span><span class="s4">'</span>
                      <span class="s4">'Actual: %r' </span><span class="s1">% (expected_exception_message</span><span class="s3">,</span>
                                      <span class="s1">actual_exception_message))</span>

    <span class="s1">context = self._AssertRaisesContext(expected_exception</span><span class="s3">, </span><span class="s1">self</span><span class="s3">, </span><span class="s1">Check)</span>
    <span class="s3">if </span><span class="s1">callable_obj </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">context</span>
    <span class="s3">with </span><span class="s1">context:</span>
      <span class="s1">callable_obj(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

  <span class="s3">def </span><span class="s1">assertContainsInOrder(self</span><span class="s3">, </span><span class="s1">strings</span><span class="s3">, </span><span class="s1">target</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that the strings provided are found in the target in order. 
 
    This may be useful for checking HTML output. 
 
    Args: 
      strings: A list of strings, such as [ 'fox', 'dog' ] 
      target: A target string in which to look for the strings, such as 
          'The quick brown fox jumped over the lazy dog'. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(strings</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">unicode </span><span class="s3">if </span><span class="s1">str </span><span class="s3">is </span><span class="s1">bytes </span><span class="s3">else </span><span class="s1">str)):</span>
      <span class="s1">strings = (strings</span><span class="s3">,</span><span class="s1">)</span>

    <span class="s1">current_index = </span><span class="s5">0</span>
    <span class="s1">last_string = </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">string </span><span class="s3">in </span><span class="s1">strings:</span>
      <span class="s1">index = target.find(str(string)</span><span class="s3">, </span><span class="s1">current_index)</span>
      <span class="s3">if </span><span class="s1">index == -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">current_index == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">self.fail(</span><span class="s4">&quot;Did not find '%s' in '%s'&quot; </span><span class="s1">%</span>
                  <span class="s1">(string</span><span class="s3">, </span><span class="s1">target)</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s3">elif </span><span class="s1">index == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">self.fail(</span><span class="s4">&quot;Did not find '%s' after '%s' in '%s'&quot; </span><span class="s1">%</span>
                  <span class="s1">(string</span><span class="s3">, </span><span class="s1">last_string</span><span class="s3">, </span><span class="s1">target)</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">last_string = string</span>
      <span class="s1">current_index = index</span>

  <span class="s3">def </span><span class="s1">assertContainsSubsequence(self</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">subsequence</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that &quot;container&quot; contains &quot;subsequence&quot; as a subsequence. 
 
    Asserts that &quot;container&quot; contains all the elements of &quot;subsequence&quot;, in 
    order, but possibly with other elements interspersed. For example, [1, 2, 3] 
    is a subsequence of [0, 0, 1, 2, 0, 3, 0] but not of [0, 0, 1, 3, 0, 2, 0]. 
 
    Args: 
      container: the list we're testing for subsequence inclusion. 
      subsequence: the list we hope will be a subsequence of container. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s1">first_nonmatching = </span><span class="s3">None</span>
    <span class="s1">reversed_container = list(reversed(container))</span>
    <span class="s1">subsequence = list(subsequence)</span>

    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">subsequence:</span>
      <span class="s3">if </span><span class="s1">e </span><span class="s3">not in </span><span class="s1">reversed_container:</span>
        <span class="s1">first_nonmatching = e</span>
        <span class="s3">break</span>
      <span class="s3">while </span><span class="s1">e != reversed_container.pop():</span>
        <span class="s3">pass</span>

    <span class="s3">if </span><span class="s1">first_nonmatching </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">self.fail(</span><span class="s4">'%s not a subsequence of %s. First non-matching element: %s' </span><span class="s1">%</span>
                <span class="s1">(subsequence</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">first_nonmatching)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertContainsExactSubsequence(self</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">subsequence</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that &quot;container&quot; contains &quot;subsequence&quot; as an exact subsequence. 
 
    Asserts that &quot;container&quot; contains all the elements of &quot;subsequence&quot;, in 
    order, and without other elements interspersed. For example, [1, 2, 3] is an 
    exact subsequence of [0, 0, 1, 2, 3, 0] but not of [0, 0, 1, 2, 0, 3, 0]. 
 
    Args: 
      container: the list we're testing for subsequence inclusion. 
      subsequence: the list we hope will be an exact subsequence of container. 
      msg: Optional message to report on failure. 
    &quot;&quot;&quot;</span>
    <span class="s1">container = list(container)</span>
    <span class="s1">subsequence = list(subsequence)</span>
    <span class="s1">longest_match = </span><span class="s5">0</span>

    <span class="s3">for </span><span class="s1">start </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1 </span><span class="s1">+ len(container) - len(subsequence)):</span>
      <span class="s3">if </span><span class="s1">longest_match == len(subsequence):</span>
        <span class="s3">break</span>
      <span class="s1">index = </span><span class="s5">0</span>
      <span class="s3">while </span><span class="s1">(index &lt; len(subsequence) </span><span class="s3">and</span>
             <span class="s1">subsequence[index] == container[start + index]):</span>
        <span class="s1">index += </span><span class="s5">1</span>
      <span class="s1">longest_match = max(longest_match</span><span class="s3">, </span><span class="s1">index)</span>

    <span class="s3">if </span><span class="s1">longest_match &lt; len(subsequence):</span>
      <span class="s1">self.fail(</span><span class="s4">'%s not an exact subsequence of %s. '</span>
                <span class="s4">'Longest matching prefix: %s' </span><span class="s1">%</span>
                <span class="s1">(subsequence</span><span class="s3">, </span><span class="s1">container</span><span class="s3">, </span><span class="s1">subsequence[:longest_match])</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertTotallyOrdered(self</span><span class="s3">, </span><span class="s1">*groups</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that total ordering has been implemented correctly. 
 
    For example, say you have a class A that compares only on its attribute x. 
    Comparators other than ``__lt__`` are omitted for brevity:: 
 
        class A(object): 
          def __init__(self, x, y): 
            self.x = x 
            self.y = y 
 
          def __hash__(self): 
            return hash(self.x) 
 
          def __lt__(self, other): 
            try: 
              return self.x &lt; other.x 
            except AttributeError: 
              return NotImplemented 
 
    assertTotallyOrdered will check that instances can be ordered correctly. 
    For example:: 
 
        self.assertTotallyOrdered( 
            [None],  # None should come before everything else. 
            [1],  # Integers sort earlier. 
            [A(1, 'a')], 
            [A(2, 'b')],  # 2 is after 1. 
            [A(3, 'c'), A(3, 'd')],  # The second argument is irrelevant. 
            [A(4, 'z')], 
            ['foo'])  # Strings sort last. 
 
    Args: 
      *groups: A list of groups of elements.  Each group of elements is a list 
        of objects that are equal.  The elements in each group must be less 
        than the elements in the group after it.  For example, these groups are 
        totally ordered: ``[None]``, ``[1]``, ``[2, 2]``, ``[3]``. 
      **kwargs: optional msg keyword argument can be passed. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">CheckOrder(small</span><span class="s3">, </span><span class="s1">big):</span>
      <span class="s2">&quot;&quot;&quot;Ensures small is ordered before big.&quot;&quot;&quot;</span>
      <span class="s1">self.assertFalse(small == big</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">, </span><span class="s4">'%r unexpectedly equals %r' </span><span class="s1">%</span>
                                           <span class="s1">(small</span><span class="s3">, </span><span class="s1">big)))</span>
      <span class="s1">self.assertTrue(small != big</span><span class="s3">,</span>
                      <span class="s1">self._formatMessage(msg</span><span class="s3">, </span><span class="s4">'%r unexpectedly equals %r' </span><span class="s1">%</span>
                                          <span class="s1">(small</span><span class="s3">, </span><span class="s1">big)))</span>
      <span class="s1">self.assertLess(small</span><span class="s3">, </span><span class="s1">big</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertFalse(big &lt; small</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly less than %r' </span><span class="s1">%</span>
                                           <span class="s1">(big</span><span class="s3">, </span><span class="s1">small)))</span>
      <span class="s1">self.assertLessEqual(small</span><span class="s3">, </span><span class="s1">big</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertFalse(big &lt;= small</span><span class="s3">, </span><span class="s1">self._formatMessage(</span>
          <span class="s4">'%r unexpectedly less than or equal to %r' </span><span class="s1">% (big</span><span class="s3">, </span><span class="s1">small)</span><span class="s3">, </span><span class="s1">msg</span>
      <span class="s1">))</span>
      <span class="s1">self.assertGreater(big</span><span class="s3">, </span><span class="s1">small</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertFalse(small &gt; big</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly greater than %r' </span><span class="s1">%</span>
                                           <span class="s1">(small</span><span class="s3">, </span><span class="s1">big)))</span>
      <span class="s1">self.assertGreaterEqual(big</span><span class="s3">, </span><span class="s1">small)</span>
      <span class="s1">self.assertFalse(small &gt;= big</span><span class="s3">, </span><span class="s1">self._formatMessage(</span>
          <span class="s1">msg</span><span class="s3">,</span>
          <span class="s4">'%r unexpectedly greater than or equal to %r' </span><span class="s1">% (small</span><span class="s3">, </span><span class="s1">big)))</span>

    <span class="s3">def </span><span class="s1">CheckEqual(a</span><span class="s3">, </span><span class="s1">b):</span>
      <span class="s2">&quot;&quot;&quot;Ensures that a and b are equal.&quot;&quot;&quot;</span>
      <span class="s1">self.assertEqual(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertFalse(a != b</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">, </span><span class="s4">'%r unexpectedly unequals %r' </span><span class="s1">%</span>
                                           <span class="s1">(a</span><span class="s3">, </span><span class="s1">b)))</span>

      <span class="s0"># Objects that compare equal must hash to the same value, but this only</span>
      <span class="s0"># applies if both objects are hashable.</span>
      <span class="s3">if </span><span class="s1">(isinstance(a</span><span class="s3">, </span><span class="s1">abc.Hashable) </span><span class="s3">and</span>
          <span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">abc.Hashable)):</span>
        <span class="s1">self.assertEqual(</span>
            <span class="s1">hash(a)</span><span class="s3">, </span><span class="s1">hash(b)</span><span class="s3">,</span>
            <span class="s1">self._formatMessage(</span>
                <span class="s1">msg</span><span class="s3">, </span><span class="s4">'hash %d of %r unexpectedly not equal to hash %d of %r' </span><span class="s1">%</span>
                <span class="s1">(hash(a)</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">hash(b)</span><span class="s3">, </span><span class="s1">b)))</span>

      <span class="s1">self.assertFalse(a &lt; b</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly less than %r' </span><span class="s1">%</span>
                                           <span class="s1">(a</span><span class="s3">, </span><span class="s1">b)))</span>
      <span class="s1">self.assertFalse(b &lt; a</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly less than %r' </span><span class="s1">%</span>
                                           <span class="s1">(b</span><span class="s3">, </span><span class="s1">a)))</span>
      <span class="s1">self.assertLessEqual(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertLessEqual(b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">msg)  </span><span class="s0"># pylint: disable=arguments-out-of-order</span>
      <span class="s1">self.assertFalse(a &gt; b</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly greater than %r' </span><span class="s1">%</span>
                                           <span class="s1">(a</span><span class="s3">, </span><span class="s1">b)))</span>
      <span class="s1">self.assertFalse(b &gt; a</span><span class="s3">,</span>
                       <span class="s1">self._formatMessage(msg</span><span class="s3">,</span>
                                           <span class="s4">'%r unexpectedly greater than %r' </span><span class="s1">%</span>
                                           <span class="s1">(b</span><span class="s3">, </span><span class="s1">a)))</span>
      <span class="s1">self.assertGreaterEqual(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">msg)</span>
      <span class="s1">self.assertGreaterEqual(b</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">msg)  </span><span class="s0"># pylint: disable=arguments-out-of-order</span>

    <span class="s1">msg = kwargs.get(</span><span class="s4">'msg'</span><span class="s1">)</span>

    <span class="s0"># For every combination of elements, check the order of every pair of</span>
    <span class="s0"># elements.</span>
    <span class="s3">for </span><span class="s1">elements </span><span class="s3">in </span><span class="s1">itertools.product(*groups):</span>
      <span class="s1">elements = list(elements)</span>
      <span class="s3">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">small </span><span class="s3">in </span><span class="s1">enumerate(elements[:-</span><span class="s5">1</span><span class="s1">]):</span>
        <span class="s3">for </span><span class="s1">big </span><span class="s3">in </span><span class="s1">elements[index + </span><span class="s5">1</span><span class="s1">:]:</span>
          <span class="s1">CheckOrder(small</span><span class="s3">, </span><span class="s1">big)</span>

    <span class="s0"># Check that every element in each group is equal.</span>
    <span class="s3">for </span><span class="s1">group </span><span class="s3">in </span><span class="s1">groups:</span>
      <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">group:</span>
        <span class="s1">CheckEqual(a</span><span class="s3">, </span><span class="s1">a)</span>
      <span class="s3">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">in </span><span class="s1">itertools.product(group</span><span class="s3">, </span><span class="s1">group):</span>
        <span class="s1">CheckEqual(a</span><span class="s3">, </span><span class="s1">b)</span>

  <span class="s3">def </span><span class="s1">assertDictEqual(self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Raises AssertionError if a and b are not equal dictionaries. 
 
    Args: 
      a: A dict, the expected value. 
      b: A dict, the actual value. 
      msg: An optional str, the associated message. 
 
    Raises: 
      AssertionError: if the dictionaries are not equal. 
    &quot;&quot;&quot;</span>
    <span class="s1">self.assertIsInstance(a</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">self._formatMessage(</span>
        <span class="s1">msg</span><span class="s3">,</span>
        <span class="s4">'First argument is not a dictionary'</span>
    <span class="s1">))</span>
    <span class="s1">self.assertIsInstance(b</span><span class="s3">, </span><span class="s1">dict</span><span class="s3">, </span><span class="s1">self._formatMessage(</span>
        <span class="s1">msg</span><span class="s3">,</span>
        <span class="s4">'Second argument is not a dictionary'</span>
    <span class="s1">))</span>

    <span class="s3">def </span><span class="s1">Sorted(list_of_items):</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">sorted(list_of_items)  </span><span class="s0"># In 3.3, unordered are possible.</span>
      <span class="s3">except </span><span class="s1">TypeError:</span>
        <span class="s3">return </span><span class="s1">list_of_items</span>

    <span class="s3">if </span><span class="s1">a == b:</span>
      <span class="s3">return</span>
    <span class="s1">a_items = Sorted(list(a.items()))</span>
    <span class="s1">b_items = Sorted(list(b.items()))</span>

    <span class="s1">unexpected = []</span>
    <span class="s1">missing = []</span>
    <span class="s1">different = []</span>

    <span class="s1">safe_repr = unittest.util.safe_repr  </span><span class="s0"># pytype: disable=module-attr</span>

    <span class="s3">def </span><span class="s1">Repr(dikt):</span>
      <span class="s2">&quot;&quot;&quot;Deterministic repr for dict.&quot;&quot;&quot;</span>
      <span class="s0"># Sort the entries based on their repr, not based on their sort order,</span>
      <span class="s0"># which will be non-deterministic across executions, for many types.</span>
      <span class="s1">entries = sorted((safe_repr(k)</span><span class="s3">, </span><span class="s1">safe_repr(v)) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">dikt.items())</span>
      <span class="s3">return </span><span class="s4">'{%s}' </span><span class="s1">% (</span><span class="s4">', '</span><span class="s1">.join(</span><span class="s4">'%s: %s' </span><span class="s1">% pair </span><span class="s3">for </span><span class="s1">pair </span><span class="s3">in </span><span class="s1">entries))</span>

    <span class="s1">message = [</span><span class="s4">'%s != %s%s' </span><span class="s1">% (Repr(a)</span><span class="s3">, </span><span class="s1">Repr(b)</span><span class="s3">, </span><span class="s4">' (%s)' </span><span class="s1">% msg </span><span class="s3">if </span><span class="s1">msg </span><span class="s3">else </span><span class="s4">''</span><span class="s1">)]</span>

    <span class="s0"># The standard library default output confounds lexical difference with</span>
    <span class="s0"># value difference; treat them separately.</span>
    <span class="s3">for </span><span class="s1">a_key</span><span class="s3">, </span><span class="s1">a_value </span><span class="s3">in </span><span class="s1">a_items:</span>
      <span class="s3">if </span><span class="s1">a_key </span><span class="s3">not in </span><span class="s1">b:</span>
        <span class="s1">missing.append((a_key</span><span class="s3">, </span><span class="s1">a_value))</span>
      <span class="s3">elif </span><span class="s1">a_value != b[a_key]:</span>
        <span class="s1">different.append((a_key</span><span class="s3">, </span><span class="s1">a_value</span><span class="s3">, </span><span class="s1">b[a_key]))</span>

    <span class="s3">for </span><span class="s1">b_key</span><span class="s3">, </span><span class="s1">b_value </span><span class="s3">in </span><span class="s1">b_items:</span>
      <span class="s3">if </span><span class="s1">b_key </span><span class="s3">not in </span><span class="s1">a:</span>
        <span class="s1">unexpected.append((b_key</span><span class="s3">, </span><span class="s1">b_value))</span>

    <span class="s3">if </span><span class="s1">unexpected:</span>
      <span class="s1">message.append(</span>
          <span class="s4">'Unexpected, but present entries:</span><span class="s3">\n</span><span class="s4">%s' </span><span class="s1">% </span><span class="s4">''</span><span class="s1">.join(</span>
              <span class="s4">'%s: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (safe_repr(k)</span><span class="s3">, </span><span class="s1">safe_repr(v)) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">unexpected))</span>

    <span class="s3">if </span><span class="s1">different:</span>
      <span class="s1">message.append(</span>
          <span class="s4">'repr() of differing entries:</span><span class="s3">\n</span><span class="s4">%s' </span><span class="s1">% </span><span class="s4">''</span><span class="s1">.join(</span>
              <span class="s4">'%s: %s != %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (safe_repr(k)</span><span class="s3">, </span><span class="s1">safe_repr(a_value)</span><span class="s3">,</span>
                                  <span class="s1">safe_repr(b_value))</span>
              <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a_value</span><span class="s3">, </span><span class="s1">b_value </span><span class="s3">in </span><span class="s1">different))</span>

    <span class="s3">if </span><span class="s1">missing:</span>
      <span class="s1">message.append(</span>
          <span class="s4">'Missing entries:</span><span class="s3">\n</span><span class="s4">%s' </span><span class="s1">% </span><span class="s4">''</span><span class="s1">.join(</span>
              <span class="s1">(</span><span class="s4">'%s: %s</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% (safe_repr(k)</span><span class="s3">, </span><span class="s1">safe_repr(v)) </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">missing)))</span>

    <span class="s3">raise </span><span class="s1">self.failureException(</span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(message))</span>

  <span class="s3">def </span><span class="s1">assertUrlEqual(self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that urls are equal, ignoring ordering of query params.&quot;&quot;&quot;</span>
    <span class="s1">parsed_a = parse.urlparse(a)</span>
    <span class="s1">parsed_b = parse.urlparse(b)</span>
    <span class="s1">self.assertEqual(parsed_a.scheme</span><span class="s3">, </span><span class="s1">parsed_b.scheme</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertEqual(parsed_a.netloc</span><span class="s3">, </span><span class="s1">parsed_b.netloc</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertEqual(parsed_a.path</span><span class="s3">, </span><span class="s1">parsed_b.path</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertEqual(parsed_a.fragment</span><span class="s3">, </span><span class="s1">parsed_b.fragment</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertEqual(sorted(parsed_a.params.split(</span><span class="s4">';'</span><span class="s1">))</span><span class="s3">,</span>
                     <span class="s1">sorted(parsed_b.params.split(</span><span class="s4">';'</span><span class="s1">))</span><span class="s3">, </span><span class="s1">msg)</span>
    <span class="s1">self.assertDictEqual(</span>
        <span class="s1">parse.parse_qs(parsed_a.query</span><span class="s3">, </span><span class="s1">keep_blank_values=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">parse.parse_qs(parsed_b.query</span><span class="s3">, </span><span class="s1">keep_blank_values=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertSameStructure(self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aname=</span><span class="s4">'a'</span><span class="s3">, </span><span class="s1">bname=</span><span class="s4">'b'</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that two values contain the same structural content. 
 
    The two arguments should be data trees consisting of trees of dicts and 
    lists. They will be deeply compared by walking into the contents of dicts 
    and lists; other items will be compared using the == operator. 
    If the two structures differ in content, the failure message will indicate 
    the location within the structures where the first difference is found. 
    This may be helpful when comparing large structures. 
 
    Mixed Sequence and Set types are supported. Mixed Mapping types are 
    supported, but the order of the keys will not be considered in the 
    comparison. 
 
    Args: 
      a: The first structure to compare. 
      b: The second structure to compare. 
      aname: Variable name to use for the first structure in assertion messages. 
      bname: Variable name to use for the second structure. 
      msg: Additional text to include in the failure message. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Accumulate all the problems found so we can report all of them at once</span>
    <span class="s0"># rather than just stopping at the first</span>
    <span class="s1">problems = []</span>

    <span class="s1">_walk_structure_for_problems(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aname</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">problems)</span>

    <span class="s0"># Avoid spamming the user toooo much</span>
    <span class="s3">if </span><span class="s1">self.maxDiff </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">max_problems_to_show = self.maxDiff // </span><span class="s5">80</span>
      <span class="s3">if </span><span class="s1">len(problems) &gt; max_problems_to_show:</span>
        <span class="s1">problems = problems[</span><span class="s5">0</span><span class="s1">:max_problems_to_show-</span><span class="s5">1</span><span class="s1">] + [</span><span class="s4">'...'</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">problems:</span>
      <span class="s1">self.fail(</span><span class="s4">'; '</span><span class="s1">.join(problems)</span><span class="s3">, </span><span class="s1">msg)</span>

  <span class="s3">def </span><span class="s1">assertJsonEqual(self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Asserts that the JSON objects defined in two strings are equal. 
 
    A summary of the differences will be included in the failure message 
    using assertSameStructure. 
 
    Args: 
      first: A string containing JSON to decode and compare to second. 
      second: A string containing JSON to decode and compare to first. 
      msg: Additional text to include in the failure message. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">first_structured = json.loads(first)</span>
    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s3">raise </span><span class="s1">ValueError(self._formatMessage(</span>
          <span class="s1">msg</span><span class="s3">,</span>
          <span class="s4">'could not decode first JSON value %s: %s' </span><span class="s1">% (first</span><span class="s3">, </span><span class="s1">e)))</span>

    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">second_structured = json.loads(second)</span>
    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s3">raise </span><span class="s1">ValueError(self._formatMessage(</span>
          <span class="s1">msg</span><span class="s3">,</span>
          <span class="s4">'could not decode second JSON value %s: %s' </span><span class="s1">% (second</span><span class="s3">, </span><span class="s1">e)))</span>

    <span class="s1">self.assertSameStructure(first_structured</span><span class="s3">, </span><span class="s1">second_structured</span><span class="s3">,</span>
                             <span class="s1">aname=</span><span class="s4">'first'</span><span class="s3">, </span><span class="s1">bname=</span><span class="s4">'second'</span><span class="s3">, </span><span class="s1">msg=msg)</span>

  <span class="s3">def </span><span class="s1">_getAssertEqualityFunc(self</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">second):</span>
    <span class="s0"># type: (Any, Any) -&gt; Callable[..., None]</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self)._getAssertEqualityFunc(first</span><span class="s3">, </span><span class="s1">second)</span>
    <span class="s3">except </span><span class="s1">AttributeError:</span>
      <span class="s0"># This is a workaround if unittest.TestCase.__init__ was never run.</span>
      <span class="s0"># It usually means that somebody created a subclass just for the</span>
      <span class="s0"># assertions and has overridden __init__. &quot;assertTrue&quot; is a safe</span>
      <span class="s0"># value that will not make __init__ raise a ValueError.</span>
      <span class="s1">test_method = getattr(self</span><span class="s3">, </span><span class="s4">'_testMethodName'</span><span class="s3">, </span><span class="s4">'assertTrue'</span><span class="s1">)</span>
      <span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self).__init__(test_method)</span>

    <span class="s3">return </span><span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self)._getAssertEqualityFunc(first</span><span class="s3">, </span><span class="s1">second)</span>

  <span class="s3">def </span><span class="s1">fail(self</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None, </span><span class="s1">prefix=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Fail immediately with the given message, optionally prefixed.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">super(TestCase</span><span class="s3">, </span><span class="s1">self).fail(self._formatMessage(prefix</span><span class="s3">, </span><span class="s1">msg))</span>


<span class="s3">def </span><span class="s1">_sorted_list_difference(expected</span><span class="s3">, </span><span class="s1">actual):</span>
  <span class="s0"># type: (List[_T], List[_T]) -&gt; Tuple[List[_T], List[_T]]</span>
  <span class="s2">&quot;&quot;&quot;Finds elements in only one or the other of two, sorted input lists. 
 
  Returns a two-element tuple of lists.  The first list contains those 
  elements in the &quot;expected&quot; list but not in the &quot;actual&quot; list, and the 
  second contains those elements in the &quot;actual&quot; list but not in the 
  &quot;expected&quot; list.  Duplicate elements in either input list are ignored. 
 
  Args: 
    expected:  The list we expected. 
    actual:  The list we actually got. 
  Returns: 
    (missing, unexpected) 
    missing: items in expected that are not in actual. 
    unexpected: items in actual that are not in expected. 
  &quot;&quot;&quot;</span>
  <span class="s1">i = j = </span><span class="s5">0</span>
  <span class="s1">missing = []</span>
  <span class="s1">unexpected = []</span>
  <span class="s3">while True</span><span class="s1">:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">e = expected[i]</span>
      <span class="s1">a = actual[j]</span>
      <span class="s3">if </span><span class="s1">e &lt; a:</span>
        <span class="s1">missing.append(e)</span>
        <span class="s1">i += </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">expected[i] == e:</span>
          <span class="s1">i += </span><span class="s5">1</span>
      <span class="s3">elif </span><span class="s1">e &gt; a:</span>
        <span class="s1">unexpected.append(a)</span>
        <span class="s1">j += </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">actual[j] == a:</span>
          <span class="s1">j += </span><span class="s5">1</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">i += </span><span class="s5">1</span>
        <span class="s3">try</span><span class="s1">:</span>
          <span class="s3">while </span><span class="s1">expected[i] == e:</span>
            <span class="s1">i += </span><span class="s5">1</span>
        <span class="s3">finally</span><span class="s1">:</span>
          <span class="s1">j += </span><span class="s5">1</span>
          <span class="s3">while </span><span class="s1">actual[j] == a:</span>
            <span class="s1">j += </span><span class="s5">1</span>
    <span class="s3">except </span><span class="s1">IndexError:</span>
      <span class="s1">missing.extend(expected[i:])</span>
      <span class="s1">unexpected.extend(actual[j:])</span>
      <span class="s3">break</span>
  <span class="s3">return </span><span class="s1">missing</span><span class="s3">, </span><span class="s1">unexpected</span>


<span class="s3">def </span><span class="s1">_are_both_of_integer_type(a</span><span class="s3">, </span><span class="s1">b):</span>
  <span class="s0"># type: (object, object) -&gt; bool</span>
  <span class="s3">return </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">int) </span><span class="s3">and </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">int)</span>


<span class="s3">def </span><span class="s1">_are_both_of_sequence_type(a</span><span class="s3">, </span><span class="s1">b):</span>
  <span class="s0"># type: (object, object) -&gt; bool</span>
  <span class="s3">return </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">abc.Sequence) </span><span class="s3">and </span><span class="s1">isinstance(</span>
      <span class="s1">b</span><span class="s3">, </span><span class="s1">abc.Sequence) </span><span class="s3">and not </span><span class="s1">isinstance(</span>
          <span class="s1">a</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES) </span><span class="s3">and not </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES)</span>


<span class="s3">def </span><span class="s1">_are_both_of_set_type(a</span><span class="s3">, </span><span class="s1">b):</span>
  <span class="s0"># type: (object, object) -&gt; bool</span>
  <span class="s3">return </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">abc.Set) </span><span class="s3">and </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">abc.Set)</span>


<span class="s3">def </span><span class="s1">_are_both_of_mapping_type(a</span><span class="s3">, </span><span class="s1">b):</span>
  <span class="s0"># type: (object, object) -&gt; bool</span>
  <span class="s3">return </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">abc.Mapping) </span><span class="s3">and </span><span class="s1">isinstance(</span>
      <span class="s1">b</span><span class="s3">, </span><span class="s1">abc.Mapping)</span>


<span class="s3">def </span><span class="s1">_walk_structure_for_problems(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aname</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">problem_list):</span>
  <span class="s2">&quot;&quot;&quot;The recursive comparison behind assertSameStructure.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">type(a) != type(b) </span><span class="s3">and not </span><span class="s1">(  </span><span class="s0"># pylint: disable=unidiomatic-typecheck</span>
      <span class="s1">_are_both_of_integer_type(a</span><span class="s3">, </span><span class="s1">b) </span><span class="s3">or </span><span class="s1">_are_both_of_sequence_type(a</span><span class="s3">, </span><span class="s1">b) </span><span class="s3">or</span>
      <span class="s1">_are_both_of_set_type(a</span><span class="s3">, </span><span class="s1">b) </span><span class="s3">or </span><span class="s1">_are_both_of_mapping_type(a</span><span class="s3">, </span><span class="s1">b)):</span>
    <span class="s0"># We do not distinguish between int and long types as 99.99% of Python 2</span>
    <span class="s0"># code should never care.  They collapse into a single type in Python 3.</span>
    <span class="s1">problem_list.append(</span><span class="s4">'%s is a %r but %s is a %r' </span><span class="s1">%</span>
                        <span class="s1">(aname</span><span class="s3">, </span><span class="s1">type(a)</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">type(b)))</span>
    <span class="s0"># If they have different types there's no point continuing</span>
    <span class="s3">return</span>

  <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">abc.Set):</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">a:</span>
      <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">b:</span>
        <span class="s1">problem_list.append(</span>
            <span class="s4">'%s has %r but %s does not' </span><span class="s1">% (aname</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">bname))</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">b:</span>
      <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">a:</span>
        <span class="s1">problem_list.append(</span><span class="s4">'%s lacks %r but %s has it' </span><span class="s1">% (aname</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">bname))</span>

  <span class="s0"># NOTE: a or b could be a defaultdict, so we must take care that the traversal</span>
  <span class="s0"># doesn't modify the data.</span>
  <span class="s3">elif </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">abc.Mapping):</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">a:</span>
      <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">b:</span>
        <span class="s1">_walk_structure_for_problems(</span>
            <span class="s1">a[k]</span><span class="s3">, </span><span class="s1">b[k]</span><span class="s3">, </span><span class="s4">'%s[%r]' </span><span class="s1">% (aname</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">, </span><span class="s4">'%s[%r]' </span><span class="s1">% (bname</span><span class="s3">, </span><span class="s1">k)</span><span class="s3">,</span>
            <span class="s1">problem_list)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">problem_list.append(</span>
            <span class="s4">&quot;%s has [%r] with value %r but it's missing in %s&quot; </span><span class="s1">%</span>
            <span class="s1">(aname</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">a[k]</span><span class="s3">, </span><span class="s1">bname))</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">b:</span>
      <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">a:</span>
        <span class="s1">problem_list.append(</span>
            <span class="s4">'%s lacks [%r] but %s has it with value %r' </span><span class="s1">%</span>
            <span class="s1">(aname</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">b[k]))</span>

  <span class="s0"># Strings/bytes are Sequences but we'll just do those with regular !=</span>
  <span class="s3">elif </span><span class="s1">(isinstance(a</span><span class="s3">, </span><span class="s1">abc.Sequence) </span><span class="s3">and</span>
        <span class="s3">not </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">_TEXT_OR_BINARY_TYPES)):</span>
    <span class="s1">minlen = min(len(a)</span><span class="s3">, </span><span class="s1">len(b))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(minlen):</span>
      <span class="s1">_walk_structure_for_problems(</span>
          <span class="s1">a[i]</span><span class="s3">, </span><span class="s1">b[i]</span><span class="s3">, </span><span class="s4">'%s[%d]' </span><span class="s1">% (aname</span><span class="s3">, </span><span class="s1">i)</span><span class="s3">, </span><span class="s4">'%s[%d]' </span><span class="s1">% (bname</span><span class="s3">, </span><span class="s1">i)</span><span class="s3">,</span>
          <span class="s1">problem_list)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(minlen</span><span class="s3">, </span><span class="s1">len(a)):</span>
      <span class="s1">problem_list.append(</span><span class="s4">'%s has [%i] with value %r but %s does not' </span><span class="s1">%</span>
                          <span class="s1">(aname</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">a[i]</span><span class="s3">, </span><span class="s1">bname))</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(minlen</span><span class="s3">, </span><span class="s1">len(b)):</span>
      <span class="s1">problem_list.append(</span><span class="s4">'%s lacks [%i] but %s has it with value %r' </span><span class="s1">%</span>
                          <span class="s1">(aname</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">b[i]))</span>

  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">a != b:</span>
      <span class="s1">problem_list.append(</span><span class="s4">'%s is %r but %s is %r' </span><span class="s1">% (aname</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">bname</span><span class="s3">, </span><span class="s1">b))</span>


<span class="s3">def </span><span class="s1">get_command_string(command):</span>
  <span class="s2">&quot;&quot;&quot;Returns an escaped string that can be used as a shell command. 
 
  Args: 
    command: List or string representing the command to run. 
  Returns: 
    A string suitable for use as a shell command. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">isinstance(command</span><span class="s3">, </span><span class="s1">str):</span>
    <span class="s3">return </span><span class="s1">command</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">' '</span><span class="s1">.join(command)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># The following is identical to Python 3's shlex.quote function.</span>
      <span class="s1">command_string = </span><span class="s4">''</span>
      <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">command:</span>
        <span class="s0"># Single quote word, and replace each ' in word with '&quot;'&quot;'</span>
        <span class="s1">command_string += </span><span class="s4">&quot;'&quot; </span><span class="s1">+ word.replace(</span><span class="s4">&quot;'&quot;</span><span class="s3">, </span><span class="s4">&quot;'</span><span class="s3">\&quot;</span><span class="s4">'</span><span class="s3">\&quot;</span><span class="s4">'&quot;</span><span class="s1">) + </span><span class="s4">&quot;' &quot;</span>
      <span class="s3">return </span><span class="s1">command_string[:-</span><span class="s5">1</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">get_command_stderr(command</span><span class="s3">, </span><span class="s1">env=</span><span class="s3">None, </span><span class="s1">close_fds=</span><span class="s3">True</span><span class="s1">):</span>
  <span class="s2">&quot;&quot;&quot;Runs the given shell command and returns a tuple. 
 
  Args: 
    command: List or string representing the command to run. 
    env: Dictionary of environment variable settings. If None, no environment 
        variables will be set for the child process. This is to make tests 
        more hermetic. NOTE: this behavior is different than the standard 
        subprocess module. 
    close_fds: Whether or not to close all open fd's in the child after forking. 
        On Windows, this is ignored and close_fds is always False. 
 
  Returns: 
    Tuple of (exit status, text printed to stdout and stderr by the command). 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">env </span><span class="s3">is None</span><span class="s1">: env = {}</span>
  <span class="s3">if </span><span class="s1">os.name == </span><span class="s4">'nt'</span><span class="s1">:</span>
    <span class="s0"># Windows does not support setting close_fds to True while also redirecting</span>
    <span class="s0"># standard handles.</span>
    <span class="s1">close_fds = </span><span class="s3">False</span>

  <span class="s1">use_shell = isinstance(command</span><span class="s3">, </span><span class="s1">str)</span>
  <span class="s1">process = subprocess.Popen(</span>
      <span class="s1">command</span><span class="s3">,</span>
      <span class="s1">close_fds=close_fds</span><span class="s3">,</span>
      <span class="s1">env=env</span><span class="s3">,</span>
      <span class="s1">shell=use_shell</span><span class="s3">,</span>
      <span class="s1">stderr=subprocess.STDOUT</span><span class="s3">,</span>
      <span class="s1">stdout=subprocess.PIPE)</span>
  <span class="s1">output = process.communicate()[</span><span class="s5">0</span><span class="s1">]</span>
  <span class="s1">exit_status = process.wait()</span>
  <span class="s3">return </span><span class="s1">(exit_status</span><span class="s3">, </span><span class="s1">output)</span>


<span class="s3">def </span><span class="s1">_quote_long_string(s):</span>
  <span class="s0"># type: (Union[Text, bytes, bytearray]) -&gt; Text</span>
  <span class="s2">&quot;&quot;&quot;Quotes a potentially multi-line string to make the start and end obvious. 
 
  Args: 
    s: A string. 
 
  Returns: 
    The quoted string. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">isinstance(s</span><span class="s3">, </span><span class="s1">(bytes</span><span class="s3">, </span><span class="s1">bytearray)):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">s = s.decode(</span><span class="s4">'utf-8'</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">UnicodeDecodeError:</span>
      <span class="s1">s = str(s)</span>
  <span class="s3">return </span><span class="s1">(</span><span class="s4">'8&lt;-----------</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">+</span>
          <span class="s1">s + </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">+</span>
          <span class="s4">'-----------&gt;8</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">print_python_version():</span>
  <span class="s0"># type: () -&gt; None</span>
  <span class="s0"># Having this in the test output logs by default helps debugging when all</span>
  <span class="s0"># you've got is the log and no other idea of which Python was used.</span>
  <span class="s1">sys.stderr.write(</span><span class="s4">'Running tests under Python {0[0]}.{0[1]}.{0[2]}: '</span>
                   <span class="s4">'{1}</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.format(</span>
                       <span class="s1">sys.version_info</span><span class="s3">,</span>
                       <span class="s1">sys.executable </span><span class="s3">if </span><span class="s1">sys.executable </span><span class="s3">else </span><span class="s4">'embedded.'</span><span class="s1">))</span>


<span class="s3">def </span><span class="s1">main(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
  <span class="s0"># type: (Text, Any) -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Executes a set of Python unit tests. 
 
  Usually this function is called without arguments, so the 
  unittest.TestProgram instance will get created with the default settings, 
  so it will run all test methods of all TestCase classes in the ``__main__`` 
  module. 
 
  Args: 
    *args: Positional arguments passed through to 
        ``unittest.TestProgram.__init__``. 
    **kwargs: Keyword arguments passed through to 
        ``unittest.TestProgram.__init__``. 
  &quot;&quot;&quot;</span>
  <span class="s1">print_python_version()</span>
  <span class="s1">_run_in_app(run_tests</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs)</span>


<span class="s3">def </span><span class="s1">_is_in_app_main():</span>
  <span class="s0"># type: () -&gt; bool</span>
  <span class="s2">&quot;&quot;&quot;Returns True iff app.run is active.&quot;&quot;&quot;</span>
  <span class="s1">f = sys._getframe().f_back  </span><span class="s0"># pylint: disable=protected-access</span>
  <span class="s3">while </span><span class="s1">f:</span>
    <span class="s3">if </span><span class="s1">f.f_code == app.run.__code__:</span>
      <span class="s3">return True</span>
    <span class="s1">f = f.f_back</span>
  <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">_register_sigterm_with_faulthandler():</span>
  <span class="s0"># type: () -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Have faulthandler dump stacks on SIGTERM.  Useful to diagnose timeouts.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">faulthandler </span><span class="s3">and </span><span class="s1">getattr(faulthandler</span><span class="s3">, </span><span class="s4">'register'</span><span class="s3">, None</span><span class="s1">):</span>
    <span class="s0"># faulthandler.register is not available on Windows.</span>
    <span class="s0"># faulthandler.enable() is already called by app.run.</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">faulthandler.register(signal.SIGTERM</span><span class="s3">, </span><span class="s1">chain=</span><span class="s3">True</span><span class="s1">)  </span><span class="s0"># pytype: disable=module-attr</span>
    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:  </span><span class="s0"># pylint: disable=broad-except</span>
      <span class="s1">sys.stderr.write(</span><span class="s4">'faulthandler.register(SIGTERM) failed '</span>
                       <span class="s4">'%r; ignoring.</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">% e)</span>


<span class="s3">def </span><span class="s1">_run_in_app(function</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs):</span>
  <span class="s0"># type: (Callable[..., None], Sequence[Text], Mapping[Text, Any]) -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Executes a set of Python unit tests, ensuring app.run. 
 
  This is a private function, users should call absltest.main(). 
 
  _run_in_app calculates argv to be the command-line arguments of this program 
  (without the flags), sets the default of FLAGS.alsologtostderr to True, 
  then it calls function(argv, args, kwargs), making sure that `function' 
  will get called within app.run(). _run_in_app does this by checking whether 
  it is called by app.run(), or by calling app.run() explicitly. 
 
  The reason why app.run has to be ensured is to make sure that 
  flags are parsed and stripped properly, and other initializations done by 
  the app module are also carried out, no matter if absltest.run() is called 
  from within or outside app.run(). 
 
  If _run_in_app is called from within app.run(), then it will reparse 
  sys.argv and pass the result without command-line flags into the argv 
  argument of `function'. The reason why this parsing is needed is that 
  __main__.main() calls absltest.main() without passing its argv. So the 
  only way _run_in_app could get to know the argv without the flags is that 
  it reparses sys.argv. 
 
  _run_in_app changes the default of FLAGS.alsologtostderr to True so that the 
  test program's stderr will contain all the log messages unless otherwise 
  specified on the command-line. This overrides any explicit assignment to 
  FLAGS.alsologtostderr by the test program prior to the call to _run_in_app() 
  (e.g. in __main__.main). 
 
  Please note that _run_in_app (and the function it calls) is allowed to make 
  changes to kwargs. 
 
  Args: 
    function: absltest.run_tests or a similar function. It will be called as 
        function(argv, args, kwargs) where argv is a list containing the 
        elements of sys.argv without the command-line flags. 
    args: Positional arguments passed through to unittest.TestProgram.__init__. 
    kwargs: Keyword arguments passed through to unittest.TestProgram.__init__. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">_is_in_app_main():</span>
    <span class="s1">_register_sigterm_with_faulthandler()</span>

    <span class="s0"># Change the default of alsologtostderr from False to True, so the test</span>
    <span class="s0"># programs's stderr will contain all the log messages.</span>
    <span class="s0"># If --alsologtostderr=false is specified in the command-line, or user</span>
    <span class="s0"># has called FLAGS.alsologtostderr = False before, then the value is kept</span>
    <span class="s0"># False.</span>
    <span class="s1">FLAGS.set_default(</span><span class="s4">'alsologtostderr'</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s0"># Here we only want to get the `argv` without the flags. To avoid any</span>
    <span class="s0"># side effects of parsing flags, we temporarily stub out the `parse` method</span>
    <span class="s1">stored_parse_methods = {}</span>
    <span class="s1">noop_parse = </span><span class="s3">lambda </span><span class="s1">_: </span><span class="s3">None</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">FLAGS:</span>
      <span class="s0"># Avoid any side effects of parsing flags.</span>
      <span class="s1">stored_parse_methods[name] = FLAGS[name].parse</span>
    <span class="s0"># This must be a separate loop since multiple flag names (short_name=) can</span>
    <span class="s0"># point to the same flag object.</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">FLAGS:</span>
      <span class="s1">FLAGS[name].parse = noop_parse</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">argv = FLAGS(sys.argv)</span>
    <span class="s3">finally</span><span class="s1">:</span>
      <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">FLAGS:</span>
        <span class="s1">FLAGS[name].parse = stored_parse_methods[name]</span>
      <span class="s1">sys.stdout.flush()</span>

    <span class="s1">function(argv</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s0"># Send logging to stderr. Use --alsologtostderr instead of --logtostderr</span>
    <span class="s0"># in case tests are reading their own logs.</span>
    <span class="s1">FLAGS.set_default(</span><span class="s4">'alsologtostderr'</span><span class="s3">, True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">main_function(argv):</span>
      <span class="s1">_register_sigterm_with_faulthandler()</span>
      <span class="s1">function(argv</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs)</span>

    <span class="s1">app.run(main=main_function)</span>


<span class="s3">def </span><span class="s1">_is_suspicious_attribute(testCaseClass</span><span class="s3">, </span><span class="s1">name):</span>
  <span class="s0"># type: (Type, Text) -&gt; bool</span>
  <span class="s2">&quot;&quot;&quot;Returns True if an attribute is a method named like a test method.&quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">name.startswith(</span><span class="s4">'Test'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">len(name) &gt; </span><span class="s5">4 </span><span class="s3">and </span><span class="s1">name[</span><span class="s5">4</span><span class="s1">].isupper():</span>
    <span class="s1">attr = getattr(testCaseClass</span><span class="s3">, </span><span class="s1">name)</span>
    <span class="s3">if </span><span class="s1">inspect.isfunction(attr) </span><span class="s3">or </span><span class="s1">inspect.ismethod(attr):</span>
      <span class="s1">args = inspect.getfullargspec(attr)</span>
      <span class="s3">return </span><span class="s1">(len(args.args) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">args.args[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'self' </span><span class="s3">and</span>
              <span class="s1">args.varargs </span><span class="s3">is None and </span><span class="s1">args.varkw </span><span class="s3">is None and</span>
              <span class="s3">not </span><span class="s1">args.kwonlyargs)</span>
  <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">skipThisClass(reason):</span>
  <span class="s0"># type: (Text) -&gt; Callable[[_T], _T]</span>
  <span class="s2">&quot;&quot;&quot;Skip tests in the decorated TestCase, but not any of its subclasses. 
 
  This decorator indicates that this class should skip all its tests, but not 
  any of its subclasses. Useful for if you want to share testMethod or setUp 
  implementations between a number of concrete testcase classes. 
 
  Example usage, showing how you can share some common test methods between 
  subclasses. In this example, only ``BaseTest`` will be marked as skipped, and 
  not RealTest or SecondRealTest:: 
 
      @absltest.skipThisClass(&quot;Shared functionality&quot;) 
      class BaseTest(absltest.TestCase): 
        def test_simple_functionality(self): 
          self.assertEqual(self.system_under_test.method(), 1) 
 
      class RealTest(BaseTest): 
        def setUp(self): 
          super().setUp() 
          self.system_under_test = MakeSystem(argument) 
 
        def test_specific_behavior(self): 
          ... 
 
      class SecondRealTest(BaseTest): 
        def setUp(self): 
          super().setUp() 
          self.system_under_test = MakeSystem(other_arguments) 
 
        def test_other_behavior(self): 
          ... 
 
  Args: 
    reason: The reason we have a skip in place. For instance: 'shared test 
      methods' or 'shared assertion methods'. 
 
  Returns: 
    Decorator function that will cause a class to be skipped. 
  &quot;&quot;&quot;</span>
  <span class="s3">if </span><span class="s1">isinstance(reason</span><span class="s3">, </span><span class="s1">type):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'Got {!r}, expected reason as string'</span><span class="s1">.format(reason))</span>

  <span class="s3">def </span><span class="s1">_skip_class(test_case_class):</span>
    <span class="s3">if not </span><span class="s1">issubclass(test_case_class</span><span class="s3">, </span><span class="s1">unittest.TestCase):</span>
      <span class="s3">raise </span><span class="s1">TypeError(</span>
          <span class="s4">'Decorating {!r}, expected TestCase subclass'</span><span class="s1">.format(test_case_class))</span>

    <span class="s0"># Only shadow the setUpClass method if it is directly defined. If it is</span>
    <span class="s0"># in the parent class we invoke it via a super() call instead of holding</span>
    <span class="s0"># a reference to it.</span>
    <span class="s1">shadowed_setupclass = test_case_class.__dict__.get(</span><span class="s4">'setUpClass'</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">replacement_setupclass(cls</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
      <span class="s0"># Skip this class if it is the one that was decorated with @skipThisClass</span>
      <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">test_case_class:</span>
        <span class="s3">raise </span><span class="s1">SkipTest(reason)</span>
      <span class="s3">if </span><span class="s1">shadowed_setupclass:</span>
        <span class="s0"># Pass along `cls` so the MRO chain doesn't break.</span>
        <span class="s0"># The original method is a `classmethod` descriptor, which can't</span>
        <span class="s0"># be directly called, but `__func__` has the underlying function.</span>
        <span class="s3">return </span><span class="s1">shadowed_setupclass.__func__(cls</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Because there's no setUpClass() defined directly on test_case_class,</span>
        <span class="s0"># we call super() ourselves to continue execution of the inheritance</span>
        <span class="s0"># chain.</span>
        <span class="s3">return </span><span class="s1">super(test_case_class</span><span class="s3">, </span><span class="s1">cls).setUpClass(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s1">test_case_class.setUpClass = replacement_setupclass</span>
    <span class="s3">return </span><span class="s1">test_case_class</span>

  <span class="s3">return </span><span class="s1">_skip_class</span>


<span class="s3">class </span><span class="s1">TestLoader(unittest.TestLoader):</span>
  <span class="s2">&quot;&quot;&quot;A test loader which supports common test features. 
 
  Supported features include: 
   * Banning untested methods with test-like names: methods attached to this 
     testCase with names starting with `Test` are ignored by the test runner, 
     and often represent mistakenly-omitted test cases. This loader will raise 
     a TypeError when attempting to load a TestCase with such methods. 
   * Randomization of test case execution order (optional). 
  &quot;&quot;&quot;</span>

  <span class="s1">_ERROR_MSG = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;Method '%s' is named like a test case but 
  is not one. This is often a bug. If you want it to be a test method, 
  name it with 'test' in lowercase. If not, rename the method to not begin 
  with 'Test'.&quot;&quot;&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwds):</span>
    <span class="s1">super(TestLoader</span><span class="s3">, </span><span class="s1">self).__init__(*args</span><span class="s3">, </span><span class="s1">**kwds)</span>
    <span class="s1">seed = _get_default_randomize_ordering_seed()</span>
    <span class="s3">if </span><span class="s1">seed:</span>
      <span class="s1">self._randomize_ordering_seed = seed</span>
      <span class="s1">self._random = random.Random(self._randomize_ordering_seed)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">self._randomize_ordering_seed = </span><span class="s3">None</span>
      <span class="s1">self._random = </span><span class="s3">None</span>

  <span class="s3">def </span><span class="s1">getTestCaseNames(self</span><span class="s3">, </span><span class="s1">testCaseClass):  </span><span class="s0"># pylint:disable=invalid-name</span>
    <span class="s2">&quot;&quot;&quot;Validates and returns a (possibly randomized) list of test case names.&quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">dir(testCaseClass):</span>
      <span class="s3">if </span><span class="s1">_is_suspicious_attribute(testCaseClass</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">raise </span><span class="s1">TypeError(TestLoader._ERROR_MSG % name)</span>
    <span class="s1">names = super(TestLoader</span><span class="s3">, </span><span class="s1">self).getTestCaseNames(testCaseClass)</span>
    <span class="s3">if </span><span class="s1">self._randomize_ordering_seed </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">logging.info(</span>
          <span class="s4">'Randomizing test order with seed: %d'</span><span class="s3">, </span><span class="s1">self._randomize_ordering_seed)</span>
      <span class="s1">logging.info(</span>
          <span class="s4">'To reproduce this order, re-run with '</span>
          <span class="s4">'--test_randomize_ordering_seed=%d'</span><span class="s3">, </span><span class="s1">self._randomize_ordering_seed)</span>
      <span class="s1">self._random.shuffle(names)</span>
    <span class="s3">return </span><span class="s1">names</span>


<span class="s3">def </span><span class="s1">get_default_xml_output_filename():</span>
  <span class="s0"># type: () -&gt; Optional[Text]</span>
  <span class="s3">if </span><span class="s1">os.environ.get(</span><span class="s4">'XML_OUTPUT_FILE'</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">os.environ[</span><span class="s4">'XML_OUTPUT_FILE'</span><span class="s1">]</span>
  <span class="s3">elif </span><span class="s1">os.environ.get(</span><span class="s4">'RUNNING_UNDER_TEST_DAEMON'</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">os.path.join(os.path.dirname(TEST_TMPDIR.value)</span><span class="s3">, </span><span class="s4">'test_detail.xml'</span><span class="s1">)</span>
  <span class="s3">elif </span><span class="s1">os.environ.get(</span><span class="s4">'TEST_XMLOUTPUTDIR'</span><span class="s1">):</span>
    <span class="s3">return </span><span class="s1">os.path.join(</span>
        <span class="s1">os.environ[</span><span class="s4">'TEST_XMLOUTPUTDIR'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s1">os.path.splitext(os.path.basename(sys.argv[</span><span class="s5">0</span><span class="s1">]))[</span><span class="s5">0</span><span class="s1">] + </span><span class="s4">'.xml'</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_setup_filtering(argv):</span>
  <span class="s0"># type: (MutableSequence[Text]) -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Implements the bazel test filtering protocol. 
 
  The following environment variable is used in this method: 
 
    TESTBRIDGE_TEST_ONLY: string, if set, is forwarded to the unittest 
      framework to use as a test filter. Its value is split with shlex, then: 
      1. On Python 3.6 and before, split values are passed as positional 
         arguments on argv. 
      2. On Python 3.7+, split values are passed to unittest's `-k` flag. Tests 
         are matched by glob patterns or substring. See 
         https://docs.python.org/3/library/unittest.html#cmdoption-unittest-k 
 
  Args: 
    argv: the argv to mutate in-place. 
  &quot;&quot;&quot;</span>
  <span class="s1">test_filter = os.environ.get(</span><span class="s4">'TESTBRIDGE_TEST_ONLY'</span><span class="s1">)</span>
  <span class="s3">if </span><span class="s1">argv </span><span class="s3">is None or not </span><span class="s1">test_filter:</span>
    <span class="s3">return</span>

  <span class="s1">filters = shlex.split(test_filter)</span>
  <span class="s3">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &gt;= (</span><span class="s5">3</span><span class="s3">, </span><span class="s5">7</span><span class="s1">):</span>
    <span class="s1">filters = [</span><span class="s4">'-k=' </span><span class="s1">+ test_filter </span><span class="s3">for </span><span class="s1">test_filter </span><span class="s3">in </span><span class="s1">filters]</span>

  <span class="s1">argv[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] = filters</span>


<span class="s3">def </span><span class="s1">_setup_test_runner_fail_fast(argv):</span>
  <span class="s0"># type: (MutableSequence[Text]) -&gt; None</span>
  <span class="s2">&quot;&quot;&quot;Implements the bazel test fail fast protocol. 
 
  The following environment variable is used in this method: 
 
    TESTBRIDGE_TEST_RUNNER_FAIL_FAST=&lt;1|0&gt; 
 
  If set to 1, --failfast is passed to the unittest framework to return upon 
  first failure. 
 
  Args: 
    argv: the argv to mutate in-place. 
  &quot;&quot;&quot;</span>

  <span class="s3">if </span><span class="s1">argv </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s3">return</span>

  <span class="s3">if </span><span class="s1">os.environ.get(</span><span class="s4">'TESTBRIDGE_TEST_RUNNER_FAIL_FAST'</span><span class="s1">) != </span><span class="s4">'1'</span><span class="s1">:</span>
    <span class="s3">return</span>

  <span class="s1">argv[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">1</span><span class="s1">] = [</span><span class="s4">'--failfast'</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_setup_sharding(custom_loader=</span><span class="s3">None</span><span class="s1">):</span>
  <span class="s0"># type: (Optional[unittest.TestLoader]) -&gt; unittest.TestLoader</span>
  <span class="s2">&quot;&quot;&quot;Implements the bazel sharding protocol. 
 
  The following environment variables are used in this method: 
 
    TEST_SHARD_STATUS_FILE: string, if set, points to a file. We write a blank 
      file to tell the test runner that this test implements the test sharding 
      protocol. 
 
    TEST_TOTAL_SHARDS: int, if set, sharding is requested. 
 
    TEST_SHARD_INDEX: int, must be set if TEST_TOTAL_SHARDS is set. Specifies 
      the shard index for this instance of the test process. Must satisfy: 
      0 &lt;= TEST_SHARD_INDEX &lt; TEST_TOTAL_SHARDS. 
 
  Args: 
    custom_loader: A TestLoader to be made sharded. 
 
  Returns: 
    The test loader for shard-filtering or the standard test loader, depending 
    on the sharding environment variables. 
  &quot;&quot;&quot;</span>

  <span class="s0"># It may be useful to write the shard file even if the other sharding</span>
  <span class="s0"># environment variables are not set. Test runners may use this functionality</span>
  <span class="s0"># to query whether a test binary implements the test sharding protocol.</span>
  <span class="s3">if </span><span class="s4">'TEST_SHARD_STATUS_FILE' </span><span class="s3">in </span><span class="s1">os.environ:</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">with </span><span class="s1">open(os.environ[</span><span class="s4">'TEST_SHARD_STATUS_FILE'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
        <span class="s1">f.write(</span><span class="s4">''</span><span class="s1">)</span>
    <span class="s3">except </span><span class="s1">IOError:</span>
      <span class="s1">sys.stderr.write(</span><span class="s4">'Error opening TEST_SHARD_STATUS_FILE (%s). Exiting.'</span>
                       <span class="s1">% os.environ[</span><span class="s4">'TEST_SHARD_STATUS_FILE'</span><span class="s1">])</span>
      <span class="s1">sys.exit(</span><span class="s5">1</span><span class="s1">)</span>

  <span class="s1">base_loader = custom_loader </span><span class="s3">or </span><span class="s1">TestLoader()</span>
  <span class="s3">if </span><span class="s4">'TEST_TOTAL_SHARDS' </span><span class="s3">not in </span><span class="s1">os.environ:</span>
    <span class="s0"># Not using sharding, use the expected test loader.</span>
    <span class="s3">return </span><span class="s1">base_loader</span>

  <span class="s1">total_shards = int(os.environ[</span><span class="s4">'TEST_TOTAL_SHARDS'</span><span class="s1">])</span>
  <span class="s1">shard_index = int(os.environ[</span><span class="s4">'TEST_SHARD_INDEX'</span><span class="s1">])</span>

  <span class="s3">if </span><span class="s1">shard_index &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">shard_index &gt;= total_shards:</span>
    <span class="s1">sys.stderr.write(</span><span class="s4">'ERROR: Bad sharding values. index=%d, total=%d</span><span class="s3">\n</span><span class="s4">' </span><span class="s1">%</span>
                     <span class="s1">(shard_index</span><span class="s3">, </span><span class="s1">total_shards))</span>
    <span class="s1">sys.exit(</span><span class="s5">1</span><span class="s1">)</span>

  <span class="s0"># Replace the original getTestCaseNames with one that returns</span>
  <span class="s0"># the test case names for this shard.</span>
  <span class="s1">delegate_get_names = base_loader.getTestCaseNames</span>

  <span class="s1">bucket_iterator = itertools.cycle(range(total_shards))</span>

  <span class="s3">def </span><span class="s1">getShardedTestCaseNames(testCaseClass):</span>
    <span class="s1">filtered_names = []</span>
    <span class="s0"># We need to sort the list of tests in order to determine which tests this</span>
    <span class="s0"># shard is responsible for; however, it's important to preserve the order</span>
    <span class="s0"># returned by the base loader, e.g. in the case of randomized test ordering.</span>
    <span class="s1">ordered_names = delegate_get_names(testCaseClass)</span>
    <span class="s3">for </span><span class="s1">testcase </span><span class="s3">in </span><span class="s1">sorted(ordered_names):</span>
      <span class="s1">bucket = next(bucket_iterator)</span>
      <span class="s3">if </span><span class="s1">bucket == shard_index:</span>
        <span class="s1">filtered_names.append(testcase)</span>
    <span class="s3">return </span><span class="s1">[x </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">ordered_names </span><span class="s3">if </span><span class="s1">x </span><span class="s3">in </span><span class="s1">filtered_names]</span>

  <span class="s1">base_loader.getTestCaseNames = getShardedTestCaseNames</span>
  <span class="s3">return </span><span class="s1">base_loader</span>


<span class="s0"># pylint: disable=line-too-long</span>
<span class="s3">def </span><span class="s1">_run_and_get_tests_result(argv</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">xml_test_runner_class):</span>
  <span class="s0"># type: (MutableSequence[Text], Sequence[Any], MutableMapping[Text, Any], Type) -&gt; unittest.TestResult</span>
  <span class="s0"># pylint: enable=line-too-long</span>
  <span class="s2">&quot;&quot;&quot;Same as run_tests, except it returns the result instead of exiting.&quot;&quot;&quot;</span>

  <span class="s0"># The entry from kwargs overrides argv.</span>
  <span class="s1">argv = kwargs.pop(</span><span class="s4">'argv'</span><span class="s3">, </span><span class="s1">argv)</span>

  <span class="s0"># Set up test filtering if requested in environment.</span>
  <span class="s1">_setup_filtering(argv)</span>
  <span class="s0"># Set up --failfast as requested in environment</span>
  <span class="s1">_setup_test_runner_fail_fast(argv)</span>

  <span class="s0"># Shard the (default or custom) loader if sharding is turned on.</span>
  <span class="s1">kwargs[</span><span class="s4">'testLoader'</span><span class="s1">] = _setup_sharding(kwargs.get(</span><span class="s4">'testLoader'</span><span class="s3">, None</span><span class="s1">))</span>

  <span class="s0"># XML file name is based upon (sorted by priority):</span>
  <span class="s0"># --xml_output_file flag, XML_OUTPUT_FILE variable,</span>
  <span class="s0"># TEST_XMLOUTPUTDIR variable or RUNNING_UNDER_TEST_DAEMON variable.</span>
  <span class="s3">if not </span><span class="s1">FLAGS.xml_output_file:</span>
    <span class="s1">FLAGS.xml_output_file = get_default_xml_output_filename()</span>
  <span class="s1">xml_output_file = FLAGS.xml_output_file</span>

  <span class="s1">xml_buffer = </span><span class="s3">None</span>
  <span class="s3">if </span><span class="s1">xml_output_file:</span>
    <span class="s1">xml_output_dir = os.path.dirname(xml_output_file)</span>
    <span class="s3">if </span><span class="s1">xml_output_dir </span><span class="s3">and not </span><span class="s1">os.path.isdir(xml_output_dir):</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">os.makedirs(xml_output_dir)</span>
      <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s0"># File exists error can occur with concurrent tests</span>
        <span class="s3">if </span><span class="s1">e.errno != errno.EEXIST:</span>
          <span class="s3">raise</span>
    <span class="s0"># Fail early if we can't write to the XML output file. This is so that we</span>
    <span class="s0"># don't waste people's time running tests that will just fail anyways.</span>
    <span class="s3">with </span><span class="s1">_open(xml_output_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">):</span>
      <span class="s3">pass</span>

    <span class="s0"># We can reuse testRunner if it supports XML output (e. g. by inheriting</span>
    <span class="s0"># from xml_reporter.TextAndXMLTestRunner). Otherwise we need to use</span>
    <span class="s0"># xml_reporter.TextAndXMLTestRunner.</span>
    <span class="s3">if </span><span class="s1">(kwargs.get(</span><span class="s4">'testRunner'</span><span class="s1">) </span><span class="s3">is not None</span>
        <span class="s3">and not </span><span class="s1">hasattr(kwargs[</span><span class="s4">'testRunner'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'set_default_xml_stream'</span><span class="s1">)):</span>
      <span class="s1">sys.stderr.write(</span><span class="s4">'WARNING: XML_OUTPUT_FILE or --xml_output_file setting '</span>
                       <span class="s4">'overrides testRunner=%r setting (possibly from --pdb)'</span>
                       <span class="s1">% (kwargs[</span><span class="s4">'testRunner'</span><span class="s1">]))</span>
      <span class="s0"># Passing a class object here allows TestProgram to initialize</span>
      <span class="s0"># instances based on its kwargs and/or parsed command-line args.</span>
      <span class="s1">kwargs[</span><span class="s4">'testRunner'</span><span class="s1">] = xml_test_runner_class</span>
    <span class="s3">if </span><span class="s1">kwargs.get(</span><span class="s4">'testRunner'</span><span class="s1">) </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">kwargs[</span><span class="s4">'testRunner'</span><span class="s1">] = xml_test_runner_class</span>
    <span class="s0"># Use an in-memory buffer (not backed by the actual file) to store the XML</span>
    <span class="s0"># report, because some tools modify the file (e.g., create a placeholder</span>
    <span class="s0"># with partial information, in case the test process crashes).</span>
    <span class="s1">xml_buffer = io.StringIO()</span>
    <span class="s1">kwargs[</span><span class="s4">'testRunner'</span><span class="s1">].set_default_xml_stream(xml_buffer)  </span><span class="s0"># pytype: disable=attribute-error</span>

    <span class="s0"># If we've used a seed to randomize test case ordering, we want to record it</span>
    <span class="s0"># as a top-level attribute in the `testsuites` section of the XML output.</span>
    <span class="s1">randomize_ordering_seed = getattr(</span>
        <span class="s1">kwargs[</span><span class="s4">'testLoader'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'_randomize_ordering_seed'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s1">setter = getattr(kwargs[</span><span class="s4">'testRunner'</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'set_testsuites_property'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">randomize_ordering_seed </span><span class="s3">and </span><span class="s1">setter:</span>
      <span class="s1">setter(</span><span class="s4">'test_randomize_ordering_seed'</span><span class="s3">, </span><span class="s1">randomize_ordering_seed)</span>
  <span class="s3">elif </span><span class="s1">kwargs.get(</span><span class="s4">'testRunner'</span><span class="s1">) </span><span class="s3">is None</span><span class="s1">:</span>
    <span class="s1">kwargs[</span><span class="s4">'testRunner'</span><span class="s1">] = _pretty_print_reporter.TextTestRunner</span>

  <span class="s3">if </span><span class="s1">FLAGS.pdb_post_mortem:</span>
    <span class="s1">runner = kwargs[</span><span class="s4">'testRunner'</span><span class="s1">]</span>
    <span class="s0"># testRunner can be a class or an instance, which must be tested for</span>
    <span class="s0"># differently.</span>
    <span class="s0"># Overriding testRunner isn't uncommon, so only enable the debugging</span>
    <span class="s0"># integration if the runner claims it does; we don't want to accidentally</span>
    <span class="s0"># clobber something on the runner.</span>
    <span class="s3">if </span><span class="s1">((isinstance(runner</span><span class="s3">, </span><span class="s1">type) </span><span class="s3">and</span>
         <span class="s1">issubclass(runner</span><span class="s3">, </span><span class="s1">_pretty_print_reporter.TextTestRunner)) </span><span class="s3">or</span>
        <span class="s1">isinstance(runner</span><span class="s3">, </span><span class="s1">_pretty_print_reporter.TextTestRunner)):</span>
      <span class="s1">runner.run_for_debugging = </span><span class="s3">True</span>

  <span class="s0"># Make sure tmpdir exists.</span>
  <span class="s3">if not </span><span class="s1">os.path.isdir(TEST_TMPDIR.value):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">os.makedirs(TEST_TMPDIR.value)</span>
    <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">e:</span>
      <span class="s0"># Concurrent test might have created the directory.</span>
      <span class="s3">if </span><span class="s1">e.errno != errno.EEXIST:</span>
        <span class="s3">raise</span>

  <span class="s0"># Let unittest.TestProgram.__init__ do its own argv parsing, e.g. for '-v',</span>
  <span class="s0"># on argv, which is sys.argv without the command-line flags.</span>
  <span class="s1">kwargs[</span><span class="s4">'argv'</span><span class="s1">] = argv</span>

  <span class="s3">try</span><span class="s1">:</span>
    <span class="s1">test_program = unittest.TestProgram(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">test_program.result</span>
  <span class="s3">finally</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">xml_buffer:</span>
      <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">_open(xml_output_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
          <span class="s1">f.write(xml_buffer.getvalue())</span>
      <span class="s3">finally</span><span class="s1">:</span>
        <span class="s1">xml_buffer.close()</span>


<span class="s3">def </span><span class="s1">run_tests(argv</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs):  </span><span class="s0"># pylint: disable=line-too-long</span>
  <span class="s0"># type: (MutableSequence[Text], Sequence[Any], MutableMapping[Text, Any]) -&gt; None</span>
  <span class="s0"># pylint: enable=line-too-long</span>
  <span class="s2">&quot;&quot;&quot;Executes a set of Python unit tests. 
 
  Most users should call absltest.main() instead of run_tests. 
 
  Please note that run_tests should be called from app.run. 
  Calling absltest.main() would ensure that. 
 
  Please note that run_tests is allowed to make changes to kwargs. 
 
  Args: 
    argv: sys.argv with the command-line flags removed from the front, i.e. the 
      argv with which :func:`app.run()&lt;absl.app.run&gt;` has called 
      ``__main__.main``. It is passed to 
      ``unittest.TestProgram.__init__(argv=)``, which does its own flag parsing. 
      It is ignored if kwargs contains an argv entry. 
    args: Positional arguments passed through to 
      ``unittest.TestProgram.__init__``. 
    kwargs: Keyword arguments passed through to 
      ``unittest.TestProgram.__init__``. 
  &quot;&quot;&quot;</span>
  <span class="s1">result = _run_and_get_tests_result(</span>
      <span class="s1">argv</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">, </span><span class="s1">xml_reporter.TextAndXMLTestRunner)</span>
  <span class="s1">sys.exit(</span><span class="s3">not </span><span class="s1">result.wasSuccessful())</span>


<span class="s3">def </span><span class="s1">_rmtree_ignore_errors(path):</span>
  <span class="s0"># type: (Text) -&gt; None</span>
  <span class="s3">if </span><span class="s1">os.path.isfile(path):</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s1">os.unlink(path)</span>
    <span class="s3">except </span><span class="s1">OSError:</span>
      <span class="s3">pass</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s1">shutil.rmtree(path</span><span class="s3">, </span><span class="s1">ignore_errors=</span><span class="s3">True</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_get_first_part(path):</span>
  <span class="s0"># type: (Text) -&gt; Text</span>
  <span class="s1">parts = path.split(os.sep</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
  <span class="s3">return </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">]</span>
</pre>
</body>
</html>