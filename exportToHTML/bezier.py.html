<html>
<head>
<title>bezier.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bezier.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A module providing some utility functions regarding Bézier path manipulation. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">lru_cache</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span>


<span class="s3"># same algorithm as 3.8's math.comb</span>
<span class="s1">@np.vectorize</span>
<span class="s1">@lru_cache(maxsize=</span><span class="s4">128</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_comb(n</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s2">if </span><span class="s1">k &gt; n:</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s1">k = min(k</span><span class="s2">, </span><span class="s1">n - k)</span>
    <span class="s1">i = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">k + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">np.prod((n + </span><span class="s4">1 </span><span class="s1">- i)/i).astype(int)</span>


<span class="s2">class </span><span class="s1">NonIntersectingPathException(ValueError):</span>
    <span class="s2">pass</span>


<span class="s3"># some functions</span>


<span class="s2">def </span><span class="s1">get_intersection(cx1</span><span class="s2">, </span><span class="s1">cy1</span><span class="s2">, </span><span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1</span><span class="s2">,</span>
                     <span class="s1">cx2</span><span class="s2">, </span><span class="s1">cy2</span><span class="s2">, </span><span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the intersection between the line through (*cx1*, *cy1*) at angle 
    *t1* and the line through (*cx2*, *cy2*) at angle *t2*. 
    &quot;&quot;&quot;</span>

    <span class="s3"># line1 =&gt; sin_t1 * (x - cx1) - cos_t1 * (y - cy1) = 0.</span>
    <span class="s3"># line1 =&gt; sin_t1 * x + cos_t1 * y = sin_t1*cx1 - cos_t1*cy1</span>

    <span class="s1">line1_rhs = sin_t1 * cx1 - cos_t1 * cy1</span>
    <span class="s1">line2_rhs = sin_t2 * cx2 - cos_t2 * cy2</span>

    <span class="s3"># rhs matrix</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b = sin_t1</span><span class="s2">, </span><span class="s1">-cos_t1</span>
    <span class="s1">c</span><span class="s2">, </span><span class="s1">d = sin_t2</span><span class="s2">, </span><span class="s1">-cos_t2</span>

    <span class="s1">ad_bc = a * d - b * c</span>
    <span class="s2">if </span><span class="s1">abs(ad_bc) &lt; </span><span class="s4">1e-12</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Given lines do not intersect. Please verify that &quot;</span>
                         <span class="s5">&quot;the angles are not equal or differ by 180 degrees.&quot;</span><span class="s1">)</span>

    <span class="s3"># rhs_inverse</span>
    <span class="s1">a_</span><span class="s2">, </span><span class="s1">b_ = d</span><span class="s2">, </span><span class="s1">-b</span>
    <span class="s1">c_</span><span class="s2">, </span><span class="s1">d_ = -c</span><span class="s2">, </span><span class="s1">a</span>
    <span class="s1">a_</span><span class="s2">, </span><span class="s1">b_</span><span class="s2">, </span><span class="s1">c_</span><span class="s2">, </span><span class="s1">d_ = [k / ad_bc </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[a_</span><span class="s2">, </span><span class="s1">b_</span><span class="s2">, </span><span class="s1">c_</span><span class="s2">, </span><span class="s1">d_]]</span>

    <span class="s1">x = a_ * line1_rhs + b_ * line2_rhs</span>
    <span class="s1">y = c_ * line1_rhs + d_ * line2_rhs</span>

    <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>


<span class="s2">def </span><span class="s1">get_normal_points(cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">, </span><span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t</span><span class="s2">, </span><span class="s1">length):</span>
    <span class="s0">&quot;&quot;&quot; 
    For a line passing through (*cx*, *cy*) and having an angle *t*, return 
    locations of the two points located along its perpendicular line at the 
    distance of *length*. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">length == </span><span class="s4">0.</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">, </span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cy</span>

    <span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1 = sin_t</span><span class="s2">, </span><span class="s1">-cos_t</span>
    <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2 = -sin_t</span><span class="s2">, </span><span class="s1">cos_t</span>

    <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = length * cos_t1 + cx</span><span class="s2">, </span><span class="s1">length * sin_t1 + cy</span>
    <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = length * cos_t2 + cx</span><span class="s2">, </span><span class="s1">length * sin_t2 + cy</span>

    <span class="s2">return </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span>


<span class="s3"># BEZIER routines</span>

<span class="s3"># subdividing bezier curve</span>
<span class="s3"># http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-sub.html</span>


<span class="s2">def </span><span class="s1">_de_casteljau1(beta</span><span class="s2">, </span><span class="s1">t):</span>
    <span class="s1">next_beta = beta[:-</span><span class="s4">1</span><span class="s1">] * (</span><span class="s4">1 </span><span class="s1">- t) + beta[</span><span class="s4">1</span><span class="s1">:] * t</span>
    <span class="s2">return </span><span class="s1">next_beta</span>


<span class="s2">def </span><span class="s1">split_de_casteljau(beta</span><span class="s2">, </span><span class="s1">t):</span>
    <span class="s0">&quot;&quot;&quot; 
    Split a Bézier segment defined by its control points *beta* into two 
    separate segments divided at *t* and return their control points. 
    &quot;&quot;&quot;</span>
    <span class="s1">beta = np.asarray(beta)</span>
    <span class="s1">beta_list = [beta]</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">beta = _de_casteljau1(beta</span><span class="s2">, </span><span class="s1">t)</span>
        <span class="s1">beta_list.append(beta)</span>
        <span class="s2">if </span><span class="s1">len(beta) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">break</span>
    <span class="s1">left_beta = [beta[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">beta </span><span class="s2">in </span><span class="s1">beta_list]</span>
    <span class="s1">right_beta = [beta[-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">beta </span><span class="s2">in </span><span class="s1">reversed(beta_list)]</span>

    <span class="s2">return </span><span class="s1">left_beta</span><span class="s2">, </span><span class="s1">right_beta</span>


<span class="s2">def </span><span class="s1">find_bezier_t_intersecting_with_closedpath(</span>
        <span class="s1">bezier_point_at_t</span><span class="s2">, </span><span class="s1">inside_closedpath</span><span class="s2">, </span><span class="s1">t0=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">t1=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">0.01</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find the intersection of the Bézier curve with a closed path. 
 
    The intersection point *t* is approximated by two parameters *t0*, *t1* 
    such that *t0* &lt;= *t* &lt;= *t1*. 
 
    Search starts from *t0* and *t1* and uses a simple bisecting algorithm 
    therefore one of the end points must be inside the path while the other 
    doesn't. The search stops when the distance of the points parametrized by 
    *t0* and *t1* gets smaller than the given *tolerance*. 
 
    Parameters 
    ---------- 
    bezier_point_at_t : callable 
        A function returning x, y coordinates of the Bézier at parameter *t*. 
        It must have the signature:: 
 
            bezier_point_at_t(t: float) -&gt; tuple[float, float] 
 
    inside_closedpath : callable 
        A function returning True if a given point (x, y) is inside the 
        closed path. It must have the signature:: 
 
            inside_closedpath(point: tuple[float, float]) -&gt; bool 
 
    t0, t1 : float 
        Start parameters for the search. 
 
    tolerance : float 
        Maximal allowed distance between the final points. 
 
    Returns 
    ------- 
    t0, t1 : float 
        The Bézier path parameters. 
    &quot;&quot;&quot;</span>
    <span class="s1">start = bezier_point_at_t(t0)</span>
    <span class="s1">end = bezier_point_at_t(t1)</span>

    <span class="s1">start_inside = inside_closedpath(start)</span>
    <span class="s1">end_inside = inside_closedpath(end)</span>

    <span class="s2">if </span><span class="s1">start_inside == end_inside </span><span class="s2">and </span><span class="s1">start != end:</span>
        <span class="s2">raise </span><span class="s1">NonIntersectingPathException(</span>
            <span class="s5">&quot;Both points are on the same side of the closed path&quot;</span><span class="s1">)</span>

    <span class="s2">while True</span><span class="s1">:</span>

        <span class="s3"># return if the distance is smaller than the tolerance</span>
        <span class="s2">if </span><span class="s1">np.hypot(start[</span><span class="s4">0</span><span class="s1">] - end[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">start[</span><span class="s4">1</span><span class="s1">] - end[</span><span class="s4">1</span><span class="s1">]) &lt; tolerance:</span>
            <span class="s2">return </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">t1</span>

        <span class="s3"># calculate the middle point</span>
        <span class="s1">middle_t = </span><span class="s4">0.5 </span><span class="s1">* (t0 + t1)</span>
        <span class="s1">middle = bezier_point_at_t(middle_t)</span>
        <span class="s1">middle_inside = inside_closedpath(middle)</span>

        <span class="s2">if </span><span class="s1">start_inside ^ middle_inside:</span>
            <span class="s1">t1 = middle_t</span>
            <span class="s1">end = middle</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">t0 = middle_t</span>
            <span class="s1">start = middle</span>
            <span class="s1">start_inside = middle_inside</span>


<span class="s2">class </span><span class="s1">BezierSegment:</span>
    <span class="s0">&quot;&quot;&quot; 
    A d-dimensional Bézier segment. 
 
    Parameters 
    ---------- 
    control_points : (N, d) array 
        Location of the *N* control points. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">control_points):</span>
        <span class="s1">self._cpoints = np.asarray(control_points)</span>
        <span class="s1">self._N</span><span class="s2">, </span><span class="s1">self._d = self._cpoints.shape</span>
        <span class="s1">self._orders = np.arange(self._N)</span>
        <span class="s1">coeff = [math.factorial(self._N - </span><span class="s4">1</span><span class="s1">)</span>
                 <span class="s1">// (math.factorial(i) * math.factorial(self._N - </span><span class="s4">1 </span><span class="s1">- i))</span>
                 <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._N)]</span>
        <span class="s1">self._px = (self._cpoints.T * coeff).T</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the Bézier curve at point(s) *t* in [0, 1]. 
 
        Parameters 
        ---------- 
        t : (k,) array-like 
            Points at which to evaluate the curve. 
 
        Returns 
        ------- 
        (k, d) array 
            Value of the curve for each point in *t*. 
        &quot;&quot;&quot;</span>
        <span class="s1">t = np.asarray(t)</span>
        <span class="s2">return </span><span class="s1">(np.power.outer(</span><span class="s4">1 </span><span class="s1">- t</span><span class="s2">, </span><span class="s1">self._orders[::-</span><span class="s4">1</span><span class="s1">])</span>
                <span class="s1">* np.power.outer(t</span><span class="s2">, </span><span class="s1">self._orders)) @ self._px</span>

    <span class="s2">def </span><span class="s1">point_at_t(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the curve at a single point, returning a tuple of *d* floats. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">tuple(self(t))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">control_points(self):</span>
        <span class="s0">&quot;&quot;&quot;The control points of the curve.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._cpoints</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dimension(self):</span>
        <span class="s0">&quot;&quot;&quot;The dimension of the curve.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._d</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">degree(self):</span>
        <span class="s0">&quot;&quot;&quot;Degree of the polynomial. One less the number of control points.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._N - </span><span class="s4">1</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">polynomial_coefficients(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The polynomial coefficients of the Bézier curve. 
 
        .. warning:: Follows opposite convention from `numpy.polyval`. 
 
        Returns 
        ------- 
        (n+1, d) array 
            Coefficients after expanding in polynomial basis, where :math:`n` 
            is the degree of the Bézier curve and :math:`d` its dimension. 
            These are the numbers (:math:`C_j`) such that the curve can be 
            written :math:`\sum_{j=0}^n C_j t^j`. 
 
        Notes 
        ----- 
        The coefficients are calculated as 
 
        .. math:: 
 
            {n \choose j} \sum_{i=0}^j (-1)^{i+j} {j \choose i} P_i 
 
        where :math:`P_i` are the control points of the curve. 
        &quot;&quot;&quot;</span>
        <span class="s1">n = self.degree</span>
        <span class="s3"># matplotlib uses n &lt;= 4. overflow plausible starting around n = 15.</span>
        <span class="s2">if </span><span class="s1">n &gt; </span><span class="s4">10</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s5">&quot;Polynomial coefficients formula unstable for high &quot;</span>
                          <span class="s5">&quot;order Bezier curves!&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">P = self.control_points</span>
        <span class="s1">j = np.arange(n+</span><span class="s4">1</span><span class="s1">)[:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">i = np.arange(n+</span><span class="s4">1</span><span class="s1">)[</span><span class="s2">None, </span><span class="s1">:]  </span><span class="s3"># _comb is non-zero for i &lt;= j</span>
        <span class="s1">prefactor = (-</span><span class="s4">1</span><span class="s1">)**(i + j) * _comb(j</span><span class="s2">, </span><span class="s1">i)  </span><span class="s3"># j on axis 0, i on axis 1</span>
        <span class="s2">return </span><span class="s1">_comb(n</span><span class="s2">, </span><span class="s1">j) * prefactor @ P  </span><span class="s3"># j on axis 0, self.dimension on 1</span>

    <span class="s2">def </span><span class="s1">axis_aligned_extrema(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dimension and location of the curve's interior extrema. 
 
        The extrema are the points along the curve where one of its partial 
        derivatives is zero. 
 
        Returns 
        ------- 
        dims : array of int 
            Index :math:`i` of the partial derivative which is zero at each 
            interior extrema. 
        dzeros : array of float 
            Of same size as dims. The :math:`t` such that :math:`d/dx_i B(t) = 
            0` 
        &quot;&quot;&quot;</span>
        <span class="s1">n = self.degree</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.array([])</span><span class="s2">, </span><span class="s1">np.array([])</span>
        <span class="s1">Cj = self.polynomial_coefficients</span>
        <span class="s1">dCj = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">)[:</span><span class="s2">, None</span><span class="s1">] * Cj[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">dims = []</span>
        <span class="s1">roots = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">pi </span><span class="s2">in </span><span class="s1">enumerate(dCj.T):</span>
            <span class="s1">r = np.roots(pi[::-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">roots.append(r)</span>
            <span class="s1">dims.append(np.full_like(r</span><span class="s2">, </span><span class="s1">i))</span>
        <span class="s1">roots = np.concatenate(roots)</span>
        <span class="s1">dims = np.concatenate(dims)</span>
        <span class="s1">in_range = np.isreal(roots) &amp; (roots &gt;= </span><span class="s4">0</span><span class="s1">) &amp; (roots &lt;= </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">dims[in_range]</span><span class="s2">, </span><span class="s1">np.real(roots)[in_range]</span>


<span class="s2">def </span><span class="s1">split_bezier_intersecting_with_closedpath(</span>
        <span class="s1">bezier</span><span class="s2">, </span><span class="s1">inside_closedpath</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">0.01</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Split a Bézier curve into two at the intersection with a closed path. 
 
    Parameters 
    ---------- 
    bezier : (N, 2) array-like 
        Control points of the Bézier segment. See `.BezierSegment`. 
    inside_closedpath : callable 
        A function returning True if a given point (x, y) is inside the 
        closed path. See also `.find_bezier_t_intersecting_with_closedpath`. 
    tolerance : float 
        The tolerance for the intersection. See also 
        `.find_bezier_t_intersecting_with_closedpath`. 
 
    Returns 
    ------- 
    left, right 
        Lists of control points for the two Bézier segments. 
    &quot;&quot;&quot;</span>

    <span class="s1">bz = BezierSegment(bezier)</span>
    <span class="s1">bezier_point_at_t = bz.point_at_t</span>

    <span class="s1">t0</span><span class="s2">, </span><span class="s1">t1 = find_bezier_t_intersecting_with_closedpath(</span>
        <span class="s1">bezier_point_at_t</span><span class="s2">, </span><span class="s1">inside_closedpath</span><span class="s2">, </span><span class="s1">tolerance=tolerance)</span>

    <span class="s1">_left</span><span class="s2">, </span><span class="s1">_right = split_de_casteljau(bezier</span><span class="s2">, </span><span class="s1">(t0 + t1) / </span><span class="s4">2.</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_left</span><span class="s2">, </span><span class="s1">_right</span>


<span class="s3"># matplotlib specific</span>


<span class="s2">def </span><span class="s1">split_path_inout(path</span><span class="s2">, </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">reorder_inout=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Divide a path into two segments at the point where ``inside(x, y)`` becomes 
    False. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">.path </span><span class="s2">import </span><span class="s1">Path</span>
    <span class="s1">path_iter = path.iter_segments()</span>

    <span class="s1">ctl_points</span><span class="s2">, </span><span class="s1">command = next(path_iter)</span>
    <span class="s1">begin_inside = inside(ctl_points[-</span><span class="s4">2</span><span class="s1">:])  </span><span class="s3"># true if begin point is inside</span>

    <span class="s1">ctl_points_old = ctl_points</span>

    <span class="s1">iold = </span><span class="s4">0</span>
    <span class="s1">i = </span><span class="s4">1</span>

    <span class="s2">for </span><span class="s1">ctl_points</span><span class="s2">, </span><span class="s1">command </span><span class="s2">in </span><span class="s1">path_iter:</span>
        <span class="s1">iold = i</span>
        <span class="s1">i += len(ctl_points) // </span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">inside(ctl_points[-</span><span class="s4">2</span><span class="s1">:]) != begin_inside:</span>
            <span class="s1">bezier_path = np.concatenate([ctl_points_old[-</span><span class="s4">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ctl_points])</span>
            <span class="s2">break</span>
        <span class="s1">ctl_points_old = ctl_points</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;The path does not intersect with the patch&quot;</span><span class="s1">)</span>

    <span class="s1">bp = bezier_path.reshape((-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">left</span><span class="s2">, </span><span class="s1">right = split_bezier_intersecting_with_closedpath(</span>
        <span class="s1">bp</span><span class="s2">, </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">tolerance)</span>
    <span class="s2">if </span><span class="s1">len(left) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">codes_left = [Path.LINETO]</span>
        <span class="s1">codes_right = [Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.LINETO]</span>
    <span class="s2">elif </span><span class="s1">len(left) == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s1">codes_left = [Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3]</span>
        <span class="s1">codes_right = [Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3]</span>
    <span class="s2">elif </span><span class="s1">len(left) == </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s1">codes_left = [Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4]</span>
        <span class="s1">codes_right = [Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s5">&quot;This should never be reached&quot;</span><span class="s1">)</span>

    <span class="s1">verts_left = left[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s1">verts_right = right[:]</span>

    <span class="s2">if </span><span class="s1">path.codes </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">path_in = Path(np.concatenate([path.vertices[:i]</span><span class="s2">, </span><span class="s1">verts_left]))</span>
        <span class="s1">path_out = Path(np.concatenate([verts_right</span><span class="s2">, </span><span class="s1">path.vertices[i:]]))</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">path_in = Path(np.concatenate([path.vertices[:iold]</span><span class="s2">, </span><span class="s1">verts_left])</span><span class="s2">,</span>
                       <span class="s1">np.concatenate([path.codes[:iold]</span><span class="s2">, </span><span class="s1">codes_left]))</span>

        <span class="s1">path_out = Path(np.concatenate([verts_right</span><span class="s2">, </span><span class="s1">path.vertices[i:]])</span><span class="s2">,</span>
                        <span class="s1">np.concatenate([codes_right</span><span class="s2">, </span><span class="s1">path.codes[i:]]))</span>

    <span class="s2">if </span><span class="s1">reorder_inout </span><span class="s2">and not </span><span class="s1">begin_inside:</span>
        <span class="s1">path_in</span><span class="s2">, </span><span class="s1">path_out = path_out</span><span class="s2">, </span><span class="s1">path_in</span>

    <span class="s2">return </span><span class="s1">path_in</span><span class="s2">, </span><span class="s1">path_out</span>


<span class="s2">def </span><span class="s1">inside_circle(cx</span><span class="s2">, </span><span class="s1">cy</span><span class="s2">, </span><span class="s1">r):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a function that checks whether a point is in a circle with center 
    (*cx*, *cy*) and radius *r*. 
 
    The returned function has the signature:: 
 
        f(xy: tuple[float, float]) -&gt; bool 
    &quot;&quot;&quot;</span>
    <span class="s1">r2 = r ** </span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">_f(xy):</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = xy</span>
        <span class="s2">return </span><span class="s1">(x - cx) ** </span><span class="s4">2 </span><span class="s1">+ (y - cy) ** </span><span class="s4">2 </span><span class="s1">&lt; r2</span>
    <span class="s2">return </span><span class="s1">_f</span>


<span class="s3"># quadratic Bezier lines</span>

<span class="s2">def </span><span class="s1">get_cos_sin(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1):</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x1 - x0</span><span class="s2">, </span><span class="s1">y1 - y0</span>
    <span class="s1">d = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>
    <span class="s3"># Account for divide by zero</span>
    <span class="s2">if </span><span class="s1">d == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span>
    <span class="s2">return </span><span class="s1">dx / d</span><span class="s2">, </span><span class="s1">dy / d</span>


<span class="s2">def </span><span class="s1">check_if_parallel(dx1</span><span class="s2">, </span><span class="s1">dy1</span><span class="s2">, </span><span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">1.e-5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check if two lines are parallel. 
 
    Parameters 
    ---------- 
    dx1, dy1, dx2, dy2 : float 
        The gradients *dy*/*dx* of the two lines. 
    tolerance : float 
        The angular tolerance in radians up to which the lines are considered 
        parallel. 
 
    Returns 
    ------- 
    is_parallel 
        - 1 if two lines are parallel in same direction. 
        - -1 if two lines are parallel in opposite direction. 
        - False otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s1">theta1 = np.arctan2(dx1</span><span class="s2">, </span><span class="s1">dy1)</span>
    <span class="s1">theta2 = np.arctan2(dx2</span><span class="s2">, </span><span class="s1">dy2)</span>
    <span class="s1">dtheta = abs(theta1 - theta2)</span>
    <span class="s2">if </span><span class="s1">dtheta &lt; tolerance:</span>
        <span class="s2">return </span><span class="s4">1</span>
    <span class="s2">elif </span><span class="s1">abs(dtheta - np.pi) &lt; tolerance:</span>
        <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">get_parallels(bezier2</span><span class="s2">, </span><span class="s1">width):</span>
    <span class="s0">&quot;&quot;&quot; 
    Given the quadratic Bézier control points *bezier2*, returns 
    control points of quadratic Bézier lines roughly parallel to given 
    one separated by *width*. 
    &quot;&quot;&quot;</span>

    <span class="s3"># The parallel Bezier lines are constructed by following ways.</span>
    <span class="s3">#  c1 and c2 are control points representing the start and end of the</span>
    <span class="s3">#  Bezier line.</span>
    <span class="s3">#  cm is the middle point</span>

    <span class="s1">c1x</span><span class="s2">, </span><span class="s1">c1y = bezier2[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">cmx</span><span class="s2">, </span><span class="s1">cmy = bezier2[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">c2x</span><span class="s2">, </span><span class="s1">c2y = bezier2[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">parallel_test = check_if_parallel(c1x - cmx</span><span class="s2">, </span><span class="s1">c1y - cmy</span><span class="s2">,</span>
                                      <span class="s1">cmx - c2x</span><span class="s2">, </span><span class="s1">cmy - c2y)</span>

    <span class="s2">if </span><span class="s1">parallel_test == -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">_api.warn_external(</span>
            <span class="s5">&quot;Lines do not intersect. A straight line is used instead.&quot;</span><span class="s1">)</span>
        <span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1 = get_cos_sin(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">c2x</span><span class="s2">, </span><span class="s1">c2y)</span>
        <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2 = cos_t1</span><span class="s2">, </span><span class="s1">sin_t1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># t1 and t2 is the angle between c1 and cm, cm, c2.  They are</span>
        <span class="s3"># also an angle of the tangential line of the path at c1 and c2</span>
        <span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1 = get_cos_sin(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">cmx</span><span class="s2">, </span><span class="s1">cmy)</span>
        <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2 = get_cos_sin(cmx</span><span class="s2">, </span><span class="s1">cmy</span><span class="s2">, </span><span class="s1">c2x</span><span class="s2">, </span><span class="s1">c2y)</span>

    <span class="s3"># find c1_left, c1_right which are located along the lines</span>
    <span class="s3"># through c1 and perpendicular to the tangential lines of the</span>
    <span class="s3"># Bezier path at a distance of width. Same thing for c2_left and</span>
    <span class="s3"># c2_right with respect to c2.</span>
    <span class="s1">c1x_left</span><span class="s2">, </span><span class="s1">c1y_left</span><span class="s2">, </span><span class="s1">c1x_right</span><span class="s2">, </span><span class="s1">c1y_right = (</span>
        <span class="s1">get_normal_points(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1</span><span class="s2">, </span><span class="s1">width)</span>
    <span class="s1">)</span>
    <span class="s1">c2x_left</span><span class="s2">, </span><span class="s1">c2y_left</span><span class="s2">, </span><span class="s1">c2x_right</span><span class="s2">, </span><span class="s1">c2y_right = (</span>
        <span class="s1">get_normal_points(c2x</span><span class="s2">, </span><span class="s1">c2y</span><span class="s2">, </span><span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2</span><span class="s2">, </span><span class="s1">width)</span>
    <span class="s1">)</span>

    <span class="s3"># find cm_left which is the intersecting point of a line through</span>
    <span class="s3"># c1_left with angle t1 and a line through c2_left with angle</span>
    <span class="s3"># t2. Same with cm_right.</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">cmx_left</span><span class="s2">, </span><span class="s1">cmy_left = get_intersection(c1x_left</span><span class="s2">, </span><span class="s1">c1y_left</span><span class="s2">, </span><span class="s1">cos_t1</span><span class="s2">,</span>
                                              <span class="s1">sin_t1</span><span class="s2">, </span><span class="s1">c2x_left</span><span class="s2">, </span><span class="s1">c2y_left</span><span class="s2">,</span>
                                              <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2)</span>
        <span class="s1">cmx_right</span><span class="s2">, </span><span class="s1">cmy_right = get_intersection(c1x_right</span><span class="s2">, </span><span class="s1">c1y_right</span><span class="s2">, </span><span class="s1">cos_t1</span><span class="s2">,</span>
                                                <span class="s1">sin_t1</span><span class="s2">, </span><span class="s1">c2x_right</span><span class="s2">, </span><span class="s1">c2y_right</span><span class="s2">,</span>
                                                <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2)</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s3"># Special case straight lines, i.e., angle between two lines is</span>
        <span class="s3"># less than the threshold used by get_intersection (we don't use</span>
        <span class="s3"># check_if_parallel as the threshold is not the same).</span>
        <span class="s1">cmx_left</span><span class="s2">, </span><span class="s1">cmy_left = (</span>
            <span class="s4">0.5 </span><span class="s1">* (c1x_left + c2x_left)</span><span class="s2">, </span><span class="s4">0.5 </span><span class="s1">* (c1y_left + c2y_left)</span>
        <span class="s1">)</span>
        <span class="s1">cmx_right</span><span class="s2">, </span><span class="s1">cmy_right = (</span>
            <span class="s4">0.5 </span><span class="s1">* (c1x_right + c2x_right)</span><span class="s2">, </span><span class="s4">0.5 </span><span class="s1">* (c1y_right + c2y_right)</span>
        <span class="s1">)</span>

    <span class="s3"># the parallel Bezier lines are created with control points of</span>
    <span class="s3"># [c1_left, cm_left, c2_left] and [c1_right, cm_right, c2_right]</span>
    <span class="s1">path_left = [(c1x_left</span><span class="s2">, </span><span class="s1">c1y_left)</span><span class="s2">,</span>
                 <span class="s1">(cmx_left</span><span class="s2">, </span><span class="s1">cmy_left)</span><span class="s2">,</span>
                 <span class="s1">(c2x_left</span><span class="s2">, </span><span class="s1">c2y_left)]</span>
    <span class="s1">path_right = [(c1x_right</span><span class="s2">, </span><span class="s1">c1y_right)</span><span class="s2">,</span>
                  <span class="s1">(cmx_right</span><span class="s2">, </span><span class="s1">cmy_right)</span><span class="s2">,</span>
                  <span class="s1">(c2x_right</span><span class="s2">, </span><span class="s1">c2y_right)]</span>

    <span class="s2">return </span><span class="s1">path_left</span><span class="s2">, </span><span class="s1">path_right</span>


<span class="s2">def </span><span class="s1">find_control_points(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">mmx</span><span class="s2">, </span><span class="s1">mmy</span><span class="s2">, </span><span class="s1">c2x</span><span class="s2">, </span><span class="s1">c2y):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find control points of the Bézier curve passing through (*c1x*, *c1y*), 
    (*mmx*, *mmy*), and (*c2x*, *c2y*), at parametric values 0, 0.5, and 1. 
    &quot;&quot;&quot;</span>
    <span class="s1">cmx = </span><span class="s4">.5 </span><span class="s1">* (</span><span class="s4">4 </span><span class="s1">* mmx - (c1x + c2x))</span>
    <span class="s1">cmy = </span><span class="s4">.5 </span><span class="s1">* (</span><span class="s4">4 </span><span class="s1">* mmy - (c1y + c2y))</span>
    <span class="s2">return </span><span class="s1">[(c1x</span><span class="s2">, </span><span class="s1">c1y)</span><span class="s2">, </span><span class="s1">(cmx</span><span class="s2">, </span><span class="s1">cmy)</span><span class="s2">, </span><span class="s1">(c2x</span><span class="s2">, </span><span class="s1">c2y)]</span>


<span class="s2">def </span><span class="s1">make_wedged_bezier2(bezier2</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">w1=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">wm=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">w2=</span><span class="s4">0.</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Being similar to `get_parallels`, returns control points of two quadratic 
    Bézier lines having a width roughly parallel to given one separated by 
    *width*. 
    &quot;&quot;&quot;</span>

    <span class="s3"># c1, cm, c2</span>
    <span class="s1">c1x</span><span class="s2">, </span><span class="s1">c1y = bezier2[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">cmx</span><span class="s2">, </span><span class="s1">cmy = bezier2[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">c3x</span><span class="s2">, </span><span class="s1">c3y = bezier2[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s3"># t1 and t2 is the angle between c1 and cm, cm, c3.</span>
    <span class="s3"># They are also an angle of the tangential line of the path at c1 and c3</span>
    <span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1 = get_cos_sin(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">cmx</span><span class="s2">, </span><span class="s1">cmy)</span>
    <span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2 = get_cos_sin(cmx</span><span class="s2">, </span><span class="s1">cmy</span><span class="s2">, </span><span class="s1">c3x</span><span class="s2">, </span><span class="s1">c3y)</span>

    <span class="s3"># find c1_left, c1_right which are located along the lines</span>
    <span class="s3"># through c1 and perpendicular to the tangential lines of the</span>
    <span class="s3"># Bezier path at a distance of width. Same thing for c3_left and</span>
    <span class="s3"># c3_right with respect to c3.</span>
    <span class="s1">c1x_left</span><span class="s2">, </span><span class="s1">c1y_left</span><span class="s2">, </span><span class="s1">c1x_right</span><span class="s2">, </span><span class="s1">c1y_right = (</span>
        <span class="s1">get_normal_points(c1x</span><span class="s2">, </span><span class="s1">c1y</span><span class="s2">, </span><span class="s1">cos_t1</span><span class="s2">, </span><span class="s1">sin_t1</span><span class="s2">, </span><span class="s1">width * w1)</span>
    <span class="s1">)</span>
    <span class="s1">c3x_left</span><span class="s2">, </span><span class="s1">c3y_left</span><span class="s2">, </span><span class="s1">c3x_right</span><span class="s2">, </span><span class="s1">c3y_right = (</span>
        <span class="s1">get_normal_points(c3x</span><span class="s2">, </span><span class="s1">c3y</span><span class="s2">, </span><span class="s1">cos_t2</span><span class="s2">, </span><span class="s1">sin_t2</span><span class="s2">, </span><span class="s1">width * w2)</span>
    <span class="s1">)</span>

    <span class="s3"># find c12, c23 and c123 which are middle points of c1-cm, cm-c3 and</span>
    <span class="s3"># c12-c23</span>
    <span class="s1">c12x</span><span class="s2">, </span><span class="s1">c12y = (c1x + cmx) * </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">(c1y + cmy) * </span><span class="s4">.5</span>
    <span class="s1">c23x</span><span class="s2">, </span><span class="s1">c23y = (cmx + c3x) * </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">(cmy + c3y) * </span><span class="s4">.5</span>
    <span class="s1">c123x</span><span class="s2">, </span><span class="s1">c123y = (c12x + c23x) * </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">(c12y + c23y) * </span><span class="s4">.5</span>

    <span class="s3"># tangential angle of c123 (angle between c12 and c23)</span>
    <span class="s1">cos_t123</span><span class="s2">, </span><span class="s1">sin_t123 = get_cos_sin(c12x</span><span class="s2">, </span><span class="s1">c12y</span><span class="s2">, </span><span class="s1">c23x</span><span class="s2">, </span><span class="s1">c23y)</span>

    <span class="s1">c123x_left</span><span class="s2">, </span><span class="s1">c123y_left</span><span class="s2">, </span><span class="s1">c123x_right</span><span class="s2">, </span><span class="s1">c123y_right = (</span>
        <span class="s1">get_normal_points(c123x</span><span class="s2">, </span><span class="s1">c123y</span><span class="s2">, </span><span class="s1">cos_t123</span><span class="s2">, </span><span class="s1">sin_t123</span><span class="s2">, </span><span class="s1">width * wm)</span>
    <span class="s1">)</span>

    <span class="s1">path_left = find_control_points(c1x_left</span><span class="s2">, </span><span class="s1">c1y_left</span><span class="s2">,</span>
                                    <span class="s1">c123x_left</span><span class="s2">, </span><span class="s1">c123y_left</span><span class="s2">,</span>
                                    <span class="s1">c3x_left</span><span class="s2">, </span><span class="s1">c3y_left)</span>
    <span class="s1">path_right = find_control_points(c1x_right</span><span class="s2">, </span><span class="s1">c1y_right</span><span class="s2">,</span>
                                     <span class="s1">c123x_right</span><span class="s2">, </span><span class="s1">c123y_right</span><span class="s2">,</span>
                                     <span class="s1">c3x_right</span><span class="s2">, </span><span class="s1">c3y_right)</span>

    <span class="s2">return </span><span class="s1">path_left</span><span class="s2">, </span><span class="s1">path_right</span>
</pre>
</body>
</html>