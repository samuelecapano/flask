<html>
<head>
<title>rules.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rules.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">ast</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">typing </span><span class="s0">as </span><span class="s1">t</span>
<span class="s0">from </span><span class="s1">dataclasses </span><span class="s0">import </span><span class="s1">dataclass</span>
<span class="s0">from </span><span class="s1">string </span><span class="s0">import </span><span class="s1">Template</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">CodeType</span>

<span class="s0">from </span><span class="s1">.._internal </span><span class="s0">import </span><span class="s1">_to_bytes</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">url_encode</span>
<span class="s0">from </span><span class="s1">..urls </span><span class="s0">import </span><span class="s1">url_quote</span>
<span class="s0">from </span><span class="s1">.converters </span><span class="s0">import </span><span class="s1">ValidationError</span>

<span class="s0">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">.converters </span><span class="s0">import </span><span class="s1">BaseConverter</span>
    <span class="s0">from </span><span class="s1">.map </span><span class="s0">import </span><span class="s1">Map</span>


<span class="s0">class </span><span class="s1">Weighting(t.NamedTuple):</span>
    <span class="s1">number_static_weights: int</span>
    <span class="s1">static_weights: t.List[t.Tuple[int</span><span class="s0">, </span><span class="s1">int]]</span>
    <span class="s1">number_argument_weights: int</span>
    <span class="s1">argument_weights: t.List[int]</span>


<span class="s1">@dataclass</span>
<span class="s0">class </span><span class="s1">RulePart:</span>
    <span class="s2">&quot;&quot;&quot;A part of a rule. 
 
    Rules can be represented by parts as delimited by `/` with 
    instances of this class representing those parts. The *content* is 
    either the raw content if *static* or a regex string to match 
    against. The *weight* can be used to order parts when matching. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">content: str</span>
    <span class="s1">final: bool</span>
    <span class="s1">static: bool</span>
    <span class="s1">suffixed: bool</span>
    <span class="s1">weight: Weighting</span>


<span class="s1">_part_re = re.compile(</span>
    <span class="s3">r&quot;&quot;&quot; 
    (?: 
        (?P&lt;slash&gt;\/)                                 # a slash 
      | 
        (?P&lt;static&gt;[^&lt;\/]+)                           # static rule data 
      | 
        (?: 
          &lt; 
            (?: 
              (?P&lt;converter&gt;[a-zA-Z_][a-zA-Z0-9_]*)   # converter name 
              (?:\((?P&lt;arguments&gt;.*?)\))?             # converter arguments 
              \:                                      # variable delimiter 
            )? 
            (?P&lt;variable&gt;[a-zA-Z_][a-zA-Z0-9_]*)      # variable name 
           &gt; 
        ) 
    ) 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">re.VERBOSE</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">_simple_rule_re = re.compile(</span><span class="s3">r&quot;&lt;([^&gt;]+)&gt;&quot;</span><span class="s1">)</span>
<span class="s1">_converter_args_re = re.compile(</span>
    <span class="s3">r&quot;&quot;&quot; 
    ((?P&lt;name&gt;\w+)\s*=\s*)? 
    (?P&lt;value&gt; 
        True|False| 
        \d+.\d+| 
        \d+.| 
        \d+| 
        [\w\d_.]+| 
        [urUR]?(?P&lt;stringval&gt;&quot;[^&quot;]*?&quot;|'[^']*') 
    )\s*, 
    &quot;&quot;&quot;</span><span class="s0">,</span>
    <span class="s1">re.VERBOSE</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">_PYTHON_CONSTANTS = {</span><span class="s3">&quot;None&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s3">&quot;True&quot;</span><span class="s1">: </span><span class="s0">True, </span><span class="s3">&quot;False&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">_find(value: str</span><span class="s0">, </span><span class="s1">target: str</span><span class="s0">, </span><span class="s1">pos: int) -&gt; int:</span>
    <span class="s2">&quot;&quot;&quot;Find the *target* in *value* after *pos*. 
 
    Returns the *value* length if *target* isn't found. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">value.index(target</span><span class="s0">, </span><span class="s1">pos)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s0">return </span><span class="s1">len(value)</span>


<span class="s0">def </span><span class="s1">_pythonize(value: str) -&gt; t.Union[</span><span class="s0">None, </span><span class="s1">bool</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">str]:</span>
    <span class="s0">if </span><span class="s1">value </span><span class="s0">in </span><span class="s1">_PYTHON_CONSTANTS:</span>
        <span class="s0">return </span><span class="s1">_PYTHON_CONSTANTS[value]</span>
    <span class="s0">for </span><span class="s1">convert </span><span class="s0">in </span><span class="s1">int</span><span class="s0">, </span><span class="s1">float:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">convert(value)  </span><span class="s4"># type: ignore</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s0">pass</span>
    <span class="s0">if </span><span class="s1">value[:</span><span class="s5">1</span><span class="s1">] == value[-</span><span class="s5">1</span><span class="s1">:] </span><span class="s0">and </span><span class="s1">value[</span><span class="s5">0</span><span class="s1">] </span><span class="s0">in </span><span class="s3">&quot;</span><span class="s0">\&quot;</span><span class="s3">'&quot;</span><span class="s1">:</span>
        <span class="s1">value = value[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">str(value)</span>


<span class="s0">def </span><span class="s1">parse_converter_args(argstr: str) -&gt; t.Tuple[t.Tuple</span><span class="s0">, </span><span class="s1">t.Dict[str</span><span class="s0">, </span><span class="s1">t.Any]]:</span>
    <span class="s1">argstr += </span><span class="s3">&quot;,&quot;</span>
    <span class="s1">args = []</span>
    <span class="s1">kwargs = {}</span>

    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">_converter_args_re.finditer(argstr):</span>
        <span class="s1">value = item.group(</span><span class="s3">&quot;stringval&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">value </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">value = item.group(</span><span class="s3">&quot;value&quot;</span><span class="s1">)</span>
        <span class="s1">value = _pythonize(value)</span>
        <span class="s0">if not </span><span class="s1">item.group(</span><span class="s3">&quot;name&quot;</span><span class="s1">):</span>
            <span class="s1">args.append(value)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">name = item.group(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s1">kwargs[name] = value</span>

    <span class="s0">return </span><span class="s1">tuple(args)</span><span class="s0">, </span><span class="s1">kwargs</span>


<span class="s0">class </span><span class="s1">RuleFactory:</span>
    <span class="s2">&quot;&quot;&quot;As soon as you have more complex URL setups it's a good idea to use rule 
    factories to avoid repetitive tasks.  Some of them are builtin, others can 
    be added by subclassing `RuleFactory` and overriding `get_rules`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterable[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s2">&quot;&quot;&quot;Subclasses of `RuleFactory` have to override this method and return 
        an iterable of rules.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>


<span class="s0">class </span><span class="s1">Subdomain(RuleFactory):</span>
    <span class="s2">&quot;&quot;&quot;All URLs provided by this factory have the subdomain set to a 
    specific domain. For example if you want to use the subdomain for 
    the current language this can be a good setup:: 
 
        url_map = Map([ 
            Rule('/', endpoint='#select_language'), 
            Subdomain('&lt;string(length=2):lang_code&gt;', [ 
                Rule('/', endpoint='index'), 
                Rule('/about', endpoint='about'), 
                Rule('/help', endpoint='help') 
            ]) 
        ]) 
 
    All the rules except for the ``'#select_language'`` endpoint will now 
    listen on a two letter long subdomain that holds the language code 
    for the current request. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">subdomain: str</span><span class="s0">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.subdomain = subdomain</span>
        <span class="s1">self.rules = rules</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">rulefactory </span><span class="s0">in </span><span class="s1">self.rules:</span>
            <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.subdomain = self.subdomain</span>
                <span class="s0">yield </span><span class="s1">rule</span>


<span class="s0">class </span><span class="s1">Submount(RuleFactory):</span>
    <span class="s2">&quot;&quot;&quot;Like `Subdomain` but prefixes the URL rule with a given string:: 
 
        url_map = Map([ 
            Rule('/', endpoint='index'), 
            Submount('/blog', [ 
                Rule('/', endpoint='blog/index'), 
                Rule('/entry/&lt;entry_slug&gt;', endpoint='blog/show') 
            ]) 
        ]) 
 
    Now the rule ``'blog/show'`` matches ``/blog/entry/&lt;entry_slug&gt;``. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">path: str</span><span class="s0">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.path = path.rstrip(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">self.rules = rules</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">rulefactory </span><span class="s0">in </span><span class="s1">self.rules:</span>
            <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.rule = self.path + rule.rule</span>
                <span class="s0">yield </span><span class="s1">rule</span>


<span class="s0">class </span><span class="s1">EndpointPrefix(RuleFactory):</span>
    <span class="s2">&quot;&quot;&quot;Prefixes all endpoints (which must be strings for this factory) with 
    another string. This can be useful for sub applications:: 
 
        url_map = Map([ 
            Rule('/', endpoint='index'), 
            EndpointPrefix('blog/', [Submount('/blog', [ 
                Rule('/', endpoint='index'), 
                Rule('/entry/&lt;entry_slug&gt;', endpoint='show') 
            ])]) 
        ]) 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">prefix: str</span><span class="s0">, </span><span class="s1">rules: t.Iterable[RuleFactory]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s1">self.rules = rules</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">rulefactory </span><span class="s0">in </span><span class="s1">self.rules:</span>
            <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">rule = rule.empty()</span>
                <span class="s1">rule.endpoint = self.prefix + rule.endpoint</span>
                <span class="s0">yield </span><span class="s1">rule</span>


<span class="s0">class </span><span class="s1">RuleTemplate:</span>
    <span class="s2">&quot;&quot;&quot;Returns copies of the rules wrapped and expands string templates in 
    the endpoint, rule, defaults or subdomain sections. 
 
    Here a small example for such a rule template:: 
 
        from werkzeug.routing import Map, Rule, RuleTemplate 
 
        resource = RuleTemplate([ 
            Rule('/$name/', endpoint='$name.list'), 
            Rule('/$name/&lt;int:id&gt;', endpoint='$name.show') 
        ]) 
 
        url_map = Map([resource(name='user'), resource(name='page')]) 
 
    When a rule template is called the keyword arguments are used to 
    replace the placeholders in all the string parameters. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">rules: t.Iterable[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.rules = list(rules)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args: t.Any</span><span class="s0">, </span><span class="s1">**kwargs: t.Any) -&gt; </span><span class="s3">&quot;RuleTemplateFactory&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">RuleTemplateFactory(self.rules</span><span class="s0">, </span><span class="s1">dict(*args</span><span class="s0">, </span><span class="s1">**kwargs))</span>


<span class="s0">class </span><span class="s1">RuleTemplateFactory(RuleFactory):</span>
    <span class="s2">&quot;&quot;&quot;A factory that fills in template variables into rules.  Used by 
    `RuleTemplate` internally. 
 
    :internal: 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">rules: t.Iterable[RuleFactory]</span><span class="s0">, </span><span class="s1">context: t.Dict[str</span><span class="s0">, </span><span class="s1">t.Any]</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.rules = rules</span>
        <span class="s1">self.context = context</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">rulefactory </span><span class="s0">in </span><span class="s1">self.rules:</span>
            <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">rulefactory.get_rules(map):</span>
                <span class="s1">new_defaults = subdomain = </span><span class="s0">None</span>
                <span class="s0">if </span><span class="s1">rule.defaults:</span>
                    <span class="s1">new_defaults = {}</span>
                    <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">rule.defaults.items():</span>
                        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">str):</span>
                            <span class="s1">value = Template(value).substitute(self.context)</span>
                        <span class="s1">new_defaults[key] = value</span>
                <span class="s0">if </span><span class="s1">rule.subdomain </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">subdomain = Template(rule.subdomain).substitute(self.context)</span>
                <span class="s1">new_endpoint = rule.endpoint</span>
                <span class="s0">if </span><span class="s1">isinstance(new_endpoint</span><span class="s0">, </span><span class="s1">str):</span>
                    <span class="s1">new_endpoint = Template(new_endpoint).substitute(self.context)</span>
                <span class="s0">yield </span><span class="s1">Rule(</span>
                    <span class="s1">Template(rule.rule).substitute(self.context)</span><span class="s0">,</span>
                    <span class="s1">new_defaults</span><span class="s0">,</span>
                    <span class="s1">subdomain</span><span class="s0">,</span>
                    <span class="s1">rule.methods</span><span class="s0">,</span>
                    <span class="s1">rule.build_only</span><span class="s0">,</span>
                    <span class="s1">new_endpoint</span><span class="s0">,</span>
                    <span class="s1">rule.strict_slashes</span><span class="s0">,</span>
                <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_prefix_names(src: str) -&gt; ast.stmt:</span>
    <span class="s2">&quot;&quot;&quot;ast parse and prefix names with `.` to avoid collision with user vars&quot;&quot;&quot;</span>
    <span class="s1">tree = ast.parse(src).body[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">isinstance(tree</span><span class="s0">, </span><span class="s1">ast.Expr):</span>
        <span class="s1">tree = tree.value  </span><span class="s4"># type: ignore</span>
    <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">ast.walk(tree):</span>
        <span class="s0">if </span><span class="s1">isinstance(node</span><span class="s0">, </span><span class="s1">ast.Name):</span>
            <span class="s1">node.id = </span><span class="s3">f&quot;.</span><span class="s0">{</span><span class="s1">node.id</span><span class="s0">}</span><span class="s3">&quot;</span>
    <span class="s0">return </span><span class="s1">tree</span>


<span class="s1">_CALL_CONVERTER_CODE_FMT = </span><span class="s3">&quot;self._converters[{elem!r}].to_url()&quot;</span>
<span class="s1">_IF_KWARGS_URL_ENCODE_CODE = </span><span class="s3">&quot;&quot;&quot;</span><span class="s0">\ 
</span><span class="s3">if kwargs: 
    params = self._encode_query_vars(kwargs) 
    q = &quot;?&quot; if params else &quot;&quot; 
else: 
    q = params = &quot;&quot; 
&quot;&quot;&quot;</span>
<span class="s1">_IF_KWARGS_URL_ENCODE_AST = _prefix_names(_IF_KWARGS_URL_ENCODE_CODE)</span>
<span class="s1">_URL_ENCODE_AST_NAMES = (_prefix_names(</span><span class="s3">&quot;q&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">_prefix_names(</span><span class="s3">&quot;params&quot;</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">Rule(RuleFactory):</span>
    <span class="s2">&quot;&quot;&quot;A Rule represents one URL pattern.  There are some options for `Rule` 
    that change the way it behaves and are passed to the `Rule` constructor. 
    Note that besides the rule-string all arguments *must* be keyword arguments 
    in order to not break the application on Werkzeug upgrades. 
 
    `string` 
        Rule strings basically are just normal URL paths with placeholders in 
        the format ``&lt;converter(arguments):name&gt;`` where the converter and the 
        arguments are optional.  If no converter is defined the `default` 
        converter is used which means `string` in the normal configuration. 
 
        URL rules that end with a slash are branch URLs, others are leaves. 
        If you have `strict_slashes` enabled (which is the default), all 
        branch URLs that are matched without a trailing slash will trigger a 
        redirect to the same URL with the missing slash appended. 
 
        The converters are defined on the `Map`. 
 
    `endpoint` 
        The endpoint for this rule. This can be anything. A reference to a 
        function, a string, a number etc.  The preferred way is using a string 
        because the endpoint is used for URL generation. 
 
    `defaults` 
        An optional dict with defaults for other rules with the same endpoint. 
        This is a bit tricky but useful if you want to have unique URLs:: 
 
            url_map = Map([ 
                Rule('/all/', defaults={'page': 1}, endpoint='all_entries'), 
                Rule('/all/page/&lt;int:page&gt;', endpoint='all_entries') 
            ]) 
 
        If a user now visits ``http://example.com/all/page/1`` they will be 
        redirected to ``http://example.com/all/``.  If `redirect_defaults` is 
        disabled on the `Map` instance this will only affect the URL 
        generation. 
 
    `subdomain` 
        The subdomain rule string for this rule. If not specified the rule 
        only matches for the `default_subdomain` of the map.  If the map is 
        not bound to a subdomain this feature is disabled. 
 
        Can be useful if you want to have user profiles on different subdomains 
        and all subdomains are forwarded to your application:: 
 
            url_map = Map([ 
                Rule('/', subdomain='&lt;username&gt;', endpoint='user/homepage'), 
                Rule('/stats', subdomain='&lt;username&gt;', endpoint='user/stats') 
            ]) 
 
    `methods` 
        A sequence of http methods this rule applies to.  If not specified, all 
        methods are allowed. For example this can be useful if you want different 
        endpoints for `POST` and `GET`.  If methods are defined and the path 
        matches but the method matched against is not in this list or in the 
        list of another rule for that path the error raised is of the type 
        `MethodNotAllowed` rather than `NotFound`.  If `GET` is present in the 
        list of methods and `HEAD` is not, `HEAD` is added automatically. 
 
    `strict_slashes` 
        Override the `Map` setting for `strict_slashes` only for this rule. If 
        not specified the `Map` setting is used. 
 
    `merge_slashes` 
        Override :attr:`Map.merge_slashes` for this rule. 
 
    `build_only` 
        Set this to True and the rule will never match but will create a URL 
        that can be build. This is useful if you have resources on a subdomain 
        or folder that are not handled by the WSGI application (like static data) 
 
    `redirect_to` 
        If given this must be either a string or callable.  In case of a 
        callable it's called with the url adapter that triggered the match and 
        the values of the URL as keyword arguments and has to return the target 
        for the redirect, otherwise it has to be a string with placeholders in 
        rule syntax:: 
 
            def foo_with_slug(adapter, id): 
                # ask the database for the slug for the old id.  this of 
                # course has nothing to do with werkzeug. 
                return f'foo/{Foo.get_slug_for_id(id)}' 
 
            url_map = Map([ 
                Rule('/foo/&lt;slug&gt;', endpoint='foo'), 
                Rule('/some/old/url/&lt;slug&gt;', redirect_to='foo/&lt;slug&gt;'), 
                Rule('/other/old/url/&lt;int:id&gt;', redirect_to=foo_with_slug) 
            ]) 
 
        When the rule is matched the routing system will raise a 
        `RequestRedirect` exception with the target for the redirect. 
 
        Keep in mind that the URL will be joined against the URL root of the 
        script so don't use a leading slash on the target URL unless you 
        really mean root of that domain. 
 
    `alias` 
        If enabled this rule serves as an alias for another rule with the same 
        endpoint and arguments. 
 
    `host` 
        If provided and the URL map has host matching enabled this can be 
        used to provide a match rule for the whole host.  This also means 
        that the subdomain feature is disabled. 
 
    `websocket` 
        If ``True``, this rule is only matches for WebSocket (``ws://``, 
        ``wss://``) requests. By default, rules will only match for HTTP 
        requests. 
 
    .. versionchanged:: 2.1 
        Percent-encoded newlines (``%0a``), which are decoded by WSGI 
        servers, are considered when routing instead of terminating the 
        match early. 
 
    .. versionadded:: 1.0 
        Added ``websocket``. 
 
    .. versionadded:: 1.0 
        Added ``merge_slashes``. 
 
    .. versionadded:: 0.7 
        Added ``alias`` and ``host``. 
 
    .. versionchanged:: 0.6.1 
       ``HEAD`` is added to ``methods`` if ``GET`` is present. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">string: str</span><span class="s0">,</span>
        <span class="s1">defaults: t.Optional[t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]] = </span><span class="s0">None,</span>
        <span class="s1">subdomain: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">methods: t.Optional[t.Iterable[str]] = </span><span class="s0">None,</span>
        <span class="s1">build_only: bool = </span><span class="s0">False,</span>
        <span class="s1">endpoint: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">strict_slashes: t.Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">merge_slashes: t.Optional[bool] = </span><span class="s0">None,</span>
        <span class="s1">redirect_to: t.Optional[t.Union[str</span><span class="s0">, </span><span class="s1">t.Callable[...</span><span class="s0">, </span><span class="s1">str]]] = </span><span class="s0">None,</span>
        <span class="s1">alias: bool = </span><span class="s0">False,</span>
        <span class="s1">host: t.Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">websocket: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">string.startswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;urls must start with a leading slash&quot;</span><span class="s1">)</span>
        <span class="s1">self.rule = string</span>
        <span class="s1">self.is_leaf = </span><span class="s0">not </span><span class="s1">string.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s1">self.is_branch = string.endswith(</span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>

        <span class="s1">self.map: </span><span class="s3">&quot;Map&quot; </span><span class="s1">= </span><span class="s0">None  </span><span class="s4"># type: ignore</span>
        <span class="s1">self.strict_slashes = strict_slashes</span>
        <span class="s1">self.merge_slashes = merge_slashes</span>
        <span class="s1">self.subdomain = subdomain</span>
        <span class="s1">self.host = host</span>
        <span class="s1">self.defaults = defaults</span>
        <span class="s1">self.build_only = build_only</span>
        <span class="s1">self.alias = alias</span>
        <span class="s1">self.websocket = websocket</span>

        <span class="s0">if </span><span class="s1">methods </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(methods</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;'methods' should be a list of strings.&quot;</span><span class="s1">)</span>

            <span class="s1">methods = {x.upper() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">methods}</span>

            <span class="s0">if </span><span class="s3">&quot;HEAD&quot; </span><span class="s0">not in </span><span class="s1">methods </span><span class="s0">and </span><span class="s3">&quot;GET&quot; </span><span class="s0">in </span><span class="s1">methods:</span>
                <span class="s1">methods.add(</span><span class="s3">&quot;HEAD&quot;</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">websocket </span><span class="s0">and </span><span class="s1">methods - {</span><span class="s3">&quot;GET&quot;</span><span class="s0">, </span><span class="s3">&quot;HEAD&quot;</span><span class="s0">, </span><span class="s3">&quot;OPTIONS&quot;</span><span class="s1">}:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;WebSocket rules can only use 'GET', 'HEAD', and 'OPTIONS' methods.&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self.methods = methods</span>
        <span class="s1">self.endpoint: str = endpoint  </span><span class="s4"># type: ignore</span>
        <span class="s1">self.redirect_to = redirect_to</span>

        <span class="s0">if </span><span class="s1">defaults:</span>
            <span class="s1">self.arguments = set(map(str</span><span class="s0">, </span><span class="s1">defaults))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.arguments = set()</span>

        <span class="s1">self._converters: t.Dict[str</span><span class="s0">, </span><span class="s3">&quot;BaseConverter&quot;</span><span class="s1">] = {}</span>
        <span class="s1">self._trace: t.List[t.Tuple[bool</span><span class="s0">, </span><span class="s1">str]] = []</span>
        <span class="s1">self._parts: t.List[RulePart] = []</span>

    <span class="s0">def </span><span class="s1">empty(self) -&gt; </span><span class="s3">&quot;Rule&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Return an unbound copy of this rule. 
 
        This can be useful if want to reuse an already bound URL for another 
        map.  See ``get_empty_kwargs`` to override what keyword arguments are 
        provided to the new copy. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">type(self)(self.rule</span><span class="s0">, </span><span class="s1">**self.get_empty_kwargs())</span>

    <span class="s0">def </span><span class="s1">get_empty_kwargs(self) -&gt; t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]:</span>
        <span class="s2">&quot;&quot;&quot; 
        Provides kwargs for instantiating empty copy with empty() 
 
        Use this method to provide custom keyword arguments to the subclass of 
        ``Rule`` when calling ``some_rule.empty()``.  Helpful when the subclass 
        has custom keyword arguments that are needed at instantiation. 
 
        Must return a ``dict`` that will be provided as kwargs to the new 
        instance of ``Rule``, following the initial ``self.rule`` value which 
        is always provided as the first, required positional argument. 
        &quot;&quot;&quot;</span>
        <span class="s1">defaults = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">self.defaults:</span>
            <span class="s1">defaults = dict(self.defaults)</span>
        <span class="s0">return </span><span class="s1">dict(</span>
            <span class="s1">defaults=defaults</span><span class="s0">,</span>
            <span class="s1">subdomain=self.subdomain</span><span class="s0">,</span>
            <span class="s1">methods=self.methods</span><span class="s0">,</span>
            <span class="s1">build_only=self.build_only</span><span class="s0">,</span>
            <span class="s1">endpoint=self.endpoint</span><span class="s0">,</span>
            <span class="s1">strict_slashes=self.strict_slashes</span><span class="s0">,</span>
            <span class="s1">redirect_to=self.redirect_to</span><span class="s0">,</span>
            <span class="s1">alias=self.alias</span><span class="s0">,</span>
            <span class="s1">host=self.host</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_rules(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s1">) -&gt; t.Iterator[</span><span class="s3">&quot;Rule&quot;</span><span class="s1">]:</span>
        <span class="s0">yield </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">refresh(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Rebinds and refreshes the URL.  Call this if you modified the 
        rule in place. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s1">self.bind(self.map</span><span class="s0">, </span><span class="s1">rebind=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">bind(self</span><span class="s0">, </span><span class="s1">map: </span><span class="s3">&quot;Map&quot;</span><span class="s0">, </span><span class="s1">rebind: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Bind the url to a map and create a regular expression based on 
        the information from the rule itself and the defaults from the map. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.map </span><span class="s0">is not None and not </span><span class="s1">rebind:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s3">f&quot;url rule </span><span class="s0">{</span><span class="s1">self</span><span class="s0">!r} </span><span class="s3">already bound to map </span><span class="s0">{</span><span class="s1">self.map</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">self.map = map</span>
        <span class="s0">if </span><span class="s1">self.strict_slashes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.strict_slashes = map.strict_slashes</span>
        <span class="s0">if </span><span class="s1">self.merge_slashes </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.merge_slashes = map.merge_slashes</span>
        <span class="s0">if </span><span class="s1">self.subdomain </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.subdomain = map.default_subdomain</span>
        <span class="s1">self.compile()</span>

    <span class="s0">def </span><span class="s1">get_converter(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">variable_name: str</span><span class="s0">,</span>
        <span class="s1">converter_name: str</span><span class="s0">,</span>
        <span class="s1">args: t.Tuple</span><span class="s0">,</span>
        <span class="s1">kwargs: t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;BaseConverter&quot;</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Looks up the converter for the given parameter. 
 
        .. versionadded:: 0.9 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">converter_name </span><span class="s0">not in </span><span class="s1">self.map.converters:</span>
            <span class="s0">raise </span><span class="s1">LookupError(</span><span class="s3">f&quot;the converter </span><span class="s0">{</span><span class="s1">converter_name</span><span class="s0">!r} </span><span class="s3">does not exist&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.map.converters[converter_name](self.map</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">_encode_query_vars(self</span><span class="s0">, </span><span class="s1">query_vars: t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">url_encode(</span>
            <span class="s1">query_vars</span><span class="s0">,</span>
            <span class="s1">charset=self.map.charset</span><span class="s0">,</span>
            <span class="s1">sort=self.map.sort_parameters</span><span class="s0">,</span>
            <span class="s1">key=self.map.sort_key</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_parse_rule(self</span><span class="s0">, </span><span class="s1">rule: str) -&gt; t.Iterable[RulePart]:</span>
        <span class="s1">content = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">static = </span><span class="s0">True</span>
        <span class="s1">argument_weights = []</span>
        <span class="s1">static_weights: t.List[t.Tuple[int</span><span class="s0">, </span><span class="s1">int]] = []</span>
        <span class="s1">final = </span><span class="s0">False</span>

        <span class="s1">pos = </span><span class="s5">0</span>
        <span class="s0">while </span><span class="s1">pos &lt; len(rule):</span>
            <span class="s1">match = _part_re.match(rule</span><span class="s0">, </span><span class="s1">pos)</span>
            <span class="s0">if </span><span class="s1">match </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;malformed url rule: </span><span class="s0">{</span><span class="s1">rule</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

            <span class="s1">data = match.groupdict()</span>
            <span class="s0">if </span><span class="s1">data[</span><span class="s3">&quot;static&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">static_weights.append((len(static_weights)</span><span class="s0">, </span><span class="s1">-len(data[</span><span class="s3">&quot;static&quot;</span><span class="s1">])))</span>
                <span class="s1">self._trace.append((</span><span class="s0">False, </span><span class="s1">data[</span><span class="s3">&quot;static&quot;</span><span class="s1">]))</span>
                <span class="s1">content += data[</span><span class="s3">&quot;static&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">static </span><span class="s0">else </span><span class="s1">re.escape(data[</span><span class="s3">&quot;static&quot;</span><span class="s1">])</span>

            <span class="s0">if </span><span class="s1">data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">static:</span>
                    <span class="s4"># Switching content to represent regex, hence the need to escape</span>
                    <span class="s1">content = re.escape(content)</span>
                <span class="s1">static = </span><span class="s0">False</span>
                <span class="s1">c_args</span><span class="s0">, </span><span class="s1">c_kwargs = parse_converter_args(data[</span><span class="s3">&quot;arguments&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">convobj = self.get_converter(</span>
                    <span class="s1">data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data[</span><span class="s3">&quot;converter&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s3">&quot;default&quot;</span><span class="s0">, </span><span class="s1">c_args</span><span class="s0">, </span><span class="s1">c_kwargs</span>
                <span class="s1">)</span>
                <span class="s1">self._converters[data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">]] = convobj</span>
                <span class="s1">self.arguments.add(data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">])</span>
                <span class="s0">if not </span><span class="s1">convobj.part_isolating:</span>
                    <span class="s1">final = </span><span class="s0">True</span>
                <span class="s1">content += </span><span class="s3">f&quot;(</span><span class="s0">{</span><span class="s1">convobj.regex</span><span class="s0">}</span><span class="s3">)&quot;</span>
                <span class="s1">argument_weights.append(convobj.weight)</span>
                <span class="s1">self._trace.append((</span><span class="s0">True, </span><span class="s1">data[</span><span class="s3">&quot;variable&quot;</span><span class="s1">]))</span>

            <span class="s0">if </span><span class="s1">data[</span><span class="s3">&quot;slash&quot;</span><span class="s1">] </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self._trace.append((</span><span class="s0">False, </span><span class="s3">&quot;/&quot;</span><span class="s1">))</span>
                <span class="s0">if </span><span class="s1">final:</span>
                    <span class="s1">content += </span><span class="s3">&quot;/&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">if not </span><span class="s1">static:</span>
                        <span class="s1">content += </span><span class="s3">r&quot;\Z&quot;</span>
                    <span class="s1">weight = Weighting(</span>
                        <span class="s1">-len(static_weights)</span><span class="s0">,</span>
                        <span class="s1">static_weights</span><span class="s0">,</span>
                        <span class="s1">-len(argument_weights)</span><span class="s0">,</span>
                        <span class="s1">argument_weights</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s0">yield </span><span class="s1">RulePart(</span>
                        <span class="s1">content=content</span><span class="s0">,</span>
                        <span class="s1">final=final</span><span class="s0">,</span>
                        <span class="s1">static=static</span><span class="s0">,</span>
                        <span class="s1">suffixed=</span><span class="s0">False,</span>
                        <span class="s1">weight=weight</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s1">content = </span><span class="s3">&quot;&quot;</span>
                    <span class="s1">static = </span><span class="s0">True</span>
                    <span class="s1">argument_weights = []</span>
                    <span class="s1">static_weights = []</span>
                    <span class="s1">final = </span><span class="s0">False</span>

            <span class="s1">pos = match.end()</span>

        <span class="s1">suffixed = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">final </span><span class="s0">and </span><span class="s1">content[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">&quot;/&quot;</span><span class="s1">:</span>
            <span class="s4"># If a converter is part_isolating=False (matches slashes) and ends with a</span>
            <span class="s4"># slash, augment the regex to support slash redirects.</span>
            <span class="s1">suffixed = </span><span class="s0">True</span>
            <span class="s1">content = content[:-</span><span class="s5">1</span><span class="s1">] + </span><span class="s3">&quot;(?&lt;!/)(/?)&quot;</span>
        <span class="s0">if not </span><span class="s1">static:</span>
            <span class="s1">content += </span><span class="s3">r&quot;\Z&quot;</span>
        <span class="s1">weight = Weighting(</span>
            <span class="s1">-len(static_weights)</span><span class="s0">,</span>
            <span class="s1">static_weights</span><span class="s0">,</span>
            <span class="s1">-len(argument_weights)</span><span class="s0">,</span>
            <span class="s1">argument_weights</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">yield </span><span class="s1">RulePart(</span>
            <span class="s1">content=content</span><span class="s0">,</span>
            <span class="s1">final=final</span><span class="s0">,</span>
            <span class="s1">static=static</span><span class="s0">,</span>
            <span class="s1">suffixed=suffixed</span><span class="s0">,</span>
            <span class="s1">weight=weight</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">suffixed:</span>
            <span class="s0">yield </span><span class="s1">RulePart(</span>
                <span class="s1">content=</span><span class="s3">&quot;&quot;</span><span class="s0">, </span><span class="s1">final=</span><span class="s0">False, </span><span class="s1">static=</span><span class="s0">True, </span><span class="s1">suffixed=</span><span class="s0">False, </span><span class="s1">weight=weight</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">compile(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">&quot;&quot;&quot;Compiles the regular expression and stores it.&quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.map </span><span class="s0">is not None, </span><span class="s3">&quot;rule not bound&quot;</span>

        <span class="s0">if </span><span class="s1">self.map.host_matching:</span>
            <span class="s1">domain_rule = self.host </span><span class="s0">or </span><span class="s3">&quot;&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">domain_rule = self.subdomain </span><span class="s0">or </span><span class="s3">&quot;&quot;</span>
        <span class="s1">self._parts = []</span>
        <span class="s1">self._trace = []</span>
        <span class="s1">self._converters = {}</span>
        <span class="s0">if </span><span class="s1">domain_rule == </span><span class="s3">&quot;&quot;</span><span class="s1">:</span>
            <span class="s1">self._parts = [</span>
                <span class="s1">RulePart(</span>
                    <span class="s1">content=</span><span class="s3">&quot;&quot;</span><span class="s0">,</span>
                    <span class="s1">final=</span><span class="s0">False,</span>
                    <span class="s1">static=</span><span class="s0">True,</span>
                    <span class="s1">suffixed=</span><span class="s0">False,</span>
                    <span class="s1">weight=Weighting(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._parts.extend(self._parse_rule(domain_rule))</span>
        <span class="s1">self._trace.append((</span><span class="s0">False, </span><span class="s3">&quot;|&quot;</span><span class="s1">))</span>
        <span class="s1">rule = self.rule</span>
        <span class="s0">if </span><span class="s1">self.merge_slashes:</span>
            <span class="s1">rule = re.sub(</span><span class="s3">&quot;/{2,}?&quot;</span><span class="s0">, </span><span class="s3">&quot;/&quot;</span><span class="s0">, </span><span class="s1">self.rule)</span>
        <span class="s1">self._parts.extend(self._parse_rule(rule))</span>

        <span class="s1">self._build: t.Callable[...</span><span class="s0">, </span><span class="s1">t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]</span>
        <span class="s1">self._build = self._compile_builder(</span><span class="s0">False</span><span class="s1">).__get__(self</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self._build_unknown: t.Callable[...</span><span class="s0">, </span><span class="s1">t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]</span>
        <span class="s1">self._build_unknown = self._compile_builder(</span><span class="s0">True</span><span class="s1">).__get__(self</span><span class="s0">, None</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_get_func_code(code: CodeType</span><span class="s0">, </span><span class="s1">name: str) -&gt; t.Callable[...</span><span class="s0">, </span><span class="s1">t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]:</span>
        <span class="s1">globs: t.Dict[str</span><span class="s0">, </span><span class="s1">t.Any] = {}</span>
        <span class="s1">locs: t.Dict[str</span><span class="s0">, </span><span class="s1">t.Any] = {}</span>
        <span class="s1">exec(code</span><span class="s0">, </span><span class="s1">globs</span><span class="s0">, </span><span class="s1">locs)</span>
        <span class="s0">return </span><span class="s1">locs[name]  </span><span class="s4"># type: ignore</span>

    <span class="s0">def </span><span class="s1">_compile_builder(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">append_unknown: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Callable[...</span><span class="s0">, </span><span class="s1">t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]:</span>
        <span class="s1">defaults = self.defaults </span><span class="s0">or </span><span class="s1">{}</span>
        <span class="s1">dom_ops: t.List[t.Tuple[bool</span><span class="s0">, </span><span class="s1">str]] = []</span>
        <span class="s1">url_ops: t.List[t.Tuple[bool</span><span class="s0">, </span><span class="s1">str]] = []</span>

        <span class="s1">opl = dom_ops</span>
        <span class="s0">for </span><span class="s1">is_dynamic</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">self._trace:</span>
            <span class="s0">if </span><span class="s1">data == </span><span class="s3">&quot;|&quot; </span><span class="s0">and </span><span class="s1">opl </span><span class="s0">is </span><span class="s1">dom_ops:</span>
                <span class="s1">opl = url_ops</span>
                <span class="s0">continue</span>
            <span class="s4"># this seems like a silly case to ever come up but:</span>
            <span class="s4"># if a default is given for a value that appears in the rule,</span>
            <span class="s4"># resolve it to a constant ahead of time</span>
            <span class="s0">if </span><span class="s1">is_dynamic </span><span class="s0">and </span><span class="s1">data </span><span class="s0">in </span><span class="s1">defaults:</span>
                <span class="s1">data = self._converters[data].to_url(defaults[data])</span>
                <span class="s1">opl.append((</span><span class="s0">False, </span><span class="s1">data))</span>
            <span class="s0">elif not </span><span class="s1">is_dynamic:</span>
                <span class="s1">opl.append(</span>
                    <span class="s1">(</span><span class="s0">False, </span><span class="s1">url_quote(_to_bytes(data</span><span class="s0">, </span><span class="s1">self.map.charset)</span><span class="s0">, </span><span class="s1">safe=</span><span class="s3">&quot;/:|+&quot;</span><span class="s1">))</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">opl.append((</span><span class="s0">True, </span><span class="s1">data))</span>

        <span class="s0">def </span><span class="s1">_convert(elem: str) -&gt; ast.stmt:</span>
            <span class="s1">ret = _prefix_names(_CALL_CONVERTER_CODE_FMT.format(elem=elem))</span>
            <span class="s1">ret.args = [ast.Name(str(elem)</span><span class="s0">, </span><span class="s1">ast.Load())]  </span><span class="s4"># type: ignore  # str for py2</span>
            <span class="s0">return </span><span class="s1">ret</span>

        <span class="s0">def </span><span class="s1">_parts(ops: t.List[t.Tuple[bool</span><span class="s0">, </span><span class="s1">str]]) -&gt; t.List[ast.AST]:</span>
            <span class="s1">parts = [</span>
                <span class="s1">_convert(elem) </span><span class="s0">if </span><span class="s1">is_dynamic </span><span class="s0">else </span><span class="s1">ast.Str(s=elem)</span>
                <span class="s0">for </span><span class="s1">is_dynamic</span><span class="s0">, </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">ops</span>
            <span class="s1">]</span>
            <span class="s1">parts = parts </span><span class="s0">or </span><span class="s1">[ast.Str(</span><span class="s3">&quot;&quot;</span><span class="s1">)]</span>
            <span class="s4"># constant fold</span>
            <span class="s1">ret = [parts[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">parts[</span><span class="s5">1</span><span class="s1">:]:</span>
                <span class="s0">if </span><span class="s1">isinstance(p</span><span class="s0">, </span><span class="s1">ast.Str) </span><span class="s0">and </span><span class="s1">isinstance(ret[-</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ast.Str):</span>
                    <span class="s1">ret[-</span><span class="s5">1</span><span class="s1">] = ast.Str(ret[-</span><span class="s5">1</span><span class="s1">].s + p.s)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ret.append(p)</span>
            <span class="s0">return </span><span class="s1">ret</span>

        <span class="s1">dom_parts = _parts(dom_ops)</span>
        <span class="s1">url_parts = _parts(url_ops)</span>
        <span class="s0">if not </span><span class="s1">append_unknown:</span>
            <span class="s1">body = []</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">body = [_IF_KWARGS_URL_ENCODE_AST]</span>
            <span class="s1">url_parts.extend(_URL_ENCODE_AST_NAMES)</span>

        <span class="s0">def </span><span class="s1">_join(parts: t.List[ast.AST]) -&gt; ast.AST:</span>
            <span class="s0">if </span><span class="s1">len(parts) == </span><span class="s5">1</span><span class="s1">:  </span><span class="s4"># shortcut</span>
                <span class="s0">return </span><span class="s1">parts[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">ast.JoinedStr(parts)</span>

        <span class="s1">body.append(</span>
            <span class="s1">ast.Return(ast.Tuple([_join(dom_parts)</span><span class="s0">, </span><span class="s1">_join(url_parts)]</span><span class="s0">, </span><span class="s1">ast.Load()))</span>
        <span class="s1">)</span>

        <span class="s1">pargs = [</span>
            <span class="s1">elem</span>
            <span class="s0">for </span><span class="s1">is_dynamic</span><span class="s0">, </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">dom_ops + url_ops</span>
            <span class="s0">if </span><span class="s1">is_dynamic </span><span class="s0">and </span><span class="s1">elem </span><span class="s0">not in </span><span class="s1">defaults</span>
        <span class="s1">]</span>
        <span class="s1">kargs = [str(k) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">defaults]</span>

        <span class="s1">func_ast: ast.FunctionDef = _prefix_names(</span><span class="s3">&quot;def _(): pass&quot;</span><span class="s1">)  </span><span class="s4"># type: ignore</span>
        <span class="s1">func_ast.name = </span><span class="s3">f&quot;&lt;builder:</span><span class="s0">{</span><span class="s1">self.rule</span><span class="s0">!r}</span><span class="s3">&gt;&quot;</span>
        <span class="s1">func_ast.args.args.append(ast.arg(</span><span class="s3">&quot;.self&quot;</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">pargs + kargs:</span>
            <span class="s1">func_ast.args.args.append(ast.arg(arg</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s1">func_ast.args.kwarg = ast.arg(</span><span class="s3">&quot;.kwargs&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">kargs:</span>
            <span class="s1">func_ast.args.defaults.append(ast.Str(</span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
        <span class="s1">func_ast.body = body</span>

        <span class="s4"># use `ast.parse` instead of `ast.Module` for better portability</span>
        <span class="s4"># Python 3.8 changes the signature of `ast.Module`</span>
        <span class="s1">module = ast.parse(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">module.body = [func_ast]</span>

        <span class="s4"># mark everything as on line 1, offset 0</span>
        <span class="s4"># less error-prone than `ast.fix_missing_locations`</span>
        <span class="s4"># bad line numbers cause an assert to fail in debug builds</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">ast.walk(module):</span>
            <span class="s0">if </span><span class="s3">&quot;lineno&quot; </span><span class="s0">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.lineno = </span><span class="s5">1</span>
            <span class="s0">if </span><span class="s3">&quot;end_lineno&quot; </span><span class="s0">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.end_lineno = node.lineno  </span><span class="s4"># type: ignore[attr-defined]</span>
            <span class="s0">if </span><span class="s3">&quot;col_offset&quot; </span><span class="s0">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.col_offset = </span><span class="s5">0</span>
            <span class="s0">if </span><span class="s3">&quot;end_col_offset&quot; </span><span class="s0">in </span><span class="s1">node._attributes:</span>
                <span class="s1">node.end_col_offset = node.col_offset  </span><span class="s4"># type: ignore[attr-defined]</span>

        <span class="s1">code = compile(module</span><span class="s0">, </span><span class="s3">&quot;&lt;werkzeug routing&gt;&quot;</span><span class="s0">, </span><span class="s3">&quot;exec&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._get_func_code(code</span><span class="s0">, </span><span class="s1">func_ast.name)</span>

    <span class="s0">def </span><span class="s1">build(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">values: t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]</span><span class="s0">, </span><span class="s1">append_unknown: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; t.Optional[t.Tuple[str</span><span class="s0">, </span><span class="s1">str]]:</span>
        <span class="s2">&quot;&quot;&quot;Assembles the relative url for that rule and the subdomain. 
        If building doesn't work for some reasons `None` is returned. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">append_unknown:</span>
                <span class="s0">return </span><span class="s1">self._build_unknown(**values)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self._build(**values)</span>
        <span class="s0">except </span><span class="s1">ValidationError:</span>
            <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">provides_defaults_for(self</span><span class="s0">, </span><span class="s1">rule: </span><span class="s3">&quot;Rule&quot;</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Check if this rule has defaults for a given rule. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(</span>
            <span class="s0">not </span><span class="s1">self.build_only</span>
            <span class="s0">and </span><span class="s1">self.defaults</span>
            <span class="s0">and </span><span class="s1">self.endpoint == rule.endpoint</span>
            <span class="s0">and </span><span class="s1">self != rule</span>
            <span class="s0">and </span><span class="s1">self.arguments == rule.arguments</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">suitable_for(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">values: t.Mapping[str</span><span class="s0">, </span><span class="s1">t.Any]</span><span class="s0">, </span><span class="s1">method: t.Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; bool:</span>
        <span class="s2">&quot;&quot;&quot;Check if the dict of values has enough data for url generation. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s4"># if a method was given explicitly and that method is not supported</span>
        <span class="s4"># by this rule, this rule is not suitable.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">method </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">self.methods </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">self.methods</span>
        <span class="s1">):</span>
            <span class="s0">return False</span>

        <span class="s1">defaults = self.defaults </span><span class="s0">or </span><span class="s1">()</span>

        <span class="s4"># all arguments required must be either in the defaults dict or</span>
        <span class="s4"># the value dictionary otherwise it's not suitable</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.arguments:</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">defaults </span><span class="s0">and </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">values:</span>
                <span class="s0">return False</span>

        <span class="s4"># in case defaults are given we ensure that either the value was</span>
        <span class="s4"># skipped or the value is the same as the default value.</span>
        <span class="s0">if </span><span class="s1">defaults:</span>
            <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">defaults.items():</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">values </span><span class="s0">and </span><span class="s1">value != values[key]:</span>
                    <span class="s0">return False</span>

        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">build_compare_key(self) -&gt; t.Tuple[int</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s2">&quot;&quot;&quot;The build compare key for sorting. 
 
        :internal: 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s5">1 </span><span class="s0">if </span><span class="s1">self.alias </span><span class="s0">else </span><span class="s5">0</span><span class="s0">, </span><span class="s1">-len(self.arguments)</span><span class="s0">, </span><span class="s1">-len(self.defaults </span><span class="s0">or </span><span class="s1">()))</span>

    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other: object) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">type(self)) </span><span class="s0">and </span><span class="s1">self._trace == other._trace</span>

    <span class="s1">__hash__ = </span><span class="s0">None  </span><span class="s4"># type: ignore</span>

    <span class="s0">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s1">self.rule</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">if </span><span class="s1">self.map </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s3">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} </span><span class="s3">(unbound)&gt;&quot;</span>
        <span class="s1">parts = []</span>
        <span class="s0">for </span><span class="s1">is_dynamic</span><span class="s0">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">self._trace:</span>
            <span class="s0">if </span><span class="s1">is_dynamic:</span>
                <span class="s1">parts.append(</span><span class="s3">f&quot;&lt;</span><span class="s0">{</span><span class="s1">data</span><span class="s0">}</span><span class="s3">&gt;&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">parts.append(data)</span>
        <span class="s1">parts = </span><span class="s3">&quot;&quot;</span><span class="s1">.join(parts).lstrip(</span><span class="s3">&quot;|&quot;</span><span class="s1">)</span>
        <span class="s1">methods = </span><span class="s3">f&quot; (</span><span class="s0">{</span><span class="s3">', '</span><span class="s1">.join(self.methods)</span><span class="s0">}</span><span class="s3">)&quot; </span><span class="s0">if </span><span class="s1">self.methods </span><span class="s0">is not None else </span><span class="s3">&quot;&quot;</span>
        <span class="s0">return </span><span class="s3">f&quot;&lt;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} {</span><span class="s1">parts</span><span class="s0">!r}{</span><span class="s1">methods</span><span class="s0">} </span><span class="s3">-&gt; </span><span class="s0">{</span><span class="s1">self.endpoint</span><span class="s0">}</span><span class="s3">&gt;&quot;</span>
</pre>
</body>
</html>