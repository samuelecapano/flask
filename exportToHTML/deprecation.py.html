<html>
<head>
<title>deprecation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
deprecation.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Helper functions for deprecating parts of the Matplotlib API. 
 
This documentation is only relevant for Matplotlib developers, not for users. 
 
.. warning:: 
 
    This module is for internal use only.  Do not use it in your own code. 
    We may change the API at any time with no warning. 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">warnings</span>


<span class="s2">class </span><span class="s1">MatplotlibDeprecationWarning(DeprecationWarning):</span>
    <span class="s0">&quot;&quot;&quot;A class for issuing deprecation warnings for Matplotlib users.&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">_generate_deprecation_warning(</span>
        <span class="s1">since</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">False, </span><span class="s1">obj_type=</span><span class="s3">''</span><span class="s2">,</span>
        <span class="s1">addendum=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">''</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">pending:</span>
        <span class="s2">if </span><span class="s1">removal:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;A pending deprecation cannot have a scheduled removal&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">removal = </span><span class="s3">f&quot;in </span><span class="s2">{</span><span class="s1">removal</span><span class="s2">}</span><span class="s3">&quot; </span><span class="s2">if </span><span class="s1">removal </span><span class="s2">else </span><span class="s3">&quot;two minor releases later&quot;</span>
    <span class="s2">if not </span><span class="s1">message:</span>
        <span class="s1">message = (</span>
            <span class="s1">(</span><span class="s3">&quot;The %(name)s %(obj_type)s&quot; </span><span class="s2">if </span><span class="s1">obj_type </span><span class="s2">else </span><span class="s3">&quot;%(name)s&quot;</span><span class="s1">)</span>
            <span class="s1">+ (</span><span class="s3">&quot; will be deprecated in a future version&quot;</span>
               <span class="s2">if </span><span class="s1">pending </span><span class="s2">else</span>
               <span class="s1">(</span><span class="s3">&quot; was deprecated in Matplotlib %(since)s&quot;</span>
                <span class="s1">+ (</span><span class="s3">&quot; and will be removed %(removal)s&quot; </span><span class="s2">if </span><span class="s1">removal </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)))</span>
            <span class="s1">+ </span><span class="s3">&quot;.&quot;</span>
            <span class="s1">+ (</span><span class="s3">&quot; Use %(alternative)s instead.&quot; </span><span class="s2">if </span><span class="s1">alternative </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">+ (</span><span class="s3">&quot; %(addendum)s&quot; </span><span class="s2">if </span><span class="s1">addendum </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
    <span class="s1">warning_cls = (PendingDeprecationWarning </span><span class="s2">if </span><span class="s1">pending</span>
                   <span class="s2">else </span><span class="s1">MatplotlibDeprecationWarning)</span>
    <span class="s2">return </span><span class="s1">warning_cls(message % dict(</span>
        <span class="s1">func=name</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">obj_type=obj_type</span><span class="s2">, </span><span class="s1">since=since</span><span class="s2">, </span><span class="s1">removal=removal</span><span class="s2">,</span>
        <span class="s1">alternative=alternative</span><span class="s2">, </span><span class="s1">addendum=addendum))</span>


<span class="s2">def </span><span class="s1">warn_deprecated(</span>
        <span class="s1">since</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">False,</span>
        <span class="s1">obj_type=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">addendum=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">''</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Display a standardized deprecation. 
 
    Parameters 
    ---------- 
    since : str 
        The release at which this API became deprecated. 
    message : str, optional 
        Override the default deprecation message.  The ``%(since)s``, 
        ``%(name)s``, ``%(alternative)s``, ``%(obj_type)s``, ``%(addendum)s``, 
        and ``%(removal)s`` format specifiers will be replaced by the values 
        of the respective arguments passed to this function. 
    name : str, optional 
        The name of the deprecated object. 
    alternative : str, optional 
        An alternative API that the user may use in place of the deprecated 
        API.  The deprecation warning will tell the user about this alternative 
        if provided. 
    pending : bool, optional 
        If True, uses a PendingDeprecationWarning instead of a 
        DeprecationWarning.  Cannot be used together with *removal*. 
    obj_type : str, optional 
        The object type being deprecated. 
    addendum : str, optional 
        Additional text appended directly to the final message. 
    removal : str, optional 
        The expected removal version.  With the default (an empty string), a 
        removal version is automatically computed from *since*.  Set to other 
        Falsy values to not schedule a removal date.  Cannot be used together 
        with *pending*. 
 
    Examples 
    -------- 
    :: 
 
        # To warn of the deprecation of &quot;matplotlib.name_of_module&quot; 
        warn_deprecated('1.4.0', name='matplotlib.name_of_module', 
                        obj_type='module') 
    &quot;&quot;&quot;</span>
    <span class="s1">warning = _generate_deprecation_warning(</span>
        <span class="s1">since</span><span class="s2">, </span><span class="s1">message</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">alternative</span><span class="s2">, </span><span class="s1">pending</span><span class="s2">, </span><span class="s1">obj_type</span><span class="s2">, </span><span class="s1">addendum</span><span class="s2">,</span>
        <span class="s1">removal=removal)</span>
    <span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">warn_external</span>
    <span class="s1">warn_external(warning</span><span class="s2">, </span><span class="s1">category=MatplotlibDeprecationWarning)</span>


<span class="s2">def </span><span class="s1">deprecated(since</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">False,</span>
               <span class="s1">obj_type=</span><span class="s2">None, </span><span class="s1">addendum=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">removal=</span><span class="s3">''</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator to mark a function, a class, or a property as deprecated. 
 
    When deprecating a classmethod, a staticmethod, or a property, the 
    ``@deprecated`` decorator should go *under* ``@classmethod`` and 
    ``@staticmethod`` (i.e., `deprecated` should directly decorate the 
    underlying callable), but *over* ``@property``. 
 
    When deprecating a class ``C`` intended to be used as a base class in a 
    multiple inheritance hierarchy, ``C`` *must* define an ``__init__`` method 
    (if ``C`` instead inherited its ``__init__`` from its own base class, then 
    ``@deprecated`` would mess up ``__init__`` inheritance when installing its 
    own (deprecation-emitting) ``C.__init__``). 
 
    Parameters are the same as for `warn_deprecated`, except that *obj_type* 
    defaults to 'class' if decorating a class, 'attribute' if decorating a 
    property, and 'function' otherwise. 
 
    Examples 
    -------- 
    :: 
 
        @deprecated('1.4.0') 
        def the_function_to_deprecate(): 
            pass 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">deprecate(obj</span><span class="s2">, </span><span class="s1">message=message</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">alternative=alternative</span><span class="s2">,</span>
                  <span class="s1">pending=pending</span><span class="s2">, </span><span class="s1">obj_type=obj_type</span><span class="s2">, </span><span class="s1">addendum=addendum):</span>
        <span class="s2">from </span><span class="s1">matplotlib._api </span><span class="s2">import </span><span class="s1">classproperty</span>

        <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">type):</span>
            <span class="s2">if </span><span class="s1">obj_type </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">obj_type = </span><span class="s3">&quot;class&quot;</span>
            <span class="s1">func = obj.__init__</span>
            <span class="s1">name = name </span><span class="s2">or </span><span class="s1">obj.__name__</span>
            <span class="s1">old_doc = obj.__doc__</span>

            <span class="s2">def </span><span class="s1">finalize(wrapper</span><span class="s2">, </span><span class="s1">new_doc):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">obj.__doc__ = new_doc</span>
                <span class="s2">except </span><span class="s1">AttributeError:  </span><span class="s4"># Can't set on some extension objects.</span>
                    <span class="s2">pass</span>
                <span class="s1">obj.__init__ = functools.wraps(obj.__init__)(wrapper)</span>
                <span class="s2">return </span><span class="s1">obj</span>

        <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(property</span><span class="s2">, </span><span class="s1">classproperty)):</span>
            <span class="s2">if </span><span class="s1">obj_type </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">obj_type = </span><span class="s3">&quot;attribute&quot;</span>
            <span class="s1">func = </span><span class="s2">None</span>
            <span class="s1">name = name </span><span class="s2">or </span><span class="s1">obj.fget.__name__</span>
            <span class="s1">old_doc = obj.__doc__</span>

            <span class="s2">class </span><span class="s1">_deprecated_property(type(obj)):</span>
                <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">owner=</span><span class="s2">None</span><span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">instance </span><span class="s2">is not None or </span><span class="s1">owner </span><span class="s2">is not None </span><span class="s1">\</span>
                            <span class="s2">and </span><span class="s1">isinstance(self</span><span class="s2">, </span><span class="s1">classproperty):</span>
                        <span class="s1">emit_warning()</span>
                    <span class="s2">return </span><span class="s1">super().__get__(instance</span><span class="s2">, </span><span class="s1">owner)</span>

                <span class="s2">def </span><span class="s1">__set__(self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">value):</span>
                    <span class="s2">if </span><span class="s1">instance </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">emit_warning()</span>
                    <span class="s2">return </span><span class="s1">super().__set__(instance</span><span class="s2">, </span><span class="s1">value)</span>

                <span class="s2">def </span><span class="s1">__delete__(self</span><span class="s2">, </span><span class="s1">instance):</span>
                    <span class="s2">if </span><span class="s1">instance </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">emit_warning()</span>
                    <span class="s2">return </span><span class="s1">super().__delete__(instance)</span>

                <span class="s2">def </span><span class="s1">__set_name__(self</span><span class="s2">, </span><span class="s1">owner</span><span class="s2">, </span><span class="s1">set_name):</span>
                    <span class="s2">nonlocal </span><span class="s1">name</span>
                    <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;&lt;lambda&gt;&quot;</span><span class="s1">:</span>
                        <span class="s1">name = set_name</span>

            <span class="s2">def </span><span class="s1">finalize(_</span><span class="s2">, </span><span class="s1">new_doc):</span>
                <span class="s2">return </span><span class="s1">_deprecated_property(</span>
                    <span class="s1">fget=obj.fget</span><span class="s2">, </span><span class="s1">fset=obj.fset</span><span class="s2">, </span><span class="s1">fdel=obj.fdel</span><span class="s2">, </span><span class="s1">doc=new_doc)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">obj_type </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">obj_type = </span><span class="s3">&quot;function&quot;</span>
            <span class="s1">func = obj</span>
            <span class="s1">name = name </span><span class="s2">or </span><span class="s1">obj.__name__</span>
            <span class="s1">old_doc = func.__doc__</span>

            <span class="s2">def </span><span class="s1">finalize(wrapper</span><span class="s2">, </span><span class="s1">new_doc):</span>
                <span class="s1">wrapper = functools.wraps(func)(wrapper)</span>
                <span class="s1">wrapper.__doc__ = new_doc</span>
                <span class="s2">return </span><span class="s1">wrapper</span>

        <span class="s2">def </span><span class="s1">emit_warning():</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">, </span><span class="s1">message=message</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">alternative=alternative</span><span class="s2">,</span>
                <span class="s1">pending=pending</span><span class="s2">, </span><span class="s1">obj_type=obj_type</span><span class="s2">, </span><span class="s1">addendum=addendum</span><span class="s2">,</span>
                <span class="s1">removal=removal)</span>

        <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">emit_warning()</span>
            <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">old_doc = inspect.cleandoc(old_doc </span><span class="s2">or </span><span class="s3">''</span><span class="s1">).strip(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s1">notes_header = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">Notes</span><span class="s2">\n</span><span class="s3">-----'</span>
        <span class="s1">second_arg = </span><span class="s3">' '</span><span class="s1">.join([t.strip() </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in</span>
                               <span class="s1">(message</span><span class="s2">, </span><span class="s3">f&quot;Use </span><span class="s2">{</span><span class="s1">alternative</span><span class="s2">} </span><span class="s3">instead.&quot;</span>
                                <span class="s2">if </span><span class="s1">alternative </span><span class="s2">else </span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">addendum) </span><span class="s2">if </span><span class="s1">t])</span>
        <span class="s1">new_doc = (</span><span class="s3">f&quot;[*Deprecated*] </span><span class="s2">{</span><span class="s1">old_doc</span><span class="s2">}\n</span><span class="s3">&quot;</span>
                   <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">notes_header </span><span class="s2">if </span><span class="s1">notes_header </span><span class="s2">not in </span><span class="s1">old_doc </span><span class="s2">else </span><span class="s3">''</span><span class="s2">}\n</span><span class="s3">&quot;</span>
                   <span class="s3">f&quot;.. deprecated:: </span><span class="s2">{</span><span class="s1">since</span><span class="s2">}\n</span><span class="s3">&quot;</span>
                   <span class="s3">f&quot;   </span><span class="s2">{</span><span class="s1">second_arg</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">old_doc:</span>
            <span class="s4"># This is to prevent a spurious 'unexpected unindent' warning from</span>
            <span class="s4"># docutils when the original docstring was blank.</span>
            <span class="s1">new_doc += </span><span class="s3">r'\ '</span>

        <span class="s2">return </span><span class="s1">finalize(wrapper</span><span class="s2">, </span><span class="s1">new_doc)</span>

    <span class="s2">return </span><span class="s1">deprecate</span>


<span class="s2">class </span><span class="s1">deprecate_privatize_attribute:</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper to deprecate public access to an attribute (or method). 
 
    This helper should only be used at class scope, as follows:: 
 
        class Foo: 
            attr = _deprecate_privatize_attribute(*args, **kwargs) 
 
    where *all* parameters are forwarded to `deprecated`.  This form makes 
    ``attr`` a property which forwards read and write access to ``self._attr`` 
    (same name but with a leading underscore), with a deprecation warning. 
    Note that the attribute name is derived from *the name this helper is 
    assigned to*.  This helper also works for deprecating methods. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.deprecator = deprecated(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">__set_name__(self</span><span class="s2">, </span><span class="s1">owner</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">setattr(owner</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">self.deprecator(</span>
            <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: getattr(self</span><span class="s2">, </span><span class="s3">f&quot;_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">value: setattr(self</span><span class="s2">, </span><span class="s3">f&quot;_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">value))</span><span class="s2">,</span>
            <span class="s1">name=name))</span>


<span class="s4"># Used by _copy_docstring_and_deprecators to redecorate pyplot wrappers and</span>
<span class="s4"># boilerplate.py to retrieve original signatures.  It may seem natural to store</span>
<span class="s4"># this information as an attribute on the wrapper, but if the wrapper gets</span>
<span class="s4"># itself functools.wraps()ed, then such attributes are silently propagated to</span>
<span class="s4"># the outer wrapper, which is not desired.</span>
<span class="s1">DECORATORS = {}</span>


<span class="s2">def </span><span class="s1">rename_parameter(since</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator indicating that parameter *old* of *func* is renamed to *new*. 
 
    The actual implementation of *func* should use *new*, not *old*.  If *old* 
    is passed to *func*, a DeprecationWarning is emitted, and its value is 
    used, even if *new* is also passed by keyword (this is to simplify pyplot 
    wrapper functions, which always pass *new* explicitly to the Axes method). 
    If *new* is also passed but positionally, a TypeError will be raised by the 
    underlying function during argument binding. 
 
    Examples 
    -------- 
    :: 
 
        @_api.rename_parameter(&quot;3.1&quot;, &quot;bad_name&quot;, &quot;good_name&quot;) 
        def func(good_name): ... 
    &quot;&quot;&quot;</span>

    <span class="s1">decorator = functools.partial(rename_parameter</span><span class="s2">, </span><span class="s1">since</span><span class="s2">, </span><span class="s1">old</span><span class="s2">, </span><span class="s1">new)</span>

    <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">signature = inspect.signature(func)</span>
    <span class="s2">assert </span><span class="s1">old </span><span class="s2">not in </span><span class="s1">signature.parameters</span><span class="s2">, </span><span class="s1">(</span>
        <span class="s3">f&quot;Matplotlib internal error: </span><span class="s2">{</span><span class="s1">old</span><span class="s2">!r} </span><span class="s3">cannot be a parameter for &quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">new </span><span class="s2">in </span><span class="s1">signature.parameters</span><span class="s2">, </span><span class="s1">(</span>
        <span class="s3">f&quot;Matplotlib internal error: </span><span class="s2">{</span><span class="s1">new</span><span class="s2">!r} </span><span class="s3">must be a parameter for &quot;</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s1">)</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">old </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">f&quot;The </span><span class="s2">{</span><span class="s1">old</span><span class="s2">!r} </span><span class="s3">parameter of </span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">() &quot;</span>
                <span class="s3">f&quot;has been renamed </span><span class="s2">{</span><span class="s1">new</span><span class="s2">!r} </span><span class="s3">since Matplotlib </span><span class="s2">{</span><span class="s1">since</span><span class="s2">}</span><span class="s3">; support &quot;</span>
                <span class="s3">f&quot;for the old name will be dropped %(removal)s.&quot;</span><span class="s1">)</span>
            <span class="s1">kwargs[new] = kwargs.pop(old)</span>
        <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s4"># wrapper() must keep the same documented signature as func(): if we</span>
    <span class="s4"># instead made both *old* and *new* appear in wrapper()'s signature, they</span>
    <span class="s4"># would both show up in the pyplot function for an Axes method as well and</span>
    <span class="s4"># pyplot would explicitly pass both arguments to the Axes method.</span>

    <span class="s1">DECORATORS[wrapper] = decorator</span>
    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">class </span><span class="s1">_deprecated_parameter_class:</span>
    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;deprecated parameter&gt;&quot;</span>


<span class="s1">_deprecated_parameter = _deprecated_parameter_class()</span>


<span class="s2">def </span><span class="s1">delete_parameter(since</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator indicating that parameter *name* of *func* is being deprecated. 
 
    The actual implementation of *func* should keep the *name* parameter in its 
    signature, or accept a ``**kwargs`` argument (through which *name* would be 
    passed). 
 
    Parameters that come after the deprecated parameter effectively become 
    keyword-only (as they cannot be passed positionally without triggering the 
    DeprecationWarning on the deprecated parameter), and should be marked as 
    such after the deprecation period has passed and the deprecated parameter 
    is removed. 
 
    Parameters other than *since*, *name*, and *func* are keyword-only and 
    forwarded to `.warn_deprecated`. 
 
    Examples 
    -------- 
    :: 
 
        @_api.delete_parameter(&quot;3.1&quot;, &quot;unused&quot;) 
        def func(used_arg, other_arg, unused, more_args): ... 
    &quot;&quot;&quot;</span>

    <span class="s1">decorator = functools.partial(delete_parameter</span><span class="s2">, </span><span class="s1">since</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">signature = inspect.signature(func)</span>
    <span class="s4"># Name of `**kwargs` parameter of the decorated function, typically</span>
    <span class="s4"># &quot;kwargs&quot; if such a parameter exists, or None if the decorated function</span>
    <span class="s4"># doesn't accept `**kwargs`.</span>
    <span class="s1">kwargs_name = next((param.name </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">signature.parameters.values()</span>
                        <span class="s2">if </span><span class="s1">param.kind == inspect.Parameter.VAR_KEYWORD)</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">signature.parameters:</span>
        <span class="s1">kind = signature.parameters[name].kind</span>
        <span class="s1">is_varargs = kind </span><span class="s2">is </span><span class="s1">inspect.Parameter.VAR_POSITIONAL</span>
        <span class="s1">is_varkwargs = kind </span><span class="s2">is </span><span class="s1">inspect.Parameter.VAR_KEYWORD</span>
        <span class="s2">if not </span><span class="s1">is_varargs </span><span class="s2">and not </span><span class="s1">is_varkwargs:</span>
            <span class="s1">name_idx = (</span>
                <span class="s4"># Deprecated parameter can't be passed positionally.</span>
                <span class="s1">math.inf </span><span class="s2">if </span><span class="s1">kind </span><span class="s2">is </span><span class="s1">inspect.Parameter.KEYWORD_ONLY</span>
                <span class="s4"># If call site has no more than this number of parameters, the</span>
                <span class="s4"># deprecated parameter can't have been passed positionally.</span>
                <span class="s2">else </span><span class="s1">[*signature.parameters].index(name))</span>
            <span class="s1">func.__signature__ = signature = signature.replace(parameters=[</span>
                <span class="s1">param.replace(default=_deprecated_parameter)</span>
                <span class="s2">if </span><span class="s1">param.name == name </span><span class="s2">else </span><span class="s1">param</span>
                <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">signature.parameters.values()])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name_idx = -</span><span class="s5">1  </span><span class="s4"># Deprecated parameter can always have been passed.</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">is_varargs = is_varkwargs = </span><span class="s2">False</span>
        <span class="s4"># Deprecated parameter can't be passed positionally.</span>
        <span class="s1">name_idx = math.inf</span>
        <span class="s2">assert </span><span class="s1">kwargs_name</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s3">f&quot;Matplotlib internal error: </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s3">must be a parameter for &quot;</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s1">)</span>

    <span class="s1">addendum = kwargs.pop(</span><span class="s3">'addendum'</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s2">def </span><span class="s1">wrapper(*inner_args</span><span class="s2">, </span><span class="s1">**inner_kwargs):</span>
        <span class="s2">if </span><span class="s1">len(inner_args) &lt;= name_idx </span><span class="s2">and </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">inner_kwargs:</span>
            <span class="s4"># Early return in the simple, non-deprecated case (much faster than</span>
            <span class="s4"># calling bind()).</span>
            <span class="s2">return </span><span class="s1">func(*inner_args</span><span class="s2">, </span><span class="s1">**inner_kwargs)</span>
        <span class="s1">arguments = signature.bind(*inner_args</span><span class="s2">, </span><span class="s1">**inner_kwargs).arguments</span>
        <span class="s2">if </span><span class="s1">is_varargs </span><span class="s2">and </span><span class="s1">arguments.get(name):</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">f&quot;Additional positional arguments to &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">() are deprecated since %(since)s and &quot;</span>
                <span class="s3">f&quot;support for them will be removed %(removal)s.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">is_varkwargs </span><span class="s2">and </span><span class="s1">arguments.get(name):</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">f&quot;Additional keyword arguments to &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">() are deprecated since %(since)s and &quot;</span>
                <span class="s3">f&quot;support for them will be removed %(removal)s.&quot;</span><span class="s1">)</span>
        <span class="s4"># We cannot just check `name not in arguments` because the pyplot</span>
        <span class="s4"># wrappers always pass all arguments explicitly.</span>
        <span class="s2">elif </span><span class="s1">any(name </span><span class="s2">in </span><span class="s1">d </span><span class="s2">and </span><span class="s1">d[name] != _deprecated_parameter</span>
                 <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">[arguments</span><span class="s2">, </span><span class="s1">arguments.get(kwargs_name</span><span class="s2">, </span><span class="s1">{})]):</span>
            <span class="s1">deprecation_addendum = (</span>
                <span class="s3">f&quot;If any parameter follows </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r}</span><span class="s3">, they should be passed as &quot;</span>
                <span class="s3">f&quot;keyword, not positionally.&quot;</span><span class="s1">)</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">,</span>
                <span class="s1">name=repr(name)</span><span class="s2">,</span>
                <span class="s1">obj_type=</span><span class="s3">f&quot;parameter of </span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s2">,</span>
                <span class="s1">addendum=(addendum + </span><span class="s3">&quot; &quot; </span><span class="s1">+ deprecation_addendum) </span><span class="s2">if </span><span class="s1">addendum</span>
                         <span class="s2">else </span><span class="s1">deprecation_addendum</span><span class="s2">,</span>
                <span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">func(*inner_args</span><span class="s2">, </span><span class="s1">**inner_kwargs)</span>

    <span class="s1">DECORATORS[wrapper] = decorator</span>
    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">def </span><span class="s1">make_keyword_only(since</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Decorator indicating that passing parameter *name* (or any of the following 
    ones) positionally to *func* is being deprecated. 
 
    When used on a method that has a pyplot wrapper, this should be the 
    outermost decorator, so that :file:`boilerplate.py` can access the original 
    signature. 
    &quot;&quot;&quot;</span>

    <span class="s1">decorator = functools.partial(make_keyword_only</span><span class="s2">, </span><span class="s1">since</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">decorator</span>

    <span class="s1">signature = inspect.signature(func)</span>
    <span class="s1">POK = inspect.Parameter.POSITIONAL_OR_KEYWORD</span>
    <span class="s1">KWO = inspect.Parameter.KEYWORD_ONLY</span>
    <span class="s2">assert </span><span class="s1">(name </span><span class="s2">in </span><span class="s1">signature.parameters</span>
            <span class="s2">and </span><span class="s1">signature.parameters[name].kind == POK)</span><span class="s2">, </span><span class="s1">(</span>
        <span class="s3">f&quot;Matplotlib internal error: </span><span class="s2">{</span><span class="s1">name</span><span class="s2">!r} </span><span class="s3">must be a positional-or-keyword &quot;</span>
        <span class="s3">f&quot;parameter for </span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s1">)</span>
    <span class="s1">names = [*signature.parameters]</span>
    <span class="s1">name_idx = names.index(name)</span>
    <span class="s1">kwonly = [name </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names[name_idx:]</span>
              <span class="s2">if </span><span class="s1">signature.parameters[name].kind == POK]</span>

    <span class="s1">@functools.wraps(func)</span>
    <span class="s2">def </span><span class="s1">wrapper(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Don't use signature.bind here, as it would fail when stacked with</span>
        <span class="s4"># rename_parameter and an &quot;old&quot; argument name is passed in</span>
        <span class="s4"># (signature.bind would fail, but the actual call would succeed).</span>
        <span class="s2">if </span><span class="s1">len(args) &gt; name_idx:</span>
            <span class="s1">warn_deprecated(</span>
                <span class="s1">since</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">&quot;Passing the %(name)s %(obj_type)s &quot;</span>
                <span class="s3">&quot;positionally is deprecated since Matplotlib %(since)s; the &quot;</span>
                <span class="s3">&quot;parameter will become keyword-only %(removal)s.&quot;</span><span class="s2">,</span>
                <span class="s1">name=name</span><span class="s2">, </span><span class="s1">obj_type=</span><span class="s3">f&quot;parameter of </span><span class="s2">{</span><span class="s1">func.__name__</span><span class="s2">}</span><span class="s3">()&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s4"># Don't modify *func*'s signature, as boilerplate.py needs it.</span>
    <span class="s1">wrapper.__signature__ = signature.replace(parameters=[</span>
        <span class="s1">param.replace(kind=KWO) </span><span class="s2">if </span><span class="s1">param.name </span><span class="s2">in </span><span class="s1">kwonly </span><span class="s2">else </span><span class="s1">param</span>
        <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">signature.parameters.values()])</span>
    <span class="s1">DECORATORS[wrapper] = decorator</span>
    <span class="s2">return </span><span class="s1">wrapper</span>


<span class="s2">def </span><span class="s1">deprecate_method_override(method</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">allow_empty=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return ``obj.method`` with a deprecation if it was overridden, else None. 
 
    Parameters 
    ---------- 
    method 
        An unbound method, i.e. an expression of the form 
        ``Class.method_name``.  Remember that within the body of a method, one 
        can always use ``__class__`` to refer to the class that is currently 
        being defined. 
    obj 
        Either an object of the class where *method* is defined, or a subclass 
        of that class. 
    allow_empty : bool, default: False 
        Whether to allow overrides by &quot;empty&quot; methods without emitting a 
        warning. 
    **kwargs 
        Additional parameters passed to `warn_deprecated` to generate the 
        deprecation warning; must at least include the &quot;since&quot; key. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">empty(): </span><span class="s2">pass</span>
    <span class="s2">def </span><span class="s1">empty_with_docstring(): </span><span class="s3">&quot;&quot;&quot;doc&quot;&quot;&quot;</span>

    <span class="s1">name = method.__name__</span>
    <span class="s1">bound_child = getattr(obj</span><span class="s2">, </span><span class="s1">name)</span>
    <span class="s1">bound_base = (</span>
        <span class="s1">method  </span><span class="s4"># If obj is a class, then we need to use unbound methods.</span>
        <span class="s2">if </span><span class="s1">isinstance(bound_child</span><span class="s2">, </span><span class="s1">type(empty)) </span><span class="s2">and </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">type)</span>
        <span class="s2">else </span><span class="s1">method.__get__(obj))</span>
    <span class="s2">if </span><span class="s1">(bound_child != bound_base</span>
            <span class="s2">and </span><span class="s1">(</span><span class="s2">not </span><span class="s1">allow_empty</span>
                 <span class="s2">or </span><span class="s1">(getattr(getattr(bound_child</span><span class="s2">, </span><span class="s3">&quot;__code__&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s3">&quot;co_code&quot;</span><span class="s2">, None</span><span class="s1">)</span>
                     <span class="s2">not in </span><span class="s1">[empty.__code__.co_code</span><span class="s2">,</span>
                             <span class="s1">empty_with_docstring.__code__.co_code]))):</span>
        <span class="s1">warn_deprecated(**{</span><span class="s3">&quot;name&quot;</span><span class="s1">: name</span><span class="s2">, </span><span class="s3">&quot;obj_type&quot;</span><span class="s1">: </span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">**kwargs})</span>
        <span class="s2">return </span><span class="s1">bound_child</span>
    <span class="s2">return None</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">suppress_matplotlib_deprecation_warning():</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">MatplotlibDeprecationWarning)</span>
        <span class="s2">yield</span>
</pre>
</body>
</html>