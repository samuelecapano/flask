<html>
<head>
<title>test_collections.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_collections.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">io</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">from </span><span class="s1">types </span><span class="s0">import </span><span class="s1">SimpleNamespace</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
<span class="s0">import </span><span class="s1">matplotlib.collections </span><span class="s0">as </span><span class="s1">mcollections</span>
<span class="s0">import </span><span class="s1">matplotlib.colors </span><span class="s0">as </span><span class="s1">mcolors</span>
<span class="s0">import </span><span class="s1">matplotlib.path </span><span class="s0">as </span><span class="s1">mpath</span>
<span class="s0">import </span><span class="s1">matplotlib.transforms </span><span class="s0">as </span><span class="s1">mtransforms</span>
<span class="s0">from </span><span class="s1">matplotlib.collections </span><span class="s0">import </span><span class="s1">(Collection</span><span class="s0">, </span><span class="s1">LineCollection</span><span class="s0">,</span>
                                    <span class="s1">EventCollection</span><span class="s0">, </span><span class="s1">PolyCollection)</span>
<span class="s0">from </span><span class="s1">matplotlib.testing.decorators </span><span class="s0">import </span><span class="s1">check_figures_equal</span><span class="s0">, </span><span class="s1">image_comparison</span>


<span class="s0">def </span><span class="s1">generate_EventCollection_plot():</span>
    <span class="s2">&quot;&quot;&quot;Generate the initial collection and plot it.&quot;&quot;&quot;</span>
    <span class="s1">positions = np.array([</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s0">, </span><span class="s3">5.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">13.</span><span class="s0">, </span><span class="s3">21.</span><span class="s1">])</span>
    <span class="s1">extra_positions = np.array([</span><span class="s3">34.</span><span class="s0">, </span><span class="s3">55.</span><span class="s0">, </span><span class="s3">89.</span><span class="s1">])</span>
    <span class="s1">orientation = </span><span class="s4">'horizontal'</span>
    <span class="s1">lineoffset = </span><span class="s3">1</span>
    <span class="s1">linelength = </span><span class="s3">.5</span>
    <span class="s1">linewidth = </span><span class="s3">2</span>
    <span class="s1">color = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">linestyle = </span><span class="s4">'solid'</span>
    <span class="s1">antialiased = </span><span class="s0">True</span>

    <span class="s1">coll = EventCollection(positions</span><span class="s0">,</span>
                           <span class="s1">orientation=orientation</span><span class="s0">,</span>
                           <span class="s1">lineoffset=lineoffset</span><span class="s0">,</span>
                           <span class="s1">linelength=linelength</span><span class="s0">,</span>
                           <span class="s1">linewidth=linewidth</span><span class="s0">,</span>
                           <span class="s1">color=color</span><span class="s0">,</span>
                           <span class="s1">linestyle=linestyle</span><span class="s0">,</span>
                           <span class="s1">antialiased=antialiased</span>
                           <span class="s1">)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.add_collection(coll)</span>
    <span class="s1">ax.set_title(</span><span class="s4">'EventCollection: default'</span><span class="s1">)</span>
    <span class="s1">props = {</span><span class="s4">'positions'</span><span class="s1">: positions</span><span class="s0">,</span>
             <span class="s4">'extra_positions'</span><span class="s1">: extra_positions</span><span class="s0">,</span>
             <span class="s4">'orientation'</span><span class="s1">: orientation</span><span class="s0">,</span>
             <span class="s4">'lineoffset'</span><span class="s1">: lineoffset</span><span class="s0">,</span>
             <span class="s4">'linelength'</span><span class="s1">: linelength</span><span class="s0">,</span>
             <span class="s4">'linewidth'</span><span class="s1">: linewidth</span><span class="s0">,</span>
             <span class="s4">'color'</span><span class="s1">: color</span><span class="s0">,</span>
             <span class="s4">'linestyle'</span><span class="s1">: linestyle</span><span class="s0">,</span>
             <span class="s4">'antialiased'</span><span class="s1">: antialiased</span>
             <span class="s1">}</span>
    <span class="s1">ax.set_xlim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">22</span><span class="s1">)</span>
    <span class="s1">ax.set_ylim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__default'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__get_props():</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s5"># check that the default segments have the correct coordinates</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s5"># check that the default positions match the input positions</span>
    <span class="s1">np.testing.assert_array_equal(props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">coll.get_positions())</span>
    <span class="s5"># check that the default orientation matches the input orientation</span>
    <span class="s0">assert </span><span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">] == coll.get_orientation()</span>
    <span class="s5"># check that the default orientation matches the input orientation</span>
    <span class="s0">assert </span><span class="s1">coll.is_horizontal()</span>
    <span class="s5"># check that the default linelength matches the input linelength</span>
    <span class="s0">assert </span><span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">] == coll.get_linelength()</span>
    <span class="s5"># check that the default lineoffset matches the input lineoffset</span>
    <span class="s0">assert </span><span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">] == coll.get_lineoffset()</span>
    <span class="s5"># check that the default linestyle matches the input linestyle</span>
    <span class="s0">assert </span><span class="s1">coll.get_linestyle() == [(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)]</span>
    <span class="s5"># check that the default color matches the input color</span>
    <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">[coll.get_color()</span><span class="s0">, </span><span class="s1">*coll.get_colors()]:</span>
        <span class="s1">np.testing.assert_array_equal(color</span><span class="s0">, </span><span class="s1">props[</span><span class="s4">'color'</span><span class="s1">])</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__set_positions'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_positions():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_positions = np.hstack([props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">props[</span><span class="s4">'extra_positions'</span><span class="s1">]])</span>
    <span class="s1">coll.set_positions(new_positions)</span>
    <span class="s1">np.testing.assert_array_equal(new_positions</span><span class="s0">, </span><span class="s1">coll.get_positions())</span>
    <span class="s1">check_segments(coll</span><span class="s0">, </span><span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: set_positions'</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">90</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__add_positions'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__add_positions():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_positions = np.hstack([props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">coll.switch_orientation()  </span><span class="s5"># Test adding in the vertical orientation, too.</span>
    <span class="s1">coll.add_positions(props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">coll.switch_orientation()</span>
    <span class="s1">np.testing.assert_array_equal(new_positions</span><span class="s0">, </span><span class="s1">coll.get_positions())</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: add_positions'</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">35</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__append_positions'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__append_positions():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_positions = np.hstack([props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">2</span><span class="s1">]])</span>
    <span class="s1">coll.append_positions(props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">np.testing.assert_array_equal(new_positions</span><span class="s0">, </span><span class="s1">coll.get_positions())</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: append_positions'</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">90</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__extend_positions'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__extend_positions():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_positions = np.hstack([props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]])</span>
    <span class="s1">coll.extend_positions(props[</span><span class="s4">'extra_positions'</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:])</span>
    <span class="s1">np.testing.assert_array_equal(new_positions</span><span class="s0">, </span><span class="s1">coll.get_positions())</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: extend_positions'</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">90</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__switch_orientation'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__switch_orientation():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_orientation = </span><span class="s4">'vertical'</span>
    <span class="s1">coll.switch_orientation()</span>
    <span class="s0">assert </span><span class="s1">new_orientation == coll.get_orientation()</span>
    <span class="s0">assert not </span><span class="s1">coll.is_horizontal()</span>
    <span class="s1">new_positions = coll.get_positions()</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_orientation)</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: switch_orientation'</span><span class="s1">)</span>
    <span class="s1">splt.set_ylim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">22</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__switch_orientation__2x'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__switch_orientation_2x():</span>
    <span class="s2">&quot;&quot;&quot; 
    Check that calling switch_orientation twice sets the orientation back to 
    the default. 
    &quot;&quot;&quot;</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">coll.switch_orientation()</span>
    <span class="s1">coll.switch_orientation()</span>
    <span class="s1">new_positions = coll.get_positions()</span>
    <span class="s0">assert </span><span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">] == coll.get_orientation()</span>
    <span class="s0">assert </span><span class="s1">coll.is_horizontal()</span>
    <span class="s1">np.testing.assert_array_equal(props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">new_positions)</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">new_positions</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: switch_orientation 2x'</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__set_orientation'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_orientation():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_orientation = </span><span class="s4">'vertical'</span>
    <span class="s1">coll.set_orientation(new_orientation)</span>
    <span class="s0">assert </span><span class="s1">new_orientation == coll.get_orientation()</span>
    <span class="s0">assert not </span><span class="s1">coll.is_horizontal()</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">new_orientation)</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: set_orientation'</span><span class="s1">)</span>
    <span class="s1">splt.set_ylim(-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">22</span><span class="s1">)</span>
    <span class="s1">splt.set_xlim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__set_linelength'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_linelength():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_linelength = </span><span class="s3">15</span>
    <span class="s1">coll.set_linelength(new_linelength)</span>
    <span class="s0">assert </span><span class="s1">new_linelength == coll.get_linelength()</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">new_linelength</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'lineoffset'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: set_linelength'</span><span class="s1">)</span>
    <span class="s1">splt.set_ylim(-</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__set_lineoffset'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_lineoffset():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">props = generate_EventCollection_plot()</span>
    <span class="s1">new_lineoffset = -</span><span class="s3">5.</span>
    <span class="s1">coll.set_lineoffset(new_lineoffset)</span>
    <span class="s0">assert </span><span class="s1">new_lineoffset == coll.get_lineoffset()</span>
    <span class="s1">check_segments(coll</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'positions'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'linelength'</span><span class="s1">]</span><span class="s0">,</span>
                   <span class="s1">new_lineoffset</span><span class="s0">,</span>
                   <span class="s1">props[</span><span class="s4">'orientation'</span><span class="s1">])</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: set_lineoffset'</span><span class="s1">)</span>
    <span class="s1">splt.set_ylim(-</span><span class="s3">6</span><span class="s0">, </span><span class="s1">-</span><span class="s3">4</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span>
    <span class="s4">'EventCollection_plot__set_linestyle'</span><span class="s0">,</span>
    <span class="s4">'EventCollection_plot__set_linestyle'</span><span class="s0">,</span>
    <span class="s4">'EventCollection_plot__set_linewidth'</span><span class="s0">,</span>
<span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_prop():</span>
    <span class="s0">for </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s4">'linestyle'</span><span class="s0">, </span><span class="s4">'dashed'</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">(</span><span class="s3">6.0</span><span class="s0">, </span><span class="s3">6.0</span><span class="s1">))])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">'linestyle'</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">(</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">6.</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">(</span><span class="s3">6.0</span><span class="s0">, </span><span class="s3">6.0</span><span class="s1">))])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">'linewidth'</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">_ = generate_EventCollection_plot()</span>
        <span class="s1">coll.set(**{prop: value})</span>
        <span class="s0">assert </span><span class="s1">plt.getp(coll</span><span class="s0">, </span><span class="s1">prop) == expected</span>
        <span class="s1">splt.set_title(</span><span class="s4">f'EventCollection: set_</span><span class="s0">{</span><span class="s1">prop</span><span class="s0">}</span><span class="s4">'</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EventCollection_plot__set_color'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test__EventCollection__set_color():</span>
    <span class="s1">splt</span><span class="s0">, </span><span class="s1">coll</span><span class="s0">, </span><span class="s1">_ = generate_EventCollection_plot()</span>
    <span class="s1">new_color = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">coll.set_color(new_color)</span>
    <span class="s0">for </span><span class="s1">color </span><span class="s0">in </span><span class="s1">[coll.get_color()</span><span class="s0">, </span><span class="s1">*coll.get_colors()]:</span>
        <span class="s1">np.testing.assert_array_equal(color</span><span class="s0">, </span><span class="s1">new_color)</span>
    <span class="s1">splt.set_title(</span><span class="s4">'EventCollection: set_color'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_segments(coll</span><span class="s0">, </span><span class="s1">positions</span><span class="s0">, </span><span class="s1">linelength</span><span class="s0">, </span><span class="s1">lineoffset</span><span class="s0">, </span><span class="s1">orientation):</span>
    <span class="s2">&quot;&quot;&quot; 
    Test helper checking that all values in the segment are correct, given a 
    particular set of inputs. 
    &quot;&quot;&quot;</span>
    <span class="s1">segments = coll.get_segments()</span>
    <span class="s0">if </span><span class="s1">(orientation.lower() == </span><span class="s4">'horizontal'</span>
            <span class="s0">or </span><span class="s1">orientation.lower() == </span><span class="s4">'none' </span><span class="s0">or </span><span class="s1">orientation </span><span class="s0">is None</span><span class="s1">):</span>
        <span class="s5"># if horizontal, the position in is in the y-axis</span>
        <span class="s1">pos1 = </span><span class="s3">1</span>
        <span class="s1">pos2 = </span><span class="s3">0</span>
    <span class="s0">elif </span><span class="s1">orientation.lower() == </span><span class="s4">'vertical'</span><span class="s1">:</span>
        <span class="s5"># if vertical, the position in is in the x-axis</span>
        <span class="s1">pos1 = </span><span class="s3">0</span>
        <span class="s1">pos2 = </span><span class="s3">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;orientation must be 'horizontal' or 'vertical'&quot;</span><span class="s1">)</span>

    <span class="s5"># test to make sure each segment is correct</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">segment </span><span class="s0">in </span><span class="s1">enumerate(segments):</span>
        <span class="s0">assert </span><span class="s1">segment[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">pos1] == lineoffset + linelength / </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">segment[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pos1] == lineoffset - linelength / </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">segment[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">pos2] == positions[i]</span>
        <span class="s0">assert </span><span class="s1">segment[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">pos2] == positions[i]</span>


<span class="s0">def </span><span class="s1">test_null_collection_datalim():</span>
    <span class="s1">col = mcollections.PathCollection([])</span>
    <span class="s1">col_data_lim = col.get_datalim(mtransforms.IdentityTransform())</span>
    <span class="s1">assert_array_equal(col_data_lim.get_points()</span><span class="s0">,</span>
                       <span class="s1">mtransforms.Bbox.null().get_points())</span>


<span class="s0">def </span><span class="s1">test_no_offsets_datalim():</span>
    <span class="s5"># A collection with no offsets and a non transData</span>
    <span class="s5"># transform should return a null bbox</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">coll = mcollections.PathCollection([mpath.Path([(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)])])</span>
    <span class="s1">ax.add_collection(coll)</span>
    <span class="s1">coll_data_lim = coll.get_datalim(mtransforms.IdentityTransform())</span>
    <span class="s1">assert_array_equal(coll_data_lim.get_points()</span><span class="s0">,</span>
                       <span class="s1">mtransforms.Bbox.null().get_points())</span>


<span class="s0">def </span><span class="s1">test_add_collection():</span>
    <span class="s5"># Test if data limits are unchanged by adding an empty collection.</span>
    <span class="s5"># GitHub issue #1490, pull #1497.</span>
    <span class="s1">plt.figure()</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">ax.scatter([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">bounds = ax.dataLim.bounds</span>
    <span class="s1">ax.scatter([]</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">assert </span><span class="s1">ax.dataLim.bounds == bounds</span>


<span class="s1">@mpl.style.context(</span><span class="s4">'mpl20'</span><span class="s1">)</span>
<span class="s1">@check_figures_equal(extensions=[</span><span class="s4">'png'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_collection_log_datalim(fig_test</span><span class="s0">, </span><span class="s1">fig_ref):</span>
    <span class="s5"># Data limits should respect the minimum x/y when using log scale.</span>
    <span class="s1">x_vals = [</span><span class="s3">4.38462e-6</span><span class="s0">, </span><span class="s3">5.54929e-6</span><span class="s0">, </span><span class="s3">7.02332e-6</span><span class="s0">, </span><span class="s3">8.88889e-6</span><span class="s0">, </span><span class="s3">1.12500e-5</span><span class="s0">,</span>
              <span class="s3">1.42383e-5</span><span class="s0">, </span><span class="s3">1.80203e-5</span><span class="s0">, </span><span class="s3">2.28070e-5</span><span class="s0">, </span><span class="s3">2.88651e-5</span><span class="s0">, </span><span class="s3">3.65324e-5</span><span class="s0">,</span>
              <span class="s3">4.62363e-5</span><span class="s0">, </span><span class="s3">5.85178e-5</span><span class="s0">, </span><span class="s3">7.40616e-5</span><span class="s0">, </span><span class="s3">9.37342e-5</span><span class="s0">, </span><span class="s3">1.18632e-4</span><span class="s1">]</span>
    <span class="s1">y_vals = [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.182</span><span class="s0">, </span><span class="s3">0.332</span><span class="s0">, </span><span class="s3">0.604</span><span class="s0">, </span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.64</span><span class="s0">, </span><span class="s3">6.64</span><span class="s0">, </span><span class="s3">12.1</span><span class="s0">, </span><span class="s3">22.0</span><span class="s0">,</span>
              <span class="s3">39.6</span><span class="s0">, </span><span class="s3">71.3</span><span class="s1">]</span>

    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(x_vals</span><span class="s0">, </span><span class="s1">y_vals)</span>
    <span class="s1">x = x.flatten()</span>
    <span class="s1">y = y.flatten()</span>

    <span class="s1">ax_test = fig_test.subplots()</span>
    <span class="s1">ax_test.set_xscale(</span><span class="s4">'log'</span><span class="s1">)</span>
    <span class="s1">ax_test.set_yscale(</span><span class="s4">'log'</span><span class="s1">)</span>
    <span class="s1">ax_test.margins = </span><span class="s3">0</span>
    <span class="s1">ax_test.scatter(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s1">ax_ref = fig_ref.subplots()</span>
    <span class="s1">ax_ref.set_xscale(</span><span class="s4">'log'</span><span class="s1">)</span>
    <span class="s1">ax_ref.set_yscale(</span><span class="s4">'log'</span><span class="s1">)</span>
    <span class="s1">ax_ref.plot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">marker=</span><span class="s4">&quot;o&quot;</span><span class="s0">, </span><span class="s1">ls=</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_quiver_limits():</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.arange(</span><span class="s3">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">u = v = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">80</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
    <span class="s1">q = plt.quiver(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">u</span><span class="s0">, </span><span class="s1">v)</span>
    <span class="s0">assert </span><span class="s1">q.get_datalim(ax.transData).bounds == (</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">7.</span><span class="s0">, </span><span class="s3">9.</span><span class="s1">)</span>

    <span class="s1">plt.figure()</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">x = np.linspace(-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y</span><span class="s0">, </span><span class="s1">x = np.meshgrid(y</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">trans = mtransforms.Affine2D().translate(</span><span class="s3">25</span><span class="s0">, </span><span class="s3">32</span><span class="s1">) + ax.transData</span>
    <span class="s1">plt.quiver(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">np.sin(x)</span><span class="s0">, </span><span class="s1">np.cos(y)</span><span class="s0">, </span><span class="s1">transform=trans)</span>
    <span class="s0">assert </span><span class="s1">ax.dataLim.bounds == (</span><span class="s3">20.0</span><span class="s0">, </span><span class="s3">30.0</span><span class="s0">, </span><span class="s3">15.0</span><span class="s0">, </span><span class="s3">6.0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_barb_limits():</span>
    <span class="s1">ax = plt.axes()</span>
    <span class="s1">x = np.linspace(-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y</span><span class="s0">, </span><span class="s1">x = np.meshgrid(y</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">trans = mtransforms.Affine2D().translate(</span><span class="s3">25</span><span class="s0">, </span><span class="s3">32</span><span class="s1">) + ax.transData</span>
    <span class="s1">plt.barbs(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">np.sin(x)</span><span class="s0">, </span><span class="s1">np.cos(y)</span><span class="s0">, </span><span class="s1">transform=trans)</span>
    <span class="s5"># The calculated bounds are approximately the bounds of the original data,</span>
    <span class="s5"># this is because the entire path is taken into account when updating the</span>
    <span class="s5"># datalim.</span>
    <span class="s1">assert_array_almost_equal(ax.dataLim.bounds</span><span class="s0">, </span><span class="s1">(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'EllipseCollection_test_image.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_EllipseCollection():</span>
    <span class="s5"># Test basic functionality</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y = np.arange(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">X</span><span class="s0">, </span><span class="s1">Y = np.meshgrid(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">XY = np.vstack((X.ravel()</span><span class="s0">, </span><span class="s1">Y.ravel())).T</span>

    <span class="s1">ww = X / x[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">hh = Y / y[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">aa = np.ones_like(ww) * </span><span class="s3">20  </span><span class="s5"># first axis is 20 degrees CCW from x axis</span>

    <span class="s1">ec = mcollections.EllipseCollection(</span>
        <span class="s1">ww</span><span class="s0">, </span><span class="s1">hh</span><span class="s0">, </span><span class="s1">aa</span><span class="s0">, </span><span class="s1">units=</span><span class="s4">'x'</span><span class="s0">, </span><span class="s1">offsets=XY</span><span class="s0">, </span><span class="s1">offset_transform=ax.transData</span><span class="s0">,</span>
        <span class="s1">facecolors=</span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s1">ax.add_collection(ec)</span>
    <span class="s1">ax.autoscale_view()</span>


<span class="s1">@image_comparison([</span><span class="s4">'polycollection_close.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_polycollection_close():</span>
    <span class="s0">from </span><span class="s1">mpl_toolkits.mplot3d </span><span class="s0">import </span><span class="s1">Axes3D</span>

    <span class="s1">vertsQuad = [</span>
        <span class="s1">[[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">[[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">[[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">[[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]]]</span>

    <span class="s1">fig = plt.figure()</span>
    <span class="s1">ax = fig.add_axes(Axes3D(fig))</span>

    <span class="s1">colors = [</span><span class="s4">'r'</span><span class="s0">, </span><span class="s4">'g'</span><span class="s0">, </span><span class="s4">'b'</span><span class="s0">, </span><span class="s4">'y'</span><span class="s0">, </span><span class="s4">'k'</span><span class="s1">]</span>
    <span class="s1">zpos = list(range(</span><span class="s3">5</span><span class="s1">))</span>

    <span class="s1">poly = mcollections.PolyCollection(</span>
        <span class="s1">vertsQuad * len(zpos)</span><span class="s0">, </span><span class="s1">linewidth=</span><span class="s3">0.25</span><span class="s1">)</span>
    <span class="s1">poly.set_alpha(</span><span class="s3">0.7</span><span class="s1">)</span>

    <span class="s5"># need to have a z-value for *each* polygon = element!</span>
    <span class="s1">zs = []</span>
    <span class="s1">cs = []</span>
    <span class="s0">for </span><span class="s1">z</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">zip(zpos</span><span class="s0">, </span><span class="s1">colors):</span>
        <span class="s1">zs.extend([z] * len(vertsQuad))</span>
        <span class="s1">cs.extend([c] * len(vertsQuad))</span>

    <span class="s1">poly.set_color(cs)</span>

    <span class="s1">ax.add_collection3d(poly</span><span class="s0">, </span><span class="s1">zs=zs</span><span class="s0">, </span><span class="s1">zdir=</span><span class="s4">'y'</span><span class="s1">)</span>

    <span class="s5"># axis limit settings:</span>
    <span class="s1">ax.set_xlim3d(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">ax.set_zlim3d(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">ax.set_ylim3d(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'regularpolycollection_rotate.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_regularpolycollection_rotate():</span>
    <span class="s1">xx</span><span class="s0">, </span><span class="s1">yy = np.mgrid[:</span><span class="s3">10</span><span class="s0">, </span><span class="s1">:</span><span class="s3">10</span><span class="s1">]</span>
    <span class="s1">xy_points = np.transpose([xx.flatten()</span><span class="s0">, </span><span class="s1">yy.flatten()])</span>
    <span class="s1">rotations = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s1">len(xy_points))</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s0">for </span><span class="s1">xy</span><span class="s0">, </span><span class="s1">alpha </span><span class="s0">in </span><span class="s1">zip(xy_points</span><span class="s0">, </span><span class="s1">rotations):</span>
        <span class="s1">col = mcollections.RegularPolyCollection(</span>
            <span class="s3">4</span><span class="s0">, </span><span class="s1">sizes=(</span><span class="s3">100</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rotation=alpha</span><span class="s0">,</span>
            <span class="s1">offsets=[xy]</span><span class="s0">, </span><span class="s1">offset_transform=ax.transData)</span>
        <span class="s1">ax.add_collection(col</span><span class="s0">, </span><span class="s1">autolim=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">ax.autoscale_view()</span>


<span class="s1">@image_comparison([</span><span class="s4">'regularpolycollection_scale.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_regularpolycollection_scale():</span>
    <span class="s5"># See issue #3860</span>

    <span class="s0">class </span><span class="s1">SquareCollection(mcollections.RegularPolyCollection):</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super().__init__(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">rotation=np.pi/</span><span class="s3">4.</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">def </span><span class="s1">get_transform(self):</span>
            <span class="s2">&quot;&quot;&quot;Return transform scaling circle areas to data space.&quot;&quot;&quot;</span>
            <span class="s1">ax = self.axes</span>

            <span class="s1">pts2pixels = </span><span class="s3">72.0 </span><span class="s1">/ ax.figure.dpi</span>

            <span class="s1">scale_x = pts2pixels * ax.bbox.width / ax.viewLim.width</span>
            <span class="s1">scale_y = pts2pixels * ax.bbox.height / ax.viewLim.height</span>
            <span class="s0">return </span><span class="s1">mtransforms.Affine2D().scale(scale_x</span><span class="s0">, </span><span class="s1">scale_y)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>

    <span class="s1">xy = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span>
    <span class="s5"># Unit square has a half-diagonal of `1/sqrt(2)`, so `pi * r**2` equals...</span>
    <span class="s1">circle_areas = [np.pi / </span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">squares = SquareCollection(</span>
        <span class="s1">sizes=circle_areas</span><span class="s0">, </span><span class="s1">offsets=xy</span><span class="s0">, </span><span class="s1">offset_transform=ax.transData)</span>
    <span class="s1">ax.add_collection(squares</span><span class="s0">, </span><span class="s1">autolim=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">ax.axis([-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_picking():</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">col = ax.scatter([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1000</span><span class="s1">]</span><span class="s0">, </span><span class="s1">picker=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">fig.savefig(io.BytesIO()</span><span class="s0">, </span><span class="s1">dpi=fig.dpi)</span>
    <span class="s1">mouse_event = SimpleNamespace(x=</span><span class="s3">325</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">240</span><span class="s1">)</span>
    <span class="s1">found</span><span class="s0">, </span><span class="s1">indices = col.contains(mouse_event)</span>
    <span class="s0">assert </span><span class="s1">found</span>
    <span class="s1">assert_array_equal(indices[</span><span class="s4">'ind'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_quadmesh_contains():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">X = x[:</span><span class="s0">, None</span><span class="s1">] * x[</span><span class="s0">None, </span><span class="s1">:]</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">mesh = ax.pcolormesh(X)</span>
    <span class="s1">fig.draw_without_rendering()</span>
    <span class="s1">xdata</span><span class="s0">, </span><span class="s1">ydata = </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = mesh.get_transform().transform((xdata</span><span class="s0">, </span><span class="s1">ydata))</span>
    <span class="s1">mouse_event = SimpleNamespace(xdata=xdata</span><span class="s0">, </span><span class="s1">ydata=ydata</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y)</span>
    <span class="s1">found</span><span class="s0">, </span><span class="s1">indices = mesh.contains(mouse_event)</span>
    <span class="s0">assert </span><span class="s1">found</span>
    <span class="s1">assert_array_equal(indices[</span><span class="s4">'ind'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">xdata</span><span class="s0">, </span><span class="s1">ydata = </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = mesh.get_transform().transform((xdata</span><span class="s0">, </span><span class="s1">ydata))</span>
    <span class="s1">mouse_event = SimpleNamespace(xdata=xdata</span><span class="s0">, </span><span class="s1">ydata=ydata</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y)</span>
    <span class="s1">found</span><span class="s0">, </span><span class="s1">indices = mesh.contains(mouse_event)</span>
    <span class="s0">assert </span><span class="s1">found</span>
    <span class="s1">assert_array_equal(indices[</span><span class="s4">'ind'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_quadmesh_contains_concave():</span>
    <span class="s5"># Test a concave polygon, V-like shape</span>
    <span class="s1">x = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]]</span>
    <span class="s1">y = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">mesh = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">fig.draw_without_rendering()</span>
    <span class="s5"># xdata, ydata, expected</span>
    <span class="s1">points = [(-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># left wing</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># between the two wings</span>
              <span class="s1">(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># right wing</span>
              <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.25</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,  </span><span class="s5"># main body</span>
              <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">point </span><span class="s0">in </span><span class="s1">points:</span>
        <span class="s1">xdata</span><span class="s0">, </span><span class="s1">ydata</span><span class="s0">, </span><span class="s1">expected = point</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y = mesh.get_transform().transform((xdata</span><span class="s0">, </span><span class="s1">ydata))</span>
        <span class="s1">mouse_event = SimpleNamespace(xdata=xdata</span><span class="s0">, </span><span class="s1">ydata=ydata</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y)</span>
        <span class="s1">found</span><span class="s0">, </span><span class="s1">indices = mesh.contains(mouse_event)</span>
        <span class="s0">assert </span><span class="s1">found </span><span class="s0">is </span><span class="s1">expected</span>


<span class="s0">def </span><span class="s1">test_quadmesh_cursor_data():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">X = x[:</span><span class="s0">, None</span><span class="s1">] * x[</span><span class="s0">None, </span><span class="s1">:]</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">mesh = ax.pcolormesh(X)</span>
    <span class="s5"># Empty array data</span>
    <span class="s1">mesh._A = </span><span class="s0">None</span>
    <span class="s1">fig.draw_without_rendering()</span>
    <span class="s1">xdata</span><span class="s0">, </span><span class="s1">ydata = </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = mesh.get_transform().transform((xdata</span><span class="s0">, </span><span class="s1">ydata))</span>
    <span class="s1">mouse_event = SimpleNamespace(xdata=xdata</span><span class="s0">, </span><span class="s1">ydata=ydata</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y)</span>
    <span class="s5"># Empty collection should return None</span>
    <span class="s0">assert </span><span class="s1">mesh.get_cursor_data(mouse_event) </span><span class="s0">is None</span>

    <span class="s5"># Now test adding the array data, to make sure we do get a value</span>
    <span class="s1">mesh.set_array(np.ones((X.shape)))</span>
    <span class="s1">assert_array_equal(mesh.get_cursor_data(mouse_event)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_quadmesh_cursor_data_multiple_points():</span>
    <span class="s1">x = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">mesh = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)))</span>
    <span class="s1">fig.draw_without_rendering()</span>
    <span class="s1">xdata</span><span class="s0">, </span><span class="s1">ydata = </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = mesh.get_transform().transform((xdata</span><span class="s0">, </span><span class="s1">ydata))</span>
    <span class="s1">mouse_event = SimpleNamespace(xdata=xdata</span><span class="s0">, </span><span class="s1">ydata=ydata</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y)</span>
    <span class="s5"># All quads are covering the same square</span>
    <span class="s1">assert_array_equal(mesh.get_cursor_data(mouse_event)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s3">9</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_linestyle_single_dashes():</span>
    <span class="s1">plt.scatter([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">linestyle=(</span><span class="s3">0.</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]))</span>
    <span class="s1">plt.draw()</span>


<span class="s1">@image_comparison([</span><span class="s4">'size_in_xy.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_size_in_xy():</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>

    <span class="s1">widths</span><span class="s0">, </span><span class="s1">heights</span><span class="s0">, </span><span class="s1">angles = (</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">0</span>
    <span class="s1">widths = </span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span>
    <span class="s1">coords = [(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">15</span><span class="s0">, </span><span class="s3">15</span><span class="s1">)]</span>
    <span class="s1">e = mcollections.EllipseCollection(</span>
        <span class="s1">widths</span><span class="s0">, </span><span class="s1">heights</span><span class="s0">, </span><span class="s1">angles</span><span class="s0">, </span><span class="s1">units=</span><span class="s4">'xy'</span><span class="s0">,</span>
        <span class="s1">offsets=coords</span><span class="s0">, </span><span class="s1">offset_transform=ax.transData)</span>

    <span class="s1">ax.add_collection(e)</span>

    <span class="s1">ax.set_xlim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
    <span class="s1">ax.set_ylim(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_pandas_indexing(pd):</span>

    <span class="s5"># Should not fail break when faced with a</span>
    <span class="s5"># non-zero indexed series</span>
    <span class="s1">index = [</span><span class="s3">11</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">13</span><span class="s1">]</span>
    <span class="s1">ec = fc = pd.Series([</span><span class="s4">'red'</span><span class="s0">, </span><span class="s4">'blue'</span><span class="s0">, </span><span class="s4">'green'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">lw = pd.Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">ls = pd.Series([</span><span class="s4">'solid'</span><span class="s0">, </span><span class="s4">'dashed'</span><span class="s0">, </span><span class="s4">'dashdot'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">aa = pd.Series([</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index)</span>

    <span class="s1">Collection(edgecolors=ec)</span>
    <span class="s1">Collection(facecolors=fc)</span>
    <span class="s1">Collection(linewidths=lw)</span>
    <span class="s1">Collection(linestyles=ls)</span>
    <span class="s1">Collection(antialiaseds=aa)</span>


<span class="s1">@mpl.style.context(</span><span class="s4">'default'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_lslw_bcast():</span>
    <span class="s1">col = mcollections.PathCollection([])</span>
    <span class="s1">col.set_linestyles([</span><span class="s4">'-'</span><span class="s0">, </span><span class="s4">'-'</span><span class="s1">])</span>
    <span class="s1">col.set_linewidths([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s0">assert </span><span class="s1">col.get_linestyles() == [(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)] * </span><span class="s3">6</span>
    <span class="s0">assert </span><span class="s1">col.get_linewidths() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">2</span>

    <span class="s1">col.set_linestyles([</span><span class="s4">'-'</span><span class="s0">, </span><span class="s4">'-'</span><span class="s0">, </span><span class="s4">'-'</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">col.get_linestyles() == [(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)] * </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">(col.get_linewidths() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]).all()</span>


<span class="s0">def </span><span class="s1">test_set_wrong_linestyle():</span>
    <span class="s1">c = Collection()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Do not know how to convert 'fuzzy'&quot;</span><span class="s1">):</span>
        <span class="s1">c.set_linestyle(</span><span class="s4">'fuzzy'</span><span class="s1">)</span>


<span class="s1">@mpl.style.context(</span><span class="s4">'default'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_capstyle():</span>
    <span class="s1">col = mcollections.PathCollection([]</span><span class="s0">, </span><span class="s1">capstyle=</span><span class="s4">'round'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">col.get_capstyle() == </span><span class="s4">'round'</span>
    <span class="s1">col.set_capstyle(</span><span class="s4">'butt'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">col.get_capstyle() == </span><span class="s4">'butt'</span>


<span class="s1">@mpl.style.context(</span><span class="s4">'default'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_joinstyle():</span>
    <span class="s1">col = mcollections.PathCollection([]</span><span class="s0">, </span><span class="s1">joinstyle=</span><span class="s4">'round'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">col.get_joinstyle() == </span><span class="s4">'round'</span>
    <span class="s1">col.set_joinstyle(</span><span class="s4">'miter'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">col.get_joinstyle() == </span><span class="s4">'miter'</span>


<span class="s1">@image_comparison([</span><span class="s4">'cap_and_joinstyle.png'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_cap_and_joinstyle_image():</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.set_xlim([-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">])</span>
    <span class="s1">ax.set_ylim([-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">])</span>

    <span class="s1">x = np.array([</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">])</span>
    <span class="s1">ys = np.array([[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s1">]]) + np.array([[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]])</span>

    <span class="s1">segs = np.zeros((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">segs[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = x</span>
    <span class="s1">segs[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] = ys</span>
    <span class="s1">line_segments = LineCollection(segs</span><span class="s0">, </span><span class="s1">linewidth=[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">20</span><span class="s1">])</span>
    <span class="s1">line_segments.set_capstyle(</span><span class="s4">&quot;round&quot;</span><span class="s1">)</span>
    <span class="s1">line_segments.set_joinstyle(</span><span class="s4">&quot;miter&quot;</span><span class="s1">)</span>

    <span class="s1">ax.add_collection(line_segments)</span>
    <span class="s1">ax.set_title(</span><span class="s4">'Line collection with customized caps and joinstyle'</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s4">'scatter_post_alpha.png'</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">remove_text=</span><span class="s0">True, </span><span class="s1">style=</span><span class="s4">'default'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_scatter_post_alpha():</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">sc = ax.scatter(range(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">c=range(</span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">sc.set_alpha(</span><span class="s3">.1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_scatter_alpha_array():</span>
    <span class="s1">x = np.arange(</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">alpha = x / </span><span class="s3">5</span>
    <span class="s5"># With colormapping.</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">(ax0</span><span class="s0">, </span><span class="s1">ax1) = plt.subplots(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">sc0 = ax0.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">c=x</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
    <span class="s1">sc1 = ax1.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">c=x)</span>
    <span class="s1">sc1.set_alpha(alpha)</span>
    <span class="s1">plt.draw()</span>
    <span class="s1">assert_array_equal(sc0.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>
    <span class="s1">assert_array_equal(sc1.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>
    <span class="s5"># Without colormapping.</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">(ax0</span><span class="s0">, </span><span class="s1">ax1) = plt.subplots(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">sc0 = ax0.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">color=[</span><span class="s4">'r'</span><span class="s0">, </span><span class="s4">'g'</span><span class="s0">, </span><span class="s4">'b'</span><span class="s0">, </span><span class="s4">'c'</span><span class="s0">, </span><span class="s4">'m'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
    <span class="s1">sc1 = ax1.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">color=</span><span class="s4">'r'</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
    <span class="s1">plt.draw()</span>
    <span class="s1">assert_array_equal(sc0.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>
    <span class="s1">assert_array_equal(sc1.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>
    <span class="s5"># Without colormapping, and set alpha afterward.</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">(ax0</span><span class="s0">, </span><span class="s1">ax1) = plt.subplots(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">sc0 = ax0.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">color=[</span><span class="s4">'r'</span><span class="s0">, </span><span class="s4">'g'</span><span class="s0">, </span><span class="s4">'b'</span><span class="s0">, </span><span class="s4">'c'</span><span class="s0">, </span><span class="s4">'m'</span><span class="s1">])</span>
    <span class="s1">sc0.set_alpha(alpha)</span>
    <span class="s1">sc1 = ax1.scatter(x</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">color=</span><span class="s4">'r'</span><span class="s1">)</span>
    <span class="s1">sc1.set_alpha(alpha)</span>
    <span class="s1">plt.draw()</span>
    <span class="s1">assert_array_equal(sc0.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>
    <span class="s1">assert_array_equal(sc1.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha)</span>


<span class="s0">def </span><span class="s1">test_pathcollection_legend_elements():</span>
    <span class="s1">np.random.seed(</span><span class="s3">19680801</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.random.rand(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y = np.random.rand(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">c = np.random.randint(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">s = np.random.randint(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">300</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">sc = ax.scatter(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">c=c</span><span class="s0">, </span><span class="s1">s=s</span><span class="s0">, </span><span class="s1">cmap=</span><span class="s4">&quot;jet&quot;</span><span class="s0">, </span><span class="s1">marker=</span><span class="s4">&quot;o&quot;</span><span class="s0">, </span><span class="s1">linewidths=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">h</span><span class="s0">, </span><span class="s1">l = sc.legend_elements(fmt=</span><span class="s4">&quot;{x:g}&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(h) == </span><span class="s3">5</span>
    <span class="s0">assert </span><span class="s1">l == [</span><span class="s4">&quot;0&quot;</span><span class="s0">, </span><span class="s4">&quot;1&quot;</span><span class="s0">, </span><span class="s4">&quot;2&quot;</span><span class="s0">, </span><span class="s4">&quot;3&quot;</span><span class="s0">, </span><span class="s4">&quot;4&quot;</span><span class="s1">]</span>
    <span class="s1">colors = np.array([line.get_color() </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">h])</span>
    <span class="s1">colors2 = sc.cmap(np.arange(</span><span class="s3">5</span><span class="s1">)/</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(colors</span><span class="s0">, </span><span class="s1">colors2)</span>
    <span class="s1">l1 = ax.legend(h</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">loc=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">h2</span><span class="s0">, </span><span class="s1">lab2 = sc.legend_elements(num=</span><span class="s3">9</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(h2) == </span><span class="s3">9</span>
    <span class="s1">l2 = ax.legend(h2</span><span class="s0">, </span><span class="s1">lab2</span><span class="s0">, </span><span class="s1">loc=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s1">h</span><span class="s0">, </span><span class="s1">l = sc.legend_elements(prop=</span><span class="s4">&quot;sizes&quot;</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">color=</span><span class="s4">&quot;red&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">all(line.get_alpha() == </span><span class="s3">0.5 </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">h)</span>
    <span class="s0">assert </span><span class="s1">all(line.get_markerfacecolor() == </span><span class="s4">&quot;red&quot; </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">h)</span>
    <span class="s1">l3 = ax.legend(h</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">loc=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s1">h</span><span class="s0">, </span><span class="s1">l = sc.legend_elements(prop=</span><span class="s4">&quot;sizes&quot;</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">fmt=</span><span class="s4">&quot;{x:.2f}&quot;</span><span class="s0">,</span>
                              <span class="s1">func=</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">2</span><span class="s1">*x)</span>
    <span class="s1">actsizes = [line.get_markersize() </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">h]</span>
    <span class="s1">labeledsizes = np.sqrt(np.array(l</span><span class="s0">, </span><span class="s1">float) / </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_array_almost_equal(actsizes</span><span class="s0">, </span><span class="s1">labeledsizes)</span>
    <span class="s1">l4 = ax.legend(h</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">loc=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s1">loc = mpl.ticker.MaxNLocator(nbins=</span><span class="s3">9</span><span class="s0">, </span><span class="s1">min_n_ticks=</span><span class="s3">9</span><span class="s1">-</span><span class="s3">1</span><span class="s0">,</span>
                                 <span class="s1">steps=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">10</span><span class="s1">])</span>
    <span class="s1">h5</span><span class="s0">, </span><span class="s1">lab5 = sc.legend_elements(num=loc)</span>
    <span class="s0">assert </span><span class="s1">len(h2) == len(h5)</span>

    <span class="s1">levels = [-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">55.4</span><span class="s0">, </span><span class="s3">260</span><span class="s1">]</span>
    <span class="s1">h6</span><span class="s0">, </span><span class="s1">lab6 = sc.legend_elements(num=levels</span><span class="s0">, </span><span class="s1">prop=</span><span class="s4">&quot;sizes&quot;</span><span class="s0">, </span><span class="s1">fmt=</span><span class="s4">&quot;{x:g}&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">[float(l) </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">lab6] == levels[</span><span class="s3">2</span><span class="s1">:]</span>

    <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">[l1</span><span class="s0">, </span><span class="s1">l2</span><span class="s0">, </span><span class="s1">l3</span><span class="s0">, </span><span class="s1">l4]:</span>
        <span class="s1">ax.add_artist(l)</span>

    <span class="s1">fig.canvas.draw()</span>


<span class="s0">def </span><span class="s1">test_EventCollection_nosort():</span>
    <span class="s5"># Check that EventCollection doesn't modify input in place</span>
    <span class="s1">arr = np.array([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">])</span>
    <span class="s1">coll = EventCollection(arr)</span>
    <span class="s1">np.testing.assert_array_equal(arr</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_collection_set_verts_array():</span>
    <span class="s1">verts = np.arange(</span><span class="s3">80</span><span class="s0">, </span><span class="s1">dtype=np.double).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">col_arr = PolyCollection(verts)</span>
    <span class="s1">col_list = PolyCollection(list(verts))</span>
    <span class="s0">assert </span><span class="s1">len(col_arr._paths) == len(col_list._paths)</span>
    <span class="s0">for </span><span class="s1">ap</span><span class="s0">, </span><span class="s1">lp </span><span class="s0">in </span><span class="s1">zip(col_arr._paths</span><span class="s0">, </span><span class="s1">col_list._paths):</span>
        <span class="s0">assert </span><span class="s1">np.array_equal(ap._vertices</span><span class="s0">, </span><span class="s1">lp._vertices)</span>
        <span class="s0">assert </span><span class="s1">np.array_equal(ap._codes</span><span class="s0">, </span><span class="s1">lp._codes)</span>

    <span class="s1">verts_tuple = np.empty(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">verts_tuple[:] = [tuple(tuple(y) </span><span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">verts]</span>
    <span class="s1">col_arr_tuple = PolyCollection(verts_tuple)</span>
    <span class="s0">assert </span><span class="s1">len(col_arr._paths) == len(col_arr_tuple._paths)</span>
    <span class="s0">for </span><span class="s1">ap</span><span class="s0">, </span><span class="s1">atp </span><span class="s0">in </span><span class="s1">zip(col_arr._paths</span><span class="s0">, </span><span class="s1">col_arr_tuple._paths):</span>
        <span class="s0">assert </span><span class="s1">np.array_equal(ap._vertices</span><span class="s0">, </span><span class="s1">atp._vertices)</span>
        <span class="s0">assert </span><span class="s1">np.array_equal(ap._codes</span><span class="s0">, </span><span class="s1">atp._codes)</span>


<span class="s0">def </span><span class="s1">test_collection_set_array():</span>
    <span class="s1">vals = [*range(</span><span class="s3">10</span><span class="s1">)]</span>

    <span class="s5"># Test set_array with list</span>
    <span class="s1">c = Collection()</span>
    <span class="s1">c.set_array(vals)</span>

    <span class="s5"># Test set_array with wrong dtype</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^Image data of dtype&quot;</span><span class="s1">):</span>
        <span class="s1">c.set_array(</span><span class="s4">&quot;wrong_input&quot;</span><span class="s1">)</span>

    <span class="s5"># Test if array kwarg is copied</span>
    <span class="s1">vals[</span><span class="s3">5</span><span class="s1">] = </span><span class="s3">45</span>
    <span class="s0">assert </span><span class="s1">np.not_equal(vals</span><span class="s0">, </span><span class="s1">c.get_array()).any()</span>


<span class="s0">def </span><span class="s1">test_blended_collection_autolim():</span>
    <span class="s1">a = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
    <span class="s1">height = </span><span class="s3">.2</span>

    <span class="s1">xy_pairs = np.column_stack([np.repeat(a</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.tile([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">height]</span><span class="s0">, </span><span class="s1">len(a))])</span>
    <span class="s1">line_segs = xy_pairs.reshape([len(a)</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s1">f</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">trans = mtransforms.blended_transform_factory(ax.transData</span><span class="s0">, </span><span class="s1">ax.transAxes)</span>
    <span class="s1">ax.add_collection(LineCollection(line_segs</span><span class="s0">, </span><span class="s1">transform=trans))</span>
    <span class="s1">ax.autoscale_view(scalex=</span><span class="s0">True, </span><span class="s1">scaley=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_allclose(ax.get_xlim()</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_singleton_autolim():</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.scatter(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_allclose(ax.get_ylim()</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">0.06</span><span class="s0">, </span><span class="s3">0.06</span><span class="s1">])</span>
    <span class="s1">np.testing.assert_allclose(ax.get_xlim()</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">0.06</span><span class="s0">, </span><span class="s3">0.06</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;transform, expected&quot;</span><span class="s0">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s4">&quot;transData&quot;</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;transAxes&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2.8</span><span class="s0">, </span><span class="s3">3.2</span><span class="s1">))</span><span class="s0">,</span>
<span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_autolim_with_zeros(transform</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s5"># 1) Test that a scatter at (0, 0) data coordinates contributes to</span>
    <span class="s5"># autoscaling even though any(offsets) would be False in that situation.</span>
    <span class="s5"># 2) Test that specifying transAxes for the transform does not contribute</span>
    <span class="s5"># to the autoscaling.</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.scatter(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">transform=getattr(ax</span><span class="s0">, </span><span class="s1">transform))</span>
    <span class="s1">ax.scatter(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_allclose(ax.get_ylim()</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">np.testing.assert_allclose(ax.get_xlim()</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_quadmesh_set_array_validation():</span>
    <span class="s1">x = np.arange(</span><span class="s3">11</span><span class="s1">)</span>
    <span class="s1">y = np.arange(</span><span class="s3">8</span><span class="s1">)</span>
    <span class="s1">z = np.random.random((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">coll = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (10, 7)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z.reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">7</span><span class="s1">))</span>

    <span class="s1">z = np.arange(</span><span class="s3">54</span><span class="s1">).reshape((</span><span class="s3">6</span><span class="s0">, </span><span class="s3">9</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (6, 9)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (54,)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z.ravel())</span>

    <span class="s5"># RGB(A) tests</span>
    <span class="s1">z = np.ones((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))  </span><span class="s5"># RGB with wrong X/Y dims</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (9, 6, 3)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z)</span>

    <span class="s1">z = np.ones((</span><span class="s3">9</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))  </span><span class="s5"># RGBA with wrong X/Y dims</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (9, 6, 4)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z)</span>

    <span class="s1">z = np.ones((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))  </span><span class="s5"># Right X/Y dims, bad 3rd dim</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span>
            <span class="s4">&quot;For X (11) and Y (8) with flat shading, A should have shape &quot;</span>
            <span class="s4">&quot;(7, 10, 3) or (7, 10, 4) or (7, 10) or (70,), not (7, 10, 2)&quot;</span><span class="s1">)):</span>
        <span class="s1">coll.set_array(z)</span>

    <span class="s1">x = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">y = np.arange(</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">z = np.random.random((</span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">coll = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">shading=</span><span class="s4">'gouraud'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_quadmesh_get_coordinates():</span>
    <span class="s1">x = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
    <span class="s1">z = np.ones(shape=(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">xx</span><span class="s0">, </span><span class="s1">yy = np.meshgrid(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">coll = plt.pcolormesh(xx</span><span class="s0">, </span><span class="s1">yy</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s5"># shape (3, 3, 2)</span>
    <span class="s1">coords = np.stack([xx.T</span><span class="s0">, </span><span class="s1">yy.T]).T</span>
    <span class="s1">assert_array_equal(coll.get_coordinates()</span><span class="s0">, </span><span class="s1">coords)</span>


<span class="s0">def </span><span class="s1">test_quadmesh_set_array():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">z = np.arange(</span><span class="s3">9</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">coll = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">np.ones(z.shape))</span>
    <span class="s5"># Test that the collection is able to update with a 2d array</span>
    <span class="s1">coll.set_array(z)</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_array()</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s5"># Check that pre-flattened arrays work too</span>
    <span class="s1">coll.set_array(np.ones(</span><span class="s3">9</span><span class="s1">))</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_array()</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s3">9</span><span class="s1">))</span>

    <span class="s1">z = np.arange(</span><span class="s3">16</span><span class="s1">).reshape((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">coll = ax.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">np.ones(z.shape)</span><span class="s0">, </span><span class="s1">shading=</span><span class="s4">'gouraud'</span><span class="s1">)</span>
    <span class="s5"># Test that the collection is able to update with a 2d array</span>
    <span class="s1">coll.set_array(z)</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_array()</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s5"># Check that pre-flattened arrays work too</span>
    <span class="s1">coll.set_array(np.ones(</span><span class="s3">16</span><span class="s1">))</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_array()</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s3">16</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_quadmesh_vmin_vmax():</span>
    <span class="s5"># test when vmin/vmax on the norm changes, the quadmesh gets updated</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">cmap = mpl.colormaps[</span><span class="s4">'plasma'</span><span class="s1">]</span>
    <span class="s1">norm = mpl.colors.Normalize(vmin=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">vmax=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">coll = ax.pcolormesh([[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">cmap=cmap</span><span class="s0">, </span><span class="s1">norm=norm)</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_facecolors()[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">cmap(norm(</span><span class="s3">1</span><span class="s1">)))</span>

    <span class="s5"># Change the vmin/vmax of the norm so that the color is from</span>
    <span class="s5"># the bottom of the colormap now</span>
    <span class="s1">norm.vmin</span><span class="s0">, </span><span class="s1">norm.vmax = </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span>
    <span class="s1">fig.canvas.draw()</span>
    <span class="s0">assert </span><span class="s1">np.array_equal(coll.get_facecolors()[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">cmap(norm(</span><span class="s3">1</span><span class="s1">)))</span>


<span class="s0">def </span><span class="s1">test_quadmesh_alpha_array():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">z = np.arange(</span><span class="s3">9</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">alpha = z / z.max()</span>
    <span class="s1">alpha_flat = alpha.ravel()</span>
    <span class="s5"># Provide 2-D alpha:</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">(ax0</span><span class="s0">, </span><span class="s1">ax1) = plt.subplots(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">coll1 = ax0.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">alpha=alpha)</span>
    <span class="s1">coll2 = ax1.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">coll2.set_alpha(alpha)</span>
    <span class="s1">plt.draw()</span>
    <span class="s1">assert_array_equal(coll1.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha_flat)</span>
    <span class="s1">assert_array_equal(coll2.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha_flat)</span>
    <span class="s5"># Or provide 1-D alpha:</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">(ax0</span><span class="s0">, </span><span class="s1">ax1) = plt.subplots(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">coll1 = ax0.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">alpha=alpha_flat)</span>
    <span class="s1">coll2 = ax1.pcolormesh(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">coll2.set_alpha(alpha_flat)</span>
    <span class="s1">plt.draw()</span>
    <span class="s1">assert_array_equal(coll1.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha_flat)</span>
    <span class="s1">assert_array_equal(coll2.get_facecolors()[:</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">alpha_flat)</span>


<span class="s0">def </span><span class="s1">test_alpha_validation():</span>
    <span class="s5"># Most of the relevant testing is in test_artist and test_colors.</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">pc = ax.pcolormesh(np.arange(</span><span class="s3">12</span><span class="s1">).reshape((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^Data array shape&quot;</span><span class="s1">):</span>
        <span class="s1">pc.set_alpha([</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.6</span><span class="s1">])</span>
        <span class="s1">pc.update_scalarmappable()</span>


<span class="s0">def </span><span class="s1">test_legend_inverse_size_label_relationship():</span>
    <span class="s2">&quot;&quot;&quot; 
    Ensure legend markers scale appropriately when label and size are 
    inversely related. 
    Here label = 5 / size 
    &quot;&quot;&quot;</span>

    <span class="s1">np.random.seed(</span><span class="s3">19680801</span><span class="s1">)</span>
    <span class="s1">X = np.random.random(</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s1">Y = np.random.random(</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s1">C = </span><span class="s3">1 </span><span class="s1">- np.random.random(</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s1">S = </span><span class="s3">5 </span><span class="s1">/ C</span>

    <span class="s1">legend_sizes = [</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s3">0.6</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">sc = ax.scatter(X</span><span class="s0">, </span><span class="s1">Y</span><span class="s0">, </span><span class="s1">s=S)</span>
    <span class="s1">handles</span><span class="s0">, </span><span class="s1">labels = sc.legend_elements(</span>
      <span class="s1">prop=</span><span class="s4">'sizes'</span><span class="s0">, </span><span class="s1">num=legend_sizes</span><span class="s0">, </span><span class="s1">func=</span><span class="s0">lambda </span><span class="s1">s: </span><span class="s3">5 </span><span class="s1">/ s</span>
    <span class="s1">)</span>

    <span class="s5"># Convert markersize scale to 's' scale</span>
    <span class="s1">handle_sizes = [x.get_markersize() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">handles]</span>
    <span class="s1">handle_sizes = [</span><span class="s3">5 </span><span class="s1">/ x**</span><span class="s3">2 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">handle_sizes]</span>

    <span class="s1">assert_array_almost_equal(handle_sizes</span><span class="s0">, </span><span class="s1">legend_sizes</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s1">@mpl.style.context(</span><span class="s4">'default'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'pcfunc'</span><span class="s0">, </span><span class="s1">[plt.pcolor</span><span class="s0">, </span><span class="s1">plt.pcolormesh])</span>
<span class="s0">def </span><span class="s1">test_color_logic(pcfunc):</span>
    <span class="s1">z = np.arange(</span><span class="s3">12</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s5"># Explicitly set an edgecolor.</span>
    <span class="s1">pc = pcfunc(z</span><span class="s0">, </span><span class="s1">edgecolors=</span><span class="s4">'red'</span><span class="s0">, </span><span class="s1">facecolors=</span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()  </span><span class="s5"># This is called in draw().</span>
    <span class="s5"># Define 2 reference &quot;colors&quot; here for multiple use.</span>
    <span class="s1">face_default = mcolors.to_rgba_array(pc._get_default_facecolor())</span>
    <span class="s1">mapped = pc.get_cmap()(pc.norm((z.ravel())))</span>
    <span class="s5"># GitHub issue #1302:</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s4">'red'</span><span class="s1">)</span>
    <span class="s5"># Check setting attributes after initialization:</span>
    <span class="s1">pc = pcfunc(z)</span>
    <span class="s1">pc.set_facecolor(</span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s1">pc.set_edgecolor(</span><span class="s4">'red'</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s1">pc.set_alpha(</span><span class="s3">0.5</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]])</span>
    <span class="s1">pc.set_alpha(</span><span class="s0">None</span><span class="s1">)  </span><span class="s5"># restore default alpha</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># Reset edgecolor to default.</span>
    <span class="s1">pc.set_edgecolor(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s1">pc.set_facecolor(</span><span class="s0">None</span><span class="s1">)  </span><span class="s5"># restore default for facecolor</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s5"># Turn off colormapping entirely:</span>
    <span class="s1">pc.set_array(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">face_default)  </span><span class="s5"># not mapped</span>
    <span class="s5"># Turn it back on by restoring the array (must be 1D!):</span>
    <span class="s1">pc.set_array(z.ravel())</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s4">'none'</span><span class="s1">)</span>
    <span class="s5"># Give color via tuple rather than string.</span>
    <span class="s1">pc = pcfunc(z</span><span class="s0">, </span><span class="s1">edgecolors=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">facecolors=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># Provide an RGB array; mapping overrides it.</span>
    <span class="s1">pc = pcfunc(z</span><span class="s0">, </span><span class="s1">edgecolors=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">facecolors=np.ones((</span><span class="s3">12</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)))</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># Turn off the mapping.</span>
    <span class="s1">pc.set_array(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s3">12</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)))</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># And an RGBA array.</span>
    <span class="s1">pc = pcfunc(z</span><span class="s0">, </span><span class="s1">edgecolors=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">facecolors=np.ones((</span><span class="s3">12</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)))</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">mapped)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># Turn off the mapping.</span>
    <span class="s1">pc.set_array(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_facecolor()</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s3">12</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)))</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(pc.get_edgecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>


<span class="s0">def </span><span class="s1">test_LineCollection_args():</span>
    <span class="s1">lc = LineCollection(</span><span class="s0">None, </span><span class="s1">linewidth=</span><span class="s3">2.2</span><span class="s0">, </span><span class="s1">edgecolor=</span><span class="s4">'r'</span><span class="s0">,</span>
                        <span class="s1">zorder=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">facecolors=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">lc.get_linewidth()[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">2.2</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(lc.get_edgecolor()</span><span class="s0">, </span><span class="s4">'r'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">lc.get_zorder() == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(lc.get_facecolor()</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
    <span class="s5"># To avoid breaking mplot3d, LineCollection internally sets the facecolor</span>
    <span class="s5"># kwarg if it has not been specified.  Hence we need the following test</span>
    <span class="s5"># for LineCollection._set_default().</span>
    <span class="s1">lc = LineCollection(</span><span class="s0">None, </span><span class="s1">facecolor=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">mcolors.same_color(lc.get_facecolor()</span><span class="s0">, </span><span class="s4">'none'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_array_wrong_dimensions():</span>
    <span class="s1">z = np.arange(</span><span class="s3">12</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">pc = plt.pcolor(z)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;^Collections can only map&quot;</span><span class="s1">):</span>
        <span class="s1">pc.set_array(z)</span>
        <span class="s1">pc.update_scalarmappable()</span>
    <span class="s1">pc = plt.pcolormesh(z)</span>
    <span class="s1">pc.set_array(z)  </span><span class="s5"># 2D is OK for Quadmesh</span>
    <span class="s1">pc.update_scalarmappable()</span>
    <span class="s5"># 3D RGB is OK as well</span>
    <span class="s1">z = np.arange(</span><span class="s3">36</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">pc.set_array(z)</span>


<span class="s0">def </span><span class="s1">test_get_segments():</span>
    <span class="s1">segments = np.tile(np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">256</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)).T</span>
    <span class="s1">lc = LineCollection([segments])</span>

    <span class="s1">readback</span><span class="s0">, </span><span class="s1">= lc.get_segments()</span>
    <span class="s5"># these should comeback un-changed!</span>
    <span class="s0">assert </span><span class="s1">np.all(segments == readback)</span>


<span class="s0">def </span><span class="s1">test_set_offsets_late():</span>
    <span class="s1">identity = mtransforms.IdentityTransform()</span>
    <span class="s1">sizes = [</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s1">null = mcollections.CircleCollection(sizes=sizes)</span>

    <span class="s1">init = mcollections.CircleCollection(sizes=sizes</span><span class="s0">, </span><span class="s1">offsets=(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

    <span class="s1">late = mcollections.CircleCollection(sizes=sizes)</span>
    <span class="s1">late.set_offsets((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

    <span class="s5"># Bbox.__eq__ doesn't compare bounds</span>
    <span class="s1">null_bounds = null.get_datalim(identity).bounds</span>
    <span class="s1">init_bounds = init.get_datalim(identity).bounds</span>
    <span class="s1">late_bounds = late.get_datalim(identity).bounds</span>

    <span class="s5"># offsets and transform are applied when set after initialization</span>
    <span class="s0">assert </span><span class="s1">null_bounds != init_bounds</span>
    <span class="s0">assert </span><span class="s1">init_bounds == late_bounds</span>


<span class="s0">def </span><span class="s1">test_set_offset_transform():</span>
    <span class="s1">skew = mtransforms.Affine2D().skew(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">init = mcollections.Collection(offset_transform=skew)</span>

    <span class="s1">late = mcollections.Collection()</span>
    <span class="s1">late.set_offset_transform(skew)</span>

    <span class="s0">assert </span><span class="s1">skew == init.get_offset_transform() == late.get_offset_transform()</span>


<span class="s0">def </span><span class="s1">test_set_offset_units():</span>
    <span class="s5"># passing the offsets in initially (i.e. via scatter)</span>
    <span class="s5"># should yield the same results as `set_offsets`</span>
    <span class="s1">x = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">y = np.sin(x)</span>
    <span class="s1">d = x * np.timedelta64(</span><span class="s3">24</span><span class="s0">, </span><span class="s4">'h'</span><span class="s1">) + np.datetime64(</span><span class="s4">'2021-11-29'</span><span class="s1">)</span>

    <span class="s1">sc = plt.scatter(d</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">off0 = sc.get_offsets()</span>
    <span class="s1">sc.set_offsets(list(zip(d</span><span class="s0">, </span><span class="s1">y)))</span>
    <span class="s1">np.testing.assert_allclose(off0</span><span class="s0">, </span><span class="s1">sc.get_offsets())</span>

    <span class="s5"># try the other way around</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">sc = ax.scatter(y</span><span class="s0">, </span><span class="s1">d)</span>
    <span class="s1">off0 = sc.get_offsets()</span>
    <span class="s1">sc.set_offsets(list(zip(y</span><span class="s0">, </span><span class="s1">d)))</span>
    <span class="s1">np.testing.assert_allclose(off0</span><span class="s0">, </span><span class="s1">sc.get_offsets())</span>


<span class="s1">@image_comparison(baseline_images=[</span><span class="s4">&quot;test_check_masked_offsets&quot;</span><span class="s1">]</span><span class="s0">,</span>
                  <span class="s1">extensions=[</span><span class="s4">&quot;png&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True, </span><span class="s1">style=</span><span class="s4">&quot;mpl20&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_check_masked_offsets():</span>
    <span class="s5"># Check if masked data is respected by scatter</span>
    <span class="s5"># Ref: Issue #24545</span>
    <span class="s1">unmasked_x = [</span>
        <span class="s1">datetime(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">49</span><span class="s0">, </span><span class="s3">52</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">datetime(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">49</span><span class="s0">, </span><span class="s3">53</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">datetime(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">49</span><span class="s0">, </span><span class="s3">54</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">datetime(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">49</span><span class="s0">, </span><span class="s3">55</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">datetime(</span><span class="s3">2022</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">49</span><span class="s0">, </span><span class="s3">56</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s1">masked_y = np.ma.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">ax.scatter(unmasked_x</span><span class="s0">, </span><span class="s1">masked_y)</span>


<span class="s1">@check_figures_equal(extensions=[</span><span class="s4">&quot;png&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_masked_set_offsets(fig_ref</span><span class="s0">, </span><span class="s1">fig_test):</span>
    <span class="s1">x = np.ma.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">y = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

    <span class="s1">ax_test = fig_test.add_subplot()</span>
    <span class="s1">scat = ax_test.scatter(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">scat.set_offsets(np.ma.column_stack([x</span><span class="s0">, </span><span class="s1">y]))</span>
    <span class="s1">ax_test.set_xticks([])</span>
    <span class="s1">ax_test.set_yticks([])</span>

    <span class="s1">ax_ref = fig_ref.add_subplot()</span>
    <span class="s1">ax_ref.scatter([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">ax_ref.set_xticks([])</span>
    <span class="s1">ax_ref.set_yticks([])</span>


<span class="s0">def </span><span class="s1">test_check_offsets_dtype():</span>
    <span class="s5"># Check that setting offsets doesn't change dtype</span>
    <span class="s1">x = np.ma.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">y = np.arange(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">scat = ax.scatter(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">masked_offsets = np.ma.column_stack([x</span><span class="s0">, </span><span class="s1">y])</span>
    <span class="s1">scat.set_offsets(masked_offsets)</span>
    <span class="s0">assert </span><span class="s1">isinstance(scat.get_offsets()</span><span class="s0">, </span><span class="s1">type(masked_offsets))</span>

    <span class="s1">unmasked_offsets = np.column_stack([x</span><span class="s0">, </span><span class="s1">y])</span>
    <span class="s1">scat.set_offsets(unmasked_offsets)</span>
    <span class="s0">assert </span><span class="s1">isinstance(scat.get_offsets()</span><span class="s0">, </span><span class="s1">type(unmasked_offsets))</span>
</pre>
</body>
</html>