<html>
<head>
<title>transforms.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
transforms.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Matplotlib includes a framework for arbitrary geometric 
transformations that is used determine the final position of all 
elements drawn on the canvas. 
 
Transforms are composed into trees of `TransformNode` objects 
whose actual value depends on their children.  When the contents of 
children change, their parents are automatically invalidated.  The 
next time an invalidated transform is accessed, it is recomputed to 
reflect those changes.  This invalidation/caching approach prevents 
unnecessary recomputations of transforms, and contributes to better 
interactive performance. 
 
For example, here is a graph of the transform tree used to plot data 
to the graph: 
 
.. image:: ../_static/transforms.png 
 
The framework can be used for both affine and non-affine 
transformations.  However, for speed, we want to use the backend 
renderers to perform affine transformations whenever possible. 
Therefore, it is possible to perform just the affine or non-affine 
part of a transformation on a set of data.  The affine is always 
assumed to occur after the non-affine.  For any transform:: 
 
  full transform == non-affine part + affine part 
 
The backends are not expected to handle non-affine transformations 
themselves. 
 
See the tutorial :doc:`/tutorials/advanced/transforms_tutorial` for examples 
of how to use transforms. 
&quot;&quot;&quot;</span>

<span class="s2"># Note: There are a number of places in the code where we use `np.min` or</span>
<span class="s2"># `np.minimum` instead of the builtin `min`, and likewise for `max`.  This is</span>
<span class="s2"># done so that `nan`s are propagated, instead of being silently dropped.</span>

<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">textwrap</span>
<span class="s3">import </span><span class="s1">weakref</span>
<span class="s3">import </span><span class="s1">math</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.linalg </span><span class="s3">import </span><span class="s1">inv</span>

<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">_api</span>
<span class="s3">from </span><span class="s1">matplotlib._path </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">affine_transform</span><span class="s3">, </span><span class="s1">count_bboxes_overlapping_bbox</span><span class="s3">, </span><span class="s1">update_path_extents)</span>
<span class="s3">from </span><span class="s1">.path </span><span class="s3">import </span><span class="s1">Path</span>

<span class="s1">DEBUG = </span><span class="s3">False</span>


<span class="s3">def </span><span class="s1">_make_str_method(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate a ``__str__`` method for a `.Transform` subclass. 
 
    After :: 
 
        class T: 
            __str__ = _make_str_method(&quot;attr&quot;, key=&quot;other&quot;) 
 
    ``str(T(...))`` will be 
 
    .. code-block:: text 
 
        {type(T).__name__}( 
            {self.attr}, 
            key={self.other}) 
    &quot;&quot;&quot;</span>
    <span class="s1">indent = functools.partial(textwrap.indent</span><span class="s3">, </span><span class="s1">prefix=</span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">strrepr(x): </span><span class="s3">return </span><span class="s1">repr(x) </span><span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">else </span><span class="s1">str(x)</span>
    <span class="s3">return lambda </span><span class="s1">self: (</span>
        <span class="s1">type(self).__name__ + </span><span class="s4">&quot;(&quot;</span>
        <span class="s1">+ </span><span class="s4">&quot;,&quot;</span><span class="s1">.join([*(indent(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">+ strrepr(getattr(self</span><span class="s3">, </span><span class="s1">arg)))</span>
                      <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args)</span><span class="s3">,</span>
                    <span class="s1">*(indent(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">+ k + </span><span class="s4">&quot;=&quot; </span><span class="s1">+ strrepr(getattr(self</span><span class="s3">, </span><span class="s1">arg)))</span>
                      <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">kwargs.items())])</span>
        <span class="s1">+ </span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TransformNode:</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class for anything that participates in the transform tree 
    and needs to invalidate its parents or be invalidated.  This includes 
    classes that are not really transforms, such as bounding boxes, since some 
    transforms depend on bounding boxes to compute their values. 
    &quot;&quot;&quot;</span>

    <span class="s2"># Invalidation may affect only the affine part.  If the</span>
    <span class="s2"># invalidation was &quot;affine-only&quot;, the _invalid member is set to</span>
    <span class="s2"># INVALID_AFFINE_ONLY</span>
    <span class="s1">INVALID_NON_AFFINE = </span><span class="s5">1</span>
    <span class="s1">INVALID_AFFINE = </span><span class="s5">2</span>
    <span class="s1">INVALID = INVALID_NON_AFFINE | INVALID_AFFINE</span>

    <span class="s2"># Some metadata about the transform, used to determine whether an</span>
    <span class="s2"># invalidation is affine-only</span>
    <span class="s1">is_affine = </span><span class="s3">False</span>
    <span class="s1">is_bbox = </span><span class="s3">False</span>

    <span class="s1">pass_through = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot; 
    If pass_through is True, all ancestors will always be 
    invalidated, even if 'self' is already invalid. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">shorthand_name=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        shorthand_name : str 
            A string representing the &quot;name&quot; of the transform. The name carries 
            no significance other than to improve the readability of 
            ``str(transform)`` when DEBUG=True. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parents = {}</span>

        <span class="s2"># TransformNodes start out as invalid until their values are</span>
        <span class="s2"># computed for the first time.</span>
        <span class="s1">self._invalid = </span><span class="s5">1</span>
        <span class="s1">self._shorthand_name = shorthand_name </span><span class="s3">or </span><span class="s4">''</span>

    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s3">def </span><span class="s1">__str__(self):</span>
            <span class="s2"># either just return the name of this TransformNode, or its repr</span>
            <span class="s3">return </span><span class="s1">self._shorthand_name </span><span class="s3">or </span><span class="s1">repr(self)</span>

    <span class="s3">def </span><span class="s1">__getstate__(self):</span>
        <span class="s2"># turn the dictionary with weak values into a normal dictionary</span>
        <span class="s3">return </span><span class="s1">{**self.__dict__</span><span class="s3">,</span>
                <span class="s4">'_parents'</span><span class="s1">: {k: v() </span><span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self._parents.items()}}</span>

    <span class="s3">def </span><span class="s1">__setstate__(self</span><span class="s3">, </span><span class="s1">data_dict):</span>
        <span class="s1">self.__dict__ = data_dict</span>
        <span class="s2"># turn the normal dictionary back into a dictionary with weak values</span>
        <span class="s2"># The extra lambda is to provide a callback to remove dead</span>
        <span class="s2"># weakrefs from the dictionary when garbage collection is done.</span>
        <span class="s1">self._parents = {</span>
            <span class="s1">k: weakref.ref(v</span><span class="s3">, lambda </span><span class="s1">_</span><span class="s3">, </span><span class="s1">pop=self._parents.pop</span><span class="s3">, </span><span class="s1">k=k: pop(k))</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">self._parents.items() </span><span class="s3">if </span><span class="s1">v </span><span class="s3">is not None</span><span class="s1">}</span>

    <span class="s3">def </span><span class="s1">__copy__(self):</span>
        <span class="s1">other = copy.copy(super())</span>
        <span class="s2"># If `c = a + b; a1 = copy(a)`, then modifications to `a1` do not</span>
        <span class="s2"># propagate back to `c`, i.e. we need to clear the parents of `a1`.</span>
        <span class="s1">other._parents = {}</span>
        <span class="s2"># If `c = a + b; c1 = copy(c)`, then modifications to `a` also need to</span>
        <span class="s2"># be propagated to `c1`.</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">val </span><span class="s3">in </span><span class="s1">vars(self).items():</span>
            <span class="s3">if </span><span class="s1">isinstance(val</span><span class="s3">, </span><span class="s1">TransformNode) </span><span class="s3">and </span><span class="s1">id(self) </span><span class="s3">in </span><span class="s1">val._parents:</span>
                <span class="s1">other.set_children(val)  </span><span class="s2"># val == getattr(other, key)</span>
        <span class="s3">return </span><span class="s1">other</span>

    <span class="s3">def </span><span class="s1">invalidate(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Invalidate this `TransformNode` and triggers an invalidation of its 
        ancestors.  Should be called any time the transform changes. 
        &quot;&quot;&quot;</span>
        <span class="s1">value = self.INVALID</span>
        <span class="s3">if </span><span class="s1">self.is_affine:</span>
            <span class="s1">value = self.INVALID_AFFINE</span>
        <span class="s3">return </span><span class="s1">self._invalidate_internal(value</span><span class="s3">, </span><span class="s1">invalidating_node=self)</span>

    <span class="s3">def </span><span class="s1">_invalidate_internal(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">invalidating_node):</span>
        <span class="s0">&quot;&quot;&quot; 
        Called by :meth:`invalidate` and subsequently ascends the transform 
        stack calling each TransformNode's _invalidate_internal method. 
        &quot;&quot;&quot;</span>
        <span class="s2"># determine if this call will be an extension to the invalidation</span>
        <span class="s2"># status. If not, then a shortcut means that we needn't invoke an</span>
        <span class="s2"># invalidation up the transform stack as it will already have been</span>
        <span class="s2"># invalidated.</span>

        <span class="s2"># N.B This makes the invalidation sticky, once a transform has been</span>
        <span class="s2"># invalidated as NON_AFFINE, then it will always be invalidated as</span>
        <span class="s2"># NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.</span>
        <span class="s2"># In most cases this is not a problem (i.e. for interactive panning and</span>
        <span class="s2"># zooming) and the only side effect will be on performance.</span>
        <span class="s1">status_changed = self._invalid &lt; value</span>

        <span class="s3">if </span><span class="s1">self.pass_through </span><span class="s3">or </span><span class="s1">status_changed:</span>
            <span class="s1">self._invalid = value</span>

            <span class="s3">for </span><span class="s1">parent </span><span class="s3">in </span><span class="s1">list(self._parents.values()):</span>
                <span class="s2"># Dereference the weak reference</span>
                <span class="s1">parent = parent()</span>
                <span class="s3">if </span><span class="s1">parent </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">parent._invalidate_internal(</span>
                        <span class="s1">value=value</span><span class="s3">, </span><span class="s1">invalidating_node=self)</span>

    <span class="s3">def </span><span class="s1">set_children(self</span><span class="s3">, </span><span class="s1">*children):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the children of the transform, to let the invalidation 
        system know which transforms can invalidate this transform. 
        Should be called from the constructor of any transforms that 
        depend on other transforms. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Parents are stored as weak references, so that if the</span>
        <span class="s2"># parents are destroyed, references from the children won't</span>
        <span class="s2"># keep them alive.</span>
        <span class="s3">for </span><span class="s1">child </span><span class="s3">in </span><span class="s1">children:</span>
            <span class="s2"># Use weak references so this dictionary won't keep obsolete nodes</span>
            <span class="s2"># alive; the callback deletes the dictionary entry. This is a</span>
            <span class="s2"># performance improvement over using WeakValueDictionary.</span>
            <span class="s1">ref = weakref.ref(</span>
                <span class="s1">self</span><span class="s3">, lambda </span><span class="s1">_</span><span class="s3">, </span><span class="s1">pop=child._parents.pop</span><span class="s3">, </span><span class="s1">k=id(self): pop(k))</span>
            <span class="s1">child._parents[id(self)] = ref</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a frozen copy of this transform node.  The frozen copy will not 
        be updated when its children change.  Useful for storing a previously 
        known state of a transform where ``copy.deepcopy()`` might normally be 
        used. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">BboxBase(TransformNode):</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class of all bounding boxes. 
 
    This class is immutable; `Bbox` is a mutable subclass. 
 
    The canonical representation is as two points, with no 
    restrictions on their ordering.  Convenience properties are 
    provided to get the left, bottom, right and top edges and width 
    and height, but these are not stored explicitly. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_bbox = </span><span class="s3">True</span>
    <span class="s1">is_affine = </span><span class="s3">True</span>

    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s1">@staticmethod</span>
        <span class="s3">def </span><span class="s1">_check(points):</span>
            <span class="s3">if </span><span class="s1">isinstance(points</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray):</span>
                <span class="s1">_api.warn_external(</span><span class="s4">&quot;Bbox bounds are a masked array.&quot;</span><span class="s1">)</span>
            <span class="s1">points = np.asarray(points)</span>
            <span class="s3">if </span><span class="s1">any((points[</span><span class="s5">1</span><span class="s3">, </span><span class="s1">:] - points[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">:]) == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s1">_api.warn_external(</span><span class="s4">&quot;Singular Bbox.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s3">return </span><span class="s1">Bbox(self.get_points().copy())</span>
    <span class="s1">frozen.__doc__ = TransformNode.__doc__</span>

    <span class="s3">def </span><span class="s1">__array__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">return </span><span class="s1">self.get_points()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">x0(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The first of the pair of *x* coordinates that define the bounding box. 
 
        This is not guaranteed to be less than :attr:`x1` (for that, use 
        :attr:`xmin`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">y0(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The first of the pair of *y* coordinates that define the bounding box. 
 
        This is not guaranteed to be less than :attr:`y1` (for that, use 
        :attr:`ymin`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">x1(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The second of the pair of *x* coordinates that define the bounding box. 
 
        This is not guaranteed to be greater than :attr:`x0` (for that, use 
        :attr:`xmax`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">y1(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The second of the pair of *y* coordinates that define the bounding box. 
 
        This is not guaranteed to be greater than :attr:`y0` (for that, use 
        :attr:`ymax`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">p0(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The first pair of (*x*, *y*) coordinates that define the bounding box. 
 
        This is not guaranteed to be the bottom-left corner (for that, use 
        :attr:`min`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">p1(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The second pair of (*x*, *y*) coordinates that define the bounding box. 
 
        This is not guaranteed to be the top-right corner (for that, use 
        :attr:`max`). 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">xmin(self):</span>
        <span class="s0">&quot;&quot;&quot;The left edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.min(self.get_points()[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">ymin(self):</span>
        <span class="s0">&quot;&quot;&quot;The bottom edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.min(self.get_points()[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">xmax(self):</span>
        <span class="s0">&quot;&quot;&quot;The right edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.max(self.get_points()[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">ymax(self):</span>
        <span class="s0">&quot;&quot;&quot;The top edge of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.max(self.get_points()[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">min(self):</span>
        <span class="s0">&quot;&quot;&quot;The bottom-left corner of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.min(self.get_points()</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">max(self):</span>
        <span class="s0">&quot;&quot;&quot;The top-right corner of the bounding box.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.max(self.get_points()</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">intervalx(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The pair of *x* coordinates that define the bounding box. 
 
        This is not guaranteed to be sorted from left to right. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">intervaly(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The pair of *y* coordinates that define the bounding box. 
 
        This is not guaranteed to be sorted from bottom to top. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points()[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">width(self):</span>
        <span class="s0">&quot;&quot;&quot;The (signed) width of the bounding box.&quot;&quot;&quot;</span>
        <span class="s1">points = self.get_points()</span>
        <span class="s3">return </span><span class="s1">points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] - points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">height(self):</span>
        <span class="s0">&quot;&quot;&quot;The (signed) height of the bounding box.&quot;&quot;&quot;</span>
        <span class="s1">points = self.get_points()</span>
        <span class="s3">return </span><span class="s1">points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] - points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">size(self):</span>
        <span class="s0">&quot;&quot;&quot;The (signed) width and height of the bounding box.&quot;&quot;&quot;</span>
        <span class="s1">points = self.get_points()</span>
        <span class="s3">return </span><span class="s1">points[</span><span class="s5">1</span><span class="s1">] - points[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">bounds(self):</span>
        <span class="s0">&quot;&quot;&quot;Return (:attr:`x0`, :attr:`y0`, :attr:`width`, :attr:`height`).&quot;&quot;&quot;</span>
        <span class="s1">(x0</span><span class="s3">, </span><span class="s1">y0)</span><span class="s3">, </span><span class="s1">(x1</span><span class="s3">, </span><span class="s1">y1) = self.get_points()</span>
        <span class="s3">return </span><span class="s1">(x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">x1 - x0</span><span class="s3">, </span><span class="s1">y1 - y0)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">extents(self):</span>
        <span class="s0">&quot;&quot;&quot;Return (:attr:`x0`, :attr:`y0`, :attr:`x1`, :attr:`y1`).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_points().flatten()  </span><span class="s2"># flatten returns a copy.</span>

    <span class="s3">def </span><span class="s1">get_points(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">containsx(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether *x* is in the closed (:attr:`x0`, :attr:`x1`) interval. 
        &quot;&quot;&quot;</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">x1 = self.intervalx</span>
        <span class="s3">return </span><span class="s1">x0 &lt;= x &lt;= x1 </span><span class="s3">or </span><span class="s1">x0 &gt;= x &gt;= x1</span>

    <span class="s3">def </span><span class="s1">containsy(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether *y* is in the closed (:attr:`y0`, :attr:`y1`) interval. 
        &quot;&quot;&quot;</span>
        <span class="s1">y0</span><span class="s3">, </span><span class="s1">y1 = self.intervaly</span>
        <span class="s3">return </span><span class="s1">y0 &lt;= y &lt;= y1 </span><span class="s3">or </span><span class="s1">y0 &gt;= y &gt;= y1</span>

    <span class="s3">def </span><span class="s1">contains(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether ``(x, y)`` is in the bounding box or on its edge. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.containsx(x) </span><span class="s3">and </span><span class="s1">self.containsy(y)</span>

    <span class="s3">def </span><span class="s1">overlaps(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether this bounding box overlaps with the other bounding box. 
 
        Parameters 
        ---------- 
        other : `.BboxBase` 
        &quot;&quot;&quot;</span>
        <span class="s1">ax1</span><span class="s3">, </span><span class="s1">ay1</span><span class="s3">, </span><span class="s1">ax2</span><span class="s3">, </span><span class="s1">ay2 = self.extents</span>
        <span class="s1">bx1</span><span class="s3">, </span><span class="s1">by1</span><span class="s3">, </span><span class="s1">bx2</span><span class="s3">, </span><span class="s1">by2 = other.extents</span>
        <span class="s3">if </span><span class="s1">ax2 &lt; ax1:</span>
            <span class="s1">ax2</span><span class="s3">, </span><span class="s1">ax1 = ax1</span><span class="s3">, </span><span class="s1">ax2</span>
        <span class="s3">if </span><span class="s1">ay2 &lt; ay1:</span>
            <span class="s1">ay2</span><span class="s3">, </span><span class="s1">ay1 = ay1</span><span class="s3">, </span><span class="s1">ay2</span>
        <span class="s3">if </span><span class="s1">bx2 &lt; bx1:</span>
            <span class="s1">bx2</span><span class="s3">, </span><span class="s1">bx1 = bx1</span><span class="s3">, </span><span class="s1">bx2</span>
        <span class="s3">if </span><span class="s1">by2 &lt; by1:</span>
            <span class="s1">by2</span><span class="s3">, </span><span class="s1">by1 = by1</span><span class="s3">, </span><span class="s1">by2</span>
        <span class="s3">return </span><span class="s1">ax1 &lt;= bx2 </span><span class="s3">and </span><span class="s1">bx1 &lt;= ax2 </span><span class="s3">and </span><span class="s1">ay1 &lt;= by2 </span><span class="s3">and </span><span class="s1">by1 &lt;= ay2</span>

    <span class="s3">def </span><span class="s1">fully_containsx(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether *x* is in the open (:attr:`x0`, :attr:`x1`) interval. 
        &quot;&quot;&quot;</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">x1 = self.intervalx</span>
        <span class="s3">return </span><span class="s1">x0 &lt; x &lt; x1 </span><span class="s3">or </span><span class="s1">x0 &gt; x &gt; x1</span>

    <span class="s3">def </span><span class="s1">fully_containsy(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether *y* is in the open (:attr:`y0`, :attr:`y1`) interval. 
        &quot;&quot;&quot;</span>
        <span class="s1">y0</span><span class="s3">, </span><span class="s1">y1 = self.intervaly</span>
        <span class="s3">return </span><span class="s1">y0 &lt; y &lt; y1 </span><span class="s3">or </span><span class="s1">y0 &gt; y &gt; y1</span>

    <span class="s3">def </span><span class="s1">fully_contains(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether ``x, y`` is in the bounding box, but not on its edge. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.fully_containsx(x) </span><span class="s3">and </span><span class="s1">self.fully_containsy(y)</span>

    <span class="s3">def </span><span class="s1">fully_overlaps(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether this bounding box overlaps with the other bounding box, 
        not including the edges. 
 
        Parameters 
        ---------- 
        other : `.BboxBase` 
        &quot;&quot;&quot;</span>
        <span class="s1">ax1</span><span class="s3">, </span><span class="s1">ay1</span><span class="s3">, </span><span class="s1">ax2</span><span class="s3">, </span><span class="s1">ay2 = self.extents</span>
        <span class="s1">bx1</span><span class="s3">, </span><span class="s1">by1</span><span class="s3">, </span><span class="s1">bx2</span><span class="s3">, </span><span class="s1">by2 = other.extents</span>
        <span class="s3">if </span><span class="s1">ax2 &lt; ax1:</span>
            <span class="s1">ax2</span><span class="s3">, </span><span class="s1">ax1 = ax1</span><span class="s3">, </span><span class="s1">ax2</span>
        <span class="s3">if </span><span class="s1">ay2 &lt; ay1:</span>
            <span class="s1">ay2</span><span class="s3">, </span><span class="s1">ay1 = ay1</span><span class="s3">, </span><span class="s1">ay2</span>
        <span class="s3">if </span><span class="s1">bx2 &lt; bx1:</span>
            <span class="s1">bx2</span><span class="s3">, </span><span class="s1">bx1 = bx1</span><span class="s3">, </span><span class="s1">bx2</span>
        <span class="s3">if </span><span class="s1">by2 &lt; by1:</span>
            <span class="s1">by2</span><span class="s3">, </span><span class="s1">by1 = by1</span><span class="s3">, </span><span class="s1">by2</span>
        <span class="s3">return </span><span class="s1">ax1 &lt; bx2 </span><span class="s3">and </span><span class="s1">bx1 &lt; ax2 </span><span class="s3">and </span><span class="s1">ay1 &lt; by2 </span><span class="s3">and </span><span class="s1">by1 &lt; ay2</span>

    <span class="s3">def </span><span class="s1">transformed(self</span><span class="s3">, </span><span class="s1">transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a `Bbox` by statically transforming this one by *transform*. 
        &quot;&quot;&quot;</span>
        <span class="s1">pts = self.get_points()</span>
        <span class="s1">ll</span><span class="s3">, </span><span class="s1">ul</span><span class="s3">, </span><span class="s1">lr = transform.transform(np.array(</span>
            <span class="s1">[pts[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[pts[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">pts[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">[pts[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">pts[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]]))</span>
        <span class="s3">return </span><span class="s1">Bbox([ll</span><span class="s3">, </span><span class="s1">[lr[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ul[</span><span class="s5">1</span><span class="s1">]]])</span>

    <span class="s1">coefs = {</span><span class="s4">'C'</span><span class="s1">:  (</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'SW'</span><span class="s1">: (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'S'</span><span class="s1">:  (</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'SE'</span><span class="s1">: (</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'E'</span><span class="s1">:  (</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'NE'</span><span class="s1">: (</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'N'</span><span class="s1">:  (</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'NW'</span><span class="s1">: (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s3">,</span>
             <span class="s4">'W'</span><span class="s1">:  (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s1">)}</span>

    <span class="s3">def </span><span class="s1">anchored(self</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">container=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the `Bbox` anchored to *c* within *container*. 
 
        Parameters 
        ---------- 
        c : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...} 
            Either an (*x*, *y*) pair of relative coordinates (0 is left or 
            bottom, 1 is right or top), 'C' (center), or a cardinal direction 
            ('SW', southwest, is bottom left, etc.). 
        container : `Bbox`, optional 
            The box within which the `Bbox` is positioned; it defaults 
            to the initial `Bbox`. 
 
        See Also 
        -------- 
        .Axes.set_anchor 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">container </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">container = self</span>
        <span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h = container.bounds</span>
        <span class="s3">if </span><span class="s1">isinstance(c</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = self.coefs[c]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = c</span>
        <span class="s1">L</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">W</span><span class="s3">, </span><span class="s1">H = self.bounds</span>
        <span class="s3">return </span><span class="s1">Bbox(self._points +</span>
                    <span class="s1">[(l + cx * (w - W)) - L</span><span class="s3">,</span>
                     <span class="s1">(b + cy * (h - H)) - B])</span>

    <span class="s3">def </span><span class="s1">shrunk(self</span><span class="s3">, </span><span class="s1">mx</span><span class="s3">, </span><span class="s1">my):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the `Bbox`, shrunk by the factor *mx* 
        in the *x* direction and the factor *my* in the *y* direction. 
        The lower left corner of the box remains unchanged.  Normally 
        *mx* and *my* will be less than 1, but this is not enforced. 
        &quot;&quot;&quot;</span>
        <span class="s1">w</span><span class="s3">, </span><span class="s1">h = self.size</span>
        <span class="s3">return </span><span class="s1">Bbox([self._points[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">self._points[</span><span class="s5">0</span><span class="s1">] + [mx * w</span><span class="s3">, </span><span class="s1">my * h]])</span>

    <span class="s3">def </span><span class="s1">shrunk_to_aspect(self</span><span class="s3">, </span><span class="s1">box_aspect</span><span class="s3">, </span><span class="s1">container=</span><span class="s3">None, </span><span class="s1">fig_aspect=</span><span class="s5">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the `Bbox`, shrunk so that it is as 
        large as it can be while having the desired aspect ratio, 
        *box_aspect*.  If the box coordinates are relative (i.e. 
        fractions of a larger box such as a figure) then the 
        physical aspect ratio of that figure is specified with 
        *fig_aspect*, so that *box_aspect* can also be given as a 
        ratio of the absolute dimensions, not the relative dimensions. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">box_aspect &lt;= </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">fig_aspect &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'box_aspect' and 'fig_aspect' must be positive&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">container </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">container = self</span>
        <span class="s1">w</span><span class="s3">, </span><span class="s1">h = container.size</span>
        <span class="s1">H = w * box_aspect / fig_aspect</span>
        <span class="s3">if </span><span class="s1">H &lt;= h:</span>
            <span class="s1">W = w</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">W = h * fig_aspect / box_aspect</span>
            <span class="s1">H = h</span>
        <span class="s3">return </span><span class="s1">Bbox([self._points[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">self._points[</span><span class="s5">0</span><span class="s1">] + (W</span><span class="s3">, </span><span class="s1">H)])</span>

    <span class="s3">def </span><span class="s1">splitx(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of new `Bbox` objects formed by splitting the original 
        one with vertical lines at fractional positions given by *args*. 
        &quot;&quot;&quot;</span>
        <span class="s1">xf = [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">y1 = self.extents</span>
        <span class="s1">w = x1 - x0</span>
        <span class="s3">return </span><span class="s1">[Bbox([[x0 + xf0 * w</span><span class="s3">, </span><span class="s1">y0]</span><span class="s3">, </span><span class="s1">[x0 + xf1 * w</span><span class="s3">, </span><span class="s1">y1]])</span>
                <span class="s3">for </span><span class="s1">xf0</span><span class="s3">, </span><span class="s1">xf1 </span><span class="s3">in </span><span class="s1">zip(xf[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">xf[</span><span class="s5">1</span><span class="s1">:])]</span>

    <span class="s3">def </span><span class="s1">splity(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of new `Bbox` objects formed by splitting the original 
        one with horizontal lines at fractional positions given by *args*. 
        &quot;&quot;&quot;</span>
        <span class="s1">yf = [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">y1 = self.extents</span>
        <span class="s1">h = y1 - y0</span>
        <span class="s3">return </span><span class="s1">[Bbox([[x0</span><span class="s3">, </span><span class="s1">y0 + yf0 * h]</span><span class="s3">, </span><span class="s1">[x1</span><span class="s3">, </span><span class="s1">y0 + yf1 * h]])</span>
                <span class="s3">for </span><span class="s1">yf0</span><span class="s3">, </span><span class="s1">yf1 </span><span class="s3">in </span><span class="s1">zip(yf[:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">yf[</span><span class="s5">1</span><span class="s1">:])]</span>

    <span class="s3">def </span><span class="s1">count_contains(self</span><span class="s3">, </span><span class="s1">vertices):</span>
        <span class="s0">&quot;&quot;&quot; 
        Count the number of vertices contained in the `Bbox`. 
        Any vertices with a non-finite x or y value are ignored. 
 
        Parameters 
        ---------- 
        vertices : Nx2 Numpy array. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(vertices) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s5">0</span>
        <span class="s1">vertices = np.asarray(vertices)</span>
        <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">(((self.min &lt; vertices) &amp;</span>
                     <span class="s1">(vertices &lt; self.max)).all(axis=</span><span class="s5">1</span><span class="s1">).sum())</span>

    <span class="s3">def </span><span class="s1">count_overlaps(self</span><span class="s3">, </span><span class="s1">bboxes):</span>
        <span class="s0">&quot;&quot;&quot; 
        Count the number of bounding boxes that overlap this one. 
 
        Parameters 
        ---------- 
        bboxes : sequence of `.BboxBase` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">count_bboxes_overlapping_bbox(</span>
            <span class="s1">self</span><span class="s3">, </span><span class="s1">np.atleast_3d([np.array(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">bboxes]))</span>

    <span class="s3">def </span><span class="s1">expanded(self</span><span class="s3">, </span><span class="s1">sw</span><span class="s3">, </span><span class="s1">sh):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a `Bbox` by expanding this one around its center by the 
        factors *sw* and *sh*. 
        &quot;&quot;&quot;</span>
        <span class="s1">width = self.width</span>
        <span class="s1">height = self.height</span>
        <span class="s1">deltaw = (sw * width - width) / </span><span class="s5">2.0</span>
        <span class="s1">deltah = (sh * height - height) / </span><span class="s5">2.0</span>
        <span class="s1">a = np.array([[-deltaw</span><span class="s3">, </span><span class="s1">-deltah]</span><span class="s3">, </span><span class="s1">[deltaw</span><span class="s3">, </span><span class="s1">deltah]])</span>
        <span class="s3">return </span><span class="s1">Bbox(self._points + a)</span>

    <span class="s3">def </span><span class="s1">padded(self</span><span class="s3">, </span><span class="s1">p):</span>
        <span class="s0">&quot;&quot;&quot;Construct a `Bbox` by padding this one on all four sides by *p*.&quot;&quot;&quot;</span>
        <span class="s1">points = self.get_points()</span>
        <span class="s3">return </span><span class="s1">Bbox(points + [[-p</span><span class="s3">, </span><span class="s1">-p]</span><span class="s3">, </span><span class="s1">[p</span><span class="s3">, </span><span class="s1">p]])</span>

    <span class="s3">def </span><span class="s1">translated(self</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty):</span>
        <span class="s0">&quot;&quot;&quot;Construct a `Bbox` by translating this one by *tx* and *ty*.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bbox(self._points + (tx</span><span class="s3">, </span><span class="s1">ty))</span>

    <span class="s3">def </span><span class="s1">corners(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the corners of this rectangle as an array of points. 
 
        Specifically, this returns the array 
        ``[[x0, y0], [x0, y1], [x1, y0], [x1, y1]]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">(x0</span><span class="s3">, </span><span class="s1">y0)</span><span class="s3">, </span><span class="s1">(x1</span><span class="s3">, </span><span class="s1">y1) = self.get_points()</span>
        <span class="s3">return </span><span class="s1">np.array([[x0</span><span class="s3">, </span><span class="s1">y0]</span><span class="s3">, </span><span class="s1">[x0</span><span class="s3">, </span><span class="s1">y1]</span><span class="s3">, </span><span class="s1">[x1</span><span class="s3">, </span><span class="s1">y0]</span><span class="s3">, </span><span class="s1">[x1</span><span class="s3">, </span><span class="s1">y1]])</span>

    <span class="s3">def </span><span class="s1">rotated(self</span><span class="s3">, </span><span class="s1">radians):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the axes-aligned bounding box that bounds the result of rotating 
        this `Bbox` by an angle of *radians*. 
        &quot;&quot;&quot;</span>
        <span class="s1">corners = self.corners()</span>
        <span class="s1">corners_rotated = Affine2D().rotate(radians).transform(corners)</span>
        <span class="s1">bbox = Bbox.unit()</span>
        <span class="s1">bbox.update_from_data_xy(corners_rotated</span><span class="s3">, </span><span class="s1">ignore=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">bbox</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">union(bboxes):</span>
        <span class="s0">&quot;&quot;&quot;Return a `Bbox` that contains all of the given *bboxes*.&quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">len(bboxes):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'bboxes' cannot be empty&quot;</span><span class="s1">)</span>
        <span class="s1">x0 = np.min([bbox.xmin </span><span class="s3">for </span><span class="s1">bbox </span><span class="s3">in </span><span class="s1">bboxes])</span>
        <span class="s1">x1 = np.max([bbox.xmax </span><span class="s3">for </span><span class="s1">bbox </span><span class="s3">in </span><span class="s1">bboxes])</span>
        <span class="s1">y0 = np.min([bbox.ymin </span><span class="s3">for </span><span class="s1">bbox </span><span class="s3">in </span><span class="s1">bboxes])</span>
        <span class="s1">y1 = np.max([bbox.ymax </span><span class="s3">for </span><span class="s1">bbox </span><span class="s3">in </span><span class="s1">bboxes])</span>
        <span class="s3">return </span><span class="s1">Bbox([[x0</span><span class="s3">, </span><span class="s1">y0]</span><span class="s3">, </span><span class="s1">[x1</span><span class="s3">, </span><span class="s1">y1]])</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">intersection(bbox1</span><span class="s3">, </span><span class="s1">bbox2):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the intersection of *bbox1* and *bbox2* if they intersect, or 
        None if they don't. 
        &quot;&quot;&quot;</span>
        <span class="s1">x0 = np.maximum(bbox1.xmin</span><span class="s3">, </span><span class="s1">bbox2.xmin)</span>
        <span class="s1">x1 = np.minimum(bbox1.xmax</span><span class="s3">, </span><span class="s1">bbox2.xmax)</span>
        <span class="s1">y0 = np.maximum(bbox1.ymin</span><span class="s3">, </span><span class="s1">bbox2.ymin)</span>
        <span class="s1">y1 = np.minimum(bbox1.ymax</span><span class="s3">, </span><span class="s1">bbox2.ymax)</span>
        <span class="s3">return </span><span class="s1">Bbox([[x0</span><span class="s3">, </span><span class="s1">y0]</span><span class="s3">, </span><span class="s1">[x1</span><span class="s3">, </span><span class="s1">y1]]) </span><span class="s3">if </span><span class="s1">x0 &lt;= x1 </span><span class="s3">and </span><span class="s1">y0 &lt;= y1 </span><span class="s3">else None</span>


<span class="s3">class </span><span class="s1">Bbox(BboxBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A mutable bounding box. 
 
    Examples 
    -------- 
    **Create from known bounds** 
 
    The default constructor takes the boundary &quot;points&quot; ``[[xmin, ymin], 
    [xmax, ymax]]``. 
 
        &gt;&gt;&gt; Bbox([[1, 1], [3, 7]]) 
        Bbox([[1.0, 1.0], [3.0, 7.0]]) 
 
    Alternatively, a Bbox can be created from the flattened points array, the 
    so-called &quot;extents&quot; ``(xmin, ymin, xmax, ymax)`` 
 
        &gt;&gt;&gt; Bbox.from_extents(1, 1, 3, 7) 
        Bbox([[1.0, 1.0], [3.0, 7.0]]) 
 
    or from the &quot;bounds&quot; ``(xmin, ymin, width, height)``. 
 
        &gt;&gt;&gt; Bbox.from_bounds(1, 1, 2, 6) 
        Bbox([[1.0, 1.0], [3.0, 7.0]]) 
 
    **Create from collections of points** 
 
    The &quot;empty&quot; object for accumulating Bboxs is the null bbox, which is a 
    stand-in for the empty set. 
 
        &gt;&gt;&gt; Bbox.null() 
        Bbox([[inf, inf], [-inf, -inf]]) 
 
    Adding points to the null bbox will give you the bbox of those points. 
 
        &gt;&gt;&gt; box = Bbox.null() 
        &gt;&gt;&gt; box.update_from_data_xy([[1, 1]]) 
        &gt;&gt;&gt; box 
        Bbox([[1.0, 1.0], [1.0, 1.0]]) 
        &gt;&gt;&gt; box.update_from_data_xy([[2, 3], [3, 2]], ignore=False) 
        &gt;&gt;&gt; box 
        Bbox([[1.0, 1.0], [3.0, 3.0]]) 
 
    Setting ``ignore=True`` is equivalent to starting over from a null bbox. 
 
        &gt;&gt;&gt; box.update_from_data_xy([[1, 1]], ignore=True) 
        &gt;&gt;&gt; box 
        Bbox([[1.0, 1.0], [1.0, 1.0]]) 
 
    .. warning:: 
 
        It is recommended to always specify ``ignore`` explicitly.  If not, the 
        default value of ``ignore`` can be changed at any time by code with 
        access to your Bbox, for example using the method `~.Bbox.ignore`. 
 
    **Properties of the ``null`` bbox** 
 
    .. note:: 
 
        The current behavior of `Bbox.null()` may be surprising as it does 
        not have all of the properties of the &quot;empty set&quot;, and as such does 
        not behave like a &quot;zero&quot; object in the mathematical sense. We may 
        change that in the future (with a deprecation period). 
 
    The null bbox is the identity for intersections 
 
        &gt;&gt;&gt; Bbox.intersection(Bbox([[1, 1], [3, 7]]), Bbox.null()) 
        Bbox([[1.0, 1.0], [3.0, 7.0]]) 
 
    except with itself, where it returns the full space. 
 
        &gt;&gt;&gt; Bbox.intersection(Bbox.null(), Bbox.null()) 
        Bbox([[-inf, -inf], [inf, inf]]) 
 
    A union containing null will always return the full space (not the other 
    set!) 
 
        &gt;&gt;&gt; Bbox.union([Bbox([[0, 0], [0, 0]]), Bbox.null()]) 
        Bbox([[-inf, -inf], [inf, inf]]) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">points</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        points : `~numpy.ndarray` 
            A 2x2 numpy array of the form ``[[x0, y0], [x1, y1]]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">points = np.asarray(points</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s3">if </span><span class="s1">points.shape != (</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Bbox points must be of the form '</span>
                             <span class="s4">'&quot;[[x0, y0], [x1, y1]]&quot;.'</span><span class="s1">)</span>
        <span class="s1">self._points = points</span>
        <span class="s1">self._minpos = np.array([np.inf</span><span class="s3">, </span><span class="s1">np.inf])</span>
        <span class="s1">self._ignore = </span><span class="s3">True</span>
        <span class="s2"># it is helpful in some contexts to know if the bbox is a</span>
        <span class="s2"># default or has been mutated; we store the orig points to</span>
        <span class="s2"># support the mutated methods</span>
        <span class="s1">self._points_orig = self._points.copy()</span>
    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s1">___init__ = __init__</span>

        <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">points</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">self._check(points)</span>
            <span class="s1">self.___init__(points</span><span class="s3">, </span><span class="s1">**kwargs)</span>

        <span class="s3">def </span><span class="s1">invalidate(self):</span>
            <span class="s1">self._check(self._points)</span>
            <span class="s1">super().invalidate()</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">frozen_bbox = super().frozen()</span>
        <span class="s1">frozen_bbox._minpos = self.minpos.copy()</span>
        <span class="s3">return </span><span class="s1">frozen_bbox</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">unit():</span>
        <span class="s0">&quot;&quot;&quot;Create a new unit `Bbox` from (0, 0) to (1, 1).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bbox([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]])</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">null():</span>
        <span class="s0">&quot;&quot;&quot;Create a new null `Bbox` from (inf, inf) to (-inf, -inf).&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bbox([[np.inf</span><span class="s3">, </span><span class="s1">np.inf]</span><span class="s3">, </span><span class="s1">[-np.inf</span><span class="s3">, </span><span class="s1">-np.inf]])</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">from_bounds(x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">width</span><span class="s3">, </span><span class="s1">height):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new `Bbox` from *x0*, *y0*, *width* and *height*. 
 
        *width* and *height* may be negative. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bbox.from_extents(x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">x0 + width</span><span class="s3">, </span><span class="s1">y0 + height)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">from_extents(*args</span><span class="s3">, </span><span class="s1">minpos=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new Bbox from *left*, *bottom*, *right* and *top*. 
 
        The *y*-axis increases upwards. 
 
        Parameters 
        ---------- 
        left, bottom, right, top : float 
            The four extents of the bounding box. 
 
        minpos : float or None 
           If this is supplied, the Bbox will have a minimum positive value 
           set. This is useful when dealing with logarithmic scales and other 
           scales where negative bounds result in floating point errors. 
        &quot;&quot;&quot;</span>
        <span class="s1">bbox = Bbox(np.reshape(args</span><span class="s3">, </span><span class="s1">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)))</span>
        <span class="s3">if </span><span class="s1">minpos </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">bbox._minpos[:] = minpos</span>
        <span class="s3">return </span><span class="s1">bbox</span>

    <span class="s3">def </span><span class="s1">__format__(self</span><span class="s3">, </span><span class="s1">fmt):</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s4">'Bbox(x0={0.x0:{1}}, y0={0.y0:{1}}, x1={0.x1:{1}}, y1={0.y1:{1}})'</span><span class="s1">.</span>
            <span class="s1">format(self</span><span class="s3">, </span><span class="s1">fmt))</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">format(self</span><span class="s3">, </span><span class="s4">''</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">'Bbox([[{0.x0}, {0.y0}], [{0.x1}, {0.y1}]])'</span><span class="s1">.format(self)</span>

    <span class="s3">def </span><span class="s1">ignore(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the existing bounds of the box should be ignored 
        by subsequent calls to :meth:`update_from_data_xy`. 
 
        value : bool 
           - When ``True``, subsequent calls to :meth:`update_from_data_xy` 
             will ignore the existing bounds of the `Bbox`. 
 
           - When ``False``, subsequent calls to :meth:`update_from_data_xy` 
             will include the existing bounds of the `Bbox`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._ignore = value</span>

    <span class="s3">def </span><span class="s1">update_from_path(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">ignore=</span><span class="s3">None, </span><span class="s1">updatex=</span><span class="s3">True, </span><span class="s1">updatey=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the bounds of the `Bbox` to contain the vertices of the 
        provided path. After updating, the bounds will have positive *width* 
        and *height*; *x0* and *y0* will be the minimal values. 
 
        Parameters 
        ---------- 
        path : `~matplotlib.path.Path` 
 
        ignore : bool, optional 
           - when ``True``, ignore the existing bounds of the `Bbox`. 
           - when ``False``, include the existing bounds of the `Bbox`. 
           - when ``None``, use the last value passed to :meth:`ignore`. 
 
        updatex, updatey : bool, default: True 
            When ``True``, update the x/y values. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">ignore </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">ignore = self._ignore</span>

        <span class="s3">if </span><span class="s1">path.vertices.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s1">points</span><span class="s3">, </span><span class="s1">minpos</span><span class="s3">, </span><span class="s1">changed = update_path_extents(</span>
            <span class="s1">path</span><span class="s3">, None, </span><span class="s1">self._points</span><span class="s3">, </span><span class="s1">self._minpos</span><span class="s3">, </span><span class="s1">ignore)</span>

        <span class="s3">if </span><span class="s1">changed:</span>
            <span class="s1">self.invalidate()</span>
            <span class="s3">if </span><span class="s1">updatex:</span>
                <span class="s1">self._points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">self._minpos[</span><span class="s5">0</span><span class="s1">] = minpos[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">updatey:</span>
                <span class="s1">self._points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">self._minpos[</span><span class="s5">1</span><span class="s1">] = minpos[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">update_from_data_x(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">ignore=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the x-bounds of the `Bbox` based on the passed in data. After 
        updating, the bounds will have positive *width*, and *x0* will be the 
        minimal value. 
 
        Parameters 
        ---------- 
        x : `~numpy.ndarray` 
            Array of x-values. 
 
        ignore : bool, optional 
           - When ``True``, ignore the existing bounds of the `Bbox`. 
           - When ``False``, include the existing bounds of the `Bbox`. 
           - When ``None``, use the last value passed to :meth:`ignore`. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = np.ravel(x)</span>
        <span class="s1">self.update_from_data_xy(np.column_stack([x</span><span class="s3">, </span><span class="s1">np.ones(x.size)])</span><span class="s3">,</span>
                                 <span class="s1">ignore=ignore</span><span class="s3">, </span><span class="s1">updatey=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">update_from_data_y(self</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">ignore=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the y-bounds of the `Bbox` based on the passed in data. After 
        updating, the bounds will have positive *height*, and *y0* will be the 
        minimal value. 
 
        Parameters 
        ---------- 
        y : `~numpy.ndarray` 
            Array of y-values. 
 
        ignore : bool, optional 
           - When ``True``, ignore the existing bounds of the `Bbox`. 
           - When ``False``, include the existing bounds of the `Bbox`. 
           - When ``None``, use the last value passed to :meth:`ignore`. 
        &quot;&quot;&quot;</span>
        <span class="s1">y = np.ravel(y)</span>
        <span class="s1">self.update_from_data_xy(np.column_stack([np.ones(y.size)</span><span class="s3">, </span><span class="s1">y])</span><span class="s3">,</span>
                                 <span class="s1">ignore=ignore</span><span class="s3">, </span><span class="s1">updatex=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">update_from_data_xy(self</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">ignore=</span><span class="s3">None, </span><span class="s1">updatex=</span><span class="s3">True, </span><span class="s1">updatey=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the bounds of the `Bbox` based on the passed in data. After 
        updating, the bounds will have positive *width* and *height*; 
        *x0* and *y0* will be the minimal values. 
 
        Parameters 
        ---------- 
        xy : `~numpy.ndarray` 
            A numpy array of 2D points. 
 
        ignore : bool, optional 
           - When ``True``, ignore the existing bounds of the `Bbox`. 
           - When ``False``, include the existing bounds of the `Bbox`. 
           - When ``None``, use the last value passed to :meth:`ignore`. 
 
        updatex, updatey : bool, default: True 
            When ``True``, update the x/y values. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(xy) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return</span>

        <span class="s1">path = Path(xy)</span>
        <span class="s1">self.update_from_path(path</span><span class="s3">, </span><span class="s1">ignore=ignore</span><span class="s3">,</span>
                              <span class="s1">updatex=updatex</span><span class="s3">, </span><span class="s1">updatey=updatey)</span>

    <span class="s1">@BboxBase.x0.setter</span>
    <span class="s3">def </span><span class="s1">x0(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.y0.setter</span>
    <span class="s3">def </span><span class="s1">y0(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.x1.setter</span>
    <span class="s3">def </span><span class="s1">x1(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.y1.setter</span>
    <span class="s3">def </span><span class="s1">y1(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.p0.setter</span>
    <span class="s3">def </span><span class="s1">p0(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">0</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.p1.setter</span>
    <span class="s3">def </span><span class="s1">p1(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s1">self._points[</span><span class="s5">1</span><span class="s1">] = val</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.intervalx.setter</span>
    <span class="s3">def </span><span class="s1">intervalx(self</span><span class="s3">, </span><span class="s1">interval):</span>
        <span class="s1">self._points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = interval</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.intervaly.setter</span>
    <span class="s3">def </span><span class="s1">intervaly(self</span><span class="s3">, </span><span class="s1">interval):</span>
        <span class="s1">self._points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = interval</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@BboxBase.bounds.setter</span>
    <span class="s3">def </span><span class="s1">bounds(self</span><span class="s3">, </span><span class="s1">bounds):</span>
        <span class="s1">l</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">h = bounds</span>
        <span class="s1">points = np.array([[l</span><span class="s3">, </span><span class="s1">b]</span><span class="s3">, </span><span class="s1">[l + w</span><span class="s3">, </span><span class="s1">b + h]]</span><span class="s3">, </span><span class="s1">float)</span>
        <span class="s3">if </span><span class="s1">np.any(self._points != points):</span>
            <span class="s1">self._points = points</span>
            <span class="s1">self.invalidate()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">minpos(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The minimum positive value in both directions within the Bbox. 
 
        This is useful when dealing with logarithmic scales and other scales 
        where negative bounds result in floating point errors, and will be used 
        as the minimum extent instead of *p0*. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._minpos</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">minposx(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The minimum positive value in the *x*-direction within the Bbox. 
 
        This is useful when dealing with logarithmic scales and other scales 
        where negative bounds result in floating point errors, and will be used 
        as the minimum *x*-extent instead of *x0*. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._minpos[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">minposy(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The minimum positive value in the *y*-direction within the Bbox. 
 
        This is useful when dealing with logarithmic scales and other scales 
        where negative bounds result in floating point errors, and will be used 
        as the minimum *y*-extent instead of *y0*. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._minpos[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">get_points(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the points of the bounding box directly as a numpy array 
        of the form: ``[[x0, y0], [x1, y1]]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._points</span>

    <span class="s3">def </span><span class="s1">set_points(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the points of the bounding box directly from a numpy array 
        of the form: ``[[x0, y0], [x1, y1]]``.  No error checking is 
        performed, as this method is mainly for internal use. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">np.any(self._points != points):</span>
            <span class="s1">self._points = points</span>
            <span class="s1">self.invalidate()</span>

    <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set this bounding box from the &quot;frozen&quot; bounds of another `Bbox`. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">np.any(self._points != other.get_points()):</span>
            <span class="s1">self._points = other.get_points()</span>
            <span class="s1">self.invalidate()</span>

    <span class="s3">def </span><span class="s1">mutated(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the bbox has changed since init.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.mutatedx() </span><span class="s3">or </span><span class="s1">self.mutatedy()</span>

    <span class="s3">def </span><span class="s1">mutatedx(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the x-limits have changed since init.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self._points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] != self._points_orig[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] </span><span class="s3">or</span>
                <span class="s1">self._points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] != self._points_orig[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">mutatedy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the y-limits have changed since init.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(self._points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] != self._points_orig[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] </span><span class="s3">or</span>
                <span class="s1">self._points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] != self._points_orig[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TransformedBbox(BboxBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `Bbox` that is automatically transformed by a given 
    transform.  When either the child bounding box or transform 
    changes, the bounds of this bbox will update accordingly. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        bbox : `Bbox` 
        transform : `Transform` 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">bbox.is_bbox:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'bbox' is not a bbox&quot;</span><span class="s1">)</span>
        <span class="s1">_api.check_isinstance(Transform</span><span class="s3">, </span><span class="s1">transform=transform)</span>
        <span class="s3">if </span><span class="s1">transform.input_dims != </span><span class="s5">2 </span><span class="s3">or </span><span class="s1">transform.output_dims != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The input and output dimensions of 'transform' must be 2&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._bbox = bbox</span>
        <span class="s1">self._transform = transform</span>
        <span class="s1">self.set_children(bbox</span><span class="s3">, </span><span class="s1">transform)</span>
        <span class="s1">self._points = </span><span class="s3">None</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_bbox&quot;</span><span class="s3">, </span><span class="s4">&quot;_transform&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_points(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">p = self._bbox.get_points()</span>
            <span class="s2"># Transform all four points, then make a new bounding box</span>
            <span class="s2"># from the result, taking care to make the orientation the</span>
            <span class="s2"># same.</span>
            <span class="s1">points = self._transform.transform(</span>
                <span class="s1">[[p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">,</span>
                 <span class="s1">[p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">,</span>
                 <span class="s1">[p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s3">,</span>
                 <span class="s1">[p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]]])</span>
            <span class="s1">points = np.ma.filled(points</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>

            <span class="s1">xs = min(points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">max(points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] &gt; p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s1">xs = xs[::-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">ys = min(points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">max(points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s3">if </span><span class="s1">p[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] &gt; p[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">ys = ys[::-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">self._points = np.array([</span>
                <span class="s1">[xs[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ys[</span><span class="s5">0</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s1">[xs[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ys[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">])</span>

            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._points</span>

    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s1">_get_points = get_points</span>

        <span class="s3">def </span><span class="s1">get_points(self):</span>
            <span class="s1">points = self._get_points()</span>
            <span class="s1">self._check(points)</span>
            <span class="s3">return </span><span class="s1">points</span>


<span class="s3">class </span><span class="s1">LockableBbox(BboxBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `Bbox` where some elements may be locked at certain values. 
 
    When the child bounding box changes, the bounds of this bbox will update 
    accordingly with the exception of the locked elements. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">x0=</span><span class="s3">None, </span><span class="s1">y0=</span><span class="s3">None, </span><span class="s1">x1=</span><span class="s3">None, </span><span class="s1">y1=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        bbox : `Bbox` 
            The child bounding box to wrap. 
 
        x0 : float or None 
            The locked value for x0, or None to leave unlocked. 
 
        y0 : float or None 
            The locked value for y0, or None to leave unlocked. 
 
        x1 : float or None 
            The locked value for x1, or None to leave unlocked. 
 
        y1 : float or None 
            The locked value for y1, or None to leave unlocked. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">bbox.is_bbox:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'bbox' is not a bbox&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._bbox = bbox</span>
        <span class="s1">self.set_children(bbox)</span>
        <span class="s1">self._points = </span><span class="s3">None</span>
        <span class="s1">fp = [x0</span><span class="s3">, </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">y1]</span>
        <span class="s1">mask = [val </span><span class="s3">is None for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">fp]</span>
        <span class="s1">self._locked_points = np.ma.array(fp</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">mask=mask).reshape((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_bbox&quot;</span><span class="s3">, </span><span class="s4">&quot;_locked_points&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_points(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">points = self._bbox.get_points()</span>
            <span class="s1">self._points = np.where(self._locked_points.mask</span><span class="s3">,</span>
                                    <span class="s1">points</span><span class="s3">,</span>
                                    <span class="s1">self._locked_points)</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._points</span>

    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s1">_get_points = get_points</span>

        <span class="s3">def </span><span class="s1">get_points(self):</span>
            <span class="s1">points = self._get_points()</span>
            <span class="s1">self._check(points)</span>
            <span class="s3">return </span><span class="s1">points</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">locked_x0(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        float or None: The value used for the locked x0. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._locked_points.mask[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._locked_points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@locked_x0.setter</span>
    <span class="s3">def </span><span class="s1">locked_x0(self</span><span class="s3">, </span><span class="s1">x0):</span>
        <span class="s1">self._locked_points.mask[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = x0 </span><span class="s3">is None</span>
        <span class="s1">self._locked_points.data[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = x0</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">locked_y0(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        float or None: The value used for the locked y0. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._locked_points.mask[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._locked_points[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@locked_y0.setter</span>
    <span class="s3">def </span><span class="s1">locked_y0(self</span><span class="s3">, </span><span class="s1">y0):</span>
        <span class="s1">self._locked_points.mask[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = y0 </span><span class="s3">is None</span>
        <span class="s1">self._locked_points.data[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = y0</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">locked_x1(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        float or None: The value used for the locked x1. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._locked_points.mask[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._locked_points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">@locked_x1.setter</span>
    <span class="s3">def </span><span class="s1">locked_x1(self</span><span class="s3">, </span><span class="s1">x1):</span>
        <span class="s1">self._locked_points.mask[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = x1 </span><span class="s3">is None</span>
        <span class="s1">self._locked_points.data[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = x1</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">locked_y1(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        float or None: The value used for the locked y1. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._locked_points.mask[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._locked_points[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">@locked_y1.setter</span>
    <span class="s3">def </span><span class="s1">locked_y1(self</span><span class="s3">, </span><span class="s1">y1):</span>
        <span class="s1">self._locked_points.mask[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = y1 </span><span class="s3">is None</span>
        <span class="s1">self._locked_points.data[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = y1</span>
        <span class="s1">self.invalidate()</span>


<span class="s3">class </span><span class="s1">Transform(TransformNode):</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class of all `TransformNode` instances that 
    actually perform a transformation. 
 
    All non-affine transformations should be subclasses of this class. 
    New affine transformations should be subclasses of `Affine2D`. 
 
    Subclasses of this class should override the following members (at 
    minimum): 
 
    - :attr:`input_dims` 
    - :attr:`output_dims` 
    - :meth:`transform` 
    - :meth:`inverted` (if an inverse exists) 
 
    The following attributes may be overridden if the default is unsuitable: 
 
    - :attr:`is_separable` (defaults to True for 1D -&gt; 1D transforms, False 
      otherwise) 
    - :attr:`has_inverse` (defaults to True if :meth:`inverted` is overridden, 
      False otherwise) 
 
    If the transform needs to do something non-standard with 
    `matplotlib.path.Path` objects, such as adding curves 
    where there were once line segments, it should override: 
 
    - :meth:`transform_path` 
    &quot;&quot;&quot;</span>

    <span class="s1">input_dims = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot; 
    The number of input dimensions of this transform. 
    Must be overridden (with integers) in the subclass. 
    &quot;&quot;&quot;</span>

    <span class="s1">output_dims = </span><span class="s3">None</span>
    <span class="s4">&quot;&quot;&quot; 
    The number of output dimensions of this transform. 
    Must be overridden (with integers) in the subclass. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_separable = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;True if this transform is separable in the x- and y- dimensions.&quot;&quot;&quot;</span>

    <span class="s1">has_inverse = </span><span class="s3">False</span>
    <span class="s4">&quot;&quot;&quot;True if this transform has a corresponding inverse transform.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init_subclass__(cls):</span>
        <span class="s2"># 1d transforms are always separable; we assume higher-dimensional ones</span>
        <span class="s2"># are not but subclasses can also directly set is_separable -- this is</span>
        <span class="s2"># verified by checking whether &quot;is_separable&quot; appears more than once in</span>
        <span class="s2"># the class's MRO (it appears once in Transform).</span>
        <span class="s3">if </span><span class="s1">(sum(</span><span class="s4">&quot;is_separable&quot; </span><span class="s3">in </span><span class="s1">vars(parent) </span><span class="s3">for </span><span class="s1">parent </span><span class="s3">in </span><span class="s1">cls.__mro__) == </span><span class="s5">1</span>
                <span class="s3">and </span><span class="s1">cls.input_dims == cls.output_dims == </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">cls.is_separable = </span><span class="s3">True</span>
        <span class="s2"># Transform.inverted raises NotImplementedError; we assume that if this</span>
        <span class="s2"># is overridden then the transform is invertible but subclass can also</span>
        <span class="s2"># directly set has_inverse.</span>
        <span class="s3">if </span><span class="s1">(sum(</span><span class="s4">&quot;has_inverse&quot; </span><span class="s3">in </span><span class="s1">vars(parent) </span><span class="s3">for </span><span class="s1">parent </span><span class="s3">in </span><span class="s1">cls.__mro__) == </span><span class="s5">1</span>
                <span class="s3">and </span><span class="s1">hasattr(cls</span><span class="s3">, </span><span class="s4">&quot;inverted&quot;</span><span class="s1">)</span>
                <span class="s3">and </span><span class="s1">cls.inverted </span><span class="s3">is not </span><span class="s1">Transform.inverted):</span>
            <span class="s1">cls.has_inverse = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compose two transforms together so that *self* is followed by *other*. 
 
        ``A + B`` returns a transform ``C`` so that 
        ``C.transform(x) == B.transform(A.transform(x))``. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(composite_transform_factory(self</span><span class="s3">, </span><span class="s1">other)</span>
                <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Transform) </span><span class="s3">else</span>
                <span class="s1">NotImplemented)</span>

    <span class="s2"># Equality is based on object identity for `Transform`s (so we don't</span>
    <span class="s2"># override `__eq__`), but some subclasses, such as TransformWrapper &amp;</span>
    <span class="s2"># AffineBase, override this behavior.</span>

    <span class="s3">def </span><span class="s1">_iter_break_from_left_to_right(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an iterator breaking down this transform stack from left to 
        right recursively. If self == ((A, N), A) then the result will be an 
        iterator which yields I : ((A, N), A), followed by A : (N, A), 
        followed by (A, N) : (A), but not ((A, N), A) : I. 
 
        This is equivalent to flattening the stack then yielding 
        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1). 
        &quot;&quot;&quot;</span>
        <span class="s3">yield </span><span class="s1">IdentityTransform()</span><span class="s3">, </span><span class="s1">self</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">depth(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of transforms which have been chained 
        together to form this Transform instance. 
 
        .. note:: 
 
            For the special case of a Composite transform, the maximum depth 
            of the two is returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">contains_branch(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the given transform is a sub-tree of this transform. 
 
        This routine uses transform equality to identify sub-trees, therefore 
        in many situations it is object id which will be used. 
 
        For the case where the given transform represents the whole 
        of this transform, returns True. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.depth &lt; other.depth:</span>
            <span class="s3">return False</span>

        <span class="s2"># check that a subtree is equal to other (starting from self)</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">sub_tree </span><span class="s3">in </span><span class="s1">self._iter_break_from_left_to_right():</span>
            <span class="s3">if </span><span class="s1">sub_tree == other:</span>
                <span class="s3">return True</span>
        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">contains_branch_seperately(self</span><span class="s3">, </span><span class="s1">other_transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the given branch is a sub-tree of this transform on 
        each separate dimension. 
 
        A common use for this method is to identify if a transform is a blended 
        transform containing an Axes' data transform. e.g.:: 
 
            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.output_dims != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'contains_branch_seperately only supports '</span>
                             <span class="s4">'transforms with 2 output dimensions'</span><span class="s1">)</span>
        <span class="s2"># for a non-blended transform each separate dimension is the same, so</span>
        <span class="s2"># just return the appropriate shape.</span>
        <span class="s3">return </span><span class="s1">[self.contains_branch(other_transform)] * </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">__sub__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compose *self* with the inverse of *other*, cancelling identical terms 
        if any:: 
 
            # In general: 
            A - B == A + B.inverted() 
            # (but see note regarding frozen transforms below). 
 
            # If A &quot;ends with&quot; B (i.e. A == A' + B for some A') we can cancel 
            # out B: 
            (A' + B) - B == A' 
 
            # Likewise, if B &quot;starts with&quot; A (B = A + B'), we can cancel out A: 
            A - (A + B') == B'.inverted() == B'^-1 
 
        Cancellation (rather than naively returning ``A + B.inverted()``) is 
        important for multiple reasons: 
 
        - It avoids floating-point inaccuracies when computing the inverse of 
          B: ``B - B`` is guaranteed to cancel out exactly (resulting in the 
          identity transform), whereas ``B + B.inverted()`` may differ by a 
          small epsilon. 
        - ``B.inverted()`` always returns a frozen transform: if one computes 
          ``A + B + B.inverted()`` and later mutates ``B``, then 
          ``B.inverted()`` won't be updated and the last two terms won't cancel 
          out anymore; on the other hand, ``A + B - B`` will always be equal to 
          ``A`` even if ``B`` is mutated. 
        &quot;&quot;&quot;</span>
        <span class="s2"># we only know how to do this operation if other is a Transform.</span>
        <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Transform):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s3">for </span><span class="s1">remainder</span><span class="s3">, </span><span class="s1">sub_tree </span><span class="s3">in </span><span class="s1">self._iter_break_from_left_to_right():</span>
            <span class="s3">if </span><span class="s1">sub_tree == other:</span>
                <span class="s3">return </span><span class="s1">remainder</span>
        <span class="s3">for </span><span class="s1">remainder</span><span class="s3">, </span><span class="s1">sub_tree </span><span class="s3">in </span><span class="s1">other._iter_break_from_left_to_right():</span>
            <span class="s3">if </span><span class="s1">sub_tree == self:</span>
                <span class="s3">if not </span><span class="s1">remainder.has_inverse:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s4">&quot;The shortcut cannot be computed since 'other' &quot;</span>
                        <span class="s4">&quot;includes a non-invertible component&quot;</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">remainder.inverted()</span>
        <span class="s2"># if we have got this far, then there was no shortcut possible</span>
        <span class="s3">if </span><span class="s1">other.has_inverse:</span>
            <span class="s3">return </span><span class="s1">self + other.inverted()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'It is not possible to compute transA - transB '</span>
                             <span class="s4">'since transB cannot be inverted and there is no '</span>
                             <span class="s4">'shortcut possible.'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__array__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Array interface to get at this Transform's affine matrix.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_affine().get_matrix()</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply this transformation on the given array of *values*. 
 
        Parameters 
        ---------- 
        values : array 
            The input values as NumPy array of length :attr:`input_dims` or 
            shape (N x :attr:`input_dims`). 
 
        Returns 
        ------- 
        array 
            The output values as NumPy array of length :attr:`output_dims` or 
            shape (N x :attr:`output_dims`), depending on the input. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Ensure that values is a 2d array (but remember whether</span>
        <span class="s2"># we started with a 1d or 2d array).</span>
        <span class="s1">values = np.asanyarray(values)</span>
        <span class="s1">ndim = values.ndim</span>
        <span class="s1">values = values.reshape((-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.input_dims))</span>

        <span class="s2"># Transform the values</span>
        <span class="s1">res = self.transform_affine(self.transform_non_affine(values))</span>

        <span class="s2"># Convert the result back to the shape of the input values.</span>
        <span class="s3">if </span><span class="s1">ndim == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">assert not </span><span class="s1">np.ma.is_masked(res)  </span><span class="s2"># just to be on the safe side</span>
            <span class="s3">return </span><span class="s1">res[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">res.reshape(-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">res</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Input values must have shape (N x {dims}) &quot;</span>
            <span class="s4">&quot;or ({dims}).&quot;</span><span class="s1">.format(dims=self.input_dims))</span>

    <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply only the affine part of this transformation on the 
        given array of values. 
 
        ``transform(values)`` is always equivalent to 
        ``transform_affine(transform_non_affine(values))``. 
 
        In non-affine transformations, this is generally a no-op.  In 
        affine transformations, this is equivalent to 
        ``transform(values)``. 
 
        Parameters 
        ---------- 
        values : array 
            The input values as NumPy array of length :attr:`input_dims` or 
            shape (N x :attr:`input_dims`). 
 
        Returns 
        ------- 
        array 
            The output values as NumPy array of length :attr:`output_dims` or 
            shape (N x :attr:`output_dims`), depending on the input. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_affine().transform(values)</span>

    <span class="s3">def </span><span class="s1">transform_non_affine(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply only the non-affine part of this transformation. 
 
        ``transform(values)`` is always equivalent to 
        ``transform_affine(transform_non_affine(values))``. 
 
        In non-affine transformations, this is generally equivalent to 
        ``transform(values)``.  In affine transformations, this is 
        always a no-op. 
 
        Parameters 
        ---------- 
        values : array 
            The input values as NumPy array of length :attr:`input_dims` or 
            shape (N x :attr:`input_dims`). 
 
        Returns 
        ------- 
        array 
            The output values as NumPy array of length :attr:`output_dims` or 
            shape (N x :attr:`output_dims`), depending on the input. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">values</span>

    <span class="s3">def </span><span class="s1">transform_bbox(self</span><span class="s3">, </span><span class="s1">bbox):</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform the given bounding box. 
 
        For smarter transforms including caching (a common requirement in 
        Matplotlib), see `TransformedBbox`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Bbox(self.transform(bbox.get_points()))</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the affine part of this transform.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">IdentityTransform()</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the matrix for the affine part of this transform.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_affine().get_matrix()</span>

    <span class="s3">def </span><span class="s1">transform_point(self</span><span class="s3">, </span><span class="s1">point):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a transformed point. 
 
        This function is only kept for backcompatibility; the more general 
        `.transform` method is capable of transforming both a list of points 
        and a single point. 
 
        The point is given as a sequence of length :attr:`input_dims`. 
        The transformed point is returned as a sequence of length 
        :attr:`output_dims`. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(point) != self.input_dims:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The length of 'point' must be 'self.input_dims'&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self.transform(point)</span>

    <span class="s3">def </span><span class="s1">transform_path(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the transform to `.Path` *path*, returning a new `.Path`. 
 
        In some cases, this transform may insert curves into the path 
        that began as line segments. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.transform_path_affine(self.transform_path_non_affine(path))</span>

    <span class="s3">def </span><span class="s1">transform_path_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the affine part of this transform to `.Path` *path*, returning a 
        new `.Path`. 
 
        ``transform_path(path)`` is equivalent to 
        ``transform_path_affine(transform_path_non_affine(values))``. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.get_affine().transform_path_affine(path)</span>

    <span class="s3">def </span><span class="s1">transform_path_non_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot; 
        Apply the non-affine part of this transform to `.Path` *path*, 
        returning a new `.Path`. 
 
        ``transform_path(path)`` is equivalent to 
        ``transform_path_affine(transform_path_non_affine(values))``. 
        &quot;&quot;&quot;</span>
        <span class="s1">x = self.transform_non_affine(path.vertices)</span>
        <span class="s3">return </span><span class="s1">Path._fast_from_codes_and_verts(x</span><span class="s3">, </span><span class="s1">path.codes</span><span class="s3">, </span><span class="s1">path)</span>

    <span class="s3">def </span><span class="s1">transform_angles(self</span><span class="s3">, </span><span class="s1">angles</span><span class="s3">, </span><span class="s1">pts</span><span class="s3">, </span><span class="s1">radians=</span><span class="s3">False, </span><span class="s1">pushoff=</span><span class="s5">1e-5</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform a set of angles anchored at specific locations. 
 
        Parameters 
        ---------- 
        angles : (N,) array-like 
            The angles to transform. 
        pts : (N, 2) array-like 
            The points where the angles are anchored. 
        radians : bool, default: False 
            Whether *angles* are radians or degrees. 
        pushoff : float 
            For each point in *pts* and angle in *angles*, the transformed 
            angle is computed by transforming a segment of length *pushoff* 
            starting at that point and making that angle relative to the 
            horizontal axis, and measuring the angle between the horizontal 
            axis and the transformed segment. 
 
        Returns 
        ------- 
        (N,) array 
        &quot;&quot;&quot;</span>
        <span class="s2"># Must be 2D</span>
        <span class="s3">if </span><span class="s1">self.input_dims != </span><span class="s5">2 </span><span class="s3">or </span><span class="s1">self.output_dims != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Only defined in 2D'</span><span class="s1">)</span>
        <span class="s1">angles = np.asarray(angles)</span>
        <span class="s1">pts = np.asarray(pts)</span>
        <span class="s1">_api.check_shape((</span><span class="s3">None, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">pts=pts)</span>
        <span class="s1">_api.check_shape((</span><span class="s3">None,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">angles=angles)</span>
        <span class="s3">if </span><span class="s1">len(angles) != len(pts):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;There must be as many 'angles' as 'pts'&quot;</span><span class="s1">)</span>
        <span class="s2"># Convert to radians if desired</span>
        <span class="s3">if not </span><span class="s1">radians:</span>
            <span class="s1">angles = np.deg2rad(angles)</span>
        <span class="s2"># Move a short distance away</span>
        <span class="s1">pts2 = pts + pushoff * np.column_stack([np.cos(angles)</span><span class="s3">,</span>
                                                <span class="s1">np.sin(angles)])</span>
        <span class="s2"># Transform both sets of points</span>
        <span class="s1">tpts = self.transform(pts)</span>
        <span class="s1">tpts2 = self.transform(pts2)</span>
        <span class="s2"># Calculate transformed angles</span>
        <span class="s1">d = tpts2 - tpts</span>
        <span class="s1">a = np.arctan2(d[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">d[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2"># Convert back to degrees if desired</span>
        <span class="s3">if not </span><span class="s1">radians:</span>
            <span class="s1">a = np.rad2deg(a)</span>
        <span class="s3">return </span><span class="s1">a</span>

    <span class="s3">def </span><span class="s1">inverted(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the corresponding inverse transformation. 
 
        It holds ``x == self.inverted().transform(self.transform(x))``. 
 
        The return value of this method should be treated as 
        temporary.  An update to *self* does not cause a corresponding 
        update to its inverted copy. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError()</span>


<span class="s3">class </span><span class="s1">TransformWrapper(Transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper class that holds a single child transform and acts 
    equivalently to it. 
 
    This is useful if a node of the transform tree must be replaced at 
    run time with a transform of a different type.  This class allows 
    that replacement to correctly trigger invalidation. 
 
    `TransformWrapper` instances must have the same input and output dimensions 
    during their entire lifetime, so the child transform may only be replaced 
    with another child transform of the same dimensions. 
    &quot;&quot;&quot;</span>

    <span class="s1">pass_through = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">child):</span>
        <span class="s0">&quot;&quot;&quot; 
        *child*: A `Transform` instance.  This child may later 
        be replaced with :meth:`set`. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(Transform</span><span class="s3">, </span><span class="s1">child=child)</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.set(child)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self._child.__eq__(other)</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_child&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self._child.frozen()</span>

    <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">child):</span>
        <span class="s0">&quot;&quot;&quot; 
        Replace the current child of this transform with another one. 
 
        The new child must have the same number of input and output 
        dimensions as the current child. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;_child&quot;</span><span class="s1">):  </span><span class="s2"># Absent during init.</span>
            <span class="s1">self.invalidate()</span>
            <span class="s1">new_dims = (child.input_dims</span><span class="s3">, </span><span class="s1">child.output_dims)</span>
            <span class="s1">old_dims = (self._child.input_dims</span><span class="s3">, </span><span class="s1">self._child.output_dims)</span>
            <span class="s3">if </span><span class="s1">new_dims != old_dims:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;The input and output dims of the new child </span><span class="s3">{</span><span class="s1">new_dims</span><span class="s3">} </span><span class="s4">&quot;</span>
                    <span class="s4">f&quot;do not match those of current child </span><span class="s3">{</span><span class="s1">old_dims</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">self._child._parents.pop(id(self)</span><span class="s3">, None</span><span class="s1">)</span>

        <span class="s1">self._child = child</span>
        <span class="s1">self.set_children(child)</span>

        <span class="s1">self.transform = child.transform</span>
        <span class="s1">self.transform_affine = child.transform_affine</span>
        <span class="s1">self.transform_non_affine = child.transform_non_affine</span>
        <span class="s1">self.transform_path = child.transform_path</span>
        <span class="s1">self.transform_path_affine = child.transform_path_affine</span>
        <span class="s1">self.transform_path_non_affine = child.transform_path_non_affine</span>
        <span class="s1">self.get_affine = child.get_affine</span>
        <span class="s1">self.inverted = child.inverted</span>
        <span class="s1">self.get_matrix = child.get_matrix</span>
        <span class="s2"># note we do not wrap other properties here since the transform's</span>
        <span class="s2"># child can be changed with WrappedTransform.set and so checking</span>
        <span class="s2"># is_affine and other such properties may be dangerous.</span>

        <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s1">self.invalidate()</span>
        <span class="s1">self._invalid = </span><span class="s5">0</span>

    <span class="s1">input_dims = property(</span><span class="s3">lambda </span><span class="s1">self: self._child.input_dims)</span>
    <span class="s1">output_dims = property(</span><span class="s3">lambda </span><span class="s1">self: self._child.output_dims)</span>
    <span class="s1">is_affine = property(</span><span class="s3">lambda </span><span class="s1">self: self._child.is_affine)</span>
    <span class="s1">is_separable = property(</span><span class="s3">lambda </span><span class="s1">self: self._child.is_separable)</span>
    <span class="s1">has_inverse = property(</span><span class="s3">lambda </span><span class="s1">self: self._child.has_inverse)</span>


<span class="s3">class </span><span class="s1">AffineBase(Transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class of all affine transformations of any number of dimensions. 
    &quot;&quot;&quot;</span>
    <span class="s1">is_affine = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._inverted = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__array__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2"># optimises the access of the transform matrix vs. the superclass</span>
        <span class="s3">return </span><span class="s1">self.get_matrix()</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">getattr(other</span><span class="s3">, </span><span class="s4">&quot;is_affine&quot;</span><span class="s3">, False</span><span class="s1">) </span><span class="s3">and </span><span class="s1">hasattr(other</span><span class="s3">, </span><span class="s4">&quot;get_matrix&quot;</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">np.all(self.get_matrix() == other.get_matrix())</span>
        <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self.transform_affine(values)</span>

    <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">'Affine subclasses should override this '</span>
                                  <span class="s4">'method.'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">transform_non_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">points</span>

    <span class="s3">def </span><span class="s1">transform_path(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self.transform_path_affine(path)</span>

    <span class="s3">def </span><span class="s1">transform_path_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">Path(self.transform_affine(path.vertices)</span><span class="s3">,</span>
                    <span class="s1">path.codes</span><span class="s3">, </span><span class="s1">path._interpolation_steps)</span>

    <span class="s3">def </span><span class="s1">transform_path_non_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">Affine2DBase(AffineBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    The base class of all 2D affine transformations. 
 
    2D affine transformations are performed using a 3x3 numpy array:: 
 
        a c e 
        b d f 
        0 0 1 
 
    This class provides the read-only interface.  For a mutable 2D 
    affine transformation, use `Affine2D`. 
 
    Subclasses of this class will generally only need to override a 
    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix. 
    &quot;&quot;&quot;</span>
    <span class="s1">input_dims = </span><span class="s5">2</span>
    <span class="s1">output_dims = </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">Affine2D(self.get_matrix().copy())</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">is_separable(self):</span>
        <span class="s1">mtx = self.get_matrix()</span>
        <span class="s3">return </span><span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] == mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0.0</span>

    <span class="s3">def </span><span class="s1">to_values(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the values of the matrix as an ``(a, b, c, d, e, f)`` tuple. 
        &quot;&quot;&quot;</span>
        <span class="s1">mtx = self.get_matrix()</span>
        <span class="s3">return </span><span class="s1">tuple(mtx[:</span><span class="s5">2</span><span class="s1">].swapaxes(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">).flat)</span>

    <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s1">mtx = self.get_matrix()</span>
        <span class="s3">if </span><span class="s1">isinstance(points</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">tpoints = affine_transform(points.data</span><span class="s3">, </span><span class="s1">mtx)</span>
            <span class="s3">return </span><span class="s1">np.ma.MaskedArray(tpoints</span><span class="s3">, </span><span class="s1">mask=np.ma.getmask(points))</span>
        <span class="s3">return </span><span class="s1">affine_transform(points</span><span class="s3">, </span><span class="s1">mtx)</span>

    <span class="s3">if </span><span class="s1">DEBUG:</span>
        <span class="s1">_transform_affine = transform_affine</span>

        <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
            <span class="s2"># docstring inherited</span>
            <span class="s2"># The major speed trap here is just converting to the</span>
            <span class="s2"># points to an array in the first place.  If we can use</span>
            <span class="s2"># more arrays upstream, that should help here.</span>
            <span class="s3">if not </span><span class="s1">isinstance(points</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s4">f'A non-numpy array of type </span><span class="s3">{</span><span class="s1">type(points)</span><span class="s3">} </span><span class="s4">was passed in '</span>
                    <span class="s4">f'for transformation, which results in poor performance.'</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">self._transform_affine(points)</span>

    <span class="s3">def </span><span class="s1">inverted(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._inverted </span><span class="s3">is None or </span><span class="s1">self._invalid:</span>
            <span class="s1">mtx = self.get_matrix()</span>
            <span class="s1">shorthand_name = </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">self._shorthand_name:</span>
                <span class="s1">shorthand_name = </span><span class="s4">'(%s)-1' </span><span class="s1">% self._shorthand_name</span>
            <span class="s1">self._inverted = Affine2D(inv(mtx)</span><span class="s3">, </span><span class="s1">shorthand_name=shorthand_name)</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._inverted</span>


<span class="s3">class </span><span class="s1">Affine2D(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A mutable 2D affine transformation. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">matrix=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize an Affine transform from a 3x3 numpy float array:: 
 
          a c e 
          b d f 
          0 0 1 
 
        If *matrix* is None, initialize with the identity transform. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s3">if </span><span class="s1">matrix </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2"># A bit faster than np.identity(3).</span>
            <span class="s1">matrix = IdentityTransform._mtx</span>
        <span class="s1">self._mtx = matrix.copy()</span>
        <span class="s1">self._invalid = </span><span class="s5">0</span>

    <span class="s1">_base_str = _make_str_method(</span><span class="s4">&quot;_mtx&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">(self._base_str()</span>
                <span class="s3">if </span><span class="s1">(self._mtx != np.diag(np.diag(self._mtx))).any()</span>
                <span class="s3">else </span><span class="s4">f&quot;Affine2D().scale(</span><span class="s3">{</span><span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">}</span><span class="s4">, </span><span class="s3">{</span><span class="s1">self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span><span class="s3">}</span><span class="s4">)&quot;</span>
                <span class="s3">if </span><span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] != self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>
                <span class="s3">else </span><span class="s4">f&quot;Affine2D().scale(</span><span class="s3">{</span><span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span><span class="s3">}</span><span class="s4">)&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">from_values(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">f):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new Affine2D instance from the given values:: 
 
          a c e 
          b d f 
          0 0 1 
 
        . 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Affine2D(</span>
            <span class="s1">np.array([a</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">float).reshape((</span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the underlying transformation matrix as a 3x3 numpy array:: 
 
          a c e 
          b d f 
          0 0 1 
 
        . 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>

    <span class="s3">def </span><span class="s1">set_matrix(self</span><span class="s3">, </span><span class="s1">mtx):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the underlying transformation matrix from a 3x3 numpy array:: 
 
          a c e 
          b d f 
          0 0 1 
 
        . 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mtx = mtx</span>
        <span class="s1">self.invalidate()</span>

    <span class="s3">def </span><span class="s1">set(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set this transformation from the frozen copy of another 
        `Affine2DBase` object. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(Affine2DBase</span><span class="s3">, </span><span class="s1">other=other)</span>
        <span class="s1">self._mtx = other.get_matrix()</span>
        <span class="s1">self.invalidate()</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">&quot;Affine2D()&quot;</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">identity():</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a new `Affine2D` object that is the identity transform. 
 
        Unless this transform will be mutated later on, consider using 
        the faster `IdentityTransform` class instead. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">Affine2D()</span>

    <span class="s3">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reset the underlying matrix to the identity transform. 
        &quot;&quot;&quot;</span>
        <span class="s2"># A bit faster than np.identity(3).</span>
        <span class="s1">self._mtx = IdentityTransform._mtx.copy()</span>
        <span class="s1">self.invalidate()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">rotate(self</span><span class="s3">, </span><span class="s1">theta):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a rotation (in radians) to this transform in place. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s1">a = math.cos(theta)</span>
        <span class="s1">b = math.sin(theta)</span>
        <span class="s1">mtx = self._mtx</span>
        <span class="s2"># Operating and assigning one scalar at a time is much faster.</span>
        <span class="s1">(xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">x0)</span><span class="s3">, </span><span class="s1">(yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">y0)</span><span class="s3">, </span><span class="s1">_ = mtx.tolist()</span>
        <span class="s2"># mtx = [[a -b 0], [b a 0], [0 0 1]] * mtx</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = a * xx - b * yx</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = a * xy - b * yy</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] = a * x0 - b * y0</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] = b * xx + a * yx</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] = b * xy + a * yy</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] = b * x0 + a * y0</span>
        <span class="s1">self.invalidate()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">rotate_deg(self</span><span class="s3">, </span><span class="s1">degrees):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a rotation (in degrees) to this transform in place. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.rotate(math.radians(degrees))</span>

    <span class="s3">def </span><span class="s1">rotate_around(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">theta):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a rotation (in radians) around the point (x, y) in place. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.translate(-x</span><span class="s3">, </span><span class="s1">-y).rotate(theta).translate(x</span><span class="s3">, </span><span class="s1">y)</span>

    <span class="s3">def </span><span class="s1">rotate_deg_around(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">degrees):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a rotation (in degrees) around the point (x, y) in place. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Cast to float to avoid wraparound issues with uint8's</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y = float(x)</span><span class="s3">, </span><span class="s1">float(y)</span>
        <span class="s3">return </span><span class="s1">self.translate(-x</span><span class="s3">, </span><span class="s1">-y).rotate_deg(degrees).translate(x</span><span class="s3">, </span><span class="s1">y)</span>

    <span class="s3">def </span><span class="s1">translate(self</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a translation in place. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] += tx</span>
        <span class="s1">self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] += ty</span>
        <span class="s1">self.invalidate()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">scale(self</span><span class="s3">, </span><span class="s1">sx</span><span class="s3">, </span><span class="s1">sy=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a scale in place. 
 
        If *sy* is None, the same scale is applied in both the *x*- and 
        *y*-directions. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">sy </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">sy = sx</span>
        <span class="s2"># explicit element-wise scaling is fastest</span>
        <span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] *= sx</span>
        <span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] *= sx</span>
        <span class="s1">self._mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] *= sx</span>
        <span class="s1">self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] *= sy</span>
        <span class="s1">self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] *= sy</span>
        <span class="s1">self._mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] *= sy</span>
        <span class="s1">self.invalidate()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">skew(self</span><span class="s3">, </span><span class="s1">xShear</span><span class="s3">, </span><span class="s1">yShear):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a skew in place. 
 
        *xShear* and *yShear* are the shear angles along the *x*- and 
        *y*-axes, respectively, in radians. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s1">rx = math.tan(xShear)</span>
        <span class="s1">ry = math.tan(yShear)</span>
        <span class="s1">mtx = self._mtx</span>
        <span class="s2"># Operating and assigning one scalar at a time is much faster.</span>
        <span class="s1">(xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">x0)</span><span class="s3">, </span><span class="s1">(yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">y0)</span><span class="s3">, </span><span class="s1">_ = mtx.tolist()</span>
        <span class="s2"># mtx = [[1 rx 0], [ry 1 0], [0 0 1]] * mtx</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] += rx * yx</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] += rx * yy</span>
        <span class="s1">mtx[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] += rx * y0</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">] += ry * xx</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">] += ry * xy</span>
        <span class="s1">mtx[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] += ry * x0</span>
        <span class="s1">self.invalidate()</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">skew_deg(self</span><span class="s3">, </span><span class="s1">xShear</span><span class="s3">, </span><span class="s1">yShear):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a skew in place. 
 
        *xShear* and *yShear* are the shear angles along the *x*- and 
        *y*-axes, respectively, in degrees. 
 
        Returns *self*, so this method can easily be chained with more 
        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate` 
        and :meth:`scale`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.skew(math.radians(xShear)</span><span class="s3">, </span><span class="s1">math.radians(yShear))</span>


<span class="s3">class </span><span class="s1">IdentityTransform(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A special class that does one thing, the identity transform, in a 
    fast way. 
    &quot;&quot;&quot;</span>
    <span class="s1">_mtx = np.identity(</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">__str__ = _make_str_method()</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">np.asanyarray(points)</span>

    <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">np.asanyarray(points)</span>

    <span class="s3">def </span><span class="s1">transform_non_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">np.asanyarray(points)</span>

    <span class="s3">def </span><span class="s1">transform_path(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">transform_path_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">transform_path_non_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">path</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">inverted(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">_BlendedMixin:</span>
    <span class="s0">&quot;&quot;&quot;Common methods for `BlendedGenericTransform` and `BlendedAffine2D`.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">(BlendedAffine2D</span><span class="s3">, </span><span class="s1">BlendedGenericTransform)):</span>
            <span class="s3">return </span><span class="s1">(self._x == other._x) </span><span class="s3">and </span><span class="s1">(self._y == other._y)</span>
        <span class="s3">elif </span><span class="s1">self._x == self._y:</span>
            <span class="s3">return </span><span class="s1">self._x == other</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">contains_branch_seperately(self</span><span class="s3">, </span><span class="s1">transform):</span>
        <span class="s3">return </span><span class="s1">(self._x.contains_branch(transform)</span><span class="s3">,</span>
                <span class="s1">self._y.contains_branch(transform))</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_x&quot;</span><span class="s3">, </span><span class="s4">&quot;_y&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">BlendedGenericTransform(_BlendedMixin</span><span class="s3">, </span><span class="s1">Transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    A &quot;blended&quot; transform uses one transform for the *x*-direction, and 
    another transform for the *y*-direction. 
 
    This &quot;generic&quot; version can handle any given child transform in the 
    *x*- and *y*-directions. 
    &quot;&quot;&quot;</span>
    <span class="s1">input_dims = </span><span class="s5">2</span>
    <span class="s1">output_dims = </span><span class="s5">2</span>
    <span class="s1">is_separable = </span><span class="s3">True</span>
    <span class="s1">pass_through = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x_transform</span><span class="s3">, </span><span class="s1">y_transform</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new &quot;blended&quot; transform using *x_transform* to transform the 
        *x*-axis and *y_transform* to transform the *y*-axis. 
 
        You will generally not call this constructor directly but use the 
        `blended_transform_factory` function instead, which can determine 
        automatically which kind of blended transform to create. 
        &quot;&quot;&quot;</span>
        <span class="s1">Transform.__init__(self</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._x = x_transform</span>
        <span class="s1">self._y = y_transform</span>
        <span class="s1">self.set_children(x_transform</span><span class="s3">, </span><span class="s1">y_transform)</span>
        <span class="s1">self._affine = </span><span class="s3">None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">depth(self):</span>
        <span class="s3">return </span><span class="s1">max(self._x.depth</span><span class="s3">, </span><span class="s1">self._y.depth)</span>

    <span class="s3">def </span><span class="s1">contains_branch(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s2"># A blended transform cannot possibly contain a branch from two</span>
        <span class="s2"># different transforms.</span>
        <span class="s3">return False</span>

    <span class="s1">is_affine = property(</span><span class="s3">lambda </span><span class="s1">self: self._x.is_affine </span><span class="s3">and </span><span class="s1">self._y.is_affine)</span>
    <span class="s1">has_inverse = property(</span>
        <span class="s3">lambda </span><span class="s1">self: self._x.has_inverse </span><span class="s3">and </span><span class="s1">self._y.has_inverse)</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">blended_transform_factory(self._x.frozen()</span><span class="s3">, </span><span class="s1">self._y.frozen())</span>

    <span class="s3">def </span><span class="s1">transform_non_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._x.is_affine </span><span class="s3">and </span><span class="s1">self._y.is_affine:</span>
            <span class="s3">return </span><span class="s1">points</span>
        <span class="s1">x = self._x</span>
        <span class="s1">y = self._y</span>

        <span class="s3">if </span><span class="s1">x == y </span><span class="s3">and </span><span class="s1">x.input_dims == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">x.transform_non_affine(points)</span>

        <span class="s3">if </span><span class="s1">x.input_dims == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">x_points = x.transform_non_affine(points)[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">x_points = x.transform_non_affine(points[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">x_points = x_points.reshape((len(x_points)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">y.input_dims == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">y_points = y.transform_non_affine(points)[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">y_points = y.transform_non_affine(points[:</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">y_points = y_points.reshape((len(y_points)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s3">if </span><span class="s1">(isinstance(x_points</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray) </span><span class="s3">or</span>
                <span class="s1">isinstance(y_points</span><span class="s3">, </span><span class="s1">np.ma.MaskedArray)):</span>
            <span class="s3">return </span><span class="s1">np.ma.concatenate((x_points</span><span class="s3">, </span><span class="s1">y_points)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.concatenate((x_points</span><span class="s3">, </span><span class="s1">y_points)</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">inverted(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">BlendedGenericTransform(self._x.inverted()</span><span class="s3">, </span><span class="s1">self._y.inverted())</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid </span><span class="s3">or </span><span class="s1">self._affine </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self._x == self._y:</span>
                <span class="s1">self._affine = self._x.get_affine()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">x_mtx = self._x.get_affine().get_matrix()</span>
                <span class="s1">y_mtx = self._y.get_affine().get_matrix()</span>
                <span class="s2"># We already know the transforms are separable, so we can skip</span>
                <span class="s2"># setting b and c to zero.</span>
                <span class="s1">mtx = np.array([x_mtx[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y_mtx[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">]])</span>
                <span class="s1">self._affine = Affine2D(mtx)</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._affine</span>


<span class="s3">class </span><span class="s1">BlendedAffine2D(_BlendedMixin</span><span class="s3">, </span><span class="s1">Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A &quot;blended&quot; transform uses one transform for the *x*-direction, and 
    another transform for the *y*-direction. 
 
    This version is an optimization for the case where both child 
    transforms are of type `Affine2DBase`. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_separable = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x_transform</span><span class="s3">, </span><span class="s1">y_transform</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new &quot;blended&quot; transform using *x_transform* to transform the 
        *x*-axis and *y_transform* to transform the *y*-axis. 
 
        Both *x_transform* and *y_transform* must be 2D affine transforms. 
 
        You will generally not call this constructor directly but use the 
        `blended_transform_factory` function instead, which can determine 
        automatically which kind of blended transform to create. 
        &quot;&quot;&quot;</span>
        <span class="s1">is_affine = x_transform.is_affine </span><span class="s3">and </span><span class="s1">y_transform.is_affine</span>
        <span class="s1">is_separable = x_transform.is_separable </span><span class="s3">and </span><span class="s1">y_transform.is_separable</span>
        <span class="s1">is_correct = is_affine </span><span class="s3">and </span><span class="s1">is_separable</span>
        <span class="s3">if not </span><span class="s1">is_correct:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Both *x_transform* and *y_transform* must be 2D &quot;</span>
                             <span class="s4">&quot;affine transforms&quot;</span><span class="s1">)</span>

        <span class="s1">Transform.__init__(self</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._x = x_transform</span>
        <span class="s1">self._y = y_transform</span>
        <span class="s1">self.set_children(x_transform</span><span class="s3">, </span><span class="s1">y_transform)</span>

        <span class="s1">Affine2DBase.__init__(self)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s3">if </span><span class="s1">self._x == self._y:</span>
                <span class="s1">self._mtx = self._x.get_matrix()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">x_mtx = self._x.get_matrix()</span>
                <span class="s1">y_mtx = self._y.get_matrix()</span>
                <span class="s2"># We already know the transforms are separable, so we can skip</span>
                <span class="s2"># setting b and c to zero.</span>
                <span class="s1">self._mtx = np.array([x_mtx[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y_mtx[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">]])</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">def </span><span class="s1">blended_transform_factory(x_transform</span><span class="s3">, </span><span class="s1">y_transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a new &quot;blended&quot; transform using *x_transform* to transform 
    the *x*-axis and *y_transform* to transform the *y*-axis. 
 
    A faster version of the blended transform is returned for the case 
    where both child transforms are affine. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(isinstance(x_transform</span><span class="s3">, </span><span class="s1">Affine2DBase) </span><span class="s3">and</span>
            <span class="s1">isinstance(y_transform</span><span class="s3">, </span><span class="s1">Affine2DBase)):</span>
        <span class="s3">return </span><span class="s1">BlendedAffine2D(x_transform</span><span class="s3">, </span><span class="s1">y_transform)</span>
    <span class="s3">return </span><span class="s1">BlendedGenericTransform(x_transform</span><span class="s3">, </span><span class="s1">y_transform)</span>


<span class="s3">class </span><span class="s1">CompositeGenericTransform(Transform):</span>
    <span class="s0">&quot;&quot;&quot; 
    A composite transform formed by applying transform *a* then 
    transform *b*. 
 
    This &quot;generic&quot; version can handle any two arbitrary 
    transformations. 
    &quot;&quot;&quot;</span>
    <span class="s1">pass_through = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new composite transform that is the result of 
        applying transform *a* then transform *b*. 
 
        You will generally not call this constructor directly but write ``a + 
        b`` instead, which will automatically choose the best kind of composite 
        transform instance to create. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">a.output_dims != b.input_dims:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The output dimension of 'a' must be equal to &quot;</span>
                             <span class="s4">&quot;the input dimensions of 'b'&quot;</span><span class="s1">)</span>
        <span class="s1">self.input_dims = a.input_dims</span>
        <span class="s1">self.output_dims = b.output_dims</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._a = a</span>
        <span class="s1">self._b = b</span>
        <span class="s1">self.set_children(a</span><span class="s3">, </span><span class="s1">b)</span>

    <span class="s3">def </span><span class="s1">frozen(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s1">frozen = composite_transform_factory(</span>
            <span class="s1">self._a.frozen()</span><span class="s3">, </span><span class="s1">self._b.frozen())</span>
        <span class="s3">if not </span><span class="s1">isinstance(frozen</span><span class="s3">, </span><span class="s1">CompositeGenericTransform):</span>
            <span class="s3">return </span><span class="s1">frozen.frozen()</span>
        <span class="s3">return </span><span class="s1">frozen</span>

    <span class="s3">def </span><span class="s1">_invalidate_internal(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">invalidating_node):</span>
        <span class="s2"># In some cases for a composite transform, an invalidating call to</span>
        <span class="s2"># AFFINE_ONLY needs to be extended to invalidate the NON_AFFINE part</span>
        <span class="s2"># too. These cases are when the right hand transform is non-affine and</span>
        <span class="s2"># either:</span>
        <span class="s2"># (a) the left hand transform is non affine</span>
        <span class="s2"># (b) it is the left hand node which has triggered the invalidation</span>
        <span class="s3">if </span><span class="s1">(value == Transform.INVALID_AFFINE </span><span class="s3">and</span>
                <span class="s3">not </span><span class="s1">self._b.is_affine </span><span class="s3">and</span>
                <span class="s1">(</span><span class="s3">not </span><span class="s1">self._a.is_affine </span><span class="s3">or </span><span class="s1">invalidating_node </span><span class="s3">is </span><span class="s1">self._a)):</span>
            <span class="s1">value = Transform.INVALID</span>

        <span class="s1">super()._invalidate_internal(value=value</span><span class="s3">,</span>
                                     <span class="s1">invalidating_node=invalidating_node)</span>

    <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">(CompositeGenericTransform</span><span class="s3">, </span><span class="s1">CompositeAffine2D)):</span>
            <span class="s3">return </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other </span><span class="s3">or </span><span class="s1">(self._a == other._a</span>
                                     <span class="s3">and </span><span class="s1">self._b == other._b)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">_iter_break_from_left_to_right(self):</span>
        <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">self._a._iter_break_from_left_to_right():</span>
            <span class="s3">yield </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right + self._b</span>
        <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">self._b._iter_break_from_left_to_right():</span>
            <span class="s3">yield </span><span class="s1">self._a + left</span><span class="s3">, </span><span class="s1">right</span>

    <span class="s1">depth = property(</span><span class="s3">lambda </span><span class="s1">self: self._a.depth + self._b.depth)</span>
    <span class="s1">is_affine = property(</span><span class="s3">lambda </span><span class="s1">self: self._a.is_affine </span><span class="s3">and </span><span class="s1">self._b.is_affine)</span>
    <span class="s1">is_separable = property(</span>
        <span class="s3">lambda </span><span class="s1">self: self._a.is_separable </span><span class="s3">and </span><span class="s1">self._b.is_separable)</span>
    <span class="s1">has_inverse = property(</span>
        <span class="s3">lambda </span><span class="s1">self: self._a.has_inverse </span><span class="s3">and </span><span class="s1">self._b.has_inverse)</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_a&quot;</span><span class="s3">, </span><span class="s4">&quot;_b&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">transform_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">self.get_affine().transform(points)</span>

    <span class="s3">def </span><span class="s1">transform_non_affine(self</span><span class="s3">, </span><span class="s1">points):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._a.is_affine </span><span class="s3">and </span><span class="s1">self._b.is_affine:</span>
            <span class="s3">return </span><span class="s1">points</span>
        <span class="s3">elif not </span><span class="s1">self._a.is_affine </span><span class="s3">and </span><span class="s1">self._b.is_affine:</span>
            <span class="s3">return </span><span class="s1">self._a.transform_non_affine(points)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._b.transform_non_affine(self._a.transform(points))</span>

    <span class="s3">def </span><span class="s1">transform_path_non_affine(self</span><span class="s3">, </span><span class="s1">path):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._a.is_affine </span><span class="s3">and </span><span class="s1">self._b.is_affine:</span>
            <span class="s3">return </span><span class="s1">path</span>
        <span class="s3">elif not </span><span class="s1">self._a.is_affine </span><span class="s3">and </span><span class="s1">self._b.is_affine:</span>
            <span class="s3">return </span><span class="s1">self._a.transform_path_non_affine(path)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._b.transform_path_non_affine(</span>
                                    <span class="s1">self._a.transform_path(path))</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if not </span><span class="s1">self._b.is_affine:</span>
            <span class="s3">return </span><span class="s1">self._b.get_affine()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">Affine2D(np.dot(self._b.get_affine().get_matrix()</span><span class="s3">,</span>
                                   <span class="s1">self._a.get_affine().get_matrix()))</span>

    <span class="s3">def </span><span class="s1">inverted(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">return </span><span class="s1">CompositeGenericTransform(</span>
            <span class="s1">self._b.inverted()</span><span class="s3">, </span><span class="s1">self._a.inverted())</span>


<span class="s3">class </span><span class="s1">CompositeAffine2D(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A composite transform formed by applying transform *a* then transform *b*. 
 
    This version is an optimization that handles the case where both *a* 
    and *b* are 2D affines. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new composite transform that is the result of 
        applying `Affine2DBase` *a* then `Affine2DBase` *b*. 
 
        You will generally not call this constructor directly but write ``a + 
        b`` instead, which will automatically choose the best kind of composite 
        transform instance to create. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">a.is_affine </span><span class="s3">or not </span><span class="s1">b.is_affine:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'a' and 'b' must be affine transforms&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">a.output_dims != b.input_dims:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The output dimension of 'a' must be equal to &quot;</span>
                             <span class="s4">&quot;the input dimensions of 'b'&quot;</span><span class="s1">)</span>
        <span class="s1">self.input_dims = a.input_dims</span>
        <span class="s1">self.output_dims = b.output_dims</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._a = a</span>
        <span class="s1">self._b = b</span>
        <span class="s1">self.set_children(a</span><span class="s3">, </span><span class="s1">b)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">depth(self):</span>
        <span class="s3">return </span><span class="s1">self._a.depth + self._b.depth</span>

    <span class="s3">def </span><span class="s1">_iter_break_from_left_to_right(self):</span>
        <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">self._a._iter_break_from_left_to_right():</span>
            <span class="s3">yield </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right + self._b</span>
        <span class="s3">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">self._b._iter_break_from_left_to_right():</span>
            <span class="s3">yield </span><span class="s1">self._a + left</span><span class="s3">, </span><span class="s1">right</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_a&quot;</span><span class="s3">, </span><span class="s4">&quot;_b&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">self._mtx = np.dot(</span>
                <span class="s1">self._b.get_matrix()</span><span class="s3">,</span>
                <span class="s1">self._a.get_matrix())</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">def </span><span class="s1">composite_transform_factory(a</span><span class="s3">, </span><span class="s1">b):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a new composite transform that is the result of applying 
    transform a then transform b. 
 
    Shortcut versions of the blended transform are provided for the 
    case where both child transforms are affine, or one or the other 
    is the identity transform. 
 
    Composite transforms may also be created using the '+' operator, 
    e.g.:: 
 
      c = a + b 
    &quot;&quot;&quot;</span>
    <span class="s2"># check to see if any of a or b are IdentityTransforms. We use</span>
    <span class="s2"># isinstance here to guarantee that the transforms will *always*</span>
    <span class="s2"># be IdentityTransforms. Since TransformWrappers are mutable,</span>
    <span class="s2"># use of equality here would be wrong.</span>
    <span class="s3">if </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">IdentityTransform):</span>
        <span class="s3">return </span><span class="s1">b</span>
    <span class="s3">elif </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">IdentityTransform):</span>
        <span class="s3">return </span><span class="s1">a</span>
    <span class="s3">elif </span><span class="s1">isinstance(a</span><span class="s3">, </span><span class="s1">Affine2D) </span><span class="s3">and </span><span class="s1">isinstance(b</span><span class="s3">, </span><span class="s1">Affine2D):</span>
        <span class="s3">return </span><span class="s1">CompositeAffine2D(a</span><span class="s3">, </span><span class="s1">b)</span>
    <span class="s3">return </span><span class="s1">CompositeGenericTransform(a</span><span class="s3">, </span><span class="s1">b)</span>


<span class="s3">class </span><span class="s1">BboxTransform(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    `BboxTransform` linearly transforms points from one `Bbox` to another. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_separable = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">boxin</span><span class="s3">, </span><span class="s1">boxout</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new `BboxTransform` that linearly transforms 
        points from *boxin* to *boxout*. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">boxin.is_bbox </span><span class="s3">or not </span><span class="s1">boxout.is_bbox:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'boxin' and 'boxout' must be bbox&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._boxin = boxin</span>
        <span class="s1">self._boxout = boxout</span>
        <span class="s1">self.set_children(boxin</span><span class="s3">, </span><span class="s1">boxout)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>
        <span class="s1">self._inverted = </span><span class="s3">None</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_boxin&quot;</span><span class="s3">, </span><span class="s4">&quot;_boxout&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">inl</span><span class="s3">, </span><span class="s1">inb</span><span class="s3">, </span><span class="s1">inw</span><span class="s3">, </span><span class="s1">inh = self._boxin.bounds</span>
            <span class="s1">outl</span><span class="s3">, </span><span class="s1">outb</span><span class="s3">, </span><span class="s1">outw</span><span class="s3">, </span><span class="s1">outh = self._boxout.bounds</span>
            <span class="s1">x_scale = outw / inw</span>
            <span class="s1">y_scale = outh / inh</span>
            <span class="s3">if </span><span class="s1">DEBUG </span><span class="s3">and </span><span class="s1">(x_scale == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">y_scale == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Transforming from or to a singular bounding box&quot;</span><span class="s1">)</span>
            <span class="s1">self._mtx = np.array([[x_scale</span><span class="s3">, </span><span class="s5">0.0    </span><span class="s3">, </span><span class="s1">(-inl*x_scale+outl)]</span><span class="s3">,</span>
                                  <span class="s1">[</span><span class="s5">0.0    </span><span class="s3">, </span><span class="s1">y_scale</span><span class="s3">, </span><span class="s1">(-inb*y_scale+outb)]</span><span class="s3">,</span>
                                  <span class="s1">[</span><span class="s5">0.0    </span><span class="s3">, </span><span class="s5">0.0    </span><span class="s3">, </span><span class="s5">1.0        </span><span class="s1">]]</span><span class="s3">,</span>
                                 <span class="s1">float)</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">BboxTransformTo(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    `BboxTransformTo` is a transformation that linearly transforms points from 
    the unit bounding box to a given `Bbox`. 
    &quot;&quot;&quot;</span>

    <span class="s1">is_separable = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">boxout</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new `BboxTransformTo` that linearly transforms 
        points from the unit bounding box to *boxout*. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">boxout.is_bbox:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'boxout' must be bbox&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._boxout = boxout</span>
        <span class="s1">self.set_children(boxout)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>
        <span class="s1">self._inverted = </span><span class="s3">None</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_boxout&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">outl</span><span class="s3">, </span><span class="s1">outb</span><span class="s3">, </span><span class="s1">outw</span><span class="s3">, </span><span class="s1">outh = self._boxout.bounds</span>
            <span class="s3">if </span><span class="s1">DEBUG </span><span class="s3">and </span><span class="s1">(outw == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">outh == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Transforming to a singular bounding box.&quot;</span><span class="s1">)</span>
            <span class="s1">self._mtx = np.array([[outw</span><span class="s3">,  </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">outl]</span><span class="s3">,</span>
                                  <span class="s1">[ </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">outh</span><span class="s3">, </span><span class="s1">outb]</span><span class="s3">,</span>
                                  <span class="s1">[ </span><span class="s5">0.0</span><span class="s3">,  </span><span class="s5">0.0</span><span class="s3">,  </span><span class="s5">1.0</span><span class="s1">]]</span><span class="s3">,</span>
                                 <span class="s1">float)</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">BboxTransformToMaxOnly(BboxTransformTo):</span>
    <span class="s0">&quot;&quot;&quot; 
    `BboxTransformTo` is a transformation that linearly transforms points from 
    the unit bounding box to a given `Bbox` with a fixed upper left of (0, 0). 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">xmax</span><span class="s3">, </span><span class="s1">ymax = self._boxout.max</span>
            <span class="s3">if </span><span class="s1">DEBUG </span><span class="s3">and </span><span class="s1">(xmax == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">ymax == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Transforming to a singular bounding box.&quot;</span><span class="s1">)</span>
            <span class="s1">self._mtx = np.array([[xmax</span><span class="s3">,  </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">[ </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">ymax</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">[ </span><span class="s5">0.0</span><span class="s3">,  </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">]]</span><span class="s3">,</span>
                                 <span class="s1">float)</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">BboxTransformFrom(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    `BboxTransformFrom` linearly transforms points from a given `Bbox` to the 
    unit bounding box. 
    &quot;&quot;&quot;</span>
    <span class="s1">is_separable = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">boxin</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s3">if not </span><span class="s1">boxin.is_bbox:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;'boxin' must be bbox&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._boxin = boxin</span>
        <span class="s1">self.set_children(boxin)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>
        <span class="s1">self._inverted = </span><span class="s3">None</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_boxin&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">inl</span><span class="s3">, </span><span class="s1">inb</span><span class="s3">, </span><span class="s1">inw</span><span class="s3">, </span><span class="s1">inh = self._boxin.bounds</span>
            <span class="s3">if </span><span class="s1">DEBUG </span><span class="s3">and </span><span class="s1">(inw == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">inh == </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Transforming from a singular bounding box.&quot;</span><span class="s1">)</span>
            <span class="s1">x_scale = </span><span class="s5">1.0 </span><span class="s1">/ inw</span>
            <span class="s1">y_scale = </span><span class="s5">1.0 </span><span class="s1">/ inh</span>
            <span class="s1">self._mtx = np.array([[x_scale</span><span class="s3">, </span><span class="s5">0.0    </span><span class="s3">, </span><span class="s1">(-inl*x_scale)]</span><span class="s3">,</span>
                                  <span class="s1">[</span><span class="s5">0.0    </span><span class="s3">, </span><span class="s1">y_scale</span><span class="s3">, </span><span class="s1">(-inb*y_scale)]</span><span class="s3">,</span>
                                  <span class="s1">[</span><span class="s5">0.0    </span><span class="s3">, </span><span class="s5">0.0    </span><span class="s3">, </span><span class="s5">1.0        </span><span class="s1">]]</span><span class="s3">,</span>
                                 <span class="s1">float)</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">ScaledTranslation(Affine2DBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A transformation that translates by *xt* and *yt*, after *xt* and *yt* 
    have been transformed by *scale_trans*. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">xt</span><span class="s3">, </span><span class="s1">yt</span><span class="s3">, </span><span class="s1">scale_trans</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._t = (xt</span><span class="s3">, </span><span class="s1">yt)</span>
        <span class="s1">self._scale_trans = scale_trans</span>
        <span class="s1">self.set_children(scale_trans)</span>
        <span class="s1">self._mtx = </span><span class="s3">None</span>
        <span class="s1">self._inverted = </span><span class="s3">None</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_t&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s2"># docstring inherited</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s2"># A bit faster than np.identity(3).</span>
            <span class="s1">self._mtx = IdentityTransform._mtx.copy()</span>
            <span class="s1">self._mtx[:</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">] = self._scale_trans.transform(self._t)</span>
            <span class="s1">self._invalid = </span><span class="s5">0</span>
            <span class="s1">self._inverted = </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">AffineDeltaTransform(Affine2DBase):</span>
    <span class="s0">r&quot;&quot;&quot; 
    A transform wrapper for transforming displacements between pairs of points. 
 
    This class is intended to be used to transform displacements (&quot;position 
    deltas&quot;) between pairs of points (e.g., as the ``offset_transform`` 
    of `.Collection`\s): given a transform ``t`` such that ``t = 
    AffineDeltaTransform(t) + offset``, ``AffineDeltaTransform`` 
    satisfies ``AffineDeltaTransform(a - b) == AffineDeltaTransform(a) - 
    AffineDeltaTransform(b)``. 
 
    This is implemented by forcing the offset components of the transform 
    matrix to zero. 
 
    This class is experimental as of 3.3, and the API may change. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._base_transform = transform</span>

    <span class="s1">__str__ = _make_str_method(</span><span class="s4">&quot;_base_transform&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">get_matrix(self):</span>
        <span class="s3">if </span><span class="s1">self._invalid:</span>
            <span class="s1">self._mtx = self._base_transform.get_matrix().copy()</span>
            <span class="s1">self._mtx[:</span><span class="s5">2</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0</span>
        <span class="s3">return </span><span class="s1">self._mtx</span>


<span class="s3">class </span><span class="s1">TransformedPath(TransformNode):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `TransformedPath` caches a non-affine transformed copy of the 
    `~.path.Path`.  This cached copy is automatically updated when the 
    non-affine part of the transform changes. 
 
    .. note:: 
 
        Paths are considered immutable by this class. Any update to the 
        path's vertices/codes will not trigger a transform recomputation. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">transform):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        path : `~.path.Path` 
        transform : `Transform` 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(Transform</span><span class="s3">, </span><span class="s1">transform=transform)</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._path = path</span>
        <span class="s1">self._transform = transform</span>
        <span class="s1">self.set_children(transform)</span>
        <span class="s1">self._transformed_path = </span><span class="s3">None</span>
        <span class="s1">self._transformed_points = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">_revalidate(self):</span>
        <span class="s2"># only recompute if the invalidation includes the non_affine part of</span>
        <span class="s2"># the transform</span>
        <span class="s3">if </span><span class="s1">(self._invalid &amp; self.INVALID_NON_AFFINE == self.INVALID_NON_AFFINE</span>
                <span class="s3">or </span><span class="s1">self._transformed_path </span><span class="s3">is None</span><span class="s1">):</span>
            <span class="s1">self._transformed_path = \</span>
                <span class="s1">self._transform.transform_path_non_affine(self._path)</span>
            <span class="s1">self._transformed_points = \</span>
                <span class="s1">Path._fast_from_codes_and_verts(</span>
                    <span class="s1">self._transform.transform_non_affine(self._path.vertices)</span><span class="s3">,</span>
                    <span class="s3">None, </span><span class="s1">self._path)</span>
        <span class="s1">self._invalid = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">get_transformed_points_and_affine(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the child path, with the non-affine part of 
        the transform already applied, along with the affine part of 
        the path necessary to complete the transformation.  Unlike 
        :meth:`get_transformed_path_and_affine`, no interpolation will 
        be performed. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._revalidate()</span>
        <span class="s3">return </span><span class="s1">self._transformed_points</span><span class="s3">, </span><span class="s1">self.get_affine()</span>

    <span class="s3">def </span><span class="s1">get_transformed_path_and_affine(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the child path, with the non-affine part of 
        the transform already applied, along with the affine part of 
        the path necessary to complete the transformation. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._revalidate()</span>
        <span class="s3">return </span><span class="s1">self._transformed_path</span><span class="s3">, </span><span class="s1">self.get_affine()</span>

    <span class="s3">def </span><span class="s1">get_fully_transformed_path(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a fully-transformed copy of the child path. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._revalidate()</span>
        <span class="s3">return </span><span class="s1">self._transform.transform_path_affine(self._transformed_path)</span>

    <span class="s3">def </span><span class="s1">get_affine(self):</span>
        <span class="s3">return </span><span class="s1">self._transform.get_affine()</span>


<span class="s3">class </span><span class="s1">TransformedPatchPath(TransformedPath):</span>
    <span class="s0">&quot;&quot;&quot; 
    A `TransformedPatchPath` caches a non-affine transformed copy of the 
    `~.patches.Patch`. This cached copy is automatically updated when the 
    non-affine part of the transform or the patch changes. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">patch):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        patch : `~.patches.Patch` 
        &quot;&quot;&quot;</span>
        <span class="s2"># Defer to TransformedPath.__init__.</span>
        <span class="s1">super().__init__(patch.get_path()</span><span class="s3">, </span><span class="s1">patch.get_transform())</span>
        <span class="s1">self._patch = patch</span>

    <span class="s3">def </span><span class="s1">_revalidate(self):</span>
        <span class="s1">patch_path = self._patch.get_path()</span>
        <span class="s2"># Force invalidation if the patch path changed; otherwise, let base</span>
        <span class="s2"># class check invalidation.</span>
        <span class="s3">if </span><span class="s1">patch_path != self._path:</span>
            <span class="s1">self._path = patch_path</span>
            <span class="s1">self._transformed_path = </span><span class="s3">None</span>
        <span class="s1">super()._revalidate()</span>


<span class="s3">def </span><span class="s1">nonsingular(vmin</span><span class="s3">, </span><span class="s1">vmax</span><span class="s3">, </span><span class="s1">expander=</span><span class="s5">0.001</span><span class="s3">, </span><span class="s1">tiny=</span><span class="s5">1e-15</span><span class="s3">, </span><span class="s1">increasing=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Modify the endpoints of a range as needed to avoid singularities. 
 
    Parameters 
    ---------- 
    vmin, vmax : float 
        The initial endpoints. 
    expander : float, default: 0.001 
        Fractional amount by which *vmin* and *vmax* are expanded if 
        the original interval is too small, based on *tiny*. 
    tiny : float, default: 1e-15 
        Threshold for the ratio of the interval to the maximum absolute 
        value of its endpoints.  If the interval is smaller than 
        this, it will be expanded.  This value should be around 
        1e-15 or larger; otherwise the interval will be approaching 
        the double precision resolution limit. 
    increasing : bool, default: True 
        If True, swap *vmin*, *vmax* if *vmin* &gt; *vmax*. 
 
    Returns 
    ------- 
    vmin, vmax : float 
        Endpoints, expanded and/or swapped if necessary. 
        If either input is inf or NaN, or if both inputs are 0 or very 
        close to zero, it returns -*expander*, *expander*. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">np.isfinite(vmin)) </span><span class="s3">or </span><span class="s1">(</span><span class="s3">not </span><span class="s1">np.isfinite(vmax)):</span>
        <span class="s3">return </span><span class="s1">-expander</span><span class="s3">, </span><span class="s1">expander</span>

    <span class="s1">swapped = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">vmax &lt; vmin:</span>
        <span class="s1">vmin</span><span class="s3">, </span><span class="s1">vmax = vmax</span><span class="s3">, </span><span class="s1">vmin</span>
        <span class="s1">swapped = </span><span class="s3">True</span>

    <span class="s2"># Expand vmin, vmax to float: if they were integer types, they can wrap</span>
    <span class="s2"># around in abs (abs(np.int8(-128)) == -128) and vmax - vmin can overflow.</span>
    <span class="s1">vmin</span><span class="s3">, </span><span class="s1">vmax = map(float</span><span class="s3">, </span><span class="s1">[vmin</span><span class="s3">, </span><span class="s1">vmax])</span>

    <span class="s1">maxabsvalue = max(abs(vmin)</span><span class="s3">, </span><span class="s1">abs(vmax))</span>
    <span class="s3">if </span><span class="s1">maxabsvalue &lt; (</span><span class="s5">1e6 </span><span class="s1">/ tiny) * np.finfo(float).tiny:</span>
        <span class="s1">vmin = -expander</span>
        <span class="s1">vmax = expander</span>

    <span class="s3">elif </span><span class="s1">vmax - vmin &lt;= maxabsvalue * tiny:</span>
        <span class="s3">if </span><span class="s1">vmax == </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">vmin == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">vmin = -expander</span>
            <span class="s1">vmax = expander</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">vmin -= expander*abs(vmin)</span>
            <span class="s1">vmax += expander*abs(vmax)</span>

    <span class="s3">if </span><span class="s1">swapped </span><span class="s3">and not </span><span class="s1">increasing:</span>
        <span class="s1">vmin</span><span class="s3">, </span><span class="s1">vmax = vmax</span><span class="s3">, </span><span class="s1">vmin</span>
    <span class="s3">return </span><span class="s1">vmin</span><span class="s3">, </span><span class="s1">vmax</span>


<span class="s3">def </span><span class="s1">interval_contains(interval</span><span class="s3">, </span><span class="s1">val):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check, inclusively, whether an interval includes a given value. 
 
    Parameters 
    ---------- 
    interval : (float, float) 
        The endpoints of the interval. 
    val : float 
        Value to check is within interval. 
 
    Returns 
    ------- 
    bool 
        Whether *val* is within the *interval*. 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b = interval</span>
    <span class="s3">if </span><span class="s1">a &gt; b:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b = b</span><span class="s3">, </span><span class="s1">a</span>
    <span class="s3">return </span><span class="s1">a &lt;= val &lt;= b</span>


<span class="s3">def </span><span class="s1">_interval_contains_close(interval</span><span class="s3">, </span><span class="s1">val</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check, inclusively, whether an interval includes a given value, with the 
    interval expanded by a small tolerance to admit floating point errors. 
 
    Parameters 
    ---------- 
    interval : (float, float) 
        The endpoints of the interval. 
    val : float 
        Value to check is within interval. 
    rtol : float, default: 1e-10 
        Relative tolerance slippage allowed outside of the interval. 
        For an interval ``[a, b]``, values 
        ``a - rtol * (b - a) &lt;= val &lt;= b + rtol * (b - a)`` are considered 
        inside the interval. 
 
    Returns 
    ------- 
    bool 
        Whether *val* is within the *interval* (with tolerance). 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b = interval</span>
    <span class="s3">if </span><span class="s1">a &gt; b:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b = b</span><span class="s3">, </span><span class="s1">a</span>
    <span class="s1">rtol = (b - a) * rtol</span>
    <span class="s3">return </span><span class="s1">a - rtol &lt;= val &lt;= b + rtol</span>


<span class="s3">def </span><span class="s1">interval_contains_open(interval</span><span class="s3">, </span><span class="s1">val):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check, excluding endpoints, whether an interval includes a given value. 
 
    Parameters 
    ---------- 
    interval : (float, float) 
        The endpoints of the interval. 
    val : float 
        Value to check is within interval. 
 
    Returns 
    ------- 
    bool 
        Whether *val* is within the *interval*. 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b = interval</span>
    <span class="s3">return </span><span class="s1">a &lt; val &lt; b </span><span class="s3">or </span><span class="s1">a &gt; val &gt; b</span>


<span class="s3">def </span><span class="s1">offset_copy(trans</span><span class="s3">, </span><span class="s1">fig=</span><span class="s3">None, </span><span class="s1">x=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">y=</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">units=</span><span class="s4">'inches'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a new transform with an added offset. 
 
    Parameters 
    ---------- 
    trans : `Transform` subclass 
        Any transform, to which offset will be applied. 
    fig : `~matplotlib.figure.Figure`, default: None 
        Current figure. It can be None if *units* are 'dots'. 
    x, y : float, default: 0.0 
        The offset to apply. 
    units : {'inches', 'points', 'dots'}, default: 'inches' 
        Units of the offset. 
 
    Returns 
    ------- 
    `Transform` subclass 
        Transform with applied offset. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">units == </span><span class="s4">'dots'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">trans + Affine2D().translate(x</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s3">if </span><span class="s1">fig </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'For units of inches or points a fig kwarg is needed'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">units == </span><span class="s4">'points'</span><span class="s1">:</span>
        <span class="s1">x /= </span><span class="s5">72.0</span>
        <span class="s1">y /= </span><span class="s5">72.0</span>
    <span class="s3">elif </span><span class="s1">units == </span><span class="s4">'inches'</span><span class="s1">:</span>
        <span class="s3">pass</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'dots'</span><span class="s3">, </span><span class="s4">'points'</span><span class="s3">, </span><span class="s4">'inches'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">units=units)</span>
    <span class="s3">return </span><span class="s1">trans + ScaledTranslation(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">fig.dpi_scale_trans)</span>
</pre>
</body>
</html>