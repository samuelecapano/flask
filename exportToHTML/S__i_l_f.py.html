<html>
<head>
<title>S__i_l_f.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
S__i_l_f.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools.misc </span><span class="s0">import </span><span class="s1">sstruct</span>
<span class="s0">from </span><span class="s1">fontTools.misc.fixedTools </span><span class="s0">import </span><span class="s1">floatToFixedToStr</span>
<span class="s0">from </span><span class="s1">fontTools.misc.textTools </span><span class="s0">import </span><span class="s1">byteord</span><span class="s0">, </span><span class="s1">safeEval</span>
<span class="s2"># from itertools import *</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">DefaultTable</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">grUtils</span>
<span class="s0">from </span><span class="s1">array </span><span class="s0">import </span><span class="s1">array</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">reduce</span>
<span class="s0">import </span><span class="s1">struct</span><span class="s0">, </span><span class="s1">re</span><span class="s0">, </span><span class="s1">sys</span>

<span class="s1">Silf_hdr_format = </span><span class="s3">''' 
    &gt; 
    version:            16.16F 
'''</span>

<span class="s1">Silf_hdr_format_3 = </span><span class="s3">''' 
    &gt; 
    version:            16.16F 
    compilerVersion:    L 
    numSilf:            H 
                        x 
                        x 
'''</span>

<span class="s1">Silf_part1_format_v3 = </span><span class="s3">''' 
    &gt; 
    ruleVersion:        16.16F 
    passOffset:         H 
    pseudosOffset:      H 
'''</span>

<span class="s1">Silf_part1_format = </span><span class="s3">''' 
    &gt; 
    maxGlyphID:         H 
    extraAscent:        h 
    extraDescent:       h 
    numPasses:          B 
    iSubst:             B 
    iPos:               B 
    iJust:              B 
    iBidi:              B 
    flags:              B 
    maxPreContext:      B 
    maxPostContext:     B 
    attrPseudo:         B 
    attrBreakWeight:    B 
    attrDirectionality: B 
    attrMirroring:      B 
    attrSkipPasses:     B 
    numJLevels:         B 
'''</span>

<span class="s1">Silf_justify_format = </span><span class="s3">''' 
    &gt; 
    attrStretch:        B 
    attrShrink:         B 
    attrStep:           B 
    attrWeight:         B 
    runto:              B 
                        x 
                        x 
                        x 
'''</span>

<span class="s1">Silf_part2_format = </span><span class="s3">''' 
    &gt; 
    numLigComp:         H 
    numUserDefn:        B 
    maxCompPerLig:      B 
    direction:          B 
    attCollisions:      B 
                        x 
                        x 
                        x 
    numCritFeatures:    B 
'''</span>

<span class="s1">Silf_pseudomap_format = </span><span class="s3">''' 
    &gt; 
    unicode:            L 
    nPseudo:            H 
'''</span>

<span class="s1">Silf_pseudomap_format_h = </span><span class="s3">''' 
    &gt; 
    unicode:            H 
    nPseudo:            H 
'''</span>

<span class="s1">Silf_classmap_format = </span><span class="s3">''' 
    &gt; 
    numClass:           H 
    numLinear:          H 
'''</span>

<span class="s1">Silf_lookupclass_format = </span><span class="s3">''' 
    &gt; 
    numIDs:             H 
    searchRange:        H 
    entrySelector:      H 
    rangeShift:         H 
'''</span>

<span class="s1">Silf_lookuppair_format = </span><span class="s3">''' 
    &gt; 
    glyphId:            H 
    index:              H 
'''</span>

<span class="s1">Silf_pass_format = </span><span class="s3">''' 
    &gt; 
    flags:              B 
    maxRuleLoop:        B 
    maxRuleContext:     B 
    maxBackup:          B 
    numRules:           H 
    fsmOffset:          H 
    pcCode:             L 
    rcCode:             L 
    aCode:              L 
    oDebug:             L 
    numRows:            H 
    numTransitional:    H 
    numSuccess:         H 
    numColumns:         H 
'''</span>

<span class="s1">aCode_info = (</span>
    <span class="s1">(</span><span class="s3">&quot;NOP&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_BYTE&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_BYTE_U&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_SHORT&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;h&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_SHORT_U&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;H&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_LONG&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;L&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;ADD&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;SUB&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;MUL&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;DIV&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;MIN&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;MAX&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;NEG&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;TRUNC8&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;TRUNC16&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;COND&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;AND&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,         </span><span class="s2"># x10</span>
    <span class="s1">(</span><span class="s3">&quot;OR&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;NOT&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;EQUAL&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;NOT_EQ&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;LESS&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;GTR&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;LESS_EQ&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;GTR_EQ&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;NEXT&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;NEXT_N&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;COPY_NEXT&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_GLYPH_8BIT_OBS&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_SUBS_8BIT_OBS&quot;</span><span class="s0">, </span><span class="s3">&quot;bBB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_COPY&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;INSERT&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;DELETE&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,      </span><span class="s2"># x20</span>
    <span class="s1">(</span><span class="s3">&quot;ASSOC&quot;</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;CNTXT_ITEM&quot;</span><span class="s0">, </span><span class="s3">&quot;bB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;ATTR_SET&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;ATTR_ADD&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;ATTR_SUB&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;ATTR_SET_SLOT&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;IATTR_SET_SLOT&quot;</span><span class="s0">, </span><span class="s3">&quot;BB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_SLOT_ATTR&quot;</span><span class="s0">, </span><span class="s3">&quot;Bb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_GLYPH_ATTR_OBS&quot;</span><span class="s0">, </span><span class="s3">&quot;Bb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_GLYPH_METRIC&quot;</span><span class="s0">, </span><span class="s3">&quot;Bbb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_FEAT&quot;</span><span class="s0">, </span><span class="s3">&quot;Bb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_ATT_TO_GATTR_OBS&quot;</span><span class="s0">, </span><span class="s3">&quot;Bb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_ATT_TO_GLYPH_METRIC&quot;</span><span class="s0">, </span><span class="s3">&quot;Bbb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_ISLOT_ATTR&quot;</span><span class="s0">, </span><span class="s3">&quot;Bbb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_IGLYPH_ATTR&quot;</span><span class="s0">, </span><span class="s3">&quot;Bbb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;POP_RET&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,     </span><span class="s2"># x30</span>
    <span class="s1">(</span><span class="s3">&quot;RET_ZERO&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;RET_TRUE&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;IATTR_SET&quot;</span><span class="s0">, </span><span class="s3">&quot;BB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;IATTR_ADD&quot;</span><span class="s0">, </span><span class="s3">&quot;BB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;IATTR_SUB&quot;</span><span class="s0">, </span><span class="s3">&quot;BB&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_PROC_STATE&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_VERSION&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_SUBS&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;bHH&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_SUBS2&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_SUBS3&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUT_GLYPH&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;H&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_GLYPH_ATTR&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;Hb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;PUSH_ATT_TO_GLYPH_ATTR&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;Hb&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;BITOR&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;BITAND&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;BITNOT&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">,      </span><span class="s2"># x40</span>
    <span class="s1">(</span><span class="s3">&quot;BITSET&quot;</span><span class="s0">, </span><span class="s3">&quot;&gt;HH&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s3">&quot;SET_FEAT&quot;</span><span class="s0">, </span><span class="s3">&quot;Bb&quot;</span><span class="s1">)</span>
<span class="s1">)</span>
<span class="s1">aCode_map = dict([(x[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">])) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">,</span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(aCode_info)])</span>

<span class="s0">def </span><span class="s1">disassemble(aCode):</span>
    <span class="s1">codelen = len(aCode)</span>
    <span class="s1">pc = </span><span class="s4">0</span>
    <span class="s1">res = []</span>
    <span class="s0">while </span><span class="s1">pc &lt; codelen:</span>
        <span class="s1">opcode = byteord(aCode[pc:pc+</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">opcode &gt; len(aCode_info):</span>
            <span class="s1">instr = aCode_info[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">instr = aCode_info[opcode]</span>
        <span class="s1">pc += </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">instr[</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">pc &gt;= codelen : </span><span class="s0">return </span><span class="s1">res</span>
        <span class="s0">if </span><span class="s1">instr[</span><span class="s4">1</span><span class="s1">] == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">count = byteord(aCode[pc])</span>
            <span class="s1">fmt = </span><span class="s3">&quot;%dB&quot; </span><span class="s1">% count</span>
            <span class="s1">pc += </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">instr[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">fmt = </span><span class="s3">&quot;&quot;</span>
        <span class="s0">else </span><span class="s1">:</span>
            <span class="s1">fmt = instr[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">fmt == </span><span class="s3">&quot;&quot;</span><span class="s1">:</span>
            <span class="s1">res.append(instr[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s0">continue</span>
        <span class="s1">parms = struct.unpack_from(fmt</span><span class="s0">, </span><span class="s1">aCode[pc:])</span>
        <span class="s1">res.append(instr[</span><span class="s4">0</span><span class="s1">] + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">parms)) + </span><span class="s3">&quot;)&quot;</span><span class="s1">)</span>
        <span class="s1">pc += struct.calcsize(fmt)</span>
    <span class="s0">return </span><span class="s1">res</span>

<span class="s1">instre = re.compile(</span><span class="s3">r&quot;^\s*([^(]+)\s*(?:\(([^)]+)\))?&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">assemble(instrs):</span>
    <span class="s1">res = </span><span class="s5">b&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">inst </span><span class="s0">in </span><span class="s1">instrs:</span>
        <span class="s1">m = instre.match(inst)</span>
        <span class="s0">if not </span><span class="s1">m </span><span class="s0">or not </span><span class="s1">m.group(</span><span class="s4">1</span><span class="s1">) </span><span class="s0">in </span><span class="s1">aCode_map:</span>
            <span class="s0">continue</span>
        <span class="s1">opcode</span><span class="s0">, </span><span class="s1">parmfmt = aCode_map[m.group(</span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">res += struct.pack(</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s1">opcode)</span>
        <span class="s0">if </span><span class="s1">m.group(</span><span class="s4">2</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">parmfmt == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s1">parms = [int(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">re.split(</span><span class="s3">r&quot;,\s*&quot;</span><span class="s0">, </span><span class="s1">m.group(</span><span class="s4">2</span><span class="s1">))]</span>
            <span class="s0">if </span><span class="s1">parmfmt == -</span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">l = len(parms)</span>
                <span class="s1">res += struct.pack((</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% (l+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">*parms)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">res += struct.pack(parmfmt</span><span class="s0">, </span><span class="s1">*parms)</span>
    <span class="s0">return </span><span class="s1">res</span>

<span class="s0">def </span><span class="s1">writecode(tag</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">instrs):</span>
    <span class="s1">writer.begintag(tag)</span>
    <span class="s1">writer.newline()</span>
    <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">disassemble(instrs):</span>
        <span class="s1">writer.write(l)</span>
        <span class="s1">writer.newline()</span>
    <span class="s1">writer.endtag(tag)</span>
    <span class="s1">writer.newline()</span>

<span class="s0">def </span><span class="s1">readcode(content):</span>
    <span class="s1">res = []</span>
    <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">content_string(content).split(</span><span class="s3">'</span><span class="s0">\n</span><span class="s3">'</span><span class="s1">):</span>
        <span class="s1">e = e.strip()</span>
        <span class="s0">if not </span><span class="s1">len(e): </span><span class="s0">continue</span>
        <span class="s1">res.append(e)</span>
    <span class="s0">return </span><span class="s1">assemble(res)</span>
    
<span class="s1">attrs_info=(</span><span class="s3">'flags'</span><span class="s0">, </span><span class="s3">'extraAscent'</span><span class="s0">, </span><span class="s3">'extraDescent'</span><span class="s0">, </span><span class="s3">'maxGlyphID'</span><span class="s0">,</span>
            <span class="s3">'numLigComp'</span><span class="s0">, </span><span class="s3">'numUserDefn'</span><span class="s0">, </span><span class="s3">'maxCompPerLig'</span><span class="s0">, </span><span class="s3">'direction'</span><span class="s0">, </span><span class="s3">'lbGID'</span><span class="s1">)</span>
<span class="s1">attrs_passindexes = (</span><span class="s3">'iSubst'</span><span class="s0">, </span><span class="s3">'iPos'</span><span class="s0">, </span><span class="s3">'iJust'</span><span class="s0">, </span><span class="s3">'iBidi'</span><span class="s1">)</span>
<span class="s1">attrs_contexts = (</span><span class="s3">'maxPreContext'</span><span class="s0">, </span><span class="s3">'maxPostContext'</span><span class="s1">)</span>
<span class="s1">attrs_attributes = (</span><span class="s3">'attrPseudo'</span><span class="s0">, </span><span class="s3">'attrBreakWeight'</span><span class="s0">, </span><span class="s3">'attrDirectionality'</span><span class="s0">,</span>
                    <span class="s3">'attrMirroring'</span><span class="s0">, </span><span class="s3">'attrSkipPasses'</span><span class="s0">, </span><span class="s3">'attCollisions'</span><span class="s1">)</span>
<span class="s1">pass_attrs_info = (</span><span class="s3">'flags'</span><span class="s0">, </span><span class="s3">'maxRuleLoop'</span><span class="s0">, </span><span class="s3">'maxRuleContext'</span><span class="s0">, </span><span class="s3">'maxBackup'</span><span class="s0">,</span>
            <span class="s3">'minRulePreContext'</span><span class="s0">, </span><span class="s3">'maxRulePreContext'</span><span class="s0">, </span><span class="s3">'collisionThreshold'</span><span class="s1">)</span>
<span class="s1">pass_attrs_fsm = (</span><span class="s3">'numRows'</span><span class="s0">, </span><span class="s3">'numTransitional'</span><span class="s0">, </span><span class="s3">'numSuccess'</span><span class="s0">, </span><span class="s3">'numColumns'</span><span class="s1">)</span>

<span class="s0">def </span><span class="s1">writesimple(tag</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*attrkeys):</span>
    <span class="s1">attrs = dict([(k</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s1">k)) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">attrkeys])</span>
    <span class="s1">writer.simpletag(tag</span><span class="s0">, </span><span class="s1">**attrs)</span>
    <span class="s1">writer.newline()</span>

<span class="s0">def </span><span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*attr_list):</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">attr_list:</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">attrs:</span>
            <span class="s1">setattr(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">int(safeEval(attrs[k])))</span>

<span class="s0">def </span><span class="s1">content_string(contents):</span>
    <span class="s1">res = </span><span class="s3">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">contents:</span>
        <span class="s0">if </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
        <span class="s1">res += element</span>
    <span class="s0">return </span><span class="s1">res.strip()</span>

<span class="s0">def </span><span class="s1">wrapline(writer</span><span class="s0">, </span><span class="s1">dat</span><span class="s0">, </span><span class="s1">length=</span><span class="s4">80</span><span class="s1">):</span>
    <span class="s1">currline = </span><span class="s3">&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dat:</span>
        <span class="s0">if </span><span class="s1">len(currline) &gt; length:</span>
            <span class="s1">writer.write(currline[:-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">currline = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">currline += d + </span><span class="s3">&quot; &quot;</span>
    <span class="s0">if </span><span class="s1">len(currline):</span>
        <span class="s1">writer.write(currline[:-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">writer.newline()</span>

<span class="s0">class </span><span class="s1">_Object() :</span>
    <span class="s0">pass</span>

<span class="s0">class </span><span class="s1">table_S__i_l_f(DefaultTable.DefaultTable):</span>
    <span class="s6">'''Silf table support'''</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">tag=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">DefaultTable.DefaultTable.__init__(self</span><span class="s0">, </span><span class="s1">tag)</span>
        <span class="s1">self.silfs = []</span>

    <span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont):</span>
        <span class="s1">sstruct.unpack2(Silf_hdr_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s1">self.version = float(floatToFixedToStr(self.version</span><span class="s0">, </span><span class="s1">precisionBits=</span><span class="s4">16</span><span class="s1">))</span>
        <span class="s0">if </span><span class="s1">self.version &gt;= </span><span class="s4">5.0</span><span class="s1">:</span>
            <span class="s1">(data</span><span class="s0">, </span><span class="s1">self.scheme) = grUtils.decompress(data)</span>
            <span class="s1">sstruct.unpack2(Silf_hdr_format_3</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
            <span class="s1">base = sstruct.calcsize(Silf_hdr_format_3)</span>
        <span class="s0">elif </span><span class="s1">self.version &lt; </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">self.numSilf = struct.unpack(</span><span class="s3">'&gt;H'</span><span class="s0">, </span><span class="s1">data[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">6</span><span class="s1">])</span>
            <span class="s1">self.scheme = </span><span class="s4">0</span>
            <span class="s1">self.compilerVersion = </span><span class="s4">0</span>
            <span class="s1">base = </span><span class="s4">8</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.scheme = </span><span class="s4">0</span>
            <span class="s1">sstruct.unpack2(Silf_hdr_format_3</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
            <span class="s1">base = sstruct.calcsize(Silf_hdr_format_3)</span>

        <span class="s1">silfoffsets = struct.unpack_from((</span><span class="s3">'&gt;%dL' </span><span class="s1">% self.numSilf)</span><span class="s0">, </span><span class="s1">data[base:])</span>
        <span class="s0">for </span><span class="s1">offset </span><span class="s0">in </span><span class="s1">silfoffsets:</span>
            <span class="s1">s = Silf()</span>
            <span class="s1">self.silfs.append(s)</span>
            <span class="s1">s.decompile(data[offset:]</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">self.version)</span>

    <span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont):</span>
        <span class="s1">self.numSilf = len(self.silfs)</span>
        <span class="s0">if </span><span class="s1">self.version &lt; </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">hdr = sstruct.pack(Silf_hdr_format</span><span class="s0">, </span><span class="s1">self)</span>
            <span class="s1">hdr += struct.pack(</span><span class="s3">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">self.numSilf</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hdr = sstruct.pack(Silf_hdr_format_3</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s1">offset = len(hdr) + </span><span class="s4">4 </span><span class="s1">* self.numSilf</span>
        <span class="s1">data = </span><span class="s5">b&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self.silfs:</span>
            <span class="s1">hdr += struct.pack(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">offset)</span>
            <span class="s1">subdata = s.compile(ttFont</span><span class="s0">, </span><span class="s1">self.version)</span>
            <span class="s1">offset += len(subdata)</span>
            <span class="s1">data += subdata</span>
        <span class="s0">if </span><span class="s1">self.version &gt;= </span><span class="s4">5.0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">grUtils.compress(self.scheme</span><span class="s0">, </span><span class="s1">hdr+data)</span>
        <span class="s0">return </span><span class="s1">hdr+data</span>

    <span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont):</span>
        <span class="s1">writer.comment(</span><span class="s3">'Attributes starting with _ are informative only'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.simpletag(</span><span class="s3">'version'</span><span class="s0">, </span><span class="s1">version=self.version</span><span class="s0">,</span>
            <span class="s1">compilerVersion=self.compilerVersion</span><span class="s0">, </span><span class="s1">compressionScheme=self.scheme)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">self.silfs:</span>
            <span class="s1">writer.begintag(</span><span class="s3">'silf'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">s.toXML(writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">self.version)</span>
            <span class="s1">writer.endtag(</span><span class="s3">'silf'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>

    <span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont):</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'version'</span><span class="s1">:</span>
            <span class="s1">self.scheme=int(safeEval(attrs[</span><span class="s3">'compressionScheme'</span><span class="s1">]))</span>
            <span class="s1">self.version = float(safeEval(attrs[</span><span class="s3">'version'</span><span class="s1">]))</span>
            <span class="s1">self.compilerVersion = int(safeEval(attrs[</span><span class="s3">'compilerVersion'</span><span class="s1">]))</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'silf'</span><span class="s1">:</span>
            <span class="s1">s = Silf()</span>
            <span class="s1">self.silfs.append(s)</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent = element</span>
                <span class="s1">s.fromXML(tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">self.version)</span>

<span class="s0">class </span><span class="s1">Silf(object):</span>
    <span class="s6">'''A particular Silf subtable'''</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.passes = []</span>
        <span class="s1">self.scriptTags = []</span>
        <span class="s1">self.critFeatures = []</span>
        <span class="s1">self.jLevels = []</span>
        <span class="s1">self.pMap = {}</span>

    <span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0 </span><span class="s1">:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">data = sstruct.unpack2(Silf_part1_format_v3</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
            <span class="s1">self.ruleVersion = float(floatToFixedToStr(self.ruleVersion</span><span class="s0">, </span><span class="s1">precisionBits=</span><span class="s4">16</span><span class="s1">))</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">data = sstruct.unpack2(Silf_part1_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">for </span><span class="s1">jlevel </span><span class="s0">in </span><span class="s1">range(self.numJLevels):</span>
            <span class="s1">j</span><span class="s0">, </span><span class="s1">data = sstruct.unpack2(Silf_justify_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">_Object())</span>
            <span class="s1">self.jLevels.append(j)</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">data = sstruct.unpack2(Silf_part2_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">if </span><span class="s1">self.numCritFeatures:</span>
            <span class="s1">self.critFeatures = struct.unpack_from((</span><span class="s3">'&gt;%dH' </span><span class="s1">% self.numCritFeatures)</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">data = data[self.numCritFeatures * </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">(numScriptTag</span><span class="s0">,</span><span class="s1">) = struct.unpack_from(</span><span class="s3">'B'</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s0">if </span><span class="s1">numScriptTag:</span>
            <span class="s1">self.scriptTags = [struct.unpack(</span><span class="s3">&quot;4s&quot;</span><span class="s0">, </span><span class="s1">data[x:x+</span><span class="s4">4</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">].decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* numScriptTag</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)]</span>
        <span class="s1">data = data[</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* numScriptTag:]</span>
        <span class="s1">(self.lbGID</span><span class="s0">,</span><span class="s1">) = struct.unpack(</span><span class="s3">'&gt;H'</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">self.numPasses:</span>
            <span class="s1">self.oPasses = struct.unpack((</span><span class="s3">'&gt;%dL' </span><span class="s1">% (self.numPasses+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">data[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">6</span><span class="s1">+</span><span class="s4">4</span><span class="s1">*self.numPasses])</span>
        <span class="s1">data = data[</span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* self.numPasses:]</span>
        <span class="s1">(numPseudo</span><span class="s0">,</span><span class="s1">) = struct.unpack(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(numPseudo):</span>
            <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0</span><span class="s1">:</span>
                <span class="s1">pseudo = sstruct.unpack(Silf_pseudomap_format</span><span class="s0">, </span><span class="s1">data[</span><span class="s4">8</span><span class="s1">+</span><span class="s4">6</span><span class="s1">*i:</span><span class="s4">14</span><span class="s1">+</span><span class="s4">6</span><span class="s1">*i]</span><span class="s0">, </span><span class="s1">_Object())</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">pseudo = sstruct.unpack(Silf_pseudomap_format_h</span><span class="s0">, </span><span class="s1">data[</span><span class="s4">8</span><span class="s1">+</span><span class="s4">4</span><span class="s1">*i:</span><span class="s4">12</span><span class="s1">+</span><span class="s4">4</span><span class="s1">*i]</span><span class="s0">, </span><span class="s1">_Object())</span>
            <span class="s1">self.pMap[pseudo.unicode] = ttFont.getGlyphName(pseudo.nPseudo)</span>
        <span class="s1">data = data[</span><span class="s4">8 </span><span class="s1">+ </span><span class="s4">6 </span><span class="s1">* numPseudo:]</span>
        <span class="s1">currpos = (sstruct.calcsize(Silf_part1_format)</span>
                    <span class="s1">+ sstruct.calcsize(Silf_justify_format) * self.numJLevels</span>
                    <span class="s1">+ sstruct.calcsize(Silf_part2_format) + </span><span class="s4">2 </span><span class="s1">* self.numCritFeatures</span>
                    <span class="s1">+ </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* numScriptTag + </span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* self.numPasses + </span><span class="s4">8 </span><span class="s1">+ </span><span class="s4">6 </span><span class="s1">* numPseudo)</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">currpos += sstruct.calcsize(Silf_part1_format_v3)</span>
        <span class="s1">self.classes = Classes()</span>
        <span class="s1">self.classes.decompile(data</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.numPasses):</span>
            <span class="s1">p = Pass()</span>
            <span class="s1">self.passes.append(p)</span>
            <span class="s1">p.decompile(data[self.oPasses[i]-currpos:self.oPasses[i+</span><span class="s4">1</span><span class="s1">]-currpos]</span><span class="s0">,</span>
                        <span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>

    <span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">self.numPasses = len(self.passes)</span>
        <span class="s1">self.numJLevels = len(self.jLevels)</span>
        <span class="s1">self.numCritFeatures = len(self.critFeatures)</span>
        <span class="s1">numPseudo = len(self.pMap)</span>
        <span class="s1">data = </span><span class="s5">b&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">hdroffset = sstruct.calcsize(Silf_part1_format_v3)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">hdroffset = </span><span class="s4">0</span>
        <span class="s1">data += sstruct.pack(Silf_part1_format</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">self.jLevels:</span>
            <span class="s1">data += sstruct.pack(Silf_justify_format</span><span class="s0">, </span><span class="s1">j)</span>
        <span class="s1">data += sstruct.pack(Silf_part2_format</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">if </span><span class="s1">self.numCritFeatures:</span>
            <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% self.numCritFeaturs)</span><span class="s0">, </span><span class="s1">*self.critFeatures)</span>
        <span class="s1">data += struct.pack(</span><span class="s3">&quot;BB&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">len(self.scriptTags))</span>
        <span class="s0">if </span><span class="s1">len(self.scriptTags):</span>
            <span class="s1">tdata = [struct.pack(</span><span class="s3">&quot;4s&quot;</span><span class="s0">, </span><span class="s1">x.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.scriptTags]</span>
            <span class="s1">data += </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(tdata)</span>
        <span class="s1">data += struct.pack(</span><span class="s3">&quot;&gt;H&quot;</span><span class="s0">, </span><span class="s1">self.lbGID)</span>
        <span class="s1">self.passOffset = len(data)</span>

        <span class="s1">data1 = grUtils.bininfo(numPseudo</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">currpos = hdroffset + len(data) + </span><span class="s4">4 </span><span class="s1">* (self.numPasses + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.pseudosOffset = currpos + len(data1)</span>
        <span class="s0">for </span><span class="s1">u</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sorted(self.pMap.items()):</span>
            <span class="s1">data1 += struct.pack((</span><span class="s3">&quot;&gt;LH&quot; </span><span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0 </span><span class="s0">else </span><span class="s3">&quot;&gt;HH&quot;</span><span class="s1">)</span><span class="s0">,</span>
                                <span class="s1">u</span><span class="s0">, </span><span class="s1">ttFont.getGlyphID(p))</span>
        <span class="s1">data1 += self.classes.compile(ttFont</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s1">currpos += len(data1)</span>
        <span class="s1">data2 = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">datao = </span><span class="s5">b&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">enumerate(self.passes):</span>
            <span class="s1">base = currpos + len(data2)</span>
            <span class="s1">datao += struct.pack(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">base)</span>
            <span class="s1">data2 += p.compile(ttFont</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s1">datao += struct.pack(</span><span class="s3">&quot;&gt;L&quot;</span><span class="s0">, </span><span class="s1">currpos + len(data2))</span>

        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">data3 = sstruct.pack(Silf_part1_format_v3</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data3 = </span><span class="s5">b&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">data3 + data + datao + data1 + data2</span>


    <span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">3.0</span><span class="s1">:</span>
            <span class="s1">writer.simpletag(</span><span class="s3">'version'</span><span class="s0">, </span><span class="s1">ruleVersion=self.ruleVersion)</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">writesimple(</span><span class="s3">'info'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*attrs_info)</span>
        <span class="s1">writesimple(</span><span class="s3">'passindexes'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*attrs_passindexes)</span>
        <span class="s1">writesimple(</span><span class="s3">'contexts'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*attrs_contexts)</span>
        <span class="s1">writesimple(</span><span class="s3">'attributes'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*attrs_attributes)</span>
        <span class="s0">if </span><span class="s1">len(self.jLevels):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'justifications'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">jformat</span><span class="s0">, </span><span class="s1">jnames</span><span class="s0">, </span><span class="s1">jfixes = sstruct.getformat(Silf_justify_format)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">enumerate(self.jLevels):</span>
                <span class="s1">attrs = dict([(k</span><span class="s0">, </span><span class="s1">getattr(j</span><span class="s0">, </span><span class="s1">k)) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">jnames])</span>
                <span class="s1">writer.simpletag(</span><span class="s3">'justify'</span><span class="s0">, </span><span class="s1">**attrs)</span>
                <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'justifications'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s0">if </span><span class="s1">len(self.critFeatures):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'critFeatures'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">writer.write(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">self.critFeatures)))</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'critFeatures'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s0">if </span><span class="s1">len(self.scriptTags):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'scriptTags'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">writer.write(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(self.scriptTags))</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'scriptTags'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s0">if </span><span class="s1">self.pMap:</span>
            <span class="s1">writer.begintag(</span><span class="s3">'pseudoMap'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted(self.pMap.items()):</span>
                <span class="s1">writer.simpletag(</span><span class="s3">'pseudo'</span><span class="s0">, </span><span class="s1">unicode=hex(k)</span><span class="s0">, </span><span class="s1">pseudo=v)</span>
                <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'pseudoMap'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">self.classes.toXML(writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s0">if </span><span class="s1">len(self.passes):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'passes'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">p </span><span class="s0">in </span><span class="s1">enumerate(self.passes):</span>
                <span class="s1">writer.begintag(</span><span class="s3">'pass'</span><span class="s0">, </span><span class="s1">_index=i)</span>
                <span class="s1">writer.newline()</span>
                <span class="s1">p.toXML(writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>
                <span class="s1">writer.endtag(</span><span class="s3">'pass'</span><span class="s1">)</span>
                <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'passes'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>

    <span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'version'</span><span class="s1">:</span>
            <span class="s1">self.ruleVersion = float(safeEval(attrs.get(</span><span class="s3">'ruleVersion'</span><span class="s0">, </span><span class="s3">&quot;0&quot;</span><span class="s1">)))</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'info'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*attrs_info)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'passindexes'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*attrs_passindexes)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'contexts'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*attrs_contexts)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'attributes'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*attrs_attributes)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'justifications'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">(tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent) = element</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'justify'</span><span class="s1">:</span>
                    <span class="s1">j = _Object()</span>
                    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">attrs.items():</span>
                        <span class="s1">setattr(j</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">int(v))</span>
                    <span class="s1">self.jLevels.append(j)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'critFeatures'</span><span class="s1">:</span>
            <span class="s1">self.critFeatures = []</span>
            <span class="s1">element = content_string(content)</span>
            <span class="s1">self.critFeatures.extend(map(int</span><span class="s0">, </span><span class="s1">element.split()))</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'scriptTags'</span><span class="s1">:</span>
            <span class="s1">self.scriptTags = []</span>
            <span class="s1">element = content_string(content)</span>
            <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">element.split():</span>
                <span class="s1">self.scriptTags.append(n)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'pseudoMap'</span><span class="s1">:</span>
            <span class="s1">self.pMap = {}</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">(tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent) = element</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'pseudo'</span><span class="s1">:</span>
                    <span class="s1">k = int(attrs[</span><span class="s3">'unicode'</span><span class="s1">]</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
                    <span class="s1">v = attrs[</span><span class="s3">'pseudo'</span><span class="s1">]</span>
                <span class="s1">self.pMap[k] = v</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'classes'</span><span class="s1">:</span>
            <span class="s1">self.classes = Classes()</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent = element</span>
                <span class="s1">self.classes.fromXML(tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'passes'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent = element</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'pass'</span><span class="s1">:</span>
                    <span class="s1">p = Pass()</span>
                    <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subcontent:</span>
                        <span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                        <span class="s1">p.fromXML(e[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">e[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">e[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version)</span>
                    <span class="s1">self.passes.append(p)</span>


<span class="s0">class </span><span class="s1">Classes(object):</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.linear = []</span>
        <span class="s1">self.nonLinear = []</span>

    <span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">sstruct.unpack2(Silf_classmap_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">4.0 </span><span class="s1">:</span>
            <span class="s1">oClasses = struct.unpack((</span><span class="s3">&quot;&gt;%dL&quot; </span><span class="s1">% (self.numClass+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">,</span>
                                        <span class="s1">data[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">8</span><span class="s1">+</span><span class="s4">4</span><span class="s1">*self.numClass])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">oClasses = struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numClass+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">,</span>
                                        <span class="s1">data[</span><span class="s4">4</span><span class="s1">:</span><span class="s4">6</span><span class="s1">+</span><span class="s4">2</span><span class="s1">*self.numClass])</span>
        <span class="s0">for </span><span class="s1">s</span><span class="s0">,</span><span class="s1">e </span><span class="s0">in </span><span class="s1">zip(oClasses[:self.numLinear]</span><span class="s0">, </span><span class="s1">oClasses[</span><span class="s4">1</span><span class="s1">:self.numLinear+</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">self.linear.append(ttFont.getGlyphName(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in</span>
                                   <span class="s1">struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% ((e-s)/</span><span class="s4">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">data[s:e]))</span>
        <span class="s0">for </span><span class="s1">s</span><span class="s0">,</span><span class="s1">e </span><span class="s0">in </span><span class="s1">zip(oClasses[self.numLinear:self.numClass]</span><span class="s0">,</span>
                        <span class="s1">oClasses[self.numLinear+</span><span class="s4">1</span><span class="s1">:self.numClass+</span><span class="s4">1</span><span class="s1">]):</span>
            <span class="s1">nonLinids = [struct.unpack(</span><span class="s3">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">data[x:x+</span><span class="s4">4</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(s+</span><span class="s4">8</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)]</span>
            <span class="s1">nonLin = dict([(ttFont.getGlyphName(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">nonLinids])</span>
            <span class="s1">self.nonLinear.append(nonLin)</span>

    <span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">data = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">oClasses = []</span>
        <span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">4.0</span><span class="s1">:</span>
            <span class="s1">offset = </span><span class="s4">8 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* (len(self.linear) + len(self.nonLinear))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">offset = </span><span class="s4">6 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* (len(self.linear) + len(self.nonLinear))</span>
        <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">self.linear:</span>
            <span class="s1">oClasses.append(len(data) + offset)</span>
            <span class="s1">gs = [ttFont.getGlyphID(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">l]</span>
            <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% len(l))</span><span class="s0">, </span><span class="s1">*gs)</span>
        <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">self.nonLinear:</span>
            <span class="s1">oClasses.append(len(data) + offset)</span>
            <span class="s1">gs = [(ttFont.getGlyphID(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">l.items()]</span>
            <span class="s1">data += grUtils.bininfo(len(gs))</span>
            <span class="s1">data += </span><span class="s5">b&quot;&quot;</span><span class="s1">.join([struct.pack(</span><span class="s3">&quot;&gt;HH&quot;</span><span class="s0">, </span><span class="s1">*x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">sorted(gs)])</span>
        <span class="s1">oClasses.append(len(data) + offset)</span>
        <span class="s1">self.numClass = len(oClasses) - </span><span class="s4">1</span>
        <span class="s1">self.numLinear = len(self.linear)</span>
        <span class="s0">return </span><span class="s1">sstruct.pack(Silf_classmap_format</span><span class="s0">, </span><span class="s1">self) + \</span>
               <span class="s1">struct.pack(((</span><span class="s3">&quot;&gt;%dL&quot; </span><span class="s0">if </span><span class="s1">version &gt;= </span><span class="s4">4.0 </span><span class="s0">else </span><span class="s3">&quot;&gt;%dH&quot;</span><span class="s1">) % len(oClasses))</span><span class="s0">,</span>
                            <span class="s1">*oClasses) + data</span>

    <span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">writer.begintag(</span><span class="s3">'classes'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.begintag(</span><span class="s3">'linearClasses'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">,</span><span class="s1">l </span><span class="s0">in </span><span class="s1">enumerate(self.linear):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'linear'</span><span class="s0">, </span><span class="s1">_index=i)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">wrapline(writer</span><span class="s0">, </span><span class="s1">l)</span>
            <span class="s1">writer.endtag(</span><span class="s3">'linear'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">writer.endtag(</span><span class="s3">'linearClasses'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.begintag(</span><span class="s3">'nonLinearClasses'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">l </span><span class="s0">in </span><span class="s1">enumerate(self.nonLinear):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'nonLinear'</span><span class="s0">, </span><span class="s1">_index=i + self.numLinear)</span>
            <span class="s1">writer.newline()</span>
            <span class="s0">for </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">ind </span><span class="s0">in </span><span class="s1">l.items():</span>
                <span class="s1">writer.simpletag(</span><span class="s3">'map'</span><span class="s0">, </span><span class="s1">glyph=inp</span><span class="s0">, </span><span class="s1">index=ind)</span>
                <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'nonLinear'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">writer.endtag(</span><span class="s3">'nonLinearClasses'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.endtag(</span><span class="s3">'classes'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>

    <span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'linearClasses'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent = element</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'linear'</span><span class="s1">:</span>
                    <span class="s1">l = content_string(subcontent).split()</span>
                    <span class="s1">self.linear.append(l)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'nonLinearClasses'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subcontent = element</span>
                <span class="s0">if </span><span class="s1">tag ==</span><span class="s3">'nonLinear'</span><span class="s1">:</span>
                    <span class="s1">l = {}</span>
                    <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">subcontent:</span>
                        <span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                        <span class="s1">tag</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">subsubcontent = e</span>
                        <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'map'</span><span class="s1">:</span>
                            <span class="s1">l[attrs[</span><span class="s3">'glyph'</span><span class="s1">]] = int(safeEval(attrs[</span><span class="s3">'index'</span><span class="s1">]))</span>
                    <span class="s1">self.nonLinear.append(l)</span>

<span class="s0">class </span><span class="s1">Pass(object):</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.colMap = {}</span>
        <span class="s1">self.rules = []</span>
        <span class="s1">self.rulePreContexts = []</span>
        <span class="s1">self.ruleSortKeys = []</span>
        <span class="s1">self.ruleConstraints = []</span>
        <span class="s1">self.passConstraints = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">self.actions = []</span>
        <span class="s1">self.stateTrans = []</span>
        <span class="s1">self.startStates = []</span>

    <span class="s0">def </span><span class="s1">decompile(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">data = sstruct.unpack2(Silf_pass_format</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s1">(numRange</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_) = struct.unpack(</span><span class="s3">&quot;&gt;4H&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">8</span><span class="s1">])</span>
        <span class="s1">data = data[</span><span class="s4">8</span><span class="s1">:]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(numRange):</span>
            <span class="s1">(first</span><span class="s0">, </span><span class="s1">last</span><span class="s0">, </span><span class="s1">col) = struct.unpack(</span><span class="s3">&quot;&gt;3H&quot;</span><span class="s0">, </span><span class="s1">data[</span><span class="s4">6</span><span class="s1">*i:</span><span class="s4">6</span><span class="s1">*i+</span><span class="s4">6</span><span class="s1">])</span>
            <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">range(first</span><span class="s0">, </span><span class="s1">last+</span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">self.colMap[ttFont.getGlyphName(g)] = col</span>
        <span class="s1">data = data[</span><span class="s4">6</span><span class="s1">*numRange:]</span>
        <span class="s1">oRuleMap = struct.unpack_from((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numSuccess + </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">data = data[</span><span class="s4">2</span><span class="s1">+</span><span class="s4">2</span><span class="s1">*self.numSuccess:]</span>
        <span class="s1">rules = struct.unpack_from((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% oRuleMap[-</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">self.rules = [rules[s:e] </span><span class="s0">for </span><span class="s1">(s</span><span class="s0">,</span><span class="s1">e) </span><span class="s0">in </span><span class="s1">zip(oRuleMap</span><span class="s0">, </span><span class="s1">oRuleMap[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">data = data[</span><span class="s4">2</span><span class="s1">*oRuleMap[-</span><span class="s4">1</span><span class="s1">]:]</span>
        <span class="s1">(self.minRulePreContext</span><span class="s0">, </span><span class="s1">self.maxRulePreContext) = struct.unpack(</span><span class="s3">'BB'</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">numStartStates = self.maxRulePreContext - self.minRulePreContext + </span><span class="s4">1</span>
        <span class="s1">self.startStates = struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% numStartStates)</span><span class="s0">,</span>
                                        <span class="s1">data[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">2 </span><span class="s1">+ numStartStates * </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">data = data[</span><span class="s4">2</span><span class="s1">+numStartStates*</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">self.ruleSortKeys = struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% self.numRules)</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">2 </span><span class="s1">* self.numRules])</span>
        <span class="s1">data = data[</span><span class="s4">2</span><span class="s1">*self.numRules:]</span>
        <span class="s1">self.rulePreContexts = struct.unpack((</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% self.numRules)</span><span class="s0">, </span><span class="s1">data[:self.numRules])</span>
        <span class="s1">data = data[self.numRules:]</span>
        <span class="s1">(self.collisionThreshold</span><span class="s0">, </span><span class="s1">pConstraint) = struct.unpack(</span><span class="s3">&quot;&gt;BH&quot;</span><span class="s0">, </span><span class="s1">data[:</span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">oConstraints = list(struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numRules + </span><span class="s4">1</span><span class="s1">))</span><span class="s0">,</span>
                                        <span class="s1">data[</span><span class="s4">3</span><span class="s1">:</span><span class="s4">5 </span><span class="s1">+ self.numRules * </span><span class="s4">2</span><span class="s1">]))</span>
        <span class="s1">data = data[</span><span class="s4">5 </span><span class="s1">+ self.numRules * </span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s1">oActions = list(struct.unpack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numRules + </span><span class="s4">1</span><span class="s1">))</span><span class="s0">,</span>
                                        <span class="s1">data[:</span><span class="s4">2 </span><span class="s1">+ self.numRules * </span><span class="s4">2</span><span class="s1">]))</span>
        <span class="s1">data = data[</span><span class="s4">2 </span><span class="s1">* self.numRules + </span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(self.numTransitional):</span>
            <span class="s1">a = array(</span><span class="s3">&quot;H&quot;</span><span class="s0">, </span><span class="s1">data[i*self.numColumns*</span><span class="s4">2</span><span class="s1">:(i+</span><span class="s4">1</span><span class="s1">)*self.numColumns*</span><span class="s4">2</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s3">&quot;big&quot;</span><span class="s1">: a.byteswap()</span>
            <span class="s1">self.stateTrans.append(a)</span>
        <span class="s1">data = data[self.numTransitional * self.numColumns * </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">self.passConstraints = data[:pConstraint]</span>
        <span class="s1">data = data[pConstraint:]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(oConstraints)-</span><span class="s4">2</span><span class="s0">,</span><span class="s1">-</span><span class="s4">1</span><span class="s0">,</span><span class="s1">-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">oConstraints[i] == </span><span class="s4">0 </span><span class="s1">:</span>
                <span class="s1">oConstraints[i] = oConstraints[i+</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.ruleConstraints = [(data[s:e] </span><span class="s0">if </span><span class="s1">(e-s &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s0">else </span><span class="s5">b&quot;&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">(s</span><span class="s0">,</span><span class="s1">e) </span><span class="s0">in </span><span class="s1">zip(oConstraints</span><span class="s0">, </span><span class="s1">oConstraints[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">data = data[oConstraints[-</span><span class="s4">1</span><span class="s1">]:]</span>
        <span class="s1">self.actions = [(data[s:e] </span><span class="s0">if </span><span class="s1">(e-s &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s0">else </span><span class="s3">&quot;&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">(s</span><span class="s0">,</span><span class="s1">e) </span><span class="s0">in </span><span class="s1">zip(oActions</span><span class="s0">, </span><span class="s1">oActions[</span><span class="s4">1</span><span class="s1">:])]</span>
        <span class="s1">data = data[oActions[-</span><span class="s4">1</span><span class="s1">]:]</span>
        <span class="s2"># not using debug</span>

    <span class="s0">def </span><span class="s1">compile(self</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">base</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s2"># build it all up backwards</span>
        <span class="s1">oActions = reduce(</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x: (a[</span><span class="s4">0</span><span class="s1">]+len(x)</span><span class="s0">, </span><span class="s1">a[</span><span class="s4">1</span><span class="s1">]+[a[</span><span class="s4">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">self.actions + [</span><span class="s5">b&quot;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">[]))[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">oConstraints = reduce(</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x: (a[</span><span class="s4">0</span><span class="s1">]+len(x)</span><span class="s0">, </span><span class="s1">a[</span><span class="s4">1</span><span class="s1">]+[a[</span><span class="s4">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">self.ruleConstraints + [</span><span class="s5">b&quot;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">[]))[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">constraintCode = </span><span class="s5">b&quot;</span><span class="s0">\000</span><span class="s5">&quot; </span><span class="s1">+ </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(self.ruleConstraints)</span>
        <span class="s1">transes = []</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.stateTrans:</span>
            <span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s3">&quot;big&quot;</span><span class="s1">: t.byteswap()</span>
            <span class="s1">transes.append(t.tobytes())</span>
            <span class="s0">if </span><span class="s1">sys.byteorder != </span><span class="s3">&quot;big&quot;</span><span class="s1">: t.byteswap()</span>
        <span class="s0">if not </span><span class="s1">len(transes):</span>
            <span class="s1">self.startStates = [</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">oRuleMap = reduce(</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">x: (a[</span><span class="s4">0</span><span class="s1">]+len(x)</span><span class="s0">, </span><span class="s1">a[</span><span class="s4">1</span><span class="s1">]+[a[</span><span class="s4">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">self.rules+[[]]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">[]))[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">passRanges = []</span>
        <span class="s1">gidcolmap = dict([(ttFont.getGlyphID(x[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.colMap.items()])</span>
        <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">grUtils.entries(gidcolmap</span><span class="s0">, </span><span class="s1">sameval = </span><span class="s0">True</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">e[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">passRanges.append((e[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">e[</span><span class="s4">0</span><span class="s1">]+e[</span><span class="s4">1</span><span class="s1">]-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">e[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">self.numRules = len(self.actions)</span>
        <span class="s1">self.fsmOffset = (sstruct.calcsize(Silf_pass_format) + </span><span class="s4">8 </span><span class="s1">+ len(passRanges) * </span><span class="s4">6</span>
                    <span class="s1">+ len(oRuleMap) * </span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2 </span><span class="s1">* oRuleMap[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">2</span>
                    <span class="s1">+ </span><span class="s4">2 </span><span class="s1">* len(self.startStates) + </span><span class="s4">3 </span><span class="s1">* self.numRules + </span><span class="s4">3</span>
                    <span class="s1">+ </span><span class="s4">4 </span><span class="s1">* self.numRules + </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">self.pcCode = self.fsmOffset + </span><span class="s4">2</span><span class="s1">*self.numTransitional*self.numColumns + </span><span class="s4">1 </span><span class="s1">+ base</span>
        <span class="s1">self.rcCode = self.pcCode + len(self.passConstraints)</span>
        <span class="s1">self.aCode = self.rcCode + len(constraintCode)</span>
        <span class="s1">self.oDebug = </span><span class="s4">0</span>
        <span class="s2"># now generate output</span>
        <span class="s1">data = sstruct.pack(Silf_pass_format</span><span class="s0">, </span><span class="s1">self)</span>
        <span class="s1">data += grUtils.bininfo(len(passRanges)</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">data += </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(struct.pack(</span><span class="s3">&quot;&gt;3H&quot;</span><span class="s0">, </span><span class="s1">*p) </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">passRanges)</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% len(oRuleMap))</span><span class="s0">, </span><span class="s1">*oRuleMap)</span>
        <span class="s1">flatrules = reduce(</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">,</span><span class="s1">x: a+x</span><span class="s0">, </span><span class="s1">self.rules</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% oRuleMap[-</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">*flatrules)</span>
        <span class="s1">data += struct.pack(</span><span class="s3">&quot;BB&quot;</span><span class="s0">, </span><span class="s1">self.minRulePreContext</span><span class="s0">, </span><span class="s1">self.maxRulePreContext)</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% len(self.startStates))</span><span class="s0">, </span><span class="s1">*self.startStates)</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% self.numRules)</span><span class="s0">, </span><span class="s1">*self.ruleSortKeys)</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;%dB&quot; </span><span class="s1">% self.numRules)</span><span class="s0">, </span><span class="s1">*self.rulePreContexts)</span>
        <span class="s1">data += struct.pack(</span><span class="s3">&quot;&gt;BH&quot;</span><span class="s0">, </span><span class="s1">self.collisionThreshold</span><span class="s0">, </span><span class="s1">len(self.passConstraints))</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numRules+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">*oConstraints)</span>
        <span class="s1">data += struct.pack((</span><span class="s3">&quot;&gt;%dH&quot; </span><span class="s1">% (self.numRules+</span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">*oActions)</span>
        <span class="s0">return </span><span class="s1">data + </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(transes) + struct.pack(</span><span class="s3">&quot;B&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) + \</span>
                <span class="s1">self.passConstraints + constraintCode + </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(self.actions)</span>

    <span class="s0">def </span><span class="s1">toXML(self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s1">writesimple(</span><span class="s3">'info'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*pass_attrs_info)</span>
        <span class="s1">writesimple(</span><span class="s3">'fsminfo'</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">*pass_attrs_fsm)</span>
        <span class="s1">writer.begintag(</span><span class="s3">'colmap'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">wrapline(writer</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;{}={}&quot;</span><span class="s1">.format(*x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">sorted(self.colMap.items()</span><span class="s0">,</span>
                                        <span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x:ttFont.getGlyphID(x[</span><span class="s4">0</span><span class="s1">]))])</span>
        <span class="s1">writer.endtag(</span><span class="s3">'colmap'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.begintag(</span><span class="s3">'staterulemap'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">r </span><span class="s0">in </span><span class="s1">enumerate(self.rules):</span>
            <span class="s1">writer.simpletag(</span><span class="s3">'state'</span><span class="s0">, </span><span class="s1">number = self.numRows - self.numSuccess + i</span><span class="s0">,</span>
                                <span class="s1">rules = </span><span class="s3">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">r)))</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">writer.endtag(</span><span class="s3">'staterulemap'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s1">writer.begintag(</span><span class="s3">'rules'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self.actions)):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'rule'</span><span class="s0">, </span><span class="s1">index=i</span><span class="s0">, </span><span class="s1">precontext=self.rulePreContexts[i]</span><span class="s0">,</span>
                            <span class="s1">sortkey=self.ruleSortKeys[i])</span>
            <span class="s1">writer.newline()</span>
            <span class="s0">if </span><span class="s1">len(self.ruleConstraints[i]):</span>
                <span class="s1">writecode(</span><span class="s3">'constraint'</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">self.ruleConstraints[i])</span>
            <span class="s1">writecode(</span><span class="s3">'action'</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">self.actions[i])</span>
            <span class="s1">writer.endtag(</span><span class="s3">'rule'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
        <span class="s1">writer.endtag(</span><span class="s3">'rules'</span><span class="s1">)</span>
        <span class="s1">writer.newline()</span>
        <span class="s0">if </span><span class="s1">len(self.passConstraints):</span>
            <span class="s1">writecode(</span><span class="s3">'passConstraint'</span><span class="s0">, </span><span class="s1">writer</span><span class="s0">, </span><span class="s1">self.passConstraints)</span>
        <span class="s0">if </span><span class="s1">len(self.stateTrans):</span>
            <span class="s1">writer.begintag(</span><span class="s3">'fsm'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s1">writer.begintag(</span><span class="s3">'starts'</span><span class="s1">)</span>
            <span class="s1">writer.write(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">self.startStates)))</span>
            <span class="s1">writer.endtag(</span><span class="s3">'starts'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">enumerate(self.stateTrans):</span>
                <span class="s1">writer.begintag(</span><span class="s3">'row'</span><span class="s0">, </span><span class="s1">_i=i)</span>
                <span class="s2"># no newlines here</span>
                <span class="s1">writer.write(</span><span class="s3">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s0">, </span><span class="s1">s)))</span>
                <span class="s1">writer.endtag(</span><span class="s3">'row'</span><span class="s1">)</span>
                <span class="s1">writer.newline()</span>
            <span class="s1">writer.endtag(</span><span class="s3">'fsm'</span><span class="s1">)</span>
            <span class="s1">writer.newline()</span>

    <span class="s0">def </span><span class="s1">fromXML(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">content</span><span class="s0">, </span><span class="s1">ttFont</span><span class="s0">, </span><span class="s1">version=</span><span class="s4">2.0</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">'info'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*pass_attrs_info)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'fsminfo'</span><span class="s1">:</span>
            <span class="s1">getSimple(self</span><span class="s0">, </span><span class="s1">attrs</span><span class="s0">, </span><span class="s1">*pass_attrs_fsm)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'colmap'</span><span class="s1">:</span>
            <span class="s1">e = content_string(content)</span>
            <span class="s0">for </span><span class="s1">w </span><span class="s0">in </span><span class="s1">e.split():</span>
                <span class="s1">x = w.split(</span><span class="s3">'='</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">len(x) != </span><span class="s4">2 </span><span class="s0">or </span><span class="s1">x[</span><span class="s4">0</span><span class="s1">] == </span><span class="s3">'' </span><span class="s0">or </span><span class="s1">x[</span><span class="s4">1</span><span class="s1">] == </span><span class="s3">''</span><span class="s1">: </span><span class="s0">continue</span>
                <span class="s1">self.colMap[x[</span><span class="s4">0</span><span class="s1">]] = int(x[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'staterulemap'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">c = e</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'state'</span><span class="s1">:</span>
                    <span class="s1">self.rules.append([int(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">a[</span><span class="s3">'rules'</span><span class="s1">].split(</span><span class="s3">&quot; &quot;</span><span class="s1">)])</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'rules'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">c = element</span>
                <span class="s0">if </span><span class="s1">tag != </span><span class="s3">'rule'</span><span class="s1">: </span><span class="s0">continue</span>
                <span class="s1">self.rulePreContexts.append(int(a[</span><span class="s3">'precontext'</span><span class="s1">]))</span>
                <span class="s1">self.ruleSortKeys.append(int(a[</span><span class="s3">'sortkey'</span><span class="s1">]))</span>
                <span class="s1">con = </span><span class="s5">b&quot;&quot;</span>
                <span class="s1">act = </span><span class="s5">b&quot;&quot;</span>
                <span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">c:</span>
                    <span class="s0">if not </span><span class="s1">isinstance(e</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                    <span class="s1">tag</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">subc = e</span>
                    <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'constraint'</span><span class="s1">:</span>
                        <span class="s1">con = readcode(subc)</span>
                    <span class="s0">elif </span><span class="s1">tag == </span><span class="s3">'action'</span><span class="s1">:</span>
                        <span class="s1">act = readcode(subc)</span>
                <span class="s1">self.actions.append(act)</span>
                <span class="s1">self.ruleConstraints.append(con)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'passConstraint'</span><span class="s1">:</span>
            <span class="s1">self.passConstraints = readcode(content)</span>
        <span class="s0">elif </span><span class="s1">name == </span><span class="s3">'fsm'</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">element </span><span class="s0">in </span><span class="s1">content:</span>
                <span class="s0">if not </span><span class="s1">isinstance(element</span><span class="s0">, </span><span class="s1">tuple): </span><span class="s0">continue</span>
                <span class="s1">tag</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">c = element</span>
                <span class="s0">if </span><span class="s1">tag == </span><span class="s3">'row'</span><span class="s1">:</span>
                    <span class="s1">s = array(</span><span class="s3">'H'</span><span class="s1">)</span>
                    <span class="s1">e = content_string(c)</span>
                    <span class="s1">s.extend(map(int</span><span class="s0">, </span><span class="s1">e.split()))</span>
                    <span class="s1">self.stateTrans.append(s)</span>
                <span class="s0">elif </span><span class="s1">tag == </span><span class="s3">'starts'</span><span class="s1">:</span>
                    <span class="s1">s = []</span>
                    <span class="s1">e = content_string(c)</span>
                    <span class="s1">s.extend(map(int</span><span class="s0">, </span><span class="s1">e.split()))</span>
                    <span class="s1">self.startStates = s</span>

</pre>
</body>
</html>