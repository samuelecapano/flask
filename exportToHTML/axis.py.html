<html>
<head>
<title>axis.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
axis.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Classes for the ticks and x- and y-axis. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">cbook</span>
<span class="s2">import </span><span class="s1">matplotlib.artist </span><span class="s2">as </span><span class="s1">martist</span>
<span class="s2">import </span><span class="s1">matplotlib.colors </span><span class="s2">as </span><span class="s1">mcolors</span>
<span class="s2">import </span><span class="s1">matplotlib.lines </span><span class="s2">as </span><span class="s1">mlines</span>
<span class="s2">import </span><span class="s1">matplotlib.scale </span><span class="s2">as </span><span class="s1">mscale</span>
<span class="s2">import </span><span class="s1">matplotlib.text </span><span class="s2">as </span><span class="s1">mtext</span>
<span class="s2">import </span><span class="s1">matplotlib.ticker </span><span class="s2">as </span><span class="s1">mticker</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">mtransforms</span>
<span class="s2">import </span><span class="s1">matplotlib.units </span><span class="s2">as </span><span class="s1">munits</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s1">GRIDLINE_INTERPOLATION_STEPS = </span><span class="s3">180</span>

<span class="s4"># This list is being used for compatibility with Axes.grid, which</span>
<span class="s4"># allows all Line2D kwargs.</span>
<span class="s1">_line_inspector = martist.ArtistInspector(mlines.Line2D)</span>
<span class="s1">_line_param_names = _line_inspector.get_setters()</span>
<span class="s1">_line_param_aliases = [list(d)[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">_line_inspector.aliasd.values()]</span>
<span class="s1">_gridline_param_names = [</span><span class="s5">'grid_' </span><span class="s1">+ name</span>
                         <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">_line_param_names + _line_param_aliases]</span>


<span class="s2">class </span><span class="s1">Tick(martist.Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    Abstract base class for the axis ticks, grid lines and labels. 
 
    Ticks mark a position on an Axis. They contain two lines as markers and 
    two labels; one each for the bottom and top positions (in case of an 
    `.XAxis`) or for the left and right positions (in case of a `.YAxis`). 
 
    Attributes 
    ---------- 
    tick1line : `.Line2D` 
        The left/bottom tick marker. 
    tick2line : `.Line2D` 
        The right/top tick marker. 
    gridline : `.Line2D` 
        The grid line associated with the label position. 
    label1 : `.Text` 
        The left/bottom tick label. 
    label2 : `.Text` 
        The right/top tick label. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
        <span class="s1">size=</span><span class="s2">None,  </span><span class="s4"># points</span>
        <span class="s1">width=</span><span class="s2">None,</span>
        <span class="s1">color=</span><span class="s2">None,</span>
        <span class="s1">tickdir=</span><span class="s2">None,</span>
        <span class="s1">pad=</span><span class="s2">None,</span>
        <span class="s1">labelsize=</span><span class="s2">None,</span>
        <span class="s1">labelcolor=</span><span class="s2">None,</span>
        <span class="s1">zorder=</span><span class="s2">None,</span>
        <span class="s1">gridOn=</span><span class="s2">None,  </span><span class="s4"># defaults to axes.grid depending on axes.grid.which</span>
        <span class="s1">tick1On=</span><span class="s2">True,</span>
        <span class="s1">tick2On=</span><span class="s2">True,</span>
        <span class="s1">label1On=</span><span class="s2">True,</span>
        <span class="s1">label2On=</span><span class="s2">False,</span>
        <span class="s1">major=</span><span class="s2">True,</span>
        <span class="s1">labelrotation=</span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">grid_color=</span><span class="s2">None,</span>
        <span class="s1">grid_linestyle=</span><span class="s2">None,</span>
        <span class="s1">grid_linewidth=</span><span class="s2">None,</span>
        <span class="s1">grid_alpha=</span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,  </span><span class="s4"># Other Line2D kwargs applied to gridlines.</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        bbox is the Bound2D bounding box in display coords of the Axes 
        loc is the tick location in data coords 
        size is the tick size in points 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>

        <span class="s2">if </span><span class="s1">gridOn </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">major </span><span class="s2">and </span><span class="s1">(mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">]</span>
                          <span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'major'</span><span class="s1">)):</span>
                <span class="s1">gridOn = mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">(</span><span class="s2">not </span><span class="s1">major) </span><span class="s2">and </span><span class="s1">(mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">]</span>
                                  <span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s1">)):</span>
                <span class="s1">gridOn = mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">gridOn = </span><span class="s2">False</span>

        <span class="s1">self.set_figure(axes.figure)</span>
        <span class="s1">self.axes = axes</span>

        <span class="s1">self._loc = loc</span>
        <span class="s1">self._major = major</span>

        <span class="s1">name = self.__name__</span>
        <span class="s1">major_minor = </span><span class="s5">&quot;major&quot; </span><span class="s2">if </span><span class="s1">major </span><span class="s2">else </span><span class="s5">&quot;minor&quot;</span>

        <span class="s2">if </span><span class="s1">size </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">size = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">major_minor</span><span class="s2">}</span><span class="s5">.size&quot;</span><span class="s1">]</span>
        <span class="s1">self._size = size</span>

        <span class="s2">if </span><span class="s1">width </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">width = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">major_minor</span><span class="s2">}</span><span class="s5">.width&quot;</span><span class="s1">]</span>
        <span class="s1">self._width = width</span>

        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.color&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">pad </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">pad = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.</span><span class="s2">{</span><span class="s1">major_minor</span><span class="s2">}</span><span class="s5">.pad&quot;</span><span class="s1">]</span>
        <span class="s1">self._base_pad = pad</span>

        <span class="s2">if </span><span class="s1">labelcolor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">labelcolor = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.labelcolor&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">labelcolor == </span><span class="s5">'inherit'</span><span class="s1">:</span>
            <span class="s4"># inherit from tick color</span>
            <span class="s1">labelcolor = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.color&quot;</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">labelsize </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">labelsize = mpl.rcParams[</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">.labelsize&quot;</span><span class="s1">]</span>

        <span class="s1">self._set_labelrotation(labelrotation)</span>

        <span class="s2">if </span><span class="s1">zorder </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">major:</span>
                <span class="s1">zorder = mlines.Line2D.zorder + </span><span class="s3">0.01</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">zorder = mlines.Line2D.zorder</span>
        <span class="s1">self._zorder = zorder</span>

        <span class="s2">if </span><span class="s1">grid_color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">grid_color = mpl.rcParams[</span><span class="s5">&quot;grid.color&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">grid_linestyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">grid_linestyle = mpl.rcParams[</span><span class="s5">&quot;grid.linestyle&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">grid_linewidth </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">grid_linewidth = mpl.rcParams[</span><span class="s5">&quot;grid.linewidth&quot;</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">grid_alpha </span><span class="s2">is None and not </span><span class="s1">mcolors._has_alpha_channel(grid_color):</span>
            <span class="s4"># alpha precedence: kwarg &gt; color alpha &gt; rcParams['grid.alpha']</span>
            <span class="s4"># Note: only resolve to rcParams if the color does not have alpha</span>
            <span class="s4"># otherwise `grid(color=(1, 1, 1, 0.5))` would work like</span>
            <span class="s4">#   grid(color=(1, 1, 1, 0.5), alpha=rcParams['grid.alpha'])</span>
            <span class="s4"># so the that the rcParams default would override color alpha.</span>
            <span class="s1">grid_alpha = mpl.rcParams[</span><span class="s5">&quot;grid.alpha&quot;</span><span class="s1">]</span>
        <span class="s1">grid_kw = {k[</span><span class="s3">5</span><span class="s1">:]: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items()}</span>

        <span class="s1">self.tick1line = mlines.Line2D(</span>
            <span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">, </span><span class="s1">linestyle=</span><span class="s5">&quot;none&quot;</span><span class="s2">, </span><span class="s1">zorder=zorder</span><span class="s2">, </span><span class="s1">visible=tick1On</span><span class="s2">,</span>
            <span class="s1">markeredgecolor=color</span><span class="s2">, </span><span class="s1">markersize=size</span><span class="s2">, </span><span class="s1">markeredgewidth=width</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.tick2line = mlines.Line2D(</span>
            <span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">, </span><span class="s1">linestyle=</span><span class="s5">&quot;none&quot;</span><span class="s2">, </span><span class="s1">zorder=zorder</span><span class="s2">, </span><span class="s1">visible=tick2On</span><span class="s2">,</span>
            <span class="s1">markeredgecolor=color</span><span class="s2">, </span><span class="s1">markersize=size</span><span class="s2">, </span><span class="s1">markeredgewidth=width</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.gridline = mlines.Line2D(</span>
            <span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">,</span>
            <span class="s1">color=grid_color</span><span class="s2">, </span><span class="s1">alpha=grid_alpha</span><span class="s2">, </span><span class="s1">visible=gridOn</span><span class="s2">,</span>
            <span class="s1">linestyle=grid_linestyle</span><span class="s2">, </span><span class="s1">linewidth=grid_linewidth</span><span class="s2">, </span><span class="s1">marker=</span><span class="s5">&quot;&quot;</span><span class="s2">,</span>
            <span class="s1">**grid_kw</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.gridline.get_path()._interpolation_steps = \</span>
            <span class="s1">GRIDLINE_INTERPOLATION_STEPS</span>
        <span class="s1">self.label1 = mtext.Text(</span>
            <span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">,</span>
            <span class="s1">fontsize=labelsize</span><span class="s2">, </span><span class="s1">color=labelcolor</span><span class="s2">, </span><span class="s1">visible=label1On</span><span class="s2">,</span>
            <span class="s1">rotation=self._labelrotation[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">self.label2 = mtext.Text(</span>
            <span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">,</span>
            <span class="s1">fontsize=labelsize</span><span class="s2">, </span><span class="s1">color=labelcolor</span><span class="s2">, </span><span class="s1">visible=label2On</span><span class="s2">,</span>
            <span class="s1">rotation=self._labelrotation[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">self._apply_tickdir(tickdir)</span>

        <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">[self.tick1line</span><span class="s2">, </span><span class="s1">self.tick2line</span><span class="s2">, </span><span class="s1">self.gridline</span><span class="s2">,</span>
                       <span class="s1">self.label1</span><span class="s2">, </span><span class="s1">self.label2]:</span>
            <span class="s1">self._set_artist_props(artist)</span>

        <span class="s1">self.update_position(loc)</span>

    <span class="s1">@property</span>
    <span class="s1">@_api.deprecated(</span><span class="s5">&quot;3.1&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s5">&quot;Tick.label1&quot;</span><span class="s2">, </span><span class="s1">removal=</span><span class="s5">&quot;3.8&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">label(self):</span>
        <span class="s2">return </span><span class="s1">self.label1</span>

    <span class="s2">def </span><span class="s1">_set_labelrotation(self</span><span class="s2">, </span><span class="s1">labelrotation):</span>
        <span class="s2">if </span><span class="s1">isinstance(labelrotation</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">mode = labelrotation</span>
            <span class="s1">angle = </span><span class="s3">0</span>
        <span class="s2">elif </span><span class="s1">isinstance(labelrotation</span><span class="s2">, </span><span class="s1">(tuple</span><span class="s2">, </span><span class="s1">list)):</span>
            <span class="s1">mode</span><span class="s2">, </span><span class="s1">angle = labelrotation</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">mode = </span><span class="s5">'default'</span>
            <span class="s1">angle = labelrotation</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'auto'</span><span class="s2">, </span><span class="s5">'default'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">labelrotation=mode)</span>
        <span class="s1">self._labelrotation = (mode</span><span class="s2">, </span><span class="s1">angle)</span>

    <span class="s2">def </span><span class="s1">_apply_tickdir(self</span><span class="s2">, </span><span class="s1">tickdir):</span>
        <span class="s0">&quot;&quot;&quot;Set tick direction.  Valid values are 'out', 'in', 'inout'.&quot;&quot;&quot;</span>
        <span class="s4"># This method is responsible for updating `_pad`, and, in subclasses,</span>
        <span class="s4"># for setting the tick{1,2}line markers as well.  From the user</span>
        <span class="s4"># perspective this should always be called though _apply_params, which</span>
        <span class="s4"># further updates ticklabel positions using the new pads.</span>
        <span class="s2">if </span><span class="s1">tickdir </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tickdir = mpl.rcParams[</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">self.__name__</span><span class="s2">}</span><span class="s5">.direction'</span><span class="s1">]</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'in'</span><span class="s2">, </span><span class="s5">'out'</span><span class="s2">, </span><span class="s5">'inout'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tickdir=tickdir)</span>
        <span class="s1">self._tickdir = tickdir</span>
        <span class="s1">self._pad = self._base_pad + self.get_tick_padding()</span>

    <span class="s2">def </span><span class="s1">get_tickdir(self):</span>
        <span class="s2">return </span><span class="s1">self._tickdir</span>

    <span class="s2">def </span><span class="s1">get_tick_padding(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the length of the tick outside of the Axes.&quot;&quot;&quot;</span>
        <span class="s1">padding = {</span>
            <span class="s5">'in'</span><span class="s1">: </span><span class="s3">0.0</span><span class="s2">,</span>
            <span class="s5">'inout'</span><span class="s1">: </span><span class="s3">0.5</span><span class="s2">,</span>
            <span class="s5">'out'</span><span class="s1">: </span><span class="s3">1.0</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">self._size * padding[self._tickdir]</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s1">children = [self.tick1line</span><span class="s2">, </span><span class="s1">self.tick2line</span><span class="s2">,</span>
                    <span class="s1">self.gridline</span><span class="s2">, </span><span class="s1">self.label1</span><span class="s2">, </span><span class="s1">self.label2]</span>
        <span class="s2">return </span><span class="s1">children</span>

    <span class="s2">def </span><span class="s1">set_clip_path(self</span><span class="s2">, </span><span class="s1">clippath</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">super().set_clip_path(clippath</span><span class="s2">, </span><span class="s1">transform)</span>
        <span class="s1">self.gridline.set_clip_path(clippath</span><span class="s2">, </span><span class="s1">transform)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_api.deprecated(</span><span class="s5">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_pad_pixels(self):</span>
        <span class="s2">return </span><span class="s1">self.figure.dpi * self._base_pad / </span><span class="s3">72</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether the mouse event occurred in the Tick marks. 
 
        This function always returns false.  It is more useful to test if the 
        axis as a whole contains the mouse rather than the set of tick marks. 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s2">return False, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">set_pad(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the tick label pad in points 
 
        Parameters 
        ---------- 
        val : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._apply_params(pad=val)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_pad(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the value of the tick label pad in points.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._base_pad</span>

    <span class="s2">def </span><span class="s1">_get_text1(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the default Text 1 instance.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_text2(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the default Text 2 instance.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_tick1line(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the default `.Line2D` instance for tick1.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_tick2line(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the default `.Line2D` instance for tick2.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_get_gridline(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the default grid `.Line2D` instance for this tick.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">get_loc(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the tick location (data coords) as a scalar.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._loc</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s1">self.stale = </span><span class="s2">False</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(self.__name__</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>
        <span class="s2">for </span><span class="s1">artist </span><span class="s2">in </span><span class="s1">[self.gridline</span><span class="s2">, </span><span class="s1">self.tick1line</span><span class="s2">, </span><span class="s1">self.tick2line</span><span class="s2">,</span>
                       <span class="s1">self.label1</span><span class="s2">, </span><span class="s1">self.label2]:</span>
            <span class="s1">artist.draw(renderer)</span>
        <span class="s1">renderer.close_group(self.__name__)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">set_label1(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the label1 text. 
 
        Parameters 
        ---------- 
        s : str 
        &quot;&quot;&quot;</span>
        <span class="s1">self.label1.set_text(s)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">set_label = set_label1</span>

    <span class="s2">def </span><span class="s1">set_label2(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the label2 text. 
 
        Parameters 
        ---------- 
        s : str 
        &quot;&quot;&quot;</span>
        <span class="s1">self.label2.set_text(s)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_url(self</span><span class="s2">, </span><span class="s1">url):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the url of label1 and label2. 
 
        Parameters 
        ---------- 
        url : str 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_url(url)</span>
        <span class="s1">self.label1.set_url(url)</span>
        <span class="s1">self.label2.set_url(url)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_set_artist_props(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s1">a.set_figure(self.figure)</span>

    <span class="s2">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the view limits ``(min, max)`` of the axis the tick belongs to. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_apply_params(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">target </span><span class="s2">in </span><span class="s1">[(</span><span class="s5">&quot;gridOn&quot;</span><span class="s2">, </span><span class="s1">self.gridline)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s5">&quot;tick1On&quot;</span><span class="s2">, </span><span class="s1">self.tick1line)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s5">&quot;tick2On&quot;</span><span class="s2">, </span><span class="s1">self.tick2line)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s5">&quot;label1On&quot;</span><span class="s2">, </span><span class="s1">self.label1)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s5">&quot;label2On&quot;</span><span class="s2">, </span><span class="s1">self.label2)]:</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s1">target.set_visible(kwargs.pop(name))</span>
        <span class="s2">if </span><span class="s1">any(k </span><span class="s2">in </span><span class="s1">kwargs </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'size'</span><span class="s2">, </span><span class="s5">'width'</span><span class="s2">, </span><span class="s5">'pad'</span><span class="s2">, </span><span class="s5">'tickdir'</span><span class="s1">]):</span>
            <span class="s1">self._size = kwargs.pop(</span><span class="s5">'size'</span><span class="s2">, </span><span class="s1">self._size)</span>
            <span class="s4"># Width could be handled outside this block, but it is</span>
            <span class="s4"># convenient to leave it here.</span>
            <span class="s1">self._width = kwargs.pop(</span><span class="s5">'width'</span><span class="s2">, </span><span class="s1">self._width)</span>
            <span class="s1">self._base_pad = kwargs.pop(</span><span class="s5">'pad'</span><span class="s2">, </span><span class="s1">self._base_pad)</span>
            <span class="s4"># _apply_tickdir uses _size and _base_pad to make _pad, and also</span>
            <span class="s4"># sets the ticklines markers.</span>
            <span class="s1">self._apply_tickdir(kwargs.pop(</span><span class="s5">'tickdir'</span><span class="s2">, </span><span class="s1">self._tickdir))</span>
            <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">(self.tick1line</span><span class="s2">, </span><span class="s1">self.tick2line):</span>
                <span class="s1">line.set_markersize(self._size)</span>
                <span class="s1">line.set_markeredgewidth(self._width)</span>
            <span class="s4"># _get_text1_transform uses _pad from _apply_tickdir.</span>
            <span class="s1">trans = self._get_text1_transform()[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.label1.set_transform(trans)</span>
            <span class="s1">trans = self._get_text2_transform()[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">self.label2.set_transform(trans)</span>
        <span class="s1">tick_kw = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'color'</span><span class="s2">, </span><span class="s5">'zorder'</span><span class="s1">]}</span>
        <span class="s2">if </span><span class="s5">'color' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">tick_kw[</span><span class="s5">'markeredgecolor'</span><span class="s1">] = kwargs[</span><span class="s5">'color'</span><span class="s1">]</span>
        <span class="s1">self.tick1line.set(**tick_kw)</span>
        <span class="s1">self.tick2line.set(**tick_kw)</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">tick_kw.items():</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s5">'_' </span><span class="s1">+ k</span><span class="s2">, </span><span class="s1">v)</span>

        <span class="s2">if </span><span class="s5">'labelrotation' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self._set_labelrotation(kwargs.pop(</span><span class="s5">'labelrotation'</span><span class="s1">))</span>
            <span class="s1">self.label1.set(rotation=self._labelrotation[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">self.label2.set(rotation=self._labelrotation[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">label_kw = {k[</span><span class="s3">5</span><span class="s1">:]: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items()</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'labelsize'</span><span class="s2">, </span><span class="s5">'labelcolor'</span><span class="s1">]}</span>
        <span class="s1">self.label1.set(**label_kw)</span>
        <span class="s1">self.label2.set(**label_kw)</span>

        <span class="s1">grid_kw = {k[</span><span class="s3">5</span><span class="s1">:]: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items()</span>
                   <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">_gridline_param_names}</span>
        <span class="s1">self.gridline.set(**grid_kw)</span>

    <span class="s2">def </span><span class="s1">update_position(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s0">&quot;&quot;&quot;Set the location of tick in data coords with scalar *loc*.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_text1_transform(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_text2_transform(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">XTick(Tick):</span>
    <span class="s0">&quot;&quot;&quot; 
    Contains all the Artists needed to make an x tick - the tick line, 
    the label text and the grid line 
    &quot;&quot;&quot;</span>
    <span class="s1">__name__ = </span><span class="s5">'xtick'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s4"># x in data coords, y in axes coords</span>
        <span class="s1">ax = self.axes</span>
        <span class="s1">self.tick1line.set(</span>
            <span class="s1">data=([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_xaxis_transform(</span><span class="s5">&quot;tick1&quot;</span><span class="s1">))</span>
        <span class="s1">self.tick2line.set(</span>
            <span class="s1">data=([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_xaxis_transform(</span><span class="s5">&quot;tick2&quot;</span><span class="s1">))</span>
        <span class="s1">self.gridline.set(</span>
            <span class="s1">data=([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_xaxis_transform(</span><span class="s5">&quot;grid&quot;</span><span class="s1">))</span>
        <span class="s4"># the y loc is 3 points below the min of y axis</span>
        <span class="s1">trans</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ha = self._get_text1_transform()</span>
        <span class="s1">self.label1.set(</span>
            <span class="s1">x=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">verticalalignment=va</span><span class="s2">, </span><span class="s1">horizontalalignment=ha</span><span class="s2">, </span><span class="s1">transform=trans</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">trans</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ha = self._get_text2_transform()</span>
        <span class="s1">self.label2.set(</span>
            <span class="s1">x=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">verticalalignment=va</span><span class="s2">, </span><span class="s1">horizontalalignment=ha</span><span class="s2">, </span><span class="s1">transform=trans</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_text1_transform(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.get_xaxis_text1_transform(self._pad)</span>

    <span class="s2">def </span><span class="s1">_get_text2_transform(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.get_xaxis_text2_transform(self._pad)</span>

    <span class="s2">def </span><span class="s1">_apply_tickdir(self</span><span class="s2">, </span><span class="s1">tickdir):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">super()._apply_tickdir(tickdir)</span>
        <span class="s1">mark1</span><span class="s2">, </span><span class="s1">mark2 = {</span>
            <span class="s5">'out'</span><span class="s1">: (mlines.TICKDOWN</span><span class="s2">, </span><span class="s1">mlines.TICKUP)</span><span class="s2">,</span>
            <span class="s5">'in'</span><span class="s1">: (mlines.TICKUP</span><span class="s2">, </span><span class="s1">mlines.TICKDOWN)</span><span class="s2">,</span>
            <span class="s5">'inout'</span><span class="s1">: (</span><span class="s5">'|'</span><span class="s2">, </span><span class="s5">'|'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}[self._tickdir]</span>
        <span class="s1">self.tick1line.set_marker(mark1)</span>
        <span class="s1">self.tick2line.set_marker(mark2)</span>

    <span class="s2">def </span><span class="s1">update_position(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s0">&quot;&quot;&quot;Set the location of tick in data coords with scalar *loc*.&quot;&quot;&quot;</span>
        <span class="s1">self.tick1line.set_xdata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.tick2line.set_xdata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.gridline.set_xdata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.label1.set_x(loc)</span>
        <span class="s1">self.label2.set_x(loc)</span>
        <span class="s1">self._loc = loc</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">self.axes.viewLim.intervalx</span>


<span class="s2">class </span><span class="s1">YTick(Tick):</span>
    <span class="s0">&quot;&quot;&quot; 
    Contains all the Artists needed to make a Y tick - the tick line, 
    the label text and the grid line 
    &quot;&quot;&quot;</span>
    <span class="s1">__name__ = </span><span class="s5">'ytick'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s4"># x in axes coords, y in data coords</span>
        <span class="s1">ax = self.axes</span>
        <span class="s1">self.tick1line.set(</span>
            <span class="s1">data=([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_yaxis_transform(</span><span class="s5">&quot;tick1&quot;</span><span class="s1">))</span>
        <span class="s1">self.tick2line.set(</span>
            <span class="s1">data=([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_yaxis_transform(</span><span class="s5">&quot;tick2&quot;</span><span class="s1">))</span>
        <span class="s1">self.gridline.set(</span>
            <span class="s1">data=([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">transform=ax.get_yaxis_transform(</span><span class="s5">&quot;grid&quot;</span><span class="s1">))</span>
        <span class="s4"># the y loc is 3 points below the min of y axis</span>
        <span class="s1">trans</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ha = self._get_text1_transform()</span>
        <span class="s1">self.label1.set(</span>
            <span class="s1">x=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">verticalalignment=va</span><span class="s2">, </span><span class="s1">horizontalalignment=ha</span><span class="s2">, </span><span class="s1">transform=trans</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">trans</span><span class="s2">, </span><span class="s1">va</span><span class="s2">, </span><span class="s1">ha = self._get_text2_transform()</span>
        <span class="s1">self.label2.set(</span>
            <span class="s1">x=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">verticalalignment=va</span><span class="s2">, </span><span class="s1">horizontalalignment=ha</span><span class="s2">, </span><span class="s1">transform=trans</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_text1_transform(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.get_yaxis_text1_transform(self._pad)</span>

    <span class="s2">def </span><span class="s1">_get_text2_transform(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.get_yaxis_text2_transform(self._pad)</span>

    <span class="s2">def </span><span class="s1">_apply_tickdir(self</span><span class="s2">, </span><span class="s1">tickdir):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">super()._apply_tickdir(tickdir)</span>
        <span class="s1">mark1</span><span class="s2">, </span><span class="s1">mark2 = {</span>
            <span class="s5">'out'</span><span class="s1">: (mlines.TICKLEFT</span><span class="s2">, </span><span class="s1">mlines.TICKRIGHT)</span><span class="s2">,</span>
            <span class="s5">'in'</span><span class="s1">: (mlines.TICKRIGHT</span><span class="s2">, </span><span class="s1">mlines.TICKLEFT)</span><span class="s2">,</span>
            <span class="s5">'inout'</span><span class="s1">: (</span><span class="s5">'_'</span><span class="s2">, </span><span class="s5">'_'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}[self._tickdir]</span>
        <span class="s1">self.tick1line.set_marker(mark1)</span>
        <span class="s1">self.tick2line.set_marker(mark2)</span>

    <span class="s2">def </span><span class="s1">update_position(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s0">&quot;&quot;&quot;Set the location of tick in data coords with scalar *loc*.&quot;&quot;&quot;</span>
        <span class="s1">self.tick1line.set_ydata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.tick2line.set_ydata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.gridline.set_ydata((loc</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">self.label1.set_y(loc)</span>
        <span class="s1">self.label2.set_y(loc)</span>
        <span class="s1">self._loc = loc</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">self.axes.viewLim.intervaly</span>


<span class="s2">class </span><span class="s1">Ticker:</span>
    <span class="s0">&quot;&quot;&quot; 
    A container for the objects defining tick position and format. 
 
    Attributes 
    ---------- 
    locator : `matplotlib.ticker.Locator` subclass 
        Determines the positions of the ticks. 
    formatter : `matplotlib.ticker.Formatter` subclass 
        Determines the format of the tick labels. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._locator = </span><span class="s2">None</span>
        <span class="s1">self._formatter = </span><span class="s2">None</span>
        <span class="s1">self._locator_is_default = </span><span class="s2">True</span>
        <span class="s1">self._formatter_is_default = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">locator(self):</span>
        <span class="s2">return </span><span class="s1">self._locator</span>

    <span class="s1">@locator.setter</span>
    <span class="s2">def </span><span class="s1">locator(self</span><span class="s2">, </span><span class="s1">locator):</span>
        <span class="s2">if not </span><span class="s1">isinstance(locator</span><span class="s2">, </span><span class="s1">mticker.Locator):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'locator must be a subclass of '</span>
                            <span class="s5">'matplotlib.ticker.Locator'</span><span class="s1">)</span>
        <span class="s1">self._locator = locator</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">formatter(self):</span>
        <span class="s2">return </span><span class="s1">self._formatter</span>

    <span class="s1">@formatter.setter</span>
    <span class="s2">def </span><span class="s1">formatter(self</span><span class="s2">, </span><span class="s1">formatter):</span>
        <span class="s2">if not </span><span class="s1">isinstance(formatter</span><span class="s2">, </span><span class="s1">mticker.Formatter):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'formatter must be a subclass of '</span>
                            <span class="s5">'matplotlib.ticker.Formatter'</span><span class="s1">)</span>
        <span class="s1">self._formatter = formatter</span>


<span class="s2">class </span><span class="s1">_LazyTickList:</span>
    <span class="s0">&quot;&quot;&quot; 
    A descriptor for lazy instantiation of tick lists. 
 
    See comment above definition of the ``majorTicks`` and ``minorTicks`` 
    attributes. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">major):</span>
        <span class="s1">self._major = major</span>

    <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">cls):</span>
        <span class="s2">if </span><span class="s1">instance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># instance._get_tick() can itself try to access the majorTicks</span>
            <span class="s4"># attribute (e.g. in certain projection classes which override</span>
            <span class="s4"># e.g. get_xaxis_text1_transform).  In order to avoid infinite</span>
            <span class="s4"># recursion, first set the majorTicks on the instance to an empty</span>
            <span class="s4"># list, then create the tick and append it.</span>
            <span class="s2">if </span><span class="s1">self._major:</span>
                <span class="s1">instance.majorTicks = []</span>
                <span class="s1">tick = instance._get_tick(major=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">instance.majorTicks.append(tick)</span>
                <span class="s2">return </span><span class="s1">instance.majorTicks</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">instance.minorTicks = []</span>
                <span class="s1">tick = instance._get_tick(major=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">instance.minorTicks.append(tick)</span>
                <span class="s2">return </span><span class="s1">instance.minorTicks</span>


<span class="s2">class </span><span class="s1">Axis(martist.Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for `.XAxis` and `.YAxis`. 
 
    Attributes 
    ---------- 
    isDefault_label : bool 
 
    axes : `matplotlib.axes.Axes` 
        The `~.axes.Axes` to which the Axis belongs. 
    major : `matplotlib.axis.Ticker` 
        Determines the major tick positions and their label format. 
    minor : `matplotlib.axis.Ticker` 
        Determines the minor tick positions and their label format. 
    callbacks : `matplotlib.cbook.CallbackRegistry` 
 
    label : `.Text` 
        The axis label. 
    labelpad : float 
        The distance between the axis label and the tick labels. 
        Defaults to :rc:`axes.labelpad` = 4. 
    offsetText : `.Text` 
        A `.Text` object containing the data offset of the ticks (if any). 
    pickradius : float 
        The acceptance radius for containment tests. See also `.Axis.contains`. 
    majorTicks : list of `.Tick` 
        The major ticks. 
    minorTicks : list of `.Tick` 
        The minor ticks. 
    &quot;&quot;&quot;</span>
    <span class="s1">OFFSETTEXTPAD = </span><span class="s3">3</span>
    <span class="s4"># The class used in _get_tick() to create tick instances. Must either be</span>
    <span class="s4"># overwritten in subclasses, or subclasses must reimplement _get_tick().</span>
    <span class="s1">_tick_class = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s5">&quot;{}({},{})&quot;</span><span class="s1">.format(</span>
            <span class="s1">type(self).__name__</span><span class="s2">, </span><span class="s1">*self.axes.transAxes.transform((</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)))</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s5">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">&quot;pickradius&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">pickradius=</span><span class="s3">15</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        axes : `matplotlib.axes.Axes` 
            The `~.axes.Axes` to which the created Axis belongs. 
        pickradius : float 
            The acceptance radius for containment tests. See also 
            `.Axis.contains`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._remove_overlapping_locs = </span><span class="s2">True</span>

        <span class="s1">self.set_figure(axes.figure)</span>

        <span class="s1">self.isDefault_label = </span><span class="s2">True</span>

        <span class="s1">self.axes = axes</span>
        <span class="s1">self.major = Ticker()</span>
        <span class="s1">self.minor = Ticker()</span>
        <span class="s1">self.callbacks = cbook.CallbackRegistry(signals=[</span><span class="s5">&quot;units&quot;</span><span class="s1">])</span>

        <span class="s1">self._autolabelpos = </span><span class="s2">True</span>

        <span class="s1">self.label = mtext.Text(</span>
            <span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">,</span>
            <span class="s1">fontsize=mpl.rcParams[</span><span class="s5">'axes.labelsize'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">fontweight=mpl.rcParams[</span><span class="s5">'axes.labelweight'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">color=mpl.rcParams[</span><span class="s5">'axes.labelcolor'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._set_artist_props(self.label)</span>
        <span class="s1">self.offsetText = mtext.Text(np.nan</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">self._set_artist_props(self.offsetText)</span>

        <span class="s1">self.labelpad = mpl.rcParams[</span><span class="s5">'axes.labelpad'</span><span class="s1">]</span>

        <span class="s1">self.pickradius = pickradius</span>

        <span class="s4"># Initialize here for testing; later add API</span>
        <span class="s1">self._major_tick_kw = dict()</span>
        <span class="s1">self._minor_tick_kw = dict()</span>

        <span class="s1">self.clear()</span>
        <span class="s1">self._autoscale_on = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">isDefault_majloc(self):</span>
        <span class="s2">return </span><span class="s1">self.major._locator_is_default</span>

    <span class="s1">@isDefault_majloc.setter</span>
    <span class="s2">def </span><span class="s1">isDefault_majloc(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.major._locator_is_default = value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">isDefault_majfmt(self):</span>
        <span class="s2">return </span><span class="s1">self.major._formatter_is_default</span>

    <span class="s1">@isDefault_majfmt.setter</span>
    <span class="s2">def </span><span class="s1">isDefault_majfmt(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.major._formatter_is_default = value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">isDefault_minloc(self):</span>
        <span class="s2">return </span><span class="s1">self.minor._locator_is_default</span>

    <span class="s1">@isDefault_minloc.setter</span>
    <span class="s2">def </span><span class="s1">isDefault_minloc(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.minor._locator_is_default = value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">isDefault_minfmt(self):</span>
        <span class="s2">return </span><span class="s1">self.minor._formatter_is_default</span>

    <span class="s1">@isDefault_minfmt.setter</span>
    <span class="s2">def </span><span class="s1">isDefault_minfmt(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self.minor._formatter_is_default = value</span>

    <span class="s4"># During initialization, Axis objects often create ticks that are later</span>
    <span class="s4"># unused; this turns out to be a very slow step.  Instead, use a custom</span>
    <span class="s4"># descriptor to make the tick lists lazy and instantiate them as needed.</span>
    <span class="s1">majorTicks = _LazyTickList(major=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">minorTicks = _LazyTickList(major=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_remove_overlapping_locs(self):</span>
        <span class="s2">return </span><span class="s1">self._remove_overlapping_locs</span>

    <span class="s2">def </span><span class="s1">set_remove_overlapping_locs(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s1">self._remove_overlapping_locs = bool(val)</span>

    <span class="s1">remove_overlapping_locs = property(</span>
        <span class="s1">get_remove_overlapping_locs</span><span class="s2">, </span><span class="s1">set_remove_overlapping_locs</span><span class="s2">,</span>
        <span class="s1">doc=(</span><span class="s5">'If minor ticker locations that overlap with major '</span>
             <span class="s5">'ticker locations should be trimmed.'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">set_label_coords(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the coordinates of the label. 
 
        By default, the x coordinate of the y label and the y coordinate of the 
        x label are determined by the tick label bounding boxes, but this can 
        lead to poor alignment of multiple labels if there are multiple axes. 
 
        You can also specify the coordinate system of the label with the 
        transform.  If None, the default coordinate system will be the axes 
        coordinate system: (0, 0) is bottom left, (0.5, 0.5) is center, etc. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._autolabelpos = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">transform = self.axes.transAxes</span>

        <span class="s1">self.label.set_transform(transform)</span>
        <span class="s1">self.label.set_position((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s2">return </span><span class="s1">self._scale.get_transform()</span>

    <span class="s2">def </span><span class="s1">get_scale(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this Axis' scale (as a str).&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._scale.name</span>

    <span class="s2">def </span><span class="s1">_set_scale(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if not </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">mscale.ScaleBase):</span>
            <span class="s1">self._scale = mscale.scale_factory(value</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._scale = value</span>
        <span class="s1">self._scale.set_default_locators_and_formatters(self)</span>

        <span class="s1">self.isDefault_majloc = </span><span class="s2">True</span>
        <span class="s1">self.isDefault_minloc = </span><span class="s2">True</span>
        <span class="s1">self.isDefault_majfmt = </span><span class="s2">True</span>
        <span class="s1">self.isDefault_minfmt = </span><span class="s2">True</span>

    <span class="s4"># This method is directly wrapped by Axes.set_{x,y}scale.</span>
    <span class="s2">def </span><span class="s1">_set_axes_scale(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set this Axis' scale. 
 
        Parameters 
        ---------- 
        value : {&quot;linear&quot;, &quot;log&quot;, &quot;symlog&quot;, &quot;logit&quot;, ...} or `.ScaleBase` 
            The axis scale type to apply. 
 
        **kwargs 
            Different keyword arguments are accepted, depending on the scale. 
            See the respective class keyword arguments: 
 
            - `matplotlib.scale.LinearScale` 
            - `matplotlib.scale.LogScale` 
            - `matplotlib.scale.SymmetricalLogScale` 
            - `matplotlib.scale.LogitScale` 
            - `matplotlib.scale.FuncScale` 
 
        Notes 
        ----- 
        By default, Matplotlib supports the above-mentioned scales. 
        Additionally, custom scales may be registered using 
        `matplotlib.scale.register_scale`. These scales can then also 
        be used here. 
        &quot;&quot;&quot;</span>
        <span class="s1">name</span><span class="s2">, </span><span class="s1">= [name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self.axes._axis_map.items()</span>
                 <span class="s2">if </span><span class="s1">axis </span><span class="s2">is </span><span class="s1">self]  </span><span class="s4"># The axis name.</span>
        <span class="s1">old_default_lims = (self.get_major_locator()</span>
                            <span class="s1">.nonsingular(-np.inf</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">g = self.axes._shared_axes[name]</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">g.get_siblings(self.axes):</span>
            <span class="s1">ax._axis_map[name]._set_scale(value</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">ax._update_transScale()</span>
            <span class="s1">ax.stale = </span><span class="s2">True</span>
        <span class="s1">new_default_lims = (self.get_major_locator()</span>
                            <span class="s1">.nonsingular(-np.inf</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s2">if </span><span class="s1">old_default_lims != new_default_lims:</span>
            <span class="s4"># Force autoscaling now, to take advantage of the scale locator's</span>
            <span class="s4"># nonsingular() before it possibly gets swapped out by the user.</span>
            <span class="s1">self.axes.autoscale_view(</span>
                <span class="s1">**{</span><span class="s5">f&quot;scale</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">: k == name </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.axes._axis_names})</span>

    <span class="s2">def </span><span class="s1">limit_range_for_scale(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax):</span>
        <span class="s2">return </span><span class="s1">self._scale.limit_range_for_scale(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">self.get_minpos())</span>

    <span class="s2">def </span><span class="s1">_get_autoscale_on(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether this Axis is autoscaled.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._autoscale_on</span>

    <span class="s2">def </span><span class="s1">_set_autoscale_on(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether this Axis is autoscaled when drawing or by 
        `.Axes.autoscale_view`. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._autoscale_on = b</span>

    <span class="s2">def </span><span class="s1">get_children(self):</span>
        <span class="s2">return </span><span class="s1">[self.label</span><span class="s2">, </span><span class="s1">self.offsetText</span><span class="s2">,</span>
                <span class="s1">*self.get_major_ticks()</span><span class="s2">, </span><span class="s1">*self.get_minor_ticks()]</span>

    <span class="s2">def </span><span class="s1">_reset_major_tick_kw(self):</span>
        <span class="s1">self._major_tick_kw.clear()</span>
        <span class="s1">self._major_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">] </span><span class="s2">and</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'major'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">_reset_minor_tick_kw(self):</span>
        <span class="s1">self._minor_tick_kw.clear()</span>
        <span class="s1">self._minor_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">] </span><span class="s2">and</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Clear the axis. 
 
        This resets axis properties to their default values: 
 
        - the label 
        - the scale 
        - locators, formatters and ticks 
        - major and minor grid 
        - units 
        - registered callbacks 
        &quot;&quot;&quot;</span>
        <span class="s1">self.label._reset_visual_defaults()</span>
        <span class="s1">self.offsetText._reset_visual_defaults()</span>
        <span class="s1">self.labelpad = mpl.rcParams[</span><span class="s5">'axes.labelpad'</span><span class="s1">]</span>

        <span class="s1">self._init()</span>

        <span class="s1">self._set_scale(</span><span class="s5">'linear'</span><span class="s1">)</span>

        <span class="s4"># Clear the callback registry for this axis, or it may &quot;leak&quot;</span>
        <span class="s1">self.callbacks = cbook.CallbackRegistry(signals=[</span><span class="s5">&quot;units&quot;</span><span class="s1">])</span>

        <span class="s4"># whether the grids are on</span>
        <span class="s1">self._major_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">] </span><span class="s2">and</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'major'</span><span class="s1">))</span>
        <span class="s1">self._minor_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid'</span><span class="s1">] </span><span class="s2">and</span>
                <span class="s1">mpl.rcParams[</span><span class="s5">'axes.grid.which'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s1">))</span>
        <span class="s1">self.reset_ticks()</span>

        <span class="s1">self.converter = </span><span class="s2">None</span>
        <span class="s1">self.units = </span><span class="s2">None</span>
        <span class="s1">self.set_units(</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">reset_ticks(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Re-initialize the major and minor Tick lists. 
 
        Each list starts with a single fresh Tick. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Restore the lazy tick lists.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self.majorTicks</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self.minorTicks</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.set_clip_path(self.axes.patch)</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">set_tick_params(self</span><span class="s2">, </span><span class="s1">which=</span><span class="s5">'major'</span><span class="s2">, </span><span class="s1">reset=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set appearance parameters for ticks, ticklabels, and gridlines. 
 
        For documentation of keyword arguments, see 
        :meth:`matplotlib.axes.Axes.tick_params`. 
 
        See Also 
        -------- 
        .Axis.get_tick_params 
            View the current style settings for ticks, ticklabels, and 
            gridlines. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">which=which)</span>
        <span class="s1">kwtrans = self._translate_tick_params(kwargs)</span>

        <span class="s4"># the kwargs are stored in self._major/minor_tick_kw so that any</span>
        <span class="s4"># future new ticks will automatically get them</span>
        <span class="s2">if </span><span class="s1">reset:</span>
            <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
                <span class="s1">self._reset_major_tick_kw()</span>
                <span class="s1">self._major_tick_kw.update(kwtrans)</span>
            <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
                <span class="s1">self._reset_minor_tick_kw()</span>
                <span class="s1">self._minor_tick_kw.update(kwtrans)</span>
            <span class="s1">self.reset_ticks()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
                <span class="s1">self._major_tick_kw.update(kwtrans)</span>
                <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">self.majorTicks:</span>
                    <span class="s1">tick._apply_params(**kwtrans)</span>
            <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
                <span class="s1">self._minor_tick_kw.update(kwtrans)</span>
                <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">self.minorTicks:</span>
                    <span class="s1">tick._apply_params(**kwtrans)</span>
            <span class="s4"># labelOn and labelcolor also apply to the offset text.</span>
            <span class="s2">if </span><span class="s5">'label1On' </span><span class="s2">in </span><span class="s1">kwtrans </span><span class="s2">or </span><span class="s5">'label2On' </span><span class="s2">in </span><span class="s1">kwtrans:</span>
                <span class="s1">self.offsetText.set_visible(</span>
                    <span class="s1">self._major_tick_kw.get(</span><span class="s5">'label1On'</span><span class="s2">, False</span><span class="s1">)</span>
                    <span class="s2">or </span><span class="s1">self._major_tick_kw.get(</span><span class="s5">'label2On'</span><span class="s2">, False</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s5">'labelcolor' </span><span class="s2">in </span><span class="s1">kwtrans:</span>
                <span class="s1">self.offsetText.set_color(kwtrans[</span><span class="s5">'labelcolor'</span><span class="s1">])</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_tick_params(self</span><span class="s2">, </span><span class="s1">which=</span><span class="s5">'major'</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get appearance parameters for ticks, ticklabels, and gridlines. 
 
        .. versionadded:: 3.7 
 
        Parameters 
        ---------- 
        which : {'major', 'minor'}, default: 'major' 
            The group of ticks for which the parameters are retrieved. 
 
        Returns 
        ------- 
        dict 
            Properties for styling tick elements added to the axis. 
 
        Notes 
        ----- 
        This method returns the appearance parameters for styling *new* 
        elements added to this axis and may be different from the values 
        on current elements if they were modified directly by the user 
        (e.g., via ``set_*`` methods on individual tick objects). 
 
        Examples 
        -------- 
        :: 
 
            &gt;&gt;&gt; ax.yaxis.set_tick_params(labelsize=30, labelcolor='red', 
                                         direction='out', which='major') 
            &gt;&gt;&gt; ax.yaxis.get_tick_params(which='major') 
            {'direction': 'out', 
            'left': True, 
            'right': False, 
            'labelleft': True, 
            'labelright': False, 
            'gridOn': False, 
            'labelsize': 30, 
            'labelcolor': 'red'} 
            &gt;&gt;&gt; ax.yaxis.get_tick_params(which='minor') 
            {'left': True, 
            'right': False, 
            'labelleft': True, 
            'labelright': False, 
            'gridOn': False} 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">which=which)</span>
        <span class="s2">if </span><span class="s1">which == </span><span class="s5">'major'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._translate_tick_params(</span>
                <span class="s1">self._major_tick_kw</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._translate_tick_params(self._minor_tick_kw</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_translate_tick_params(kw</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Translate the kwargs supported by `.Axis.set_tick_params` to kwargs 
        supported by `.Tick._apply_params`. 
 
        In particular, this maps axis specific names like 'top', 'left' 
        to the generic tick1, tick2 logic of the axis. Additionally, there 
        are some other name translations. 
 
        Returns a new dict of translated kwargs. 
 
        Note: Use reverse=True to translate from those supported by 
        `.Tick._apply_params` back to those supported by 
        `.Axis.set_tick_params`. 
        &quot;&quot;&quot;</span>
        <span class="s1">kw_ = {**kw}</span>

        <span class="s4"># The following lists may be moved to a more accessible location.</span>
        <span class="s1">allowed_keys = [</span>
            <span class="s5">'size'</span><span class="s2">, </span><span class="s5">'width'</span><span class="s2">, </span><span class="s5">'color'</span><span class="s2">, </span><span class="s5">'tickdir'</span><span class="s2">, </span><span class="s5">'pad'</span><span class="s2">,</span>
            <span class="s5">'labelsize'</span><span class="s2">, </span><span class="s5">'labelcolor'</span><span class="s2">, </span><span class="s5">'zorder'</span><span class="s2">, </span><span class="s5">'gridOn'</span><span class="s2">,</span>
            <span class="s5">'tick1On'</span><span class="s2">, </span><span class="s5">'tick2On'</span><span class="s2">, </span><span class="s5">'label1On'</span><span class="s2">, </span><span class="s5">'label2On'</span><span class="s2">,</span>
            <span class="s5">'length'</span><span class="s2">, </span><span class="s5">'direction'</span><span class="s2">, </span><span class="s5">'left'</span><span class="s2">, </span><span class="s5">'bottom'</span><span class="s2">, </span><span class="s5">'right'</span><span class="s2">, </span><span class="s5">'top'</span><span class="s2">,</span>
            <span class="s5">'labelleft'</span><span class="s2">, </span><span class="s5">'labelbottom'</span><span class="s2">, </span><span class="s5">'labelright'</span><span class="s2">, </span><span class="s5">'labeltop'</span><span class="s2">,</span>
            <span class="s5">'labelrotation'</span><span class="s2">,</span>
            <span class="s1">*_gridline_param_names]</span>

        <span class="s1">keymap = {</span>
            <span class="s4"># tick_params key -&gt; axis key</span>
            <span class="s5">'length'</span><span class="s1">: </span><span class="s5">'size'</span><span class="s2">,</span>
            <span class="s5">'direction'</span><span class="s1">: </span><span class="s5">'tickdir'</span><span class="s2">,</span>
            <span class="s5">'rotation'</span><span class="s1">: </span><span class="s5">'labelrotation'</span><span class="s2">,</span>
            <span class="s5">'left'</span><span class="s1">: </span><span class="s5">'tick1On'</span><span class="s2">,</span>
            <span class="s5">'bottom'</span><span class="s1">: </span><span class="s5">'tick1On'</span><span class="s2">,</span>
            <span class="s5">'right'</span><span class="s1">: </span><span class="s5">'tick2On'</span><span class="s2">,</span>
            <span class="s5">'top'</span><span class="s1">: </span><span class="s5">'tick2On'</span><span class="s2">,</span>
            <span class="s5">'labelleft'</span><span class="s1">: </span><span class="s5">'label1On'</span><span class="s2">,</span>
            <span class="s5">'labelbottom'</span><span class="s1">: </span><span class="s5">'label1On'</span><span class="s2">,</span>
            <span class="s5">'labelright'</span><span class="s1">: </span><span class="s5">'label2On'</span><span class="s2">,</span>
            <span class="s5">'labeltop'</span><span class="s1">: </span><span class="s5">'label2On'</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">reverse:</span>
            <span class="s1">kwtrans = {</span>
                <span class="s1">oldkey: kw_.pop(newkey)</span>
                <span class="s2">for </span><span class="s1">oldkey</span><span class="s2">, </span><span class="s1">newkey </span><span class="s2">in </span><span class="s1">keymap.items() </span><span class="s2">if </span><span class="s1">newkey </span><span class="s2">in </span><span class="s1">kw_</span>
            <span class="s1">}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">kwtrans = {</span>
                <span class="s1">newkey: kw_.pop(oldkey)</span>
                <span class="s2">for </span><span class="s1">oldkey</span><span class="s2">, </span><span class="s1">newkey </span><span class="s2">in </span><span class="s1">keymap.items() </span><span class="s2">if </span><span class="s1">oldkey </span><span class="s2">in </span><span class="s1">kw_</span>
            <span class="s1">}</span>
        <span class="s2">if </span><span class="s5">'colors' </span><span class="s2">in </span><span class="s1">kw_:</span>
            <span class="s1">c = kw_.pop(</span><span class="s5">'colors'</span><span class="s1">)</span>
            <span class="s1">kwtrans[</span><span class="s5">'color'</span><span class="s1">] = c</span>
            <span class="s1">kwtrans[</span><span class="s5">'labelcolor'</span><span class="s1">] = c</span>
        <span class="s4"># Maybe move the checking up to the caller of this method.</span>
        <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">kw_:</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">allowed_keys:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;keyword %s is not recognized; valid keywords are %s&quot;</span>
                    <span class="s1">% (key</span><span class="s2">, </span><span class="s1">allowed_keys))</span>
        <span class="s1">kwtrans.update(kw_)</span>
        <span class="s2">return </span><span class="s1">kwtrans</span>

    <span class="s2">def </span><span class="s1">set_clip_path(self</span><span class="s2">, </span><span class="s1">clippath</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">super().set_clip_path(clippath</span><span class="s2">, </span><span class="s1">transform)</span>
        <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">self.majorTicks + self.minorTicks:</span>
            <span class="s1">child.set_clip_path(clippath</span><span class="s2">, </span><span class="s1">transform)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_view_interval(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the ``(min, max)`` view limits of this axis.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_view_interval(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">ignore=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the axis view limits.  This method is for internal use; Matplotlib 
        users should typically use e.g. `~.Axes.set_xlim` or `~.Axes.set_ylim`. 
 
        If *ignore* is False (the default), this method will never reduce the 
        preexisting view limits, only expand them if *vmin* or *vmax* are not 
        within them.  Moreover, the order of *vmin* and *vmax* does not matter; 
        the orientation of the axis will not change. 
 
        If *ignore* is True, the view limits will be set exactly to ``(vmin, 
        vmax)`` in that order. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_data_interval(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the ``(min, max)`` data limits of this axis.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_data_interval(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">ignore=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the axis data limits.  This method is for internal use. 
 
        If *ignore* is False (the default), this method will never reduce the 
        preexisting data limits, only expand them if *vmin* or *vmax* are not 
        within them.  Moreover, the order of *vmin* and *vmax* does not matter; 
        the orientation of the axis will not change. 
 
        If *ignore* is True, the data limits will be set exactly to ``(vmin, 
        vmax)`` in that order. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_inverted(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether this Axis is oriented in the &quot;inverse&quot; direction. 
 
        The &quot;normal&quot; direction is increasing to the right for the x-axis and to 
        the top for the y-axis; the &quot;inverse&quot; direction is increasing to the 
        left for the x-axis and to the bottom for the y-axis. 
        &quot;&quot;&quot;</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = self.get_view_interval()</span>
        <span class="s2">return </span><span class="s1">high &lt; low</span>

    <span class="s2">def </span><span class="s1">set_inverted(self</span><span class="s2">, </span><span class="s1">inverted):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether this Axis is oriented in the &quot;inverse&quot; direction. 
 
        The &quot;normal&quot; direction is increasing to the right for the x-axis and to 
        the top for the y-axis; the &quot;inverse&quot; direction is increasing to the 
        left for the x-axis and to the bottom for the y-axis. 
        &quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = self.get_view_interval()</span>
        <span class="s4"># cast to bool to avoid bad interaction between python 3.8 and np.bool_</span>
        <span class="s1">self._set_lim(*sorted((a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">reverse=bool(inverted))</span><span class="s2">, </span><span class="s1">auto=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_default_intervals(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the default limits for the axis data and view interval if they 
        have not been not mutated yet. 
        &quot;&quot;&quot;</span>
        <span class="s4"># this is mainly in support of custom object plotting.  For</span>
        <span class="s4"># example, if someone passes in a datetime object, we do not</span>
        <span class="s4"># know automagically how to set the default min/max of the</span>
        <span class="s4"># data and view limits.  The unit conversion AxisInfo</span>
        <span class="s4"># interface provides a hook for custom types to register</span>
        <span class="s4"># default limits through the AxisInfo.default_limits</span>
        <span class="s4"># attribute, and the derived code below will check for that</span>
        <span class="s4"># and use it if it's available (else just use 0..1)</span>

    <span class="s2">def </span><span class="s1">_set_lim(self</span><span class="s2">, </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">emit=</span><span class="s2">True, </span><span class="s1">auto):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set view limits. 
 
        This method is a helper for the Axes ``set_xlim``, ``set_ylim``, and 
        ``set_zlim`` methods. 
 
        Parameters 
        ---------- 
        v0, v1 : float 
            The view limits.  (Passing *v0* as a (low, high) pair is not 
            supported; normalization must occur in the Axes setters.) 
        emit : bool, default: True 
            Whether to notify observers of limit change. 
        auto : bool or None, default: False 
            Whether to turn on autoscaling of the x-axis. True turns on, False 
            turns off, None leaves unchanged. 
        &quot;&quot;&quot;</span>
        <span class="s1">name</span><span class="s2">, </span><span class="s1">= [name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self.axes._axis_map.items()</span>
                 <span class="s2">if </span><span class="s1">axis </span><span class="s2">is </span><span class="s1">self]  </span><span class="s4"># The axis name.</span>

        <span class="s1">self.axes._process_unit_info([(name</span><span class="s2">, </span><span class="s1">(v0</span><span class="s2">, </span><span class="s1">v1))]</span><span class="s2">, </span><span class="s1">convert=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">v0 = self.axes._validate_converted_limits(v0</span><span class="s2">, </span><span class="s1">self.convert_units)</span>
        <span class="s1">v1 = self.axes._validate_converted_limits(v1</span><span class="s2">, </span><span class="s1">self.convert_units)</span>

        <span class="s2">if </span><span class="s1">v0 </span><span class="s2">is None or </span><span class="s1">v1 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s4"># Axes init calls set_xlim(0, 1) before get_xlim() can be called,</span>
            <span class="s4"># so only grab the limits if we really need them.</span>
            <span class="s1">old0</span><span class="s2">, </span><span class="s1">old1 = self.get_view_interval()</span>
            <span class="s2">if </span><span class="s1">v0 </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">v0 = old0</span>
            <span class="s2">if </span><span class="s1">v1 </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">v1 = old1</span>

        <span class="s2">if </span><span class="s1">self.get_scale() == </span><span class="s5">'log' </span><span class="s2">and </span><span class="s1">(v0 &lt;= </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">v1 &lt;= </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s4"># Axes init calls set_xlim(0, 1) before get_xlim() can be called,</span>
            <span class="s4"># so only grab the limits if we really need them.</span>
            <span class="s1">old0</span><span class="s2">, </span><span class="s1">old1 = self.get_view_interval()</span>
            <span class="s2">if </span><span class="s1">v0 &lt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s5">f&quot;Attempt to set non-positive </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">lim on &quot;</span>
                                   <span class="s5">f&quot;a log-scaled axis will be ignored.&quot;</span><span class="s1">)</span>
                <span class="s1">v0 = old0</span>
            <span class="s2">if </span><span class="s1">v1 &lt;= </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s5">f&quot;Attempt to set non-positive </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">lim on &quot;</span>
                                   <span class="s5">f&quot;a log-scaled axis will be ignored.&quot;</span><span class="s1">)</span>
                <span class="s1">v1 = old1</span>
        <span class="s2">if </span><span class="s1">v0 == v1:</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s5">f&quot;Attempting to set identical low and high </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">lims &quot;</span>
                <span class="s5">f&quot;makes transformation singular; automatically expanding.&quot;</span><span class="s1">)</span>
        <span class="s1">reverse = bool(v0 &gt; v1)  </span><span class="s4"># explicit cast needed for python3.8+np.bool_.</span>
        <span class="s1">v0</span><span class="s2">, </span><span class="s1">v1 = self.get_major_locator().nonsingular(v0</span><span class="s2">, </span><span class="s1">v1)</span>
        <span class="s1">v0</span><span class="s2">, </span><span class="s1">v1 = self.limit_range_for_scale(v0</span><span class="s2">, </span><span class="s1">v1)</span>
        <span class="s1">v0</span><span class="s2">, </span><span class="s1">v1 = sorted([v0</span><span class="s2">, </span><span class="s1">v1]</span><span class="s2">, </span><span class="s1">reverse=bool(reverse))</span>

        <span class="s1">self.set_view_interval(v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">ignore=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s4"># Mark viewlims as no longer stale without triggering an autoscale.</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">self.axes._shared_axes[name].get_siblings(self.axes):</span>
            <span class="s1">ax._stale_viewlims[name] = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">auto </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._set_autoscale_on(bool(auto))</span>

        <span class="s2">if </span><span class="s1">emit:</span>
            <span class="s1">self.axes.callbacks.process(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">lim_changed&quot;</span><span class="s2">, </span><span class="s1">self.axes)</span>
            <span class="s4"># Call all of the other axes that are shared with this one</span>
            <span class="s2">for </span><span class="s1">other </span><span class="s2">in </span><span class="s1">self.axes._shared_axes[name].get_siblings(self.axes):</span>
                <span class="s2">if </span><span class="s1">other </span><span class="s2">is not </span><span class="s1">self.axes:</span>
                    <span class="s1">other._axis_map[name]._set_lim(</span>
                        <span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">, </span><span class="s1">emit=</span><span class="s2">False, </span><span class="s1">auto=auto)</span>
                    <span class="s2">if </span><span class="s1">other.figure != self.figure:</span>
                        <span class="s1">other.figure.canvas.draw_idle()</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span>

    <span class="s2">def </span><span class="s1">_set_artist_props(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">a.set_figure(self.figure)</span>

    <span class="s1">@_api.deprecated(</span><span class="s5">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_ticklabel_extents(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Get the extents of the tick labels on either side of the axes.&quot;&quot;&quot;</span>
        <span class="s1">ticks_to_draw = self._update_ticks()</span>
        <span class="s1">tlb1</span><span class="s2">, </span><span class="s1">tlb2 = self._get_ticklabel_bboxes(ticks_to_draw</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s2">if </span><span class="s1">len(tlb1):</span>
            <span class="s1">bbox1 = mtransforms.Bbox.union(tlb1)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bbox1 = mtransforms.Bbox.from_extents(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(tlb2):</span>
            <span class="s1">bbox2 = mtransforms.Bbox.union(tlb2)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bbox2 = mtransforms.Bbox.from_extents(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">bbox1</span><span class="s2">, </span><span class="s1">bbox2</span>

    <span class="s2">def </span><span class="s1">_update_ticks(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update ticks (position and labels) using the current data interval of 
        the axes.  Return the list of ticks that will be drawn. 
        &quot;&quot;&quot;</span>
        <span class="s1">major_locs = self.get_majorticklocs()</span>
        <span class="s1">major_labels = self.major.formatter.format_ticks(major_locs)</span>
        <span class="s1">major_ticks = self.get_major_ticks(len(major_locs))</span>
        <span class="s1">self.major.formatter.set_locs(major_locs)</span>
        <span class="s2">for </span><span class="s1">tick</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">label </span><span class="s2">in </span><span class="s1">zip(major_ticks</span><span class="s2">, </span><span class="s1">major_locs</span><span class="s2">, </span><span class="s1">major_labels):</span>
            <span class="s1">tick.update_position(loc)</span>
            <span class="s1">tick.set_label1(label)</span>
            <span class="s1">tick.set_label2(label)</span>
        <span class="s1">minor_locs = self.get_minorticklocs()</span>
        <span class="s1">minor_labels = self.minor.formatter.format_ticks(minor_locs)</span>
        <span class="s1">minor_ticks = self.get_minor_ticks(len(minor_locs))</span>
        <span class="s1">self.minor.formatter.set_locs(minor_locs)</span>
        <span class="s2">for </span><span class="s1">tick</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">label </span><span class="s2">in </span><span class="s1">zip(minor_ticks</span><span class="s2">, </span><span class="s1">minor_locs</span><span class="s2">, </span><span class="s1">minor_labels):</span>
            <span class="s1">tick.update_position(loc)</span>
            <span class="s1">tick.set_label1(label)</span>
            <span class="s1">tick.set_label2(label)</span>
        <span class="s1">ticks = [*major_ticks</span><span class="s2">, </span><span class="s1">*minor_ticks]</span>

        <span class="s1">view_low</span><span class="s2">, </span><span class="s1">view_high = self.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">view_low &gt; view_high:</span>
            <span class="s1">view_low</span><span class="s2">, </span><span class="s1">view_high = view_high</span><span class="s2">, </span><span class="s1">view_low</span>

        <span class="s1">interval_t = self.get_transform().transform([view_low</span><span class="s2">, </span><span class="s1">view_high])</span>

        <span class="s1">ticks_to_draw = []</span>
        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">loc_t = self.get_transform().transform(tick.get_loc())</span>
            <span class="s2">except </span><span class="s1">AssertionError:</span>
                <span class="s4"># transforms.transform doesn't allow masked values but</span>
                <span class="s4"># some scales might make them, so we need this try/except.</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">mtransforms._interval_contains_close(interval_t</span><span class="s2">, </span><span class="s1">loc_t):</span>
                    <span class="s1">ticks_to_draw.append(tick)</span>

        <span class="s2">return </span><span class="s1">ticks_to_draw</span>

    <span class="s2">def </span><span class="s1">_get_ticklabel_bboxes(self</span><span class="s2">, </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return lists of bboxes for ticks' label1's and label2's.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>
        <span class="s2">return </span><span class="s1">([tick.label1.get_window_extent(renderer)</span>
                 <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label1.get_visible()]</span><span class="s2">,</span>
                <span class="s1">[tick.label2.get_window_extent(renderer)</span>
                 <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label2.get_visible()])</span>

    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">for_layout_only=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a bounding box that encloses the axis. It only accounts 
        tick labels, axis label, and offsetText. 
 
        If *for_layout_only* is True, then the width of the label (if this 
        is an x-axis) or the height of the label (if this is a y-axis) is 
        collapsed to near zero.  This allows tight/constrained_layout to ignore 
        too-long labels when doing their layout. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>
        <span class="s1">ticks_to_draw = self._update_ticks()</span>

        <span class="s1">self._update_label_position(renderer)</span>

        <span class="s4"># go back to just this axis's tick labels</span>
        <span class="s1">tlb1</span><span class="s2">, </span><span class="s1">tlb2 = self._get_ticklabel_bboxes(ticks_to_draw</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s1">self._update_offset_text_position(tlb1</span><span class="s2">, </span><span class="s1">tlb2)</span>
        <span class="s1">self.offsetText.set_text(self.major.formatter.get_offset())</span>

        <span class="s1">bboxes = [</span>
            <span class="s1">*(a.get_window_extent(renderer)</span>
              <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">[self.offsetText]</span>
              <span class="s2">if </span><span class="s1">a.get_visible())</span><span class="s2">,</span>
            <span class="s1">*tlb1</span><span class="s2">, </span><span class="s1">*tlb2</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s4"># take care of label</span>
        <span class="s2">if </span><span class="s1">self.label.get_visible():</span>
            <span class="s1">bb = self.label.get_window_extent(renderer)</span>
            <span class="s4"># for constrained/tight_layout, we want to ignore the label's</span>
            <span class="s4"># width/height because the adjustments they make can't be improved.</span>
            <span class="s4"># this code collapses the relevant direction</span>
            <span class="s2">if </span><span class="s1">for_layout_only:</span>
                <span class="s2">if </span><span class="s1">self.axis_name == </span><span class="s5">&quot;x&quot; </span><span class="s2">and </span><span class="s1">bb.width &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">bb.x0 = (bb.x0 + bb.x1) / </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">0.5</span>
                    <span class="s1">bb.x1 = bb.x0 + </span><span class="s3">1.0</span>
                <span class="s2">if </span><span class="s1">self.axis_name == </span><span class="s5">&quot;y&quot; </span><span class="s2">and </span><span class="s1">bb.height &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">bb.y0 = (bb.y0 + bb.y1) / </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">0.5</span>
                    <span class="s1">bb.y1 = bb.y0 + </span><span class="s3">1.0</span>
            <span class="s1">bboxes.append(bb)</span>
        <span class="s1">bboxes = [b </span><span class="s2">for </span><span class="s1">b </span><span class="s2">in </span><span class="s1">bboxes</span>
                  <span class="s2">if </span><span class="s3">0 </span><span class="s1">&lt; b.width &lt; np.inf </span><span class="s2">and </span><span class="s3">0 </span><span class="s1">&lt; b.height &lt; np.inf]</span>
        <span class="s2">if </span><span class="s1">bboxes:</span>
            <span class="s2">return </span><span class="s1">mtransforms.Bbox.union(bboxes)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">get_tick_padding(self):</span>
        <span class="s1">values = []</span>
        <span class="s2">if </span><span class="s1">len(self.majorTicks):</span>
            <span class="s1">values.append(self.majorTicks[</span><span class="s3">0</span><span class="s1">].get_tick_padding())</span>
        <span class="s2">if </span><span class="s1">len(self.minorTicks):</span>
            <span class="s1">values.append(self.minorTicks[</span><span class="s3">0</span><span class="s1">].get_tick_padding())</span>
        <span class="s2">return </span><span class="s1">max(values</span><span class="s2">, </span><span class="s1">default=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">@martist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># docstring inherited</span>

        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">renderer.open_group(__name__</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>

        <span class="s1">ticks_to_draw = self._update_ticks()</span>
        <span class="s1">tlb1</span><span class="s2">, </span><span class="s1">tlb2 = self._get_ticklabel_bboxes(ticks_to_draw</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks_to_draw:</span>
            <span class="s1">tick.draw(renderer)</span>

        <span class="s4"># Shift label away from axes to avoid overlapping ticklabels.</span>
        <span class="s1">self._update_label_position(renderer)</span>
        <span class="s1">self.label.draw(renderer)</span>

        <span class="s1">self._update_offset_text_position(tlb1</span><span class="s2">, </span><span class="s1">tlb2)</span>
        <span class="s1">self.offsetText.set_text(self.major.formatter.get_offset())</span>
        <span class="s1">self.offsetText.draw(renderer)</span>

        <span class="s1">renderer.close_group(__name__)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_gridlines(self):</span>
        <span class="s0">r&quot;&quot;&quot;Return this Axis' grid lines as a list of `.Line2D`\s.&quot;&quot;&quot;</span>
        <span class="s1">ticks = self.get_major_ticks()</span>
        <span class="s2">return </span><span class="s1">cbook.silent_list(</span><span class="s5">'Line2D gridline'</span><span class="s2">,</span>
                                 <span class="s1">[tick.gridline </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks])</span>

    <span class="s2">def </span><span class="s1">get_label(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the axis label as a Text instance.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.label</span>

    <span class="s2">def </span><span class="s1">get_offset_text(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the axis offsetText as a Text instance.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.offsetText</span>

    <span class="s2">def </span><span class="s1">get_pickradius(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the depth of the axis used by the picker.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._pickradius</span>

    <span class="s2">def </span><span class="s1">get_majorticklabels(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this Axis' major tick labels, as a list of `~.text.Text`.&quot;&quot;&quot;</span>
        <span class="s1">self._update_ticks()</span>
        <span class="s1">ticks = self.get_major_ticks()</span>
        <span class="s1">labels1 = [tick.label1 </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label1.get_visible()]</span>
        <span class="s1">labels2 = [tick.label2 </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label2.get_visible()]</span>
        <span class="s2">return </span><span class="s1">labels1 + labels2</span>

    <span class="s2">def </span><span class="s1">get_minorticklabels(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this Axis' minor tick labels, as a list of `~.text.Text`.&quot;&quot;&quot;</span>
        <span class="s1">self._update_ticks()</span>
        <span class="s1">ticks = self.get_minor_ticks()</span>
        <span class="s1">labels1 = [tick.label1 </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label1.get_visible()]</span>
        <span class="s1">labels2 = [tick.label2 </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks </span><span class="s2">if </span><span class="s1">tick.label2.get_visible()]</span>
        <span class="s2">return </span><span class="s1">labels1 + labels2</span>

    <span class="s2">def </span><span class="s1">get_ticklabels(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">which=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get this Axis' tick labels. 
 
        Parameters 
        ---------- 
        minor : bool 
           Whether to return the minor or the major ticklabels. 
 
        which : None, ('minor', 'major', 'both') 
           Overrides *minor*. 
 
           Selects which ticklabels to return 
 
        Returns 
        ------- 
        list of `~matplotlib.text.Text` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">which </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">which == </span><span class="s5">'minor'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.get_minorticklabels()</span>
            <span class="s2">elif </span><span class="s1">which == </span><span class="s5">'major'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.get_majorticklabels()</span>
            <span class="s2">elif </span><span class="s1">which == </span><span class="s5">'both'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.get_majorticklabels() + self.get_minorticklabels()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_api.check_in_list([</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">which=which)</span>
        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s2">return </span><span class="s1">self.get_minorticklabels()</span>
        <span class="s2">return </span><span class="s1">self.get_majorticklabels()</span>

    <span class="s2">def </span><span class="s1">get_majorticklines(self):</span>
        <span class="s0">r&quot;&quot;&quot;Return this Axis' major tick lines as a list of `.Line2D`\s.&quot;&quot;&quot;</span>
        <span class="s1">lines = []</span>
        <span class="s1">ticks = self.get_major_ticks()</span>
        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s1">lines.append(tick.tick1line)</span>
            <span class="s1">lines.append(tick.tick2line)</span>
        <span class="s2">return </span><span class="s1">cbook.silent_list(</span><span class="s5">'Line2D ticklines'</span><span class="s2">, </span><span class="s1">lines)</span>

    <span class="s2">def </span><span class="s1">get_minorticklines(self):</span>
        <span class="s0">r&quot;&quot;&quot;Return this Axis' minor tick lines as a list of `.Line2D`\s.&quot;&quot;&quot;</span>
        <span class="s1">lines = []</span>
        <span class="s1">ticks = self.get_minor_ticks()</span>
        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s1">lines.append(tick.tick1line)</span>
            <span class="s1">lines.append(tick.tick2line)</span>
        <span class="s2">return </span><span class="s1">cbook.silent_list(</span><span class="s5">'Line2D ticklines'</span><span class="s2">, </span><span class="s1">lines)</span>

    <span class="s2">def </span><span class="s1">get_ticklines(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot;Return this Axis' tick lines as a list of `.Line2D`\s.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s2">return </span><span class="s1">self.get_minorticklines()</span>
        <span class="s2">return </span><span class="s1">self.get_majorticklines()</span>

    <span class="s2">def </span><span class="s1">get_majorticklocs(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this Axis' major tick locations in data coordinates.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.major.locator()</span>

    <span class="s2">def </span><span class="s1">get_minorticklocs(self):</span>
        <span class="s0">&quot;&quot;&quot;Return this Axis' minor tick locations in data coordinates.&quot;&quot;&quot;</span>
        <span class="s4"># Remove minor ticks duplicating major ticks.</span>
        <span class="s1">minor_locs = np.asarray(self.minor.locator())</span>
        <span class="s2">if </span><span class="s1">self.remove_overlapping_locs:</span>
            <span class="s1">major_locs = self.major.locator()</span>
            <span class="s1">transform = self._scale.get_transform()</span>
            <span class="s1">tr_minor_locs = transform.transform(minor_locs)</span>
            <span class="s1">tr_major_locs = transform.transform(major_locs)</span>
            <span class="s1">lo</span><span class="s2">, </span><span class="s1">hi = sorted(transform.transform(self.get_view_interval()))</span>
            <span class="s4"># Use the transformed view limits as scale.  1e-5 is the default</span>
            <span class="s4"># rtol for np.isclose.</span>
            <span class="s1">tol = (hi - lo) * </span><span class="s3">1e-5</span>
            <span class="s1">mask = np.isclose(tr_minor_locs[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tr_major_locs[</span><span class="s2">None, </span><span class="s1">:]</span><span class="s2">,</span>
                              <span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">0</span><span class="s1">).any(axis=</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">minor_locs = minor_locs[~mask]</span>
        <span class="s2">return </span><span class="s1">minor_locs</span>

    <span class="s2">def </span><span class="s1">get_ticklocs(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return this Axis' tick locations in data coordinates. 
 
        The locations are not clipped to the current axis limits and hence 
        may contain locations that are not visible in the output. 
 
        Parameters 
        ---------- 
        minor : bool, default: False 
            True to return the minor tick directions, 
            False to return the major tick directions. 
 
        Returns 
        ------- 
        numpy array of tick locations 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_minorticklocs() </span><span class="s2">if </span><span class="s1">minor </span><span class="s2">else </span><span class="s1">self.get_majorticklocs()</span>

    <span class="s2">def </span><span class="s1">get_ticks_direction(self</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the tick directions as a numpy array 
 
        Parameters 
        ---------- 
        minor : bool, default: False 
            True to return the minor tick directions, 
            False to return the major tick directions. 
 
        Returns 
        ------- 
        numpy array of tick directions 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s2">return </span><span class="s1">np.array(</span>
                <span class="s1">[tick._tickdir </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">self.get_minor_ticks()])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.array(</span>
                <span class="s1">[tick._tickdir </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">self.get_major_ticks()])</span>

    <span class="s2">def </span><span class="s1">_get_tick(self</span><span class="s2">, </span><span class="s1">major):</span>
        <span class="s0">&quot;&quot;&quot;Return the default tick instance.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._tick_class </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">f&quot;The Axis subclass </span><span class="s2">{</span><span class="s1">self.__class__.__name__</span><span class="s2">} </span><span class="s5">must define &quot;</span>
                <span class="s5">&quot;_tick_class or reimplement _get_tick()&quot;</span><span class="s1">)</span>
        <span class="s1">tick_kw = self._major_tick_kw </span><span class="s2">if </span><span class="s1">major </span><span class="s2">else </span><span class="s1">self._minor_tick_kw</span>
        <span class="s2">return </span><span class="s1">self._tick_class(self.axes</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">major=major</span><span class="s2">, </span><span class="s1">**tick_kw)</span>

    <span class="s2">def </span><span class="s1">_get_tick_label_size(self</span><span class="s2">, </span><span class="s1">axis_name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the text size of tick labels for this Axis. 
 
        This is a convenience function to avoid having to create a `Tick` in 
        `.get_tick_space`, since it is expensive. 
        &quot;&quot;&quot;</span>
        <span class="s1">tick_kw = self._major_tick_kw</span>
        <span class="s1">size = tick_kw.get(</span><span class="s5">'labelsize'</span><span class="s2">,</span>
                           <span class="s1">mpl.rcParams[</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">axis_name</span><span class="s2">}</span><span class="s5">tick.labelsize'</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">mtext.FontProperties(size=size).get_size_in_points()</span>

    <span class="s2">def </span><span class="s1">_copy_tick_props(self</span><span class="s2">, </span><span class="s1">src</span><span class="s2">, </span><span class="s1">dest):</span>
        <span class="s0">&quot;&quot;&quot;Copy the properties from *src* tick to *dest* tick.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">src </span><span class="s2">is None or </span><span class="s1">dest </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s1">dest.label1.update_from(src.label1)</span>
        <span class="s1">dest.label2.update_from(src.label2)</span>
        <span class="s1">dest.tick1line.update_from(src.tick1line)</span>
        <span class="s1">dest.tick2line.update_from(src.tick2line)</span>
        <span class="s1">dest.gridline.update_from(src.gridline)</span>

    <span class="s2">def </span><span class="s1">get_label_text(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the text of the label.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.label.get_text()</span>

    <span class="s2">def </span><span class="s1">get_major_locator(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the locator of the major ticker.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.major.locator</span>

    <span class="s2">def </span><span class="s1">get_minor_locator(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the locator of the minor ticker.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.minor.locator</span>

    <span class="s2">def </span><span class="s1">get_major_formatter(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the formatter of the major ticker.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.major.formatter</span>

    <span class="s2">def </span><span class="s1">get_minor_formatter(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the formatter of the minor ticker.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.minor.formatter</span>

    <span class="s2">def </span><span class="s1">get_major_ticks(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot;Return the list of major `.Tick`\s.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">numticks = len(self.get_majorticklocs())</span>

        <span class="s2">while </span><span class="s1">len(self.majorTicks) &lt; numticks:</span>
            <span class="s4"># Update the new tick label properties from the old.</span>
            <span class="s1">tick = self._get_tick(major=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.majorTicks.append(tick)</span>
            <span class="s1">self._copy_tick_props(self.majorTicks[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tick)</span>

        <span class="s2">return </span><span class="s1">self.majorTicks[:numticks]</span>

    <span class="s2">def </span><span class="s1">get_minor_ticks(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot;Return the list of minor `.Tick`\s.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">numticks </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">numticks = len(self.get_minorticklocs())</span>

        <span class="s2">while </span><span class="s1">len(self.minorTicks) &lt; numticks:</span>
            <span class="s4"># Update the new tick label properties from the old.</span>
            <span class="s1">tick = self._get_tick(major=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self.minorTicks.append(tick)</span>
            <span class="s1">self._copy_tick_props(self.minorTicks[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tick)</span>

        <span class="s2">return </span><span class="s1">self.minorTicks[:numticks]</span>

    <span class="s2">def </span><span class="s1">grid(self</span><span class="s2">, </span><span class="s1">visible=</span><span class="s2">None, </span><span class="s1">which=</span><span class="s5">'major'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Configure the grid lines. 
 
        Parameters 
        ---------- 
        visible : bool or None 
            Whether to show the grid lines.  If any *kwargs* are supplied, it 
            is assumed you want the grid on and *visible* will be set to True. 
 
            If *visible* is *None* and there are no *kwargs*, this toggles the 
            visibility of the lines. 
 
        which : {'major', 'minor', 'both'} 
            The grid lines to apply the changes on. 
 
        **kwargs : `.Line2D` properties 
            Define the line properties of the grid, e.g.:: 
 
                grid(color='r', linestyle='-', linewidth=2) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s2">if </span><span class="s1">visible </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">visible = </span><span class="s2">True</span>
            <span class="s2">elif not </span><span class="s1">visible:  </span><span class="s4"># something false-like but not None</span>
                <span class="s1">_api.warn_external(</span><span class="s5">'First parameter to grid() is false, '</span>
                                   <span class="s5">'but line properties are supplied. The '</span>
                                   <span class="s5">'grid will be enabled.'</span><span class="s1">)</span>
                <span class="s1">visible = </span><span class="s2">True</span>
        <span class="s1">which = which.lower()</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">which=which)</span>
        <span class="s1">gridkw = {</span><span class="s5">f'grid_</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">'</span><span class="s1">: value </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">kwargs.items()}</span>
        <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'minor'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
            <span class="s1">gridkw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span><span class="s2">not </span><span class="s1">self._minor_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">]</span>
                                <span class="s2">if </span><span class="s1">visible </span><span class="s2">is None else </span><span class="s1">visible)</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'minor'</span><span class="s2">, </span><span class="s1">**gridkw)</span>
        <span class="s2">if </span><span class="s1">which </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'major'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s1">]:</span>
            <span class="s1">gridkw[</span><span class="s5">'gridOn'</span><span class="s1">] = (</span><span class="s2">not </span><span class="s1">self._major_tick_kw[</span><span class="s5">'gridOn'</span><span class="s1">]</span>
                                <span class="s2">if </span><span class="s1">visible </span><span class="s2">is None else </span><span class="s1">visible)</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'major'</span><span class="s2">, </span><span class="s1">**gridkw)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">update_units(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot; 
        Introspect *data* for units converter and update the 
        ``axis.converter`` instance if necessary. Return *True* 
        if *data* is registered for unit conversion. 
        &quot;&quot;&quot;</span>
        <span class="s1">converter = munits.registry.get_converter(data)</span>
        <span class="s2">if </span><span class="s1">converter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return False</span>

        <span class="s1">neednew = self.converter != converter</span>
        <span class="s1">self.converter = converter</span>
        <span class="s1">default = self.converter.default_units(data</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">if </span><span class="s1">default </span><span class="s2">is not None and </span><span class="s1">self.units </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.set_units(default)</span>

        <span class="s2">elif </span><span class="s1">neednew:</span>
            <span class="s1">self._update_axisinfo()</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_update_axisinfo(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check the axis converter for the stored units to see if the 
        axis info needs to be updated. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.converter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">info = self.converter.axisinfo(self.units</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s2">if </span><span class="s1">info </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">info.majloc </span><span class="s2">is not None and </span><span class="s1">\</span>
           <span class="s1">self.major.locator != info.majloc </span><span class="s2">and </span><span class="s1">self.isDefault_majloc:</span>
            <span class="s1">self.set_major_locator(info.majloc)</span>
            <span class="s1">self.isDefault_majloc = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">info.minloc </span><span class="s2">is not None and </span><span class="s1">\</span>
           <span class="s1">self.minor.locator != info.minloc </span><span class="s2">and </span><span class="s1">self.isDefault_minloc:</span>
            <span class="s1">self.set_minor_locator(info.minloc)</span>
            <span class="s1">self.isDefault_minloc = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">info.majfmt </span><span class="s2">is not None and </span><span class="s1">\</span>
           <span class="s1">self.major.formatter != info.majfmt </span><span class="s2">and </span><span class="s1">self.isDefault_majfmt:</span>
            <span class="s1">self.set_major_formatter(info.majfmt)</span>
            <span class="s1">self.isDefault_majfmt = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">info.minfmt </span><span class="s2">is not None and </span><span class="s1">\</span>
           <span class="s1">self.minor.formatter != info.minfmt </span><span class="s2">and </span><span class="s1">self.isDefault_minfmt:</span>
            <span class="s1">self.set_minor_formatter(info.minfmt)</span>
            <span class="s1">self.isDefault_minfmt = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">info.label </span><span class="s2">is not None and </span><span class="s1">self.isDefault_label:</span>
            <span class="s1">self.set_label_text(info.label)</span>
            <span class="s1">self.isDefault_label = </span><span class="s2">True</span>

        <span class="s1">self.set_default_intervals()</span>

    <span class="s2">def </span><span class="s1">have_units(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return `True` if units or a converter have been set. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.converter </span><span class="s2">is not None or </span><span class="s1">self.units </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">_have_units_and_converter(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return `True` if units and a converter have been set. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.converter </span><span class="s2">is not None and </span><span class="s1">self.units </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">convert_units(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s4"># If x is natively supported by Matplotlib, doesn't need converting</span>
        <span class="s2">if </span><span class="s1">munits._is_natively_supported(x):</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s2">if </span><span class="s1">self.converter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.converter = munits.registry.get_converter(x)</span>

        <span class="s2">if </span><span class="s1">self.converter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">ret = self.converter.convert(x</span><span class="s2">, </span><span class="s1">self.units</span><span class="s2">, </span><span class="s1">self)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">munits.ConversionError(</span><span class="s5">'Failed to convert value(s) to axis '</span>
                                         <span class="s5">f'units: </span><span class="s2">{</span><span class="s1">x</span><span class="s2">!r}</span><span class="s5">'</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">set_units(self</span><span class="s2">, </span><span class="s1">u):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the units for axis. 
 
        Parameters 
        ---------- 
        u : units tag 
 
        Notes 
        ----- 
        The units of any shared axis will also be updated. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">u == self.units:</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self.axes._axis_map.items():</span>
            <span class="s2">if </span><span class="s1">self </span><span class="s2">is </span><span class="s1">axis:</span>
                <span class="s1">shared = [</span>
                    <span class="s1">getattr(ax</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">axis&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">ax</span>
                    <span class="s2">in </span><span class="s1">self.axes._shared_axes[name].get_siblings(self.axes)]</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">shared = [self]</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">shared:</span>
            <span class="s1">axis.units = u</span>
            <span class="s1">axis._update_axisinfo()</span>
            <span class="s1">axis.callbacks.process(</span><span class="s5">'units'</span><span class="s1">)</span>
            <span class="s1">axis.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_units(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the units for axis.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.units</span>

    <span class="s2">def </span><span class="s1">set_label_text(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">fontdict=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the text value of the axis label. 
 
        Parameters 
        ---------- 
        label : str 
            Text string. 
        fontdict : dict 
            Text properties. 
        **kwargs 
            Merged into fontdict. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.isDefault_label = </span><span class="s2">False</span>
        <span class="s1">self.label.set_text(label)</span>
        <span class="s2">if </span><span class="s1">fontdict </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.label.update(fontdict)</span>
        <span class="s1">self.label.update(kwargs)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">self.label</span>

    <span class="s2">def </span><span class="s1">set_major_formatter(self</span><span class="s2">, </span><span class="s1">formatter):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the formatter of the major ticker. 
 
        In addition to a `~matplotlib.ticker.Formatter` instance, 
        this also accepts a ``str`` or function. 
 
        For a ``str`` a `~matplotlib.ticker.StrMethodFormatter` is used. 
        The field used for the value must be labeled ``'x'`` and the field used 
        for the position must be labeled ``'pos'``. 
        See the  `~matplotlib.ticker.StrMethodFormatter` documentation for 
        more information. 
 
        For a function, a `~matplotlib.ticker.FuncFormatter` is used. 
        The function must take two inputs (a tick value ``x`` and a 
        position ``pos``), and return a string containing the corresponding 
        tick label. 
        See the  `~matplotlib.ticker.FuncFormatter` documentation for 
        more information. 
 
        Parameters 
        ---------- 
        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_formatter(formatter</span><span class="s2">, </span><span class="s1">self.major)</span>

    <span class="s2">def </span><span class="s1">set_minor_formatter(self</span><span class="s2">, </span><span class="s1">formatter):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the formatter of the minor ticker. 
 
        In addition to a `~matplotlib.ticker.Formatter` instance, 
        this also accepts a ``str`` or function. 
        See `.Axis.set_major_formatter` for more information. 
 
        Parameters 
        ---------- 
        formatter : `~matplotlib.ticker.Formatter`, ``str``, or function 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_formatter(formatter</span><span class="s2">, </span><span class="s1">self.minor)</span>

    <span class="s2">def </span><span class="s1">_set_formatter(self</span><span class="s2">, </span><span class="s1">formatter</span><span class="s2">, </span><span class="s1">level):</span>
        <span class="s2">if </span><span class="s1">isinstance(formatter</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">formatter = mticker.StrMethodFormatter(formatter)</span>
        <span class="s4"># Don't allow any other TickHelper to avoid easy-to-make errors,</span>
        <span class="s4"># like using a Locator instead of a Formatter.</span>
        <span class="s2">elif </span><span class="s1">(callable(formatter) </span><span class="s2">and</span>
              <span class="s2">not </span><span class="s1">isinstance(formatter</span><span class="s2">, </span><span class="s1">mticker.TickHelper)):</span>
            <span class="s1">formatter = mticker.FuncFormatter(formatter)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_api.check_isinstance(mticker.Formatter</span><span class="s2">, </span><span class="s1">formatter=formatter)</span>

        <span class="s2">if </span><span class="s1">(isinstance(formatter</span><span class="s2">, </span><span class="s1">mticker.FixedFormatter)</span>
                <span class="s2">and </span><span class="s1">len(formatter.seq) &gt; </span><span class="s3">0</span>
                <span class="s2">and not </span><span class="s1">isinstance(level.locator</span><span class="s2">, </span><span class="s1">mticker.FixedLocator)):</span>
            <span class="s1">_api.warn_external(</span><span class="s5">'FixedFormatter should only be used together '</span>
                               <span class="s5">'with FixedLocator'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">level == self.major:</span>
            <span class="s1">self.isDefault_majfmt = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.isDefault_minfmt = </span><span class="s2">False</span>

        <span class="s1">level.formatter = formatter</span>
        <span class="s1">formatter.set_axis(self)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_major_locator(self</span><span class="s2">, </span><span class="s1">locator):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the locator of the major ticker. 
 
        Parameters 
        ---------- 
        locator : `~matplotlib.ticker.Locator` 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mticker.Locator</span><span class="s2">, </span><span class="s1">locator=locator)</span>
        <span class="s1">self.isDefault_majloc = </span><span class="s2">False</span>
        <span class="s1">self.major.locator = locator</span>
        <span class="s2">if </span><span class="s1">self.major.formatter:</span>
            <span class="s1">self.major.formatter._set_locator(locator)</span>
        <span class="s1">locator.set_axis(self)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_minor_locator(self</span><span class="s2">, </span><span class="s1">locator):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the locator of the minor ticker. 
 
        Parameters 
        ---------- 
        locator : `~matplotlib.ticker.Locator` 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(mticker.Locator</span><span class="s2">, </span><span class="s1">locator=locator)</span>
        <span class="s1">self.isDefault_minloc = </span><span class="s2">False</span>
        <span class="s1">self.minor.locator = locator</span>
        <span class="s2">if </span><span class="s1">self.minor.formatter:</span>
            <span class="s1">self.minor.formatter._set_locator(locator)</span>
        <span class="s1">locator.set_axis(self)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_pickradius(self</span><span class="s2">, </span><span class="s1">pickradius):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the depth of the axis used by the picker. 
 
        Parameters 
        ---------- 
        pickradius : float 
            The acceptance radius for containment tests. 
            See also `.Axis.contains`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(pickradius</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">or </span><span class="s1">pickradius &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;pick radius should be a distance&quot;</span><span class="s1">)</span>
        <span class="s1">self._pickradius = pickradius</span>

    <span class="s1">pickradius = property(</span>
        <span class="s1">get_pickradius</span><span class="s2">, </span><span class="s1">set_pickradius</span><span class="s2">, </span><span class="s1">doc=</span><span class="s5">&quot;The acceptance radius for &quot;</span>
        <span class="s5">&quot;containment tests. See also `.Axis.contains`.&quot;</span><span class="s1">)</span>

    <span class="s4"># Helper for set_ticklabels. Defining it here makes it picklable.</span>
    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_format_with_dict(tickd</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">pos):</span>
        <span class="s2">return </span><span class="s1">tickd.get(x</span><span class="s2">, </span><span class="s5">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">@_api.rename_parameter(</span><span class="s5">&quot;3.7&quot;</span><span class="s2">, </span><span class="s5">&quot;ticklabels&quot;</span><span class="s2">, </span><span class="s5">&quot;labels&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_ticklabels(self</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">fontdict=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">r&quot;&quot;&quot; 
        [*Discouraged*] Set this Axis' tick labels with list of string labels. 
 
        .. admonition:: Discouraged 
 
            The use of this method is discouraged, because of the dependency on 
            tick positions. In most cases, you'll want to use 
            ``Axes.set_[x/y/z]ticks(positions, labels)`` or ``Axis.set_ticks`` 
            instead. 
 
            If you are using this method, you should always fix the tick 
            positions before, e.g. by using `.Axis.set_ticks` or by explicitly 
            setting a `~.ticker.FixedLocator`. Otherwise, ticks are free to 
            move and the labels may end up in unexpected positions. 
 
        Parameters 
        ---------- 
        labels : sequence of str or of `.Text`\s 
            Texts for labeling each tick location in the sequence set by 
            `.Axis.set_ticks`; the number of labels must match the number of 
            locations. 
 
        minor : bool 
            If True, set minor ticks instead of major ticks. 
 
        fontdict : dict, optional 
            A dictionary controlling the appearance of the ticklabels. 
            The default *fontdict* is:: 
 
               {'fontsize': rcParams['axes.titlesize'], 
                'fontweight': rcParams['axes.titleweight'], 
                'verticalalignment': 'baseline', 
                'horizontalalignment': loc} 
 
        **kwargs 
            Text properties. 
 
        Returns 
        ------- 
        list of `.Text`\s 
            For each tick, includes ``tick.label1`` if it is visible, then 
            ``tick.label2`` if it is visible, in that order. 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">labels = [t.get_text() </span><span class="s2">if </span><span class="s1">hasattr(t</span><span class="s2">, </span><span class="s5">'get_text'</span><span class="s1">) </span><span class="s2">else </span><span class="s1">t</span>
                      <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">labels]</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">labels</span><span class="s2">:</span><span class="s5">=</span><span class="s2">} </span><span class="s5">must be a sequence&quot;</span><span class="s1">) </span><span class="s2">from None</span>
        <span class="s1">locator = (self.get_minor_locator() </span><span class="s2">if </span><span class="s1">minor</span>
                   <span class="s2">else </span><span class="s1">self.get_major_locator())</span>
        <span class="s2">if </span><span class="s1">isinstance(locator</span><span class="s2">, </span><span class="s1">mticker.FixedLocator):</span>
            <span class="s4"># Passing [] as a list of labels is often used as a way to</span>
            <span class="s4"># remove all tick labels, so only error for &gt; 0 labels</span>
            <span class="s2">if </span><span class="s1">len(locator.locs) != len(labels) </span><span class="s2">and </span><span class="s1">len(labels) != </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;The number of FixedLocator locations&quot;</span>
                    <span class="s5">f&quot; (</span><span class="s2">{</span><span class="s1">len(locator.locs)</span><span class="s2">}</span><span class="s5">), usually from a call to&quot;</span>
                    <span class="s5">&quot; set_ticks, does not match&quot;</span>
                    <span class="s5">f&quot; the number of labels (</span><span class="s2">{</span><span class="s1">len(labels)</span><span class="s2">}</span><span class="s5">).&quot;</span><span class="s1">)</span>
            <span class="s1">tickd = {loc: lab </span><span class="s2">for </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">lab </span><span class="s2">in </span><span class="s1">zip(locator.locs</span><span class="s2">, </span><span class="s1">labels)}</span>
            <span class="s1">func = functools.partial(self._format_with_dict</span><span class="s2">, </span><span class="s1">tickd)</span>
            <span class="s1">formatter = mticker.FuncFormatter(func)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">formatter = mticker.FixedFormatter(labels)</span>

        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s1">self.set_minor_formatter(formatter)</span>
            <span class="s1">locs = self.get_minorticklocs()</span>
            <span class="s1">ticks = self.get_minor_ticks(len(locs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set_major_formatter(formatter)</span>
            <span class="s1">locs = self.get_majorticklocs()</span>
            <span class="s1">ticks = self.get_major_ticks(len(locs))</span>

        <span class="s1">ret = []</span>
        <span class="s2">if </span><span class="s1">fontdict </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs.update(fontdict)</span>
        <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">(loc</span><span class="s2">, </span><span class="s1">tick) </span><span class="s2">in </span><span class="s1">enumerate(zip(locs</span><span class="s2">, </span><span class="s1">ticks)):</span>
            <span class="s1">tick.update_position(loc)</span>
            <span class="s1">tick_label = formatter(loc</span><span class="s2">, </span><span class="s1">pos)</span>
            <span class="s4"># deal with label1</span>
            <span class="s1">tick.label1.set_text(tick_label)</span>
            <span class="s1">tick.label1._internal_update(kwargs)</span>
            <span class="s4"># deal with label2</span>
            <span class="s1">tick.label2.set_text(tick_label)</span>
            <span class="s1">tick.label2._internal_update(kwargs)</span>
            <span class="s4"># only return visible tick labels</span>
            <span class="s2">if </span><span class="s1">tick.label1.get_visible():</span>
                <span class="s1">ret.append(tick.label1)</span>
            <span class="s2">if </span><span class="s1">tick.label2.get_visible():</span>
                <span class="s1">ret.append(tick.label2)</span>

        <span class="s1">self.stale = </span><span class="s2">True</span>
        <span class="s2">return </span><span class="s1">ret</span>

    <span class="s2">def </span><span class="s1">_set_tick_locations(self</span><span class="s2">, </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s4"># see docstring of set_ticks</span>

        <span class="s4"># XXX if the user changes units, the information will be lost here</span>
        <span class="s1">ticks = self.convert_units(ticks)</span>
        <span class="s1">locator = mticker.FixedLocator(ticks)  </span><span class="s4"># validate ticks early.</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self.axes._axis_map.items():</span>
            <span class="s2">if </span><span class="s1">self </span><span class="s2">is </span><span class="s1">axis:</span>
                <span class="s1">shared = [</span>
                    <span class="s1">getattr(ax</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s5">axis&quot;</span><span class="s1">)</span>
                    <span class="s2">for </span><span class="s1">ax</span>
                    <span class="s2">in </span><span class="s1">self.axes._shared_axes[name].get_siblings(self.axes)]</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">shared = [self]</span>
        <span class="s2">if </span><span class="s1">len(ticks):</span>
            <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">shared:</span>
                <span class="s4"># set_view_interval maintains any preexisting inversion.</span>
                <span class="s1">axis.set_view_interval(min(ticks)</span><span class="s2">, </span><span class="s1">max(ticks))</span>
        <span class="s1">self.axes.stale = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">minor:</span>
            <span class="s1">self.set_minor_locator(locator)</span>
            <span class="s2">return </span><span class="s1">self.get_minor_ticks(len(ticks))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set_major_locator(locator)</span>
            <span class="s2">return </span><span class="s1">self.get_major_ticks(len(ticks))</span>

    <span class="s2">def </span><span class="s1">set_ticks(self</span><span class="s2">, </span><span class="s1">ticks</span><span class="s2">, </span><span class="s1">labels=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">minor=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set this Axis' tick locations and optionally labels. 
 
        If necessary, the view limits of the Axis are expanded so that all 
        given ticks are visible. 
 
        Parameters 
        ---------- 
        ticks : list of floats 
            List of tick locations.  The axis `.Locator` is replaced by a 
            `~.ticker.FixedLocator`. 
 
            Some tick formatters will not label arbitrary tick positions; 
            e.g. log formatters only label decade ticks by default. In 
            such a case you can set a formatter explicitly on the axis 
            using `.Axis.set_major_formatter` or provide formatted 
            *labels* yourself. 
        labels : list of str, optional 
            List of tick labels. If not set, the labels are generated with 
            the axis tick `.Formatter`. 
        minor : bool, default: False 
            If ``False``, set the major ticks; if ``True``, the minor ticks. 
        **kwargs 
            `.Text` properties for the labels. These take effect only if you 
            pass *labels*. In other cases, please use `~.Axes.tick_params`. 
 
        Notes 
        ----- 
        The mandatory expansion of the view limits is an intentional design 
        choice to prevent the surprise of a non-visible tick. If you need 
        other limits, you should set the limits explicitly after setting the 
        ticks. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None and </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'labels argument cannot be None when '</span>
                             <span class="s5">'kwargs are passed'</span><span class="s1">)</span>
        <span class="s1">result = self._set_tick_locations(ticks</span><span class="s2">, </span><span class="s1">minor=minor)</span>
        <span class="s2">if </span><span class="s1">labels </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_ticklabels(labels</span><span class="s2">, </span><span class="s1">minor=minor</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_get_tick_boxes_siblings(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the bounding boxes for this `.axis` and its siblings 
        as set by `.Figure.align_xlabels` or  `.Figure.align_ylabels`. 
 
        By default, it just gets bboxes for *self*. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Get the Grouper keeping track of x or y label groups for this figure.</span>
        <span class="s1">axis_names = [</span>
            <span class="s1">name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">self.axes._axis_map.items()</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.figure._align_label_groups </span><span class="s2">and </span><span class="s1">axis </span><span class="s2">is </span><span class="s1">self]</span>
        <span class="s2">if </span><span class="s1">len(axis_names) != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s1">axis_name</span><span class="s2">, </span><span class="s1">= axis_names</span>
        <span class="s1">grouper = self.figure._align_label_groups[axis_name]</span>
        <span class="s1">bboxes = []</span>
        <span class="s1">bboxes2 = []</span>
        <span class="s4"># If we want to align labels from other Axes:</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">grouper.get_siblings(self.axes):</span>
            <span class="s1">axis = getattr(ax</span><span class="s2">, </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">axis_name</span><span class="s2">}</span><span class="s5">axis&quot;</span><span class="s1">)</span>
            <span class="s1">ticks_to_draw = axis._update_ticks()</span>
            <span class="s1">tlb</span><span class="s2">, </span><span class="s1">tlb2 = axis._get_ticklabel_bboxes(ticks_to_draw</span><span class="s2">, </span><span class="s1">renderer)</span>
            <span class="s1">bboxes.extend(tlb)</span>
            <span class="s1">bboxes2.extend(tlb2)</span>
        <span class="s2">return </span><span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2</span>

    <span class="s2">def </span><span class="s1">_update_label_position(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the label position based on the bounding box enclosing 
        all the ticklabels and axis spine. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_update_offset_text_position(self</span><span class="s2">, </span><span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the offset text position based on the sequence of bounding 
        boxes of all the ticklabels. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">axis_date(self</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set up axis ticks and labels to treat data along this Axis as dates. 
 
        Parameters 
        ---------- 
        tz : str or `datetime.tzinfo`, default: :rc:`timezone` 
            The timezone used to create date labels. 
        &quot;&quot;&quot;</span>
        <span class="s4"># By providing a sample datetime instance with the desired timezone,</span>
        <span class="s4"># the registered converter can be selected, and the &quot;units&quot; attribute,</span>
        <span class="s4"># which is the timezone, can be set.</span>
        <span class="s2">if </span><span class="s1">isinstance(tz</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">import </span><span class="s1">dateutil.tz</span>
            <span class="s1">tz = dateutil.tz.gettz(tz)</span>
        <span class="s1">self.update_units(datetime.datetime(</span><span class="s3">2009</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">tz))</span>

    <span class="s2">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the estimated number of ticks that can fit on the axis.&quot;&quot;&quot;</span>
        <span class="s4"># Must be overridden in the subclass</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">_get_ticks_position(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper for `XAxis.get_ticks_position` and `YAxis.get_ticks_position`. 
 
        Check the visibility of tick1line, label1, tick2line, and label2 on 
        the first major and the first minor ticks, and return 
 
        - 1 if only tick1line and label1 are visible (which corresponds to 
          &quot;bottom&quot; for the x-axis and &quot;left&quot; for the y-axis); 
        - 2 if only tick2line and label2 are visible (which corresponds to 
          &quot;top&quot; for the x-axis and &quot;right&quot; for the y-axis); 
        - &quot;default&quot; if only tick1line, tick2line and label1 are visible; 
        - &quot;unknown&quot; otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">major = self.majorTicks[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">minor = self.minorTicks[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">all(tick.tick1line.get_visible()</span>
               <span class="s2">and not </span><span class="s1">tick.tick2line.get_visible()</span>
               <span class="s2">and </span><span class="s1">tick.label1.get_visible()</span>
               <span class="s2">and not </span><span class="s1">tick.label2.get_visible()</span>
               <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">[major</span><span class="s2">, </span><span class="s1">minor]):</span>
            <span class="s2">return </span><span class="s3">1</span>
        <span class="s2">elif </span><span class="s1">all(tick.tick2line.get_visible()</span>
                 <span class="s2">and not </span><span class="s1">tick.tick1line.get_visible()</span>
                 <span class="s2">and </span><span class="s1">tick.label2.get_visible()</span>
                 <span class="s2">and not </span><span class="s1">tick.label1.get_visible()</span>
                 <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">[major</span><span class="s2">, </span><span class="s1">minor]):</span>
            <span class="s2">return </span><span class="s3">2</span>
        <span class="s2">elif </span><span class="s1">all(tick.tick1line.get_visible()</span>
                 <span class="s2">and </span><span class="s1">tick.tick2line.get_visible()</span>
                 <span class="s2">and </span><span class="s1">tick.label1.get_visible()</span>
                 <span class="s2">and not </span><span class="s1">tick.label2.get_visible()</span>
                 <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">[major</span><span class="s2">, </span><span class="s1">minor]):</span>
            <span class="s2">return </span><span class="s5">&quot;default&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">&quot;unknown&quot;</span>

    <span class="s2">def </span><span class="s1">get_label_position(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the label position (top or bottom) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.label_position</span>

    <span class="s2">def </span><span class="s1">set_label_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the label position (top or bottom) 
 
        Parameters 
        ---------- 
        position : {'top', 'bottom'} 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>

    <span class="s2">def </span><span class="s1">get_minpos(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError()</span>


<span class="s2">def </span><span class="s1">_make_getset_interval(method_name</span><span class="s2">, </span><span class="s1">lim_name</span><span class="s2">, </span><span class="s1">attr_name):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper to generate ``get_{data,view}_interval`` and 
    ``set_{data,view}_interval`` implementations. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">getter(self):</span>
        <span class="s4"># docstring inherited.</span>
        <span class="s2">return </span><span class="s1">getattr(getattr(self.axes</span><span class="s2">, </span><span class="s1">lim_name)</span><span class="s2">, </span><span class="s1">attr_name)</span>

    <span class="s2">def </span><span class="s1">setter(self</span><span class="s2">, </span><span class="s1">vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">ignore=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s4"># docstring inherited.</span>
        <span class="s2">if </span><span class="s1">ignore:</span>
            <span class="s1">setattr(getattr(self.axes</span><span class="s2">, </span><span class="s1">lim_name)</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">(vmin</span><span class="s2">, </span><span class="s1">vmax))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">oldmin</span><span class="s2">, </span><span class="s1">oldmax = getter(self)</span>
            <span class="s2">if </span><span class="s1">oldmin &lt; oldmax:</span>
                <span class="s1">setter(self</span><span class="s2">, </span><span class="s1">min(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">oldmin)</span><span class="s2">, </span><span class="s1">max(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">oldmax)</span><span class="s2">,</span>
                       <span class="s1">ignore=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">setter(self</span><span class="s2">, </span><span class="s1">max(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">oldmin)</span><span class="s2">, </span><span class="s1">min(vmin</span><span class="s2">, </span><span class="s1">vmax</span><span class="s2">, </span><span class="s1">oldmax)</span><span class="s2">,</span>
                       <span class="s1">ignore=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">getter.__name__ = </span><span class="s5">f&quot;get_</span><span class="s2">{</span><span class="s1">method_name</span><span class="s2">}</span><span class="s5">_interval&quot;</span>
    <span class="s1">setter.__name__ = </span><span class="s5">f&quot;set_</span><span class="s2">{</span><span class="s1">method_name</span><span class="s2">}</span><span class="s5">_interval&quot;</span>

    <span class="s2">return </span><span class="s1">getter</span><span class="s2">, </span><span class="s1">setter</span>


<span class="s2">class </span><span class="s1">XAxis(Axis):</span>
    <span class="s1">__name__ = </span><span class="s5">'xaxis'</span>
    <span class="s1">axis_name = </span><span class="s5">'x'  </span><span class="s4">#: Read-only name identifying the axis.</span>
    <span class="s1">_tick_class = XTick</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._init()</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the label and offsetText instance values and 
        `label_position` / `offset_text_position`. 
        &quot;&quot;&quot;</span>
        <span class="s4"># x in axes coords, y in display coords (to be updated at draw time by</span>
        <span class="s4"># _update_label_positions and _update_offset_text_position).</span>
        <span class="s1">self.label.set(</span>
            <span class="s1">x=</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">verticalalignment=</span><span class="s5">'top'</span><span class="s2">, </span><span class="s1">horizontalalignment=</span><span class="s5">'center'</span><span class="s2">,</span>
            <span class="s1">transform=mtransforms.blended_transform_factory(</span>
                <span class="s1">self.axes.transAxes</span><span class="s2">, </span><span class="s1">mtransforms.IdentityTransform())</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.label_position = </span><span class="s5">'bottom'</span>

        <span class="s1">self.offsetText.set(</span>
            <span class="s1">x=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s2">,</span>
            <span class="s1">verticalalignment=</span><span class="s5">'top'</span><span class="s2">, </span><span class="s1">horizontalalignment=</span><span class="s5">'right'</span><span class="s2">,</span>
            <span class="s1">transform=mtransforms.blended_transform_factory(</span>
                <span class="s1">self.axes.transAxes</span><span class="s2">, </span><span class="s1">mtransforms.IdentityTransform())</span><span class="s2">,</span>
            <span class="s1">fontsize=mpl.rcParams[</span><span class="s5">'xtick.labelsize'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">color=mpl.rcParams[</span><span class="s5">'xtick.color'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.offset_text_position = </span><span class="s5">'bottom'</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot;Test whether the mouse event occurred in the x-axis.&quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">trans = self.axes.transAxes.inverted()</span>
            <span class="s1">xaxes</span><span class="s2">, </span><span class="s1">yaxes = trans.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>
        <span class="s1">(l</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">(r</span><span class="s2">, </span><span class="s1">t) = self.axes.transAxes.transform([(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s1">inaxis = </span><span class="s3">0 </span><span class="s1">&lt;= xaxes &lt;= </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">b - self._pickradius &lt; y &lt; b </span><span class="s2">or</span>
            <span class="s1">t &lt; y &lt; t + self._pickradius)</span>
        <span class="s2">return </span><span class="s1">inaxis</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">set_label_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the label position (top or bottom) 
 
        Parameters 
        ---------- 
        position : {'top', 'bottom'} 
        &quot;&quot;&quot;</span>
        <span class="s1">self.label.set_verticalalignment(_api.check_getitem({</span>
            <span class="s5">'top'</span><span class="s1">: </span><span class="s5">'baseline'</span><span class="s2">, </span><span class="s5">'bottom'</span><span class="s1">: </span><span class="s5">'top'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">position=position))</span>
        <span class="s1">self.label_position = position</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_update_label_position(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the label position based on the bounding box enclosing 
        all the ticklabels and axis spine 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._autolabelpos:</span>
            <span class="s2">return</span>

        <span class="s4"># get bounding boxes for this axis and any siblings</span>
        <span class="s4"># that have been set by `fig.align_xlabels()`</span>
        <span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.label.get_position()</span>
        <span class="s2">if </span><span class="s1">self.label_position == </span><span class="s5">'bottom'</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spine = self.axes.spines[</span><span class="s5">'bottom'</span><span class="s1">]</span>
                <span class="s1">spinebbox = spine.get_window_extent()</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s4"># use Axes if spine doesn't exist</span>
                <span class="s1">spinebbox = self.axes.bbox</span>
            <span class="s1">bbox = mtransforms.Bbox.union(bboxes + [spinebbox])</span>
            <span class="s1">bottom = bbox.y0</span>

            <span class="s1">self.label.set_position(</span>
                <span class="s1">(x</span><span class="s2">, </span><span class="s1">bottom - self.labelpad * self.figure.dpi / </span><span class="s3">72</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spine = self.axes.spines[</span><span class="s5">'top'</span><span class="s1">]</span>
                <span class="s1">spinebbox = spine.get_window_extent()</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s4"># use Axes if spine doesn't exist</span>
                <span class="s1">spinebbox = self.axes.bbox</span>
            <span class="s1">bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])</span>
            <span class="s1">top = bbox.y1</span>

            <span class="s1">self.label.set_position(</span>
                <span class="s1">(x</span><span class="s2">, </span><span class="s1">top + self.labelpad * self.figure.dpi / </span><span class="s3">72</span><span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_update_offset_text_position(self</span><span class="s2">, </span><span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the offset_text position based on the sequence of bounding 
        boxes of all the ticklabels 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.offsetText.get_position()</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">'_tick_position'</span><span class="s1">):</span>
            <span class="s1">self._tick_position = </span><span class="s5">'bottom'</span>
        <span class="s2">if </span><span class="s1">self._tick_position == </span><span class="s5">'bottom'</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">len(bboxes):</span>
                <span class="s1">bottom = self.axes.bbox.ymin</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bbox = mtransforms.Bbox.union(bboxes)</span>
                <span class="s1">bottom = bbox.y0</span>
            <span class="s1">y = bottom - self.OFFSETTEXTPAD * self.figure.dpi / </span><span class="s3">72</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">len(bboxes2):</span>
                <span class="s1">top = self.axes.bbox.ymax</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bbox = mtransforms.Bbox.union(bboxes2)</span>
                <span class="s1">top = bbox.y1</span>
            <span class="s1">y = top + self.OFFSETTEXTPAD * self.figure.dpi / </span><span class="s3">72</span>
        <span class="s1">self.offsetText.set_position((x</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s1">@_api.deprecated(</span><span class="s5">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_text_heights(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return how much space should be reserved for text above and below the 
        Axes, as a pair of floats. 
        &quot;&quot;&quot;</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">bbox2 = self.get_ticklabel_extents(renderer)</span>
        <span class="s4"># MGDTODO: Need a better way to get the pad</span>
        <span class="s1">pad_pixels = self.majorTicks[</span><span class="s3">0</span><span class="s1">].get_pad_pixels()</span>

        <span class="s1">above = </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">bbox2.height:</span>
            <span class="s1">above += bbox2.height + pad_pixels</span>
        <span class="s1">below = </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">bbox.height:</span>
            <span class="s1">below += bbox.height + pad_pixels</span>

        <span class="s2">if </span><span class="s1">self.get_label_position() == </span><span class="s5">'top'</span><span class="s1">:</span>
            <span class="s1">above += self.label.get_window_extent(renderer).height + pad_pixels</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">below += self.label.get_window_extent(renderer).height + pad_pixels</span>
        <span class="s2">return </span><span class="s1">above</span><span class="s2">, </span><span class="s1">below</span>

    <span class="s2">def </span><span class="s1">set_ticks_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the ticks position. 
 
        Parameters 
        ---------- 
        position : {'top', 'bottom', 'both', 'default', 'none'} 
            'both' sets the ticks to appear on both positions, but does not 
            change the tick labels.  'default' resets the tick positions to 
            the default: ticks on both positions, labels at bottom.  'none' 
            can be used if you don't want any ticks. 'none' and 'both' 
            affect only the ticks, not the labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'top'</span><span class="s2">, </span><span class="s5">'bottom'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'default'</span><span class="s2">, </span><span class="s5">'none'</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">position=position)</span>
        <span class="s2">if </span><span class="s1">position == </span><span class="s5">'top'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">top=</span><span class="s2">True, </span><span class="s1">labeltop=</span><span class="s2">True,</span>
                                 <span class="s1">bottom=</span><span class="s2">False, </span><span class="s1">labelbottom=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self._tick_position = </span><span class="s5">'top'</span>
            <span class="s1">self.offsetText.set_verticalalignment(</span><span class="s5">'bottom'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'bottom'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">top=</span><span class="s2">False, </span><span class="s1">labeltop=</span><span class="s2">False,</span>
                                 <span class="s1">bottom=</span><span class="s2">True, </span><span class="s1">labelbottom=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self._tick_position = </span><span class="s5">'bottom'</span>
            <span class="s1">self.offsetText.set_verticalalignment(</span><span class="s5">'top'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'both'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">top=</span><span class="s2">True,</span>
                                 <span class="s1">bottom=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'none'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">top=</span><span class="s2">False,</span>
                                 <span class="s1">bottom=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'default'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">top=</span><span class="s2">True, </span><span class="s1">labeltop=</span><span class="s2">False,</span>
                                 <span class="s1">bottom=</span><span class="s2">True, </span><span class="s1">labelbottom=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self._tick_position = </span><span class="s5">'bottom'</span>
            <span class="s1">self.offsetText.set_verticalalignment(</span><span class="s5">'top'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert False, </span><span class="s5">&quot;unhandled parameter not caught by _check_in_list&quot;</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">tick_top(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move ticks and ticklabels (if present) to the top of the Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s5">'label1On' </span><span class="s2">in </span><span class="s1">self._major_tick_kw:</span>
            <span class="s1">label = (self._major_tick_kw[</span><span class="s5">'label1On'</span><span class="s1">]</span>
                     <span class="s2">or </span><span class="s1">self._major_tick_kw[</span><span class="s5">'label2On'</span><span class="s1">])</span>
        <span class="s1">self.set_ticks_position(</span><span class="s5">'top'</span><span class="s1">)</span>
        <span class="s4"># If labels were turned off before this was called, leave them off.</span>
        <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">labeltop=label)</span>

    <span class="s2">def </span><span class="s1">tick_bottom(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move ticks and ticklabels (if present) to the bottom of the Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s5">'label1On' </span><span class="s2">in </span><span class="s1">self._major_tick_kw:</span>
            <span class="s1">label = (self._major_tick_kw[</span><span class="s5">'label1On'</span><span class="s1">]</span>
                     <span class="s2">or </span><span class="s1">self._major_tick_kw[</span><span class="s5">'label2On'</span><span class="s1">])</span>
        <span class="s1">self.set_ticks_position(</span><span class="s5">'bottom'</span><span class="s1">)</span>
        <span class="s4"># If labels were turned off before this was called, leave them off.</span>
        <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">labelbottom=label)</span>

    <span class="s2">def </span><span class="s1">get_ticks_position(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ticks position (&quot;top&quot;, &quot;bottom&quot;, &quot;default&quot;, or &quot;unknown&quot;). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s3">1</span><span class="s1">: </span><span class="s5">&quot;bottom&quot;</span><span class="s2">, </span><span class="s3">2</span><span class="s1">: </span><span class="s5">&quot;top&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;default&quot;</span><span class="s1">: </span><span class="s5">&quot;default&quot;</span><span class="s2">, </span><span class="s5">&quot;unknown&quot;</span><span class="s1">: </span><span class="s5">&quot;unknown&quot;</span><span class="s1">}[</span>
                    <span class="s1">self._get_ticks_position()]</span>

    <span class="s1">get_view_interval</span><span class="s2">, </span><span class="s1">set_view_interval = _make_getset_interval(</span>
        <span class="s5">&quot;view&quot;</span><span class="s2">, </span><span class="s5">&quot;viewLim&quot;</span><span class="s2">, </span><span class="s5">&quot;intervalx&quot;</span><span class="s1">)</span>
    <span class="s1">get_data_interval</span><span class="s2">, </span><span class="s1">set_data_interval = _make_getset_interval(</span>
        <span class="s5">&quot;data&quot;</span><span class="s2">, </span><span class="s5">&quot;dataLim&quot;</span><span class="s2">, </span><span class="s5">&quot;intervalx&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_minpos(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.dataLim.minposx</span>

    <span class="s2">def </span><span class="s1">set_default_intervals(self):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># only change view if dataLim has not changed and user has</span>
        <span class="s4"># not changed the view:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">self.axes.dataLim.mutatedx() </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self.axes.viewLim.mutatedx()):</span>
            <span class="s2">if </span><span class="s1">self.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">info = self.converter.axisinfo(self.units</span><span class="s2">, </span><span class="s1">self)</span>
                <span class="s2">if </span><span class="s1">info.default_limits </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">xmin</span><span class="s2">, </span><span class="s1">xmax = self.convert_units(info.default_limits)</span>
                    <span class="s1">self.axes.viewLim.intervalx = xmin</span><span class="s2">, </span><span class="s1">xmax</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s1">ends = mtransforms.Bbox.unit().transformed(</span>
            <span class="s1">self.axes.transAxes - self.figure.dpi_scale_trans)</span>
        <span class="s1">length = ends.width * </span><span class="s3">72</span>
        <span class="s4"># There is a heuristic here that the aspect ratio of tick text</span>
        <span class="s4"># is no more than 3:1</span>
        <span class="s1">size = self._get_tick_label_size(</span><span class="s5">'x'</span><span class="s1">) * </span><span class="s3">3</span>
        <span class="s2">if </span><span class="s1">size &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">int(np.floor(length / size))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">2</span><span class="s1">**</span><span class="s3">31 </span><span class="s1">- </span><span class="s3">1</span>


<span class="s2">class </span><span class="s1">YAxis(Axis):</span>
    <span class="s1">__name__ = </span><span class="s5">'yaxis'</span>
    <span class="s1">axis_name = </span><span class="s5">'y'  </span><span class="s4">#: Read-only name identifying the axis.</span>
    <span class="s1">_tick_class = YTick</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self._init()</span>

    <span class="s2">def </span><span class="s1">_init(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the label and offsetText instance values and 
        `label_position` / `offset_text_position`. 
        &quot;&quot;&quot;</span>
        <span class="s4"># x in display coords, y in axes coords (to be updated at draw time by</span>
        <span class="s4"># _update_label_positions and _update_offset_text_position).</span>
        <span class="s1">self.label.set(</span>
            <span class="s1">x=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0.5</span><span class="s2">,</span>
            <span class="s1">verticalalignment=</span><span class="s5">'bottom'</span><span class="s2">, </span><span class="s1">horizontalalignment=</span><span class="s5">'center'</span><span class="s2">,</span>
            <span class="s1">rotation=</span><span class="s5">'vertical'</span><span class="s2">, </span><span class="s1">rotation_mode=</span><span class="s5">'anchor'</span><span class="s2">,</span>
            <span class="s1">transform=mtransforms.blended_transform_factory(</span>
                <span class="s1">mtransforms.IdentityTransform()</span><span class="s2">, </span><span class="s1">self.axes.transAxes)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.label_position = </span><span class="s5">'left'</span>
        <span class="s4"># x in axes coords, y in display coords(!).</span>
        <span class="s1">self.offsetText.set(</span>
            <span class="s1">x=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s3">0.5</span><span class="s2">,</span>
            <span class="s1">verticalalignment=</span><span class="s5">'baseline'</span><span class="s2">, </span><span class="s1">horizontalalignment=</span><span class="s5">'left'</span><span class="s2">,</span>
            <span class="s1">transform=mtransforms.blended_transform_factory(</span>
                <span class="s1">self.axes.transAxes</span><span class="s2">, </span><span class="s1">mtransforms.IdentityTransform())</span><span class="s2">,</span>
            <span class="s1">fontsize=mpl.rcParams[</span><span class="s5">'ytick.labelsize'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">color=mpl.rcParams[</span><span class="s5">'ytick.color'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.offset_text_position = </span><span class="s5">'left'</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">trans = self.axes.transAxes.inverted()</span>
            <span class="s1">xaxes</span><span class="s2">, </span><span class="s1">yaxes = trans.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>
        <span class="s1">(l</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">(r</span><span class="s2">, </span><span class="s1">t) = self.axes.transAxes.transform([(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)])</span>
        <span class="s1">inaxis = </span><span class="s3">0 </span><span class="s1">&lt;= yaxes &lt;= </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">l - self._pickradius &lt; x &lt; l </span><span class="s2">or</span>
            <span class="s1">r &lt; x &lt; r + self._pickradius)</span>
        <span class="s2">return </span><span class="s1">inaxis</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">set_label_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the label position (left or right) 
 
        Parameters 
        ---------- 
        position : {'left', 'right'} 
        &quot;&quot;&quot;</span>
        <span class="s1">self.label.set_rotation_mode(</span><span class="s5">'anchor'</span><span class="s1">)</span>
        <span class="s1">self.label.set_verticalalignment(_api.check_getitem({</span>
            <span class="s5">'left'</span><span class="s1">: </span><span class="s5">'bottom'</span><span class="s2">, </span><span class="s5">'right'</span><span class="s1">: </span><span class="s5">'top'</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s1">position=position))</span>
        <span class="s1">self.label_position = position</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_update_label_position(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the label position based on the bounding box enclosing 
        all the ticklabels and axis spine 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._autolabelpos:</span>
            <span class="s2">return</span>

        <span class="s4"># get bounding boxes for this axis and any siblings</span>
        <span class="s4"># that have been set by `fig.align_ylabels()`</span>
        <span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2 = self._get_tick_boxes_siblings(renderer=renderer)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.label.get_position()</span>
        <span class="s2">if </span><span class="s1">self.label_position == </span><span class="s5">'left'</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spine = self.axes.spines[</span><span class="s5">'left'</span><span class="s1">]</span>
                <span class="s1">spinebbox = spine.get_window_extent()</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s4"># use Axes if spine doesn't exist</span>
                <span class="s1">spinebbox = self.axes.bbox</span>
            <span class="s1">bbox = mtransforms.Bbox.union(bboxes + [spinebbox])</span>
            <span class="s1">left = bbox.x0</span>
            <span class="s1">self.label.set_position(</span>
                <span class="s1">(left - self.labelpad * self.figure.dpi / </span><span class="s3">72</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">spine = self.axes.spines[</span><span class="s5">'right'</span><span class="s1">]</span>
                <span class="s1">spinebbox = spine.get_window_extent()</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s4"># use Axes if spine doesn't exist</span>
                <span class="s1">spinebbox = self.axes.bbox</span>

            <span class="s1">bbox = mtransforms.Bbox.union(bboxes2 + [spinebbox])</span>
            <span class="s1">right = bbox.x1</span>
            <span class="s1">self.label.set_position(</span>
                <span class="s1">(right + self.labelpad * self.figure.dpi / </span><span class="s3">72</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_update_offset_text_position(self</span><span class="s2">, </span><span class="s1">bboxes</span><span class="s2">, </span><span class="s1">bboxes2):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the offset_text position based on the sequence of bounding 
        boxes of all the ticklabels 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">_ = self.offsetText.get_position()</span>
        <span class="s2">if </span><span class="s5">'outline' </span><span class="s2">in </span><span class="s1">self.axes.spines:</span>
            <span class="s4"># Special case for colorbars:</span>
            <span class="s1">bbox = self.axes.spines[</span><span class="s5">'outline'</span><span class="s1">].get_window_extent()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">bbox = self.axes.bbox</span>
        <span class="s1">top = bbox.ymax</span>
        <span class="s1">self.offsetText.set_position(</span>
            <span class="s1">(x</span><span class="s2">, </span><span class="s1">top + self.OFFSETTEXTPAD * self.figure.dpi / </span><span class="s3">72</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_offset_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        position : {'left', 'right'} 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.offsetText.get_position()</span>
        <span class="s1">x = _api.check_getitem({</span><span class="s5">'left'</span><span class="s1">: </span><span class="s3">0</span><span class="s2">, </span><span class="s5">'right'</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}</span><span class="s2">, </span><span class="s1">position=position)</span>

        <span class="s1">self.offsetText.set_ha(position)</span>
        <span class="s1">self.offsetText.set_position((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_api.deprecated(</span><span class="s5">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_text_widths(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">bbox</span><span class="s2">, </span><span class="s1">bbox2 = self.get_ticklabel_extents(renderer)</span>
        <span class="s4"># MGDTODO: Need a better way to get the pad</span>
        <span class="s1">pad_pixels = self.majorTicks[</span><span class="s3">0</span><span class="s1">].get_pad_pixels()</span>

        <span class="s1">left = </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">bbox.width:</span>
            <span class="s1">left += bbox.width + pad_pixels</span>
        <span class="s1">right = </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">bbox2.width:</span>
            <span class="s1">right += bbox2.width + pad_pixels</span>

        <span class="s2">if </span><span class="s1">self.get_label_position() == </span><span class="s5">'left'</span><span class="s1">:</span>
            <span class="s1">left += self.label.get_window_extent(renderer).width + pad_pixels</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">right += self.label.get_window_extent(renderer).width + pad_pixels</span>
        <span class="s2">return </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s2">def </span><span class="s1">set_ticks_position(self</span><span class="s2">, </span><span class="s1">position):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the ticks position. 
 
        Parameters 
        ---------- 
        position : {'left', 'right', 'both', 'default', 'none'} 
            'both' sets the ticks to appear on both positions, but does not 
            change the tick labels.  'default' resets the tick positions to 
            the default: ticks on both positions, labels at left.  'none' 
            can be used if you don't want any ticks. 'none' and 'both' 
            affect only the ticks, not the labels. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s5">'left'</span><span class="s2">, </span><span class="s5">'right'</span><span class="s2">, </span><span class="s5">'both'</span><span class="s2">, </span><span class="s5">'default'</span><span class="s2">, </span><span class="s5">'none'</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">position=position)</span>
        <span class="s2">if </span><span class="s1">position == </span><span class="s5">'right'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">right=</span><span class="s2">True, </span><span class="s1">labelright=</span><span class="s2">True,</span>
                                 <span class="s1">left=</span><span class="s2">False, </span><span class="s1">labelleft=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self.set_offset_position(position)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'left'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">right=</span><span class="s2">False, </span><span class="s1">labelright=</span><span class="s2">False,</span>
                                 <span class="s1">left=</span><span class="s2">True, </span><span class="s1">labelleft=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">self.set_offset_position(position)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'both'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">right=</span><span class="s2">True,</span>
                                 <span class="s1">left=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'none'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">right=</span><span class="s2">False,</span>
                                 <span class="s1">left=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">position == </span><span class="s5">'default'</span><span class="s1">:</span>
            <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">right=</span><span class="s2">True, </span><span class="s1">labelright=</span><span class="s2">False,</span>
                                 <span class="s1">left=</span><span class="s2">True, </span><span class="s1">labelleft=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert False, </span><span class="s5">&quot;unhandled parameter not caught by _check_in_list&quot;</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">tick_right(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move ticks and ticklabels (if present) to the right of the Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s5">'label1On' </span><span class="s2">in </span><span class="s1">self._major_tick_kw:</span>
            <span class="s1">label = (self._major_tick_kw[</span><span class="s5">'label1On'</span><span class="s1">]</span>
                     <span class="s2">or </span><span class="s1">self._major_tick_kw[</span><span class="s5">'label2On'</span><span class="s1">])</span>
        <span class="s1">self.set_ticks_position(</span><span class="s5">'right'</span><span class="s1">)</span>
        <span class="s4"># if labels were turned off before this was called</span>
        <span class="s4"># leave them off</span>
        <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">labelright=label)</span>

    <span class="s2">def </span><span class="s1">tick_left(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Move ticks and ticklabels (if present) to the left of the Axes. 
        &quot;&quot;&quot;</span>
        <span class="s1">label = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s5">'label1On' </span><span class="s2">in </span><span class="s1">self._major_tick_kw:</span>
            <span class="s1">label = (self._major_tick_kw[</span><span class="s5">'label1On'</span><span class="s1">]</span>
                     <span class="s2">or </span><span class="s1">self._major_tick_kw[</span><span class="s5">'label2On'</span><span class="s1">])</span>
        <span class="s1">self.set_ticks_position(</span><span class="s5">'left'</span><span class="s1">)</span>
        <span class="s4"># if labels were turned off before this was called</span>
        <span class="s4"># leave them off</span>
        <span class="s1">self.set_tick_params(which=</span><span class="s5">'both'</span><span class="s2">, </span><span class="s1">labelleft=label)</span>

    <span class="s2">def </span><span class="s1">get_ticks_position(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the ticks position (&quot;left&quot;, &quot;right&quot;, &quot;default&quot;, or &quot;unknown&quot;). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s3">1</span><span class="s1">: </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s3">2</span><span class="s1">: </span><span class="s5">&quot;right&quot;</span><span class="s2">,</span>
                <span class="s5">&quot;default&quot;</span><span class="s1">: </span><span class="s5">&quot;default&quot;</span><span class="s2">, </span><span class="s5">&quot;unknown&quot;</span><span class="s1">: </span><span class="s5">&quot;unknown&quot;</span><span class="s1">}[</span>
                    <span class="s1">self._get_ticks_position()]</span>

    <span class="s1">get_view_interval</span><span class="s2">, </span><span class="s1">set_view_interval = _make_getset_interval(</span>
        <span class="s5">&quot;view&quot;</span><span class="s2">, </span><span class="s5">&quot;viewLim&quot;</span><span class="s2">, </span><span class="s5">&quot;intervaly&quot;</span><span class="s1">)</span>
    <span class="s1">get_data_interval</span><span class="s2">, </span><span class="s1">set_data_interval = _make_getset_interval(</span>
        <span class="s5">&quot;data&quot;</span><span class="s2">, </span><span class="s5">&quot;dataLim&quot;</span><span class="s2">, </span><span class="s5">&quot;intervaly&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_minpos(self):</span>
        <span class="s2">return </span><span class="s1">self.axes.dataLim.minposy</span>

    <span class="s2">def </span><span class="s1">set_default_intervals(self):</span>
        <span class="s4"># docstring inherited</span>
        <span class="s4"># only change view if dataLim has not changed and user has</span>
        <span class="s4"># not changed the view:</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">self.axes.dataLim.mutatedy() </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self.axes.viewLim.mutatedy()):</span>
            <span class="s2">if </span><span class="s1">self.converter </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">info = self.converter.axisinfo(self.units</span><span class="s2">, </span><span class="s1">self)</span>
                <span class="s2">if </span><span class="s1">info.default_limits </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ymin</span><span class="s2">, </span><span class="s1">ymax = self.convert_units(info.default_limits)</span>
                    <span class="s1">self.axes.viewLim.intervaly = ymin</span><span class="s2">, </span><span class="s1">ymax</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_tick_space(self):</span>
        <span class="s1">ends = mtransforms.Bbox.unit().transformed(</span>
            <span class="s1">self.axes.transAxes - self.figure.dpi_scale_trans)</span>
        <span class="s1">length = ends.height * </span><span class="s3">72</span>
        <span class="s4"># Having a spacing of at least 2 just looks good.</span>
        <span class="s1">size = self._get_tick_label_size(</span><span class="s5">'y'</span><span class="s1">) * </span><span class="s3">2</span>
        <span class="s2">if </span><span class="s1">size &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">int(np.floor(length / size))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">2</span><span class="s1">**</span><span class="s3">31 </span><span class="s1">- </span><span class="s3">1</span>
</pre>
</body>
</html>