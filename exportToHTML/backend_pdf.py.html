<html>
<head>
<title>backend_pdf.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
backend_pdf.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A PDF Matplotlib backend. 
 
Author: Jouni K Sepp√§nen &lt;jks@iki.fi&gt; and others. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">codecs</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">total_ordering</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">zlib</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">PIL </span><span class="s2">import </span><span class="s1">Image</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_text_helpers</span><span class="s2">, </span><span class="s1">_type1font</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">dviread</span>
<span class="s2">from </span><span class="s1">matplotlib._pylab_helpers </span><span class="s2">import </span><span class="s1">Gcf</span>
<span class="s2">from </span><span class="s1">matplotlib.backend_bases </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_Backend</span><span class="s2">, </span><span class="s1">FigureCanvasBase</span><span class="s2">, </span><span class="s1">FigureManagerBase</span><span class="s2">, </span><span class="s1">GraphicsContextBase</span><span class="s2">,</span>
    <span class="s1">RendererBase)</span>
<span class="s2">from </span><span class="s1">matplotlib.backends.backend_mixed </span><span class="s2">import </span><span class="s1">MixedModeRenderer</span>
<span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>
<span class="s2">from </span><span class="s1">matplotlib.font_manager </span><span class="s2">import </span><span class="s1">get_font</span><span class="s2">, </span><span class="s1">fontManager </span><span class="s2">as </span><span class="s1">_fontManager</span>
<span class="s2">from </span><span class="s1">matplotlib._afm </span><span class="s2">import </span><span class="s1">AFM</span>
<span class="s2">from </span><span class="s1">matplotlib.ft2font </span><span class="s2">import </span><span class="s1">(FIXED_WIDTH</span><span class="s2">, </span><span class="s1">ITALIC</span><span class="s2">, </span><span class="s1">LOAD_NO_SCALE</span><span class="s2">,</span>
                                <span class="s1">LOAD_NO_HINTING</span><span class="s2">, </span><span class="s1">KERNING_UNFITTED</span><span class="s2">, </span><span class="s1">FT2Font)</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Affine2D</span><span class="s2">, </span><span class="s1">BboxBase</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">matplotlib.dates </span><span class="s2">import </span><span class="s1">UTC</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_path</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_backend_pdf_ps</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s3"># Overview</span>
<span class="s3">#</span>
<span class="s3"># The low-level knowledge about pdf syntax lies mainly in the pdfRepr</span>
<span class="s3"># function and the classes Reference, Name, Operator, and Stream.  The</span>
<span class="s3"># PdfFile class knows about the overall structure of pdf documents.</span>
<span class="s3"># It provides a &quot;write&quot; method for writing arbitrary strings in the</span>
<span class="s3"># file, and an &quot;output&quot; method that passes objects through the pdfRepr</span>
<span class="s3"># function before writing them in the file.  The output method is</span>
<span class="s3"># called by the RendererPdf class, which contains the various draw_foo</span>
<span class="s3"># methods.  RendererPdf contains a GraphicsContextPdf instance, and</span>
<span class="s3"># each draw_foo calls self.check_gc before outputting commands.  This</span>
<span class="s3"># method checks whether the pdf graphics state needs to be modified</span>
<span class="s3"># and outputs the necessary commands.  GraphicsContextPdf represents</span>
<span class="s3"># the graphics state, and its &quot;delta&quot; method returns the commands that</span>
<span class="s3"># modify the state.</span>

<span class="s3"># Add &quot;pdf.use14corefonts: True&quot; in your configuration file to use only</span>
<span class="s3"># the 14 PDF core fonts. These fonts do not need to be embedded; every</span>
<span class="s3"># PDF viewing application is required to have them. This results in very</span>
<span class="s3"># light PDF files you can use directly in LaTeX or ConTeXt documents</span>
<span class="s3"># generated with pdfTeX, without any conversion.</span>

<span class="s3"># These fonts are: Helvetica, Helvetica-Bold, Helvetica-Oblique,</span>
<span class="s3"># Helvetica-BoldOblique, Courier, Courier-Bold, Courier-Oblique,</span>
<span class="s3"># Courier-BoldOblique, Times-Roman, Times-Bold, Times-Italic,</span>
<span class="s3"># Times-BoldItalic, Symbol, ZapfDingbats.</span>
<span class="s3">#</span>
<span class="s3"># Some tricky points:</span>
<span class="s3">#</span>
<span class="s3"># 1. The clip path can only be widened by popping from the state</span>
<span class="s3"># stack.  Thus the state must be pushed onto the stack before narrowing</span>
<span class="s3"># the clip path.  This is taken care of by GraphicsContextPdf.</span>
<span class="s3">#</span>
<span class="s3"># 2. Sometimes it is necessary to refer to something (e.g., font,</span>
<span class="s3"># image, or extended graphics state, which contains the alpha value)</span>
<span class="s3"># in the page stream by a name that needs to be defined outside the</span>
<span class="s3"># stream.  PdfFile provides the methods fontName, imageObject, and</span>
<span class="s3"># alphaState for this purpose.  The implementations of these methods</span>
<span class="s3"># should perhaps be generalized.</span>

<span class="s3"># TODOs:</span>
<span class="s3">#</span>
<span class="s3"># * encoding of fonts, including mathtext fonts and Unicode support</span>
<span class="s3"># * TTF support has lots of small TODOs, e.g., how do you know if a font</span>
<span class="s3">#   is serif/sans-serif, or symbolic/non-symbolic?</span>
<span class="s3"># * draw_quad_mesh</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;a vendored copy of _fill&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">fill(strings</span><span class="s2">, </span><span class="s1">linelen=</span><span class="s5">75</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">_fill(strings</span><span class="s2">, </span><span class="s1">linelen=linelen)</span>


<span class="s2">def </span><span class="s1">_fill(strings</span><span class="s2">, </span><span class="s1">linelen=</span><span class="s5">75</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Make one string from sequence of strings, with whitespace in between. 
 
    The whitespace is chosen to form lines of at most *linelen* characters, 
    if possible. 
    &quot;&quot;&quot;</span>
    <span class="s1">currpos = </span><span class="s5">0</span>
    <span class="s1">lasti = </span><span class="s5">0</span>
    <span class="s1">result = []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">s </span><span class="s2">in </span><span class="s1">enumerate(strings):</span>
        <span class="s1">length = len(s)</span>
        <span class="s2">if </span><span class="s1">currpos + length &lt; linelen:</span>
            <span class="s1">currpos += length + </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result.append(</span><span class="s6">b' '</span><span class="s1">.join(strings[lasti:i]))</span>
            <span class="s1">lasti = i</span>
            <span class="s1">currpos = length</span>
    <span class="s1">result.append(</span><span class="s6">b' '</span><span class="s1">.join(strings[lasti:]))</span>
    <span class="s2">return </span><span class="s6">b'</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">.join(result)</span>


<span class="s2">def </span><span class="s1">_create_pdf_info_dict(backend</span><span class="s2">, </span><span class="s1">metadata):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a PDF infoDict based on user-supplied metadata. 
 
    A default ``Creator``, ``Producer``, and ``CreationDate`` are added, though 
    the user metadata may override it. The date may be the current time, or a 
    time set by the ``SOURCE_DATE_EPOCH`` environment variable. 
 
    Metadata is verified to have the correct keys and their expected types. Any 
    unknown keys/types will raise a warning. 
 
    Parameters 
    ---------- 
    backend : str 
        The name of the backend to use in the Producer value. 
 
    metadata : dict[str, Union[str, datetime, Name]] 
        A dictionary of metadata supplied by the user with information 
        following the PDF specification, also defined in 
        `~.backend_pdf.PdfPages` below. 
 
        If any value is *None*, then the key will be removed. This can be used 
        to remove any pre-defined values. 
 
    Returns 
    ------- 
    dict[str, Union[str, datetime, Name]] 
        A validated dictionary of metadata. 
    &quot;&quot;&quot;</span>

    <span class="s3"># get source date from SOURCE_DATE_EPOCH, if set</span>
    <span class="s3"># See https://reproducible-builds.org/specs/source-date-epoch/</span>
    <span class="s1">source_date_epoch = os.getenv(</span><span class="s4">&quot;SOURCE_DATE_EPOCH&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">source_date_epoch:</span>
        <span class="s1">source_date = datetime.utcfromtimestamp(int(source_date_epoch))</span>
        <span class="s1">source_date = source_date.replace(tzinfo=UTC)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">source_date = datetime.today()</span>

    <span class="s1">info = {</span>
        <span class="s4">'Creator'</span><span class="s1">: </span><span class="s4">f'Matplotlib v</span><span class="s2">{</span><span class="s1">mpl.__version__</span><span class="s2">}</span><span class="s4">, https://matplotlib.org'</span><span class="s2">,</span>
        <span class="s4">'Producer'</span><span class="s1">: </span><span class="s4">f'Matplotlib </span><span class="s2">{</span><span class="s1">backend</span><span class="s2">} </span><span class="s4">backend v</span><span class="s2">{</span><span class="s1">mpl.__version__</span><span class="s2">}</span><span class="s4">'</span><span class="s2">,</span>
        <span class="s4">'CreationDate'</span><span class="s1">: source_date</span><span class="s2">,</span>
        <span class="s1">**metadata</span>
    <span class="s1">}</span>
    <span class="s1">info = {k: v </span><span class="s2">for </span><span class="s1">(k</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">in </span><span class="s1">info.items() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">is_string_like(x):</span>
        <span class="s2">return </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str)</span>
    <span class="s1">is_string_like.text_for_warning = </span><span class="s4">&quot;an instance of str&quot;</span>

    <span class="s2">def </span><span class="s1">is_date(x):</span>
        <span class="s2">return </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">datetime)</span>
    <span class="s1">is_date.text_for_warning = </span><span class="s4">&quot;an instance of datetime.datetime&quot;</span>

    <span class="s2">def </span><span class="s1">check_trapped(x):</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">Name):</span>
            <span class="s2">return </span><span class="s1">x.name </span><span class="s2">in </span><span class="s1">(</span><span class="s6">b'True'</span><span class="s2">, </span><span class="s6">b'False'</span><span class="s2">, </span><span class="s6">b'Unknown'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">x </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'True'</span><span class="s2">, </span><span class="s4">'False'</span><span class="s2">, </span><span class="s4">'Unknown'</span><span class="s1">)</span>
    <span class="s1">check_trapped.text_for_warning = </span><span class="s4">'one of {&quot;True&quot;, &quot;False&quot;, &quot;Unknown&quot;}'</span>

    <span class="s1">keywords = {</span>
        <span class="s4">'Title'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'Author'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'Subject'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'Keywords'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'Creator'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'Producer'</span><span class="s1">: is_string_like</span><span class="s2">,</span>
        <span class="s4">'CreationDate'</span><span class="s1">: is_date</span><span class="s2">,</span>
        <span class="s4">'ModDate'</span><span class="s1">: is_date</span><span class="s2">,</span>
        <span class="s4">'Trapped'</span><span class="s1">: check_trapped</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">info:</span>
        <span class="s2">if </span><span class="s1">k </span><span class="s2">not in </span><span class="s1">keywords:</span>
            <span class="s1">_api.warn_external(</span><span class="s4">f'Unknown infodict keyword: </span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r}</span><span class="s4">. '</span>
                               <span class="s4">f'Must be one of </span><span class="s2">{</span><span class="s1">set(keywords)</span><span class="s2">!r}</span><span class="s4">.'</span><span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">keywords[k](info[k]):</span>
            <span class="s1">_api.warn_external(</span><span class="s4">f'Bad value for infodict keyword </span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s4">. '</span>
                               <span class="s4">f'Got </span><span class="s2">{</span><span class="s1">info[k]</span><span class="s2">!r} </span><span class="s4">which is not '</span>
                               <span class="s4">f'</span><span class="s2">{</span><span class="s1">keywords[k].text_for_warning</span><span class="s2">}</span><span class="s4">.'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s4">'Trapped' </span><span class="s2">in </span><span class="s1">info:</span>
        <span class="s1">info[</span><span class="s4">'Trapped'</span><span class="s1">] = Name(info[</span><span class="s4">'Trapped'</span><span class="s1">])</span>

    <span class="s2">return </span><span class="s1">info</span>


<span class="s2">def </span><span class="s1">_datetime_to_pdf(d):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a datetime to a PDF string representing it. 
 
    Used for PDF and PGF. 
    &quot;&quot;&quot;</span>
    <span class="s1">r = d.strftime(</span><span class="s4">'D:%Y%m%d%H%M%S'</span><span class="s1">)</span>
    <span class="s1">z = d.utcoffset()</span>
    <span class="s2">if </span><span class="s1">z </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">z = z.seconds</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">time.daylight:</span>
            <span class="s1">z = time.altzone</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">z = time.timezone</span>
    <span class="s2">if </span><span class="s1">z == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">r += </span><span class="s4">'Z'</span>
    <span class="s2">elif </span><span class="s1">z &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">r += </span><span class="s4">&quot;+%02d'%02d'&quot; </span><span class="s1">% ((-z) // </span><span class="s5">3600</span><span class="s2">, </span><span class="s1">(-z) % </span><span class="s5">3600</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">r += </span><span class="s4">&quot;-%02d'%02d'&quot; </span><span class="s1">% (z // </span><span class="s5">3600</span><span class="s2">, </span><span class="s1">z % </span><span class="s5">3600</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">r</span>


<span class="s2">def </span><span class="s1">_calculate_quad_point_coordinates(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the coordinates of rectangle when rotated by angle around x, y 
    &quot;&quot;&quot;</span>

    <span class="s1">angle = math.radians(-angle)</span>
    <span class="s1">sin_angle = math.sin(angle)</span>
    <span class="s1">cos_angle = math.cos(angle)</span>
    <span class="s1">a = x + height * sin_angle</span>
    <span class="s1">b = y + height * cos_angle</span>
    <span class="s1">c = x + width * cos_angle + height * sin_angle</span>
    <span class="s1">d = y - width * sin_angle + height * cos_angle</span>
    <span class="s1">e = x + width * cos_angle</span>
    <span class="s1">f = y - width * sin_angle</span>
    <span class="s2">return </span><span class="s1">((x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">(e</span><span class="s2">, </span><span class="s1">f)</span><span class="s2">, </span><span class="s1">(c</span><span class="s2">, </span><span class="s1">d)</span><span class="s2">, </span><span class="s1">(a</span><span class="s2">, </span><span class="s1">b))</span>


<span class="s2">def </span><span class="s1">_get_coordinates_of_block(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the coordinates of rotated rectangle and rectangle that covers the 
    rotated rectangle. 
    &quot;&quot;&quot;</span>

    <span class="s1">vertices = _calculate_quad_point_coordinates(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">,</span>
                                                 <span class="s1">height</span><span class="s2">, </span><span class="s1">angle)</span>

    <span class="s3"># Find min and max values for rectangle</span>
    <span class="s3"># adjust so that QuadPoints is inside Rect</span>
    <span class="s3"># PDF docs says that QuadPoints should be ignored if any point lies</span>
    <span class="s3"># outside Rect, but for Acrobat it is enough that QuadPoints is on the</span>
    <span class="s3"># border of Rect.</span>

    <span class="s1">pad = </span><span class="s5">0.00001 </span><span class="s2">if </span><span class="s1">angle % </span><span class="s5">90 </span><span class="s2">else </span><span class="s5">0</span>
    <span class="s1">min_x = min(v[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vertices) - pad</span>
    <span class="s1">min_y = min(v[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vertices) - pad</span>
    <span class="s1">max_x = max(v[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vertices) + pad</span>
    <span class="s1">max_y = max(v[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">vertices) + pad</span>
    <span class="s2">return </span><span class="s1">(tuple(itertools.chain.from_iterable(vertices))</span><span class="s2">,</span>
            <span class="s1">(min_x</span><span class="s2">, </span><span class="s1">min_y</span><span class="s2">, </span><span class="s1">max_x</span><span class="s2">, </span><span class="s1">max_y))</span>


<span class="s2">def </span><span class="s1">_get_link_annotation(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Create a link annotation object for embedding URLs. 
    &quot;&quot;&quot;</span>
    <span class="s1">quadpoints</span><span class="s2">, </span><span class="s1">rect = _get_coordinates_of_block(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle)</span>
    <span class="s1">link_annotation = {</span>
        <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Annot'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Link'</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s4">'Rect'</span><span class="s1">: rect</span><span class="s2">,</span>
        <span class="s4">'Border'</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s4">'A'</span><span class="s1">: {</span>
            <span class="s4">'S'</span><span class="s1">: Name(</span><span class="s4">'URI'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'URI'</span><span class="s1">: gc.get_url()</span><span class="s2">,</span>
        <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">angle % </span><span class="s5">90</span><span class="s1">:</span>
        <span class="s3"># Add QuadPoints</span>
        <span class="s1">link_annotation[</span><span class="s4">'QuadPoints'</span><span class="s1">] = quadpoints</span>
    <span class="s2">return </span><span class="s1">link_annotation</span>


<span class="s3"># PDF strings are supposed to be able to include any eight-bit data, except</span>
<span class="s3"># that unbalanced parens and backslashes must be escaped by a backslash.</span>
<span class="s3"># However, sf bug #2708559 shows that the carriage return character may get</span>
<span class="s3"># read as a newline; these characters correspond to \gamma and \Omega in TeX's</span>
<span class="s3"># math font encoding. Escaping them fixes the bug.</span>
<span class="s1">_str_escapes = str.maketrans({</span>
    <span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\\\\</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'('</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">('</span><span class="s2">, </span><span class="s4">')'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">)'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">n'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s1">: </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">r'</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">pdfRepr(obj):</span>
    <span class="s0">&quot;&quot;&quot;Map Python objects to PDF syntax.&quot;&quot;&quot;</span>

    <span class="s3"># Some objects defined later have their own pdfRepr method.</span>
    <span class="s2">if </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s4">'pdfRepr'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">obj.pdfRepr()</span>

    <span class="s3"># Floats. PDF does not have exponential notation (1.0e-10) so we</span>
    <span class="s3"># need to use %f with some precision.  Perhaps the precision</span>
    <span class="s3"># should adapt to the magnitude of the number?</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(float</span><span class="s2">, </span><span class="s1">np.floating)):</span>
        <span class="s2">if not </span><span class="s1">np.isfinite(obj):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Can only output finite numbers in PDF&quot;</span><span class="s1">)</span>
        <span class="s1">r = </span><span class="s6">b&quot;%.10f&quot; </span><span class="s1">% obj</span>
        <span class="s2">return </span><span class="s1">r.rstrip(</span><span class="s6">b'0'</span><span class="s1">).rstrip(</span><span class="s6">b'.'</span><span class="s1">)</span>

    <span class="s3"># Booleans. Needs to be tested before integers since</span>
    <span class="s3"># isinstance(True, int) is true.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">bool):</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s6">b'false'</span><span class="s2">, </span><span class="s6">b'true'</span><span class="s1">][obj]</span>

    <span class="s3"># Integers are written as such.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(int</span><span class="s2">, </span><span class="s1">np.integer)):</span>
        <span class="s2">return </span><span class="s6">b&quot;%d&quot; </span><span class="s1">% obj</span>

    <span class="s3"># Non-ASCII Unicode strings are encoded in UTF-16BE with byte-order mark.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">return </span><span class="s1">pdfRepr(obj.encode(</span><span class="s4">'ascii'</span><span class="s1">) </span><span class="s2">if </span><span class="s1">obj.isascii()</span>
                       <span class="s2">else </span><span class="s1">codecs.BOM_UTF16_BE + obj.encode(</span><span class="s4">'UTF-16BE'</span><span class="s1">))</span>

    <span class="s3"># Strings are written in parentheses, with backslashes and parens</span>
    <span class="s3"># escaped. Actually balanced parens are allowed, but it is</span>
    <span class="s3"># simpler to escape them all. TODO: cut long strings into lines;</span>
    <span class="s3"># I believe there is some maximum line length in PDF.</span>
    <span class="s3"># Despite the extra decode/encode, translate is faster than regex.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">bytes):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s6">b'(' </span><span class="s1">+</span>
            <span class="s1">obj.decode(</span><span class="s4">'latin-1'</span><span class="s1">).translate(_str_escapes).encode(</span><span class="s4">'latin-1'</span><span class="s1">)</span>
            <span class="s1">+ </span><span class="s6">b')'</span><span class="s1">)</span>

    <span class="s3"># Dictionaries. The keys must be PDF names, so if we find strings</span>
    <span class="s3"># there, we make Name objects from them. The values may be</span>
    <span class="s3"># anything, so the caller must ensure that PDF names are</span>
    <span class="s3"># represented as Name objects.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">dict):</span>
        <span class="s2">return </span><span class="s1">_fill([</span>
            <span class="s6">b&quot;&lt;&lt;&quot;</span><span class="s2">,</span>
            <span class="s1">*[Name(k).pdfRepr() + </span><span class="s6">b&quot; &quot; </span><span class="s1">+ pdfRepr(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">obj.items()]</span><span class="s2">,</span>
            <span class="s6">b&quot;&gt;&gt;&quot;</span><span class="s2">,</span>
        <span class="s1">])</span>

    <span class="s3"># Lists.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
        <span class="s2">return </span><span class="s1">_fill([</span><span class="s6">b&quot;[&quot;</span><span class="s2">, </span><span class="s1">*[pdfRepr(val) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">obj]</span><span class="s2">, </span><span class="s6">b&quot;]&quot;</span><span class="s1">])</span>

    <span class="s3"># The null keyword.</span>
    <span class="s2">elif </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s6">b'null'</span>

    <span class="s3"># A date.</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">datetime):</span>
        <span class="s2">return </span><span class="s1">pdfRepr(_datetime_to_pdf(obj))</span>

    <span class="s3"># A bounding box</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">BboxBase):</span>
        <span class="s2">return </span><span class="s1">_fill([pdfRepr(val) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">obj.bounds])</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Don't know a PDF representation for {} objects&quot;</span>
                        <span class="s1">.format(type(obj)))</span>


<span class="s2">def </span><span class="s1">_font_supports_glyph(fonttype</span><span class="s2">, </span><span class="s1">glyph):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns True if the font is able to provide codepoint *glyph* in a PDF. 
 
    For a Type 3 font, this method returns True only for single-byte 
    characters. For Type 42 fonts this method return True if the character is 
    from the Basic Multilingual Plane. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">fonttype == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">glyph &lt;= </span><span class="s5">255</span>
    <span class="s2">if </span><span class="s1">fonttype == </span><span class="s5">42</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">glyph &lt;= </span><span class="s5">65535</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError()</span>


<span class="s2">class </span><span class="s1">Reference:</span>
    <span class="s0">&quot;&quot;&quot; 
    PDF reference object. 
 
    Use PdfFile.reserveObject() to create References. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">id):</span>
        <span class="s1">self.id = id</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;Reference %d&gt;&quot; </span><span class="s1">% self.id</span>

    <span class="s2">def </span><span class="s1">pdfRepr(self):</span>
        <span class="s2">return </span><span class="s6">b&quot;%d 0 R&quot; </span><span class="s1">% self.id</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">contents</span><span class="s2">, </span><span class="s1">file):</span>
        <span class="s1">write = file.write</span>
        <span class="s1">write(</span><span class="s6">b&quot;%d 0 obj</span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">% self.id)</span>
        <span class="s1">write(pdfRepr(contents))</span>
        <span class="s1">write(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">endobj</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span>


<span class="s1">@total_ordering</span>
<span class="s2">class </span><span class="s1">Name:</span>
    <span class="s0">&quot;&quot;&quot;PDF name object.&quot;&quot;&quot;</span>
    <span class="s1">__slots__ = (</span><span class="s4">'name'</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">_hexify = {c: </span><span class="s4">'#%02x' </span><span class="s1">% c</span>
               <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">{*range(</span><span class="s5">256</span><span class="s1">)} - {*range(ord(</span><span class="s4">'!'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ord(</span><span class="s4">'~'</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">)}}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">Name):</span>
            <span class="s1">self.name = name.name</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">bytes):</span>
                <span class="s1">name = name.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>
            <span class="s1">self.name = name.translate(self._hexify).encode(</span><span class="s4">'ascii'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;Name %s&gt;&quot; </span><span class="s1">% self.name</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">'/' </span><span class="s1">+ self.name.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Name) </span><span class="s2">and </span><span class="s1">self.name == other.name</span>

    <span class="s2">def </span><span class="s1">__lt__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Name) </span><span class="s2">and </span><span class="s1">self.name &lt; other.name</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.name)</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">hexify(match):</span>
        <span class="s2">return </span><span class="s4">'#%02x' </span><span class="s1">% ord(match.group())</span>

    <span class="s2">def </span><span class="s1">pdfRepr(self):</span>
        <span class="s2">return </span><span class="s6">b'/' </span><span class="s1">+ self.name</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">Operator:</span>
    <span class="s1">__slots__ = (</span><span class="s4">'op'</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">op):</span>
        <span class="s1">self.op = op</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;Operator %s&gt;' </span><span class="s1">% self.op</span>

    <span class="s2">def </span><span class="s1">pdfRepr(self):</span>
        <span class="s2">return </span><span class="s1">self.op</span>


<span class="s2">class </span><span class="s1">Verbatim:</span>
    <span class="s0">&quot;&quot;&quot;Store verbatim PDF command content for later inclusion in the stream.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">self._x = x</span>

    <span class="s2">def </span><span class="s1">pdfRepr(self):</span>
        <span class="s2">return </span><span class="s1">self._x</span>


<span class="s2">class </span><span class="s1">Op(Enum):</span>
    <span class="s0">&quot;&quot;&quot;PDF operators (not an exhaustive list).&quot;&quot;&quot;</span>

    <span class="s1">close_fill_stroke = </span><span class="s6">b'b'</span>
    <span class="s1">fill_stroke = </span><span class="s6">b'B'</span>
    <span class="s1">fill = </span><span class="s6">b'f'</span>
    <span class="s1">closepath = </span><span class="s6">b'h'</span>
    <span class="s1">close_stroke = </span><span class="s6">b's'</span>
    <span class="s1">stroke = </span><span class="s6">b'S'</span>
    <span class="s1">endpath = </span><span class="s6">b'n'</span>
    <span class="s1">begin_text = </span><span class="s6">b'BT'</span>
    <span class="s1">end_text = </span><span class="s6">b'ET'</span>
    <span class="s1">curveto = </span><span class="s6">b'c'</span>
    <span class="s1">rectangle = </span><span class="s6">b're'</span>
    <span class="s1">lineto = </span><span class="s6">b'l'</span>
    <span class="s1">moveto = </span><span class="s6">b'm'</span>
    <span class="s1">concat_matrix = </span><span class="s6">b'cm'</span>
    <span class="s1">use_xobject = </span><span class="s6">b'Do'</span>
    <span class="s1">setgray_stroke = </span><span class="s6">b'G'</span>
    <span class="s1">setgray_nonstroke = </span><span class="s6">b'g'</span>
    <span class="s1">setrgb_stroke = </span><span class="s6">b'RG'</span>
    <span class="s1">setrgb_nonstroke = </span><span class="s6">b'rg'</span>
    <span class="s1">setcolorspace_stroke = </span><span class="s6">b'CS'</span>
    <span class="s1">setcolorspace_nonstroke = </span><span class="s6">b'cs'</span>
    <span class="s1">setcolor_stroke = </span><span class="s6">b'SCN'</span>
    <span class="s1">setcolor_nonstroke = </span><span class="s6">b'scn'</span>
    <span class="s1">setdash = </span><span class="s6">b'd'</span>
    <span class="s1">setlinejoin = </span><span class="s6">b'j'</span>
    <span class="s1">setlinecap = </span><span class="s6">b'J'</span>
    <span class="s1">setgstate = </span><span class="s6">b'gs'</span>
    <span class="s1">gsave = </span><span class="s6">b'q'</span>
    <span class="s1">grestore = </span><span class="s6">b'Q'</span>
    <span class="s1">textpos = </span><span class="s6">b'Td'</span>
    <span class="s1">selectfont = </span><span class="s6">b'Tf'</span>
    <span class="s1">textmatrix = </span><span class="s6">b'Tm'</span>
    <span class="s1">show = </span><span class="s6">b'Tj'</span>
    <span class="s1">showkern = </span><span class="s6">b'TJ'</span>
    <span class="s1">setlinewidth = </span><span class="s6">b'w'</span>
    <span class="s1">clip = </span><span class="s6">b'W'</span>
    <span class="s1">shading = </span><span class="s6">b'sh'</span>

    <span class="s1">op = _api.deprecated(</span><span class="s4">'3.6'</span><span class="s1">)(property(</span><span class="s2">lambda </span><span class="s1">self: self.value))</span>

    <span class="s2">def </span><span class="s1">pdfRepr(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">paint_path(cls</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">stroke):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the PDF operator to paint a path. 
 
        Parameters 
        ---------- 
        fill : bool 
            Fill the path with the fill color. 
        stroke : bool 
            Stroke the outline of the path with the line color. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">stroke:</span>
            <span class="s2">if </span><span class="s1">fill:</span>
                <span class="s2">return </span><span class="s1">cls.fill_stroke</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls.stroke</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">fill:</span>
                <span class="s2">return </span><span class="s1">cls.fill</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls.endpath</span>


<span class="s2">class </span><span class="s1">Stream:</span>
    <span class="s0">&quot;&quot;&quot; 
    PDF stream object. 
 
    This has no pdfRepr method. Instead, call begin(), then output the 
    contents of the stream by calling write(), and finally call end(). 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = (</span><span class="s4">'id'</span><span class="s2">, </span><span class="s4">'len'</span><span class="s2">, </span><span class="s4">'pdfFile'</span><span class="s2">, </span><span class="s4">'file'</span><span class="s2">, </span><span class="s4">'compressobj'</span><span class="s2">, </span><span class="s4">'extra'</span><span class="s2">, </span><span class="s4">'pos'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">len</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">extra=</span><span class="s2">None, </span><span class="s1">png=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        id : int 
            Object id of the stream. 
        len : Reference or None 
            An unused Reference object for the length of the stream; 
            None means to use a memory buffer so the length can be inlined. 
        file : PdfFile 
            The underlying object to write the stream to. 
        extra : dict from Name to anything, or None 
            Extra key-value pairs to include in the stream header. 
        png : dict or None 
            If the data is already png encoded, the decode parameters. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.id = id            </span><span class="s3"># object id</span>
        <span class="s1">self.len = len          </span><span class="s3"># id of length object</span>
        <span class="s1">self.pdfFile = file</span>
        <span class="s1">self.file = file.fh      </span><span class="s3"># file to which the stream is written</span>
        <span class="s1">self.compressobj = </span><span class="s2">None  </span><span class="s3"># compression object</span>
        <span class="s2">if </span><span class="s1">extra </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.extra = dict()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.extra = extra.copy()</span>
        <span class="s2">if </span><span class="s1">png </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.extra.update({</span><span class="s4">'Filter'</span><span class="s1">:      Name(</span><span class="s4">'FlateDecode'</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s4">'DecodeParms'</span><span class="s1">: png})</span>

        <span class="s1">self.pdfFile.recordXref(self.id)</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.compression'</span><span class="s1">] </span><span class="s2">and not </span><span class="s1">png:</span>
            <span class="s1">self.compressobj = zlib.compressobj(</span>
                <span class="s1">mpl.rcParams[</span><span class="s4">'pdf.compression'</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">self.len </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.file = BytesIO()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._writeHeader()</span>
            <span class="s1">self.pos = self.file.tell()</span>

    <span class="s2">def </span><span class="s1">_writeHeader(self):</span>
        <span class="s1">write = self.file.write</span>
        <span class="s1">write(</span><span class="s6">b&quot;%d 0 obj</span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">% self.id)</span>
        <span class="s1">dict = self.extra</span>
        <span class="s1">dict[</span><span class="s4">'Length'</span><span class="s1">] = self.len</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.compression'</span><span class="s1">]:</span>
            <span class="s1">dict[</span><span class="s4">'Filter'</span><span class="s1">] = Name(</span><span class="s4">'FlateDecode'</span><span class="s1">)</span>

        <span class="s1">write(pdfRepr(dict))</span>
        <span class="s1">write(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">stream</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">end(self):</span>
        <span class="s0">&quot;&quot;&quot;Finalize stream.&quot;&quot;&quot;</span>

        <span class="s1">self._flush()</span>
        <span class="s2">if </span><span class="s1">self.len </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">contents = self.file.getvalue()</span>
            <span class="s1">self.len = len(contents)</span>
            <span class="s1">self.file = self.pdfFile.fh</span>
            <span class="s1">self._writeHeader()</span>
            <span class="s1">self.file.write(contents)</span>
            <span class="s1">self.file.write(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">endstream</span><span class="s2">\n</span><span class="s6">endobj</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">length = self.file.tell() - self.pos</span>
            <span class="s1">self.file.write(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">endstream</span><span class="s2">\n</span><span class="s6">endobj</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span>
            <span class="s1">self.pdfFile.writeObject(self.len</span><span class="s2">, </span><span class="s1">length)</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot;Write some data on the stream.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.compressobj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.file.write(data)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">compressed = self.compressobj.compress(data)</span>
            <span class="s1">self.file.write(compressed)</span>

    <span class="s2">def </span><span class="s1">_flush(self):</span>
        <span class="s0">&quot;&quot;&quot;Flush the compression object.&quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.compressobj </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">compressed = self.compressobj.flush()</span>
            <span class="s1">self.file.write(compressed)</span>
            <span class="s1">self.compressobj = </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_get_pdf_charprocs(font_path</span><span class="s2">, </span><span class="s1">glyph_ids):</span>
    <span class="s1">font = get_font(font_path</span><span class="s2">, </span><span class="s1">hinting_factor=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">conv = </span><span class="s5">1000 </span><span class="s1">/ font.units_per_EM  </span><span class="s3"># Conversion to PS units (1/1000's).</span>
    <span class="s1">procs = {}</span>
    <span class="s2">for </span><span class="s1">glyph_id </span><span class="s2">in </span><span class="s1">glyph_ids:</span>
        <span class="s1">g = font.load_glyph(glyph_id</span><span class="s2">, </span><span class="s1">LOAD_NO_SCALE)</span>
        <span class="s3"># NOTE: We should be using round(), but instead use</span>
        <span class="s3"># &quot;(x+.5).astype(int)&quot; to keep backcompat with the old ttconv code</span>
        <span class="s3"># (this is different for negative x's).</span>
        <span class="s1">d1 = (np.array([g.horiAdvance</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">*g.bbox]) * conv + </span><span class="s5">.5</span><span class="s1">).astype(int)</span>
        <span class="s1">v</span><span class="s2">, </span><span class="s1">c = font.get_path()</span>
        <span class="s1">v = (v * </span><span class="s5">64</span><span class="s1">).astype(int)  </span><span class="s3"># Back to TrueType's internal units (1/64's).</span>
        <span class="s3"># Backcompat with old ttconv code: control points between two quads are</span>
        <span class="s3"># omitted if they are exactly at the midpoint between the control of</span>
        <span class="s3"># the quad before and the quad after, but ttconv used to interpolate</span>
        <span class="s3"># *after* conversion to PS units, causing floating point errors.  Here</span>
        <span class="s3"># we reproduce ttconv's logic, detecting these &quot;implicit&quot; points and</span>
        <span class="s3"># re-interpolating them.  Note that occasionally (e.g. with DejaVu Sans</span>
        <span class="s3"># glyph &quot;0&quot;) a point detected as &quot;implicit&quot; is actually explicit, and</span>
        <span class="s3"># will thus be shifted by 1.</span>
        <span class="s1">quads</span><span class="s2">, </span><span class="s1">= np.nonzero(c == </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">quads_on = quads[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">quads_mid_on = np.array(</span>
            <span class="s1">sorted({*quads_on} &amp; {*(quads - </span><span class="s5">1</span><span class="s1">)} &amp; {*(quads + </span><span class="s5">1</span><span class="s1">)})</span><span class="s2">, </span><span class="s1">int)</span>
        <span class="s1">implicit = quads_mid_on[</span>
            <span class="s1">(v[quads_mid_on]  </span><span class="s3"># As above, use astype(int), not // division</span>
             <span class="s1">== ((v[quads_mid_on - </span><span class="s5">1</span><span class="s1">] + v[quads_mid_on + </span><span class="s5">1</span><span class="s1">]) / </span><span class="s5">2</span><span class="s1">).astype(int))</span>
            <span class="s1">.all(axis=</span><span class="s5">1</span><span class="s1">)]</span>
        <span class="s2">if </span><span class="s1">(font.postscript_name</span><span class="s2">, </span><span class="s1">glyph_id) </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">(</span><span class="s4">&quot;DejaVuSerif-Italic&quot;</span><span class="s2">, </span><span class="s5">77</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># j</span>
                <span class="s1">(</span><span class="s4">&quot;DejaVuSerif-Italic&quot;</span><span class="s2">, </span><span class="s5">135</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># \AA</span>
        <span class="s1">]:</span>
            <span class="s1">v[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] -= </span><span class="s5">1  </span><span class="s3"># Hard-coded backcompat (FreeType shifts glyph by 1).</span>
        <span class="s1">v = (v * conv + </span><span class="s5">.5</span><span class="s1">).astype(int)  </span><span class="s3"># As above re: truncation vs rounding.</span>
        <span class="s1">v[implicit] = ((  </span><span class="s3"># Fix implicit points; again, truncate.</span>
            <span class="s1">(v[implicit - </span><span class="s5">1</span><span class="s1">] + v[implicit + </span><span class="s5">1</span><span class="s1">]) / </span><span class="s5">2</span><span class="s1">).astype(int))</span>
        <span class="s1">procs[font.get_glyph_name(glyph_id)] = (</span>
            <span class="s4">&quot; &quot;</span><span class="s1">.join(map(str</span><span class="s2">, </span><span class="s1">d1)).encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">) + </span><span class="s6">b&quot; d1</span><span class="s2">\n</span><span class="s6">&quot;</span>
            <span class="s1">+ _path.convert_to_string(</span>
                <span class="s1">Path(v</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, None, None, False, None, </span><span class="s1">-</span><span class="s5">1</span><span class="s2">,</span>
                <span class="s3"># no code for quad Beziers triggers auto-conversion to cubics.</span>
                <span class="s1">[</span><span class="s6">b&quot;m&quot;</span><span class="s2">, </span><span class="s6">b&quot;l&quot;</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s2">, </span><span class="s6">b&quot;c&quot;</span><span class="s2">, </span><span class="s6">b&quot;h&quot;</span><span class="s1">]</span><span class="s2">, True</span><span class="s1">)</span>
            <span class="s1">+ </span><span class="s6">b&quot;f&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">procs</span>


<span class="s2">class </span><span class="s1">PdfFile:</span>
    <span class="s0">&quot;&quot;&quot;PDF file object.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        filename : str or path-like or file-like 
            Output target; if a string, a file will be opened for writing. 
 
        metadata : dict from strings to strings and dates 
            Information dictionary object (see PDF reference section 10.2.1 
            'Document Information Dictionary'), e.g.: 
            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``. 
 
            The standard keys are 'Title', 'Author', 'Subject', 'Keywords', 
            'Creator', 'Producer', 'CreationDate', 'ModDate', and 
            'Trapped'. Values have been predefined for 'Creator', 'Producer' 
            and 'CreationDate'. They can be removed by setting them to `None`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>

        <span class="s1">self._object_seq = itertools.count(</span><span class="s5">1</span><span class="s1">)  </span><span class="s3"># consumed by reserveObject</span>
        <span class="s1">self.xrefTable = [[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">65535</span><span class="s2">, </span><span class="s4">'the zero object'</span><span class="s1">]]</span>
        <span class="s1">self.passed_in_file_object = </span><span class="s2">False</span>
        <span class="s1">self.original_file_like = </span><span class="s2">None</span>
        <span class="s1">self.tell_base = </span><span class="s5">0</span>
        <span class="s1">fh</span><span class="s2">, </span><span class="s1">opened = cbook.to_filehandle(filename</span><span class="s2">, </span><span class="s4">&quot;wb&quot;</span><span class="s2">, </span><span class="s1">return_opened=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">opened:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.tell_base = filename.tell()</span>
            <span class="s2">except </span><span class="s1">IOError:</span>
                <span class="s1">fh = BytesIO()</span>
                <span class="s1">self.original_file_like = filename</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fh = filename</span>
                <span class="s1">self.passed_in_file_object = </span><span class="s2">True</span>

        <span class="s1">self.fh = fh</span>
        <span class="s1">self.currentstream = </span><span class="s2">None  </span><span class="s3"># stream object to write to, if any</span>
        <span class="s1">fh.write(</span><span class="s6">b&quot;%PDF-1.4</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)    </span><span class="s3"># 1.4 is the first version to have alpha</span>
        <span class="s3"># Output some eight-bit chars as a comment so various utilities</span>
        <span class="s3"># recognize the file as binary by looking at the first few</span>
        <span class="s3"># lines (see note in section 3.4.1 of the PDF reference).</span>
        <span class="s1">fh.write(</span><span class="s6">b&quot;%</span><span class="s2">\254\334 \253\272\n</span><span class="s6">&quot;</span><span class="s1">)</span>

        <span class="s1">self.rootObject = self.reserveObject(</span><span class="s4">'root'</span><span class="s1">)</span>
        <span class="s1">self.pagesObject = self.reserveObject(</span><span class="s4">'pages'</span><span class="s1">)</span>
        <span class="s1">self.pageList = []</span>
        <span class="s1">self.fontObject = self.reserveObject(</span><span class="s4">'fonts'</span><span class="s1">)</span>
        <span class="s1">self._extGStateObject = self.reserveObject(</span><span class="s4">'extended graphics states'</span><span class="s1">)</span>
        <span class="s1">self.hatchObject = self.reserveObject(</span><span class="s4">'tiling patterns'</span><span class="s1">)</span>
        <span class="s1">self.gouraudObject = self.reserveObject(</span><span class="s4">'Gouraud triangles'</span><span class="s1">)</span>
        <span class="s1">self.XObjectObject = self.reserveObject(</span><span class="s4">'external objects'</span><span class="s1">)</span>
        <span class="s1">self.resourceObject = self.reserveObject(</span><span class="s4">'resources'</span><span class="s1">)</span>

        <span class="s1">root = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Catalog'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Pages'</span><span class="s1">: self.pagesObject}</span>
        <span class="s1">self.writeObject(self.rootObject</span><span class="s2">, </span><span class="s1">root)</span>

        <span class="s1">self.infoDict = _create_pdf_info_dict(</span><span class="s4">'pdf'</span><span class="s2">, </span><span class="s1">metadata </span><span class="s2">or </span><span class="s1">{})</span>

        <span class="s1">self.fontNames = {}     </span><span class="s3"># maps filenames to internal font names</span>
        <span class="s1">self._internal_font_seq = (Name(</span><span class="s4">f'F</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.count(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self.dviFontInfo = {}   </span><span class="s3"># maps dvi font names to embedding information</span>
        <span class="s3"># differently encoded Type-1 fonts may share the same descriptor</span>
        <span class="s1">self.type1Descriptors = {}</span>
        <span class="s1">self._character_tracker = _backend_pdf_ps.CharacterTracker()</span>

        <span class="s1">self.alphaStates = {}   </span><span class="s3"># maps alpha values to graphics state objects</span>
        <span class="s1">self._alpha_state_seq = (Name(</span><span class="s4">f'A</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.count(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self._soft_mask_states = {}</span>
        <span class="s1">self._soft_mask_seq = (Name(</span><span class="s4">f'SM</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.count(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self._soft_mask_groups = []</span>
        <span class="s1">self.hatchPatterns = {}</span>
        <span class="s1">self._hatch_pattern_seq = (Name(</span><span class="s4">f'H</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.count(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">self.gouraudTriangles = []</span>

        <span class="s1">self._images = {}</span>
        <span class="s1">self._image_seq = (Name(</span><span class="s4">f'I</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">'</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">itertools.count(</span><span class="s5">1</span><span class="s1">))</span>

        <span class="s1">self.markers = {}</span>
        <span class="s1">self.multi_byte_charprocs = {}</span>

        <span class="s1">self.paths = []</span>

        <span class="s3"># A list of annotations for each page. Each entry is a tuple of the</span>
        <span class="s3"># overall Annots object reference that's inserted into the page object,</span>
        <span class="s3"># followed by a list of the actual annotations.</span>
        <span class="s1">self._annotations = []</span>
        <span class="s3"># For annotations added before a page is created; mostly for the</span>
        <span class="s3"># purpose of newTextnote.</span>
        <span class="s1">self.pageAnnotations = []</span>

        <span class="s3"># The PDF spec recommends to include every procset</span>
        <span class="s1">procsets = [Name(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s4">&quot;PDF Text ImageB ImageC ImageI&quot;</span><span class="s1">.split()]</span>

        <span class="s3"># Write resource dictionary.</span>
        <span class="s3"># Possibly TODO: more general ExtGState (graphics state dictionaries)</span>
        <span class="s3">#                ColorSpace Pattern Shading Properties</span>
        <span class="s1">resources = {</span><span class="s4">'Font'</span><span class="s1">: self.fontObject</span><span class="s2">,</span>
                     <span class="s4">'XObject'</span><span class="s1">: self.XObjectObject</span><span class="s2">,</span>
                     <span class="s4">'ExtGState'</span><span class="s1">: self._extGStateObject</span><span class="s2">,</span>
                     <span class="s4">'Pattern'</span><span class="s1">: self.hatchObject</span><span class="s2">,</span>
                     <span class="s4">'Shading'</span><span class="s1">: self.gouraudObject</span><span class="s2">,</span>
                     <span class="s4">'ProcSet'</span><span class="s1">: procsets}</span>
        <span class="s1">self.writeObject(self.resourceObject</span><span class="s2">, </span><span class="s1">resources)</span>

    <span class="s2">def </span><span class="s1">newPage(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s1">self.endStream()</span>

        <span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.height = width</span><span class="s2">, </span><span class="s1">height</span>
        <span class="s1">contentObject = self.reserveObject(</span><span class="s4">'page contents'</span><span class="s1">)</span>
        <span class="s1">annotsObject = self.reserveObject(</span><span class="s4">'annotations'</span><span class="s1">)</span>
        <span class="s1">thePage = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Page'</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s4">'Parent'</span><span class="s1">: self.pagesObject</span><span class="s2">,</span>
                   <span class="s4">'Resources'</span><span class="s1">: self.resourceObject</span><span class="s2">,</span>
                   <span class="s4">'MediaBox'</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">72 </span><span class="s1">* width</span><span class="s2">, </span><span class="s5">72 </span><span class="s1">* height]</span><span class="s2">,</span>
                   <span class="s4">'Contents'</span><span class="s1">: contentObject</span><span class="s2">,</span>
                   <span class="s4">'Annots'</span><span class="s1">: annotsObject</span><span class="s2">,</span>
                   <span class="s1">}</span>
        <span class="s1">pageObject = self.reserveObject(</span><span class="s4">'page'</span><span class="s1">)</span>
        <span class="s1">self.writeObject(pageObject</span><span class="s2">, </span><span class="s1">thePage)</span>
        <span class="s1">self.pageList.append(pageObject)</span>
        <span class="s1">self._annotations.append((annotsObject</span><span class="s2">, </span><span class="s1">self.pageAnnotations))</span>

        <span class="s1">self.beginStream(contentObject.id</span><span class="s2">,</span>
                         <span class="s1">self.reserveObject(</span><span class="s4">'length of content stream'</span><span class="s1">))</span>
        <span class="s3"># Initialize the pdf graphics state to match the default Matplotlib</span>
        <span class="s3"># graphics context (colorspace and joinstyle).</span>
        <span class="s1">self.output(Name(</span><span class="s4">'DeviceRGB'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Op.setcolorspace_stroke)</span>
        <span class="s1">self.output(Name(</span><span class="s4">'DeviceRGB'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Op.setcolorspace_nonstroke)</span>
        <span class="s1">self.output(GraphicsContextPdf.joinstyles[</span><span class="s4">'round'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setlinejoin)</span>

        <span class="s3"># Clear the list of annotations for the next page</span>
        <span class="s1">self.pageAnnotations = []</span>

    <span class="s2">def </span><span class="s1">newTextnote(self</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">positionRect=[-</span><span class="s5">100</span><span class="s2">, </span><span class="s1">-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s3"># Create a new annotation of type text</span>
        <span class="s1">theNote = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Annot'</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Text'</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s4">'Contents'</span><span class="s1">: text</span><span class="s2">,</span>
                   <span class="s4">'Rect'</span><span class="s1">: positionRect</span><span class="s2">,</span>
                   <span class="s1">}</span>
        <span class="s1">self.pageAnnotations.append(theNote)</span>

    <span class="s2">def </span><span class="s1">_get_subsetted_psname(self</span><span class="s2">, </span><span class="s1">ps_name</span><span class="s2">, </span><span class="s1">charmap):</span>
        <span class="s2">def </span><span class="s1">toStr(n</span><span class="s2">, </span><span class="s1">base):</span>
            <span class="s2">if </span><span class="s1">n &lt; base:</span>
                <span class="s2">return </span><span class="s1">string.ascii_uppercase[n]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">(</span>
                    <span class="s1">toStr(n // base</span><span class="s2">, </span><span class="s1">base) + string.ascii_uppercase[n % base]</span>
                <span class="s1">)</span>

        <span class="s3"># encode to string using base 26</span>
        <span class="s1">hashed = hash(frozenset(charmap.keys())) % ((sys.maxsize + </span><span class="s5">1</span><span class="s1">) * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">prefix = toStr(hashed</span><span class="s2">, </span><span class="s5">26</span><span class="s1">)</span>

        <span class="s3"># get first 6 characters from prefix</span>
        <span class="s2">return </span><span class="s1">prefix[:</span><span class="s5">6</span><span class="s1">] + </span><span class="s4">&quot;+&quot; </span><span class="s1">+ ps_name</span>

    <span class="s2">def </span><span class="s1">finalize(self):</span>
        <span class="s0">&quot;&quot;&quot;Write out the various deferred objects and the pdf end matter.&quot;&quot;&quot;</span>

        <span class="s1">self.endStream()</span>
        <span class="s1">self._write_annotations()</span>
        <span class="s1">self.writeFonts()</span>
        <span class="s1">self.writeExtGSTates()</span>
        <span class="s1">self._write_soft_mask_groups()</span>
        <span class="s1">self.writeHatches()</span>
        <span class="s1">self.writeGouraudTriangles()</span>
        <span class="s1">xobjects = {</span>
            <span class="s1">name: ob </span><span class="s2">for </span><span class="s1">image</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ob </span><span class="s2">in </span><span class="s1">self._images.values()}</span>
        <span class="s2">for </span><span class="s1">tup </span><span class="s2">in </span><span class="s1">self.markers.values():</span>
            <span class="s1">xobjects[tup[</span><span class="s5">0</span><span class="s1">]] = tup[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">self.multi_byte_charprocs.items():</span>
            <span class="s1">xobjects[name] = value</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">join</span><span class="s2">, </span><span class="s1">cap</span><span class="s2">, </span><span class="s1">padding</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">stroked \</span>
                <span class="s2">in </span><span class="s1">self.paths:</span>
            <span class="s1">xobjects[name] = ob</span>
        <span class="s1">self.writeObject(self.XObjectObject</span><span class="s2">, </span><span class="s1">xobjects)</span>
        <span class="s1">self.writeImages()</span>
        <span class="s1">self.writeMarkers()</span>
        <span class="s1">self.writePathCollectionTemplates()</span>
        <span class="s1">self.writeObject(self.pagesObject</span><span class="s2">,</span>
                         <span class="s1">{</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Pages'</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s4">'Kids'</span><span class="s1">: self.pageList</span><span class="s2">,</span>
                          <span class="s4">'Count'</span><span class="s1">: len(self.pageList)})</span>
        <span class="s1">self.writeInfoDict()</span>

        <span class="s3"># Finalize the file</span>
        <span class="s1">self.writeXref()</span>
        <span class="s1">self.writeTrailer()</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s0">&quot;&quot;&quot;Flush all buffers and free all resources.&quot;&quot;&quot;</span>

        <span class="s1">self.endStream()</span>
        <span class="s2">if </span><span class="s1">self.passed_in_file_object:</span>
            <span class="s1">self.fh.flush()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.original_file_like </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.original_file_like.write(self.fh.getvalue())</span>
            <span class="s1">self.fh.close()</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">self.currentstream </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.fh.write(data)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.currentstream.write(data)</span>

    <span class="s2">def </span><span class="s1">output(self</span><span class="s2">, </span><span class="s1">*data):</span>
        <span class="s1">self.write(_fill([pdfRepr(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">data]))</span>
        <span class="s1">self.write(</span><span class="s6">b'</span><span class="s2">\n</span><span class="s6">'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">beginStream(self</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">len</span><span class="s2">, </span><span class="s1">extra=</span><span class="s2">None, </span><span class="s1">png=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">self.currentstream </span><span class="s2">is None</span>
        <span class="s1">self.currentstream = Stream(id</span><span class="s2">, </span><span class="s1">len</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">extra</span><span class="s2">, </span><span class="s1">png)</span>

    <span class="s2">def </span><span class="s1">endStream(self):</span>
        <span class="s2">if </span><span class="s1">self.currentstream </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.currentstream.end()</span>
            <span class="s1">self.currentstream = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">outputStream(self</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">extra=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.beginStream(ref.id</span><span class="s2">, None, </span><span class="s1">extra)</span>
        <span class="s1">self.currentstream.write(data)</span>
        <span class="s1">self.endStream()</span>

    <span class="s2">def </span><span class="s1">_write_annotations(self):</span>
        <span class="s2">for </span><span class="s1">annotsObject</span><span class="s2">, </span><span class="s1">annotations </span><span class="s2">in </span><span class="s1">self._annotations:</span>
            <span class="s1">self.writeObject(annotsObject</span><span class="s2">, </span><span class="s1">annotations)</span>

    <span class="s2">def </span><span class="s1">fontName(self</span><span class="s2">, </span><span class="s1">fontprop):</span>
        <span class="s0">&quot;&quot;&quot; 
        Select a font based on fontprop and return a name suitable for 
        Op.selectfont. If fontprop is a string, it will be interpreted 
        as the filename of the font. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">isinstance(fontprop</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">filenames = [fontprop]</span>
        <span class="s2">elif </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.use14corefonts'</span><span class="s1">]:</span>
            <span class="s1">filenames = _fontManager._find_fonts_by_props(</span>
                <span class="s1">fontprop</span><span class="s2">, </span><span class="s1">fontext=</span><span class="s4">'afm'</span><span class="s2">, </span><span class="s1">directory=RendererPdf._afm_font_dir</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">filenames = _fontManager._find_fonts_by_props(fontprop)</span>
        <span class="s1">first_Fx = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">filenames:</span>
            <span class="s1">Fx = self.fontNames.get(fname)</span>
            <span class="s2">if not </span><span class="s1">first_Fx:</span>
                <span class="s1">first_Fx = Fx</span>
            <span class="s2">if </span><span class="s1">Fx </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">Fx = next(self._internal_font_seq)</span>
                <span class="s1">self.fontNames[fname] = Fx</span>
                <span class="s1">_log.debug(</span><span class="s4">'Assigning font %s = %r'</span><span class="s2">, </span><span class="s1">Fx</span><span class="s2">, </span><span class="s1">fname)</span>
                <span class="s2">if not </span><span class="s1">first_Fx:</span>
                    <span class="s1">first_Fx = Fx</span>

        <span class="s3"># find_fontsprop's first value always adheres to</span>
        <span class="s3"># findfont's value, so technically no behaviour change</span>
        <span class="s2">return </span><span class="s1">first_Fx</span>

    <span class="s2">def </span><span class="s1">dviFontName(self</span><span class="s2">, </span><span class="s1">dvifont):</span>
        <span class="s0">&quot;&quot;&quot; 
        Given a dvi font object, return a name suitable for Op.selectfont. 
        This registers the font information in ``self.dviFontInfo`` if not yet 
        registered. 
        &quot;&quot;&quot;</span>

        <span class="s1">dvi_info = self.dviFontInfo.get(dvifont.texname)</span>
        <span class="s2">if </span><span class="s1">dvi_info </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">dvi_info.pdfname</span>

        <span class="s1">tex_font_map = dviread.PsfontsMap(dviread._find_tex_file(</span><span class="s4">'pdftex.map'</span><span class="s1">))</span>
        <span class="s1">psfont = tex_font_map[dvifont.texname]</span>
        <span class="s2">if </span><span class="s1">psfont.filename </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;No usable font file found for {} (TeX: {}); &quot;</span>
                <span class="s4">&quot;the font may lack a Type-1 version&quot;</span>
                <span class="s1">.format(psfont.psname</span><span class="s2">, </span><span class="s1">dvifont.texname))</span>

        <span class="s1">pdfname = next(self._internal_font_seq)</span>
        <span class="s1">_log.debug(</span><span class="s4">'Assigning font %s = %s (dvi)'</span><span class="s2">, </span><span class="s1">pdfname</span><span class="s2">, </span><span class="s1">dvifont.texname)</span>
        <span class="s1">self.dviFontInfo[dvifont.texname] = types.SimpleNamespace(</span>
            <span class="s1">dvifont=dvifont</span><span class="s2">,</span>
            <span class="s1">pdfname=pdfname</span><span class="s2">,</span>
            <span class="s1">fontfile=psfont.filename</span><span class="s2">,</span>
            <span class="s1">basefont=psfont.psname</span><span class="s2">,</span>
            <span class="s1">encodingfile=psfont.encoding</span><span class="s2">,</span>
            <span class="s1">effects=psfont.effects)</span>
        <span class="s2">return </span><span class="s1">pdfname</span>

    <span class="s2">def </span><span class="s1">writeFonts(self):</span>
        <span class="s1">fonts = {}</span>
        <span class="s2">for </span><span class="s1">dviname</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">sorted(self.dviFontInfo.items()):</span>
            <span class="s1">Fx = info.pdfname</span>
            <span class="s1">_log.debug(</span><span class="s4">'Embedding Type-1 font %s from dvi.'</span><span class="s2">, </span><span class="s1">dviname)</span>
            <span class="s1">fonts[Fx] = self._embedTeXFont(info)</span>
        <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">sorted(self.fontNames):</span>
            <span class="s1">Fx = self.fontNames[filename]</span>
            <span class="s1">_log.debug(</span><span class="s4">'Embedding font %s.'</span><span class="s2">, </span><span class="s1">filename)</span>
            <span class="s2">if </span><span class="s1">filename.endswith(</span><span class="s4">'.afm'</span><span class="s1">):</span>
                <span class="s3"># from pdf.use14corefonts</span>
                <span class="s1">_log.debug(</span><span class="s4">'Writing AFM font.'</span><span class="s1">)</span>
                <span class="s1">fonts[Fx] = self._write_afm_font(filename)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># a normal TrueType font</span>
                <span class="s1">_log.debug(</span><span class="s4">'Writing TrueType font.'</span><span class="s1">)</span>
                <span class="s1">chars = self._character_tracker.used.get(filename)</span>
                <span class="s2">if </span><span class="s1">chars:</span>
                    <span class="s1">fonts[Fx] = self.embedTTF(filename</span><span class="s2">, </span><span class="s1">chars)</span>
        <span class="s1">self.writeObject(self.fontObject</span><span class="s2">, </span><span class="s1">fonts)</span>

    <span class="s2">def </span><span class="s1">_write_afm_font(self</span><span class="s2">, </span><span class="s1">filename):</span>
        <span class="s2">with </span><span class="s1">open(filename</span><span class="s2">, </span><span class="s4">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fh:</span>
            <span class="s1">font = AFM(fh)</span>
        <span class="s1">fontname = font.get_fontname()</span>
        <span class="s1">fontdict = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Font'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Type1'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'BaseFont'</span><span class="s1">: Name(fontname)</span><span class="s2">,</span>
                    <span class="s4">'Encoding'</span><span class="s1">: Name(</span><span class="s4">'WinAnsiEncoding'</span><span class="s1">)}</span>
        <span class="s1">fontdictObject = self.reserveObject(</span><span class="s4">'font dictionary'</span><span class="s1">)</span>
        <span class="s1">self.writeObject(fontdictObject</span><span class="s2">, </span><span class="s1">fontdict)</span>
        <span class="s2">return </span><span class="s1">fontdictObject</span>

    <span class="s2">def </span><span class="s1">_embedTeXFont(self</span><span class="s2">, </span><span class="s1">fontinfo):</span>
        <span class="s1">_log.debug(</span><span class="s4">'Embedding TeX font %s - fontinfo=%s'</span><span class="s2">,</span>
                   <span class="s1">fontinfo.dvifont.texname</span><span class="s2">, </span><span class="s1">fontinfo.__dict__)</span>

        <span class="s3"># Widths</span>
        <span class="s1">widthsObject = self.reserveObject(</span><span class="s4">'font widths'</span><span class="s1">)</span>
        <span class="s1">self.writeObject(widthsObject</span><span class="s2">, </span><span class="s1">fontinfo.dvifont.widths)</span>

        <span class="s3"># Font dictionary</span>
        <span class="s1">fontdictObject = self.reserveObject(</span><span class="s4">'font dictionary'</span><span class="s1">)</span>
        <span class="s1">fontdict = {</span>
            <span class="s4">'Type'</span><span class="s1">:      Name(</span><span class="s4">'Font'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'Subtype'</span><span class="s1">:   Name(</span><span class="s4">'Type1'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'FirstChar'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s4">'LastChar'</span><span class="s1">:  len(fontinfo.dvifont.widths) - </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s4">'Widths'</span><span class="s1">:    widthsObject</span><span class="s2">,</span>
            <span class="s1">}</span>

        <span class="s3"># Encoding (if needed)</span>
        <span class="s2">if </span><span class="s1">fontinfo.encodingfile </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">fontdict[</span><span class="s4">'Encoding'</span><span class="s1">] = {</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Encoding'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Differences'</span><span class="s1">: [</span>
                    <span class="s5">0</span><span class="s2">, </span><span class="s1">*map(Name</span><span class="s2">, </span><span class="s1">dviread._parse_enc(fontinfo.encodingfile))]</span><span class="s2">,</span>
            <span class="s1">}</span>

        <span class="s3"># If no file is specified, stop short</span>
        <span class="s2">if </span><span class="s1">fontinfo.fontfile </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">_log.warning(</span>
                <span class="s4">&quot;Because of TeX configuration (pdftex.map, see updmap option &quot;</span>
                <span class="s4">&quot;pdftexDownloadBase14) the font %s is not embedded. This is &quot;</span>
                <span class="s4">&quot;deprecated as of PDF 1.5 and it may cause the consumer &quot;</span>
                <span class="s4">&quot;application to show something that was not intended.&quot;</span><span class="s2">,</span>
                <span class="s1">fontinfo.basefont)</span>
            <span class="s1">fontdict[</span><span class="s4">'BaseFont'</span><span class="s1">] = Name(fontinfo.basefont)</span>
            <span class="s1">self.writeObject(fontdictObject</span><span class="s2">, </span><span class="s1">fontdict)</span>
            <span class="s2">return </span><span class="s1">fontdictObject</span>

        <span class="s3"># We have a font file to embed - read it in and apply any effects</span>
        <span class="s1">t1font = _type1font.Type1Font(fontinfo.fontfile)</span>
        <span class="s2">if </span><span class="s1">fontinfo.effects:</span>
            <span class="s1">t1font = t1font.transform(fontinfo.effects)</span>
        <span class="s1">fontdict[</span><span class="s4">'BaseFont'</span><span class="s1">] = Name(t1font.prop[</span><span class="s4">'FontName'</span><span class="s1">])</span>

        <span class="s3"># Font descriptors may be shared between differently encoded</span>
        <span class="s3"># Type-1 fonts, so only create a new descriptor if there is no</span>
        <span class="s3"># existing descriptor for this font.</span>
        <span class="s1">effects = (fontinfo.effects.get(</span><span class="s4">'slant'</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span><span class="s2">,</span>
                   <span class="s1">fontinfo.effects.get(</span><span class="s4">'extend'</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">))</span>
        <span class="s1">fontdesc = self.type1Descriptors.get((fontinfo.fontfile</span><span class="s2">, </span><span class="s1">effects))</span>
        <span class="s2">if </span><span class="s1">fontdesc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fontdesc = self.createType1Descriptor(t1font</span><span class="s2">, </span><span class="s1">fontinfo.fontfile)</span>
            <span class="s1">self.type1Descriptors[(fontinfo.fontfile</span><span class="s2">, </span><span class="s1">effects)] = fontdesc</span>
        <span class="s1">fontdict[</span><span class="s4">'FontDescriptor'</span><span class="s1">] = fontdesc</span>

        <span class="s1">self.writeObject(fontdictObject</span><span class="s2">, </span><span class="s1">fontdict)</span>
        <span class="s2">return </span><span class="s1">fontdictObject</span>

    <span class="s2">def </span><span class="s1">createType1Descriptor(self</span><span class="s2">, </span><span class="s1">t1font</span><span class="s2">, </span><span class="s1">fontfile):</span>
        <span class="s3"># Create and write the font descriptor and the font file</span>
        <span class="s3"># of a Type-1 font</span>
        <span class="s1">fontdescObject = self.reserveObject(</span><span class="s4">'font descriptor'</span><span class="s1">)</span>
        <span class="s1">fontfileObject = self.reserveObject(</span><span class="s4">'font file'</span><span class="s1">)</span>

        <span class="s1">italic_angle = t1font.prop[</span><span class="s4">'ItalicAngle'</span><span class="s1">]</span>
        <span class="s1">fixed_pitch = t1font.prop[</span><span class="s4">'isFixedPitch'</span><span class="s1">]</span>

        <span class="s1">flags = </span><span class="s5">0</span>
        <span class="s3"># fixed width</span>
        <span class="s2">if </span><span class="s1">fixed_pitch:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">0</span>
        <span class="s3"># TODO: serif</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">1</span>
        <span class="s3"># TODO: symbolic (most TeX fonts are)</span>
        <span class="s2">if </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">2</span>
        <span class="s3"># non-symbolic</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">5</span>
        <span class="s3"># italic</span>
        <span class="s2">if </span><span class="s1">italic_angle:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">6</span>
        <span class="s3"># TODO: all caps</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">16</span>
        <span class="s3"># TODO: small caps</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">17</span>
        <span class="s3"># TODO: force bold</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">18</span>

        <span class="s1">ft2font = get_font(fontfile)</span>

        <span class="s1">descriptor = {</span>
            <span class="s4">'Type'</span><span class="s1">:        Name(</span><span class="s4">'FontDescriptor'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'FontName'</span><span class="s1">:    Name(t1font.prop[</span><span class="s4">'FontName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s4">'Flags'</span><span class="s1">:       flags</span><span class="s2">,</span>
            <span class="s4">'FontBBox'</span><span class="s1">:    ft2font.bbox</span><span class="s2">,</span>
            <span class="s4">'ItalicAngle'</span><span class="s1">: italic_angle</span><span class="s2">,</span>
            <span class="s4">'Ascent'</span><span class="s1">:      ft2font.ascender</span><span class="s2">,</span>
            <span class="s4">'Descent'</span><span class="s1">:     ft2font.descender</span><span class="s2">,</span>
            <span class="s4">'CapHeight'</span><span class="s1">:   </span><span class="s5">1000</span><span class="s2">,  </span><span class="s3"># TODO: find this out</span>
            <span class="s4">'XHeight'</span><span class="s1">:     </span><span class="s5">500</span><span class="s2">,  </span><span class="s3"># TODO: this one too</span>
            <span class="s4">'FontFile'</span><span class="s1">:    fontfileObject</span><span class="s2">,</span>
            <span class="s4">'FontFamily'</span><span class="s1">:  t1font.prop[</span><span class="s4">'FamilyName'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4">'StemV'</span><span class="s1">:       </span><span class="s5">50</span><span class="s2">,  </span><span class="s3"># TODO</span>
            <span class="s3"># (see also revision 3874; but not all TeX distros have AFM files!)</span>
            <span class="s3"># 'FontWeight': a number where 400 = Regular, 700 = Bold</span>
            <span class="s1">}</span>

        <span class="s1">self.writeObject(fontdescObject</span><span class="s2">, </span><span class="s1">descriptor)</span>

        <span class="s1">self.outputStream(fontfileObject</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">.join(t1font.parts[:</span><span class="s5">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">extra={</span><span class="s4">'Length1'</span><span class="s1">: len(t1font.parts[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                                 <span class="s4">'Length2'</span><span class="s1">: len(t1font.parts[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                                 <span class="s4">'Length3'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>

        <span class="s2">return </span><span class="s1">fontdescObject</span>

    <span class="s2">def </span><span class="s1">_get_xobject_glyph_name(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">glyph_name):</span>
        <span class="s1">Fx = self.fontName(filename)</span>
        <span class="s2">return </span><span class="s4">&quot;-&quot;</span><span class="s1">.join([</span>
            <span class="s1">Fx.name.decode()</span><span class="s2">,</span>
            <span class="s1">os.path.splitext(os.path.basename(filename))[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">glyph_name])</span>

    <span class="s1">_identityToUnicodeCMap = </span><span class="s6">b&quot;&quot;&quot;/CIDInit /ProcSet findresource begin 
12 dict begin 
begincmap 
/CIDSystemInfo 
&lt;&lt; /Registry (Adobe) 
   /Ordering (UCS) 
   /Supplement 0 
&gt;&gt; def 
/CMapName /Adobe-Identity-UCS def 
/CMapType 2 def 
1 begincodespacerange 
&lt;0000&gt; &lt;ffff&gt; 
endcodespacerange 
%d beginbfrange 
%s 
endbfrange 
endcmap 
CMapName currentdict /CMap defineresource pop 
end 
end&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">embedTTF(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">characters):</span>
        <span class="s0">&quot;&quot;&quot;Embed the TTF font from the named file into the document.&quot;&quot;&quot;</span>

        <span class="s1">font = get_font(filename)</span>
        <span class="s1">fonttype = mpl.rcParams[</span><span class="s4">'pdf.fonttype'</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">cvt(length</span><span class="s2">, </span><span class="s1">upe=font.units_per_EM</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot;Convert font coordinates to PDF glyph coordinates.&quot;&quot;&quot;</span>
            <span class="s1">value = length / upe * </span><span class="s5">1000</span>
            <span class="s2">if </span><span class="s1">nearest:</span>
                <span class="s2">return </span><span class="s1">round(value)</span>
            <span class="s3"># Best(?) to round away from zero for bounding boxes and the like.</span>
            <span class="s2">if </span><span class="s1">value &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">math.floor(value)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">math.ceil(value)</span>

        <span class="s2">def </span><span class="s1">embedTTFType3(font</span><span class="s2">, </span><span class="s1">characters</span><span class="s2">, </span><span class="s1">descriptor):</span>
            <span class="s0">&quot;&quot;&quot;The Type 3-specific part of embedding a Truetype font&quot;&quot;&quot;</span>
            <span class="s1">widthsObject = self.reserveObject(</span><span class="s4">'font widths'</span><span class="s1">)</span>
            <span class="s1">fontdescObject = self.reserveObject(</span><span class="s4">'font descriptor'</span><span class="s1">)</span>
            <span class="s1">fontdictObject = self.reserveObject(</span><span class="s4">'font dictionary'</span><span class="s1">)</span>
            <span class="s1">charprocsObject = self.reserveObject(</span><span class="s4">'character procs'</span><span class="s1">)</span>
            <span class="s1">differencesArray = []</span>
            <span class="s1">firstchar</span><span class="s2">, </span><span class="s1">lastchar = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">255</span>
            <span class="s1">bbox = [cvt(x</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">font.bbox]</span>

            <span class="s1">fontdict = {</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Font'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'BaseFont'</span><span class="s1">: ps_name</span><span class="s2">,</span>
                <span class="s4">'FirstChar'</span><span class="s1">: firstchar</span><span class="s2">,</span>
                <span class="s4">'LastChar'</span><span class="s1">: lastchar</span><span class="s2">,</span>
                <span class="s4">'FontDescriptor'</span><span class="s1">: fontdescObject</span><span class="s2">,</span>
                <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Type3'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Name'</span><span class="s1">: descriptor[</span><span class="s4">'FontName'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s4">'FontBBox'</span><span class="s1">: bbox</span><span class="s2">,</span>
                <span class="s4">'FontMatrix'</span><span class="s1">: [</span><span class="s5">.001</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">.001</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s4">'CharProcs'</span><span class="s1">: charprocsObject</span><span class="s2">,</span>
                <span class="s4">'Encoding'</span><span class="s1">: {</span>
                    <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Encoding'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'Differences'</span><span class="s1">: differencesArray}</span><span class="s2">,</span>
                <span class="s4">'Widths'</span><span class="s1">: widthsObject</span>
                <span class="s1">}</span>

            <span class="s2">from </span><span class="s1">encodings </span><span class="s2">import </span><span class="s1">cp1252</span>

            <span class="s3"># Make the &quot;Widths&quot; array</span>
            <span class="s2">def </span><span class="s1">get_char_width(charcode):</span>
                <span class="s1">s = ord(cp1252.decoding_table[charcode])</span>
                <span class="s1">width = font.load_char(</span>
                    <span class="s1">s</span><span class="s2">, </span><span class="s1">flags=LOAD_NO_SCALE | LOAD_NO_HINTING).horiAdvance</span>
                <span class="s2">return </span><span class="s1">cvt(width)</span>
            <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s3"># Ignore 'Required glyph missing from current font' warning</span>
                <span class="s3"># from ft2font: here we're just building the widths table, but</span>
                <span class="s3"># the missing glyphs may not even be used in the actual string.</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
                <span class="s1">widths = [get_char_width(charcode)</span>
                          <span class="s2">for </span><span class="s1">charcode </span><span class="s2">in </span><span class="s1">range(firstchar</span><span class="s2">, </span><span class="s1">lastchar+</span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s1">descriptor[</span><span class="s4">'MaxWidth'</span><span class="s1">] = max(widths)</span>

            <span class="s3"># Make the &quot;Differences&quot; array, sort the ccodes &lt; 255 from</span>
            <span class="s3"># the multi-byte ccodes, and build the whole set of glyph ids</span>
            <span class="s3"># that we need from this font.</span>
            <span class="s1">glyph_ids = []</span>
            <span class="s1">differences = []</span>
            <span class="s1">multi_byte_chars = set()</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">characters:</span>
                <span class="s1">ccode = c</span>
                <span class="s1">gind = font.get_char_index(ccode)</span>
                <span class="s1">glyph_ids.append(gind)</span>
                <span class="s1">glyph_name = font.get_glyph_name(gind)</span>
                <span class="s2">if </span><span class="s1">ccode &lt;= </span><span class="s5">255</span><span class="s1">:</span>
                    <span class="s1">differences.append((ccode</span><span class="s2">, </span><span class="s1">glyph_name))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">multi_byte_chars.add(glyph_name)</span>
            <span class="s1">differences.sort()</span>

            <span class="s1">last_c = -</span><span class="s5">2</span>
            <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">differences:</span>
                <span class="s2">if </span><span class="s1">c != last_c + </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">differencesArray.append(c)</span>
                <span class="s1">differencesArray.append(Name(name))</span>
                <span class="s1">last_c = c</span>

            <span class="s3"># Make the charprocs array.</span>
            <span class="s1">rawcharprocs = _get_pdf_charprocs(filename</span><span class="s2">, </span><span class="s1">glyph_ids)</span>
            <span class="s1">charprocs = {}</span>
            <span class="s2">for </span><span class="s1">charname </span><span class="s2">in </span><span class="s1">sorted(rawcharprocs):</span>
                <span class="s1">stream = rawcharprocs[charname]</span>
                <span class="s1">charprocDict = {}</span>
                <span class="s3"># The 2-byte characters are used as XObjects, so they</span>
                <span class="s3"># need extra info in their dictionary</span>
                <span class="s2">if </span><span class="s1">charname </span><span class="s2">in </span><span class="s1">multi_byte_chars:</span>
                    <span class="s1">charprocDict = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Form'</span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s4">'BBox'</span><span class="s1">: bbox}</span>
                    <span class="s3"># Each glyph includes bounding box information,</span>
                    <span class="s3"># but xpdf and ghostscript can't handle it in a</span>
                    <span class="s3"># Form XObject (they segfault!!!), so we remove it</span>
                    <span class="s3"># from the stream here.  It's not needed anyway,</span>
                    <span class="s3"># since the Form XObject includes it in its BBox</span>
                    <span class="s3"># value.</span>
                    <span class="s1">stream = stream[stream.find(</span><span class="s6">b&quot;d1&quot;</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">:]</span>
                <span class="s1">charprocObject = self.reserveObject(</span><span class="s4">'charProc'</span><span class="s1">)</span>
                <span class="s1">self.outputStream(charprocObject</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">extra=charprocDict)</span>

                <span class="s3"># Send the glyphs with ccode &gt; 255 to the XObject dictionary,</span>
                <span class="s3"># and the others to the font itself</span>
                <span class="s2">if </span><span class="s1">charname </span><span class="s2">in </span><span class="s1">multi_byte_chars:</span>
                    <span class="s1">name = self._get_xobject_glyph_name(filename</span><span class="s2">, </span><span class="s1">charname)</span>
                    <span class="s1">self.multi_byte_charprocs[name] = charprocObject</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">charprocs[charname] = charprocObject</span>

            <span class="s3"># Write everything out</span>
            <span class="s1">self.writeObject(fontdictObject</span><span class="s2">, </span><span class="s1">fontdict)</span>
            <span class="s1">self.writeObject(fontdescObject</span><span class="s2">, </span><span class="s1">descriptor)</span>
            <span class="s1">self.writeObject(widthsObject</span><span class="s2">, </span><span class="s1">widths)</span>
            <span class="s1">self.writeObject(charprocsObject</span><span class="s2">, </span><span class="s1">charprocs)</span>

            <span class="s2">return </span><span class="s1">fontdictObject</span>

        <span class="s2">def </span><span class="s1">embedTTFType42(font</span><span class="s2">, </span><span class="s1">characters</span><span class="s2">, </span><span class="s1">descriptor):</span>
            <span class="s0">&quot;&quot;&quot;The Type 42-specific part of embedding a Truetype font&quot;&quot;&quot;</span>
            <span class="s1">fontdescObject = self.reserveObject(</span><span class="s4">'font descriptor'</span><span class="s1">)</span>
            <span class="s1">cidFontDictObject = self.reserveObject(</span><span class="s4">'CID font dictionary'</span><span class="s1">)</span>
            <span class="s1">type0FontDictObject = self.reserveObject(</span><span class="s4">'Type 0 font dictionary'</span><span class="s1">)</span>
            <span class="s1">cidToGidMapObject = self.reserveObject(</span><span class="s4">'CIDToGIDMap stream'</span><span class="s1">)</span>
            <span class="s1">fontfileObject = self.reserveObject(</span><span class="s4">'font file stream'</span><span class="s1">)</span>
            <span class="s1">wObject = self.reserveObject(</span><span class="s4">'Type 0 widths'</span><span class="s1">)</span>
            <span class="s1">toUnicodeMapObject = self.reserveObject(</span><span class="s4">'ToUnicode map'</span><span class="s1">)</span>

            <span class="s1">subset_str = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(chr(c) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">characters)</span>
            <span class="s1">_log.debug(</span><span class="s4">&quot;SUBSET %s characters: %s&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">subset_str)</span>
            <span class="s1">fontdata = _backend_pdf_ps.get_glyphs_subset(filename</span><span class="s2">, </span><span class="s1">subset_str)</span>
            <span class="s1">_log.debug(</span>
                <span class="s4">&quot;SUBSET %s %d -&gt; %d&quot;</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">,</span>
                <span class="s1">os.stat(filename).st_size</span><span class="s2">, </span><span class="s1">fontdata.getbuffer().nbytes</span>
            <span class="s1">)</span>

            <span class="s3"># We need this ref for XObjects</span>
            <span class="s1">full_font = font</span>

            <span class="s3"># reload the font object from the subset</span>
            <span class="s3"># (all the necessary data could probably be obtained directly</span>
            <span class="s3"># using fontLib.ttLib)</span>
            <span class="s1">font = FT2Font(fontdata)</span>

            <span class="s1">cidFontDict = {</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Font'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'CIDFontType2'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'BaseFont'</span><span class="s1">: ps_name</span><span class="s2">,</span>
                <span class="s4">'CIDSystemInfo'</span><span class="s1">: {</span>
                    <span class="s4">'Registry'</span><span class="s1">: </span><span class="s4">'Adobe'</span><span class="s2">,</span>
                    <span class="s4">'Ordering'</span><span class="s1">: </span><span class="s4">'Identity'</span><span class="s2">,</span>
                    <span class="s4">'Supplement'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span><span class="s2">,</span>
                <span class="s4">'FontDescriptor'</span><span class="s1">: fontdescObject</span><span class="s2">,</span>
                <span class="s4">'W'</span><span class="s1">: wObject</span><span class="s2">,</span>
                <span class="s4">'CIDToGIDMap'</span><span class="s1">: cidToGidMapObject</span>
                <span class="s1">}</span>

            <span class="s1">type0FontDict = {</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Font'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Type0'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'BaseFont'</span><span class="s1">: ps_name</span><span class="s2">,</span>
                <span class="s4">'Encoding'</span><span class="s1">: Name(</span><span class="s4">'Identity-H'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'DescendantFonts'</span><span class="s1">: [cidFontDictObject]</span><span class="s2">,</span>
                <span class="s4">'ToUnicode'</span><span class="s1">: toUnicodeMapObject</span>
                <span class="s1">}</span>

            <span class="s3"># Make fontfile stream</span>
            <span class="s1">descriptor[</span><span class="s4">'FontFile2'</span><span class="s1">] = fontfileObject</span>
            <span class="s1">self.outputStream(</span>
                <span class="s1">fontfileObject</span><span class="s2">, </span><span class="s1">fontdata.getvalue()</span><span class="s2">,</span>
                <span class="s1">extra={</span><span class="s4">'Length1'</span><span class="s1">: fontdata.getbuffer().nbytes})</span>

            <span class="s3"># Make the 'W' (Widths) array, CidToGidMap and ToUnicode CMap</span>
            <span class="s3"># at the same time</span>
            <span class="s1">cid_to_gid_map = [</span><span class="s4">'</span><span class="s2">\0</span><span class="s4">'</span><span class="s1">] * </span><span class="s5">65536</span>
            <span class="s1">widths = []</span>
            <span class="s1">max_ccode = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">characters:</span>
                <span class="s1">ccode = c</span>
                <span class="s1">gind = font.get_char_index(ccode)</span>
                <span class="s1">glyph = font.load_char(ccode</span><span class="s2">,</span>
                                       <span class="s1">flags=LOAD_NO_SCALE | LOAD_NO_HINTING)</span>
                <span class="s1">widths.append((ccode</span><span class="s2">, </span><span class="s1">cvt(glyph.horiAdvance)))</span>
                <span class="s2">if </span><span class="s1">ccode &lt; </span><span class="s5">65536</span><span class="s1">:</span>
                    <span class="s1">cid_to_gid_map[ccode] = chr(gind)</span>
                <span class="s1">max_ccode = max(ccode</span><span class="s2">, </span><span class="s1">max_ccode)</span>
            <span class="s1">widths.sort()</span>
            <span class="s1">cid_to_gid_map = cid_to_gid_map[:max_ccode + </span><span class="s5">1</span><span class="s1">]</span>

            <span class="s1">last_ccode = -</span><span class="s5">2</span>
            <span class="s1">w = []</span>
            <span class="s1">max_width = </span><span class="s5">0</span>
            <span class="s1">unicode_groups = []</span>
            <span class="s2">for </span><span class="s1">ccode</span><span class="s2">, </span><span class="s1">width </span><span class="s2">in </span><span class="s1">widths:</span>
                <span class="s2">if </span><span class="s1">ccode != last_ccode + </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">w.append(ccode)</span>
                    <span class="s1">w.append([width])</span>
                    <span class="s1">unicode_groups.append([ccode</span><span class="s2">, </span><span class="s1">ccode])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">w[-</span><span class="s5">1</span><span class="s1">].append(width)</span>
                    <span class="s1">unicode_groups[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">] = ccode</span>
                <span class="s1">max_width = max(max_width</span><span class="s2">, </span><span class="s1">width)</span>
                <span class="s1">last_ccode = ccode</span>

            <span class="s1">unicode_bfrange = []</span>
            <span class="s2">for </span><span class="s1">start</span><span class="s2">, </span><span class="s1">end </span><span class="s2">in </span><span class="s1">unicode_groups:</span>
                <span class="s3"># Ensure the CID map contains only chars from BMP</span>
                <span class="s2">if </span><span class="s1">start &gt; </span><span class="s5">65535</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s1">end = min(</span><span class="s5">65535</span><span class="s2">, </span><span class="s1">end)</span>

                <span class="s1">unicode_bfrange.append(</span>
                    <span class="s6">b&quot;&lt;%04x&gt; &lt;%04x&gt; [%s]&quot; </span><span class="s1">%</span>
                    <span class="s1">(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">,</span>
                     <span class="s6">b&quot; &quot;</span><span class="s1">.join(</span><span class="s6">b&quot;&lt;%04x&gt;&quot; </span><span class="s1">% x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">range(start</span><span class="s2">, </span><span class="s1">end+</span><span class="s5">1</span><span class="s1">))))</span>
            <span class="s1">unicode_cmap = (self._identityToUnicodeCMap %</span>
                            <span class="s1">(len(unicode_groups)</span><span class="s2">, </span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">.join(unicode_bfrange)))</span>

            <span class="s3"># Add XObjects for unsupported chars</span>
            <span class="s1">glyph_ids = []</span>
            <span class="s2">for </span><span class="s1">ccode </span><span class="s2">in </span><span class="s1">characters:</span>
                <span class="s2">if not </span><span class="s1">_font_supports_glyph(fonttype</span><span class="s2">, </span><span class="s1">ccode):</span>
                    <span class="s1">gind = full_font.get_char_index(ccode)</span>
                    <span class="s1">glyph_ids.append(gind)</span>

            <span class="s1">bbox = [cvt(x</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">full_font.bbox]</span>
            <span class="s1">rawcharprocs = _get_pdf_charprocs(filename</span><span class="s2">, </span><span class="s1">glyph_ids)</span>
            <span class="s2">for </span><span class="s1">charname </span><span class="s2">in </span><span class="s1">sorted(rawcharprocs):</span>
                <span class="s1">stream = rawcharprocs[charname]</span>
                <span class="s1">charprocDict = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Form'</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s4">'BBox'</span><span class="s1">: bbox}</span>
                <span class="s3"># Each glyph includes bounding box information,</span>
                <span class="s3"># but xpdf and ghostscript can't handle it in a</span>
                <span class="s3"># Form XObject (they segfault!!!), so we remove it</span>
                <span class="s3"># from the stream here.  It's not needed anyway,</span>
                <span class="s3"># since the Form XObject includes it in its BBox</span>
                <span class="s3"># value.</span>
                <span class="s1">stream = stream[stream.find(</span><span class="s6">b&quot;d1&quot;</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">:]</span>
                <span class="s1">charprocObject = self.reserveObject(</span><span class="s4">'charProc'</span><span class="s1">)</span>
                <span class="s1">self.outputStream(charprocObject</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">extra=charprocDict)</span>

                <span class="s1">name = self._get_xobject_glyph_name(filename</span><span class="s2">, </span><span class="s1">charname)</span>
                <span class="s1">self.multi_byte_charprocs[name] = charprocObject</span>

            <span class="s3"># CIDToGIDMap stream</span>
            <span class="s1">cid_to_gid_map = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(cid_to_gid_map).encode(</span><span class="s4">&quot;utf-16be&quot;</span><span class="s1">)</span>
            <span class="s1">self.outputStream(cidToGidMapObject</span><span class="s2">, </span><span class="s1">cid_to_gid_map)</span>

            <span class="s3"># ToUnicode CMap</span>
            <span class="s1">self.outputStream(toUnicodeMapObject</span><span class="s2">, </span><span class="s1">unicode_cmap)</span>

            <span class="s1">descriptor[</span><span class="s4">'MaxWidth'</span><span class="s1">] = max_width</span>

            <span class="s3"># Write everything out</span>
            <span class="s1">self.writeObject(cidFontDictObject</span><span class="s2">, </span><span class="s1">cidFontDict)</span>
            <span class="s1">self.writeObject(type0FontDictObject</span><span class="s2">, </span><span class="s1">type0FontDict)</span>
            <span class="s1">self.writeObject(fontdescObject</span><span class="s2">, </span><span class="s1">descriptor)</span>
            <span class="s1">self.writeObject(wObject</span><span class="s2">, </span><span class="s1">w)</span>

            <span class="s2">return </span><span class="s1">type0FontDictObject</span>

        <span class="s3"># Beginning of main embedTTF function...</span>

        <span class="s1">ps_name = self._get_subsetted_psname(</span>
            <span class="s1">font.postscript_name</span><span class="s2">,</span>
            <span class="s1">font.get_charmap()</span>
        <span class="s1">)</span>
        <span class="s1">ps_name = ps_name.encode(</span><span class="s4">'ascii'</span><span class="s2">, </span><span class="s4">'replace'</span><span class="s1">)</span>
        <span class="s1">ps_name = Name(ps_name)</span>
        <span class="s1">pclt = font.get_sfnt_table(</span><span class="s4">'pclt'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">{</span><span class="s4">'capHeight'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s4">'xHeight'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span>
        <span class="s1">post = font.get_sfnt_table(</span><span class="s4">'post'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">{</span><span class="s4">'italicAngle'</span><span class="s1">: (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)}</span>
        <span class="s1">ff = font.face_flags</span>
        <span class="s1">sf = font.style_flags</span>

        <span class="s1">flags = </span><span class="s5">0</span>
        <span class="s1">symbolic = </span><span class="s2">False  </span><span class="s3"># ps_name.name in ('Cmsy10', 'Cmmi10', 'Cmex10')</span>
        <span class="s2">if </span><span class="s1">ff &amp; FIXED_WIDTH:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># TODO: serif</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">symbolic:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">5</span>
        <span class="s2">if </span><span class="s1">sf &amp; ITALIC:</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">6</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># TODO: all caps</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">16</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># TODO: small caps</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">17</span>
        <span class="s2">if </span><span class="s5">0</span><span class="s1">:  </span><span class="s3"># TODO: force bold</span>
            <span class="s1">flags |= </span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">18</span>

        <span class="s1">descriptor = {</span>
            <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'FontDescriptor'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'FontName'</span><span class="s1">: ps_name</span><span class="s2">,</span>
            <span class="s4">'Flags'</span><span class="s1">: flags</span><span class="s2">,</span>
            <span class="s4">'FontBBox'</span><span class="s1">: [cvt(x</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">font.bbox]</span><span class="s2">,</span>
            <span class="s4">'Ascent'</span><span class="s1">: cvt(font.ascender</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'Descent'</span><span class="s1">: cvt(font.descender</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'CapHeight'</span><span class="s1">: cvt(pclt[</span><span class="s4">'capHeight'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">nearest=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s4">'XHeight'</span><span class="s1">: cvt(pclt[</span><span class="s4">'xHeight'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s4">'ItalicAngle'</span><span class="s1">: post[</span><span class="s4">'italicAngle'</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,  </span><span class="s3"># ???</span>
            <span class="s4">'StemV'</span><span class="s1">: </span><span class="s5">0  </span><span class="s3"># ???</span>
            <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">fonttype == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">embedTTFType3(font</span><span class="s2">, </span><span class="s1">characters</span><span class="s2">, </span><span class="s1">descriptor)</span>
        <span class="s2">elif </span><span class="s1">fonttype == </span><span class="s5">42</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">embedTTFType42(font</span><span class="s2">, </span><span class="s1">characters</span><span class="s2">, </span><span class="s1">descriptor)</span>

    <span class="s2">def </span><span class="s1">alphaState(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot;Return name of an ExtGState that sets alpha to the given value.&quot;&quot;&quot;</span>

        <span class="s1">state = self.alphaStates.get(alpha</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">state </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">state[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">name = next(self._alpha_state_seq)</span>
        <span class="s1">self.alphaStates[alpha] = \</span>
            <span class="s1">(name</span><span class="s2">, </span><span class="s1">{</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'ExtGState'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'CA'</span><span class="s1">: alpha[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">'ca'</span><span class="s1">: alpha[</span><span class="s5">1</span><span class="s1">]})</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">_soft_mask_state(self</span><span class="s2">, </span><span class="s1">smask):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an ExtGState that sets the soft mask to the given shading. 
 
        Parameters 
        ---------- 
        smask : Reference 
            Reference to a shading in DeviceGray color space, whose luminosity 
            is to be used as the alpha channel. 
 
        Returns 
        ------- 
        Name 
        &quot;&quot;&quot;</span>

        <span class="s1">state = self._soft_mask_states.get(smask</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">state </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">state[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">name = next(self._soft_mask_seq)</span>
        <span class="s1">groupOb = self.reserveObject(</span><span class="s4">'transparency group for soft mask'</span><span class="s1">)</span>
        <span class="s1">self._soft_mask_states[smask] = (</span>
            <span class="s1">name</span><span class="s2">,</span>
            <span class="s1">{</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'ExtGState'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'AIS'</span><span class="s1">: </span><span class="s2">False,</span>
                <span class="s4">'SMask'</span><span class="s1">: {</span>
                    <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Mask'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'S'</span><span class="s1">: Name(</span><span class="s4">'Luminosity'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'BC'</span><span class="s1">: [</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s4">'G'</span><span class="s1">: groupOb</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">)</span>
        <span class="s1">self._soft_mask_groups.append((</span>
            <span class="s1">groupOb</span><span class="s2">,</span>
            <span class="s1">{</span>
                <span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Form'</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">'FormType'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,</span>
                <span class="s4">'Group'</span><span class="s1">: {</span>
                    <span class="s4">'S'</span><span class="s1">: Name(</span><span class="s4">'Transparency'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s4">'CS'</span><span class="s1">: Name(</span><span class="s4">'DeviceGray'</span><span class="s1">)</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s4">'Matrix'</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s4">'Resources'</span><span class="s1">: {</span><span class="s4">'Shading'</span><span class="s1">: {</span><span class="s4">'S'</span><span class="s1">: smask}}</span><span class="s2">,</span>
                <span class="s4">'BBox'</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">[Name(</span><span class="s4">'S'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Op.shading]</span>
        <span class="s1">))</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">writeExtGSTates(self):</span>
        <span class="s1">self.writeObject(</span>
            <span class="s1">self._extGStateObject</span><span class="s2">,</span>
            <span class="s1">dict([</span>
                <span class="s1">*self.alphaStates.values()</span><span class="s2">,</span>
                <span class="s1">*self._soft_mask_states.values()</span>
            <span class="s1">])</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_write_soft_mask_groups(self):</span>
        <span class="s2">for </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">, </span><span class="s1">content </span><span class="s2">in </span><span class="s1">self._soft_mask_groups:</span>
            <span class="s1">self.beginStream(ob.id</span><span class="s2">, None, </span><span class="s1">attributes)</span>
            <span class="s1">self.output(*content)</span>
            <span class="s1">self.endStream()</span>

    <span class="s2">def </span><span class="s1">hatchPattern(self</span><span class="s2">, </span><span class="s1">hatch_style):</span>
        <span class="s3"># The colors may come in as numpy arrays, which aren't hashable</span>
        <span class="s2">if </span><span class="s1">hatch_style </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">edge</span><span class="s2">, </span><span class="s1">face</span><span class="s2">, </span><span class="s1">hatch = hatch_style</span>
            <span class="s2">if </span><span class="s1">edge </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">edge = tuple(edge)</span>
            <span class="s2">if </span><span class="s1">face </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">face = tuple(face)</span>
            <span class="s1">hatch_style = (edge</span><span class="s2">, </span><span class="s1">face</span><span class="s2">, </span><span class="s1">hatch)</span>

        <span class="s1">pattern = self.hatchPatterns.get(hatch_style</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pattern </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">pattern</span>

        <span class="s1">name = next(self._hatch_pattern_seq)</span>
        <span class="s1">self.hatchPatterns[hatch_style] = name</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">writeHatches(self):</span>
        <span class="s1">hatchDict = dict()</span>
        <span class="s1">sidelen = </span><span class="s5">72.0</span>
        <span class="s2">for </span><span class="s1">hatch_style</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.hatchPatterns.items():</span>
            <span class="s1">ob = self.reserveObject(</span><span class="s4">'hatch pattern'</span><span class="s1">)</span>
            <span class="s1">hatchDict[name] = ob</span>
            <span class="s1">res = {</span><span class="s4">'Procsets'</span><span class="s1">:</span>
                   <span class="s1">[Name(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s4">&quot;PDF Text ImageB ImageC ImageI&quot;</span><span class="s1">.split()]}</span>
            <span class="s1">self.beginStream(</span>
                <span class="s1">ob.id</span><span class="s2">, None,</span>
                <span class="s1">{</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'Pattern'</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s4">'PatternType'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s4">'PaintType'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s4">'TilingType'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">,</span>
                 <span class="s4">'BBox'</span><span class="s1">: [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">sidelen</span><span class="s2">, </span><span class="s1">sidelen]</span><span class="s2">,</span>
                 <span class="s4">'XStep'</span><span class="s1">: sidelen</span><span class="s2">, </span><span class="s4">'YStep'</span><span class="s1">: sidelen</span><span class="s2">,</span>
                 <span class="s4">'Resources'</span><span class="s1">: res</span><span class="s2">,</span>
                 <span class="s3"># Change origin to match Agg at top-left.</span>
                 <span class="s4">'Matrix'</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.height * </span><span class="s5">72</span><span class="s1">]})</span>

            <span class="s1">stroke_rgb</span><span class="s2">, </span><span class="s1">fill_rgb</span><span class="s2">, </span><span class="s1">hatch = hatch_style</span>
            <span class="s1">self.output(stroke_rgb[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stroke_rgb[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stroke_rgb[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">Op.setrgb_stroke)</span>
            <span class="s2">if </span><span class="s1">fill_rgb </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.output(fill_rgb[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_rgb[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fill_rgb[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">Op.setrgb_nonstroke</span><span class="s2">,</span>
                            <span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">sidelen</span><span class="s2">, </span><span class="s1">sidelen</span><span class="s2">, </span><span class="s1">Op.rectangle</span><span class="s2">,</span>
                            <span class="s1">Op.fill)</span>

            <span class="s1">self.output(mpl.rcParams[</span><span class="s4">'hatch.linewidth'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setlinewidth)</span>

            <span class="s1">self.output(*self.pathOperations(</span>
                <span class="s1">Path.hatch(hatch)</span><span class="s2">,</span>
                <span class="s1">Affine2D().scale(sidelen)</span><span class="s2">,</span>
                <span class="s1">simplify=</span><span class="s2">False</span><span class="s1">))</span>
            <span class="s1">self.output(Op.fill_stroke)</span>

            <span class="s1">self.endStream()</span>
        <span class="s1">self.writeObject(self.hatchObject</span><span class="s2">, </span><span class="s1">hatchDict)</span>

    <span class="s2">def </span><span class="s1">addGouraudTriangles(self</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a Gouraud triangle shading. 
 
        Parameters 
        ---------- 
        points : np.ndarray 
            Triangle vertices, shape (n, 3, 2) 
            where n = number of triangles, 3 = vertices, 2 = x, y. 
        colors : np.ndarray 
            Vertex colors, shape (n, 3, 1) or (n, 3, 4) 
            as with points, but last dimension is either (gray,) 
            or (r, g, b, alpha). 
 
        Returns 
        ------- 
        Name, Reference 
        &quot;&quot;&quot;</span>
        <span class="s1">name = Name(</span><span class="s4">'GT%d' </span><span class="s1">% len(self.gouraudTriangles))</span>
        <span class="s1">ob = self.reserveObject(</span><span class="s4">f'Gouraud triangle </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self.gouraudTriangles.append((name</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors))</span>
        <span class="s2">return </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ob</span>

    <span class="s2">def </span><span class="s1">writeGouraudTriangles(self):</span>
        <span class="s1">gouraudDict = dict()</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors </span><span class="s2">in </span><span class="s1">self.gouraudTriangles:</span>
            <span class="s1">gouraudDict[name] = ob</span>
            <span class="s1">shape = points.shape</span>
            <span class="s1">flat_points = points.reshape((shape[</span><span class="s5">0</span><span class="s1">] * shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
            <span class="s1">colordim = colors.shape[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">assert </span><span class="s1">colordim </span><span class="s2">in </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">flat_colors = colors.reshape((shape[</span><span class="s5">0</span><span class="s1">] * shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">colordim))</span>
            <span class="s2">if </span><span class="s1">colordim == </span><span class="s5">4</span><span class="s1">:</span>
                <span class="s3"># strip the alpha channel</span>
                <span class="s1">colordim = </span><span class="s5">3</span>
            <span class="s1">points_min = np.min(flat_points</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) - (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">8</span><span class="s1">)</span>
            <span class="s1">points_max = np.max(flat_points</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) + (</span><span class="s5">1 </span><span class="s1">&lt;&lt; </span><span class="s5">8</span><span class="s1">)</span>
            <span class="s1">factor = </span><span class="s5">0xffffffff </span><span class="s1">/ (points_max - points_min)</span>

            <span class="s1">self.beginStream(</span>
                <span class="s1">ob.id</span><span class="s2">, None,</span>
                <span class="s1">{</span><span class="s4">'ShadingType'</span><span class="s1">: </span><span class="s5">4</span><span class="s2">,</span>
                 <span class="s4">'BitsPerCoordinate'</span><span class="s1">: </span><span class="s5">32</span><span class="s2">,</span>
                 <span class="s4">'BitsPerComponent'</span><span class="s1">: </span><span class="s5">8</span><span class="s2">,</span>
                 <span class="s4">'BitsPerFlag'</span><span class="s1">: </span><span class="s5">8</span><span class="s2">,</span>
                 <span class="s4">'ColorSpace'</span><span class="s1">: Name(</span>
                     <span class="s4">'DeviceRGB' </span><span class="s2">if </span><span class="s1">colordim == </span><span class="s5">3 </span><span class="s2">else </span><span class="s4">'DeviceGray'</span>
                 <span class="s1">)</span><span class="s2">,</span>
                 <span class="s4">'AntiAlias'</span><span class="s1">: </span><span class="s2">False,</span>
                 <span class="s4">'Decode'</span><span class="s1">: ([points_min[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">points_max[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">points_min[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">points_max[</span><span class="s5">1</span><span class="s1">]]</span>
                            <span class="s1">+ [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] * colordim)</span><span class="s2">,</span>
                 <span class="s1">})</span>

            <span class="s1">streamarr = np.empty(</span>
                <span class="s1">(shape[</span><span class="s5">0</span><span class="s1">] * shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">dtype=[(</span><span class="s4">'flags'</span><span class="s2">, </span><span class="s4">'u1'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s4">'points'</span><span class="s2">, </span><span class="s4">'&gt;u4'</span><span class="s2">, </span><span class="s1">(</span><span class="s5">2</span><span class="s2">,</span><span class="s1">))</span><span class="s2">,</span>
                       <span class="s1">(</span><span class="s4">'colors'</span><span class="s2">, </span><span class="s4">'u1'</span><span class="s2">, </span><span class="s1">(colordim</span><span class="s2">,</span><span class="s1">))])</span>
            <span class="s1">streamarr[</span><span class="s4">'flags'</span><span class="s1">] = </span><span class="s5">0</span>
            <span class="s1">streamarr[</span><span class="s4">'points'</span><span class="s1">] = (flat_points - points_min) * factor</span>
            <span class="s1">streamarr[</span><span class="s4">'colors'</span><span class="s1">] = flat_colors[:</span><span class="s2">, </span><span class="s1">:colordim] * </span><span class="s5">255.0</span>

            <span class="s1">self.write(streamarr.tobytes())</span>
            <span class="s1">self.endStream()</span>
        <span class="s1">self.writeObject(self.gouraudObject</span><span class="s2">, </span><span class="s1">gouraudDict)</span>

    <span class="s2">def </span><span class="s1">imageObject(self</span><span class="s2">, </span><span class="s1">image):</span>
        <span class="s0">&quot;&quot;&quot;Return name of an image XObject representing the given image.&quot;&quot;&quot;</span>

        <span class="s1">entry = self._images.get(id(image)</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">entry </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">entry[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">name = next(self._image_seq)</span>
        <span class="s1">ob = self.reserveObject(</span><span class="s4">f'image </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">'</span><span class="s1">)</span>
        <span class="s1">self._images[id(image)] = (image</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ob)</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">_unpack(self</span><span class="s2">, </span><span class="s1">im):</span>
        <span class="s0">&quot;&quot;&quot; 
        Unpack image array *im* into ``(data, alpha)``, which have shape 
        ``(height, width, 3)`` (RGB) or ``(height, width, 1)`` (grayscale or 
        alpha), except that alpha is None if the image is fully opaque. 
        &quot;&quot;&quot;</span>
        <span class="s1">im = im[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">im.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">im</span><span class="s2">, None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rgb = im[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>
            <span class="s1">rgb = np.array(rgb</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">'C'</span><span class="s1">)</span>
            <span class="s3"># PDF needs a separate alpha image</span>
            <span class="s2">if </span><span class="s1">im.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">4</span><span class="s1">:</span>
                <span class="s1">alpha = im[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">][...</span><span class="s2">, None</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">np.all(alpha == </span><span class="s5">255</span><span class="s1">):</span>
                    <span class="s1">alpha = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">alpha = np.array(alpha</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">'C'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">alpha = </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">rgb</span><span class="s2">, </span><span class="s1">alpha</span>

    <span class="s2">def </span><span class="s1">_writePng(self</span><span class="s2">, </span><span class="s1">img):</span>
        <span class="s0">&quot;&quot;&quot; 
        Write the image *img* into the pdf file using png 
        predictors with Flate compression. 
        &quot;&quot;&quot;</span>
        <span class="s1">buffer = BytesIO()</span>
        <span class="s1">img.save(buffer</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">&quot;png&quot;</span><span class="s1">)</span>
        <span class="s1">buffer.seek(</span><span class="s5">8</span><span class="s1">)</span>
        <span class="s1">png_data = </span><span class="s6">b''</span>
        <span class="s1">bit_depth = palette = </span><span class="s2">None</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">length</span><span class="s2">, </span><span class="s1">type = struct.unpack(</span><span class="s6">b'!L4s'</span><span class="s2">, </span><span class="s1">buffer.read(</span><span class="s5">8</span><span class="s1">))</span>
            <span class="s2">if </span><span class="s1">type </span><span class="s2">in </span><span class="s1">[</span><span class="s6">b'IHDR'</span><span class="s2">, </span><span class="s6">b'PLTE'</span><span class="s2">, </span><span class="s6">b'IDAT'</span><span class="s1">]:</span>
                <span class="s1">data = buffer.read(length)</span>
                <span class="s2">if </span><span class="s1">len(data) != length:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;truncated data&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">type == </span><span class="s6">b'IHDR'</span><span class="s1">:</span>
                    <span class="s1">bit_depth = int(data[</span><span class="s5">8</span><span class="s1">])</span>
                <span class="s2">elif </span><span class="s1">type == </span><span class="s6">b'PLTE'</span><span class="s1">:</span>
                    <span class="s1">palette = data</span>
                <span class="s2">elif </span><span class="s1">type == </span><span class="s6">b'IDAT'</span><span class="s1">:</span>
                    <span class="s1">png_data += data</span>
            <span class="s2">elif </span><span class="s1">type == </span><span class="s6">b'IEND'</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">buffer.seek(length</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">buffer.seek(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)   </span><span class="s3"># skip CRC</span>
        <span class="s2">return </span><span class="s1">png_data</span><span class="s2">, </span><span class="s1">bit_depth</span><span class="s2">, </span><span class="s1">palette</span>

    <span class="s2">def </span><span class="s1">_writeImg(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">id</span><span class="s2">, </span><span class="s1">smask=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Write the image *data*, of shape ``(height, width, 1)`` (grayscale) or 
        ``(height, width, 3)`` (RGB), as pdf object *id* and with the soft mask 
        (alpha channel) *smask*, which should be either None or a ``(height, 
        width, 1)`` array. 
        &quot;&quot;&quot;</span>
        <span class="s1">height</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">color_channels = data.shape</span>
        <span class="s1">obj = {</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Image'</span><span class="s1">)</span><span class="s2">,</span>
               <span class="s4">'Width'</span><span class="s1">: width</span><span class="s2">,</span>
               <span class="s4">'Height'</span><span class="s1">: height</span><span class="s2">,</span>
               <span class="s4">'ColorSpace'</span><span class="s1">: Name({</span><span class="s5">1</span><span class="s1">: </span><span class="s4">'DeviceGray'</span><span class="s2">,</span>
                                   <span class="s5">3</span><span class="s1">: </span><span class="s4">'DeviceRGB'</span><span class="s1">}[color_channels])</span><span class="s2">,</span>
               <span class="s4">'BitsPerComponent'</span><span class="s1">: </span><span class="s5">8</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">smask:</span>
            <span class="s1">obj[</span><span class="s4">'SMask'</span><span class="s1">] = smask</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.compression'</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">data.shape[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">data = data.squeeze(axis=-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">img = Image.fromarray(data)</span>
            <span class="s1">img_colors = img.getcolors(maxcolors=</span><span class="s5">256</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">color_channels == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">img_colors </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># Convert to indexed color if there are 256 colors or fewer</span>
                <span class="s3"># This can significantly reduce the file size</span>
                <span class="s1">num_colors = len(img_colors)</span>
                <span class="s3"># These constants were converted to IntEnums and deprecated in</span>
                <span class="s3"># Pillow 9.2</span>
                <span class="s1">dither = getattr(Image</span><span class="s2">, </span><span class="s4">'Dither'</span><span class="s2">, </span><span class="s1">Image).NONE</span>
                <span class="s1">pmode = getattr(Image</span><span class="s2">, </span><span class="s4">'Palette'</span><span class="s2">, </span><span class="s1">Image).ADAPTIVE</span>
                <span class="s1">img = img.convert(</span>
                    <span class="s1">mode=</span><span class="s4">'P'</span><span class="s2">, </span><span class="s1">dither=dither</span><span class="s2">, </span><span class="s1">palette=pmode</span><span class="s2">, </span><span class="s1">colors=num_colors</span>
                <span class="s1">)</span>
                <span class="s1">png_data</span><span class="s2">, </span><span class="s1">bit_depth</span><span class="s2">, </span><span class="s1">palette = self._writePng(img)</span>
                <span class="s2">if </span><span class="s1">bit_depth </span><span class="s2">is None or </span><span class="s1">palette </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;invalid PNG header&quot;</span><span class="s1">)</span>
                <span class="s1">palette = palette[:num_colors * </span><span class="s5">3</span><span class="s1">]  </span><span class="s3"># Trim padding</span>
                <span class="s1">obj[</span><span class="s4">'ColorSpace'</span><span class="s1">] = Verbatim(</span>
                    <span class="s6">b'[/Indexed /DeviceRGB %d %s]'</span>
                    <span class="s1">% (num_colors - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">pdfRepr(palette)))</span>
                <span class="s1">obj[</span><span class="s4">'BitsPerComponent'</span><span class="s1">] = bit_depth</span>
                <span class="s1">color_channels = </span><span class="s5">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">png_data</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = self._writePng(img)</span>
            <span class="s1">png = {</span><span class="s4">'Predictor'</span><span class="s1">: </span><span class="s5">10</span><span class="s2">, </span><span class="s4">'Colors'</span><span class="s1">: color_channels</span><span class="s2">, </span><span class="s4">'Columns'</span><span class="s1">: width}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">png = </span><span class="s2">None</span>
        <span class="s1">self.beginStream(</span>
            <span class="s1">id</span><span class="s2">,</span>
            <span class="s1">self.reserveObject(</span><span class="s4">'length of image stream'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">obj</span><span class="s2">,</span>
            <span class="s1">png=png</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">png:</span>
            <span class="s1">self.currentstream.write(png_data)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.currentstream.write(data.tobytes())</span>
        <span class="s1">self.endStream()</span>

    <span class="s2">def </span><span class="s1">writeImages(self):</span>
        <span class="s2">for </span><span class="s1">img</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">ob </span><span class="s2">in </span><span class="s1">self._images.values():</span>
            <span class="s1">data</span><span class="s2">, </span><span class="s1">adata = self._unpack(img)</span>
            <span class="s2">if </span><span class="s1">adata </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">smaskObject = self.reserveObject(</span><span class="s4">&quot;smask&quot;</span><span class="s1">)</span>
                <span class="s1">self._writeImg(adata</span><span class="s2">, </span><span class="s1">smaskObject.id)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">smaskObject = </span><span class="s2">None</span>
            <span class="s1">self._writeImg(data</span><span class="s2">, </span><span class="s1">ob.id</span><span class="s2">, </span><span class="s1">smaskObject)</span>

    <span class="s2">def </span><span class="s1">markerObject(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">stroke</span><span class="s2">, </span><span class="s1">lw</span><span class="s2">, </span><span class="s1">joinstyle</span><span class="s2">,</span>
                     <span class="s1">capstyle):</span>
        <span class="s0">&quot;&quot;&quot;Return name of a marker XObject representing the given path.&quot;&quot;&quot;</span>
        <span class="s3"># self.markers used by markerObject, writeMarkers, close:</span>
        <span class="s3"># mapping from (path operations, fill?, stroke?) to</span>
        <span class="s3">#   [name, object reference, bounding box, linewidth]</span>
        <span class="s3"># This enables different draw_markers calls to share the XObject</span>
        <span class="s3"># if the gc is sufficiently similar: colors etc can vary, but</span>
        <span class="s3"># the choices of whether to fill and whether to stroke cannot.</span>
        <span class="s3"># We need a bounding box enclosing all of the XObject path,</span>
        <span class="s3"># but since line width may vary, we store the maximum of all</span>
        <span class="s3"># occurring line widths in self.markers.</span>
        <span class="s3"># close() is somewhat tightly coupled in that it expects the</span>
        <span class="s3"># first two components of each value in self.markers to be the</span>
        <span class="s3"># name and object reference.</span>
        <span class="s1">pathops = self.pathOperations(path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">simplify=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">key = (tuple(pathops)</span><span class="s2">, </span><span class="s1">bool(fill)</span><span class="s2">, </span><span class="s1">bool(stroke)</span><span class="s2">, </span><span class="s1">joinstyle</span><span class="s2">, </span><span class="s1">capstyle)</span>
        <span class="s1">result = self.markers.get(key)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">name = Name(</span><span class="s4">'M%d' </span><span class="s1">% len(self.markers))</span>
            <span class="s1">ob = self.reserveObject(</span><span class="s4">'marker %d' </span><span class="s1">% len(self.markers))</span>
            <span class="s1">bbox = path.get_extents(trans)</span>
            <span class="s1">self.markers[key] = [name</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">lw]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">result[-</span><span class="s5">1</span><span class="s1">] &lt; lw:</span>
                <span class="s1">result[-</span><span class="s5">1</span><span class="s1">] = lw</span>
            <span class="s1">name = result[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">writeMarkers(self):</span>
        <span class="s2">for </span><span class="s1">((pathops</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">stroke</span><span class="s2">, </span><span class="s1">joinstyle</span><span class="s2">, </span><span class="s1">capstyle)</span><span class="s2">,</span>
             <span class="s1">(name</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">lw)) </span><span class="s2">in </span><span class="s1">self.markers.items():</span>
            <span class="s3"># bbox wraps the exact limits of the control points, so half a line</span>
            <span class="s3"># will appear outside it. If the join style is miter and the line</span>
            <span class="s3"># is not parallel to the edge, then the line will extend even</span>
            <span class="s3"># further. From the PDF specification, Section 8.4.3.5, the miter</span>
            <span class="s3"># limit is miterLength / lineWidth and from Table 52, the default</span>
            <span class="s3"># is 10. With half the miter length outside, that works out to the</span>
            <span class="s3"># following padding:</span>
            <span class="s1">bbox = bbox.padded(lw * </span><span class="s5">5</span><span class="s1">)</span>
            <span class="s1">self.beginStream(</span>
                <span class="s1">ob.id</span><span class="s2">, None,</span>
                <span class="s1">{</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Form'</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s4">'BBox'</span><span class="s1">: list(bbox.extents)})</span>
            <span class="s1">self.output(GraphicsContextPdf.joinstyles[joinstyle]</span><span class="s2">,</span>
                        <span class="s1">Op.setlinejoin)</span>
            <span class="s1">self.output(GraphicsContextPdf.capstyles[capstyle]</span><span class="s2">, </span><span class="s1">Op.setlinecap)</span>
            <span class="s1">self.output(*pathops)</span>
            <span class="s1">self.output(Op.paint_path(fill</span><span class="s2">, </span><span class="s1">stroke))</span>
            <span class="s1">self.endStream()</span>

    <span class="s2">def </span><span class="s1">pathCollectionObject(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">padding</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">stroked):</span>
        <span class="s1">name = Name(</span><span class="s4">'P%d' </span><span class="s1">% len(self.paths))</span>
        <span class="s1">ob = self.reserveObject(</span><span class="s4">'path %d' </span><span class="s1">% len(self.paths))</span>
        <span class="s1">self.paths.append(</span>
            <span class="s1">(name</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">gc.get_joinstyle()</span><span class="s2">, </span><span class="s1">gc.get_capstyle()</span><span class="s2">,</span>
             <span class="s1">padding</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">stroked))</span>
        <span class="s2">return </span><span class="s1">name</span>

    <span class="s2">def </span><span class="s1">writePathCollectionTemplates(self):</span>
        <span class="s2">for </span><span class="s1">(name</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">ob</span><span class="s2">, </span><span class="s1">joinstyle</span><span class="s2">, </span><span class="s1">capstyle</span><span class="s2">, </span><span class="s1">padding</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">,</span>
             <span class="s1">stroked) </span><span class="s2">in </span><span class="s1">self.paths:</span>
            <span class="s1">pathops = self.pathOperations(path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">simplify=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">bbox = path.get_extents(trans)</span>
            <span class="s2">if not </span><span class="s1">np.all(np.isfinite(bbox.extents)):</span>
                <span class="s1">extents = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">bbox = bbox.padded(padding)</span>
                <span class="s1">extents = list(bbox.extents)</span>
            <span class="s1">self.beginStream(</span>
                <span class="s1">ob.id</span><span class="s2">, None,</span>
                <span class="s1">{</span><span class="s4">'Type'</span><span class="s1">: Name(</span><span class="s4">'XObject'</span><span class="s1">)</span><span class="s2">, </span><span class="s4">'Subtype'</span><span class="s1">: Name(</span><span class="s4">'Form'</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s4">'BBox'</span><span class="s1">: extents})</span>
            <span class="s1">self.output(GraphicsContextPdf.joinstyles[joinstyle]</span><span class="s2">,</span>
                        <span class="s1">Op.setlinejoin)</span>
            <span class="s1">self.output(GraphicsContextPdf.capstyles[capstyle]</span><span class="s2">, </span><span class="s1">Op.setlinecap)</span>
            <span class="s1">self.output(*pathops)</span>
            <span class="s1">self.output(Op.paint_path(filled</span><span class="s2">, </span><span class="s1">stroked))</span>
            <span class="s1">self.endStream()</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">pathOperations(path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None, </span><span class="s1">simplify=</span><span class="s2">None, </span><span class="s1">sketch=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">[Verbatim(_path.convert_to_string(</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">clip</span><span class="s2">, </span><span class="s1">simplify</span><span class="s2">, </span><span class="s1">sketch</span><span class="s2">,</span>
            <span class="s5">6</span><span class="s2">,</span>
            <span class="s1">[Op.moveto.value</span><span class="s2">, </span><span class="s1">Op.lineto.value</span><span class="s2">, </span><span class="s6">b''</span><span class="s2">, </span><span class="s1">Op.curveto.value</span><span class="s2">,</span>
             <span class="s1">Op.closepath.value]</span><span class="s2">,</span>
            <span class="s2">True</span><span class="s1">))]</span>

    <span class="s2">def </span><span class="s1">writePath(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">False, </span><span class="s1">sketch=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">clip:</span>
            <span class="s1">clip = (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">self.width * </span><span class="s5">72</span><span class="s2">, </span><span class="s1">self.height * </span><span class="s5">72</span><span class="s1">)</span>
            <span class="s1">simplify = path.should_simplify</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">clip = </span><span class="s2">None</span>
            <span class="s1">simplify = </span><span class="s2">False</span>
        <span class="s1">cmds = self.pathOperations(path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">clip</span><span class="s2">, </span><span class="s1">simplify=simplify</span><span class="s2">,</span>
                                   <span class="s1">sketch=sketch)</span>
        <span class="s1">self.output(*cmds)</span>

    <span class="s2">def </span><span class="s1">reserveObject(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">''</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reserve an ID for an indirect object. 
 
        The name is used for debugging in case we forget to print out 
        the object with writeObject. 
        &quot;&quot;&quot;</span>
        <span class="s1">id = next(self._object_seq)</span>
        <span class="s1">self.xrefTable.append([</span><span class="s2">None, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">name])</span>
        <span class="s2">return </span><span class="s1">Reference(id)</span>

    <span class="s2">def </span><span class="s1">recordXref(self</span><span class="s2">, </span><span class="s1">id):</span>
        <span class="s1">self.xrefTable[id][</span><span class="s5">0</span><span class="s1">] = self.fh.tell() - self.tell_base</span>

    <span class="s2">def </span><span class="s1">writeObject(self</span><span class="s2">, </span><span class="s1">object</span><span class="s2">, </span><span class="s1">contents):</span>
        <span class="s1">self.recordXref(object.id)</span>
        <span class="s1">object.write(contents</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s2">def </span><span class="s1">writeXref(self):</span>
        <span class="s0">&quot;&quot;&quot;Write out the xref table.&quot;&quot;&quot;</span>
        <span class="s1">self.startxref = self.fh.tell() - self.tell_base</span>
        <span class="s1">self.write(</span><span class="s6">b&quot;xref</span><span class="s2">\n</span><span class="s6">0 %d</span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">% len(self.xrefTable))</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(offset</span><span class="s2">, </span><span class="s1">generation</span><span class="s2">, </span><span class="s1">name) </span><span class="s2">in </span><span class="s1">enumerate(self.xrefTable):</span>
            <span class="s2">if </span><span class="s1">offset </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(</span>
                    <span class="s4">'No offset for object %d (%s)' </span><span class="s1">% (i</span><span class="s2">, </span><span class="s1">name))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">key = </span><span class="s6">b&quot;f&quot; </span><span class="s2">if </span><span class="s1">name == </span><span class="s4">'the zero object' </span><span class="s2">else </span><span class="s6">b&quot;n&quot;</span>
                <span class="s1">text = </span><span class="s6">b&quot;%010d %05d %b </span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">% (offset</span><span class="s2">, </span><span class="s1">generation</span><span class="s2">, </span><span class="s1">key)</span>
                <span class="s1">self.write(text)</span>

    <span class="s2">def </span><span class="s1">writeInfoDict(self):</span>
        <span class="s0">&quot;&quot;&quot;Write out the info dictionary, checking it for good form&quot;&quot;&quot;</span>

        <span class="s1">self.infoObject = self.reserveObject(</span><span class="s4">'info'</span><span class="s1">)</span>
        <span class="s1">self.writeObject(self.infoObject</span><span class="s2">, </span><span class="s1">self.infoDict)</span>

    <span class="s2">def </span><span class="s1">writeTrailer(self):</span>
        <span class="s0">&quot;&quot;&quot;Write out the PDF trailer.&quot;&quot;&quot;</span>

        <span class="s1">self.write(</span><span class="s6">b&quot;trailer</span><span class="s2">\n</span><span class="s6">&quot;</span><span class="s1">)</span>
        <span class="s1">self.write(pdfRepr(</span>
            <span class="s1">{</span><span class="s4">'Size'</span><span class="s1">: len(self.xrefTable)</span><span class="s2">,</span>
             <span class="s4">'Root'</span><span class="s1">: self.rootObject</span><span class="s2">,</span>
             <span class="s4">'Info'</span><span class="s1">: self.infoObject}))</span>
        <span class="s3"># Could add 'ID'</span>
        <span class="s1">self.write(</span><span class="s6">b&quot;</span><span class="s2">\n</span><span class="s6">startxref</span><span class="s2">\n</span><span class="s6">%d</span><span class="s2">\n</span><span class="s6">%%%%EOF</span><span class="s2">\n</span><span class="s6">&quot; </span><span class="s1">% self.startxref)</span>


<span class="s2">class </span><span class="s1">RendererPdf(_backend_pdf_ps.RendererPDFPSBase):</span>

    <span class="s1">_afm_font_dir = cbook._get_data_path(</span><span class="s4">&quot;fonts/pdfcorefonts&quot;</span><span class="s1">)</span>
    <span class="s1">_use_afm_rc_name = </span><span class="s4">&quot;pdf.use14corefonts&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file</span><span class="s2">, </span><span class="s1">image_dpi</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s1">super().__init__(width</span><span class="s2">, </span><span class="s1">height)</span>
        <span class="s1">self.file = file</span>
        <span class="s1">self.gc = self.new_gc()</span>
        <span class="s1">self.image_dpi = image_dpi</span>

    <span class="s2">def </span><span class="s1">finalize(self):</span>
        <span class="s1">self.file.output(*self.gc.finalize())</span>

    <span class="s2">def </span><span class="s1">check_gc(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">fillcolor=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">orig_fill = getattr(gc</span><span class="s2">, </span><span class="s4">'_fillcolor'</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">))</span>
        <span class="s1">gc._fillcolor = fillcolor</span>

        <span class="s1">orig_alphas = getattr(gc</span><span class="s2">, </span><span class="s4">'_effective_alphas'</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">gc.get_rgb() </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># It should not matter what color here since linewidth should be</span>
            <span class="s3"># 0 unless affected by global settings in rcParams, hence setting</span>
            <span class="s3"># zero alpha just in case.</span>
            <span class="s1">gc.set_foreground((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">gc._forced_alpha:</span>
            <span class="s1">gc._effective_alphas = (gc._alpha</span><span class="s2">, </span><span class="s1">gc._alpha)</span>
        <span class="s2">elif </span><span class="s1">fillcolor </span><span class="s2">is None or </span><span class="s1">len(fillcolor) &lt; </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">gc._effective_alphas = (gc._rgb[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">gc._effective_alphas = (gc._rgb[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fillcolor[</span><span class="s5">3</span><span class="s1">])</span>

        <span class="s1">delta = self.gc.delta(gc)</span>
        <span class="s2">if </span><span class="s1">delta:</span>
            <span class="s1">self.file.output(*delta)</span>

        <span class="s3"># Restore gc to avoid unwanted side effects</span>
        <span class="s1">gc._fillcolor = orig_fill</span>
        <span class="s1">gc._effective_alphas = orig_alphas</span>

    <span class="s2">def </span><span class="s1">get_image_magnification(self):</span>
        <span class="s2">return </span><span class="s1">self.image_dpi/</span><span class="s5">72.0</span>

    <span class="s2">def </span><span class="s1">draw_image(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">im</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s1">h</span><span class="s2">, </span><span class="s1">w = im.shape[:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">w == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">h == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># If there's no transform, alpha has already been applied</span>
            <span class="s1">gc.set_alpha(</span><span class="s5">1.0</span><span class="s1">)</span>

        <span class="s1">self.check_gc(gc)</span>

        <span class="s1">w = </span><span class="s5">72.0 </span><span class="s1">* w / self.image_dpi</span>
        <span class="s1">h = </span><span class="s5">72.0 </span><span class="s1">* h / self.image_dpi</span>

        <span class="s1">imob = self.file.imageObject(im)</span>

        <span class="s2">if </span><span class="s1">transform </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.file.output(Op.gsave</span><span class="s2">,</span>
                             <span class="s1">w</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">,</span>
                             <span class="s1">imob</span><span class="s2">, </span><span class="s1">Op.use_xobject</span><span class="s2">, </span><span class="s1">Op.grestore)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tr1</span><span class="s2">, </span><span class="s1">tr2</span><span class="s2">, </span><span class="s1">tr3</span><span class="s2">, </span><span class="s1">tr4</span><span class="s2">, </span><span class="s1">tr5</span><span class="s2">, </span><span class="s1">tr6 = transform.frozen().to_values()</span>

            <span class="s1">self.file.output(Op.gsave</span><span class="s2">,</span>
                             <span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">,</span>
                             <span class="s1">tr1</span><span class="s2">, </span><span class="s1">tr2</span><span class="s2">, </span><span class="s1">tr3</span><span class="s2">, </span><span class="s1">tr4</span><span class="s2">, </span><span class="s1">tr5</span><span class="s2">, </span><span class="s1">tr6</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">,</span>
                             <span class="s1">imob</span><span class="s2">, </span><span class="s1">Op.use_xobject</span><span class="s2">, </span><span class="s1">Op.grestore)</span>

    <span class="s2">def </span><span class="s1">draw_path(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">self.check_gc(gc</span><span class="s2">, </span><span class="s1">rgbFace)</span>
        <span class="s1">self.file.writePath(</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">,</span>
            <span class="s1">rgbFace </span><span class="s2">is None and </span><span class="s1">gc.get_hatch_path() </span><span class="s2">is None,</span>
            <span class="s1">gc.get_sketch_params())</span>
        <span class="s1">self.file.output(self.gc.paint())</span>

    <span class="s2">def </span><span class="s1">draw_path_collection(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms</span><span class="s2">,</span>
                             <span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors</span><span class="s2">,</span>
                             <span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">, </span><span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">,</span>
                             <span class="s1">offset_position):</span>
        <span class="s3"># We can only reuse the objects if the presence of fill and</span>
        <span class="s3"># stroke (and the amount of alpha for each) is the same for</span>
        <span class="s3"># all of them</span>
        <span class="s1">can_do_optimization = </span><span class="s2">True</span>
        <span class="s1">facecolors = np.asarray(facecolors)</span>
        <span class="s1">edgecolors = np.asarray(edgecolors)</span>

        <span class="s2">if not </span><span class="s1">len(facecolors):</span>
            <span class="s1">filled = </span><span class="s2">False</span>
            <span class="s1">can_do_optimization = </span><span class="s2">not </span><span class="s1">gc.get_hatch()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">np.all(facecolors[:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] == facecolors[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]):</span>
                <span class="s1">filled = facecolors[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0.0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">can_do_optimization = </span><span class="s2">False</span>

        <span class="s2">if not </span><span class="s1">len(edgecolors):</span>
            <span class="s1">stroked = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">np.all(np.asarray(linewidths) == </span><span class="s5">0.0</span><span class="s1">):</span>
                <span class="s1">stroked = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">np.all(edgecolors[:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] == edgecolors[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]):</span>
                <span class="s1">stroked = edgecolors[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0.0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">can_do_optimization = </span><span class="s2">False</span>

        <span class="s3"># Is the optimization worth it? Rough calculation:</span>
        <span class="s3"># cost of emitting a path in-line is len_path * uses_per_path</span>
        <span class="s3"># cost of XObject is len_path + 5 for the definition,</span>
        <span class="s3">#    uses_per_path for the uses</span>
        <span class="s1">len_path = len(paths[</span><span class="s5">0</span><span class="s1">].vertices) </span><span class="s2">if </span><span class="s1">len(paths) &gt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s5">0</span>
        <span class="s1">uses_per_path = self._iter_collection_uses_per_path(</span>
            <span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors)</span>
        <span class="s1">should_do_optimization = \</span>
            <span class="s1">len_path + uses_per_path + </span><span class="s5">5 </span><span class="s1">&lt; len_path * uses_per_path</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">can_do_optimization) </span><span class="s2">or </span><span class="s1">(</span><span class="s2">not </span><span class="s1">should_do_optimization):</span>
            <span class="s2">return </span><span class="s1">RendererBase.draw_path_collection(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms</span><span class="s2">,</span>
                <span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">, </span><span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors</span><span class="s2">,</span>
                <span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">, </span><span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">,</span>
                <span class="s1">offset_position)</span>

        <span class="s1">padding = np.max(linewidths)</span>
        <span class="s1">path_codes = []</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(path</span><span class="s2">, </span><span class="s1">transform) </span><span class="s2">in </span><span class="s1">enumerate(self._iter_collection_raw_paths(</span>
                <span class="s1">master_transform</span><span class="s2">, </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">all_transforms)):</span>
            <span class="s1">name = self.file.pathCollectionObject(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform</span><span class="s2">, </span><span class="s1">padding</span><span class="s2">, </span><span class="s1">filled</span><span class="s2">, </span><span class="s1">stroked)</span>
            <span class="s1">path_codes.append(name)</span>

        <span class="s1">output = self.file.output</span>
        <span class="s1">output(*self.gc.push())</span>
        <span class="s1">lastx</span><span class="s2">, </span><span class="s1">lasty = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">xo</span><span class="s2">, </span><span class="s1">yo</span><span class="s2">, </span><span class="s1">path_id</span><span class="s2">, </span><span class="s1">gc0</span><span class="s2">, </span><span class="s1">rgbFace </span><span class="s2">in </span><span class="s1">self._iter_collection(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">path_codes</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">, </span><span class="s1">offset_trans</span><span class="s2">,</span>
                <span class="s1">facecolors</span><span class="s2">, </span><span class="s1">edgecolors</span><span class="s2">, </span><span class="s1">linewidths</span><span class="s2">, </span><span class="s1">linestyles</span><span class="s2">,</span>
                <span class="s1">antialiaseds</span><span class="s2">, </span><span class="s1">urls</span><span class="s2">, </span><span class="s1">offset_position):</span>

            <span class="s1">self.check_gc(gc0</span><span class="s2">, </span><span class="s1">rgbFace)</span>
            <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = xo - lastx</span><span class="s2">, </span><span class="s1">yo - lasty</span>
            <span class="s1">output(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">, </span><span class="s1">path_id</span><span class="s2">,</span>
                   <span class="s1">Op.use_xobject)</span>
            <span class="s1">lastx</span><span class="s2">, </span><span class="s1">lasty = xo</span><span class="s2">, </span><span class="s1">yo</span>
        <span class="s1">output(*self.gc.pop())</span>

    <span class="s2">def </span><span class="s1">draw_markers(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">,</span>
                     <span class="s1">rgbFace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s3"># Same logic as in draw_path_collection</span>
        <span class="s1">len_marker_path = len(marker_path)</span>
        <span class="s1">uses = len(path)</span>
        <span class="s2">if </span><span class="s1">len_marker_path * uses &lt; len_marker_path + uses + </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s1">RendererBase.draw_markers(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">,</span>
                                      <span class="s1">path</span><span class="s2">, </span><span class="s1">trans</span><span class="s2">, </span><span class="s1">rgbFace)</span>
            <span class="s2">return</span>

        <span class="s1">self.check_gc(gc</span><span class="s2">, </span><span class="s1">rgbFace)</span>
        <span class="s1">fill = gc.fill(rgbFace)</span>
        <span class="s1">stroke = gc.stroke()</span>

        <span class="s1">output = self.file.output</span>
        <span class="s1">marker = self.file.markerObject(</span>
            <span class="s1">marker_path</span><span class="s2">, </span><span class="s1">marker_trans</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">stroke</span><span class="s2">, </span><span class="s1">self.gc._linewidth</span><span class="s2">,</span>
            <span class="s1">gc.get_joinstyle()</span><span class="s2">, </span><span class="s1">gc.get_capstyle())</span>

        <span class="s1">output(Op.gsave)</span>
        <span class="s1">lastx</span><span class="s2">, </span><span class="s1">lasty = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">vertices</span><span class="s2">, </span><span class="s1">code </span><span class="s2">in </span><span class="s1">path.iter_segments(</span>
                <span class="s1">trans</span><span class="s2">,</span>
                <span class="s1">clip=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.file.width*</span><span class="s5">72</span><span class="s2">, </span><span class="s1">self.file.height*</span><span class="s5">72</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">simplify=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">len(vertices):</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = vertices[-</span><span class="s5">2</span><span class="s1">:]</span>
                <span class="s2">if not </span><span class="s1">(</span><span class="s5">0 </span><span class="s1">&lt;= x &lt;= self.file.width * </span><span class="s5">72</span>
                        <span class="s2">and </span><span class="s5">0 </span><span class="s1">&lt;= y &lt;= self.file.height * </span><span class="s5">72</span><span class="s1">):</span>
                    <span class="s2">continue</span>
                <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x - lastx</span><span class="s2">, </span><span class="s1">y - lasty</span>
                <span class="s1">output(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">,</span>
                       <span class="s1">marker</span><span class="s2">, </span><span class="s1">Op.use_xobject)</span>
                <span class="s1">lastx</span><span class="s2">, </span><span class="s1">lasty = x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s1">output(Op.grestore)</span>

    <span class="s2">def </span><span class="s1">draw_gouraud_triangle(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s1">self.draw_gouraud_triangles(gc</span><span class="s2">, </span><span class="s1">points.reshape((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span><span class="s2">,</span>
                                    <span class="s1">colors.reshape((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">trans)</span>

    <span class="s2">def </span><span class="s1">draw_gouraud_triangles(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s2">assert </span><span class="s1">len(points) == len(colors)</span>
        <span class="s2">if </span><span class="s1">len(points) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return</span>
        <span class="s2">assert </span><span class="s1">points.ndim == </span><span class="s5">3</span>
        <span class="s2">assert </span><span class="s1">points.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">3</span>
        <span class="s2">assert </span><span class="s1">points.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">colors.ndim == </span><span class="s5">3</span>
        <span class="s2">assert </span><span class="s1">colors.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">3</span>
        <span class="s2">assert </span><span class="s1">colors.shape[</span><span class="s5">2</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s1">shape = points.shape</span>
        <span class="s1">points = points.reshape((shape[</span><span class="s5">0</span><span class="s1">] * shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">tpoints = trans.transform(points)</span>
        <span class="s1">tpoints = tpoints.reshape(shape)</span>
        <span class="s1">name</span><span class="s2">, </span><span class="s1">_ = self.file.addGouraudTriangles(tpoints</span><span class="s2">, </span><span class="s1">colors)</span>
        <span class="s1">output = self.file.output</span>

        <span class="s2">if </span><span class="s1">colors.shape[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3"># grayscale</span>
            <span class="s1">gc.set_alpha(</span><span class="s5">1.0</span><span class="s1">)</span>
            <span class="s1">self.check_gc(gc)</span>
            <span class="s1">output(name</span><span class="s2">, </span><span class="s1">Op.shading)</span>
            <span class="s2">return</span>

        <span class="s1">alpha = colors[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">np.allclose(alpha</span><span class="s2">, </span><span class="s1">colors[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]):</span>
            <span class="s3"># single alpha value</span>
            <span class="s1">gc.set_alpha(alpha)</span>
            <span class="s1">self.check_gc(gc)</span>
            <span class="s1">output(name</span><span class="s2">, </span><span class="s1">Op.shading)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># varying alpha: use a soft mask</span>
            <span class="s1">alpha = colors[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">3</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, None</span><span class="s1">]</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">smask_ob = self.file.addGouraudTriangles(tpoints</span><span class="s2">, </span><span class="s1">alpha)</span>
            <span class="s1">gstate = self.file._soft_mask_state(smask_ob)</span>
            <span class="s1">output(Op.gsave</span><span class="s2">, </span><span class="s1">gstate</span><span class="s2">, </span><span class="s1">Op.setgstate</span><span class="s2">,</span>
                   <span class="s1">name</span><span class="s2">, </span><span class="s1">Op.shading</span><span class="s2">,</span>
                   <span class="s1">Op.grestore)</span>

    <span class="s2">def </span><span class="s1">_setup_textpos(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">oldx=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">oldy=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">oldangle=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">angle == oldangle == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self.file.output(x - oldx</span><span class="s2">, </span><span class="s1">y - oldy</span><span class="s2">, </span><span class="s1">Op.textpos)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">angle = math.radians(angle)</span>
            <span class="s1">self.file.output(math.cos(angle)</span><span class="s2">, </span><span class="s1">math.sin(angle)</span><span class="s2">,</span>
                             <span class="s1">-math.sin(angle)</span><span class="s2">, </span><span class="s1">math.cos(angle)</span><span class="s2">,</span>
                             <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.textmatrix)</span>
            <span class="s1">self.file.output(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">Op.textpos)</span>

    <span class="s2">def </span><span class="s1">draw_mathtext(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle):</span>
        <span class="s3"># TODO: fix positioning and encoding</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">descent</span><span class="s2">, </span><span class="s1">glyphs</span><span class="s2">, </span><span class="s1">rects = \</span>
            <span class="s1">self._text2path.mathtext_parser.parse(s</span><span class="s2">, </span><span class="s5">72</span><span class="s2">, </span><span class="s1">prop)</span>

        <span class="s2">if </span><span class="s1">gc.get_url() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.file._annotations[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">].append(_get_link_annotation(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle))</span>

        <span class="s1">fonttype = mpl.rcParams[</span><span class="s4">'pdf.fonttype'</span><span class="s1">]</span>

        <span class="s3"># Set up a global transformation matrix for the whole math expression</span>
        <span class="s1">a = math.radians(angle)</span>
        <span class="s1">self.file.output(Op.gsave)</span>
        <span class="s1">self.file.output(math.cos(a)</span><span class="s2">, </span><span class="s1">math.sin(a)</span><span class="s2">,</span>
                         <span class="s1">-math.sin(a)</span><span class="s2">, </span><span class="s1">math.cos(a)</span><span class="s2">,</span>
                         <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.concat_matrix)</span>

        <span class="s1">self.check_gc(gc</span><span class="s2">, </span><span class="s1">gc._rgb)</span>
        <span class="s1">prev_font = </span><span class="s2">None, None</span>
        <span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s1">unsupported_chars = []</span>

        <span class="s1">self.file.output(Op.begin_text)</span>
        <span class="s2">for </span><span class="s1">font</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy </span><span class="s2">in </span><span class="s1">glyphs:</span>
            <span class="s1">self.file._character_tracker.track_glyph(font</span><span class="s2">, </span><span class="s1">num)</span>
            <span class="s1">fontname = font.fname</span>
            <span class="s2">if not </span><span class="s1">_font_supports_glyph(fonttype</span><span class="s2">, </span><span class="s1">num):</span>
                <span class="s3"># Unsupported chars (i.e. multibyte in Type 3 or beyond BMP in</span>
                <span class="s3"># Type 42) must be emitted separately (below).</span>
                <span class="s1">unsupported_chars.append((font</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">num))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._setup_textpos(ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy)</span>
                <span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy = ox</span><span class="s2">, </span><span class="s1">oy</span>
                <span class="s2">if </span><span class="s1">(fontname</span><span class="s2">, </span><span class="s1">fontsize) != prev_font:</span>
                    <span class="s1">self.file.output(self.file.fontName(fontname)</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">,</span>
                                     <span class="s1">Op.selectfont)</span>
                    <span class="s1">prev_font = fontname</span><span class="s2">, </span><span class="s1">fontsize</span>
                <span class="s1">self.file.output(self.encode_string(chr(num)</span><span class="s2">, </span><span class="s1">fonttype)</span><span class="s2">,</span>
                                 <span class="s1">Op.show)</span>
        <span class="s1">self.file.output(Op.end_text)</span>

        <span class="s2">for </span><span class="s1">font</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">num </span><span class="s2">in </span><span class="s1">unsupported_chars:</span>
            <span class="s1">self._draw_xobject_glyph(</span>
                <span class="s1">font</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">font.get_char_index(num)</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy)</span>

        <span class="s3"># Draw any horizontal lines in the math layout</span>
        <span class="s2">for </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height </span><span class="s2">in </span><span class="s1">rects:</span>
            <span class="s1">self.file.output(Op.gsave</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">,</span>
                             <span class="s1">Op.rectangle</span><span class="s2">, </span><span class="s1">Op.fill</span><span class="s2">, </span><span class="s1">Op.grestore)</span>

        <span class="s3"># Pop off the global transformation</span>
        <span class="s1">self.file.output(Op.grestore)</span>

    <span class="s2">def </span><span class="s1">draw_tex(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">mtext=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">texmanager = self.get_texmanager()</span>
        <span class="s1">fontsize = prop.get_size_in_points()</span>
        <span class="s1">dvifile = texmanager.make_dvi(s</span><span class="s2">, </span><span class="s1">fontsize)</span>
        <span class="s2">with </span><span class="s1">dviread.Dvi(dvifile</span><span class="s2">, </span><span class="s5">72</span><span class="s1">) </span><span class="s2">as </span><span class="s1">dvi:</span>
            <span class="s1">page</span><span class="s2">, </span><span class="s1">= dvi</span>

        <span class="s2">if </span><span class="s1">gc.get_url() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.file._annotations[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">].append(_get_link_annotation(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">page.width</span><span class="s2">, </span><span class="s1">page.height</span><span class="s2">, </span><span class="s1">angle))</span>

        <span class="s3"># Gather font information and do some setup for combining</span>
        <span class="s3"># characters into strings. The variable seq will contain a</span>
        <span class="s3"># sequence of font and text entries. A font entry is a list</span>
        <span class="s3"># ['font', name, size] where name is a Name object for the</span>
        <span class="s3"># font. A text entry is ['text', x, y, glyphs, x+w] where x</span>
        <span class="s3"># and y are the starting coordinates, w is the width, and</span>
        <span class="s3"># glyphs is a list; in this phase it will always contain just</span>
        <span class="s3"># one one-character string, but later it may have longer</span>
        <span class="s3"># strings interspersed with kern amounts.</span>
        <span class="s1">oldfont</span><span class="s2">, </span><span class="s1">seq = </span><span class="s2">None, </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">dvifont</span><span class="s2">, </span><span class="s1">glyph</span><span class="s2">, </span><span class="s1">width </span><span class="s2">in </span><span class="s1">page.text:</span>
            <span class="s2">if </span><span class="s1">dvifont != oldfont:</span>
                <span class="s1">pdfname = self.file.dviFontName(dvifont)</span>
                <span class="s1">seq += [[</span><span class="s4">'font'</span><span class="s2">, </span><span class="s1">pdfname</span><span class="s2">, </span><span class="s1">dvifont.size]]</span>
                <span class="s1">oldfont = dvifont</span>
            <span class="s1">seq += [[</span><span class="s4">'text'</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">[bytes([glyph])]</span><span class="s2">, </span><span class="s1">x1+width]]</span>

        <span class="s3"># Find consecutive text strings with constant y coordinate and</span>
        <span class="s3"># combine into a sequence of strings and kerns, or just one</span>
        <span class="s3"># string (if any kerns would be less than 0.1 points).</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">curx</span><span class="s2">, </span><span class="s1">fontsize = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, None</span>
        <span class="s2">while </span><span class="s1">i &lt; len(seq)-</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">elt</span><span class="s2">, </span><span class="s1">nxt = seq[i:i+</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">elt[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'font'</span><span class="s1">:</span>
                <span class="s1">fontsize = elt[</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s2">elif </span><span class="s1">elt[</span><span class="s5">0</span><span class="s1">] == nxt[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'text' </span><span class="s2">and </span><span class="s1">elt[</span><span class="s5">2</span><span class="s1">] == nxt[</span><span class="s5">2</span><span class="s1">]:</span>
                <span class="s1">offset = elt[</span><span class="s5">4</span><span class="s1">] - nxt[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">abs(offset) &lt; </span><span class="s5">0.1</span><span class="s1">:</span>
                    <span class="s1">elt[</span><span class="s5">3</span><span class="s1">][-</span><span class="s5">1</span><span class="s1">] += nxt[</span><span class="s5">3</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">elt[</span><span class="s5">4</span><span class="s1">] += nxt[</span><span class="s5">4</span><span class="s1">]-nxt[</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">elt[</span><span class="s5">3</span><span class="s1">] += [offset*</span><span class="s5">1000.0</span><span class="s1">/fontsize</span><span class="s2">, </span><span class="s1">nxt[</span><span class="s5">3</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]]</span>
                    <span class="s1">elt[</span><span class="s5">4</span><span class="s1">] = nxt[</span><span class="s5">4</span><span class="s1">]</span>
                <span class="s2">del </span><span class="s1">seq[i+</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s2">continue</span>
            <span class="s1">i += </span><span class="s5">1</span>

        <span class="s3"># Create a transform to map the dvi contents to the canvas.</span>
        <span class="s1">mytrans = Affine2D().rotate_deg(angle).translate(x</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s3"># Output the text.</span>
        <span class="s1">self.check_gc(gc</span><span class="s2">, </span><span class="s1">gc._rgb)</span>
        <span class="s1">self.file.output(Op.begin_text)</span>
        <span class="s1">curx</span><span class="s2">, </span><span class="s1">cury</span><span class="s2">, </span><span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy = </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span>
        <span class="s2">for </span><span class="s1">elt </span><span class="s2">in </span><span class="s1">seq:</span>
            <span class="s2">if </span><span class="s1">elt[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'font'</span><span class="s1">:</span>
                <span class="s1">self.file.output(elt[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">elt[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.selectfont)</span>
            <span class="s2">elif </span><span class="s1">elt[</span><span class="s5">0</span><span class="s1">] == </span><span class="s4">'text'</span><span class="s1">:</span>
                <span class="s1">curx</span><span class="s2">, </span><span class="s1">cury = mytrans.transform((elt[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">elt[</span><span class="s5">2</span><span class="s1">]))</span>
                <span class="s1">self._setup_textpos(curx</span><span class="s2">, </span><span class="s1">cury</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy)</span>
                <span class="s1">oldx</span><span class="s2">, </span><span class="s1">oldy = curx</span><span class="s2">, </span><span class="s1">cury</span>
                <span class="s2">if </span><span class="s1">len(elt[</span><span class="s5">3</span><span class="s1">]) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">self.file.output(elt[</span><span class="s5">3</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.show)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.file.output(elt[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.showkern)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert False</span>
        <span class="s1">self.file.output(Op.end_text)</span>

        <span class="s3"># Then output the boxes (e.g., variable-length lines of square</span>
        <span class="s3"># roots).</span>
        <span class="s1">boxgc = self.new_gc()</span>
        <span class="s1">boxgc.copy_properties(gc)</span>
        <span class="s1">boxgc.set_linewidth(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">pathops = [Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.LINETO</span><span class="s2">, </span><span class="s1">Path.LINETO</span><span class="s2">, </span><span class="s1">Path.LINETO</span><span class="s2">,</span>
                   <span class="s1">Path.CLOSEPOLY]</span>
        <span class="s2">for </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">page.boxes:</span>
            <span class="s1">path = Path([[x1</span><span class="s2">, </span><span class="s1">y1]</span><span class="s2">, </span><span class="s1">[x1+w</span><span class="s2">, </span><span class="s1">y1]</span><span class="s2">, </span><span class="s1">[x1+w</span><span class="s2">, </span><span class="s1">y1+h]</span><span class="s2">, </span><span class="s1">[x1</span><span class="s2">, </span><span class="s1">y1+h]</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">pathops)</span>
            <span class="s1">self.draw_path(boxgc</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mytrans</span><span class="s2">, </span><span class="s1">gc._rgb)</span>

    <span class="s2">def </span><span class="s1">encode_string(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">fonttype):</span>
        <span class="s2">if </span><span class="s1">fonttype </span><span class="s2">in </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">s.encode(</span><span class="s4">'cp1252'</span><span class="s2">, </span><span class="s4">'replace'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">s.encode(</span><span class="s4">'utf-16be'</span><span class="s2">, </span><span class="s4">'replace'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">draw_text(self</span><span class="s2">, </span><span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">ismath=</span><span class="s2">False, </span><span class="s1">mtext=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s3"># TODO: combine consecutive texts into one BT/ET delimited section</span>

        <span class="s1">self.check_gc(gc</span><span class="s2">, </span><span class="s1">gc._rgb)</span>
        <span class="s2">if </span><span class="s1">ismath:</span>
            <span class="s2">return </span><span class="s1">self.draw_mathtext(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">prop</span><span class="s2">, </span><span class="s1">angle)</span>

        <span class="s1">fontsize = prop.get_size_in_points()</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.use14corefonts'</span><span class="s1">]:</span>
            <span class="s1">font = self._get_font_afm(prop)</span>
            <span class="s1">fonttype = </span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">font = self._get_font_ttf(prop)</span>
            <span class="s1">self.file._character_tracker.track(font</span><span class="s2">, </span><span class="s1">s)</span>
            <span class="s1">fonttype = mpl.rcParams[</span><span class="s4">'pdf.fonttype'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">gc.get_url() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">font.set_text(s)</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = font.get_width_height()</span>
            <span class="s1">self.file._annotations[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">].append(_get_link_annotation(</span>
                <span class="s1">gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">width / </span><span class="s5">64</span><span class="s2">, </span><span class="s1">height / </span><span class="s5">64</span><span class="s2">, </span><span class="s1">angle))</span>

        <span class="s3"># If fonttype is neither 3 nor 42, emit the whole string at once</span>
        <span class="s3"># without manual kerning.</span>
        <span class="s2">if </span><span class="s1">fonttype </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">42</span><span class="s1">]:</span>
            <span class="s1">self.file.output(Op.begin_text</span><span class="s2">,</span>
                             <span class="s1">self.file.fontName(prop)</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">Op.selectfont)</span>
            <span class="s1">self._setup_textpos(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">angle)</span>
            <span class="s1">self.file.output(self.encode_string(s</span><span class="s2">, </span><span class="s1">fonttype)</span><span class="s2">,</span>
                             <span class="s1">Op.show</span><span class="s2">, </span><span class="s1">Op.end_text)</span>

        <span class="s3"># A sequence of characters is broken into multiple chunks. The chunking</span>
        <span class="s3"># serves two purposes:</span>
        <span class="s3">#   - For Type 3 fonts, there is no way to access multibyte characters,</span>
        <span class="s3">#     as they cannot have a CIDMap.  Therefore, in this case we break</span>
        <span class="s3">#     the string into chunks, where each chunk contains either a string</span>
        <span class="s3">#     of consecutive 1-byte characters or a single multibyte character.</span>
        <span class="s3">#   - A sequence of 1-byte characters is split into chunks to allow for</span>
        <span class="s3">#     kerning adjustments between consecutive chunks.</span>
        <span class="s3">#</span>
        <span class="s3"># Each chunk is emitted with a separate command: 1-byte characters use</span>
        <span class="s3"># the regular text show command (TJ) with appropriate kerning between</span>
        <span class="s3"># chunks, whereas multibyte characters use the XObject command (Do).</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># List of (ft_object, start_x, [prev_kern, char, char, ...]),</span>
            <span class="s3"># w/o zero kerns.</span>
            <span class="s1">singlebyte_chunks = []</span>
            <span class="s3"># List of (ft_object, start_x, glyph_index).</span>
            <span class="s1">multibyte_glyphs = []</span>
            <span class="s1">prev_was_multibyte = </span><span class="s2">True</span>
            <span class="s1">prev_font = font</span>
            <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">_text_helpers.layout(</span>
                    <span class="s1">s</span><span class="s2">, </span><span class="s1">font</span><span class="s2">, </span><span class="s1">kern_mode=KERNING_UNFITTED):</span>
                <span class="s2">if </span><span class="s1">_font_supports_glyph(fonttype</span><span class="s2">, </span><span class="s1">ord(item.char)):</span>
                    <span class="s2">if </span><span class="s1">prev_was_multibyte </span><span class="s2">or </span><span class="s1">item.ft_object != prev_font:</span>
                        <span class="s1">singlebyte_chunks.append((item.ft_object</span><span class="s2">, </span><span class="s1">item.x</span><span class="s2">, </span><span class="s1">[]))</span>
                        <span class="s1">prev_font = item.ft_object</span>
                    <span class="s2">if </span><span class="s1">item.prev_kern:</span>
                        <span class="s1">singlebyte_chunks[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">].append(item.prev_kern)</span>
                    <span class="s1">singlebyte_chunks[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">2</span><span class="s1">].append(item.char)</span>
                    <span class="s1">prev_was_multibyte = </span><span class="s2">False</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">multibyte_glyphs.append(</span>
                        <span class="s1">(item.ft_object</span><span class="s2">, </span><span class="s1">item.x</span><span class="s2">, </span><span class="s1">item.glyph_idx)</span>
                    <span class="s1">)</span>
                    <span class="s1">prev_was_multibyte = </span><span class="s2">True</span>
            <span class="s3"># Do the rotation and global translation as a single matrix</span>
            <span class="s3"># concatenation up front</span>
            <span class="s1">self.file.output(Op.gsave)</span>
            <span class="s1">a = math.radians(angle)</span>
            <span class="s1">self.file.output(math.cos(a)</span><span class="s2">, </span><span class="s1">math.sin(a)</span><span class="s2">,</span>
                             <span class="s1">-math.sin(a)</span><span class="s2">, </span><span class="s1">math.cos(a)</span><span class="s2">,</span>
                             <span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.concat_matrix)</span>
            <span class="s3"># Emit all the 1-byte characters in a BT/ET group.</span>

            <span class="s1">self.file.output(Op.begin_text)</span>
            <span class="s1">prev_start_x = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">ft_object</span><span class="s2">, </span><span class="s1">start_x</span><span class="s2">, </span><span class="s1">kerns_or_chars </span><span class="s2">in </span><span class="s1">singlebyte_chunks:</span>
                <span class="s1">ft_name = self.file.fontName(ft_object.fname)</span>
                <span class="s1">self.file.output(ft_name</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">Op.selectfont)</span>
                <span class="s1">self._setup_textpos(start_x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">prev_start_x</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">self.file.output(</span>
                    <span class="s3"># See pdf spec &quot;Text space details&quot; for the 1000/fontsize</span>
                    <span class="s3"># (aka. 1000/T_fs) factor.</span>
                    <span class="s1">[-</span><span class="s5">1000 </span><span class="s1">* next(group) / fontsize </span><span class="s2">if </span><span class="s1">tp == float  </span><span class="s3"># a kern</span>
                     <span class="s2">else </span><span class="s1">self.encode_string(</span><span class="s4">&quot;&quot;</span><span class="s1">.join(group)</span><span class="s2">, </span><span class="s1">fonttype)</span>
                     <span class="s2">for </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">group </span><span class="s2">in </span><span class="s1">itertools.groupby(kerns_or_chars</span><span class="s2">, </span><span class="s1">type)]</span><span class="s2">,</span>
                    <span class="s1">Op.showkern)</span>
                <span class="s1">prev_start_x = start_x</span>
            <span class="s1">self.file.output(Op.end_text)</span>
            <span class="s3"># Then emit all the multibyte characters, one at a time.</span>
            <span class="s2">for </span><span class="s1">ft_object</span><span class="s2">, </span><span class="s1">start_x</span><span class="s2">, </span><span class="s1">glyph_idx </span><span class="s2">in </span><span class="s1">multibyte_glyphs:</span>
                <span class="s1">self._draw_xobject_glyph(</span>
                    <span class="s1">ft_object</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">glyph_idx</span><span class="s2">, </span><span class="s1">start_x</span><span class="s2">, </span><span class="s5">0</span>
                <span class="s1">)</span>
            <span class="s1">self.file.output(Op.grestore)</span>

    <span class="s2">def </span><span class="s1">_draw_xobject_glyph(self</span><span class="s2">, </span><span class="s1">font</span><span class="s2">, </span><span class="s1">fontsize</span><span class="s2">, </span><span class="s1">glyph_idx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot;Draw a multibyte character from a Type 3 font as an XObject.&quot;&quot;&quot;</span>
        <span class="s1">glyph_name = font.get_glyph_name(glyph_idx)</span>
        <span class="s1">name = self.file._get_xobject_glyph_name(font.fname</span><span class="s2">, </span><span class="s1">glyph_name)</span>
        <span class="s1">self.file.output(</span>
            <span class="s1">Op.gsave</span><span class="s2">,</span>
            <span class="s5">0.001 </span><span class="s1">* fontsize</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.001 </span><span class="s1">* fontsize</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">Op.concat_matrix</span><span class="s2">,</span>
            <span class="s1">Name(name)</span><span class="s2">, </span><span class="s1">Op.use_xobject</span><span class="s2">,</span>
            <span class="s1">Op.grestore</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">new_gc(self):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">return </span><span class="s1">GraphicsContextPdf(self.file)</span>


<span class="s2">class </span><span class="s1">GraphicsContextPdf(GraphicsContextBase):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">file):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._fillcolor = (</span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span>
        <span class="s1">self._effective_alphas = (</span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">)</span>
        <span class="s1">self.file = file</span>
        <span class="s1">self.parent = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">d = dict(self.__dict__)</span>
        <span class="s2">del </span><span class="s1">d[</span><span class="s4">'file'</span><span class="s1">]</span>
        <span class="s2">del </span><span class="s1">d[</span><span class="s4">'parent'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">repr(d)</span>

    <span class="s2">def </span><span class="s1">stroke(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predicate: does the path need to be stroked (its outline drawn)? 
        This tests for the various conditions that disable stroking 
        the path, in which case it would presumably be filled. 
        &quot;&quot;&quot;</span>
        <span class="s3"># _linewidth &gt; 0: in pdf a line of width 0 is drawn at minimum</span>
        <span class="s3">#   possible device width, but e.g., agg doesn't draw at all</span>
        <span class="s2">return </span><span class="s1">(self._linewidth &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">self._alpha &gt; </span><span class="s5">0 </span><span class="s2">and</span>
                <span class="s1">(len(self._rgb) &lt;= </span><span class="s5">3 </span><span class="s2">or </span><span class="s1">self._rgb[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0.0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">fill(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Predicate: does the path need to be filled? 
 
        An optional argument can be used to specify an alternative 
        _fillcolor, as needed by RendererPdf.draw_markers. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(args):</span>
            <span class="s1">_fillcolor = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_fillcolor = self._fillcolor</span>
        <span class="s2">return </span><span class="s1">(self._hatch </span><span class="s2">or</span>
                <span class="s1">(_fillcolor </span><span class="s2">is not None and</span>
                 <span class="s1">(len(_fillcolor) &lt;= </span><span class="s5">3 </span><span class="s2">or </span><span class="s1">_fillcolor[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0.0</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">paint(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the appropriate pdf operator to cause the path to be 
        stroked, filled, or both. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">Op.paint_path(self.fill()</span><span class="s2">, </span><span class="s1">self.stroke())</span>

    <span class="s1">capstyles = {</span><span class="s4">'butt'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s4">'round'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s4">'projecting'</span><span class="s1">: </span><span class="s5">2</span><span class="s1">}</span>
    <span class="s1">joinstyles = {</span><span class="s4">'miter'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s4">'round'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s4">'bevel'</span><span class="s1">: </span><span class="s5">2</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">capstyle_cmd(self</span><span class="s2">, </span><span class="s1">style):</span>
        <span class="s2">return </span><span class="s1">[self.capstyles[style]</span><span class="s2">, </span><span class="s1">Op.setlinecap]</span>

    <span class="s2">def </span><span class="s1">joinstyle_cmd(self</span><span class="s2">, </span><span class="s1">style):</span>
        <span class="s2">return </span><span class="s1">[self.joinstyles[style]</span><span class="s2">, </span><span class="s1">Op.setlinejoin]</span>

    <span class="s2">def </span><span class="s1">linewidth_cmd(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s2">return </span><span class="s1">[width</span><span class="s2">, </span><span class="s1">Op.setlinewidth]</span>

    <span class="s2">def </span><span class="s1">dash_cmd(self</span><span class="s2">, </span><span class="s1">dashes):</span>
        <span class="s1">offset</span><span class="s2">, </span><span class="s1">dash = dashes</span>
        <span class="s2">if </span><span class="s1">dash </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dash = []</span>
            <span class="s1">offset = </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">[list(dash)</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">Op.setdash]</span>

    <span class="s2">def </span><span class="s1">alpha_cmd(self</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">forced</span><span class="s2">, </span><span class="s1">effective_alphas):</span>
        <span class="s1">name = self.file.alphaState(effective_alphas)</span>
        <span class="s2">return </span><span class="s1">[name</span><span class="s2">, </span><span class="s1">Op.setgstate]</span>

    <span class="s2">def </span><span class="s1">hatch_cmd(self</span><span class="s2">, </span><span class="s1">hatch</span><span class="s2">, </span><span class="s1">hatch_color):</span>
        <span class="s2">if not </span><span class="s1">hatch:</span>
            <span class="s2">if </span><span class="s1">self._fillcolor </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.fillcolor_cmd(self._fillcolor)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">[Name(</span><span class="s4">'DeviceRGB'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Op.setcolorspace_nonstroke]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">hatch_style = (hatch_color</span><span class="s2">, </span><span class="s1">self._fillcolor</span><span class="s2">, </span><span class="s1">hatch)</span>
            <span class="s1">name = self.file.hatchPattern(hatch_style)</span>
            <span class="s2">return </span><span class="s1">[Name(</span><span class="s4">'Pattern'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Op.setcolorspace_nonstroke</span><span class="s2">,</span>
                    <span class="s1">name</span><span class="s2">, </span><span class="s1">Op.setcolor_nonstroke]</span>

    <span class="s2">def </span><span class="s1">rgb_cmd(self</span><span class="s2">, </span><span class="s1">rgb):</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.inheritcolor'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">if </span><span class="s1">rgb[</span><span class="s5">0</span><span class="s1">] == rgb[</span><span class="s5">1</span><span class="s1">] == rgb[</span><span class="s5">2</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[rgb[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setgray_stroke]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[*rgb[:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setrgb_stroke]</span>

    <span class="s2">def </span><span class="s1">fillcolor_cmd(self</span><span class="s2">, </span><span class="s1">rgb):</span>
        <span class="s2">if </span><span class="s1">rgb </span><span class="s2">is None or </span><span class="s1">mpl.rcParams[</span><span class="s4">'pdf.inheritcolor'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">elif </span><span class="s1">rgb[</span><span class="s5">0</span><span class="s1">] == rgb[</span><span class="s5">1</span><span class="s1">] == rgb[</span><span class="s5">2</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">[rgb[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setgray_nonstroke]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[*rgb[:</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Op.setrgb_nonstroke]</span>

    <span class="s2">def </span><span class="s1">push(self):</span>
        <span class="s1">parent = GraphicsContextPdf(self.file)</span>
        <span class="s1">parent.copy_properties(self)</span>
        <span class="s1">parent.parent = self.parent</span>
        <span class="s1">self.parent = parent</span>
        <span class="s2">return </span><span class="s1">[Op.gsave]</span>

    <span class="s2">def </span><span class="s1">pop(self):</span>
        <span class="s2">assert </span><span class="s1">self.parent </span><span class="s2">is not None</span>
        <span class="s1">self.copy_properties(self.parent)</span>
        <span class="s1">self.parent = self.parent.parent</span>
        <span class="s2">return </span><span class="s1">[Op.grestore]</span>

    <span class="s2">def </span><span class="s1">clip_cmd(self</span><span class="s2">, </span><span class="s1">cliprect</span><span class="s2">, </span><span class="s1">clippath):</span>
        <span class="s0">&quot;&quot;&quot;Set clip rectangle. Calls `.pop()` and `.push()`.&quot;&quot;&quot;</span>
        <span class="s1">cmds = []</span>
        <span class="s3"># Pop graphics state until we hit the right one or the stack is empty</span>
        <span class="s2">while </span><span class="s1">((self._cliprect</span><span class="s2">, </span><span class="s1">self._clippath) != (cliprect</span><span class="s2">, </span><span class="s1">clippath)</span>
                <span class="s2">and </span><span class="s1">self.parent </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s1">cmds.extend(self.pop())</span>
        <span class="s3"># Unless we hit the right one, set the clip polygon</span>
        <span class="s2">if </span><span class="s1">((self._cliprect</span><span class="s2">, </span><span class="s1">self._clippath) != (cliprect</span><span class="s2">, </span><span class="s1">clippath) </span><span class="s2">or</span>
                <span class="s1">self.parent </span><span class="s2">is None</span><span class="s1">):</span>
            <span class="s1">cmds.extend(self.push())</span>
            <span class="s2">if </span><span class="s1">self._cliprect != cliprect:</span>
                <span class="s1">cmds.extend([cliprect</span><span class="s2">, </span><span class="s1">Op.rectangle</span><span class="s2">, </span><span class="s1">Op.clip</span><span class="s2">, </span><span class="s1">Op.endpath])</span>
            <span class="s2">if </span><span class="s1">self._clippath != clippath:</span>
                <span class="s1">path</span><span class="s2">, </span><span class="s1">affine = clippath.get_transformed_path_and_affine()</span>
                <span class="s1">cmds.extend(</span>
                    <span class="s1">PdfFile.pathOperations(path</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">simplify=</span><span class="s2">False</span><span class="s1">) +</span>
                    <span class="s1">[Op.clip</span><span class="s2">, </span><span class="s1">Op.endpath])</span>
        <span class="s2">return </span><span class="s1">cmds</span>

    <span class="s1">commands = (</span>
        <span class="s3"># must come first since may pop</span>
        <span class="s1">((</span><span class="s4">'_cliprect'</span><span class="s2">, </span><span class="s4">'_clippath'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">clip_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_alpha'</span><span class="s2">, </span><span class="s4">'_forced_alpha'</span><span class="s2">, </span><span class="s4">'_effective_alphas'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">alpha_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_capstyle'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">capstyle_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_fillcolor'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">fillcolor_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_joinstyle'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">joinstyle_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_linewidth'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_dashes'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dash_cmd)</span><span class="s2">,</span>
        <span class="s1">((</span><span class="s4">'_rgb'</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rgb_cmd)</span><span class="s2">,</span>
        <span class="s3"># must come after fillcolor and rgb</span>
        <span class="s1">((</span><span class="s4">'_hatch'</span><span class="s2">, </span><span class="s4">'_hatch_color'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">hatch_cmd)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">delta(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy properties of other into self and return PDF commands 
        needed to transform *self* into *other*. 
        &quot;&quot;&quot;</span>
        <span class="s1">cmds = []</span>
        <span class="s1">fill_performed = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">params</span><span class="s2">, </span><span class="s1">cmd </span><span class="s2">in </span><span class="s1">self.commands:</span>
            <span class="s1">different = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">params:</span>
                <span class="s1">ours = getattr(self</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s1">theirs = getattr(other</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">ours </span><span class="s2">is None or </span><span class="s1">theirs </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s1">different = ours </span><span class="s2">is not </span><span class="s1">theirs</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">different = bool(ours != theirs)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s1">ours = np.asarray(ours)</span>
                    <span class="s1">theirs = np.asarray(theirs)</span>
                    <span class="s1">different = (ours.shape != theirs.shape </span><span class="s2">or</span>
                                 <span class="s1">np.any(ours != theirs))</span>
                <span class="s2">if </span><span class="s1">different:</span>
                    <span class="s2">break</span>

            <span class="s3"># Need to update hatching if we also updated fillcolor</span>
            <span class="s2">if </span><span class="s1">params == (</span><span class="s4">'_hatch'</span><span class="s2">, </span><span class="s4">'_hatch_color'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">fill_performed:</span>
                <span class="s1">different = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">different:</span>
                <span class="s2">if </span><span class="s1">params == (</span><span class="s4">'_fillcolor'</span><span class="s2">,</span><span class="s1">):</span>
                    <span class="s1">fill_performed = </span><span class="s2">True</span>
                <span class="s1">theirs = [getattr(other</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">params]</span>
                <span class="s1">cmds.extend(cmd(self</span><span class="s2">, </span><span class="s1">*theirs))</span>
                <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">params:</span>
                    <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">getattr(other</span><span class="s2">, </span><span class="s1">p))</span>
        <span class="s2">return </span><span class="s1">cmds</span>

    <span class="s2">def </span><span class="s1">copy_properties(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Copy properties of other into self. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().copy_properties(other)</span>
        <span class="s1">fillcolor = getattr(other</span><span class="s2">, </span><span class="s4">'_fillcolor'</span><span class="s2">, </span><span class="s1">self._fillcolor)</span>
        <span class="s1">effective_alphas = getattr(other</span><span class="s2">, </span><span class="s4">'_effective_alphas'</span><span class="s2">,</span>
                                   <span class="s1">self._effective_alphas)</span>
        <span class="s1">self._fillcolor = fillcolor</span>
        <span class="s1">self._effective_alphas = effective_alphas</span>

    <span class="s2">def </span><span class="s1">finalize(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make sure every pushed graphics state is popped. 
        &quot;&quot;&quot;</span>
        <span class="s1">cmds = []</span>
        <span class="s2">while </span><span class="s1">self.parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">cmds.extend(self.pop())</span>
        <span class="s2">return </span><span class="s1">cmds</span>


<span class="s2">class </span><span class="s1">PdfPages:</span>
    <span class="s0">&quot;&quot;&quot; 
    A multi-page PDF file. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; # Initialize: 
    &gt;&gt;&gt; with PdfPages('foo.pdf') as pdf: 
    ...     # As many times as you like, create a figure fig and save it: 
    ...     fig = plt.figure() 
    ...     pdf.savefig(fig) 
    ...     # When no figure is specified the current figure is saved 
    ...     pdf.savefig() 
 
    Notes 
    ----- 
    In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid 
    confusion when using `~.pyplot.savefig` and forgetting the format argument. 
    &quot;&quot;&quot;</span>
    <span class="s1">__slots__ = (</span><span class="s4">'_file'</span><span class="s2">, </span><span class="s4">'keep_empty'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">keep_empty=</span><span class="s2">True, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new PdfPages object. 
 
        Parameters 
        ---------- 
        filename : str or path-like or file-like 
            Plots using `PdfPages.savefig` will be written to a file at this 
            location. The file is opened at once and any older file with the 
            same name is overwritten. 
 
        keep_empty : bool, optional 
            If set to False, then empty pdf files will be deleted automatically 
            when closed. 
 
        metadata : dict, optional 
            Information dictionary object (see PDF reference section 10.2.1 
            'Document Information Dictionary'), e.g.: 
            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``. 
 
            The standard keys are 'Title', 'Author', 'Subject', 'Keywords', 
            'Creator', 'Producer', 'CreationDate', 'ModDate', and 
            'Trapped'. Values have been predefined for 'Creator', 'Producer' 
            and 'CreationDate'. They can be removed by setting them to `None`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._file = PdfFile(filename</span><span class="s2">, </span><span class="s1">metadata=metadata)</span>
        <span class="s1">self.keep_empty = keep_empty</span>

    <span class="s2">def </span><span class="s1">__enter__(self):</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__exit__(self</span><span class="s2">, </span><span class="s1">exc_type</span><span class="s2">, </span><span class="s1">exc_val</span><span class="s2">, </span><span class="s1">exc_tb):</span>
        <span class="s1">self.close()</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Finalize this object, making the underlying file a complete 
        PDF file. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._file.finalize()</span>
        <span class="s1">self._file.close()</span>
        <span class="s2">if </span><span class="s1">(self.get_pagecount() == </span><span class="s5">0 </span><span class="s2">and not </span><span class="s1">self.keep_empty </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">self._file.passed_in_file_object):</span>
            <span class="s1">os.remove(self._file.fh.name)</span>
        <span class="s1">self._file = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">infodict(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a modifiable information dictionary object 
        (see PDF reference section 10.2.1 'Document Information 
        Dictionary'). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._file.infoDict</span>

    <span class="s2">def </span><span class="s1">savefig(self</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Save a `.Figure` to this file as a new page. 
 
        Any other keyword arguments are passed to `~.Figure.savefig`. 
 
        Parameters 
        ---------- 
        figure : `.Figure` or int, default: the active figure 
            The figure, or index of the figure, that is saved to the file. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(figure</span><span class="s2">, </span><span class="s1">Figure):</span>
            <span class="s2">if </span><span class="s1">figure </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">manager = Gcf.get_active()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">manager = Gcf.get_fig_manager(figure)</span>
            <span class="s2">if </span><span class="s1">manager </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;No figure {}&quot;</span><span class="s1">.format(figure))</span>
            <span class="s1">figure = manager.canvas.figure</span>
        <span class="s3"># Force use of pdf backend, as PdfPages is tightly coupled with it.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">orig_canvas = figure.canvas</span>
            <span class="s1">figure.canvas = FigureCanvasPdf(figure)</span>
            <span class="s1">figure.savefig(self</span><span class="s2">, </span><span class="s1">format=</span><span class="s4">&quot;pdf&quot;</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">figure.canvas = orig_canvas</span>

    <span class="s2">def </span><span class="s1">get_pagecount(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the current number of pages in the multipage pdf file.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self._file.pageList)</span>

    <span class="s2">def </span><span class="s1">attach_note(self</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">positionRect=[-</span><span class="s5">100</span><span class="s2">, </span><span class="s1">-</span><span class="s5">100</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a new text note to the page to be saved next. The optional 
        positionRect specifies the position of the new note on the 
        page. It is outside the page per default to make sure it is 
        invisible on printouts. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._file.newTextnote(text</span><span class="s2">, </span><span class="s1">positionRect)</span>


<span class="s2">class </span><span class="s1">FigureCanvasPdf(FigureCanvasBase):</span>
    <span class="s3"># docstring inherited</span>

    <span class="s1">fixed_dpi = </span><span class="s5">72</span>
    <span class="s1">filetypes = {</span><span class="s4">'pdf'</span><span class="s1">: </span><span class="s4">'Portable Document Format'</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">get_default_filetype(self):</span>
        <span class="s2">return </span><span class="s4">'pdf'</span>

    <span class="s2">def </span><span class="s1">print_pdf(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                  <span class="s1">bbox_inches_restore=</span><span class="s2">None, </span><span class="s1">metadata=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">dpi = self.figure.dpi</span>
        <span class="s1">self.figure.dpi = </span><span class="s5">72  </span><span class="s3"># there are 72 pdf points to an inch</span>
        <span class="s1">width</span><span class="s2">, </span><span class="s1">height = self.figure.get_size_inches()</span>
        <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">PdfPages):</span>
            <span class="s1">file = filename._file</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">file = PdfFile(filename</span><span class="s2">, </span><span class="s1">metadata=metadata)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">file.newPage(width</span><span class="s2">, </span><span class="s1">height)</span>
            <span class="s1">renderer = MixedModeRenderer(</span>
                <span class="s1">self.figure</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">dpi</span><span class="s2">,</span>
                <span class="s1">RendererPdf(file</span><span class="s2">, </span><span class="s1">dpi</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">width)</span><span class="s2">,</span>
                <span class="s1">bbox_inches_restore=bbox_inches_restore)</span>
            <span class="s1">self.figure.draw(renderer)</span>
            <span class="s1">renderer.finalize()</span>
            <span class="s2">if not </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">PdfPages):</span>
                <span class="s1">file.finalize()</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">PdfPages):  </span><span class="s3"># finish off this page</span>
                <span class="s1">file.endStream()</span>
            <span class="s2">else</span><span class="s1">:            </span><span class="s3"># we opened the file above; now finish it off</span>
                <span class="s1">file.close()</span>

    <span class="s2">def </span><span class="s1">draw(self):</span>
        <span class="s1">self.figure.draw_without_rendering()</span>
        <span class="s2">return </span><span class="s1">super().draw()</span>


<span class="s1">FigureManagerPdf = FigureManagerBase</span>


<span class="s1">@_Backend.export</span>
<span class="s2">class </span><span class="s1">_BackendPdf(_Backend):</span>
    <span class="s1">FigureCanvas = FigureCanvasPdf</span>
</pre>
</body>
</html>