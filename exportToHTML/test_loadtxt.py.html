<html>
<head>
<title>test_loadtxt.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_loadtxt.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests specific to `np.loadtxt` added during the move of loadtxt to be backed 
by C code. 
These tests complement those found in `test_io.py`. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">NamedTemporaryFile</span><span class="s2">, </span><span class="s1">mkstemp</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">StringIO</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.ma.testutils </span><span class="s2">import </span><span class="s1">assert_equal</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_array_equal</span><span class="s2">, </span><span class="s1">HAS_REFCOUNT</span><span class="s2">, </span><span class="s1">IS_PYPY</span>


<span class="s2">def </span><span class="s1">test_scientific_notation():</span>
    <span class="s0">&quot;&quot;&quot;Test that both 'e' and 'E' are parsed correctly.&quot;&quot;&quot;</span>
    <span class="s1">data = StringIO(</span>
        <span class="s1">(</span>
            <span class="s3">&quot;1.0e-1,2.0E1,3.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;4.0e-2,5.0E-1,6.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;7.0e-3,8.0E1,9.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;0.0e-4,1.0E-1,2.0&quot;</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">20.</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.04</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.007</span><span class="s2">, </span><span class="s4">80.</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(np.loadtxt(data</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;comment&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;..&quot;</span><span class="s2">, </span><span class="s3">&quot;//&quot;</span><span class="s2">, </span><span class="s3">&quot;@-&quot;</span><span class="s2">, </span><span class="s3">&quot;this is a comment:&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_comment_multiple_chars(comment):</span>
    <span class="s1">content = </span><span class="s3">&quot;# IGNORE</span><span class="s2">\n</span><span class="s3">1.5, 2.5# ABC</span><span class="s2">\n</span><span class="s3">3.0,4.0# XXX</span><span class="s2">\n</span><span class="s3">5.5,6.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">txt = StringIO(content.replace(</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s1">comment))</span>
    <span class="s1">a = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=comment)</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">6.0</span><span class="s1">]])</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">mixed_types_structured():</span>
    <span class="s0">&quot;&quot;&quot; 
    Fixture providing hetergeneous input data with a structured dtype, along 
    with the associated structured array. 
    &quot;&quot;&quot;</span>
    <span class="s1">data = StringIO(</span>
        <span class="s1">(</span>
            <span class="s3">&quot;1000;2.4;alpha;-34</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;2000;3.1;beta;29</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;3500;9.9;gamma;120</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;4090;8.1;delta;0</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;5001;4.4;epsilon;-99</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;6543;7.8;omega;-1</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">dtype = np.dtype(</span>
        <span class="s1">[(</span><span class="s3">'f0'</span><span class="s2">, </span><span class="s1">np.uint16)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s1">np.float64)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f2'</span><span class="s2">, </span><span class="s3">'S7'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f3'</span><span class="s2">, </span><span class="s1">np.int8)]</span>
    <span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2.4</span><span class="s2">, </span><span class="s3">&quot;alpha&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">34</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">3.1</span><span class="s2">, </span><span class="s3">&quot;beta&quot;</span><span class="s2">, </span><span class="s4">29</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">3500</span><span class="s2">, </span><span class="s4">9.9</span><span class="s2">, </span><span class="s3">&quot;gamma&quot;</span><span class="s2">, </span><span class="s4">120</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">4090</span><span class="s2">, </span><span class="s4">8.1</span><span class="s2">, </span><span class="s3">&quot;delta&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">5001</span><span class="s2">, </span><span class="s4">4.4</span><span class="s2">, </span><span class="s3">&quot;epsilon&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">99</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">6543</span><span class="s2">, </span><span class="s4">7.8</span><span class="s2">, </span><span class="s3">&quot;omega&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=dtype</span>
    <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">expected</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'skiprows'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_structured_dtype_and_skiprows_no_empty_lines(</span>
        <span class="s1">skiprows</span><span class="s2">, </span><span class="s1">mixed_types_structured):</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">expected = mixed_types_structured</span>
    <span class="s1">a = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;;&quot;</span><span class="s2">, </span><span class="s1">skiprows=skiprows)</span>
    <span class="s1">assert_array_equal(a</span><span class="s2">, </span><span class="s1">expected[skiprows:])</span>


<span class="s2">def </span><span class="s1">test_unpack_structured(mixed_types_structured):</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">expected = mixed_types_structured</span>

    <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;;&quot;</span><span class="s2">, </span><span class="s1">unpack=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(a</span><span class="s2">, </span><span class="s1">expected[</span><span class="s3">&quot;f0&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">expected[</span><span class="s3">&quot;f1&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(c</span><span class="s2">, </span><span class="s1">expected[</span><span class="s3">&quot;f2&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(d</span><span class="s2">, </span><span class="s1">expected[</span><span class="s3">&quot;f3&quot;</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_structured_dtype_with_shape():</span>
    <span class="s1">dtype = np.dtype([(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;u1&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;u1&quot;</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;0,1,2,3</span><span class="s2">\n</span><span class="s3">6,7,8,9</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span><span class="s2">, </span><span class="s1">((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s1">))]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">assert_array_equal(np.loadtxt(data</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_structured_dtype_with_multi_shape():</span>
    <span class="s1">dtype = np.dtype([(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;u1&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))])</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;0 1 2 3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([(((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span><span class="s2">,</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">assert_array_equal(np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_nested_structured_subarray():</span>
    <span class="s5"># Test from gh-16678</span>
    <span class="s1">point = np.dtype([(</span><span class="s3">'x'</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'y'</span><span class="s2">, </span><span class="s1">float)])</span>
    <span class="s1">dt = np.dtype([(</span><span class="s3">'code'</span><span class="s2">, </span><span class="s1">int)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'points'</span><span class="s2">, </span><span class="s1">point</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))])</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;100,1,2,3,4</span><span class="s2">\n</span><span class="s3">200,5,6,7,8</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">)])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">200</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">5.</span><span class="s2">, </span><span class="s4">6.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7.</span><span class="s2">, </span><span class="s4">8.</span><span class="s1">)])</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=dt</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_structured_dtype_offsets():</span>
    <span class="s5"># An aligned structured dtype will have additional padding</span>
    <span class="s1">dt = np.dtype(</span><span class="s3">&quot;i1, i4, i1, i4, i1, i4&quot;</span><span class="s2">, </span><span class="s1">align=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;1,2,3,4,5,6</span><span class="s2">\n</span><span class="s3">7,8,9,10,11,12</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dt)</span>
    <span class="s1">assert_array_equal(np.loadtxt(data</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=dt)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;param&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;skiprows&quot;</span><span class="s2">, </span><span class="s3">&quot;max_rows&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_exception_negative_row_limits(param):</span>
    <span class="s0">&quot;&quot;&quot;skiprows and max_rows should raise for negative parameters.&quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be nonnegative&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(</span><span class="s3">&quot;foo.bar&quot;</span><span class="s2">, </span><span class="s1">**{param: -</span><span class="s4">3</span><span class="s1">})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;param&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;skiprows&quot;</span><span class="s2">, </span><span class="s3">&quot;max_rows&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_exception_noninteger_row_limits(param):</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(</span><span class="s3">&quot;foo.bar&quot;</span><span class="s2">, </span><span class="s1">**{param: </span><span class="s4">1.0</span><span class="s1">})</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;data, shape&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;1 2 3 4 5</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span><span class="s2">,  </span><span class="s5"># Single row</span>
        <span class="s1">(</span><span class="s3">&quot;1</span><span class="s2">\n</span><span class="s3">2</span><span class="s2">\n</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">4</span><span class="s2">\n</span><span class="s3">5</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span><span class="s2">,  </span><span class="s5"># Single column</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_ndmin_single_row_or_col(data</span><span class="s2">, </span><span class="s1">shape):</span>
    <span class="s1">arr = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">arr2d = arr.reshape(shape)</span>

    <span class="s1">assert_array_equal(np.loadtxt(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">assert_array_equal(np.loadtxt(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">assert_array_equal(np.loadtxt(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">assert_array_equal(np.loadtxt(StringIO(data)</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">arr2d)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;badval&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, None, </span><span class="s3">&quot;plate of shrimp&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_bad_ndmin(badval):</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Illegal value of ndmin keyword&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(</span><span class="s3">&quot;foo.bar&quot;</span><span class="s2">, </span><span class="s1">ndmin=badval)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ws&quot;</span><span class="s2">,</span>
    <span class="s1">(</span>
            <span class="s3">&quot; &quot;</span><span class="s2">,  </span><span class="s5"># space</span>
            <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># tab</span>
            <span class="s3">&quot;</span><span class="s2">\u2003</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># em</span>
            <span class="s3">&quot;</span><span class="s2">\u00A0</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># non-break</span>
            <span class="s3">&quot;</span><span class="s2">\u3000</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># ideographic space</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_blank_lines_spaces_delimit(ws):</span>
    <span class="s1">txt = StringIO(</span>
        <span class="s3">f&quot;1 2</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">30</span><span class="s2">\n\n{</span><span class="s1">ws</span><span class="s2">}\n</span><span class="s3">&quot;</span>
        <span class="s3">f&quot;4 5 60</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}\n  {</span><span class="s1">ws</span><span class="s2">}  \n</span><span class="s3">&quot;</span>
        <span class="s3">f&quot;7 8 </span><span class="s2">{</span><span class="s1">ws</span><span class="s2">} </span><span class="s3">90</span><span class="s2">\n  </span><span class="s3"># comment</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s3">f&quot;3 2 1&quot;</span>
    <span class="s1">)</span>
    <span class="s5"># NOTE: It is unclear that the `  # comment` should succeed. Except</span>
    <span class="s5">#       for delimiter=None, which should use any whitespace (and maybe</span>
    <span class="s5">#       should just be implemented closer to Python</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">60</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">90</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">assert_equal(</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s2">None, </span><span class="s1">comments=</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_blank_lines_normal_delimiter():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1,2,30</span><span class="s2">\n\n</span><span class="s3">4,5,60</span><span class="s2">\n\n</span><span class="s3">7,8,90</span><span class="s2">\n</span><span class="s3"># comment</span><span class="s2">\n</span><span class="s3">3,2,1'</span><span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">60</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">90</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">assert_equal(</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">','</span><span class="s2">, </span><span class="s1">comments=</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">(float</span><span class="s2">, </span><span class="s1">object))</span>
<span class="s2">def </span><span class="s1">test_maxrows_no_blank_lines(dtype):</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1.5,2.5</span><span class="s2">\n</span><span class="s3">3.0,4.0</span><span class="s2">\n</span><span class="s3">5.5,6.0&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">max_rows=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(res.dtype</span><span class="s2">, </span><span class="s1">dtype)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s3">&quot;1.5&quot;</span><span class="s2">, </span><span class="s3">&quot;2.5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;3.0&quot;</span><span class="s2">, </span><span class="s3">&quot;4.0&quot;</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype))</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">(np.dtype(</span><span class="s3">&quot;f8&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">&quot;i2&quot;</span><span class="s1">)))</span>
<span class="s2">def </span><span class="s1">test_exception_message_bad_values(dtype):</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">3,XXX</span><span class="s2">\n</span><span class="s3">5,6&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">f&quot;could not convert string 'XXX' to </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">} </span><span class="s3">at row 1, column 2&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_converters_negative_indices():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1.5,2.5</span><span class="s2">\n</span><span class="s3">3.0,XXX</span><span class="s2">\n</span><span class="s3">5.5,6.0'</span><span class="s1">)</span>
    <span class="s1">conv = {-</span><span class="s4">1</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">s: np.nan </span><span class="s2">if </span><span class="s1">s == </span><span class="s3">'XXX' </span><span class="s2">else </span><span class="s1">float(s)}</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">6.0</span><span class="s1">]])</span>
    <span class="s1">res = np.loadtxt(</span>
        <span class="s1">txt</span><span class="s2">, </span><span class="s1">dtype=np.float64</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">converters=conv</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_converters_negative_indices_with_usecols():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1.5,2.5,3.5</span><span class="s2">\n</span><span class="s3">3.0,4.0,XXX</span><span class="s2">\n</span><span class="s3">5.5,6.0,7.5</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s1">conv = {-</span><span class="s4">1</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">s: np.nan </span><span class="s2">if </span><span class="s1">s == </span><span class="s3">'XXX' </span><span class="s2">else </span><span class="s1">float(s)}</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">7.5</span><span class="s1">]])</span>
    <span class="s1">res = np.loadtxt(</span>
        <span class="s1">txt</span><span class="s2">,</span>
        <span class="s1">dtype=np.float64</span><span class="s2">,</span>
        <span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
        <span class="s1">converters=conv</span><span class="s2">,</span>
        <span class="s1">usecols=[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">encoding=</span><span class="s2">None,</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s5"># Second test with variable number of rows:</span>
    <span class="s1">res = np.loadtxt(StringIO(</span><span class="s3">'''0,1,2</span><span class="s2">\n</span><span class="s3">0,1,2,3,4'''</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
                     <span class="s1">usecols=[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">converters={-</span><span class="s4">1</span><span class="s1">: (</span><span class="s2">lambda </span><span class="s1">x: -</span><span class="s4">1</span><span class="s1">)})</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]])</span>

<span class="s2">def </span><span class="s1">test_ragged_usecols():</span>
    <span class="s5"># usecols, and negative ones, work even with varying number of columns.</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;0,0,XXX</span><span class="s2">\n</span><span class="s3">0,XXX,0,XXX</span><span class="s2">\n</span><span class="s3">0,XXX,XXX,0,XXX</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">usecols=[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">txt = StringIO(</span><span class="s3">&quot;0,0,XXX</span><span class="s2">\n</span><span class="s3">0</span><span class="s2">\n</span><span class="s3">0,XXX,XXX,0,XXX</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">,</span>
                <span class="s1">match=</span><span class="s3">&quot;invalid column index -2 at row 2 with 1 columns&quot;</span><span class="s1">):</span>
        <span class="s5"># There is no -2 column in the second row:</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">usecols=[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_empty_usecols():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;0,0,XXX</span><span class="s2">\n</span><span class="s3">0,XXX,0,XXX</span><span class="s2">\n</span><span class="s3">0,XXX,XXX,0,XXX</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=np.dtype([])</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">usecols=[])</span>
    <span class="s2">assert </span><span class="s1">res.shape == (</span><span class="s4">3</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">res.dtype == np.dtype([])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;c1&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;の&quot;</span><span class="s2">, </span><span class="s3">&quot;🫕&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;c2&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;の&quot;</span><span class="s2">, </span><span class="s3">&quot;🫕&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_large_unicode_characters(c1</span><span class="s2">, </span><span class="s1">c2):</span>
    <span class="s5"># c1 and c2 span ascii, 16bit and 32bit range.</span>
    <span class="s1">txt = StringIO(</span><span class="s3">f&quot;a,</span><span class="s2">{</span><span class="s1">c1</span><span class="s2">}</span><span class="s3">,c,1.0</span><span class="s2">\n</span><span class="s3">e,</span><span class="s2">{</span><span class="s1">c2</span><span class="s2">}</span><span class="s3">,2.0,g&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">'U12'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span><span class="s3">f&quot;a,</span><span class="s2">{</span><span class="s1">c1</span><span class="s2">}</span><span class="s3">,c,1.0&quot;</span><span class="s1">.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">f&quot;e,</span><span class="s2">{</span><span class="s1">c2</span><span class="s2">}</span><span class="s3">,2.0,g&quot;</span><span class="s1">.split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">dtype=np.dtype(</span><span class="s3">'U12'</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_unicode_with_converter():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;cat,dog</span><span class="s2">\n</span><span class="s3">αβγ,δεζ</span><span class="s2">\n</span><span class="s3">abc,def</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">conv = {</span><span class="s4">0</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">s: s.upper()}</span>
    <span class="s1">res = np.loadtxt(</span>
        <span class="s1">txt</span><span class="s2">,</span>
        <span class="s1">dtype=np.dtype(</span><span class="s3">&quot;U12&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">converters=conv</span><span class="s2">,</span>
        <span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">,</span>
        <span class="s1">encoding=</span><span class="s2">None</span>
    <span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">'CAT'</span><span class="s2">, </span><span class="s3">'dog'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'ΑΒΓ'</span><span class="s2">, </span><span class="s3">'δεζ'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'ABC'</span><span class="s2">, </span><span class="s3">'def'</span><span class="s1">]])</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_converter_with_structured_dtype():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1.5,2.5,Abc</span><span class="s2">\n</span><span class="s3">3.0,4.0,dEf</span><span class="s2">\n</span><span class="s3">5.5,6.0,ghI</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s1">dt = np.dtype([(</span><span class="s3">'m'</span><span class="s2">, </span><span class="s1">np.int32)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">np.float32)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'code'</span><span class="s2">, </span><span class="s3">'U8'</span><span class="s1">)])</span>
    <span class="s1">conv = {</span><span class="s4">0</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">s: int(</span><span class="s4">10</span><span class="s1">*float(s))</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">s: s.upper()}</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">converters=conv)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s3">'ABC'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s3">'DEF'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">55</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s3">'GHI'</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dt</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_converter_with_unicode_dtype():</span>
    <span class="s0">&quot;&quot;&quot; 
    With the default 'bytes' encoding, tokens are encoded prior to being 
    passed to the converter. This means that the output of the converter may 
    be bytes instead of unicode as expected by `read_rows`. 
 
    This test checks that outputs from the above scenario are properly decoded 
    prior to parsing by `read_rows`. 
    &quot;&quot;&quot;</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'abc,def</span><span class="s2">\n</span><span class="s3">rst,xyz'</span><span class="s1">)</span>
    <span class="s1">conv = bytes.upper</span>
    <span class="s1">res = np.loadtxt(</span>
            <span class="s1">txt</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;U3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters=conv</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s3">'ABC'</span><span class="s2">, </span><span class="s3">'DEF'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'RST'</span><span class="s2">, </span><span class="s3">'XYZ'</span><span class="s1">]])</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_huge_row():</span>
    <span class="s1">row = </span><span class="s3">&quot;1.5, 2.5,&quot; </span><span class="s1">* </span><span class="s4">50000</span>
    <span class="s1">row = row[:-</span><span class="s4">1</span><span class="s1">] + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">txt = StringIO(row * </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=float)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">np.tile([</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50000</span><span class="s1">)))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;edfgFDG&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_huge_float(dtype):</span>
    <span class="s5"># Covers a non-optimized path that is rarely taken:</span>
    <span class="s1">field = </span><span class="s3">&quot;0&quot; </span><span class="s1">* </span><span class="s4">1000 </span><span class="s1">+ </span><span class="s3">&quot;.123456789&quot;</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s1">value = np.loadtxt([field]</span><span class="s2">, </span><span class="s1">dtype=dtype)[()]</span>
    <span class="s2">assert </span><span class="s1">value == dtype.type(</span><span class="s3">&quot;0.123456789&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s3">&quot;given_dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;expected_dtype&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">&quot;S5&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s1">np.dtype(</span><span class="s3">&quot;U5&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_string_no_length_given(given_dtype</span><span class="s2">, </span><span class="s1">expected_dtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    The given dtype is just 'S' or 'U' with no length. In these cases, the 
    length of the resulting dtype is determined by the longest string found 
    in the file. 
    &quot;&quot;&quot;</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;AAA,5-1</span><span class="s2">\n</span><span class="s3">BBBBB,0-3</span><span class="s2">\n</span><span class="s3">C,4-9</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=given_dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[[</span><span class="s3">'AAA'</span><span class="s2">, </span><span class="s3">'5-1'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'BBBBB'</span><span class="s2">, </span><span class="s3">'0-3'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'C'</span><span class="s2">, </span><span class="s3">'4-9'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=expected_dtype</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">assert_equal(res.dtype</span><span class="s2">, </span><span class="s1">expected_dtype)</span>


<span class="s2">def </span><span class="s1">test_float_conversion():</span>
    <span class="s0">&quot;&quot;&quot; 
    Some tests that the conversion to float64 works as accurately as the 
    Python built-in `float` function. In a naive version of the float parser, 
    these strings resulted in values that were off by an ULP or two. 
    &quot;&quot;&quot;</span>
    <span class="s1">strings = [</span>
        <span class="s3">'0.9999999999999999'</span><span class="s2">,</span>
        <span class="s3">'9876543210.123456'</span><span class="s2">,</span>
        <span class="s3">'5.43215432154321e+300'</span><span class="s2">,</span>
        <span class="s3">'0.901'</span><span class="s2">,</span>
        <span class="s3">'0.333'</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(strings))</span>
    <span class="s1">res = np.loadtxt(txt)</span>
    <span class="s1">expected = np.array([float(s) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">strings])</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_bool():</span>
    <span class="s5"># Simple test for bool via integer</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1, 0</span><span class="s2">\n</span><span class="s3">10, -1&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=bool</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">res.dtype == bool</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, True</span><span class="s1">]])</span>
    <span class="s5"># Make sure we use only 1 and 0 on the byte level:</span>
    <span class="s1">assert_array_equal(res.view(np.uint8)</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">np.typecodes[</span><span class="s3">&quot;AllInteger&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;error:.*integer via a float.*:DeprecationWarning&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_integer_signs(dtype):</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s2">assert </span><span class="s1">np.loadtxt([</span><span class="s3">&quot;+2&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype) == </span><span class="s4">2</span>
    <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s3">&quot;u&quot;</span><span class="s1">:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.loadtxt([</span><span class="s3">&quot;-1</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">np.loadtxt([</span><span class="s3">&quot;-2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype) == -</span><span class="s4">2</span>

    <span class="s2">for </span><span class="s1">sign </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;++&quot;</span><span class="s2">, </span><span class="s3">&quot;+-&quot;</span><span class="s2">, </span><span class="s3">&quot;--&quot;</span><span class="s2">, </span><span class="s3">&quot;-+&quot;</span><span class="s1">]:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">np.loadtxt([</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">sign</span><span class="s2">}</span><span class="s3">2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">np.typecodes[</span><span class="s3">&quot;AllInteger&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;error:.*integer via a float.*:DeprecationWarning&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_implicit_cast_float_to_int_fails(dtype):</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1.0, 2.1, 3.7</span><span class="s2">\n</span><span class="s3">4, 5, 6&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">(np.complex64</span><span class="s2">, </span><span class="s1">np.complex128))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;with_parens&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s2">False, True</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_complex_parsing(dtype</span><span class="s2">, </span><span class="s1">with_parens):</span>
    <span class="s1">s = </span><span class="s3">&quot;(1.0-2.5j),3.75,(7+-5.0j)</span><span class="s2">\n</span><span class="s3">(4),(-19e2j),(0)&quot;</span>
    <span class="s2">if not </span><span class="s1">with_parens:</span>
        <span class="s1">s = s.replace(</span><span class="s3">&quot;(&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).replace(</span><span class="s3">&quot;)&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">res = np.loadtxt(StringIO(s)</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[[</span><span class="s4">1.0</span><span class="s1">-</span><span class="s4">2.5j</span><span class="s2">, </span><span class="s4">3.75</span><span class="s2">, </span><span class="s4">7</span><span class="s1">-</span><span class="s4">5j</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1900j</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_from_generator():</span>
    <span class="s2">def </span><span class="s1">gen():</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s2">yield </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s4">2</span><span class="s1">*i</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">i**</span><span class="s4">2</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s1">res = np.loadtxt(gen()</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]])</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_from_generator_multitype():</span>
    <span class="s2">def </span><span class="s1">gen():</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">):</span>
            <span class="s2">yield </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s2">} {</span><span class="s1">i / </span><span class="s4">4</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s1">res = np.loadtxt(gen()</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;i, d&quot;</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot; &quot;</span><span class="s1">)</span>
    <span class="s1">expected = np.array([(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;i, d&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_read_from_bad_generator():</span>
    <span class="s2">def </span><span class="s1">gen():</span>
        <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;1,2&quot;</span><span class="s2">, </span><span class="s6">b&quot;3, 5&quot;</span><span class="s2">, </span><span class="s4">12738</span><span class="s1">]:</span>
            <span class="s2">yield </span><span class="s1">entry</span>

    <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">r&quot;non-string returned while reading data&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(gen()</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;i, i&quot;</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s2">not </span><span class="s1">HAS_REFCOUNT</span><span class="s2">, </span><span class="s1">reason=</span><span class="s3">&quot;Python lacks refcounts&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_object_cleanup_on_read_error():</span>
    <span class="s1">sentinel = object()</span>
    <span class="s1">already_read = </span><span class="s4">0</span>

    <span class="s2">def </span><span class="s1">conv(x):</span>
        <span class="s2">nonlocal </span><span class="s1">already_read</span>
        <span class="s2">if </span><span class="s1">already_read &gt; </span><span class="s4">4999</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;failed half-way through!&quot;</span><span class="s1">)</span>
        <span class="s1">already_read += </span><span class="s4">1</span>
        <span class="s2">return </span><span class="s1">sentinel</span>

    <span class="s1">txt = StringIO(</span><span class="s3">&quot;x</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">* </span><span class="s4">10000</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;at row 5000, column 1&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=object</span><span class="s2">, </span><span class="s1">converters={</span><span class="s4">0</span><span class="s1">: conv})</span>

    <span class="s2">assert </span><span class="s1">sys.getrefcount(sentinel) == </span><span class="s4">2</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_character_not_bytes_compatible():</span>
    <span class="s0">&quot;&quot;&quot;Test exception when a character cannot be encoded as 'S'.&quot;&quot;&quot;</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;–&quot;</span><span class="s1">)  </span><span class="s5"># == \u2013</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;S5&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;conv&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">[float]</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_invalid_converter(conv):</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;converters must be a dictionary mapping columns to converter &quot;</span>
        <span class="s3">&quot;functions or a single callable.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2</span><span class="s2">\n</span><span class="s3">3 4&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters=conv)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_converters_dict_raises_non_integer_key():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;keys of the converters dict&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2</span><span class="s2">\n</span><span class="s3">3 4&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters={</span><span class="s3">&quot;a&quot;</span><span class="s1">: int})</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;keys of the converters dict&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2</span><span class="s2">\n</span><span class="s3">3 4&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters={</span><span class="s3">&quot;a&quot;</span><span class="s1">: int}</span><span class="s2">, </span><span class="s1">usecols=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bad_col_ind&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_converters_dict_raises_non_col_key(bad_col_ind):</span>
    <span class="s1">data = StringIO(</span><span class="s3">&quot;1 2</span><span class="s2">\n</span><span class="s3">3 4&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;converter specified for column&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(data</span><span class="s2">, </span><span class="s1">converters={bad_col_ind: int})</span>


<span class="s2">def </span><span class="s1">test_converters_dict_raises_val_not_callable():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">,</span>
                <span class="s1">match=</span><span class="s3">&quot;values of the converters dictionary must be callable&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2</span><span class="s2">\n</span><span class="s3">3 4&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters={</span><span class="s4">0</span><span class="s1">: </span><span class="s4">1</span><span class="s1">})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&quot;'</span><span class="s2">, </span><span class="s3">&quot;'&quot;</span><span class="s2">, </span><span class="s3">&quot;`&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_quoted_field(q):</span>
    <span class="s1">txt = StringIO(</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">alpha, x</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">, 2.5</span><span class="s2">\n{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">beta, y</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">, 4.5</span><span class="s2">\n{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">gamma, z</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">, 5.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">)</span>
    <span class="s1">dtype = np.dtype([(</span><span class="s3">'f0'</span><span class="s2">, </span><span class="s3">'U8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s1">np.float64)])</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[(</span><span class="s3">&quot;alpha, x&quot;</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;beta, y&quot;</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;gamma, z&quot;</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
    <span class="s1">)</span>

    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=q)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;q&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'&quot;'</span><span class="s2">, </span><span class="s3">&quot;'&quot;</span><span class="s2">, </span><span class="s3">&quot;`&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_quoted_field_with_whitepace_delimiter(q):</span>
    <span class="s1">txt = StringIO(</span>
        <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">alpha, x</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}     </span><span class="s3">2.5</span><span class="s2">\n{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">beta, y</span><span class="s2">{</span><span class="s1">q</span><span class="s2">} </span><span class="s3">4.5</span><span class="s2">\n{</span><span class="s1">q</span><span class="s2">}</span><span class="s3">gamma, z</span><span class="s2">{</span><span class="s1">q</span><span class="s2">}   </span><span class="s3">5.0</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">)</span>
    <span class="s1">dtype = np.dtype([(</span><span class="s3">'f0'</span><span class="s2">, </span><span class="s3">'U8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s1">np.float64)])</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[(</span><span class="s3">&quot;alpha, x&quot;</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;beta, y&quot;</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;gamma, z&quot;</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dtype</span>
    <span class="s1">)</span>

    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s2">None, </span><span class="s1">quotechar=q)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_quote_support_default():</span>
    <span class="s0">&quot;&quot;&quot;Support for quoted fields is disabled by default.&quot;&quot;&quot;</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'&quot;lat,long&quot;, 45, 30</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span>
    <span class="s1">dtype = np.dtype([(</span><span class="s3">'f0'</span><span class="s2">, </span><span class="s3">'U24'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s1">np.float64)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f2'</span><span class="s2">, </span><span class="s1">np.float64)])</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;the number of columns changed&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>

    <span class="s5"># Enable quoting support with non-None value for quotechar param</span>
    <span class="s1">txt.seek(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([(</span><span class="s3">&quot;lat,long&quot;</span><span class="s2">, </span><span class="s4">45.</span><span class="s2">, </span><span class="s4">30.</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>

    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_quotechar_multichar_error():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">3,4&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">r&quot;.*must be a single unicode character or None&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;''&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_comment_multichar_error_with_quote():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">3,4&quot;</span><span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;when multiple comments or a multi-character comment is given, &quot;</span>
        <span class="s3">&quot;quotes are not supported.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=</span><span class="s3">&quot;123&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=[</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s3">&quot;%&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>

    <span class="s5"># A single character string in a tuple is unpacked though:</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=(</span><span class="s3">&quot;#&quot;</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;'&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_structured_dtype_with_quotes():</span>
    <span class="s1">data = StringIO(</span>
        <span class="s1">(</span>
            <span class="s3">&quot;1000;2.4;'alpha';-34</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;2000;3.1;'beta';29</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;3500;9.9;'gamma';120</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;4090;8.1;'delta';0</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;5001;4.4;'epsilon';-99</span><span class="s2">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;6543;7.8;'omega';-1</span><span class="s2">\n</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">dtype = np.dtype(</span>
        <span class="s1">[(</span><span class="s3">'f0'</span><span class="s2">, </span><span class="s1">np.uint16)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s1">np.float64)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f2'</span><span class="s2">, </span><span class="s3">'S7'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'f3'</span><span class="s2">, </span><span class="s1">np.int8)]</span>
    <span class="s1">)</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2.4</span><span class="s2">, </span><span class="s3">&quot;alpha&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">34</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">3.1</span><span class="s2">, </span><span class="s3">&quot;beta&quot;</span><span class="s2">, </span><span class="s4">29</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">3500</span><span class="s2">, </span><span class="s4">9.9</span><span class="s2">, </span><span class="s3">&quot;gamma&quot;</span><span class="s2">, </span><span class="s4">120</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">4090</span><span class="s2">, </span><span class="s4">8.1</span><span class="s2">, </span><span class="s3">&quot;delta&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">5001</span><span class="s2">, </span><span class="s4">4.4</span><span class="s2">, </span><span class="s3">&quot;epsilon&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">99</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">6543</span><span class="s2">, </span><span class="s4">7.8</span><span class="s2">, </span><span class="s3">&quot;omega&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">dtype=dtype</span>
    <span class="s1">)</span>
    <span class="s1">res = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;;&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;'&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_quoted_field_is_not_empty():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1</span><span class="s2">\n\n</span><span class="s3">&quot;4&quot;</span><span class="s2">\n</span><span class="s3">&quot;&quot;'</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;4&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U1&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U1&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

<span class="s2">def </span><span class="s1">test_quoted_field_is_not_empty_nonstrict():</span>
    <span class="s5"># Same as test_quoted_field_is_not_empty but check that we are not strict</span>
    <span class="s5"># about missing closing quote (this is the `csv.reader` default also)</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'1</span><span class="s2">\n\n</span><span class="s3">&quot;4&quot;</span><span class="s2">\n</span><span class="s3">&quot;'</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;4&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U1&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U1&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

<span class="s2">def </span><span class="s1">test_consecutive_quotechar_escaped():</span>
    <span class="s1">txt = StringIO(</span><span class="s3">'&quot;Hello, my name is &quot;&quot;Monty&quot;&quot;!&quot;'</span><span class="s1">)</span>
    <span class="s1">expected = np.array(</span><span class="s3">'Hello, my name is &quot;Monty&quot;!'</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U40&quot;</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U40&quot;</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n\n\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;# 1 2 3</span><span class="s2">\n</span><span class="s3"># 4 5 6</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ndmin&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;usecols&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_warn_on_no_data(data</span><span class="s2">, </span><span class="s1">ndmin</span><span class="s2">, </span><span class="s1">usecols):</span>
    <span class="s0">&quot;&quot;&quot;Check that a UserWarning is emitted when no data is read from input.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">usecols </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">expected_shape = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">ndmin == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">expected_shape = (</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># guess a single column?!</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">expected_shape = (</span><span class="s4">0</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s1">txt = StringIO(data)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;input contained no data&quot;</span><span class="s1">):</span>
        <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">ndmin=ndmin</span><span class="s2">, </span><span class="s1">usecols=usecols)</span>
    <span class="s2">assert </span><span class="s1">res.shape == expected_shape</span>

    <span class="s2">with </span><span class="s1">NamedTemporaryFile(mode=</span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fh:</span>
        <span class="s1">fh.write(data)</span>
        <span class="s1">fh.seek(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;input contained no data&quot;</span><span class="s1">):</span>
            <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">ndmin=ndmin</span><span class="s2">, </span><span class="s1">usecols=usecols)</span>
        <span class="s2">assert </span><span class="s1">res.shape == expected_shape</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;skiprows&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_warn_on_skipped_data(skiprows):</span>
    <span class="s1">data = </span><span class="s3">&quot;1 2 3</span><span class="s2">\n</span><span class="s3">4 5 6&quot;</span>
    <span class="s1">txt = StringIO(data)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;input contained no data&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">skiprows=skiprows)</span>


<span class="s1">@pytest.mark.parametrize([</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;value&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;i2&quot;</span><span class="s2">, </span><span class="s4">0x0001</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;u2&quot;</span><span class="s2">, </span><span class="s4">0x0001</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;i4&quot;</span><span class="s2">, </span><span class="s4">0x00010203</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;u4&quot;</span><span class="s2">, </span><span class="s4">0x00010203</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;i8&quot;</span><span class="s2">, </span><span class="s4">0x0001020304050607</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;u8&quot;</span><span class="s2">, </span><span class="s4">0x0001020304050607</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5"># The following values are constructed to lead to unique bytes:</span>
        <span class="s1">(</span><span class="s3">&quot;float16&quot;</span><span class="s2">, </span><span class="s4">3.07e-05</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;float32&quot;</span><span class="s2">, </span><span class="s4">9.2557e-41</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;complex64&quot;</span><span class="s2">, </span><span class="s4">9.2557e-41</span><span class="s1">+</span><span class="s4">2.8622554e-29j</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;float64&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.758571353180402e-24</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s5"># Here and below, the repr side-steps a small loss of precision in</span>
        <span class="s5"># complex `str` in PyPy (which is probably fine, as repr works):</span>
        <span class="s1">(</span><span class="s3">&quot;complex128&quot;</span><span class="s2">, </span><span class="s1">repr(</span><span class="s4">5.406409232372729e-29</span><span class="s1">-</span><span class="s4">1.758571353180402e-24j</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s5"># Use integer values that fit into double.  Everything else leads to</span>
        <span class="s5"># problems due to longdoubles going via double and decimal strings</span>
        <span class="s5"># causing rounding errors.</span>
        <span class="s1">(</span><span class="s3">&quot;longdouble&quot;</span><span class="s2">, </span><span class="s4">0x01020304050607</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;clongdouble&quot;</span><span class="s2">, </span><span class="s1">repr(</span><span class="s4">0x01020304050607 </span><span class="s1">+ (</span><span class="s4">0x00121314151617 </span><span class="s1">* </span><span class="s4">1j</span><span class="s1">)))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;U2&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\U00010203\U000a0b0c</span><span class="s3">&quot;</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;swap&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_byteswapping_and_unaligned(dtype</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">swap):</span>
    <span class="s5"># Try to create &quot;interesting&quot; values within the valid unicode range:</span>
    <span class="s1">dtype = np.dtype(dtype)</span>
    <span class="s1">data = [</span><span class="s3">f&quot;x,</span><span class="s2">{</span><span class="s1">value</span><span class="s2">}\n</span><span class="s3">&quot;</span><span class="s1">]  </span><span class="s5"># repr as PyPy `str` truncates some</span>
    <span class="s2">if </span><span class="s1">swap:</span>
        <span class="s1">dtype = dtype.newbyteorder()</span>
    <span class="s1">full_dt = np.dtype([(</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;S1&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">dtype)]</span><span class="s2">, </span><span class="s1">align=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s5"># The above ensures that the interesting &quot;b&quot; field is unaligned:</span>
    <span class="s2">assert </span><span class="s1">full_dt.fields[</span><span class="s3">&quot;b&quot;</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span>
    <span class="s1">res = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=full_dt</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None,</span>
                     <span class="s1">max_rows=</span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># max-rows prevents over-allocation</span>
    <span class="s2">assert </span><span class="s1">res[</span><span class="s3">&quot;b&quot;</span><span class="s1">] == dtype.type(value)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">,</span>
        <span class="s1">np.typecodes[</span><span class="s3">&quot;AllInteger&quot;</span><span class="s1">] + </span><span class="s3">&quot;efdFD&quot; </span><span class="s1">+ </span><span class="s3">&quot;?&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_unicode_whitespace_stripping(dtype):</span>
    <span class="s5"># Test that all numeric types (and bool) strip whitespace correctly</span>
    <span class="s5"># \u202F is a narrow no-break space, `\n` is just a whitespace if quoted.</span>
    <span class="s5"># Currently, skip float128 as it did not always support this and has no</span>
    <span class="s5"># &quot;custom&quot; parsing:</span>
    <span class="s1">txt = StringIO(</span><span class="s3">' 3 ,&quot;</span><span class="s2">\u202F</span><span class="s3">2</span><span class="s2">\n</span><span class="s3">&quot;'</span><span class="s1">)</span>
    <span class="s1">res = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]).astype(dtype))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;FD&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_unicode_whitespace_stripping_complex(dtype):</span>
    <span class="s5"># Complex has a few extra cases since it has two components and</span>
    <span class="s5"># parentheses</span>
    <span class="s1">line = </span><span class="s3">&quot; 1 , 2+3j , ( 4+5j ), ( 6+-7j )  , 8j , ( 9j ) </span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">data = [line</span><span class="s2">, </span><span class="s1">line.replace(</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\u202F</span><span class="s3">&quot;</span><span class="s1">)]</span>
    <span class="s1">res = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">','</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">+</span><span class="s4">3j</span><span class="s2">, </span><span class="s4">4</span><span class="s1">+</span><span class="s4">5j</span><span class="s2">, </span><span class="s4">6</span><span class="s1">-</span><span class="s4">7j</span><span class="s2">, </span><span class="s4">8j</span><span class="s2">, </span><span class="s4">9j</span><span class="s1">]] * </span><span class="s4">2</span><span class="s1">))</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;FD&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;field&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;1 +2j&quot;</span><span class="s2">, </span><span class="s3">&quot;1+ 2j&quot;</span><span class="s2">, </span><span class="s3">&quot;1+2 j&quot;</span><span class="s2">, </span><span class="s3">&quot;1+-+3&quot;</span><span class="s2">, </span><span class="s3">&quot;(1j&quot;</span><span class="s2">, </span><span class="s3">&quot;(1&quot;</span><span class="s2">, </span><span class="s3">&quot;(1+2j&quot;</span><span class="s2">, </span><span class="s3">&quot;1+2j)&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_bad_complex(dtype</span><span class="s2">, </span><span class="s1">field):</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">np.loadtxt([field + </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">,</span>
            <span class="s1">np.typecodes[</span><span class="s3">&quot;AllInteger&quot;</span><span class="s1">] + </span><span class="s3">&quot;efgdFDG&quot; </span><span class="s1">+ </span><span class="s3">&quot;?&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_nul_character_error(dtype):</span>
    <span class="s5"># Test that a \0 character is correctly recognized as an error even if</span>
    <span class="s5"># what comes before is valid (not everything gets parsed internally).</span>
    <span class="s2">if </span><span class="s1">dtype.lower() == </span><span class="s3">&quot;g&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.xfail(</span><span class="s3">&quot;longdouble/clongdouble assignment may misbehave.&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">np.loadtxt([</span><span class="s3">&quot;1</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">,</span>
        <span class="s1">np.typecodes[</span><span class="s3">&quot;AllInteger&quot;</span><span class="s1">] + </span><span class="s3">&quot;efgdFDG&quot; </span><span class="s1">+ </span><span class="s3">&quot;?&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_no_thousands_support(dtype):</span>
    <span class="s5"># Mainly to document behaviour, Python supports thousands like 1_1.</span>
    <span class="s5"># (e and G may end up using different conversion and support it, this is</span>
    <span class="s5"># a bug but happens...)</span>
    <span class="s2">if </span><span class="s1">dtype == </span><span class="s3">&quot;e&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;half assignment currently uses Python float converter&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">&quot;eG&quot;</span><span class="s1">:</span>
        <span class="s1">pytest.xfail(</span><span class="s3">&quot;clongdouble assignment is buggy (uses `complex`?).&quot;</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">int(</span><span class="s3">&quot;1_1&quot;</span><span class="s1">) == float(</span><span class="s3">&quot;1_1&quot;</span><span class="s1">) == complex(</span><span class="s3">&quot;1_1&quot;</span><span class="s1">) == </span><span class="s4">11</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">np.loadtxt([</span><span class="s3">&quot;1_1</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;2</span><span class="s2">\n</span><span class="s3">,3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;2</span><span class="s2">\r</span><span class="s3">,3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]])</span>
<span class="s2">def </span><span class="s1">test_bad_newline_in_iterator(data):</span>
    <span class="s5"># In NumPy &lt;=1.22 this was accepted, because newlines were completely</span>
    <span class="s5"># ignored when the input was an iterable.  This could be changed, but right</span>
    <span class="s5"># now, we raise an error.</span>
    <span class="s1">msg = </span><span class="s3">&quot;Found an unquoted embedded newline within a single line&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(data</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;2,3</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># a universal newline</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;'2</span><span class="s2">\n</span><span class="s3">',3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># a quoted newline</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;'2</span><span class="s2">\r</span><span class="s3">',3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">&quot;1,2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;'2</span><span class="s2">\r\n</span><span class="s3">',3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_good_newline_in_iterator(data):</span>
    <span class="s5"># The quoted newlines will be untransformed here, but are just whitespace.</span>
    <span class="s1">res = np.loadtxt(data</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;'&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;newline&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_universal_newlines_quoted(newline):</span>
    <span class="s5"># Check that universal newline support within the tokenizer is not applied</span>
    <span class="s5"># to quoted fields.  (note that lines must end in newline or quoted</span>
    <span class="s5"># fields will not include a newline at all)</span>
    <span class="s1">data = [</span><span class="s3">'1,&quot;2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'3,&quot;4</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">, </span><span class="s3">'1&quot;</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">]</span>
    <span class="s1">data = [row.replace(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">newline) </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">data]</span>
    <span class="s1">res = np.loadtxt(data</span><span class="s2">, </span><span class="s1">dtype=object</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">'&quot;'</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">'1'</span><span class="s2">, </span><span class="s3">f'2</span><span class="s2">{</span><span class="s1">newline</span><span class="s2">}</span><span class="s3">'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'3'</span><span class="s2">, </span><span class="s3">f'4</span><span class="s2">{</span><span class="s1">newline</span><span class="s2">}</span><span class="s3">1'</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_null_character():</span>
    <span class="s5"># Basic tests to check that the NUL character is not special:</span>
    <span class="s1">res = np.loadtxt([</span><span class="s3">&quot;1</span><span class="s2">\000</span><span class="s3">2</span><span class="s2">\000</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;4</span><span class="s2">\000</span><span class="s3">5</span><span class="s2">\000</span><span class="s3">6&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]])</span>

    <span class="s5"># Also not as part of a field (avoid unicode/arrays as unicode strips \0)</span>
    <span class="s1">res = np.loadtxt([</span><span class="s3">&quot;1</span><span class="s2">\000</span><span class="s3">,2</span><span class="s2">\000</span><span class="s3">,3</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;4</span><span class="s2">\000</span><span class="s3">,5</span><span class="s2">\000</span><span class="s3">,6&quot;</span><span class="s1">]</span><span class="s2">,</span>
                     <span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s2">assert </span><span class="s1">res.tolist() == [[</span><span class="s3">&quot;1</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;2</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;3&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;4</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;5</span><span class="s2">\000</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;6&quot;</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">test_iterator_fails_getting_next_line():</span>
    <span class="s2">class </span><span class="s1">BadSequence:</span>
        <span class="s2">def </span><span class="s1">__len__(self):</span>
            <span class="s2">return </span><span class="s4">100</span>

        <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">item):</span>
            <span class="s2">if </span><span class="s1">item == </span><span class="s4">50</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Bad things happened!&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">item</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">item+</span><span class="s4">1</span><span class="s2">}</span><span class="s3">&quot;</span>

    <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Bad things happened!&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(BadSequence()</span><span class="s2">, </span><span class="s1">dtype=int</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestCReaderUnitTests:</span>
    <span class="s5"># These are internal tests for path that should not be possible to hit</span>
    <span class="s5"># unless things go very very wrong somewhere.</span>
    <span class="s2">def </span><span class="s1">test_not_an_filelike(self):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*read&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">object()</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;i&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filelike_read_fails(self):</span>
        <span class="s5"># Can only be reached if loadtxt opens the file, so it is hard to do</span>
        <span class="s5"># via the public interface (although maybe not impossible considering</span>
        <span class="s5"># the current &quot;DataClass&quot; backing).</span>
        <span class="s2">class </span><span class="s1">BadFileLike:</span>
            <span class="s1">counter = </span><span class="s4">0</span>

            <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size):</span>
                <span class="s1">self.counter += </span><span class="s4">1</span>
                <span class="s2">if </span><span class="s1">self.counter &gt; </span><span class="s4">20</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Bad bad bad!&quot;</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s3">&quot;1,2,3</span><span class="s2">\n</span><span class="s3">&quot;</span>

        <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Bad bad bad!&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">BadFileLike()</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;i&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filelike_bad_read(self):</span>
        <span class="s5"># Can only be reached if loadtxt opens the file, so it is hard to do</span>
        <span class="s5"># via the public interface (although maybe not impossible considering</span>
        <span class="s5"># the current &quot;DataClass&quot; backing).</span>

        <span class="s2">class </span><span class="s1">BadFileLike:</span>
            <span class="s1">counter = </span><span class="s4">0</span>

            <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size):</span>
                <span class="s2">return </span><span class="s4">1234  </span><span class="s5"># not a string!</span>

        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">,</span>
                    <span class="s1">match=</span><span class="s3">&quot;non-string returned while reading data&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">BadFileLike()</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;i&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_not_an_iter(self):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">,</span>
                    <span class="s1">match=</span><span class="s3">&quot;error reading from object, expected an iterable&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">object()</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;i&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_type(self):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;internal error: dtype must&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">object()</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;i&quot;</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_encoding(self):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;encoding must be a unicode&quot;</span><span class="s1">):</span>
            <span class="s1">np.core._multiarray_umath._load_from_filelike(</span>
                <span class="s1">object()</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;i&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">False, </span><span class="s1">encoding=</span><span class="s4">123</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;newline&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_manual_universal_newlines(self</span><span class="s2">, </span><span class="s1">newline):</span>
        <span class="s5"># This is currently not available to users, because we should always</span>
        <span class="s5"># open files with universal newlines enabled `newlines=None`.</span>
        <span class="s5"># (And reading from an iterator uses slightly different code paths.)</span>
        <span class="s5"># We have no real support for `newline=&quot;\r&quot;` or `newline=&quot;\n&quot; as the</span>
        <span class="s5"># user cannot specify those options.</span>
        <span class="s1">data = StringIO(</span><span class="s3">'0</span><span class="s2">\n</span><span class="s3">1</span><span class="s2">\n</span><span class="s3">&quot;2</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">4 #</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.replace(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">newline)</span><span class="s2">,</span>
                        <span class="s1">newline=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

        <span class="s1">res = np.core._multiarray_umath._load_from_filelike(</span>
            <span class="s1">data</span><span class="s2">, </span><span class="s1">dtype=np.dtype(</span><span class="s3">&quot;U10&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">filelike=</span><span class="s2">True,</span>
            <span class="s1">quote=</span><span class="s3">'&quot;'</span><span class="s2">, </span><span class="s1">comment=</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s1">skiplines=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(res[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">f&quot;2</span><span class="s2">{</span><span class="s1">newline</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;3&quot;</span><span class="s2">, </span><span class="s3">&quot;4 &quot;</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_delimiter_comment_collision_raises():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*control characters.*incompatible&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1, 2, 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_delimiter_quotechar_collision_raises():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*control characters.*incompatible&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1, 2, 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_comment_quotechar_collision_raises():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*control characters.*incompatible&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">comments=</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;#&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_delimiter_and_multiple_comments_collision_raises():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Comment characters.*cannot include the delimiter&quot;</span>
    <span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1, 2, 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">comments=[</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s3">&quot;,&quot;</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;ws&quot;</span><span class="s2">,</span>
    <span class="s1">(</span>
        <span class="s3">&quot; &quot;</span><span class="s2">,  </span><span class="s5"># space</span>
        <span class="s3">&quot;</span><span class="s2">\t</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># tab</span>
        <span class="s3">&quot;</span><span class="s2">\u2003</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># em</span>
        <span class="s3">&quot;</span><span class="s2">\u00A0</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># non-break</span>
        <span class="s3">&quot;</span><span class="s2">\u3000</span><span class="s3">&quot;</span><span class="s2">,  </span><span class="s5"># ideographic space</span>
    <span class="s1">)</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_collision_with_default_delimiter_raises(ws):</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*control characters.*incompatible&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">f&quot;1</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">2</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">4</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">5</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">6</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">comments=ws)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;.*control characters.*incompatible&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">f&quot;1</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">2</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">3</span><span class="s2">\n</span><span class="s3">4</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">5</span><span class="s2">{</span><span class="s1">ws</span><span class="s2">}</span><span class="s3">6</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">quotechar=ws)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;nl&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\r</span><span class="s3">&quot;</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_control_character_newline_raises(nl):</span>
    <span class="s1">txt = StringIO(</span><span class="s3">f&quot;1</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">2</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">3</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">4</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">5</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">6</span><span class="s2">{</span><span class="s1">nl</span><span class="s2">}{</span><span class="s1">nl</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s3">&quot;control character.*cannot be a newline&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">delimiter=nl)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">comments=nl)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">np.loadtxt(txt</span><span class="s2">, </span><span class="s1">quotechar=nl)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s3">&quot;generic_data&quot;</span><span class="s2">, </span><span class="s3">&quot;long_datum&quot;</span><span class="s2">, </span><span class="s3">&quot;unitless_dtype&quot;</span><span class="s2">, </span><span class="s3">&quot;expected_dtype&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;2012-03&quot;</span><span class="s2">, </span><span class="s3">&quot;2013-01-15&quot;</span><span class="s2">, </span><span class="s3">&quot;M8&quot;</span><span class="s2">, </span><span class="s3">&quot;M8[D]&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># Datetimes</span>
        <span class="s1">(</span><span class="s3">&quot;spam-a-lot&quot;</span><span class="s2">, </span><span class="s3">&quot;tis_but_a_scratch&quot;</span><span class="s2">, </span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s3">&quot;U17&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># str</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;nrows&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">50000</span><span class="s2">, </span><span class="s4">60000</span><span class="s1">))  </span><span class="s5"># lt, eq, gt chunksize</span>
<span class="s2">def </span><span class="s1">test_parametric_unit_discovery(</span>
    <span class="s1">generic_data</span><span class="s2">, </span><span class="s1">long_datum</span><span class="s2">, </span><span class="s1">unitless_dtype</span><span class="s2">, </span><span class="s1">expected_dtype</span><span class="s2">, </span><span class="s1">nrows</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Check that the correct unit (e.g. month, day, second) is discovered from 
    the data when a user specifies a unitless datetime.&quot;&quot;&quot;</span>
    <span class="s5"># Unit should be &quot;D&quot; (days) due to last entry</span>
    <span class="s1">data = [generic_data] * </span><span class="s4">50000 </span><span class="s1">+ [long_datum]</span>
    <span class="s1">expected = np.array(data</span><span class="s2">, </span><span class="s1">dtype=expected_dtype)</span>

    <span class="s5"># file-like path</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(data))</span>
    <span class="s1">a = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=unitless_dtype)</span>
    <span class="s2">assert </span><span class="s1">a.dtype == expected.dtype</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s5"># file-obj path</span>
    <span class="s1">fd</span><span class="s2">, </span><span class="s1">fname = mkstemp()</span>
    <span class="s1">os.close(fd)</span>
    <span class="s2">with </span><span class="s1">open(fname</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fh:</span>
        <span class="s1">fh.write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(data))</span>
    <span class="s1">a = np.loadtxt(fname</span><span class="s2">, </span><span class="s1">dtype=unitless_dtype)</span>
    <span class="s1">os.remove(fname)</span>
    <span class="s2">assert </span><span class="s1">a.dtype == expected.dtype</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_str_dtype_unit_discovery_with_converter():</span>
    <span class="s1">data = [</span><span class="s3">&quot;spam-a-lot&quot;</span><span class="s1">] * </span><span class="s4">60000 </span><span class="s1">+ [</span><span class="s3">&quot;XXXtis_but_a_scratch&quot;</span><span class="s1">]</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span><span class="s3">&quot;spam-a-lot&quot;</span><span class="s1">] * </span><span class="s4">60000 </span><span class="s1">+ [</span><span class="s3">&quot;tis_but_a_scratch&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U17&quot;</span>
    <span class="s1">)</span>
    <span class="s1">conv = </span><span class="s2">lambda </span><span class="s1">s: s.strip(</span><span class="s3">&quot;XXX&quot;</span><span class="s1">)</span>

    <span class="s5"># file-like path</span>
    <span class="s1">txt = StringIO(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(data))</span>
    <span class="s1">a = np.loadtxt(txt</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s1">converters=conv</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">a.dtype == expected.dtype</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s5"># file-obj path</span>
    <span class="s1">fd</span><span class="s2">, </span><span class="s1">fname = mkstemp()</span>
    <span class="s1">os.close(fd)</span>
    <span class="s2">with </span><span class="s1">open(fname</span><span class="s2">, </span><span class="s3">&quot;w&quot;</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fh:</span>
        <span class="s1">fh.write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(data))</span>
    <span class="s1">a = np.loadtxt(fname</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;U&quot;</span><span class="s2">, </span><span class="s1">converters=conv</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">os.remove(fname)</span>
    <span class="s2">assert </span><span class="s1">a.dtype == expected.dtype</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.skipif(IS_PYPY </span><span class="s2">and </span><span class="s1">sys.implementation.version &lt;= (</span><span class="s4">7</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;PyPy bug in error formatting&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_control_character_empty():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Text reading control character must&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Text reading control character must&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">quotechar=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;comments cannot be an empty string&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">comments=</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;comments cannot be an empty string&quot;</span><span class="s1">):</span>
        <span class="s1">np.loadtxt(StringIO(</span><span class="s3">&quot;1 2 3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">comments=[</span><span class="s3">&quot;#&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_control_characters_as_bytes():</span>
    <span class="s0">&quot;&quot;&quot;Byte control characters (comments, delimiter) are supported.&quot;&quot;&quot;</span>
    <span class="s1">a = np.loadtxt(StringIO(</span><span class="s3">&quot;#header</span><span class="s2">\n</span><span class="s3">1,2,3&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">comments=</span><span class="s6">b&quot;#&quot;</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s6">b&quot;,&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">'ignore::UserWarning'</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_field_growing_cases():</span>
    <span class="s5"># Test empty field appending/growing (each field still takes 1 character)</span>
    <span class="s5"># to see if the final field appending does not create issues.</span>
    <span class="s1">res = np.loadtxt([</span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=bytes)</span>
    <span class="s2">assert </span><span class="s1">len(res) == </span><span class="s4">0</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1024</span><span class="s1">):</span>
        <span class="s1">res = np.loadtxt([</span><span class="s3">&quot;,&quot; </span><span class="s1">* i]</span><span class="s2">, </span><span class="s1">delimiter=</span><span class="s3">&quot;,&quot;</span><span class="s2">, </span><span class="s1">dtype=bytes)</span>
        <span class="s2">assert </span><span class="s1">len(res) == i+</span><span class="s4">1</span>
</pre>
</body>
</html>