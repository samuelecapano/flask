<html>
<head>
<title>gridspec.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gridspec.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
:mod:`~matplotlib.gridspec` contains classes that help to layout multiple 
`~.axes.Axes` in a grid-like pattern within a figure. 
 
The `GridSpec` specifies the overall grid structure. Individual cells within 
the grid are referenced by `SubplotSpec`\s. 
 
Often, users need not access this module directly, and can use higher-level 
methods like `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` and 
`~.Figure.subfigures`. See the tutorial 
:doc:`/tutorials/intermediate/arranging_axes` for a guide. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_pylab_helpers</span><span class="s2">, </span><span class="s1">_tight_layout</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Bbox</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s2">class </span><span class="s1">GridSpecBase:</span>
    <span class="s0">&quot;&quot;&quot; 
    A base class of GridSpec that specifies the geometry of the grid 
    that a subplot will be placed. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">height_ratios=</span><span class="s2">None, </span><span class="s1">width_ratios=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        nrows, ncols : int 
            The number of rows and columns of the grid. 
        width_ratios : array-like of length *ncols*, optional 
            Defines the relative widths of the columns. Each column gets a 
            relative width of ``width_ratios[i] / sum(width_ratios)``. 
            If not given, all columns will have the same width. 
        height_ratios : array-like of length *nrows*, optional 
            Defines the relative heights of the rows. Each row gets a 
            relative height of ``height_ratios[i] / sum(height_ratios)``. 
            If not given, all rows will have the same height. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(nrows</span><span class="s2">, </span><span class="s1">Integral) </span><span class="s2">or </span><span class="s1">nrows &lt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Number of rows must be a positive integer, not </span><span class="s2">{</span><span class="s1">nrows</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(ncols</span><span class="s2">, </span><span class="s1">Integral) </span><span class="s2">or </span><span class="s1">ncols &lt;= </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Number of columns must be a positive integer, not </span><span class="s2">{</span><span class="s1">ncols</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">self._nrows</span><span class="s2">, </span><span class="s1">self._ncols = nrows</span><span class="s2">, </span><span class="s1">ncols</span>
        <span class="s1">self.set_height_ratios(height_ratios)</span>
        <span class="s1">self.set_width_ratios(width_ratios)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">height_arg = (</span><span class="s4">', height_ratios=%r' </span><span class="s1">% (self._row_height_ratios</span><span class="s2">,</span><span class="s1">)</span>
                      <span class="s2">if </span><span class="s1">len(set(self._row_height_ratios)) != </span><span class="s3">1 </span><span class="s2">else </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s1">width_arg = (</span><span class="s4">', width_ratios=%r' </span><span class="s1">% (self._col_width_ratios</span><span class="s2">,</span><span class="s1">)</span>
                     <span class="s2">if </span><span class="s1">len(set(self._col_width_ratios)) != </span><span class="s3">1 </span><span class="s2">else </span><span class="s4">''</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s4">'{clsname}({nrows}, {ncols}{optionals})'</span><span class="s1">.format(</span>
            <span class="s1">clsname=self.__class__.__name__</span><span class="s2">,</span>
            <span class="s1">nrows=self._nrows</span><span class="s2">,</span>
            <span class="s1">ncols=self._ncols</span><span class="s2">,</span>
            <span class="s1">optionals=height_arg + width_arg</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s1">nrows = property(</span><span class="s2">lambda </span><span class="s1">self: self._nrows</span><span class="s2">,</span>
                     <span class="s1">doc=</span><span class="s4">&quot;The number of rows in the grid.&quot;</span><span class="s1">)</span>
    <span class="s1">ncols = property(</span><span class="s2">lambda </span><span class="s1">self: self._ncols</span><span class="s2">,</span>
                     <span class="s1">doc=</span><span class="s4">&quot;The number of columns in the grid.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_geometry(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a tuple containing the number of rows and columns in the grid. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._nrows</span><span class="s2">, </span><span class="s1">self._ncols</span>

    <span class="s2">def </span><span class="s1">get_subplot_params(self</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5"># Must be implemented in subclasses</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">new_subplotspec(self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">rowspan=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">colspan=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create and return a `.SubplotSpec` instance. 
 
        Parameters 
        ---------- 
        loc : (int, int) 
            The position of the subplot in the grid as 
            ``(row_index, column_index)``. 
        rowspan, colspan : int, default: 1 
            The number of rows and columns the subplot should span in the grid. 
        &quot;&quot;&quot;</span>
        <span class="s1">loc1</span><span class="s2">, </span><span class="s1">loc2 = loc</span>
        <span class="s1">subplotspec = self[loc1:loc1+rowspan</span><span class="s2">, </span><span class="s1">loc2:loc2+colspan]</span>
        <span class="s2">return </span><span class="s1">subplotspec</span>

    <span class="s2">def </span><span class="s1">set_width_ratios(self</span><span class="s2">, </span><span class="s1">width_ratios):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the relative widths of the columns. 
 
        *width_ratios* must be of length *ncols*. Each column gets a relative 
        width of ``width_ratios[i] / sum(width_ratios)``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">width_ratios </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">width_ratios = [</span><span class="s3">1</span><span class="s1">] * self._ncols</span>
        <span class="s2">elif </span><span class="s1">len(width_ratios) != self._ncols:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Expected the given number of width ratios to '</span>
                             <span class="s4">'match the number of columns of the grid'</span><span class="s1">)</span>
        <span class="s1">self._col_width_ratios = width_ratios</span>

    <span class="s2">def </span><span class="s1">get_width_ratios(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the width ratios. 
 
        This is *None* if no width ratios have been set explicitly. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._col_width_ratios</span>

    <span class="s2">def </span><span class="s1">set_height_ratios(self</span><span class="s2">, </span><span class="s1">height_ratios):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the relative heights of the rows. 
 
        *height_ratios* must be of length *nrows*. Each row gets a relative 
        height of ``height_ratios[i] / sum(height_ratios)``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">height_ratios </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">height_ratios = [</span><span class="s3">1</span><span class="s1">] * self._nrows</span>
        <span class="s2">elif </span><span class="s1">len(height_ratios) != self._nrows:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Expected the given number of height ratios to '</span>
                             <span class="s4">'match the number of rows of the grid'</span><span class="s1">)</span>
        <span class="s1">self._row_height_ratios = height_ratios</span>

    <span class="s2">def </span><span class="s1">get_height_ratios(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the height ratios. 
 
        This is *None* if no height ratios have been set explicitly. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._row_height_ratios</span>

    <span class="s1">@_api.delete_parameter(</span><span class="s4">&quot;3.7&quot;</span><span class="s2">, </span><span class="s4">&quot;raw&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">get_grid_positions(self</span><span class="s2">, </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">raw=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the positions of the grid cells in figure coordinates. 
 
        Parameters 
        ---------- 
        fig : `~matplotlib.figure.Figure` 
            The figure the grid should be applied to. The subplot parameters 
            (margins and spacing between subplots) are taken from *fig*. 
        raw : bool, default: False 
            If *True*, the subplot parameters of the figure are not taken 
            into account. The grid spans the range [0, 1] in both directions 
            without margins and there is no space between grid cells. This is 
            used for constrained_layout. 
 
        Returns 
        ------- 
        bottoms, tops, lefts, rights : array 
            The bottom, top, left, right positions of the grid cells in 
            figure coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols = self.get_geometry()</span>

        <span class="s2">if </span><span class="s1">raw:</span>
            <span class="s1">left = </span><span class="s3">0.</span>
            <span class="s1">right = </span><span class="s3">1.</span>
            <span class="s1">bottom = </span><span class="s3">0.</span>
            <span class="s1">top = </span><span class="s3">1.</span>
            <span class="s1">wspace = </span><span class="s3">0.</span>
            <span class="s1">hspace = </span><span class="s3">0.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subplot_params = self.get_subplot_params(fig)</span>
            <span class="s1">left = subplot_params.left</span>
            <span class="s1">right = subplot_params.right</span>
            <span class="s1">bottom = subplot_params.bottom</span>
            <span class="s1">top = subplot_params.top</span>
            <span class="s1">wspace = subplot_params.wspace</span>
            <span class="s1">hspace = subplot_params.hspace</span>
        <span class="s1">tot_width = right - left</span>
        <span class="s1">tot_height = top - bottom</span>

        <span class="s5"># calculate accumulated heights of columns</span>
        <span class="s1">cell_h = tot_height / (nrows + hspace*(nrows-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">sep_h = hspace * cell_h</span>
        <span class="s1">norm = cell_h * nrows / sum(self._row_height_ratios)</span>
        <span class="s1">cell_heights = [r * norm </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self._row_height_ratios]</span>
        <span class="s1">sep_heights = [</span><span class="s3">0</span><span class="s1">] + ([sep_h] * (nrows-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">cell_hs = np.cumsum(np.column_stack([sep_heights</span><span class="s2">, </span><span class="s1">cell_heights]).flat)</span>

        <span class="s5"># calculate accumulated widths of rows</span>
        <span class="s1">cell_w = tot_width / (ncols + wspace*(ncols-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">sep_w = wspace * cell_w</span>
        <span class="s1">norm = cell_w * ncols / sum(self._col_width_ratios)</span>
        <span class="s1">cell_widths = [r * norm </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self._col_width_ratios]</span>
        <span class="s1">sep_widths = [</span><span class="s3">0</span><span class="s1">] + ([sep_w] * (ncols-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">cell_ws = np.cumsum(np.column_stack([sep_widths</span><span class="s2">, </span><span class="s1">cell_widths]).flat)</span>

        <span class="s1">fig_tops</span><span class="s2">, </span><span class="s1">fig_bottoms = (top - cell_hs).reshape((-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)).T</span>
        <span class="s1">fig_lefts</span><span class="s2">, </span><span class="s1">fig_rights = (left + cell_ws).reshape((-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)).T</span>
        <span class="s2">return </span><span class="s1">fig_bottoms</span><span class="s2">, </span><span class="s1">fig_tops</span><span class="s2">, </span><span class="s1">fig_lefts</span><span class="s2">, </span><span class="s1">fig_rights</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_check_gridspec_exists(figure</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if the figure already has a gridspec with these dimensions, 
        or create a new one 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">figure.get_axes():</span>
            <span class="s1">gs = ax.get_gridspec()</span>
            <span class="s2">if </span><span class="s1">gs </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">hasattr(gs</span><span class="s2">, </span><span class="s4">'get_topmost_subplotspec'</span><span class="s1">):</span>
                    <span class="s5"># This is needed for colorbar gridspec layouts.</span>
                    <span class="s5"># This is probably OK because this whole logic tree</span>
                    <span class="s5"># is for when the user is doing simple things with the</span>
                    <span class="s5"># add_subplot command.  For complicated layouts</span>
                    <span class="s5"># like subgridspecs the proper gridspec is passed in...</span>
                    <span class="s1">gs = gs.get_topmost_subplotspec().get_gridspec()</span>
                <span class="s2">if </span><span class="s1">gs.get_geometry() == (nrows</span><span class="s2">, </span><span class="s1">ncols):</span>
                    <span class="s2">return </span><span class="s1">gs</span>
        <span class="s5"># else gridspec not found:</span>
        <span class="s2">return </span><span class="s1">GridSpec(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">figure=figure)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Create and return a `.SubplotSpec` instance.&quot;&quot;&quot;</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols = self.get_geometry()</span>

        <span class="s2">def </span><span class="s1">_normalize(key</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">axis):  </span><span class="s5"># Includes last index.</span>
            <span class="s1">orig_key = key</span>
            <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">slice):</span>
                <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">_ = key.indices(size)</span>
                <span class="s2">if </span><span class="s1">stop &gt; start:</span>
                    <span class="s2">return </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop - </span><span class="s3">1</span>
                <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s4">&quot;GridSpec slice would result in no space &quot;</span>
                                 <span class="s4">&quot;allocated for subplot&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">key &lt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">key = key + size</span>
                <span class="s2">if </span><span class="s3">0 </span><span class="s1">&lt;= key &lt; size:</span>
                    <span class="s2">return </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key</span>
                <span class="s2">elif </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s4">f&quot;index </span><span class="s2">{</span><span class="s1">orig_key</span><span class="s2">} </span><span class="s4">is out of bounds for &quot;</span>
                                     <span class="s4">f&quot;axis </span><span class="s2">{</span><span class="s1">axis</span><span class="s2">} </span><span class="s4">with size </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:  </span><span class="s5"># flat index</span>
                    <span class="s2">raise </span><span class="s1">IndexError(</span><span class="s4">f&quot;index </span><span class="s2">{</span><span class="s1">orig_key</span><span class="s2">} </span><span class="s4">is out of bounds for &quot;</span>
                                     <span class="s4">f&quot;GridSpec with size </span><span class="s2">{</span><span class="s1">size</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(key</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">k1</span><span class="s2">, </span><span class="s1">k2 = key</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized subplot spec&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s1">num1</span><span class="s2">, </span><span class="s1">num2 = np.ravel_multi_index(</span>
                <span class="s1">[_normalize(k1</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_normalize(k2</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)]</span><span class="s2">,</span>
                <span class="s1">(nrows</span><span class="s2">, </span><span class="s1">ncols))</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s5"># Single key</span>
            <span class="s1">num1</span><span class="s2">, </span><span class="s1">num2 = _normalize(key</span><span class="s2">, </span><span class="s1">nrows * ncols</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">SubplotSpec(self</span><span class="s2">, </span><span class="s1">num1</span><span class="s2">, </span><span class="s1">num2)</span>

    <span class="s2">def </span><span class="s1">subplots(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">sharex=</span><span class="s2">False, </span><span class="s1">sharey=</span><span class="s2">False, </span><span class="s1">squeeze=</span><span class="s2">True,</span>
                 <span class="s1">subplot_kw=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add all subplots specified by this `GridSpec` to its parent figure. 
 
        See `.Figure.subplots` for detailed documentation. 
        &quot;&quot;&quot;</span>

        <span class="s1">figure = self.figure</span>

        <span class="s2">if </span><span class="s1">figure </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;GridSpec.subplots() only works for GridSpecs &quot;</span>
                             <span class="s4">&quot;created with a parent figure&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">isinstance(sharex</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">sharex = </span><span class="s4">&quot;all&quot; </span><span class="s2">if </span><span class="s1">sharex </span><span class="s2">else </span><span class="s4">&quot;none&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(sharey</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">sharey = </span><span class="s4">&quot;all&quot; </span><span class="s2">if </span><span class="s1">sharey </span><span class="s2">else </span><span class="s4">&quot;none&quot;</span>

        <span class="s1">_api.check_in_list([</span><span class="s4">&quot;all&quot;</span><span class="s2">, </span><span class="s4">&quot;row&quot;</span><span class="s2">, </span><span class="s4">&quot;col&quot;</span><span class="s2">, </span><span class="s4">&quot;none&quot;</span><span class="s2">, False, True</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">sharex=sharex</span><span class="s2">, </span><span class="s1">sharey=sharey)</span>
        <span class="s2">if </span><span class="s1">subplot_kw </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">subplot_kw = {}</span>
        <span class="s5"># don't mutate kwargs passed by user...</span>
        <span class="s1">subplot_kw = subplot_kw.copy()</span>

        <span class="s5"># Create array to hold all axes.</span>
        <span class="s1">axarr = np.empty((self._nrows</span><span class="s2">, </span><span class="s1">self._ncols)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">range(self._nrows):</span>
            <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">range(self._ncols):</span>
                <span class="s1">shared_with = {</span><span class="s4">&quot;none&quot;</span><span class="s1">: </span><span class="s2">None, </span><span class="s4">&quot;all&quot;</span><span class="s1">: axarr[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                               <span class="s4">&quot;row&quot;</span><span class="s1">: axarr[row</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">&quot;col&quot;</span><span class="s1">: axarr[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">col]}</span>
                <span class="s1">subplot_kw[</span><span class="s4">&quot;sharex&quot;</span><span class="s1">] = shared_with[sharex]</span>
                <span class="s1">subplot_kw[</span><span class="s4">&quot;sharey&quot;</span><span class="s1">] = shared_with[sharey]</span>
                <span class="s1">axarr[row</span><span class="s2">, </span><span class="s1">col] = figure.add_subplot(</span>
                    <span class="s1">self[row</span><span class="s2">, </span><span class="s1">col]</span><span class="s2">, </span><span class="s1">**subplot_kw)</span>

        <span class="s5"># turn off redundant tick labeling</span>
        <span class="s2">if </span><span class="s1">sharex </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;col&quot;</span><span class="s2">, </span><span class="s4">&quot;all&quot;</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axarr.flat:</span>
                <span class="s1">ax._label_outer_xaxis(check_patch=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">sharey </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;row&quot;</span><span class="s2">, </span><span class="s4">&quot;all&quot;</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axarr.flat:</span>
                <span class="s1">ax._label_outer_yaxis(check_patch=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">squeeze:</span>
            <span class="s5"># Discarding unneeded dimensions that equal 1.  If we only have one</span>
            <span class="s5"># subplot, just return it instead of a 1-element array.</span>
            <span class="s2">return </span><span class="s1">axarr.item() </span><span class="s2">if </span><span class="s1">axarr.size == </span><span class="s3">1 </span><span class="s2">else </span><span class="s1">axarr.squeeze()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Returned axis array will be always 2-d, even if nrows=ncols=1.</span>
            <span class="s2">return </span><span class="s1">axarr</span>


<span class="s2">class </span><span class="s1">GridSpec(GridSpecBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    A grid layout to place subplots within a figure. 
 
    The location of the grid cells is determined in a similar way to 
    `~.figure.SubplotParams` using *left*, *right*, *top*, *bottom*, *wspace* 
    and *hspace*. 
 
    Indexing a GridSpec instance returns a `.SubplotSpec`. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None,</span>
                 <span class="s1">left=</span><span class="s2">None, </span><span class="s1">bottom=</span><span class="s2">None, </span><span class="s1">right=</span><span class="s2">None, </span><span class="s1">top=</span><span class="s2">None,</span>
                 <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None,</span>
                 <span class="s1">width_ratios=</span><span class="s2">None, </span><span class="s1">height_ratios=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        nrows, ncols : int 
            The number of rows and columns of the grid. 
 
        figure : `.Figure`, optional 
            Only used for constrained layout to create a proper layoutgrid. 
 
        left, right, top, bottom : float, optional 
            Extent of the subplots as a fraction of figure width or height. 
            Left cannot be larger than right, and bottom cannot be larger than 
            top. If not given, the values will be inferred from a figure or 
            rcParams at draw time. See also `GridSpec.get_subplot_params`. 
 
        wspace : float, optional 
            The amount of width reserved for space between subplots, 
            expressed as a fraction of the average axis width. 
            If not given, the values will be inferred from a figure or 
            rcParams when necessary. See also `GridSpec.get_subplot_params`. 
 
        hspace : float, optional 
            The amount of height reserved for space between subplots, 
            expressed as a fraction of the average axis height. 
            If not given, the values will be inferred from a figure or 
            rcParams when necessary. See also `GridSpec.get_subplot_params`. 
 
        width_ratios : array-like of length *ncols*, optional 
            Defines the relative widths of the columns. Each column gets a 
            relative width of ``width_ratios[i] / sum(width_ratios)``. 
            If not given, all columns will have the same width. 
 
        height_ratios : array-like of length *nrows*, optional 
            Defines the relative heights of the rows. Each row gets a 
            relative height of ``height_ratios[i] / sum(height_ratios)``. 
            If not given, all rows will have the same height. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.left = left</span>
        <span class="s1">self.bottom = bottom</span>
        <span class="s1">self.right = right</span>
        <span class="s1">self.top = top</span>
        <span class="s1">self.wspace = wspace</span>
        <span class="s1">self.hspace = hspace</span>
        <span class="s1">self.figure = figure</span>

        <span class="s1">super().__init__(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">,</span>
                         <span class="s1">width_ratios=width_ratios</span><span class="s2">,</span>
                         <span class="s1">height_ratios=height_ratios)</span>

    <span class="s1">_AllowedKeys = [</span><span class="s4">&quot;left&quot;</span><span class="s2">, </span><span class="s4">&quot;bottom&quot;</span><span class="s2">, </span><span class="s4">&quot;right&quot;</span><span class="s2">, </span><span class="s4">&quot;top&quot;</span><span class="s2">, </span><span class="s4">&quot;wspace&quot;</span><span class="s2">, </span><span class="s4">&quot;hspace&quot;</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the subplot parameters of the grid. 
 
        Parameters that are not explicitly given are not changed. Setting a 
        parameter to *None* resets it to :rc:`figure.subplot.*`. 
 
        Parameters 
        ---------- 
        left, right, top, bottom : float or None, optional 
            Extent of the subplots as a fraction of figure width or height. 
        wspace, hspace : float, optional 
            Spacing between the subplots as a fraction of the average subplot 
            width / height. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
            <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._AllowedKeys:</span>
                <span class="s1">setattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">} </span><span class="s4">is an unknown keyword&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">figmanager </span><span class="s2">in </span><span class="s1">_pylab_helpers.Gcf.figs.values():</span>
            <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">figmanager.canvas.figure.axes:</span>
                <span class="s2">if </span><span class="s1">ax.get_subplotspec() </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">ss = ax.get_subplotspec().get_topmost_subplotspec()</span>
                    <span class="s2">if </span><span class="s1">ss.get_gridspec() == self:</span>
                        <span class="s1">ax._set_position(</span>
                            <span class="s1">ax.get_subplotspec().get_position(ax.figure))</span>

    <span class="s2">def </span><span class="s1">get_subplot_params(self</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.SubplotParams` for the GridSpec. 
 
        In order of precedence the values are taken from 
 
        - non-*None* attributes of the GridSpec 
        - the provided *figure* 
        - :rc:`figure.subplot.*` 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">figure </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">kw = {k: mpl.rcParams[</span><span class="s4">&quot;figure.subplot.&quot;</span><span class="s1">+k]</span>
                  <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._AllowedKeys}</span>
            <span class="s1">subplotpars = mpl.figure.SubplotParams(**kw)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subplotpars = copy.copy(figure.subplotpars)</span>

        <span class="s1">subplotpars.update(**{k: getattr(self</span><span class="s2">, </span><span class="s1">k) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._AllowedKeys})</span>

        <span class="s2">return </span><span class="s1">subplotpars</span>

    <span class="s2">def </span><span class="s1">locally_modified_subplot_params(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of the names of the subplot parameters explicitly set 
        in the GridSpec. 
 
        This is a subset of the attributes of `.SubplotParams`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[k </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._AllowedKeys </span><span class="s2">if </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">k)]</span>

    <span class="s2">def </span><span class="s1">tight_layout(self</span><span class="s2">, </span><span class="s1">figure</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None,</span>
                     <span class="s1">pad=</span><span class="s3">1.08</span><span class="s2">, </span><span class="s1">h_pad=</span><span class="s2">None, </span><span class="s1">w_pad=</span><span class="s2">None, </span><span class="s1">rect=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust subplot parameters to give specified padding. 
 
        Parameters 
        ---------- 
        pad : float 
            Padding between the figure edge and the edges of subplots, as a 
            fraction of the font-size. 
        h_pad, w_pad : float, optional 
            Padding (height/width) between edges of adjacent subplots. 
            Defaults to *pad*. 
        rect : tuple (left, bottom, right, top), default: None 
            (left, bottom, right, top) rectangle in normalized figure 
            coordinates that the whole subplots area (including labels) will 
            fit into. Default (None) is the whole figure. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = figure._get_renderer()</span>
        <span class="s1">kwargs = _tight_layout.get_tight_layout_figure(</span>
            <span class="s1">figure</span><span class="s2">, </span><span class="s1">figure.axes</span><span class="s2">,</span>
            <span class="s1">_tight_layout.get_subplotspec_list(figure.axes</span><span class="s2">, </span><span class="s1">grid_spec=self)</span><span class="s2">,</span>
            <span class="s1">renderer</span><span class="s2">, </span><span class="s1">pad=pad</span><span class="s2">, </span><span class="s1">h_pad=h_pad</span><span class="s2">, </span><span class="s1">w_pad=w_pad</span><span class="s2">, </span><span class="s1">rect=rect)</span>
        <span class="s2">if </span><span class="s1">kwargs:</span>
            <span class="s1">self.update(**kwargs)</span>


<span class="s2">class </span><span class="s1">GridSpecFromSubplotSpec(GridSpecBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    GridSpec whose subplot layout parameters are inherited from the 
    location specified by a given SubplotSpec. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">,</span>
                 <span class="s1">subplot_spec</span><span class="s2">,</span>
                 <span class="s1">wspace=</span><span class="s2">None, </span><span class="s1">hspace=</span><span class="s2">None,</span>
                 <span class="s1">height_ratios=</span><span class="s2">None, </span><span class="s1">width_ratios=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        nrows, ncols : int 
            Number of rows and number of columns of the grid. 
        subplot_spec : SubplotSpec 
            Spec from which the layout parameters are inherited. 
        wspace, hspace : float, optional 
            See `GridSpec` for more details. If not specified default values 
            (from the figure or rcParams) are used. 
        height_ratios : array-like of length *nrows*, optional 
            See `GridSpecBase` for details. 
        width_ratios : array-like of length *ncols*, optional 
            See `GridSpecBase` for details. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._wspace = wspace</span>
        <span class="s1">self._hspace = hspace</span>
        <span class="s1">self._subplot_spec = subplot_spec</span>
        <span class="s1">self.figure = self._subplot_spec.get_gridspec().figure</span>
        <span class="s1">super().__init__(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">,</span>
                         <span class="s1">width_ratios=width_ratios</span><span class="s2">,</span>
                         <span class="s1">height_ratios=height_ratios)</span>

    <span class="s2">def </span><span class="s1">get_subplot_params(self</span><span class="s2">, </span><span class="s1">figure=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of subplot layout parameters.&quot;&quot;&quot;</span>
        <span class="s1">hspace = (self._hspace </span><span class="s2">if </span><span class="s1">self._hspace </span><span class="s2">is not None</span>
                  <span class="s2">else </span><span class="s1">figure.subplotpars.hspace </span><span class="s2">if </span><span class="s1">figure </span><span class="s2">is not None</span>
                  <span class="s2">else </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;figure.subplot.hspace&quot;</span><span class="s1">])</span>
        <span class="s1">wspace = (self._wspace </span><span class="s2">if </span><span class="s1">self._wspace </span><span class="s2">is not None</span>
                  <span class="s2">else </span><span class="s1">figure.subplotpars.wspace </span><span class="s2">if </span><span class="s1">figure </span><span class="s2">is not None</span>
                  <span class="s2">else </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;figure.subplot.wspace&quot;</span><span class="s1">])</span>

        <span class="s1">figbox = self._subplot_spec.get_position(figure)</span>
        <span class="s1">left</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">top = figbox.extents</span>

        <span class="s2">return </span><span class="s1">mpl.figure.SubplotParams(left=left</span><span class="s2">, </span><span class="s1">right=right</span><span class="s2">,</span>
                                        <span class="s1">bottom=bottom</span><span class="s2">, </span><span class="s1">top=top</span><span class="s2">,</span>
                                        <span class="s1">wspace=wspace</span><span class="s2">, </span><span class="s1">hspace=hspace)</span>

    <span class="s2">def </span><span class="s1">get_topmost_subplotspec(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the topmost `.SubplotSpec` instance associated with the subplot. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._subplot_spec.get_topmost_subplotspec()</span>


<span class="s2">class </span><span class="s1">SubplotSpec:</span>
    <span class="s0">&quot;&quot;&quot; 
    The location of a subplot in a `GridSpec`. 
 
    .. note:: 
 
        Likely, you will never instantiate a `SubplotSpec` yourself. Instead, 
        you will typically obtain one from a `GridSpec` using item-access. 
 
    Parameters 
    ---------- 
    gridspec : `~matplotlib.gridspec.GridSpec` 
        The GridSpec, which the subplot is referencing. 
    num1, num2 : int 
        The subplot will occupy the *num1*-th cell of the given 
        *gridspec*.  If *num2* is provided, the subplot will span between 
        *num1*-th cell and *num2*-th cell **inclusive**. 
 
        The index starts from 0. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">gridspec</span><span class="s2">, </span><span class="s1">num1</span><span class="s2">, </span><span class="s1">num2=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._gridspec = gridspec</span>
        <span class="s1">self.num1 = num1</span>
        <span class="s1">self.num2 = num2</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.get_gridspec()</span><span class="s2">}</span><span class="s4">[&quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.rowspan.start</span><span class="s2">}</span><span class="s4">:</span><span class="s2">{</span><span class="s1">self.rowspan.stop</span><span class="s2">}</span><span class="s4">, &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.colspan.start</span><span class="s2">}</span><span class="s4">:</span><span class="s2">{</span><span class="s1">self.colspan.stop</span><span class="s2">}</span><span class="s4">]&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_from_subplot_args(figure</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a `.SubplotSpec` from a parent `.Figure` and either 
 
        - a `.SubplotSpec` -- returned as is; 
        - one or three numbers -- a MATLAB-style subplot specifier. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">arg</span><span class="s2">, </span><span class="s1">= args</span>
            <span class="s2">if </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">SubplotSpec):</span>
                <span class="s2">return </span><span class="s1">arg</span>
            <span class="s2">elif not </span><span class="s1">isinstance(arg</span><span class="s2">, </span><span class="s1">Integral):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Single argument to subplot must be a three-digit &quot;</span>
                    <span class="s4">f&quot;integer, not </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">num = map(int</span><span class="s2">, </span><span class="s1">str(arg))</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Single argument to subplot must be a three-digit &quot;</span>
                    <span class="s4">f&quot;integer, not </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">) </span><span class="s2">from None</span>
        <span class="s2">elif </span><span class="s1">len(args) == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">num = args</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">_api.nargs_error(</span><span class="s4">&quot;subplot&quot;</span><span class="s2">, </span><span class="s1">takes=</span><span class="s4">&quot;1 or 3&quot;</span><span class="s2">, </span><span class="s1">given=len(args))</span>

        <span class="s1">gs = GridSpec._check_gridspec_exists(figure</span><span class="s2">, </span><span class="s1">rows</span><span class="s2">, </span><span class="s1">cols)</span>
        <span class="s2">if </span><span class="s1">gs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">gs = GridSpec(rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">figure=figure)</span>
        <span class="s2">if </span><span class="s1">isinstance(num</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">len(num) == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(n</span><span class="s2">, </span><span class="s1">Integral) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">num):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Subplot specifier tuple must contain integers, not </span><span class="s2">{</span><span class="s1">num</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">i</span><span class="s2">, </span><span class="s1">j = num</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">isinstance(num</span><span class="s2">, </span><span class="s1">Integral) </span><span class="s2">or </span><span class="s1">num &lt; </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">num &gt; rows*cols:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;num must be an integer with 1 &lt;= num &lt;= </span><span class="s2">{</span><span class="s1">rows*cols</span><span class="s2">}</span><span class="s4">, &quot;</span>
                    <span class="s4">f&quot;not </span><span class="s2">{</span><span class="s1">num</span><span class="s2">!r}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
            <span class="s1">i = j = num</span>
        <span class="s2">return </span><span class="s1">gs[i-</span><span class="s3">1</span><span class="s1">:j]</span>

    <span class="s5"># num2 is a property only to handle the case where it is None and someone</span>
    <span class="s5"># mutates num1.</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">num2(self):</span>
        <span class="s2">return </span><span class="s1">self.num1 </span><span class="s2">if </span><span class="s1">self._num2 </span><span class="s2">is None else </span><span class="s1">self._num2</span>

    <span class="s1">@num2.setter</span>
    <span class="s2">def </span><span class="s1">num2(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._num2 = value</span>

    <span class="s2">def </span><span class="s1">get_gridspec(self):</span>
        <span class="s2">return </span><span class="s1">self._gridspec</span>

    <span class="s2">def </span><span class="s1">get_geometry(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the subplot geometry as tuple ``(n_rows, n_cols, start, stop)``. 
 
        The indices *start* and *stop* define the range of the subplot within 
        the `GridSpec`. *stop* is inclusive (i.e. for a single cell 
        ``start == stop``). 
        &quot;&quot;&quot;</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = self.get_gridspec().get_geometry()</span>
        <span class="s2">return </span><span class="s1">rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">self.num1</span><span class="s2">, </span><span class="s1">self.num2</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">rowspan(self):</span>
        <span class="s0">&quot;&quot;&quot;The rows spanned by this subplot, as a `range` object.&quot;&quot;&quot;</span>
        <span class="s1">ncols = self.get_gridspec().ncols</span>
        <span class="s2">return </span><span class="s1">range(self.num1 // ncols</span><span class="s2">, </span><span class="s1">self.num2 // ncols + </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">colspan(self):</span>
        <span class="s0">&quot;&quot;&quot;The columns spanned by this subplot, as a `range` object.&quot;&quot;&quot;</span>
        <span class="s1">ncols = self.get_gridspec().ncols</span>
        <span class="s5"># We explicitly support num2 referring to a column on num1's *left*, so</span>
        <span class="s5"># we must sort the column indices here so that the range makes sense.</span>
        <span class="s1">c1</span><span class="s2">, </span><span class="s1">c2 = sorted([self.num1 % ncols</span><span class="s2">, </span><span class="s1">self.num2 % ncols])</span>
        <span class="s2">return </span><span class="s1">range(c1</span><span class="s2">, </span><span class="s1">c2 + </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">is_first_row(self):</span>
        <span class="s2">return </span><span class="s1">self.rowspan.start == </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">is_last_row(self):</span>
        <span class="s2">return </span><span class="s1">self.rowspan.stop == self.get_gridspec().nrows</span>

    <span class="s2">def </span><span class="s1">is_first_col(self):</span>
        <span class="s2">return </span><span class="s1">self.colspan.start == </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">is_last_col(self):</span>
        <span class="s2">return </span><span class="s1">self.colspan.stop == self.get_gridspec().ncols</span>

    <span class="s2">def </span><span class="s1">get_position(self</span><span class="s2">, </span><span class="s1">figure):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the subplot position from ``figure.subplotpars``. 
        &quot;&quot;&quot;</span>
        <span class="s1">gridspec = self.get_gridspec()</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols = gridspec.get_geometry()</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols = np.unravel_index([self.num1</span><span class="s2">, </span><span class="s1">self.num2]</span><span class="s2">, </span><span class="s1">(nrows</span><span class="s2">, </span><span class="s1">ncols))</span>
        <span class="s1">fig_bottoms</span><span class="s2">, </span><span class="s1">fig_tops</span><span class="s2">, </span><span class="s1">fig_lefts</span><span class="s2">, </span><span class="s1">fig_rights = \</span>
            <span class="s1">gridspec.get_grid_positions(figure)</span>

        <span class="s1">fig_bottom = fig_bottoms[rows].min()</span>
        <span class="s1">fig_top = fig_tops[rows].max()</span>
        <span class="s1">fig_left = fig_lefts[cols].min()</span>
        <span class="s1">fig_right = fig_rights[cols].max()</span>
        <span class="s2">return </span><span class="s1">Bbox.from_extents(fig_left</span><span class="s2">, </span><span class="s1">fig_bottom</span><span class="s2">, </span><span class="s1">fig_right</span><span class="s2">, </span><span class="s1">fig_top)</span>

    <span class="s2">def </span><span class="s1">get_topmost_subplotspec(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the topmost `SubplotSpec` instance associated with the subplot. 
        &quot;&quot;&quot;</span>
        <span class="s1">gridspec = self.get_gridspec()</span>
        <span class="s2">if </span><span class="s1">hasattr(gridspec</span><span class="s2">, </span><span class="s4">&quot;get_topmost_subplotspec&quot;</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">gridspec.get_topmost_subplotspec()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Two SubplotSpecs are considered equal if they refer to the same 
        position(s) in the same `GridSpec`. 
        &quot;&quot;&quot;</span>
        <span class="s5"># other may not even have the attributes we are checking.</span>
        <span class="s2">return </span><span class="s1">((self._gridspec</span><span class="s2">, </span><span class="s1">self.num1</span><span class="s2">, </span><span class="s1">self.num2)</span>
                <span class="s1">== (getattr(other</span><span class="s2">, </span><span class="s4">&quot;_gridspec&quot;</span><span class="s2">, </span><span class="s1">object())</span><span class="s2">,</span>
                    <span class="s1">getattr(other</span><span class="s2">, </span><span class="s4">&quot;num1&quot;</span><span class="s2">, </span><span class="s1">object())</span><span class="s2">,</span>
                    <span class="s1">getattr(other</span><span class="s2">, </span><span class="s4">&quot;num2&quot;</span><span class="s2">, </span><span class="s1">object())))</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self._gridspec</span><span class="s2">, </span><span class="s1">self.num1</span><span class="s2">, </span><span class="s1">self.num2))</span>

    <span class="s2">def </span><span class="s1">subgridspec(self</span><span class="s2">, </span><span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a GridSpec within this subplot. 
 
        The created `.GridSpecFromSubplotSpec` will have this `SubplotSpec` as 
        a parent. 
 
        Parameters 
        ---------- 
        nrows : int 
            Number of rows in grid. 
 
        ncols : int 
            Number of columns in grid. 
 
        Returns 
        ------- 
        `.GridSpecFromSubplotSpec` 
 
        Other Parameters 
        ---------------- 
        **kwargs 
            All other parameters are passed to `.GridSpecFromSubplotSpec`. 
 
        See Also 
        -------- 
        matplotlib.pyplot.subplots 
 
        Examples 
        -------- 
        Adding three subplots in the space occupied by a single subplot:: 
 
            fig = plt.figure() 
            gs0 = fig.add_gridspec(3, 1) 
            ax1 = fig.add_subplot(gs0[0]) 
            ax2 = fig.add_subplot(gs0[1]) 
            gssub = gs0[2].subgridspec(1, 3) 
            for i in range(3): 
                fig.add_subplot(gssub[0, i]) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">GridSpecFromSubplotSpec(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>