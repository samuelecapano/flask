<html>
<head>
<title>artist.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
artist.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">lru_cache</span><span class="s0">, </span><span class="s1">wraps</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">Signature</span><span class="s0">, </span><span class="s1">Parameter</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Number</span>
<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">cbook</span>
<span class="s0">from </span><span class="s1">.colors </span><span class="s0">import </span><span class="s1">BoundaryNorm</span>
<span class="s0">from </span><span class="s1">.cm </span><span class="s0">import </span><span class="s1">ScalarMappable</span>
<span class="s0">from </span><span class="s1">.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">.transforms </span><span class="s0">import </span><span class="s1">(Bbox</span><span class="s0">, </span><span class="s1">IdentityTransform</span><span class="s0">, </span><span class="s1">Transform</span><span class="s0">, </span><span class="s1">TransformedBbox</span><span class="s0">,</span>
                         <span class="s1">TransformedPatchPath</span><span class="s0">, </span><span class="s1">TransformedPath)</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s0">def </span><span class="s1">_prevent_rasterization(draw):</span>
    <span class="s2"># We assume that by default artists are not allowed to rasterize (unless</span>
    <span class="s2"># its draw method is explicitly decorated). If it is being drawn after a</span>
    <span class="s2"># rasterized artist and it has reached a raster_depth of 0, we stop</span>
    <span class="s2"># rasterization so that it does not affect the behavior of normal artist</span>
    <span class="s2"># (e.g., change in dpi).</span>

    <span class="s1">@wraps(draw)</span>
    <span class="s0">def </span><span class="s1">draw_wrapper(artist</span><span class="s0">, </span><span class="s1">renderer</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">if </span><span class="s1">renderer._raster_depth == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">renderer._rasterizing:</span>
            <span class="s2"># Only stop when we are not in a rasterized parent</span>
            <span class="s2"># and something has been rasterized since last stop.</span>
            <span class="s1">renderer.stop_rasterizing()</span>
            <span class="s1">renderer._rasterizing = </span><span class="s0">False</span>

        <span class="s0">return </span><span class="s1">draw(artist</span><span class="s0">, </span><span class="s1">renderer</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s1">draw_wrapper._supports_rasterization = </span><span class="s0">False</span>
    <span class="s0">return </span><span class="s1">draw_wrapper</span>


<span class="s0">def </span><span class="s1">allow_rasterization(draw):</span>
    <span class="s4">&quot;&quot;&quot; 
    Decorator for Artist.draw method. Provides routines 
    that run before and after the draw call. The before and after functions 
    are useful for changing artist-dependent renderer attributes or making 
    other setup function calls, such as starting and flushing a mixed-mode 
    renderer. 
    &quot;&quot;&quot;</span>

    <span class="s1">@wraps(draw)</span>
    <span class="s0">def </span><span class="s1">draw_wrapper(artist</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">artist.get_rasterized():</span>
                <span class="s0">if </span><span class="s1">renderer._raster_depth == </span><span class="s3">0 </span><span class="s0">and not </span><span class="s1">renderer._rasterizing:</span>
                    <span class="s1">renderer.start_rasterizing()</span>
                    <span class="s1">renderer._rasterizing = </span><span class="s0">True</span>
                <span class="s1">renderer._raster_depth += </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">renderer._raster_depth == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">renderer._rasterizing:</span>
                    <span class="s2"># Only stop when we are not in a rasterized parent</span>
                    <span class="s2"># and something has be rasterized since last stop</span>
                    <span class="s1">renderer.stop_rasterizing()</span>
                    <span class="s1">renderer._rasterizing = </span><span class="s0">False</span>

            <span class="s0">if </span><span class="s1">artist.get_agg_filter() </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">renderer.start_filter()</span>

            <span class="s0">return </span><span class="s1">draw(artist</span><span class="s0">, </span><span class="s1">renderer)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">artist.get_agg_filter() </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">renderer.stop_filter(artist.get_agg_filter())</span>
            <span class="s0">if </span><span class="s1">artist.get_rasterized():</span>
                <span class="s1">renderer._raster_depth -= </span><span class="s3">1</span>
            <span class="s0">if </span><span class="s1">(renderer._rasterizing </span><span class="s0">and </span><span class="s1">artist.figure </span><span class="s0">and</span>
                    <span class="s1">artist.figure.suppressComposite):</span>
                <span class="s2"># restart rasterizing to prevent merging</span>
                <span class="s1">renderer.stop_rasterizing()</span>
                <span class="s1">renderer.start_rasterizing()</span>

    <span class="s1">draw_wrapper._supports_rasterization = </span><span class="s0">True</span>
    <span class="s0">return </span><span class="s1">draw_wrapper</span>


<span class="s0">def </span><span class="s1">_finalize_rasterization(draw):</span>
    <span class="s4">&quot;&quot;&quot; 
    Decorator for Artist.draw method. Needed on the outermost artist, i.e. 
    Figure, to finish up if the render is still in rasterized mode. 
    &quot;&quot;&quot;</span>
    <span class="s1">@wraps(draw)</span>
    <span class="s0">def </span><span class="s1">draw_wrapper(artist</span><span class="s0">, </span><span class="s1">renderer</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">result = draw(artist</span><span class="s0">, </span><span class="s1">renderer</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">renderer._rasterizing:</span>
            <span class="s1">renderer.stop_rasterizing()</span>
            <span class="s1">renderer._rasterizing = </span><span class="s0">False</span>
        <span class="s0">return </span><span class="s1">result</span>
    <span class="s0">return </span><span class="s1">draw_wrapper</span>


<span class="s0">def </span><span class="s1">_stale_axes_callback(self</span><span class="s0">, </span><span class="s1">val):</span>
    <span class="s0">if </span><span class="s1">self.axes:</span>
        <span class="s1">self.axes.stale = val</span>


<span class="s1">_XYPair = namedtuple(</span><span class="s5">&quot;_XYPair&quot;</span><span class="s0">, </span><span class="s5">&quot;x y&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">_Unset:</span>
    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s5">&quot;&lt;UNSET&gt;&quot;</span>
<span class="s1">_UNSET = _Unset()</span>


<span class="s0">class </span><span class="s1">Artist:</span>
    <span class="s4">&quot;&quot;&quot; 
    Abstract base class for objects that render into a FigureCanvas. 
 
    Typically, all visible elements in a figure are subclasses of Artist. 
    &quot;&quot;&quot;</span>

    <span class="s1">zorder = </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">__init_subclass__(cls):</span>

        <span class="s2"># Decorate draw() method so that all artists are able to stop</span>
        <span class="s2"># rastrization when necessary. If the artist's draw method is already</span>
        <span class="s2"># decorated (has a `_supports_rasterization` attribute), it won't be</span>
        <span class="s2"># decorated.</span>

        <span class="s0">if not </span><span class="s1">hasattr(cls.draw</span><span class="s0">, </span><span class="s5">&quot;_supports_rasterization&quot;</span><span class="s1">):</span>
            <span class="s1">cls.draw = _prevent_rasterization(cls.draw)</span>

        <span class="s2"># Inject custom set() methods into the subclass with signature and</span>
        <span class="s2"># docstring based on the subclasses' properties.</span>

        <span class="s0">if not </span><span class="s1">hasattr(cls.set</span><span class="s0">, </span><span class="s5">'_autogenerated_signature'</span><span class="s1">):</span>
            <span class="s2"># Don't overwrite cls.set if the subclass or one of its parents</span>
            <span class="s2"># has defined a set method set itself.</span>
            <span class="s2"># If there was no explicit definition, cls.set is inherited from</span>
            <span class="s2"># the hierarchy of auto-generated set methods, which hold the</span>
            <span class="s2"># flag _autogenerated_signature.</span>
            <span class="s0">return</span>

        <span class="s1">cls.set = </span><span class="s0">lambda </span><span class="s1">self</span><span class="s0">, </span><span class="s1">**kwargs: Artist.set(self</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">cls.set.__name__ = </span><span class="s5">&quot;set&quot;</span>
        <span class="s1">cls.set.__qualname__ = </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">cls.__qualname__</span><span class="s0">}</span><span class="s5">.set&quot;</span>
        <span class="s1">cls._update_set_signature_and_docstring()</span>

    <span class="s1">_PROPERTIES_EXCLUDED_FROM_SET = [</span>
        <span class="s5">'navigate_mode'</span><span class="s0">,  </span><span class="s2"># not a user-facing function</span>
        <span class="s5">'figure'</span><span class="s0">,         </span><span class="s2"># changing the figure is such a profound operation</span>
                          <span class="s2"># that we don't want this in set()</span>
        <span class="s5">'3d_properties'</span><span class="s0">,  </span><span class="s2"># cannot be used as a keyword due to leading digit</span>
    <span class="s1">]</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_update_set_signature_and_docstring(cls):</span>
        <span class="s4">&quot;&quot;&quot; 
        Update the signature of the set function to list all properties 
        as keyword arguments. 
 
        Property aliases are not listed in the signature for brevity, but 
        are still accepted as keyword arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">cls.set.__signature__ = Signature(</span>
            <span class="s1">[Parameter(</span><span class="s5">&quot;self&quot;</span><span class="s0">, </span><span class="s1">Parameter.POSITIONAL_OR_KEYWORD)</span><span class="s0">,</span>
             <span class="s1">*[Parameter(prop</span><span class="s0">, </span><span class="s1">Parameter.KEYWORD_ONLY</span><span class="s0">, </span><span class="s1">default=_UNSET)</span>
               <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">ArtistInspector(cls).get_setters()</span>
               <span class="s0">if </span><span class="s1">prop </span><span class="s0">not in </span><span class="s1">Artist._PROPERTIES_EXCLUDED_FROM_SET]])</span>
        <span class="s1">cls.set._autogenerated_signature = </span><span class="s0">True</span>

        <span class="s1">cls.set.__doc__ = (</span>
            <span class="s5">&quot;Set multiple properties at once.</span><span class="s0">\n\n</span><span class="s5">&quot;</span>
            <span class="s5">&quot;Supported properties are</span><span class="s0">\n\n</span><span class="s5">&quot;</span>
            <span class="s1">+ kwdoc(cls))</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._stale = </span><span class="s0">True</span>
        <span class="s1">self.stale_callback = </span><span class="s0">None</span>
        <span class="s1">self._axes = </span><span class="s0">None</span>
        <span class="s1">self.figure = </span><span class="s0">None</span>

        <span class="s1">self._transform = </span><span class="s0">None</span>
        <span class="s1">self._transformSet = </span><span class="s0">False</span>
        <span class="s1">self._visible = </span><span class="s0">True</span>
        <span class="s1">self._animated = </span><span class="s0">False</span>
        <span class="s1">self._alpha = </span><span class="s0">None</span>
        <span class="s1">self.clipbox = </span><span class="s0">None</span>
        <span class="s1">self._clippath = </span><span class="s0">None</span>
        <span class="s1">self._clipon = </span><span class="s0">True</span>
        <span class="s1">self._label = </span><span class="s5">''</span>
        <span class="s1">self._picker = </span><span class="s0">None</span>
        <span class="s1">self._rasterized = </span><span class="s0">False</span>
        <span class="s1">self._agg_filter = </span><span class="s0">None</span>
        <span class="s2"># Normally, artist classes need to be queried for mouseover info if and</span>
        <span class="s2"># only if they override get_cursor_data.</span>
        <span class="s1">self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data</span>
        <span class="s1">self._callbacks = cbook.CallbackRegistry(signals=[</span><span class="s5">&quot;pchanged&quot;</span><span class="s1">])</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.axes = </span><span class="s0">None</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s2"># Handle self.axes as a read-only property, as in Figure.</span>
            <span class="s0">pass</span>
        <span class="s1">self._remove_method = </span><span class="s0">None</span>
        <span class="s1">self._url = </span><span class="s0">None</span>
        <span class="s1">self._gid = </span><span class="s0">None</span>
        <span class="s1">self._snap = </span><span class="s0">None</span>
        <span class="s1">self._sketch = mpl.rcParams[</span><span class="s5">'path.sketch'</span><span class="s1">]</span>
        <span class="s1">self._path_effects = mpl.rcParams[</span><span class="s5">'path.effects'</span><span class="s1">]</span>
        <span class="s1">self._sticky_edges = _XYPair([]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">self._in_layout = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">d = self.__dict__.copy()</span>
        <span class="s2"># remove the unpicklable remove method, this will get re-added on load</span>
        <span class="s2"># (by the Axes) if the artist lives on an Axes.</span>
        <span class="s1">d[</span><span class="s5">'stale_callback'</span><span class="s1">] = </span><span class="s0">None</span>
        <span class="s0">return </span><span class="s1">d</span>

    <span class="s0">def </span><span class="s1">remove(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Remove the artist from the figure if possible. 
 
        The effect will not be visible until the figure is redrawn, e.g., 
        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to 
        update the axes limits if desired. 
 
        Note: `~.axes.Axes.relim` will not see collections even if the 
        collection was added to the axes with *autolim* = True. 
 
        Note: there is no support for removing the artist's legend entry. 
        &quot;&quot;&quot;</span>

        <span class="s2"># There is no method to set the callback.  Instead, the parent should</span>
        <span class="s2"># set the _remove_method attribute directly.  This would be a</span>
        <span class="s2"># protected attribute if Python supported that sort of thing.  The</span>
        <span class="s2"># callback has one parameter, which is the child to be removed.</span>
        <span class="s0">if </span><span class="s1">self._remove_method </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._remove_method(self)</span>
            <span class="s2"># clear stale callback</span>
            <span class="s1">self.stale_callback = </span><span class="s0">None</span>
            <span class="s1">_ax_flag = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s5">'axes'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">self.axes:</span>
                <span class="s2"># remove from the mouse hit list</span>
                <span class="s1">self.axes._mouseover_set.discard(self)</span>
                <span class="s1">self.axes.stale = </span><span class="s0">True</span>
                <span class="s1">self.axes = </span><span class="s0">None  </span><span class="s2"># decouple the artist from the Axes</span>
                <span class="s1">_ax_flag = </span><span class="s0">True</span>

            <span class="s0">if </span><span class="s1">self.figure:</span>
                <span class="s1">self.figure = </span><span class="s0">None</span>
                <span class="s0">if not </span><span class="s1">_ax_flag:</span>
                    <span class="s1">self.figure = </span><span class="s0">True</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'cannot remove artist'</span><span class="s1">)</span>
        <span class="s2"># TODO: the fix for the collections relim problem is to move the</span>
        <span class="s2"># limits calculation into the artist itself, including the property of</span>
        <span class="s2"># whether or not the artist should affect the limits.  Then there will</span>
        <span class="s2"># be no distinction between axes.add_line, axes.add_patch, etc.</span>
        <span class="s2"># TODO: add legend support</span>

    <span class="s0">def </span><span class="s1">have_units(self):</span>
        <span class="s4">&quot;&quot;&quot;Return whether units are set on any axis.&quot;&quot;&quot;</span>
        <span class="s1">ax = self.axes</span>
        <span class="s0">return </span><span class="s1">ax </span><span class="s0">and </span><span class="s1">any(axis.have_units() </span><span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">ax._axis_map.values())</span>

    <span class="s0">def </span><span class="s1">convert_xunits(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert *x* using the unit type of the xaxis. 
 
        If the artist is not contained in an Axes or if the xaxis does not 
        have units, *x* itself is returned. 
        &quot;&quot;&quot;</span>
        <span class="s1">ax = getattr(self</span><span class="s0">, </span><span class="s5">'axes'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None or </span><span class="s1">ax.xaxis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">x</span>
        <span class="s0">return </span><span class="s1">ax.xaxis.convert_units(x)</span>

    <span class="s0">def </span><span class="s1">convert_yunits(self</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s4">&quot;&quot;&quot; 
        Convert *y* using the unit type of the yaxis. 
 
        If the artist is not contained in an Axes or if the yaxis does not 
        have units, *y* itself is returned. 
        &quot;&quot;&quot;</span>
        <span class="s1">ax = getattr(self</span><span class="s0">, </span><span class="s5">'axes'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">ax </span><span class="s0">is None or </span><span class="s1">ax.yaxis </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">y</span>
        <span class="s0">return </span><span class="s1">ax.yaxis.convert_units(y)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">axes(self):</span>
        <span class="s4">&quot;&quot;&quot;The `~.axes.Axes` instance the artist resides in, or *None*.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._axes</span>

    <span class="s1">@axes.setter</span>
    <span class="s0">def </span><span class="s1">axes(self</span><span class="s0">, </span><span class="s1">new_axes):</span>
        <span class="s0">if </span><span class="s1">(new_axes </span><span class="s0">is not None and </span><span class="s1">self._axes </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">new_axes != self._axes):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Can not reset the axes.  You are probably &quot;</span>
                             <span class="s5">&quot;trying to re-use an artist in more than one &quot;</span>
                             <span class="s5">&quot;Axes which is not supported&quot;</span><span class="s1">)</span>
        <span class="s1">self._axes = new_axes</span>
        <span class="s0">if </span><span class="s1">new_axes </span><span class="s0">is not None and </span><span class="s1">new_axes </span><span class="s0">is not </span><span class="s1">self:</span>
            <span class="s1">self.stale_callback = _stale_axes_callback</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">stale(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Whether the artist is 'stale' and needs to be re-drawn for the output 
        to match the internal state of the artist. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._stale</span>

    <span class="s1">@stale.setter</span>
    <span class="s0">def </span><span class="s1">stale(self</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s1">self._stale = val</span>

        <span class="s2"># if the artist is animated it does not take normal part in the</span>
        <span class="s2"># draw stack and is not expected to be drawn as part of the normal</span>
        <span class="s2"># draw loop (when not saving) so do not propagate this change</span>
        <span class="s0">if </span><span class="s1">self.get_animated():</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">val </span><span class="s0">and </span><span class="s1">self.stale_callback </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.stale_callback(self</span><span class="s0">, </span><span class="s1">val)</span>

    <span class="s0">def </span><span class="s1">get_window_extent(self</span><span class="s0">, </span><span class="s1">renderer=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the artist's bounding box in display space. 
 
        The bounding box' width and height are nonnegative. 
 
        Subclasses should override for inclusion in the bounding box 
        &quot;tight&quot; calculation. Default is to return an empty bounding 
        box at 0, 0. 
 
        Be careful when using this function, the results will not update 
        if the artist window extent of the artist changes.  The extent 
        can change due to any changes in the transform stack, such as 
        changing the axes limits, the figure size, or the canvas used 
        (as is done when saving a figure).  This can lead to unexpected 
        behavior where interactive figures will look fine on the screen, 
        but will save incorrectly. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">Bbox([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">get_tightbbox(self</span><span class="s0">, </span><span class="s1">renderer=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Like `.Artist.get_window_extent`, but includes any clipping. 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass 
            renderer that will be used to draw the figures (i.e. 
            ``fig.canvas.get_renderer()``) 
 
        Returns 
        ------- 
        `.Bbox` 
            The enclosing bounding box (in figure pixel coordinates). 
        &quot;&quot;&quot;</span>
        <span class="s1">bbox = self.get_window_extent(renderer)</span>
        <span class="s0">if </span><span class="s1">self.get_clip_on():</span>
            <span class="s1">clip_box = self.get_clip_box()</span>
            <span class="s0">if </span><span class="s1">clip_box </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">bbox = Bbox.intersection(bbox</span><span class="s0">, </span><span class="s1">clip_box)</span>
            <span class="s1">clip_path = self.get_clip_path()</span>
            <span class="s0">if </span><span class="s1">clip_path </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">clip_path = clip_path.get_fully_transformed_path()</span>
                <span class="s1">bbox = Bbox.intersection(bbox</span><span class="s0">, </span><span class="s1">clip_path.get_extents())</span>
        <span class="s0">return </span><span class="s1">bbox</span>

    <span class="s0">def </span><span class="s1">add_callback(self</span><span class="s0">, </span><span class="s1">func):</span>
        <span class="s4">&quot;&quot;&quot; 
        Add a callback function that will be called whenever one of the 
        `.Artist`'s properties changes. 
 
        Parameters 
        ---------- 
        func : callable 
            The callback function. It must have the signature:: 
 
                def func(artist: Artist) -&gt; Any 
 
            where *artist* is the calling `.Artist`. Return values may exist 
            but are ignored. 
 
        Returns 
        ------- 
        int 
            The observer id associated with the callback. This id can be 
            used for removing the callback with `.remove_callback` later. 
 
        See Also 
        -------- 
        remove_callback 
        &quot;&quot;&quot;</span>
        <span class="s2"># Wrapping func in a lambda ensures it can be connected multiple times</span>
        <span class="s2"># and never gets weakref-gc'ed.</span>
        <span class="s0">return </span><span class="s1">self._callbacks.connect(</span><span class="s5">&quot;pchanged&quot;</span><span class="s0">, lambda</span><span class="s1">: func(self))</span>

    <span class="s0">def </span><span class="s1">remove_callback(self</span><span class="s0">, </span><span class="s1">oid):</span>
        <span class="s4">&quot;&quot;&quot; 
        Remove a callback based on its observer id. 
 
        See Also 
        -------- 
        add_callback 
        &quot;&quot;&quot;</span>
        <span class="s1">self._callbacks.disconnect(oid)</span>

    <span class="s0">def </span><span class="s1">pchanged(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Call all of the registered callbacks. 
 
        This function is triggered internally when a property is changed. 
 
        See Also 
        -------- 
        add_callback 
        remove_callback 
        &quot;&quot;&quot;</span>
        <span class="s1">self._callbacks.process(</span><span class="s5">&quot;pchanged&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">is_transform_set(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return whether the Artist has an explicitly set transform. 
 
        This is *True* after `.set_transform` has been called. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._transformSet</span>

    <span class="s0">def </span><span class="s1">set_transform(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the artist transform. 
 
        Parameters 
        ---------- 
        t : `.Transform` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._transform = t</span>
        <span class="s1">self._transformSet = </span><span class="s0">True</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_transform(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the `.Transform` instance used by this artist.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._transform </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._transform = IdentityTransform()</span>
        <span class="s0">elif </span><span class="s1">(</span><span class="s0">not </span><span class="s1">isinstance(self._transform</span><span class="s0">, </span><span class="s1">Transform)</span>
              <span class="s0">and </span><span class="s1">hasattr(self._transform</span><span class="s0">, </span><span class="s5">'_as_mpl_transform'</span><span class="s1">)):</span>
            <span class="s1">self._transform = self._transform._as_mpl_transform(self.axes)</span>
        <span class="s0">return </span><span class="s1">self._transform</span>

    <span class="s0">def </span><span class="s1">get_children(self):</span>
        <span class="s4">r&quot;&quot;&quot;Return a list of the child `.Artist`\s of this `.Artist`.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">[]</span>

    <span class="s0">def </span><span class="s1">_default_contains(self</span><span class="s0">, </span><span class="s1">mouseevent</span><span class="s0">, </span><span class="s1">figure=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Base impl. for checking whether a mouseevent happened in an artist. 
 
        1. If the artist figure is known and the event did not occur in that 
           figure (by checking its ``canvas`` attribute), reject it. 
        2. Otherwise, return `None, {}`, indicating that the subclass' 
           implementation should be used. 
 
        Subclasses should start their definition of `contains` as follows: 
 
            inside, info = self._default_contains(mouseevent) 
            if inside is not None: 
                return inside, info 
            # subclass-specific implementation follows 
 
        The *figure* kwarg is provided for the implementation of 
        `.Figure.contains`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">figure </span><span class="s0">is not None and </span><span class="s1">mouseevent.canvas </span><span class="s0">is not </span><span class="s1">figure.canvas:</span>
            <span class="s0">return False, </span><span class="s1">{}</span>
        <span class="s0">return None, </span><span class="s1">{}</span>

    <span class="s0">def </span><span class="s1">contains(self</span><span class="s0">, </span><span class="s1">mouseevent):</span>
        <span class="s4">&quot;&quot;&quot; 
        Test whether the artist contains the mouse event. 
 
        Parameters 
        ---------- 
        mouseevent : `matplotlib.backend_bases.MouseEvent` 
 
        Returns 
        ------- 
        contains : bool 
            Whether any values are within the radius. 
        details : dict 
            An artist-specific dictionary of details of the event context, 
            such as which points are contained in the pick radius. See the 
            individual Artist subclasses for details. 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s0">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s0">if </span><span class="s1">inside </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">inside</span><span class="s0">, </span><span class="s1">info</span>
        <span class="s1">_log.warning(</span><span class="s5">&quot;%r needs 'contains' method&quot;</span><span class="s0">, </span><span class="s1">self.__class__.__name__)</span>
        <span class="s0">return False, </span><span class="s1">{}</span>

    <span class="s0">def </span><span class="s1">pickable(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return whether the artist is pickable. 
 
        See Also 
        -------- 
        set_picker, get_picker, pick 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.figure </span><span class="s0">is not None and </span><span class="s1">self._picker </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">pick(self</span><span class="s0">, </span><span class="s1">mouseevent):</span>
        <span class="s4">&quot;&quot;&quot; 
        Process a pick event. 
 
        Each child artist will fire a pick event if *mouseevent* is over 
        the artist and the artist has picker set. 
 
        See Also 
        -------- 
        set_picker, get_picker, pickable 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">.backend_bases </span><span class="s0">import </span><span class="s1">PickEvent  </span><span class="s2"># Circular import.</span>
        <span class="s2"># Pick self</span>
        <span class="s0">if </span><span class="s1">self.pickable():</span>
            <span class="s1">picker = self.get_picker()</span>
            <span class="s0">if </span><span class="s1">callable(picker):</span>
                <span class="s1">inside</span><span class="s0">, </span><span class="s1">prop = picker(self</span><span class="s0">, </span><span class="s1">mouseevent)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">inside</span><span class="s0">, </span><span class="s1">prop = self.contains(mouseevent)</span>
            <span class="s0">if </span><span class="s1">inside:</span>
                <span class="s1">PickEvent(</span><span class="s5">&quot;pick_event&quot;</span><span class="s0">, </span><span class="s1">self.figure.canvas</span><span class="s0">,</span>
                          <span class="s1">mouseevent</span><span class="s0">, </span><span class="s1">self</span><span class="s0">, </span><span class="s1">**prop)._process()</span>

        <span class="s2"># Pick children</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">self.get_children():</span>
            <span class="s2"># make sure the event happened in the same Axes</span>
            <span class="s1">ax = getattr(a</span><span class="s0">, </span><span class="s5">'axes'</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">(mouseevent.inaxes </span><span class="s0">is None or </span><span class="s1">ax </span><span class="s0">is None</span>
                    <span class="s0">or </span><span class="s1">mouseevent.inaxes == ax):</span>
                <span class="s2"># we need to check if mouseevent.inaxes is None</span>
                <span class="s2"># because some objects associated with an Axes (e.g., a</span>
                <span class="s2"># tick label) can be outside the bounding box of the</span>
                <span class="s2"># Axes and inaxes will be None</span>
                <span class="s2"># also check that ax is None so that it traverse objects</span>
                <span class="s2"># which do not have an axes property but children might</span>
                <span class="s1">a.pick(mouseevent)</span>

    <span class="s0">def </span><span class="s1">set_picker(self</span><span class="s0">, </span><span class="s1">picker):</span>
        <span class="s4">&quot;&quot;&quot; 
        Define the picking behavior of the artist. 
 
        Parameters 
        ---------- 
        picker : None or bool or float or callable 
            This can be one of the following: 
 
            - *None*: Picking is disabled for this artist (default). 
 
            - A boolean: If *True* then picking will be enabled and the 
              artist will fire a pick event if the mouse event is over 
              the artist. 
 
            - A float: If picker is a number it is interpreted as an 
              epsilon tolerance in points and the artist will fire 
              off an event if its data is within epsilon of the mouse 
              event.  For some artists like lines and patch collections, 
              the artist may provide additional data to the pick event 
              that is generated, e.g., the indices of the data within 
              epsilon of the pick event 
 
            - A function: If picker is callable, it is a user supplied 
              function which determines whether the artist is hit by the 
              mouse event:: 
 
                hit, props = picker(artist, mouseevent) 
 
              to determine the hit test.  if the mouse event is over the 
              artist, return *hit=True* and props is a dictionary of 
              properties you want added to the PickEvent attributes. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._picker = picker</span>

    <span class="s0">def </span><span class="s1">get_picker(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the picking behavior of the artist. 
 
        The possible values are described in `.set_picker`. 
 
        See Also 
        -------- 
        set_picker, pickable, pick 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._picker</span>

    <span class="s0">def </span><span class="s1">get_url(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the url.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._url</span>

    <span class="s0">def </span><span class="s1">set_url(self</span><span class="s0">, </span><span class="s1">url):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the url for the artist. 
 
        Parameters 
        ---------- 
        url : str 
        &quot;&quot;&quot;</span>
        <span class="s1">self._url = url</span>

    <span class="s0">def </span><span class="s1">get_gid(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the group id.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._gid</span>

    <span class="s0">def </span><span class="s1">set_gid(self</span><span class="s0">, </span><span class="s1">gid):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the (group) id for the artist. 
 
        Parameters 
        ---------- 
        gid : str 
        &quot;&quot;&quot;</span>
        <span class="s1">self._gid = gid</span>

    <span class="s0">def </span><span class="s1">get_snap(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the snap setting. 
 
        See `.set_snap` for details. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s5">'path.snap'</span><span class="s1">]:</span>
            <span class="s0">return </span><span class="s1">self._snap</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">set_snap(self</span><span class="s0">, </span><span class="s1">snap):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the snapping behavior. 
 
        Snapping aligns positions with the pixel grid, which results in 
        clearer images. For example, if a black line of 1px width was 
        defined at a position in between two pixels, the resulting image 
        would contain the interpolated value of that line in the pixel grid, 
        which would be a grey value on both adjacent pixel positions. In 
        contrast, snapping will move the line to the nearest integer pixel 
        value, so that the resulting image will really contain a 1px wide 
        black line. 
 
        Snapping is currently only supported by the Agg and MacOSX backends. 
 
        Parameters 
        ---------- 
        snap : bool or None 
            Possible values: 
 
            - *True*: Snap vertices to the nearest pixel center. 
            - *False*: Do not modify vertex positions. 
            - *None*: (auto) If the path contains only rectilinear line 
              segments, round to the nearest pixel center. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._snap = snap</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_sketch_params(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the sketch parameters for the artist. 
 
        Returns 
        ------- 
        tuple or None 
 
            A 3-tuple with the following elements: 
 
            - *scale*: The amplitude of the wiggle perpendicular to the 
              source line. 
            - *length*: The length of the wiggle along the line. 
            - *randomness*: The scale factor by which the length is 
              shrunken or expanded. 
 
            Returns *None* if no sketch parameters were set. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._sketch</span>

    <span class="s0">def </span><span class="s1">set_sketch_params(self</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">None, </span><span class="s1">length=</span><span class="s0">None, </span><span class="s1">randomness=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the sketch parameters. 
 
        Parameters 
        ---------- 
        scale : float, optional 
            The amplitude of the wiggle perpendicular to the source 
            line, in pixels.  If scale is `None`, or not provided, no 
            sketch filter will be provided. 
        length : float, optional 
             The length of the wiggle along the line, in pixels 
             (default 128.0) 
        randomness : float, optional 
            The scale factor by which the length is shrunken or 
            expanded (default 16.0) 
 
            The PGF backend uses this argument as an RNG seed and not as 
            described above. Using the same seed yields the same random shape. 
 
            .. ACCEPTS: (scale: float, length: float, randomness: float) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">scale </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._sketch = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._sketch = (scale</span><span class="s0">, </span><span class="s1">length </span><span class="s0">or </span><span class="s3">128.0</span><span class="s0">, </span><span class="s1">randomness </span><span class="s0">or </span><span class="s3">16.0</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_path_effects(self</span><span class="s0">, </span><span class="s1">path_effects):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the path effects. 
 
        Parameters 
        ---------- 
        path_effects : `.AbstractPathEffect` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._path_effects = path_effects</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_path_effects(self):</span>
        <span class="s0">return </span><span class="s1">self._path_effects</span>

    <span class="s0">def </span><span class="s1">get_figure(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the `.Figure` instance the artist belongs to.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.figure</span>

    <span class="s0">def </span><span class="s1">set_figure(self</span><span class="s0">, </span><span class="s1">fig):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the `.Figure` instance the artist belongs to. 
 
        Parameters 
        ---------- 
        fig : `.Figure` 
        &quot;&quot;&quot;</span>
        <span class="s2"># if this is a no-op just return</span>
        <span class="s0">if </span><span class="s1">self.figure </span><span class="s0">is </span><span class="s1">fig:</span>
            <span class="s0">return</span>
        <span class="s2"># if we currently have a figure (the case of both `self.figure`</span>
        <span class="s2"># and *fig* being none is taken care of above) we then user is</span>
        <span class="s2"># trying to change the figure an artist is associated with which</span>
        <span class="s2"># is not allowed for the same reason as adding the same instance</span>
        <span class="s2"># to more than one Axes</span>
        <span class="s0">if </span><span class="s1">self.figure </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s5">&quot;Can not put single artist in &quot;</span>
                               <span class="s5">&quot;more than one figure&quot;</span><span class="s1">)</span>
        <span class="s1">self.figure = fig</span>
        <span class="s0">if </span><span class="s1">self.figure </span><span class="s0">and </span><span class="s1">self.figure </span><span class="s0">is not </span><span class="s1">self:</span>
            <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_clip_box(self</span><span class="s0">, </span><span class="s1">clipbox):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the artist's clip `.Bbox`. 
 
        Parameters 
        ---------- 
        clipbox : `.Bbox` 
 
            Typically would be created from a `.TransformedBbox`. For 
            instance ``TransformedBbox(Bbox([[0, 0], [1, 1]]), ax.transAxes)`` 
            is the default clipping for an artist added to an Axes. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self.clipbox = clipbox</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_clip_path(self</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">transform=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the artist's clip path. 
 
        Parameters 
        ---------- 
        path : `.Patch` or `.Path` or `.TransformedPath` or None 
            The clip path. If given a `.Path`, *transform* must be provided as 
            well. If *None*, a previously set clip path is removed. 
        transform : `~matplotlib.transforms.Transform`, optional 
            Only used if *path* is a `.Path`, in which case the given `.Path` 
            is converted to a `.TransformedPath` using *transform*. 
 
        Notes 
        ----- 
        For efficiency, if *path* is a `.Rectangle` this method will set the 
        clipping box to the corresponding rectangle and set the clipping path 
        to ``None``. 
 
        For technical reasons (support of `~.Artist.set`), a tuple 
        (*path*, *transform*) is also accepted as a single positional 
        parameter. 
 
        .. ACCEPTS: Patch or (Path, Transform) or None 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">matplotlib.patches </span><span class="s0">import </span><span class="s1">Patch</span><span class="s0">, </span><span class="s1">Rectangle</span>

        <span class="s1">success = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">transform </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">Rectangle):</span>
                <span class="s1">self.clipbox = TransformedBbox(Bbox.unit()</span><span class="s0">,</span>
                                               <span class="s1">path.get_transform())</span>
                <span class="s1">self._clippath = </span><span class="s0">None</span>
                <span class="s1">success = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">Patch):</span>
                <span class="s1">self._clippath = TransformedPatchPath(path)</span>
                <span class="s1">success = </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s1">path</span><span class="s0">, </span><span class="s1">transform = path</span>

        <span class="s0">if </span><span class="s1">path </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._clippath = </span><span class="s0">None</span>
            <span class="s1">success = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">Path):</span>
            <span class="s1">self._clippath = TransformedPath(path</span><span class="s0">, </span><span class="s1">transform)</span>
            <span class="s1">success = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">TransformedPatchPath):</span>
            <span class="s1">self._clippath = path</span>
            <span class="s1">success = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">isinstance(path</span><span class="s0">, </span><span class="s1">TransformedPath):</span>
            <span class="s1">self._clippath = path</span>
            <span class="s1">success = </span><span class="s0">True</span>

        <span class="s0">if not </span><span class="s1">success:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">&quot;Invalid arguments to set_clip_path, of type {} and {}&quot;</span>
                <span class="s1">.format(type(path).__name__</span><span class="s0">, </span><span class="s1">type(transform).__name__))</span>
        <span class="s2"># This may result in the callbacks being hit twice, but guarantees they</span>
        <span class="s2"># will be hit at least once.</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_alpha(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the alpha value used for blending - not supported on all 
        backends. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._alpha</span>

    <span class="s0">def </span><span class="s1">get_visible(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the visibility.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._visible</span>

    <span class="s0">def </span><span class="s1">get_animated(self):</span>
        <span class="s4">&quot;&quot;&quot;Return whether the artist is animated.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._animated</span>

    <span class="s0">def </span><span class="s1">get_in_layout(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return boolean flag, ``True`` if artist is included in layout 
        calculations. 
 
        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`, 
        `.Figure.tight_layout()`, and 
        ``fig.savefig(fname, bbox_inches='tight')``. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._in_layout</span>

    <span class="s0">def </span><span class="s1">_fully_clipped_to_axes(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a boolean flag, ``True`` if the artist is clipped to the Axes 
        and can thus be skipped in layout calculations. Requires `get_clip_on` 
        is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents`` 
        is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch`` 
        is equivalent to ``ax.patch`` (if set). 
        &quot;&quot;&quot;</span>
        <span class="s2"># Note that ``clip_path.get_fully_transformed_path().get_extents()``</span>
        <span class="s2"># cannot be directly compared to ``axes.bbox.extents`` because the</span>
        <span class="s2"># extents may be undefined (i.e. equivalent to ``Bbox.null()``)</span>
        <span class="s2"># before the associated artist is drawn, and this method is meant</span>
        <span class="s2"># to determine whether ``axes.get_tightbbox()`` may bypass drawing</span>
        <span class="s1">clip_box = self.get_clip_box()</span>
        <span class="s1">clip_path = self.get_clip_path()</span>
        <span class="s0">return </span><span class="s1">(self.axes </span><span class="s0">is not None</span>
                <span class="s0">and </span><span class="s1">self.get_clip_on()</span>
                <span class="s0">and </span><span class="s1">(clip_box </span><span class="s0">is not None or </span><span class="s1">clip_path </span><span class="s0">is not None</span><span class="s1">)</span>
                <span class="s0">and </span><span class="s1">(clip_box </span><span class="s0">is None</span>
                     <span class="s0">or </span><span class="s1">np.all(clip_box.extents == self.axes.bbox.extents))</span>
                <span class="s0">and </span><span class="s1">(clip_path </span><span class="s0">is None</span>
                     <span class="s0">or </span><span class="s1">isinstance(clip_path</span><span class="s0">, </span><span class="s1">TransformedPatchPath)</span>
                     <span class="s0">and </span><span class="s1">clip_path._patch </span><span class="s0">is </span><span class="s1">self.axes.patch))</span>

    <span class="s0">def </span><span class="s1">get_clip_on(self):</span>
        <span class="s4">&quot;&quot;&quot;Return whether the artist uses clipping.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._clipon</span>

    <span class="s0">def </span><span class="s1">get_clip_box(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the clipbox.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.clipbox</span>

    <span class="s0">def </span><span class="s1">get_clip_path(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the clip path.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._clippath</span>

    <span class="s0">def </span><span class="s1">get_transformed_clip_path_and_affine(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the clip path with the non-affine part of its 
        transformation applied, and the remaining affine part of its 
        transformation. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._clippath </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._clippath.get_transformed_path_and_affine()</span>
        <span class="s0">return None, None</span>

    <span class="s0">def </span><span class="s1">set_clip_on(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set whether the artist uses clipping. 
 
        When False, artists will be visible outside the Axes which 
        can lead to unexpected results. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._clipon = b</span>
        <span class="s2"># This may result in the callbacks being hit twice, but ensures they</span>
        <span class="s2"># are hit at least once</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_set_gc_clip(self</span><span class="s0">, </span><span class="s1">gc):</span>
        <span class="s4">&quot;&quot;&quot;Set the clip properly for the gc.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._clipon:</span>
            <span class="s0">if </span><span class="s1">self.clipbox </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">gc.set_clip_rectangle(self.clipbox)</span>
            <span class="s1">gc.set_clip_path(self._clippath)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">gc.set_clip_rectangle(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">gc.set_clip_path(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_rasterized(self):</span>
        <span class="s4">&quot;&quot;&quot;Return whether the artist is to be rasterized.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._rasterized</span>

    <span class="s0">def </span><span class="s1">set_rasterized(self</span><span class="s0">, </span><span class="s1">rasterized):</span>
        <span class="s4">&quot;&quot;&quot; 
        Force rasterized (bitmap) drawing for vector graphics output. 
 
        Rasterized drawing is not supported by all artists. If you try to 
        enable this on an artist that does not support it, the command has no 
        effect and a warning will be issued. 
 
        This setting is ignored for pixel-based output. 
 
        See also :doc:`/gallery/misc/rasterization_demo`. 
 
        Parameters 
        ---------- 
        rasterized : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">supports_rasterization = getattr(self.draw</span><span class="s0">,</span>
                                         <span class="s5">&quot;_supports_rasterization&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">rasterized </span><span class="s0">and not </span><span class="s1">supports_rasterization:</span>
            <span class="s1">_api.warn_external(</span><span class="s5">f&quot;Rasterization of '</span><span class="s0">{</span><span class="s1">self</span><span class="s0">}</span><span class="s5">' will be ignored&quot;</span><span class="s1">)</span>

        <span class="s1">self._rasterized = rasterized</span>

    <span class="s0">def </span><span class="s1">get_agg_filter(self):</span>
        <span class="s4">&quot;&quot;&quot;Return filter function to be used for agg filter.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._agg_filter</span>

    <span class="s0">def </span><span class="s1">set_agg_filter(self</span><span class="s0">, </span><span class="s1">filter_func):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the agg filter. 
 
        Parameters 
        ---------- 
        filter_func : callable 
            A filter function, which takes a (m, n, depth) float array 
            and a dpi value, and returns a (m, n, depth) array and two 
            offsets from the bottom left corner of the image 
 
            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array 
                and a dpi value, and returns a (m, n, 3) array and two offsets 
                from the bottom left corner of the image 
        &quot;&quot;&quot;</span>
        <span class="s1">self._agg_filter = filter_func</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">draw(self</span><span class="s0">, </span><span class="s1">renderer):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw the Artist (and its children) using the given renderer. 
 
        This has no effect if the artist is not visible (`.Artist.get_visible` 
        returns False). 
 
        Parameters 
        ---------- 
        renderer : `.RendererBase` subclass. 
 
        Notes 
        ----- 
        This method is overridden in the Artist subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.get_visible():</span>
            <span class="s0">return</span>
        <span class="s1">self.stale = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">set_alpha(self</span><span class="s0">, </span><span class="s1">alpha):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the alpha value used for blending - not supported on all backends. 
 
        Parameters 
        ---------- 
        alpha : scalar or None 
            *alpha* must be within the 0-1 range, inclusive. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">alpha </span><span class="s0">is not None and not </span><span class="s1">isinstance(alpha</span><span class="s0">, </span><span class="s1">Number):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f'alpha must be numeric or None, not </span><span class="s0">{</span><span class="s1">type(alpha)</span><span class="s0">}</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">alpha </span><span class="s0">is not None and not </span><span class="s1">(</span><span class="s3">0 </span><span class="s1">&lt;= alpha &lt;= </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f'alpha (</span><span class="s0">{</span><span class="s1">alpha</span><span class="s0">}</span><span class="s5">) is outside 0-1 range'</span><span class="s1">)</span>
        <span class="s1">self._alpha = alpha</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">_set_alpha_for_array(self</span><span class="s0">, </span><span class="s1">alpha):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the alpha value used for blending - not supported on all backends. 
 
        Parameters 
        ---------- 
        alpha : array-like or scalar or None 
            All values must be within the 0-1 range, inclusive. 
            Masked values and nans are not supported. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(alpha</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;alpha must be numeric or None, not a string&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">np.iterable(alpha):</span>
            <span class="s1">Artist.set_alpha(self</span><span class="s0">, </span><span class="s1">alpha)</span>
            <span class="s0">return</span>
        <span class="s1">alpha = np.asarray(alpha)</span>
        <span class="s0">if not </span><span class="s1">(</span><span class="s3">0 </span><span class="s1">&lt;= alpha.min() </span><span class="s0">and </span><span class="s1">alpha.max() &lt;= </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'alpha must be between 0 and 1, inclusive, '</span>
                             <span class="s5">f'but min is </span><span class="s0">{</span><span class="s1">alpha.min()</span><span class="s0">}</span><span class="s5">, max is </span><span class="s0">{</span><span class="s1">alpha.max()</span><span class="s0">}</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">self._alpha = alpha</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_visible(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the artist's visibility. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._visible = b</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">set_animated(self</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set whether the artist is intended to be used in an animation. 
 
        If True, the artist is excluded from regular drawing of the figure. 
        You have to call `.Figure.draw_artist` / `.Axes.draw_artist` 
        explicitly on the artist. This approach is used to speed up animations 
        using blitting. 
 
        See also `matplotlib.animation` and 
        :doc:`/tutorials/advanced/blitting`. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._animated != b:</span>
            <span class="s1">self._animated = b</span>
            <span class="s1">self.pchanged()</span>

    <span class="s0">def </span><span class="s1">set_in_layout(self</span><span class="s0">, </span><span class="s1">in_layout):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set if artist is to be included in layout calculations, 
        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`, 
        `.Figure.tight_layout()`, and 
        ``fig.savefig(fname, bbox_inches='tight')``. 
 
        Parameters 
        ---------- 
        in_layout : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._in_layout = in_layout</span>

    <span class="s0">def </span><span class="s1">get_label(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the label used for this artist in the legend.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._label</span>

    <span class="s0">def </span><span class="s1">set_label(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set a label that will be displayed in the legend. 
 
        Parameters 
        ---------- 
        s : object 
            *s* will be converted to a string by calling `str`. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">s </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self._label = str(s)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._label = </span><span class="s0">None</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">get_zorder(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the artist's zorder.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.zorder</span>

    <span class="s0">def </span><span class="s1">set_zorder(self</span><span class="s0">, </span><span class="s1">level):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set the zorder for the artist.  Artists with lower zorder 
        values are drawn first. 
 
        Parameters 
        ---------- 
        level : float 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">level </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">level = self.__class__.zorder</span>
        <span class="s1">self.zorder = level</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">sticky_edges(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        ``x`` and ``y`` sticky edge lists for autoscaling. 
 
        When performing autoscaling, if a data limit coincides with a value in 
        the corresponding sticky_edges list, then no margin will be added--the 
        view limit &quot;sticks&quot; to the edge. A typical use case is histograms, 
        where one usually expects no margin on the bottom edge (0) of the 
        histogram. 
 
        Moreover, margin expansion &quot;bumps&quot; against sticky edges and cannot 
        cross them.  For example, if the upper data limit is 1.0, the upper 
        view limit computed by simple margin application is 1.2, but there is a 
        sticky edge at 1.1, then the actual upper view limit will be 1.1. 
 
        This attribute cannot be assigned to; however, the ``x`` and ``y`` 
        lists can be modified in place as needed. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; artist.sticky_edges.x[:] = (xmin, xmax) 
        &gt;&gt;&gt; artist.sticky_edges.y[:] = (ymin, ymax) 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._sticky_edges</span>

    <span class="s0">def </span><span class="s1">update_from(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s4">&quot;&quot;&quot;Copy properties from *other* to *self*.&quot;&quot;&quot;</span>
        <span class="s1">self._transform = other._transform</span>
        <span class="s1">self._transformSet = other._transformSet</span>
        <span class="s1">self._visible = other._visible</span>
        <span class="s1">self._alpha = other._alpha</span>
        <span class="s1">self.clipbox = other.clipbox</span>
        <span class="s1">self._clipon = other._clipon</span>
        <span class="s1">self._clippath = other._clippath</span>
        <span class="s1">self._label = other._label</span>
        <span class="s1">self._sketch = other._sketch</span>
        <span class="s1">self._path_effects = other._path_effects</span>
        <span class="s1">self.sticky_edges.x[:] = other.sticky_edges.x.copy()</span>
        <span class="s1">self.sticky_edges.y[:] = other.sticky_edges.y.copy()</span>
        <span class="s1">self.pchanged()</span>
        <span class="s1">self.stale = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">properties(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a dictionary of all the properties of the artist.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">ArtistInspector(self).properties()</span>

    <span class="s0">def </span><span class="s1">_update_props(self</span><span class="s0">, </span><span class="s1">props</span><span class="s0">, </span><span class="s1">errfmt):</span>
        <span class="s4">&quot;&quot;&quot; 
        Helper for `.Artist.set` and `.Artist.update`. 
 
        *errfmt* is used to generate error messages for invalid property 
        names; it gets formatted with ``type(self)`` and the property name. 
        &quot;&quot;&quot;</span>
        <span class="s1">ret = []</span>
        <span class="s0">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s0">, </span><span class="s1">eventson=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">props.items():</span>
                <span class="s2"># Allow attributes we want to be able to update through</span>
                <span class="s2"># art.update, art.set, setp.</span>
                <span class="s0">if </span><span class="s1">k == </span><span class="s5">&quot;axes&quot;</span><span class="s1">:</span>
                    <span class="s1">ret.append(setattr(self</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">func = getattr(self</span><span class="s0">, </span><span class="s5">f&quot;set_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                    <span class="s0">if not </span><span class="s1">callable(func):</span>
                        <span class="s0">raise </span><span class="s1">AttributeError(</span>
                            <span class="s1">errfmt.format(cls=type(self)</span><span class="s0">, </span><span class="s1">prop_name=k))</span>
                    <span class="s1">ret.append(func(v))</span>
        <span class="s0">if </span><span class="s1">ret:</span>
            <span class="s1">self.pchanged()</span>
            <span class="s1">self.stale = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">ret</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">props):</span>
        <span class="s4">&quot;&quot;&quot; 
        Update this artist's properties from the dict *props*. 
 
        Parameters 
        ---------- 
        props : dict 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._update_props(</span>
            <span class="s1">props</span><span class="s0">, </span><span class="s5">&quot;{cls.__name__!r} object has no property {prop_name!r}&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_internal_update(self</span><span class="s0">, </span><span class="s1">kwargs):</span>
        <span class="s4">&quot;&quot;&quot; 
        Update artist properties without prenormalizing them, but generating 
        errors as if calling `set`. 
 
        The lack of prenormalization is to maintain backcompatibility. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._update_props(</span>
            <span class="s1">kwargs</span><span class="s0">, </span><span class="s5">&quot;{cls.__name__}.set() got an unexpected keyword argument &quot;</span>
            <span class="s5">&quot;{prop_name!r}&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2"># docstring and signature are auto-generated via</span>
        <span class="s2"># Artist._update_set_signature_and_docstring() at the end of the</span>
        <span class="s2"># module.</span>
        <span class="s0">return </span><span class="s1">self._internal_update(cbook.normalize_kwargs(kwargs</span><span class="s0">, </span><span class="s1">self))</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s0">def </span><span class="s1">_cm_set(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s4">&quot;&quot;&quot; 
        `.Artist.set` context-manager that restores original values at exit. 
        &quot;&quot;&quot;</span>
        <span class="s1">orig_vals = {k: getattr(self</span><span class="s0">, </span><span class="s5">f&quot;get_</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)() </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">kwargs}</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.set(**kwargs)</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">self.set(**orig_vals)</span>

    <span class="s0">def </span><span class="s1">findobj(self</span><span class="s0">, </span><span class="s1">match=</span><span class="s0">None, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Find artist objects. 
 
        Recursively find all `.Artist` instances contained in the artist. 
 
        Parameters 
        ---------- 
        match 
            A filter criterion for the matches. This can be 
 
            - *None*: Return all objects contained in artist. 
            - A function with signature ``def match(artist: Artist) -&gt; bool``. 
              The result will only contain artists for which the function 
              returns *True*. 
            - A class instance: e.g., `.Line2D`. The result will only contain 
              artists of this class or its subclasses (``isinstance`` check). 
 
        include_self : bool 
            Include *self* in the list to be checked for a match. 
 
        Returns 
        ------- 
        list of `.Artist` 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">match </span><span class="s0">is None</span><span class="s1">:  </span><span class="s2"># always return True</span>
            <span class="s0">def </span><span class="s1">matchfunc(x):</span>
                <span class="s0">return True</span>
        <span class="s0">elif </span><span class="s1">isinstance(match</span><span class="s0">, </span><span class="s1">type) </span><span class="s0">and </span><span class="s1">issubclass(match</span><span class="s0">, </span><span class="s1">Artist):</span>
            <span class="s0">def </span><span class="s1">matchfunc(x):</span>
                <span class="s0">return </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">match)</span>
        <span class="s0">elif </span><span class="s1">callable(match):</span>
            <span class="s1">matchfunc = match</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'match must be None, a matplotlib.artist.Artist '</span>
                             <span class="s5">'subclass, or a callable'</span><span class="s1">)</span>

        <span class="s1">artists = sum([c.findobj(matchfunc) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self.get_children()]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s0">if </span><span class="s1">include_self </span><span class="s0">and </span><span class="s1">matchfunc(self):</span>
            <span class="s1">artists.append(self)</span>
        <span class="s0">return </span><span class="s1">artists</span>

    <span class="s0">def </span><span class="s1">get_cursor_data(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the cursor data for a given event. 
 
        .. note:: 
            This method is intended to be overridden by artist subclasses. 
            As an end-user of Matplotlib you will most likely not call this 
            method yourself. 
 
        Cursor data can be used by Artists to provide additional context 
        information for a given event. The default implementation just returns 
        *None*. 
 
        Subclasses can override the method and return arbitrary data. However, 
        when doing so, they must ensure that `.format_cursor_data` can convert 
        the data to a string representation. 
 
        The only current use case is displaying the z-value of an `.AxesImage` 
        in the status bar of a plot window, while moving the mouse. 
 
        Parameters 
        ---------- 
        event : `matplotlib.backend_bases.MouseEvent` 
 
        See Also 
        -------- 
        format_cursor_data 
 
        &quot;&quot;&quot;</span>
        <span class="s0">return None</span>

    <span class="s0">def </span><span class="s1">format_cursor_data(self</span><span class="s0">, </span><span class="s1">data):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a string representation of *data*. 
 
        .. note:: 
            This method is intended to be overridden by artist subclasses. 
            As an end-user of Matplotlib you will most likely not call this 
            method yourself. 
 
        The default implementation converts ints and floats and arrays of ints 
        and floats into a comma-separated string enclosed in square brackets, 
        unless the artist has an associated colorbar, in which case scalar 
        values are formatted using the colorbar's formatter. 
 
        See Also 
        -------- 
        get_cursor_data 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">np.ndim(data) == </span><span class="s3">0 </span><span class="s0">and </span><span class="s1">isinstance(self</span><span class="s0">, </span><span class="s1">ScalarMappable):</span>
            <span class="s2"># This block logically belongs to ScalarMappable, but can't be</span>
            <span class="s2"># implemented in it because most ScalarMappable subclasses inherit</span>
            <span class="s2"># from Artist first and from ScalarMappable second, so</span>
            <span class="s2"># Artist.format_cursor_data would always have precedence over</span>
            <span class="s2"># ScalarMappable.format_cursor_data.</span>
            <span class="s1">n = self.cmap.N</span>
            <span class="s0">if </span><span class="s1">np.ma.getmask(data):</span>
                <span class="s0">return </span><span class="s5">&quot;[]&quot;</span>
            <span class="s1">normed = self.norm(data)</span>
            <span class="s0">if </span><span class="s1">np.isfinite(normed):</span>
                <span class="s0">if </span><span class="s1">isinstance(self.norm</span><span class="s0">, </span><span class="s1">BoundaryNorm):</span>
                    <span class="s2"># not an invertible normalization mapping</span>
                    <span class="s1">cur_idx = np.argmin(np.abs(self.norm.boundaries - data))</span>
                    <span class="s1">neigh_idx = max(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cur_idx - </span><span class="s3">1</span><span class="s1">)</span>
                    <span class="s2"># use max diff to prevent delta == 0</span>
                    <span class="s1">delta = np.diff(</span>
                        <span class="s1">self.norm.boundaries[neigh_idx:cur_idx + </span><span class="s3">2</span><span class="s1">]</span>
                    <span class="s1">).max()</span>

                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># Midpoints of neighboring color intervals.</span>
                    <span class="s1">neighbors = self.norm.inverse(</span>
                        <span class="s1">(int(normed * n) + np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])) / n)</span>
                    <span class="s1">delta = abs(neighbors - data).max()</span>
                <span class="s1">g_sig_digits = cbook._g_sig_digits(data</span><span class="s0">, </span><span class="s1">delta)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">g_sig_digits = </span><span class="s3">3  </span><span class="s2"># Consistent with default below.</span>
            <span class="s0">return </span><span class="s5">&quot;[{:-#.{}g}]&quot;</span><span class="s1">.format(data</span><span class="s0">, </span><span class="s1">g_sig_digits)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">data[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">IndexError):</span>
                <span class="s1">data = [data]</span>
            <span class="s1">data_str = </span><span class="s5">', '</span><span class="s1">.join(</span><span class="s5">'{:0.3g}'</span><span class="s1">.format(item) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">data</span>
                                 <span class="s0">if </span><span class="s1">isinstance(item</span><span class="s0">, </span><span class="s1">Number))</span>
            <span class="s0">return </span><span class="s5">&quot;[&quot; </span><span class="s1">+ data_str + </span><span class="s5">&quot;]&quot;</span>

    <span class="s0">def </span><span class="s1">get_mouseover(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return whether this artist is queried for custom context information 
        when the mouse cursor moves over it. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._mouseover</span>

    <span class="s0">def </span><span class="s1">set_mouseover(self</span><span class="s0">, </span><span class="s1">mouseover):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set whether this artist is queried for custom context information when 
        the mouse cursor moves over it. 
 
        Parameters 
        ---------- 
        mouseover : bool 
 
        See Also 
        -------- 
        get_cursor_data 
        .ToolCursorPosition 
        .NavigationToolbar2 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mouseover = bool(mouseover)</span>
        <span class="s1">ax = self.axes</span>
        <span class="s0">if </span><span class="s1">ax:</span>
            <span class="s0">if </span><span class="s1">self._mouseover:</span>
                <span class="s1">ax._mouseover_set.add(self)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">ax._mouseover_set.discard(self)</span>

    <span class="s1">mouseover = property(get_mouseover</span><span class="s0">, </span><span class="s1">set_mouseover)  </span><span class="s2"># backcompat.</span>


<span class="s0">def </span><span class="s1">_get_tightbbox_for_layout_only(obj</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a 
    *for_layout_only* kwarg; this helper tries to use the kwarg but skips it 
    when encountering third-party subclasses that do not support it. 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">obj.get_tightbbox(*args</span><span class="s0">, </span><span class="s1">**{**kwargs</span><span class="s0">, </span><span class="s5">&quot;for_layout_only&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">})</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return </span><span class="s1">obj.get_tightbbox(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">ArtistInspector:</span>
    <span class="s4">&quot;&quot;&quot; 
    A helper class to inspect an `~matplotlib.artist.Artist` and return 
    information about its settable properties and their current values. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">o):</span>
        <span class="s4">r&quot;&quot;&quot; 
        Initialize the artist inspector with an `Artist` or an iterable of 
        `Artist`\s.  If an iterable is used, we assume it is a homogeneous 
        sequence (all `Artist`\s are of the same type) and it is your 
        responsibility to make sure this is so. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(o</span><span class="s0">, </span><span class="s1">Artist):</span>
            <span class="s0">if </span><span class="s1">np.iterable(o):</span>
                <span class="s1">o = list(o)</span>
                <span class="s0">if </span><span class="s1">len(o):</span>
                    <span class="s1">o = o[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">self.oorig = o</span>
        <span class="s0">if not </span><span class="s1">isinstance(o</span><span class="s0">, </span><span class="s1">type):</span>
            <span class="s1">o = type(o)</span>
        <span class="s1">self.o = o</span>

        <span class="s1">self.aliasd = self.get_aliases()</span>

    <span class="s0">def </span><span class="s1">get_aliases(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get a dict mapping property fullnames to sets of aliases for each alias 
        in the :class:`~matplotlib.artist.ArtistInspector`. 
 
        e.g., for lines:: 
 
          {'markerfacecolor': {'mfc'}, 
           'linewidth'      : {'lw'}, 
          } 
        &quot;&quot;&quot;</span>
        <span class="s1">names = [name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(self.o)</span>
                 <span class="s0">if </span><span class="s1">name.startswith((</span><span class="s5">'set_'</span><span class="s0">, </span><span class="s5">'get_'</span><span class="s1">))</span>
                    <span class="s0">and </span><span class="s1">callable(getattr(self.o</span><span class="s0">, </span><span class="s1">name))]</span>
        <span class="s1">aliases = {}</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s1">func = getattr(self.o</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s0">if not </span><span class="s1">self.is_alias(func):</span>
                <span class="s0">continue</span>
            <span class="s1">propname = re.search(</span><span class="s5">&quot;`({}.*)`&quot;</span><span class="s1">.format(name[:</span><span class="s3">4</span><span class="s1">])</span><span class="s0">,  </span><span class="s2"># get_.*/set_.*</span>
                                 <span class="s1">inspect.getdoc(func)).group(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">aliases.setdefault(propname[</span><span class="s3">4</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">set()).add(name[</span><span class="s3">4</span><span class="s1">:])</span>
        <span class="s0">return </span><span class="s1">aliases</span>

    <span class="s1">_get_valid_values_regex = re.compile(</span>
        <span class="s5">r&quot;\n\s*(?:\.\.\s+)?ACCEPTS:\s*((?:.|\n)*?)(?:$|(?:\n\n))&quot;</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_valid_values(self</span><span class="s0">, </span><span class="s1">attr):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the legal arguments for the setter associated with *attr*. 
 
        This is done by querying the docstring of the setter for a line that 
        begins with &quot;ACCEPTS:&quot; or &quot;.. ACCEPTS:&quot;, and then by looking for a 
        numpydoc-style documentation for the setter's first argument. 
        &quot;&quot;&quot;</span>

        <span class="s1">name = </span><span class="s5">'set_%s' </span><span class="s1">% attr</span>
        <span class="s0">if not </span><span class="s1">hasattr(self.o</span><span class="s0">, </span><span class="s1">name):</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s5">'%s has no function %s' </span><span class="s1">% (self.o</span><span class="s0">, </span><span class="s1">name))</span>
        <span class="s1">func = getattr(self.o</span><span class="s0">, </span><span class="s1">name)</span>

        <span class="s1">docstring = inspect.getdoc(func)</span>
        <span class="s0">if </span><span class="s1">docstring </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s5">'unknown'</span>

        <span class="s0">if </span><span class="s1">docstring.startswith(</span><span class="s5">'Alias for '</span><span class="s1">):</span>
            <span class="s0">return None</span>

        <span class="s1">match = self._get_valid_values_regex.search(docstring)</span>
        <span class="s0">if </span><span class="s1">match </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">re.sub(</span><span class="s5">&quot;</span><span class="s0">\n </span><span class="s5">*&quot;</span><span class="s0">, </span><span class="s5">&quot; &quot;</span><span class="s0">, </span><span class="s1">match.group(</span><span class="s3">1</span><span class="s1">))</span>

        <span class="s2"># Much faster than list(inspect.signature(func).parameters)[1],</span>
        <span class="s2"># although barely relevant wrt. matplotlib's total import time.</span>
        <span class="s1">param_name = func.__code__.co_varnames[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2"># We could set the presence * based on whether the parameter is a</span>
        <span class="s2"># varargs (it can't be a varkwargs) but it's not really worth it.</span>
        <span class="s1">match = re.search(</span><span class="s5">r&quot;(?m)^ *\*?{} : (.+)&quot;</span><span class="s1">.format(param_name)</span><span class="s0">, </span><span class="s1">docstring)</span>
        <span class="s0">if </span><span class="s1">match:</span>
            <span class="s0">return </span><span class="s1">match.group(</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s5">'unknown'</span>

    <span class="s0">def </span><span class="s1">_replace_path(self</span><span class="s0">, </span><span class="s1">source_class):</span>
        <span class="s4">&quot;&quot;&quot; 
        Changes the full path to the public API path that is used 
        in sphinx. This is needed for links to work. 
        &quot;&quot;&quot;</span>
        <span class="s1">replace_dict = {</span><span class="s5">'_base._AxesBase'</span><span class="s1">: </span><span class="s5">'Axes'</span><span class="s0">,</span>
                        <span class="s5">'_axes.Axes'</span><span class="s1">: </span><span class="s5">'Axes'</span><span class="s1">}</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">replace_dict.items():</span>
            <span class="s1">source_class = source_class.replace(key</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">return </span><span class="s1">source_class</span>

    <span class="s0">def </span><span class="s1">get_setters(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the attribute strings with setters for object. 
 
        For example, for a line, return ``['markerfacecolor', 'linewidth', 
        ....]``. 
        &quot;&quot;&quot;</span>
        <span class="s1">setters = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(self.o):</span>
            <span class="s0">if not </span><span class="s1">name.startswith(</span><span class="s5">'set_'</span><span class="s1">):</span>
                <span class="s0">continue</span>
            <span class="s1">func = getattr(self.o</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">not </span><span class="s1">callable(func)</span>
                    <span class="s0">or </span><span class="s1">self.number_of_parameters(func) &lt; </span><span class="s3">2</span>
                    <span class="s0">or </span><span class="s1">self.is_alias(func)):</span>
                <span class="s0">continue</span>
            <span class="s1">setters.append(name[</span><span class="s3">4</span><span class="s1">:])</span>
        <span class="s0">return </span><span class="s1">setters</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@lru_cache(maxsize=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">number_of_parameters(func):</span>
        <span class="s4">&quot;&quot;&quot;Return number of parameters of the callable *func*.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">len(inspect.signature(func).parameters)</span>

    <span class="s1">@staticmethod</span>
    <span class="s1">@lru_cache(maxsize=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">is_alias(method):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return whether the object *method* is an alias for another method. 
        &quot;&quot;&quot;</span>

        <span class="s1">ds = inspect.getdoc(method)</span>
        <span class="s0">if </span><span class="s1">ds </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return False</span>

        <span class="s0">return </span><span class="s1">ds.startswith(</span><span class="s5">'Alias for '</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">aliased_name(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'. 
 
        For example, for the line markerfacecolor property, which has an 
        alias, return 'markerfacecolor or mfc' and for the transform 
        property, which does not, return 'transform'. 
        &quot;&quot;&quot;</span>
        <span class="s1">aliases = </span><span class="s5">''</span><span class="s1">.join(</span><span class="s5">' or %s' </span><span class="s1">% x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">sorted(self.aliasd.get(s</span><span class="s0">, </span><span class="s1">[])))</span>
        <span class="s0">return </span><span class="s1">s + aliases</span>

    <span class="s1">_NOT_LINKABLE = {</span>
        <span class="s2"># A set of property setter methods that are not available in our</span>
        <span class="s2"># current docs. This is a workaround used to prevent trying to link</span>
        <span class="s2"># these setters which would lead to &quot;target reference not found&quot;</span>
        <span class="s2"># warnings during doc build.</span>
        <span class="s5">'matplotlib.image._ImageBase.set_alpha'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_array'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_data'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_filternorm'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_filterrad'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_interpolation'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_interpolation_stage'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.image._ImageBase.set_resample'</span><span class="s0">,</span>
        <span class="s5">'matplotlib.text._AnnotationBase.set_annotation_clip'</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">aliased_name_rest(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">target):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME', 
        formatted for reST. 
 
        For example, for the line markerfacecolor property, which has an 
        alias, return 'markerfacecolor or mfc' and for the transform 
        property, which does not, return 'transform'. 
        &quot;&quot;&quot;</span>
        <span class="s2"># workaround to prevent &quot;reference target not found&quot;</span>
        <span class="s0">if </span><span class="s1">target </span><span class="s0">in </span><span class="s1">self._NOT_LINKABLE:</span>
            <span class="s0">return </span><span class="s5">f'``</span><span class="s0">{</span><span class="s1">s</span><span class="s0">}</span><span class="s5">``'</span>

        <span class="s1">aliases = </span><span class="s5">''</span><span class="s1">.join(</span><span class="s5">' or %s' </span><span class="s1">% x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">sorted(self.aliasd.get(s</span><span class="s0">, </span><span class="s1">[])))</span>
        <span class="s0">return </span><span class="s5">':meth:`%s &lt;%s&gt;`%s' </span><span class="s1">% (s</span><span class="s0">, </span><span class="s1">target</span><span class="s0">, </span><span class="s1">aliases)</span>

    <span class="s0">def </span><span class="s1">pprint_setters(self</span><span class="s0">, </span><span class="s1">prop=</span><span class="s0">None, </span><span class="s1">leadingspace=</span><span class="s3">2</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        If *prop* is *None*, return a list of strings of all settable 
        properties and their valid values. 
 
        If *prop* is not *None*, it is a valid property name and that 
        property will be returned as a string of property : valid 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">leadingspace:</span>
            <span class="s1">pad = </span><span class="s5">' ' </span><span class="s1">* leadingspace</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pad = </span><span class="s5">''</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">accepts = self.get_valid_values(prop)</span>
            <span class="s0">return </span><span class="s5">'%s%s: %s' </span><span class="s1">% (pad</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">accepts)</span>

        <span class="s1">lines = []</span>
        <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">sorted(self.get_setters()):</span>
            <span class="s1">accepts = self.get_valid_values(prop)</span>
            <span class="s1">name = self.aliased_name(prop)</span>
            <span class="s1">lines.append(</span><span class="s5">'%s%s: %s' </span><span class="s1">% (pad</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">accepts))</span>
        <span class="s0">return </span><span class="s1">lines</span>

    <span class="s0">def </span><span class="s1">pprint_setters_rest(self</span><span class="s0">, </span><span class="s1">prop=</span><span class="s0">None, </span><span class="s1">leadingspace=</span><span class="s3">4</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        If *prop* is *None*, return a list of reST-formatted strings of all 
        settable properties and their valid values. 
 
        If *prop* is not *None*, it is a valid property name and that 
        property will be returned as a string of &quot;property : valid&quot; 
        values. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">leadingspace:</span>
            <span class="s1">pad = </span><span class="s5">' ' </span><span class="s1">* leadingspace</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pad = </span><span class="s5">''</span>
        <span class="s0">if </span><span class="s1">prop </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">accepts = self.get_valid_values(prop)</span>
            <span class="s0">return </span><span class="s5">'%s%s: %s' </span><span class="s1">% (pad</span><span class="s0">, </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">accepts)</span>

        <span class="s1">prop_and_qualnames = []</span>
        <span class="s0">for </span><span class="s1">prop </span><span class="s0">in </span><span class="s1">sorted(self.get_setters()):</span>
            <span class="s2"># Find the parent method which actually provides the docstring.</span>
            <span class="s0">for </span><span class="s1">cls </span><span class="s0">in </span><span class="s1">self.o.__mro__:</span>
                <span class="s1">method = getattr(cls</span><span class="s0">, </span><span class="s5">f&quot;set_</span><span class="s0">{</span><span class="s1">prop</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">method </span><span class="s0">and </span><span class="s1">method.__doc__ </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s2"># No docstring available.</span>
                <span class="s1">method = getattr(self.o</span><span class="s0">, </span><span class="s5">f&quot;set_</span><span class="s0">{</span><span class="s1">prop</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>
            <span class="s1">prop_and_qualnames.append(</span>
                <span class="s1">(prop</span><span class="s0">, </span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">method.__module__</span><span class="s0">}</span><span class="s5">.</span><span class="s0">{</span><span class="s1">method.__qualname__</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">))</span>

        <span class="s1">names = [self.aliased_name_rest(prop</span><span class="s0">, </span><span class="s1">target)</span>
                 <span class="s1">.replace(</span><span class="s5">'_base._AxesBase'</span><span class="s0">, </span><span class="s5">'Axes'</span><span class="s1">)</span>
                 <span class="s1">.replace(</span><span class="s5">'_axes.Axes'</span><span class="s0">, </span><span class="s5">'Axes'</span><span class="s1">)</span>
                 <span class="s0">for </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">target </span><span class="s0">in </span><span class="s1">prop_and_qualnames]</span>
        <span class="s1">accepts = [self.get_valid_values(prop)</span>
                   <span class="s0">for </span><span class="s1">prop</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">prop_and_qualnames]</span>

        <span class="s1">col0_len = max(len(n) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">names)</span>
        <span class="s1">col1_len = max(len(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">accepts)</span>
        <span class="s1">table_formatstr = pad + </span><span class="s5">'   ' </span><span class="s1">+ </span><span class="s5">'=' </span><span class="s1">* col0_len + </span><span class="s5">'   ' </span><span class="s1">+ </span><span class="s5">'=' </span><span class="s1">* col1_len</span>

        <span class="s0">return </span><span class="s1">[</span>
            <span class="s5">''</span><span class="s0">,</span>
            <span class="s1">pad + </span><span class="s5">'.. table::'</span><span class="s0">,</span>
            <span class="s1">pad + </span><span class="s5">'   :class: property-table'</span><span class="s0">,</span>
            <span class="s5">''</span><span class="s0">,</span>
            <span class="s1">table_formatstr</span><span class="s0">,</span>
            <span class="s1">pad + </span><span class="s5">'   ' </span><span class="s1">+ </span><span class="s5">'Property'</span><span class="s1">.ljust(col0_len)</span>
            <span class="s1">+ </span><span class="s5">'   ' </span><span class="s1">+ </span><span class="s5">'Description'</span><span class="s1">.ljust(col1_len)</span><span class="s0">,</span>
            <span class="s1">table_formatstr</span><span class="s0">,</span>
            <span class="s1">*[pad + </span><span class="s5">'   ' </span><span class="s1">+ n.ljust(col0_len) + </span><span class="s5">'   ' </span><span class="s1">+ a.ljust(col1_len)</span>
              <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">a </span><span class="s0">in </span><span class="s1">zip(names</span><span class="s0">, </span><span class="s1">accepts)]</span><span class="s0">,</span>
            <span class="s1">table_formatstr</span><span class="s0">,</span>
            <span class="s5">''</span><span class="s0">,</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">properties(self):</span>
        <span class="s4">&quot;&quot;&quot;Return a dictionary mapping property name -&gt; value.&quot;&quot;&quot;</span>
        <span class="s1">o = self.oorig</span>
        <span class="s1">getters = [name </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">dir(o)</span>
                   <span class="s0">if </span><span class="s1">name.startswith(</span><span class="s5">'get_'</span><span class="s1">) </span><span class="s0">and </span><span class="s1">callable(getattr(o</span><span class="s0">, </span><span class="s1">name))]</span>
        <span class="s1">getters.sort()</span>
        <span class="s1">d = {}</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">getters:</span>
            <span class="s1">func = getattr(o</span><span class="s0">, </span><span class="s1">name)</span>
            <span class="s0">if </span><span class="s1">self.is_alias(func):</span>
                <span class="s0">continue</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s1">warnings.simplefilter(</span><span class="s5">'ignore'</span><span class="s1">)</span>
                    <span class="s1">val = func()</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">continue</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">d[name[</span><span class="s3">4</span><span class="s1">:]] = val</span>
        <span class="s0">return </span><span class="s1">d</span>

    <span class="s0">def </span><span class="s1">pprint_getters(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the getters and actual values as list of strings.&quot;&quot;&quot;</span>
        <span class="s1">lines = []</span>
        <span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">sorted(self.properties().items()):</span>
            <span class="s0">if </span><span class="s1">getattr(val</span><span class="s0">, </span><span class="s5">'shape'</span><span class="s0">, </span><span class="s1">()) != () </span><span class="s0">and </span><span class="s1">len(val) &gt; </span><span class="s3">6</span><span class="s1">:</span>
                <span class="s1">s = str(val[:</span><span class="s3">6</span><span class="s1">]) + </span><span class="s5">'...'</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">s = str(val)</span>
            <span class="s1">s = s.replace(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s0">, </span><span class="s5">' '</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(s) &gt; </span><span class="s3">50</span><span class="s1">:</span>
                <span class="s1">s = s[:</span><span class="s3">50</span><span class="s1">] + </span><span class="s5">'...'</span>
            <span class="s1">name = self.aliased_name(name)</span>
            <span class="s1">lines.append(</span><span class="s5">'    %s = %s' </span><span class="s1">% (name</span><span class="s0">, </span><span class="s1">s))</span>
        <span class="s0">return </span><span class="s1">lines</span>


<span class="s0">def </span><span class="s1">getp(obj</span><span class="s0">, </span><span class="s1">property=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Return the value of an `.Artist`'s *property*, or print all of them. 
 
    Parameters 
    ---------- 
    obj : `.Artist` 
        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`. 
 
    property : str or None, default: None 
        If *property* is 'somename', this function returns 
        ``obj.get_somename()``. 
 
        If it's None (or unset), it *prints* all gettable properties from 
        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is 
        an alias for 'linewidth'.  In the output, aliases and full property 
        names will be listed as: 
 
          property or alias = value 
 
        e.g.: 
 
          linewidth or lw = 2 
 
    See Also 
    -------- 
    setp 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">property </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">insp = ArtistInspector(obj)</span>
        <span class="s1">ret = insp.pprint_getters()</span>
        <span class="s1">print(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">.join(ret))</span>
        <span class="s0">return</span>
    <span class="s0">return </span><span class="s1">getattr(obj</span><span class="s0">, </span><span class="s5">'get_' </span><span class="s1">+ property)()</span>

<span class="s2"># alias</span>
<span class="s1">get = getp</span>


<span class="s0">def </span><span class="s1">setp(obj</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">file=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Set one or more properties on an `.Artist`, or list allowed values. 
 
    Parameters 
    ---------- 
    obj : `.Artist` or list of `.Artist` 
        The artist(s) whose properties are being set or queried.  When setting 
        properties, all artists are affected; when querying the allowed values, 
        only the first instance in the sequence is queried. 
 
        For example, two lines can be made thicker and red with a single call: 
 
        &gt;&gt;&gt; x = arange(0, 1, 0.01) 
        &gt;&gt;&gt; lines = plot(x, sin(2*pi*x), x, sin(4*pi*x)) 
        &gt;&gt;&gt; setp(lines, linewidth=2, color='r') 
 
    file : file-like, default: `sys.stdout` 
        Where `setp` writes its output when asked to list allowed values. 
 
        &gt;&gt;&gt; with open('output.log') as file: 
        ...     setp(line, file=file) 
 
        The default, ``None``, means `sys.stdout`. 
 
    *args, **kwargs 
        The properties to set.  The following combinations are supported: 
 
        - Set the linestyle of a line to be dashed: 
 
          &gt;&gt;&gt; line, = plot([1, 2, 3]) 
          &gt;&gt;&gt; setp(line, linestyle='--') 
 
        - Set multiple properties at once: 
 
          &gt;&gt;&gt; setp(line, linewidth=2, color='r') 
 
        - List allowed values for a line's linestyle: 
 
          &gt;&gt;&gt; setp(line, 'linestyle') 
          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} 
 
        - List all properties that can be set, and their allowed values: 
 
          &gt;&gt;&gt; setp(line) 
          agg_filter: a filter function, ... 
          [long output listing omitted] 
 
        `setp` also supports MATLAB style string/value pairs.  For example, the 
        following are equivalent: 
 
        &gt;&gt;&gt; setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style 
        &gt;&gt;&gt; setp(lines, linewidth=2, color='r')        # Python style 
 
    See Also 
    -------- 
    getp 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">Artist):</span>
        <span class="s1">objs = [obj]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">objs = list(cbook.flatten(obj))</span>

    <span class="s0">if not </span><span class="s1">objs:</span>
        <span class="s0">return</span>

    <span class="s1">insp = ArtistInspector(objs[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">if not </span><span class="s1">kwargs </span><span class="s0">and </span><span class="s1">len(args) &lt; </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s1">print(insp.pprint_setters(prop=args[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">file=file)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">.join(insp.pprint_setters())</span><span class="s0">, </span><span class="s1">file=file)</span>
        <span class="s0">return</span>

    <span class="s0">if </span><span class="s1">len(args) % </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">'The set args must be string, value pairs'</span><span class="s1">)</span>

    <span class="s1">funcvals = dict(zip(args[::</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s3">1</span><span class="s1">::</span><span class="s3">2</span><span class="s1">]))</span>
    <span class="s1">ret = [o.update(funcvals) </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">objs] + [o.set(**kwargs) </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">objs]</span>
    <span class="s0">return </span><span class="s1">list(cbook.flatten(ret))</span>


<span class="s0">def </span><span class="s1">kwdoc(artist):</span>
    <span class="s4">r&quot;&quot;&quot; 
    Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and 
    return information about its settable properties and their current values. 
 
    Parameters 
    ---------- 
    artist : `~matplotlib.artist.Artist` or an iterable of `Artist`\s 
 
    Returns 
    ------- 
    str 
        The settable properties of *artist*, as plain text if 
        :rc:`docstring.hardcopy` is False and as a rst table (intended for 
        use in Sphinx) if it is True. 
    &quot;&quot;&quot;</span>
    <span class="s1">ai = ArtistInspector(artist)</span>
    <span class="s0">return </span><span class="s1">(</span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">.join(ai.pprint_setters_rest(leadingspace=</span><span class="s3">4</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s5">'docstring.hardcopy'</span><span class="s1">] </span><span class="s0">else</span>
            <span class="s5">'Properties:</span><span class="s0">\n</span><span class="s5">' </span><span class="s1">+ </span><span class="s5">'</span><span class="s0">\n</span><span class="s5">'</span><span class="s1">.join(ai.pprint_setters(leadingspace=</span><span class="s3">4</span><span class="s1">)))</span>

<span class="s2"># We defer this to the end of them module, because it needs ArtistInspector</span>
<span class="s2"># to be defined.</span>
<span class="s1">Artist._update_set_signature_and_docstring()</span>
</pre>
</body>
</html>