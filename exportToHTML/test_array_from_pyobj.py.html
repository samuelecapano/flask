<html>
<head>
<title>test_array_from_pyobj.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_array_from_pyobj.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span>
<span class="s0">from </span><span class="s1">numpy.core.multiarray </span><span class="s0">import </span><span class="s1">typeinfo </span><span class="s0">as </span><span class="s1">_typeinfo</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">util</span>

<span class="s1">wrap = </span><span class="s0">None</span>

<span class="s2"># Extend core typeinfo with CHARACTER to test dtype('c')</span>
<span class="s1">_ti = _typeinfo[</span><span class="s3">'STRING'</span><span class="s1">]</span>
<span class="s1">typeinfo = dict(</span>
    <span class="s1">CHARACTER=type(_ti)((</span><span class="s3">'c'</span><span class="s0">, </span><span class="s1">_ti.num</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s1">_ti.alignment</span><span class="s0">, </span><span class="s1">_ti.type))</span><span class="s0">,</span>
    <span class="s1">**_typeinfo)</span>


<span class="s0">def </span><span class="s1">setup_module():</span>
    <span class="s5">&quot;&quot;&quot; 
    Build the required testing extension module 
 
    &quot;&quot;&quot;</span>
    <span class="s0">global </span><span class="s1">wrap</span>

    <span class="s2"># Check compiler availability first</span>
    <span class="s0">if not </span><span class="s1">util.has_c_compiler():</span>
        <span class="s1">pytest.skip(</span><span class="s3">&quot;No C compiler available&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">wrap </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">config_code = </span><span class="s3">&quot;&quot;&quot; 
        config.add_extension('test_array_from_pyobj_ext', 
                             sources=['wrapmodule.c', 'fortranobject.c'], 
                             define_macros=[]) 
        &quot;&quot;&quot;</span>
        <span class="s1">d = os.path.dirname(__file__)</span>
        <span class="s1">src = [</span>
            <span class="s1">util.getpath(</span><span class="s3">&quot;tests&quot;</span><span class="s0">, </span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;array_from_pyobj&quot;</span><span class="s0">, </span><span class="s3">&quot;wrapmodule.c&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">util.getpath(</span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;fortranobject.c&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">util.getpath(</span><span class="s3">&quot;src&quot;</span><span class="s0">, </span><span class="s3">&quot;fortranobject.h&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s1">wrap = util.build_module_distutils(src</span><span class="s0">, </span><span class="s1">config_code</span><span class="s0">,</span>
                                           <span class="s3">&quot;test_array_from_pyobj_ext&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">flags_info(arr):</span>
    <span class="s1">flags = wrap.array_attrs(arr)[</span><span class="s4">6</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">flags2names(flags)</span>


<span class="s0">def </span><span class="s1">flags2names(flags):</span>
    <span class="s1">info = []</span>
    <span class="s0">for </span><span class="s1">flagname </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;FORTRAN&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;OWNDATA&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;ENSURECOPY&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;ENSUREARRAY&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;ALIGNED&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;NOTSWAPPED&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;WRITEABLE&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;WRITEBACKIFCOPY&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;UPDATEIFCOPY&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;BEHAVED&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;BEHAVED_RO&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;CARRAY&quot;</span><span class="s0">,</span>
            <span class="s3">&quot;FARRAY&quot;</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">abs(flags) &amp; getattr(wrap</span><span class="s0">, </span><span class="s1">flagname</span><span class="s0">, </span><span class="s4">0</span><span class="s1">):</span>
            <span class="s1">info.append(flagname)</span>
    <span class="s0">return </span><span class="s1">info</span>


<span class="s0">class </span><span class="s1">Intent:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">intent_list=[]):</span>
        <span class="s1">self.intent_list = intent_list[:]</span>
        <span class="s1">flags = </span><span class="s4">0</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">intent_list:</span>
            <span class="s0">if </span><span class="s1">i == </span><span class="s3">&quot;optional&quot;</span><span class="s1">:</span>
                <span class="s1">flags |= wrap.F2PY_OPTIONAL</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">flags |= getattr(wrap</span><span class="s0">, </span><span class="s3">&quot;F2PY_INTENT_&quot; </span><span class="s1">+ i.upper())</span>
        <span class="s1">self.flags = flags</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">name = name.lower()</span>
        <span class="s0">if </span><span class="s1">name == </span><span class="s3">&quot;in_&quot;</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s3">&quot;in&quot;</span>
        <span class="s0">return </span><span class="s1">self.__class__(self.intent_list + [name])</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s3">&quot;intent(%s)&quot; </span><span class="s1">% (</span><span class="s3">&quot;,&quot;</span><span class="s1">.join(self.intent_list))</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s3">&quot;Intent(%r)&quot; </span><span class="s1">% (self.intent_list)</span>

    <span class="s0">def </span><span class="s1">is_intent(self</span><span class="s0">, </span><span class="s1">*names):</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">names:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self.intent_list:</span>
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">is_intent_exact(self</span><span class="s0">, </span><span class="s1">*names):</span>
        <span class="s0">return </span><span class="s1">len(self.intent_list) == len(names) </span><span class="s0">and </span><span class="s1">self.is_intent(*names)</span>


<span class="s1">intent = Intent()</span>

<span class="s1">_type_names = [</span>
    <span class="s3">&quot;BOOL&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;BYTE&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;UBYTE&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;SHORT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;USHORT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;INT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;UINT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;LONG&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ULONG&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;LONGLONG&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ULONGLONG&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;FLOAT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;DOUBLE&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;CFLOAT&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;STRING1&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;STRING5&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;CHARACTER&quot;</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">_cast_dict = {</span><span class="s3">&quot;BOOL&quot;</span><span class="s1">: [</span><span class="s3">&quot;BOOL&quot;</span><span class="s1">]}</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;BYTE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;BOOL&quot;</span><span class="s1">] + [</span><span class="s3">&quot;BYTE&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;UBYTE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;BOOL&quot;</span><span class="s1">] + [</span><span class="s3">&quot;UBYTE&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;BYTE&quot;</span><span class="s1">] = [</span><span class="s3">&quot;BYTE&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;UBYTE&quot;</span><span class="s1">] = [</span><span class="s3">&quot;UBYTE&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;SHORT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;BYTE&quot;</span><span class="s1">] + [</span><span class="s3">&quot;UBYTE&quot;</span><span class="s0">, </span><span class="s3">&quot;SHORT&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;USHORT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;UBYTE&quot;</span><span class="s1">] + [</span><span class="s3">&quot;BYTE&quot;</span><span class="s0">, </span><span class="s3">&quot;USHORT&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;INT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;SHORT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;USHORT&quot;</span><span class="s0">, </span><span class="s3">&quot;INT&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;UINT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;USHORT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;SHORT&quot;</span><span class="s0">, </span><span class="s3">&quot;UINT&quot;</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s3">&quot;LONG&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;INT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;LONG&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;ULONG&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;UINT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;ULONG&quot;</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s3">&quot;LONGLONG&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;LONG&quot;</span><span class="s1">] + [</span><span class="s3">&quot;LONGLONG&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;ULONGLONG&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;ULONG&quot;</span><span class="s1">] + [</span><span class="s3">&quot;ULONGLONG&quot;</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s3">&quot;FLOAT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;SHORT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;USHORT&quot;</span><span class="s0">, </span><span class="s3">&quot;FLOAT&quot;</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">&quot;DOUBLE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;INT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;UINT&quot;</span><span class="s0">, </span><span class="s3">&quot;FLOAT&quot;</span><span class="s0">, </span><span class="s3">&quot;DOUBLE&quot;</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s3">&quot;CFLOAT&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;FLOAT&quot;</span><span class="s1">] + [</span><span class="s3">&quot;CFLOAT&quot;</span><span class="s1">]</span>

<span class="s1">_cast_dict[</span><span class="s3">'STRING1'</span><span class="s1">] = [</span><span class="s3">'STRING1'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">'STRING5'</span><span class="s1">] = [</span><span class="s3">'STRING5'</span><span class="s1">]</span>
<span class="s1">_cast_dict[</span><span class="s3">'CHARACTER'</span><span class="s1">] = [</span><span class="s3">'CHARACTER'</span><span class="s1">]</span>

<span class="s2"># 32 bit system malloc typically does not provide the alignment required by</span>
<span class="s2"># 16 byte long double types this means the inout intent cannot be satisfied</span>
<span class="s2"># and several tests fail as the alignment flag can be randomly true or fals</span>
<span class="s2"># when numpy gains an aligned allocator the tests could be enabled again</span>
<span class="s2">#</span>
<span class="s2"># Furthermore, on macOS ARM64, LONGDOUBLE is an alias for DOUBLE.</span>
<span class="s0">if </span><span class="s1">((np.intp().dtype.itemsize != </span><span class="s4">4 </span><span class="s0">or </span><span class="s1">np.clongdouble().dtype.alignment &lt;= </span><span class="s4">8</span><span class="s1">)</span>
        <span class="s0">and </span><span class="s1">sys.platform != </span><span class="s3">&quot;win32&quot;</span>
        <span class="s0">and </span><span class="s1">(platform.system()</span><span class="s0">, </span><span class="s1">platform.processor()) != (</span><span class="s3">&quot;Darwin&quot;</span><span class="s0">, </span><span class="s3">&quot;arm&quot;</span><span class="s1">)):</span>
    <span class="s1">_type_names.extend([</span><span class="s3">&quot;LONGDOUBLE&quot;</span><span class="s0">, </span><span class="s3">&quot;CDOUBLE&quot;</span><span class="s0">, </span><span class="s3">&quot;CLONGDOUBLE&quot;</span><span class="s1">])</span>
    <span class="s1">_cast_dict[</span><span class="s3">&quot;LONGDOUBLE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;LONG&quot;</span><span class="s1">] + [</span>
        <span class="s3">&quot;ULONG&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;FLOAT&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;DOUBLE&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;LONGDOUBLE&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">_cast_dict[</span><span class="s3">&quot;CLONGDOUBLE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;LONGDOUBLE&quot;</span><span class="s1">] + [</span>
        <span class="s3">&quot;CFLOAT&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;CDOUBLE&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;CLONGDOUBLE&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">_cast_dict[</span><span class="s3">&quot;CDOUBLE&quot;</span><span class="s1">] = _cast_dict[</span><span class="s3">&quot;DOUBLE&quot;</span><span class="s1">] + [</span><span class="s3">&quot;CFLOAT&quot;</span><span class="s0">, </span><span class="s3">&quot;CDOUBLE&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">Type:</span>
    <span class="s1">_type_cache = {}</span>

    <span class="s0">def </span><span class="s1">__new__(cls</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">if </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s1">dtype0 = name</span>
            <span class="s1">name = </span><span class="s0">None</span>
            <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">typeinfo.items():</span>
                <span class="s0">if not </span><span class="s1">isinstance(i</span><span class="s0">, </span><span class="s1">type) </span><span class="s0">and </span><span class="s1">dtype0.type </span><span class="s0">is </span><span class="s1">i.type:</span>
                    <span class="s1">name = n</span>
                    <span class="s0">break</span>
        <span class="s1">obj = cls._type_cache.get(name.upper()</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">obj</span>
        <span class="s1">obj = object.__new__(cls)</span>
        <span class="s1">obj._init(name)</span>
        <span class="s1">cls._type_cache[name.upper()] = obj</span>
        <span class="s0">return </span><span class="s1">obj</span>

    <span class="s0">def </span><span class="s1">_init(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self.NAME = name.upper()</span>

        <span class="s0">if </span><span class="s1">self.NAME == </span><span class="s3">'CHARACTER'</span><span class="s1">:</span>
            <span class="s1">info = typeinfo[self.NAME]</span>
            <span class="s1">self.type_num = getattr(wrap</span><span class="s0">, </span><span class="s3">'NPY_STRING'</span><span class="s1">)</span>
            <span class="s1">self.elsize = </span><span class="s4">1</span>
            <span class="s1">self.dtype = np.dtype(</span><span class="s3">'c'</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">self.NAME.startswith(</span><span class="s3">'STRING'</span><span class="s1">):</span>
            <span class="s1">info = typeinfo[self.NAME[:</span><span class="s4">6</span><span class="s1">]]</span>
            <span class="s1">self.type_num = getattr(wrap</span><span class="s0">, </span><span class="s3">'NPY_STRING'</span><span class="s1">)</span>
            <span class="s1">self.elsize = int(self.NAME[</span><span class="s4">6</span><span class="s1">:] </span><span class="s0">or </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self.dtype = np.dtype(</span><span class="s3">f'S</span><span class="s0">{</span><span class="s1">self.elsize</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">info = typeinfo[self.NAME]</span>
            <span class="s1">self.type_num = getattr(wrap</span><span class="s0">, </span><span class="s3">'NPY_' </span><span class="s1">+ self.NAME)</span>
            <span class="s1">self.elsize = info.bits // </span><span class="s4">8</span>
            <span class="s1">self.dtype = np.dtype(info.type)</span>

        <span class="s0">assert </span><span class="s1">self.type_num == info.num</span>
        <span class="s1">self.type = info.type</span>
        <span class="s1">self.dtypechar = info.char</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">f&quot;Type(</span><span class="s0">{</span><span class="s1">self.NAME</span><span class="s0">}</span><span class="s3">)|type_num=</span><span class="s0">{</span><span class="s1">self.type_num</span><span class="s0">}</span><span class="s3">,&quot;</span>
                <span class="s3">f&quot; dtype=</span><span class="s0">{</span><span class="s1">self.dtype</span><span class="s0">}</span><span class="s3">,&quot;</span>
                <span class="s3">f&quot; type=</span><span class="s0">{</span><span class="s1">self.type</span><span class="s0">}</span><span class="s3">, elsize=</span><span class="s0">{</span><span class="s1">self.elsize</span><span class="s0">}</span><span class="s3">,&quot;</span>
                <span class="s3">f&quot; dtypechar=</span><span class="s0">{</span><span class="s1">self.dtypechar</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">cast_types(self):</span>
        <span class="s0">return </span><span class="s1">[self.__class__(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">_cast_dict[self.NAME]]</span>

    <span class="s0">def </span><span class="s1">all_types(self):</span>
        <span class="s0">return </span><span class="s1">[self.__class__(_m) </span><span class="s0">for </span><span class="s1">_m </span><span class="s0">in </span><span class="s1">_type_names]</span>

    <span class="s0">def </span><span class="s1">smaller_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment &lt; bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>

    <span class="s0">def </span><span class="s1">equal_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">name == self.NAME:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment == bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>

    <span class="s0">def </span><span class="s1">larger_types(self):</span>
        <span class="s1">bits = typeinfo[self.NAME].alignment</span>
        <span class="s1">types = []</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">_type_names:</span>
            <span class="s0">if </span><span class="s1">typeinfo[name].alignment &gt; bits:</span>
                <span class="s1">types.append(Type(name))</span>
        <span class="s0">return </span><span class="s1">types</span>


<span class="s0">class </span><span class="s1">Array:</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">f'Array(</span><span class="s0">{</span><span class="s1">self.type</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">self.dims</span><span class="s0">}</span><span class="s3">, </span><span class="s0">{</span><span class="s1">self.intent</span><span class="s0">}</span><span class="s3">,'</span>
                <span class="s3">f' </span><span class="s0">{</span><span class="s1">self.obj</span><span class="s0">}</span><span class="s3">)|arr=</span><span class="s0">{</span><span class="s1">self.arr</span><span class="s0">}</span><span class="s3">'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">typ</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj):</span>
        <span class="s1">self.type = typ</span>
        <span class="s1">self.dims = dims</span>
        <span class="s1">self.intent = intent</span>
        <span class="s1">self.obj_copy = copy.deepcopy(obj)</span>
        <span class="s1">self.obj = obj</span>

        <span class="s2"># arr.dtypechar may be different from typ.dtypechar</span>
        <span class="s1">self.arr = wrap.call(typ.type_num</span><span class="s0">,</span>
                             <span class="s1">typ.elsize</span><span class="s0">,</span>
                             <span class="s1">dims</span><span class="s0">, </span><span class="s1">intent.flags</span><span class="s0">, </span><span class="s1">obj)</span>

        <span class="s0">assert </span><span class="s1">isinstance(self.arr</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

        <span class="s1">self.arr_attr = wrap.array_attrs(self.arr)</span>

        <span class="s0">if </span><span class="s1">len(dims) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.intent.is_intent(</span><span class="s3">&quot;c&quot;</span><span class="s1">):</span>
                <span class="s0">assert </span><span class="s1">(intent.flags &amp; wrap.F2PY_INTENT_C)</span>
                <span class="s0">assert not </span><span class="s1">self.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">self.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">(</span><span class="s0">not </span><span class="s1">self.arr_attr[</span><span class="s4">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">(</span><span class="s0">not </span><span class="s1">intent.flags &amp; wrap.F2PY_INTENT_C)</span>
                <span class="s0">assert </span><span class="s1">self.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]</span>
                <span class="s0">assert not </span><span class="s1">self.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">(self.arr_attr[</span><span class="s4">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>

        <span class="s0">if </span><span class="s1">obj </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self.pyarr = </span><span class="s0">None</span>
            <span class="s1">self.pyarr_attr = </span><span class="s0">None</span>
            <span class="s0">return</span>

        <span class="s0">if </span><span class="s1">intent.is_intent(</span><span class="s3">&quot;cache&quot;</span><span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">np.ndarray)</span><span class="s0">, </span><span class="s1">repr(type(obj))</span>
            <span class="s1">self.pyarr = np.array(obj).reshape(*dims).copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.pyarr = np.array(</span>
                <span class="s1">np.array(obj</span><span class="s0">, </span><span class="s1">dtype=typ.dtypechar).reshape(*dims)</span><span class="s0">,</span>
                <span class="s1">order=self.intent.is_intent(</span><span class="s3">&quot;c&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s3">&quot;C&quot; </span><span class="s0">or </span><span class="s3">&quot;F&quot;</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">self.pyarr.dtype == typ</span>
        <span class="s1">self.pyarr.setflags(write=self.arr.flags[</span><span class="s3">&quot;WRITEABLE&quot;</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">self.pyarr.flags[</span><span class="s3">&quot;OWNDATA&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(obj</span><span class="s0">, </span><span class="s1">intent)</span>
        <span class="s1">self.pyarr_attr = wrap.array_attrs(self.pyarr)</span>

        <span class="s0">if </span><span class="s1">len(dims) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.intent.is_intent(</span><span class="s3">&quot;c&quot;</span><span class="s1">):</span>
                <span class="s0">assert not </span><span class="s1">self.pyarr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">self.pyarr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">(</span><span class="s0">not </span><span class="s1">self.pyarr_attr[</span><span class="s4">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">self.pyarr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]</span>
                <span class="s0">assert not </span><span class="s1">self.pyarr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
                <span class="s0">assert </span><span class="s1">(self.pyarr_attr[</span><span class="s4">6</span><span class="s1">] &amp; wrap.FORTRAN)</span>

        <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">1</span><span class="s1">] == self.pyarr_attr[</span><span class="s4">1</span><span class="s1">]  </span><span class="s2"># nd</span>
        <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">2</span><span class="s1">] == self.pyarr_attr[</span><span class="s4">2</span><span class="s1">]  </span><span class="s2"># dimensions</span>
        <span class="s0">if </span><span class="s1">self.arr_attr[</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">3</span><span class="s1">] == self.pyarr_attr[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((</span>
                <span class="s1">self.arr_attr[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">self.pyarr_attr[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">self.arr.tobytes()</span><span class="s0">,</span>
                <span class="s1">self.pyarr.tobytes()</span><span class="s0">,</span>
            <span class="s1">))  </span><span class="s2"># strides</span>
        <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">5</span><span class="s1">][-</span><span class="s4">2</span><span class="s1">:] == self.pyarr_attr[</span><span class="s4">5</span><span class="s1">][-</span><span class="s4">2</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">repr((</span>
            <span class="s1">self.arr_attr[</span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.pyarr_attr[</span><span class="s4">5</span><span class="s1">]</span>
            <span class="s1">))  </span><span class="s2"># descr</span>
        <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">6</span><span class="s1">] == self.pyarr_attr[</span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((</span>
            <span class="s1">self.arr_attr[</span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">self.pyarr_attr[</span><span class="s4">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">flags2names(</span><span class="s4">0 </span><span class="s1">* self.arr_attr[</span><span class="s4">6</span><span class="s1">] - self.pyarr_attr[</span><span class="s4">6</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">flags2names(self.arr_attr[</span><span class="s4">6</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">intent</span><span class="s0">,</span>
        <span class="s1">))  </span><span class="s2"># flags</span>

        <span class="s0">if </span><span class="s1">intent.is_intent(</span><span class="s3">&quot;cache&quot;</span><span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">5</span><span class="s1">][</span><span class="s4">3</span><span class="s1">] &gt;= self.type.elsize</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">self.arr_attr[</span><span class="s4">5</span><span class="s1">][</span><span class="s4">3</span><span class="s1">] == self.type.elsize</span>
            <span class="s0">assert </span><span class="s1">(self.arr_equal(self.pyarr</span><span class="s0">, </span><span class="s1">self.arr))</span>

        <span class="s0">if </span><span class="s1">isinstance(self.obj</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if </span><span class="s1">typ.elsize == Type(obj.dtype).elsize:</span>
                <span class="s0">if not </span><span class="s1">intent.is_intent(</span><span class="s3">&quot;copy&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">self.arr_attr[</span><span class="s4">1</span><span class="s1">] &lt;= </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s0">assert </span><span class="s1">self.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">arr_equal(self</span><span class="s0">, </span><span class="s1">arr1</span><span class="s0">, </span><span class="s1">arr2):</span>
        <span class="s0">if </span><span class="s1">arr1.shape != arr2.shape:</span>
            <span class="s0">return False</span>
        <span class="s0">return </span><span class="s1">(arr1 == arr2).all()</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">str(self.arr)</span>

    <span class="s0">def </span><span class="s1">has_shared_memory(self):</span>
        <span class="s5">&quot;&quot;&quot;Check that created array shares data with input array.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.obj </span><span class="s0">is </span><span class="s1">self.arr:</span>
            <span class="s0">return True</span>
        <span class="s0">if not </span><span class="s1">isinstance(self.obj</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">return False</span>
        <span class="s1">obj_attr = wrap.array_attrs(self.obj)</span>
        <span class="s0">return </span><span class="s1">obj_attr[</span><span class="s4">0</span><span class="s1">] == self.arr_attr[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">TestIntent:</span>
    <span class="s0">def </span><span class="s1">test_in_out(self):</span>
        <span class="s0">assert </span><span class="s1">str(intent.in_.out) == </span><span class="s3">&quot;intent(in,out)&quot;</span>
        <span class="s0">assert </span><span class="s1">intent.in_.c.is_intent(</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">intent.in_.c.is_intent_exact(</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">intent.in_.c.is_intent_exact(</span><span class="s3">&quot;c&quot;</span><span class="s0">, </span><span class="s3">&quot;in&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">intent.in_.c.is_intent_exact(</span><span class="s3">&quot;in&quot;</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">intent.in_.is_intent(</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSharedMemory:</span>

    <span class="s1">@pytest.fixture(autouse=</span><span class="s0">True, </span><span class="s1">scope=</span><span class="s3">&quot;class&quot;</span><span class="s0">, </span><span class="s1">params=_type_names)</span>
    <span class="s0">def </span><span class="s1">setup_type(self</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s1">request.cls.type = Type(request.param)</span>
        <span class="s1">request.cls.array = </span><span class="s0">lambda </span><span class="s1">self</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj: Array(</span>
            <span class="s1">Type(request.param)</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">intent</span><span class="s0">, </span><span class="s1">obj)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">num2seq(self):</span>
        <span class="s0">if </span><span class="s1">self.type.NAME.startswith(</span><span class="s3">'STRING'</span><span class="s1">):</span>
            <span class="s1">elsize = self.type.elsize</span>
            <span class="s0">return </span><span class="s1">[</span><span class="s3">'1' </span><span class="s1">* elsize</span><span class="s0">, </span><span class="s3">'2' </span><span class="s1">* elsize]</span>
        <span class="s0">return </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">num23seq(self):</span>
        <span class="s0">if </span><span class="s1">self.type.NAME.startswith(</span><span class="s3">'STRING'</span><span class="s1">):</span>
            <span class="s1">elsize = self.type.elsize</span>
            <span class="s0">return </span><span class="s1">[[</span><span class="s3">'1' </span><span class="s1">* elsize</span><span class="s0">, </span><span class="s3">'2' </span><span class="s1">* elsize</span><span class="s0">, </span><span class="s3">'3' </span><span class="s1">* elsize]</span><span class="s0">,</span>
                    <span class="s1">[</span><span class="s3">'4' </span><span class="s1">* elsize</span><span class="s0">, </span><span class="s3">'5' </span><span class="s1">* elsize</span><span class="s0">, </span><span class="s3">'6' </span><span class="s1">* elsize]]</span>
        <span class="s0">return </span><span class="s1">[[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]]</span>

    <span class="s0">def </span><span class="s1">test_in_from_2seq(self):</span>
        <span class="s1">a = self.array([</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">self.num2seq)</span>
        <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_in_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr((self.type.dtype</span><span class="s0">, </span><span class="s1">t.dtype))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;write&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;w&quot;</span><span class="s0">, </span><span class="s3">&quot;ro&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;C&quot;</span><span class="s0">, </span><span class="s3">&quot;F&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;inp&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">&quot;2seq&quot;</span><span class="s0">, </span><span class="s3">&quot;23seq&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_in_nocopy(self</span><span class="s0">, </span><span class="s1">write</span><span class="s0">, </span><span class="s1">order</span><span class="s0">, </span><span class="s1">inp):</span>
        <span class="s5">&quot;&quot;&quot;Test if intent(in) array can be passed without copies&quot;&quot;&quot;</span>
        <span class="s1">seq = getattr(self</span><span class="s0">, </span><span class="s3">&quot;num&quot; </span><span class="s1">+ inp)</span>
        <span class="s1">obj = np.array(seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=order)</span>
        <span class="s1">obj.setflags(write=(write == </span><span class="s3">'w'</span><span class="s1">))</span>
        <span class="s1">a = self.array(obj.shape</span><span class="s0">,</span>
                       <span class="s1">((order == </span><span class="s3">'C' </span><span class="s0">and </span><span class="s1">intent.in_.c) </span><span class="s0">or </span><span class="s1">intent.in_)</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_inout_2seq(self):</span>
        <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array([</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">self.num2seq)</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                    <span class="s3">&quot;failed to initialize intent(inout|inplace|cache) array&quot;</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span><span class="s3">&quot;intent(inout) should have failed on sequence&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_f_inout_23seq(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">&quot;C&quot;</span><span class="s1">)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                    <span class="s3">&quot;failed to initialize intent(inout) array&quot;</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span>
                <span class="s3">&quot;intent(inout) should have failed on improper array&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_c_inout_23seq(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s1">shape = (len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.inout</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_in_copy_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array([len(self.num2seq)]</span><span class="s0">, </span><span class="s1">intent.in_.copy</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_c_in_from_23seq(self):</span>
        <span class="s1">a = self.array(</span>
            <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">,</span>
            <span class="s1">self.num23seq)</span>
        <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array(</span>
                <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_f_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">a = self.array(</span>
                <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_c_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array(</span>
                <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_.c</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">if </span><span class="s1">t.elsize == self.type.elsize:</span>
                <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_f_copy_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">a = self.array(</span>
                <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_.copy</span><span class="s0">,</span>
                <span class="s1">obj)</span>
            <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_c_copy_in_from_23casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">a = self.array(</span>
                <span class="s1">[len(self.num23seq)</span><span class="s0">, </span><span class="s1">len(self.num23seq[</span><span class="s4">0</span><span class="s1">])]</span><span class="s0">, </span><span class="s1">intent.in_.c.copy</span><span class="s0">,</span>
                <span class="s1">obj)</span>
            <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_in_cache_from_2casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.all_types():</span>
            <span class="s0">if </span><span class="s1">t.elsize != self.type.elsize:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">shape = (len(self.num2seq)</span><span class="s0">, </span><span class="s1">)</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">&quot;F&quot;</span><span class="s1">)</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.c.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span>

            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert </span><span class="s1">a.has_shared_memory()</span><span class="s0">, </span><span class="s1">repr(t.dtype)</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj[::-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
                <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                        <span class="s3">&quot;failed to initialize intent(cache) array&quot;</span><span class="s1">):</span>
                    <span class="s0">raise</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">SystemError(</span>
                    <span class="s3">&quot;intent(cache) should have failed on multisegmented array&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_in_cache_from_2casttype_failure(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.all_types():</span>
            <span class="s0">if </span><span class="s1">t.NAME == </span><span class="s3">'STRING'</span><span class="s1">:</span>
                <span class="s2"># string elsize is 0, so skipping the test</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">t.elsize &gt;= self.type.elsize:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num2seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s1">shape = (len(self.num2seq)</span><span class="s0">, </span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.array(shape</span><span class="s0">, </span><span class="s1">intent.in_.cache</span><span class="s0">, </span><span class="s1">obj)  </span><span class="s2"># Should succeed</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
                <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                        <span class="s3">&quot;failed to initialize intent(cache) array&quot;</span><span class="s1">):</span>
                    <span class="s0">raise</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">SystemError(</span>
                    <span class="s3">&quot;intent(cache) should have failed on smaller array&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_cache_hidden(self):</span>
        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>

        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>

        <span class="s1">shape = (-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.cache.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                    <span class="s3">&quot;failed to create intent(cache|hide)|optional array&quot;</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span>
                <span class="s3">&quot;intent(cache) should have failed on undefined dimensions&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_hidden(self):</span>
        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>

        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>
        <span class="s0">assert </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and not </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>

        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.c.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>
        <span class="s0">assert not </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>

        <span class="s1">shape = (-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.hide</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">msg:</span>
            <span class="s0">if not </span><span class="s1">str(msg).startswith(</span>
                    <span class="s3">&quot;failed to create intent(cache|hide)|optional array&quot;</span><span class="s1">):</span>
                <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">SystemError(</span>
                <span class="s3">&quot;intent(hide) should have failed on undefined dimensions&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_optional_none(self):</span>
        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>

        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>
        <span class="s0">assert </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and not </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>

        <span class="s1">shape = (</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.c.optional</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert </span><span class="s1">a.arr_equal(a.arr</span><span class="s0">, </span><span class="s1">np.zeros(shape</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype))</span>
        <span class="s0">assert not </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">a.arr.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_optional_from_2seq(self):</span>
        <span class="s1">obj = self.num2seq</span>
        <span class="s1">shape = (len(obj)</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_optional_from_23seq(self):</span>
        <span class="s1">obj = self.num23seq</span>
        <span class="s1">shape = (len(obj)</span><span class="s0">, </span><span class="s1">len(obj[</span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.optional.c</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">a.arr.shape == shape</span>
        <span class="s0">assert not </span><span class="s1">a.has_shared_memory()</span>

    <span class="s0">def </span><span class="s1">test_inplace(self):</span>
        <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s0">assert not </span><span class="s1">obj.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">obj.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
        <span class="s1">shape = obj.shape</span>
        <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.inplace</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s0">assert </span><span class="s1">obj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr))</span>
        <span class="s1">a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">54</span>
        <span class="s0">assert </span><span class="s1">obj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == np.array(</span><span class="s4">54</span><span class="s0">, </span><span class="s1">dtype=self.type.dtype)</span>
        <span class="s0">assert </span><span class="s1">a.arr </span><span class="s0">is </span><span class="s1">obj</span>
        <span class="s0">assert </span><span class="s1">obj.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]  </span><span class="s2"># obj attributes are changed inplace!</span>
        <span class="s0">assert not </span><span class="s1">obj.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_inplace_from_casttype(self):</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">self.type.cast_types():</span>
            <span class="s0">if </span><span class="s1">t </span><span class="s0">is </span><span class="s1">self.type:</span>
                <span class="s0">continue</span>
            <span class="s1">obj = np.array(self.num23seq</span><span class="s0">, </span><span class="s1">dtype=t.dtype)</span>
            <span class="s0">assert </span><span class="s1">obj.dtype.type == t.type</span>
            <span class="s0">assert </span><span class="s1">obj.dtype.type </span><span class="s0">is not </span><span class="s1">self.type.type</span>
            <span class="s0">assert not </span><span class="s1">obj.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">obj.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
            <span class="s1">shape = obj.shape</span>
            <span class="s1">a = self.array(shape</span><span class="s0">, </span><span class="s1">intent.inplace</span><span class="s0">, </span><span class="s1">obj)</span>
            <span class="s0">assert </span><span class="s1">obj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">repr((obj</span><span class="s0">, </span><span class="s1">a.arr))</span>
            <span class="s1">a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] = </span><span class="s4">54</span>
            <span class="s0">assert </span><span class="s1">obj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == a.arr[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">] == np.array(</span><span class="s4">54</span><span class="s0">,</span>
                                                        <span class="s1">dtype=self.type.dtype)</span>
            <span class="s0">assert </span><span class="s1">a.arr </span><span class="s0">is </span><span class="s1">obj</span>
            <span class="s0">assert </span><span class="s1">obj.flags[</span><span class="s3">&quot;FORTRAN&quot;</span><span class="s1">]  </span><span class="s2"># obj attributes changed inplace!</span>
            <span class="s0">assert not </span><span class="s1">obj.flags[</span><span class="s3">&quot;CONTIGUOUS&quot;</span><span class="s1">]</span>
            <span class="s0">assert </span><span class="s1">obj.dtype.type </span><span class="s0">is </span><span class="s1">self.type.type  </span><span class="s2"># obj changed inplace!</span>
</pre>
</body>
</html>