<html>
<head>
<title>sankey.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sankey.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Module for creating Sankey diagrams using Matplotlib. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">SimpleNamespace</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">matplotlib.patches </span><span class="s2">import </span><span class="s1">PathPatch</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Affine2D</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_docstring</span>

<span class="s1">_log = logging.getLogger(__name__)</span>

<span class="s1">__author__ = </span><span class="s3">&quot;Kevin L. Davies&quot;</span>
<span class="s1">__credits__ = [</span><span class="s3">&quot;Yannick Copin&quot;</span><span class="s1">]</span>
<span class="s1">__license__ = </span><span class="s3">&quot;BSD&quot;</span>
<span class="s1">__version__ = </span><span class="s3">&quot;2011/09/16&quot;</span>

<span class="s4"># Angles [deg/90]</span>
<span class="s1">RIGHT = </span><span class="s5">0</span>
<span class="s1">UP = </span><span class="s5">1</span>
<span class="s4"># LEFT = 2</span>
<span class="s1">DOWN = </span><span class="s5">3</span>


<span class="s2">class </span><span class="s1">Sankey:</span>
    <span class="s0">&quot;&quot;&quot; 
    Sankey diagram. 
 
      Sankey diagrams are a specific type of flow diagram, in which 
      the width of the arrows is shown proportionally to the flow 
      quantity.  They are typically used to visualize energy or 
      material or cost transfers between processes. 
      `Wikipedia (6/1/2011) &lt;https://en.wikipedia.org/wiki/Sankey_diagram&gt;`_ 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">scale=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'%G'</span><span class="s2">, </span><span class="s1">gap=</span><span class="s5">0.25</span><span class="s2">,</span>
                 <span class="s1">radius=</span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">shoulder=</span><span class="s5">0.03</span><span class="s2">, </span><span class="s1">offset=</span><span class="s5">0.15</span><span class="s2">, </span><span class="s1">head_angle=</span><span class="s5">100</span><span class="s2">,</span>
                 <span class="s1">margin=</span><span class="s5">0.4</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a new Sankey instance. 
 
        The optional arguments listed below are applied to all subdiagrams so 
        that there is consistent alignment and formatting. 
 
        In order to draw a complex Sankey diagram, create an instance of 
        :class:`Sankey` by calling it without any kwargs:: 
 
            sankey = Sankey() 
 
        Then add simple Sankey sub-diagrams:: 
 
            sankey.add() # 1 
            sankey.add() # 2 
            #... 
            sankey.add() # n 
 
        Finally, create the full diagram:: 
 
            sankey.finish() 
 
        Or, instead, simply daisy-chain those calls:: 
 
            Sankey().add().add...  .add().finish() 
 
        Other Parameters 
        ---------------- 
        ax : `~.axes.Axes` 
            Axes onto which the data should be plotted.  If *ax* isn't 
            provided, new Axes will be created. 
        scale : float 
            Scaling factor for the flows.  *scale* sizes the width of the paths 
            in order to maintain proper layout.  The same scale is applied to 
            all subdiagrams.  The value should be chosen such that the product 
            of the scale and the sum of the inputs is approximately 1.0 (and 
            the product of the scale and the sum of the outputs is 
            approximately -1.0). 
        unit : str 
            The physical unit associated with the flow quantities.  If *unit* 
            is None, then none of the quantities are labeled. 
        format : str or callable 
            A Python number formatting string or callable used to label the 
            flows with their quantities (i.e., a number times a unit, where the 
            unit is given). If a format string is given, the label will be 
            ``format % quantity``. If a callable is given, it will be called 
            with ``quantity`` as an argument. 
        gap : float 
            Space between paths that break in/break away to/from the top or 
            bottom. 
        radius : float 
            Inner radius of the vertical paths. 
        shoulder : float 
            Size of the shoulders of output arrows. 
        offset : float 
            Text offset (from the dip or tip of the arrow). 
        head_angle : float 
            Angle, in degrees, of the arrow heads (and negative of the angle of 
            the tails). 
        margin : float 
            Minimum space between Sankey outlines and the edge of the plot 
            area. 
        tolerance : float 
            Acceptable maximum of the magnitude of the sum of flows.  The 
            magnitude of the sum of connected flows cannot be greater than 
            *tolerance*. 
        **kwargs 
            Any additional keyword arguments will be passed to :meth:`add`, 
            which will create the first subdiagram. 
 
        See Also 
        -------- 
        Sankey.add 
        Sankey.finish 
 
        Examples 
        -------- 
        .. plot:: gallery/specialty_plots/sankey_basics.py 
        &quot;&quot;&quot;</span>
        <span class="s4"># Check the arguments.</span>
        <span class="s2">if </span><span class="s1">gap &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;'gap' is negative, which is not allowed because it would &quot;</span>
                <span class="s3">&quot;cause the paths to overlap&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">radius &gt; gap:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;'radius' is greater than 'gap', which is not allowed because &quot;</span>
                <span class="s3">&quot;it would cause the paths to overlap&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">head_angle &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;'head_angle' is negative, which is not allowed because it &quot;</span>
                <span class="s3">&quot;would cause inputs to look like outputs and vice versa&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">tolerance &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;'tolerance' is negative, but it must be a magnitude&quot;</span><span class="s1">)</span>

        <span class="s4"># Create axes if necessary.</span>
        <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
            <span class="s1">fig = plt.figure()</span>
            <span class="s1">ax = fig.add_subplot(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">xticks=[]</span><span class="s2">, </span><span class="s1">yticks=[])</span>

        <span class="s1">self.diagrams = []</span>

        <span class="s4"># Store the inputs.</span>
        <span class="s1">self.ax = ax</span>
        <span class="s1">self.unit = unit</span>
        <span class="s1">self.format = format</span>
        <span class="s1">self.scale = scale</span>
        <span class="s1">self.gap = gap</span>
        <span class="s1">self.radius = radius</span>
        <span class="s1">self.shoulder = shoulder</span>
        <span class="s1">self.offset = offset</span>
        <span class="s1">self.margin = margin</span>
        <span class="s1">self.pitch = np.tan(np.pi * (</span><span class="s5">1 </span><span class="s1">- head_angle / </span><span class="s5">180.0</span><span class="s1">) / </span><span class="s5">2.0</span><span class="s1">)</span>
        <span class="s1">self.tolerance = tolerance</span>

        <span class="s4"># Initialize the vertices of tight box around the diagram(s).</span>
        <span class="s1">self.extent = np.array((np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">-np.inf))</span>

        <span class="s4"># If there are any kwargs, create the first subdiagram.</span>
        <span class="s2">if </span><span class="s1">len(kwargs):</span>
            <span class="s1">self.add(**kwargs)</span>

    <span class="s2">def </span><span class="s1">_arc(self</span><span class="s2">, </span><span class="s1">quadrant=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cw=</span><span class="s2">True, </span><span class="s1">radius=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">center=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the codes and vertices for a rotated, scaled, and translated 
        90 degree arc. 
 
        Other Parameters 
        ---------------- 
        quadrant : {0, 1, 2, 3}, default: 0 
            Uses 0-based indexing (0, 1, 2, or 3). 
        cw : bool, default: True 
            If True, the arc vertices are produced clockwise; counter-clockwise 
            otherwise. 
        radius : float, default: 1 
            The radius of the arc. 
        center : (float, float), default: (0, 0) 
            (x, y) tuple of the arc's center. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Note:  It would be possible to use matplotlib's transforms to rotate,</span>
        <span class="s4"># scale, and translate the arc, but since the angles are discrete,</span>
        <span class="s4"># it's just as easy and maybe more efficient to do it here.</span>
        <span class="s1">ARC_CODES = [Path.LINETO</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE4]</span>
        <span class="s4"># Vertices of a cubic Bezier curve approximating a 90 deg arc</span>
        <span class="s4"># These can be determined by Path.arc(0, 90).</span>
        <span class="s1">ARC_VERTICES = np.array([[</span><span class="s5">1.00000000e+00</span><span class="s2">, </span><span class="s5">0.00000000e+00</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s5">1.00000000e+00</span><span class="s2">, </span><span class="s5">2.65114773e-01</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s5">8.94571235e-01</span><span class="s2">, </span><span class="s5">5.19642327e-01</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s5">7.07106781e-01</span><span class="s2">, </span><span class="s5">7.07106781e-01</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s5">5.19642327e-01</span><span class="s2">, </span><span class="s5">8.94571235e-01</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s5">2.65114773e-01</span><span class="s2">, </span><span class="s5">1.00000000e+00</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s4"># Insignificant</span>
                                 <span class="s4"># [6.12303177e-17, 1.00000000e+00]])</span>
                                 <span class="s1">[</span><span class="s5">0.00000000e+00</span><span class="s2">, </span><span class="s5">1.00000000e+00</span><span class="s1">]])</span>
        <span class="s2">if </span><span class="s1">quadrant </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">cw:</span>
                <span class="s1">vertices = ARC_VERTICES</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vertices = ARC_VERTICES[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># Swap x and y.</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># 1, 3</span>
            <span class="s4"># Negate x.</span>
            <span class="s2">if </span><span class="s1">cw:</span>
                <span class="s4"># Swap x and y.</span>
                <span class="s1">vertices = np.column_stack((-ARC_VERTICES[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">ARC_VERTICES[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vertices = np.column_stack((-ARC_VERTICES[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">ARC_VERTICES[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s2">if </span><span class="s1">quadrant &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">radius = -radius  </span><span class="s4"># Rotate 180 deg.</span>
        <span class="s2">return </span><span class="s1">list(zip(ARC_CODES</span><span class="s2">, </span><span class="s1">radius * vertices +</span>
                        <span class="s1">np.tile(center</span><span class="s2">, </span><span class="s1">(ARC_VERTICES.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))))</span>

    <span class="s2">def </span><span class="s1">_add_input(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">flow</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add an input to a path and return its tip and label locations. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">angle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = path[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># Use the last point as a reference.</span>
            <span class="s1">dipdepth = (flow / </span><span class="s5">2</span><span class="s1">) * self.pitch</span>
            <span class="s2">if </span><span class="s1">angle == RIGHT:</span>
                <span class="s1">x -= length</span>
                <span class="s1">dip = [x + dipdepth</span><span class="s2">, </span><span class="s1">y + flow / </span><span class="s5">2.0</span><span class="s1">]</span>
                <span class="s1">path.extend([(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">dip)</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y + flow])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x + self.gap</span><span class="s2">, </span><span class="s1">y + flow])])</span>
                <span class="s1">label_location = [dip[</span><span class="s5">0</span><span class="s1">] - self.offset</span><span class="s2">, </span><span class="s1">dip[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s4"># Vertical</span>
                <span class="s1">x -= self.gap</span>
                <span class="s2">if </span><span class="s1">angle == UP:</span>
                    <span class="s1">sign = </span><span class="s5">1</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sign = -</span><span class="s5">1</span>

                <span class="s1">dip = [x - flow / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">y - sign * (length - dipdepth)]</span>
                <span class="s2">if </span><span class="s1">angle == DOWN:</span>
                    <span class="s1">quadrant = </span><span class="s5">2</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">quadrant = </span><span class="s5">1</span>

                <span class="s4"># Inner arc isn't needed if inner radius is zero</span>
                <span class="s2">if </span><span class="s1">self.radius:</span>
                    <span class="s1">path.extend(self._arc(quadrant=quadrant</span><span class="s2">,</span>
                                          <span class="s1">cw=angle == UP</span><span class="s2">,</span>
                                          <span class="s1">radius=self.radius</span><span class="s2">,</span>
                                          <span class="s1">center=(x + self.radius</span><span class="s2">,</span>
                                                  <span class="s1">y - sign * self.radius)))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">path.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y]))</span>
                <span class="s1">path.extend([(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y - sign * length])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">dip)</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x - flow</span><span class="s2">, </span><span class="s1">y - sign * length])])</span>
                <span class="s1">path.extend(self._arc(quadrant=quadrant</span><span class="s2">,</span>
                                      <span class="s1">cw=angle == DOWN</span><span class="s2">,</span>
                                      <span class="s1">radius=flow + self.radius</span><span class="s2">,</span>
                                      <span class="s1">center=(x + self.radius</span><span class="s2">,</span>
                                              <span class="s1">y - sign * self.radius)))</span>
                <span class="s1">path.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[x - flow</span><span class="s2">, </span><span class="s1">y + sign * flow]))</span>
                <span class="s1">label_location = [dip[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dip[</span><span class="s5">1</span><span class="s1">] - sign * self.offset]</span>

            <span class="s2">return </span><span class="s1">dip</span><span class="s2">, </span><span class="s1">label_location</span>

    <span class="s2">def </span><span class="s1">_add_output(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">flow</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0">&quot;&quot;&quot; 
        Append an output to a path and return its tip and label locations. 
 
        .. note:: *flow* is negative for an output. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">angle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = path[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># Use the last point as a reference.</span>
            <span class="s1">tipheight = (self.shoulder - flow / </span><span class="s5">2</span><span class="s1">) * self.pitch</span>
            <span class="s2">if </span><span class="s1">angle == RIGHT:</span>
                <span class="s1">x += length</span>
                <span class="s1">tip = [x + tipheight</span><span class="s2">, </span><span class="s1">y + flow / </span><span class="s5">2.0</span><span class="s1">]</span>
                <span class="s1">path.extend([(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y + self.shoulder])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tip)</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y - self.shoulder + flow])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y + flow])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x - self.gap</span><span class="s2">, </span><span class="s1">y + flow])])</span>
                <span class="s1">label_location = [tip[</span><span class="s5">0</span><span class="s1">] + self.offset</span><span class="s2">, </span><span class="s1">tip[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s4"># Vertical</span>
                <span class="s1">x += self.gap</span>
                <span class="s2">if </span><span class="s1">angle == UP:</span>
                    <span class="s1">sign</span><span class="s2">, </span><span class="s1">quadrant = </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">sign</span><span class="s2">, </span><span class="s1">quadrant = -</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span>

                <span class="s1">tip = [x - flow / </span><span class="s5">2.0</span><span class="s2">, </span><span class="s1">y + sign * (length + tipheight)]</span>
                <span class="s4"># Inner arc isn't needed if inner radius is zero</span>
                <span class="s2">if </span><span class="s1">self.radius:</span>
                    <span class="s1">path.extend(self._arc(quadrant=quadrant</span><span class="s2">,</span>
                                          <span class="s1">cw=angle == UP</span><span class="s2">,</span>
                                          <span class="s1">radius=self.radius</span><span class="s2">,</span>
                                          <span class="s1">center=(x - self.radius</span><span class="s2">,</span>
                                                  <span class="s1">y + sign * self.radius)))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">path.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y]))</span>
                <span class="s1">path.extend([(Path.LINETO</span><span class="s2">, </span><span class="s1">[x</span><span class="s2">, </span><span class="s1">y + sign * length])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x - self.shoulder</span><span class="s2">,</span>
                                            <span class="s1">y + sign * length])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tip)</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x + self.shoulder - flow</span><span class="s2">,</span>
                                            <span class="s1">y + sign * length])</span><span class="s2">,</span>
                             <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[x - flow</span><span class="s2">, </span><span class="s1">y + sign * length])])</span>
                <span class="s1">path.extend(self._arc(quadrant=quadrant</span><span class="s2">,</span>
                                      <span class="s1">cw=angle == DOWN</span><span class="s2">,</span>
                                      <span class="s1">radius=self.radius - flow</span><span class="s2">,</span>
                                      <span class="s1">center=(x - self.radius</span><span class="s2">,</span>
                                              <span class="s1">y + sign * self.radius)))</span>
                <span class="s1">path.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[x - flow</span><span class="s2">, </span><span class="s1">y + sign * flow]))</span>
                <span class="s1">label_location = [tip[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tip[</span><span class="s5">1</span><span class="s1">] + sign * self.offset]</span>
            <span class="s2">return </span><span class="s1">tip</span><span class="s2">, </span><span class="s1">label_location</span>

    <span class="s2">def </span><span class="s1">_revert(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">first_action=Path.LINETO):</span>
        <span class="s0">&quot;&quot;&quot; 
        A path is not simply reversible by path[::-1] since the code 
        specifies an action to take from the **previous** point. 
        &quot;&quot;&quot;</span>
        <span class="s1">reverse_path = []</span>
        <span class="s1">next_code = first_action</span>
        <span class="s2">for </span><span class="s1">code</span><span class="s2">, </span><span class="s1">position </span><span class="s2">in </span><span class="s1">path[::-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">reverse_path.append((next_code</span><span class="s2">, </span><span class="s1">position))</span>
            <span class="s1">next_code = code</span>
        <span class="s2">return </span><span class="s1">reverse_path</span>
        <span class="s4"># This might be more efficient, but it fails because 'tuple' object</span>
        <span class="s4"># doesn't support item assignment:</span>
        <span class="s4"># path[1] = path[1][-1:0:-1]</span>
        <span class="s4"># path[1][0] = first_action</span>
        <span class="s4"># path[2] = path[2][::-1]</span>
        <span class="s4"># return path</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">patchlabel=</span><span class="s3">''</span><span class="s2">, </span><span class="s1">flows=</span><span class="s2">None, </span><span class="s1">orientations=</span><span class="s2">None, </span><span class="s1">labels=</span><span class="s3">''</span><span class="s2">,</span>
            <span class="s1">trunklength=</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">pathlengths=</span><span class="s5">0.25</span><span class="s2">, </span><span class="s1">prior=</span><span class="s2">None, </span><span class="s1">connect=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">rotation=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add a simple Sankey diagram with flows at the same hierarchical level. 
 
        Parameters 
        ---------- 
        patchlabel : str 
            Label to be placed at the center of the diagram. 
            Note that *label* (not *patchlabel*) can be passed as keyword 
            argument to create an entry in the legend. 
 
        flows : list of float 
            Array of flow values.  By convention, inputs are positive and 
            outputs are negative. 
 
            Flows are placed along the top of the diagram from the inside out 
            in order of their index within *flows*.  They are placed along the 
            sides of the diagram from the top down and along the bottom from 
            the outside in. 
 
            If the sum of the inputs and outputs is 
            nonzero, the discrepancy will appear as a cubic BÃ©zier curve along 
            the top and bottom edges of the trunk. 
 
        orientations : list of {-1, 0, 1} 
            List of orientations of the flows (or a single orientation to be 
            used for all flows).  Valid values are 0 (inputs from 
            the left, outputs to the right), 1 (from and to the top) or -1 
            (from and to the bottom). 
 
        labels : list of (str or None) 
            List of labels for the flows (or a single label to be used for all 
            flows).  Each label may be *None* (no label), or a labeling string. 
            If an entry is a (possibly empty) string, then the quantity for the 
            corresponding flow will be shown below the string.  However, if 
            the *unit* of the main diagram is None, then quantities are never 
            shown, regardless of the value of this argument. 
 
        trunklength : float 
            Length between the bases of the input and output groups (in 
            data-space units). 
 
        pathlengths : list of float 
            List of lengths of the vertical arrows before break-in or after 
            break-away.  If a single value is given, then it will be applied to 
            the first (inside) paths on the top and bottom, and the length of 
            all other arrows will be justified accordingly.  The *pathlengths* 
            are not applied to the horizontal inputs and outputs. 
 
        prior : int 
            Index of the prior diagram to which this diagram should be 
            connected. 
 
        connect : (int, int) 
            A (prior, this) tuple indexing the flow of the prior diagram and 
            the flow of this diagram which should be connected.  If this is the 
            first diagram or *prior* is *None*, *connect* will be ignored. 
 
        rotation : float 
            Angle of rotation of the diagram in degrees.  The interpretation of 
            the *orientations* argument will be rotated accordingly (e.g., if 
            *rotation* == 90, an *orientations* entry of 1 means to/from the 
            left).  *rotation* is ignored if this diagram is connected to an 
            existing one (using *prior* and *connect*). 
 
        Returns 
        ------- 
        Sankey 
            The current `.Sankey` instance. 
 
        Other Parameters 
        ---------------- 
        **kwargs 
           Additional keyword arguments set `matplotlib.patches.PathPatch` 
           properties, listed below.  For example, one may want to use 
           ``fill=False`` or ``label=&quot;A legend entry&quot;``. 
 
        %(Patch:kwdoc)s 
 
        See Also 
        -------- 
        Sankey.finish 
        &quot;&quot;&quot;</span>
        <span class="s4"># Check and preprocess the arguments.</span>
        <span class="s1">flows = np.array([</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">flows </span><span class="s2">is None else </span><span class="s1">np.array(flows)</span>
        <span class="s1">n = flows.shape[</span><span class="s5">0</span><span class="s1">]  </span><span class="s4"># Number of flows</span>
        <span class="s2">if </span><span class="s1">rotation </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rotation = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># In the code below, angles are expressed in deg/90.</span>
            <span class="s1">rotation /= </span><span class="s5">90.0</span>
        <span class="s2">if </span><span class="s1">orientations </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">orientations = </span><span class="s5">0</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">orientations = np.broadcast_to(orientations</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;The shapes of 'flows' </span><span class="s2">{</span><span class="s1">np.shape(flows)</span><span class="s2">} </span><span class="s3">and 'orientations' &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">np.shape(orientations)</span><span class="s2">} </span><span class="s3">are incompatible&quot;</span>
            <span class="s1">) </span><span class="s2">from None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">labels = np.broadcast_to(labels</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;The shapes of 'flows' </span><span class="s2">{</span><span class="s1">np.shape(flows)</span><span class="s2">} </span><span class="s3">and 'labels' &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">np.shape(labels)</span><span class="s2">} </span><span class="s3">are incompatible&quot;</span>
            <span class="s1">) </span><span class="s2">from None</span>
        <span class="s2">if </span><span class="s1">trunklength &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;'trunklength' is negative, which is not allowed because it &quot;</span>
                <span class="s3">&quot;would cause poor layout&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">abs(np.sum(flows)) &gt; self.tolerance:</span>
            <span class="s1">_log.info(</span><span class="s3">&quot;The sum of the flows is nonzero (%f; patchlabel=%r); &quot;</span>
                      <span class="s3">&quot;is the system not at steady state?&quot;</span><span class="s2">,</span>
                      <span class="s1">np.sum(flows)</span><span class="s2">, </span><span class="s1">patchlabel)</span>
        <span class="s1">scaled_flows = self.scale * flows</span>
        <span class="s1">gain = sum(max(flow</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) </span><span class="s2">for </span><span class="s1">flow </span><span class="s2">in </span><span class="s1">scaled_flows)</span>
        <span class="s1">loss = sum(min(flow</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) </span><span class="s2">for </span><span class="s1">flow </span><span class="s2">in </span><span class="s1">scaled_flows)</span>
        <span class="s2">if </span><span class="s1">prior </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">prior &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;The index of the prior diagram is negative&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">min(connect) &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;At least one of the connection indices is negative&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">prior &gt;= len(self.diagrams):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The index of the prior diagram is </span><span class="s2">{</span><span class="s1">prior</span><span class="s2">}</span><span class="s3">, but there &quot;</span>
                    <span class="s3">f&quot;are only </span><span class="s2">{</span><span class="s1">len(self.diagrams)</span><span class="s2">} </span><span class="s3">other diagrams&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">connect[</span><span class="s5">0</span><span class="s1">] &gt;= len(self.diagrams[prior].flows):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;The connection index to the source diagram is {}, but &quot;</span>
                    <span class="s3">&quot;that diagram has only {} flows&quot;</span><span class="s1">.format(</span>
                        <span class="s1">connect[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">len(self.diagrams[prior].flows)))</span>
            <span class="s2">if </span><span class="s1">connect[</span><span class="s5">1</span><span class="s1">] &gt;= n:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The connection index to this diagram is </span><span class="s2">{</span><span class="s1">connect[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;but this diagram has only </span><span class="s2">{</span><span class="s1">n</span><span class="s2">} </span><span class="s3">flows&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.diagrams[prior].angles[connect[</span><span class="s5">0</span><span class="s1">]] </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The connection cannot be made, which may occur if the &quot;</span>
                    <span class="s3">f&quot;magnitude of flow </span><span class="s2">{</span><span class="s1">connect[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">} </span><span class="s3">of diagram </span><span class="s2">{</span><span class="s1">prior</span><span class="s2">} </span><span class="s3">is &quot;</span>
                    <span class="s3">f&quot;less than the specified tolerance&quot;</span><span class="s1">)</span>
            <span class="s1">flow_error = (self.diagrams[prior].flows[connect[</span><span class="s5">0</span><span class="s1">]] +</span>
                          <span class="s1">flows[connect[</span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s2">if </span><span class="s1">abs(flow_error) &gt;= self.tolerance:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The scaled sum of the connected flows is </span><span class="s2">{</span><span class="s1">flow_error</span><span class="s2">}</span><span class="s3">, &quot;</span>
                    <span class="s3">f&quot;which is not within the tolerance (</span><span class="s2">{</span><span class="s1">self.tolerance</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)</span>

        <span class="s4"># Determine if the flows are inputs.</span>
        <span class="s1">are_inputs = [</span><span class="s2">None</span><span class="s1">] * n</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">flow </span><span class="s2">in </span><span class="s1">enumerate(flows):</span>
            <span class="s2">if </span><span class="s1">flow &gt;= self.tolerance:</span>
                <span class="s1">are_inputs[i] = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">flow &lt;= -self.tolerance:</span>
                <span class="s1">are_inputs[i] = </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_log.info(</span>
                    <span class="s3">&quot;The magnitude of flow %d (%f) is below the tolerance &quot;</span>
                    <span class="s3">&quot;(%f).</span><span class="s2">\n</span><span class="s3">It will not be shown, and it cannot be used in a &quot;</span>
                    <span class="s3">&quot;connection.&quot;</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">flow</span><span class="s2">, </span><span class="s1">self.tolerance)</span>

        <span class="s4"># Determine the angles of the arrows (before rotation).</span>
        <span class="s1">angles = [</span><span class="s2">None</span><span class="s1">] * n</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(orient</span><span class="s2">, </span><span class="s1">is_input) </span><span class="s2">in </span><span class="s1">enumerate(zip(orientations</span><span class="s2">, </span><span class="s1">are_inputs)):</span>
            <span class="s2">if </span><span class="s1">orient == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">is_input:</span>
                    <span class="s1">angles[i] = DOWN</span>
                <span class="s2">elif </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                    <span class="s4"># Be specific since is_input can be None.</span>
                    <span class="s1">angles[i] = UP</span>
            <span class="s2">elif </span><span class="s1">orient == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">is_input </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">angles[i] = RIGHT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">orient != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">f&quot;The value of orientations[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">] is </span><span class="s2">{</span><span class="s1">orient</span><span class="s2">}</span><span class="s3">, &quot;</span>
                        <span class="s3">f&quot;but it must be -1, 0, or 1&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">is_input:</span>
                    <span class="s1">angles[i] = UP</span>
                <span class="s2">elif </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                    <span class="s1">angles[i] = DOWN</span>

        <span class="s4"># Justify the lengths of the paths.</span>
        <span class="s2">if </span><span class="s1">np.iterable(pathlengths):</span>
            <span class="s2">if </span><span class="s1">len(pathlengths) != n:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;The lengths of 'flows' (</span><span class="s2">{</span><span class="s1">n</span><span class="s2">}</span><span class="s3">) and 'pathlengths' &quot;</span>
                    <span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">len(pathlengths)</span><span class="s2">}</span><span class="s3">) are incompatible&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># Make pathlengths into a list.</span>
            <span class="s1">urlength = pathlengths</span>
            <span class="s1">ullength = pathlengths</span>
            <span class="s1">lrlength = pathlengths</span>
            <span class="s1">lllength = pathlengths</span>
            <span class="s1">d = dict(RIGHT=pathlengths)</span>
            <span class="s1">pathlengths = [d.get(angle</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) </span><span class="s2">for </span><span class="s1">angle </span><span class="s2">in </span><span class="s1">angles]</span>
            <span class="s4"># Determine the lengths of the top-side arrows</span>
            <span class="s4"># from the middle outwards.</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">flow) </span><span class="s2">in </span><span class="s1">enumerate(zip(angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">,</span>
                                                            <span class="s1">scaled_flows)):</span>
                <span class="s2">if </span><span class="s1">angle == DOWN </span><span class="s2">and </span><span class="s1">is_input:</span>
                    <span class="s1">pathlengths[i] = ullength</span>
                    <span class="s1">ullength += flow</span>
                <span class="s2">elif </span><span class="s1">angle == UP </span><span class="s2">and </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                    <span class="s1">pathlengths[i] = urlength</span>
                    <span class="s1">urlength -= flow  </span><span class="s4"># Flow is negative for outputs.</span>
            <span class="s4"># Determine the lengths of the bottom-side arrows</span>
            <span class="s4"># from the middle outwards.</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">flow) </span><span class="s2">in </span><span class="s1">enumerate(reversed(list(zip(</span>
                  <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">scaled_flows)))):</span>
                <span class="s2">if </span><span class="s1">angle == UP </span><span class="s2">and </span><span class="s1">is_input:</span>
                    <span class="s1">pathlengths[n - i - </span><span class="s5">1</span><span class="s1">] = lllength</span>
                    <span class="s1">lllength += flow</span>
                <span class="s2">elif </span><span class="s1">angle == DOWN </span><span class="s2">and </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                    <span class="s1">pathlengths[n - i - </span><span class="s5">1</span><span class="s1">] = lrlength</span>
                    <span class="s1">lrlength -= flow</span>
            <span class="s4"># Determine the lengths of the left-side arrows</span>
            <span class="s4"># from the bottom upwards.</span>
            <span class="s1">has_left_input = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(reversed(list(zip(</span>
                  <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths))))):</span>
                <span class="s2">if </span><span class="s1">angle == RIGHT:</span>
                    <span class="s2">if </span><span class="s1">is_input:</span>
                        <span class="s2">if </span><span class="s1">has_left_input:</span>
                            <span class="s1">pathlengths[n - i - </span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">has_left_input = </span><span class="s2">True</span>
            <span class="s4"># Determine the lengths of the right-side arrows</span>
            <span class="s4"># from the top downwards.</span>
            <span class="s1">has_right_output = </span><span class="s2">False</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(zip(</span>
                  <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">list(zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths)))):</span>
                <span class="s2">if </span><span class="s1">angle == RIGHT:</span>
                    <span class="s2">if </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">has_right_output:</span>
                            <span class="s1">pathlengths[i] = </span><span class="s5">0</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s1">has_right_output = </span><span class="s2">True</span>

        <span class="s4"># Begin the subpaths, and smooth the transition if the sum of the flows</span>
        <span class="s4"># is nonzero.</span>
        <span class="s1">urpath = [(Path.MOVETO</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">)</span><span class="s2">,  </span><span class="s4"># Upper right</span>
                                 <span class="s1">gain / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">) / </span><span class="s5">2.0</span><span class="s2">,</span>
                                 <span class="s1">gain / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.CURVE4</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">) / </span><span class="s5">8.0</span><span class="s2">,</span>
                                 <span class="s1">gain / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.CURVE4</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap) / </span><span class="s5">8.0</span><span class="s2">,</span>
                                 <span class="s1">-loss / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap) / </span><span class="s5">2.0</span><span class="s2">,</span>
                                 <span class="s1">-loss / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap)</span><span class="s2">,</span>
                                 <span class="s1">-loss / </span><span class="s5">2.0</span><span class="s1">])]</span>
        <span class="s1">llpath = [(Path.LINETO</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap)</span><span class="s2">,  </span><span class="s4"># Lower left</span>
                                 <span class="s1">loss / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap) / </span><span class="s5">2.0</span><span class="s2">,</span>
                                 <span class="s1">loss / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.CURVE4</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap) / </span><span class="s5">8.0</span><span class="s2">,</span>
                                 <span class="s1">loss / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.CURVE4</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">) / </span><span class="s5">8.0</span><span class="s2">,</span>
                                 <span class="s1">-gain / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">) / </span><span class="s5">2.0</span><span class="s2">,</span>
                                 <span class="s1">-gain / </span><span class="s5">2.0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">[(self.gap - trunklength / </span><span class="s5">2.0</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s1">-gain / </span><span class="s5">2.0</span><span class="s1">])]</span>
        <span class="s1">lrpath = [(Path.LINETO</span><span class="s2">, </span><span class="s1">[(trunklength / </span><span class="s5">2.0 </span><span class="s1">- self.gap)</span><span class="s2">,  </span><span class="s4"># Lower right</span>
                                 <span class="s1">loss / </span><span class="s5">2.0</span><span class="s1">])]</span>
        <span class="s1">ulpath = [(Path.LINETO</span><span class="s2">, </span><span class="s1">[self.gap - trunklength / </span><span class="s5">2.0</span><span class="s2">,  </span><span class="s4"># Upper left</span>
                                 <span class="s1">gain / </span><span class="s5">2.0</span><span class="s1">])]</span>

        <span class="s4"># Add the subpaths and assign the locations of the tips and labels.</span>
        <span class="s1">tips = np.zeros((n</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">label_locations = np.zeros((n</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s4"># Add the top-side inputs and outputs from the middle outwards.</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(zip(</span>
              <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">list(zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths)))):</span>
            <span class="s2">if </span><span class="s1">angle == DOWN </span><span class="s2">and </span><span class="s1">is_input:</span>
                <span class="s1">tips[i</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">label_locations[i</span><span class="s2">, </span><span class="s1">:] = self._add_input(</span>
                    <span class="s1">ulpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
            <span class="s2">elif </span><span class="s1">angle == UP </span><span class="s2">and </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s1">tips[i</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">label_locations[i</span><span class="s2">, </span><span class="s1">:] = self._add_output(</span>
                    <span class="s1">urpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
        <span class="s4"># Add the bottom-side inputs and outputs from the middle outwards.</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(reversed(list(zip(</span>
              <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">list(zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths)))))):</span>
            <span class="s2">if </span><span class="s1">angle == UP </span><span class="s2">and </span><span class="s1">is_input:</span>
                <span class="s1">tip</span><span class="s2">, </span><span class="s1">label_location = self._add_input(llpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
                <span class="s1">tips[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = tip</span>
                <span class="s1">label_locations[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = label_location</span>
            <span class="s2">elif </span><span class="s1">angle == DOWN </span><span class="s2">and </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s1">tip</span><span class="s2">, </span><span class="s1">label_location = self._add_output(lrpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
                <span class="s1">tips[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = tip</span>
                <span class="s1">label_locations[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = label_location</span>
        <span class="s4"># Add the left-side inputs from the bottom upwards.</span>
        <span class="s1">has_left_input = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(reversed(list(zip(</span>
              <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">list(zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths)))))):</span>
            <span class="s2">if </span><span class="s1">angle == RIGHT </span><span class="s2">and </span><span class="s1">is_input:</span>
                <span class="s2">if not </span><span class="s1">has_left_input:</span>
                    <span class="s4"># Make sure the lower path extends</span>
                    <span class="s4"># at least as far as the upper one.</span>
                    <span class="s2">if </span><span class="s1">llpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] &gt; ulpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]:</span>
                        <span class="s1">llpath.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[ulpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                                     <span class="s1">llpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]]))</span>
                    <span class="s1">has_left_input = </span><span class="s2">True</span>
                <span class="s1">tip</span><span class="s2">, </span><span class="s1">label_location = self._add_input(llpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
                <span class="s1">tips[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = tip</span>
                <span class="s1">label_locations[n - i - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:] = label_location</span>
        <span class="s4"># Add the right-side outputs from the top downwards.</span>
        <span class="s1">has_right_output = </span><span class="s2">False</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(angle</span><span class="s2">, </span><span class="s1">is_input</span><span class="s2">, </span><span class="s1">spec) </span><span class="s2">in </span><span class="s1">enumerate(zip(</span>
              <span class="s1">angles</span><span class="s2">, </span><span class="s1">are_inputs</span><span class="s2">, </span><span class="s1">list(zip(scaled_flows</span><span class="s2">, </span><span class="s1">pathlengths)))):</span>
            <span class="s2">if </span><span class="s1">angle == RIGHT </span><span class="s2">and </span><span class="s1">is_input </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">has_right_output:</span>
                    <span class="s4"># Make sure the upper path extends</span>
                    <span class="s4"># at least as far as the lower one.</span>
                    <span class="s2">if </span><span class="s1">urpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">] &lt; lrpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]:</span>
                        <span class="s1">urpath.append((Path.LINETO</span><span class="s2">, </span><span class="s1">[lrpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                                                     <span class="s1">urpath[-</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]]))</span>
                    <span class="s1">has_right_output = </span><span class="s2">True</span>
                <span class="s1">tips[i</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">label_locations[i</span><span class="s2">, </span><span class="s1">:] = self._add_output(</span>
                    <span class="s1">urpath</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">*spec)</span>
        <span class="s4"># Trim any hanging vertices.</span>
        <span class="s2">if not </span><span class="s1">has_left_input:</span>
            <span class="s1">ulpath.pop()</span>
            <span class="s1">llpath.pop()</span>
        <span class="s2">if not </span><span class="s1">has_right_output:</span>
            <span class="s1">lrpath.pop()</span>
            <span class="s1">urpath.pop()</span>

        <span class="s4"># Concatenate the subpaths in the correct order (clockwise from top).</span>
        <span class="s1">path = (urpath + self._revert(lrpath) + llpath + self._revert(ulpath) +</span>
                <span class="s1">[(Path.CLOSEPOLY</span><span class="s2">, </span><span class="s1">urpath[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">])])</span>

        <span class="s4"># Create a patch with the Sankey outline.</span>
        <span class="s1">codes</span><span class="s2">, </span><span class="s1">vertices = zip(*path)</span>
        <span class="s1">vertices = np.array(vertices)</span>

        <span class="s2">def </span><span class="s1">_get_angle(a</span><span class="s2">, </span><span class="s1">r):</span>
            <span class="s2">if </span><span class="s1">a </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">a + r</span>

        <span class="s2">if </span><span class="s1">prior </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">rotation != </span><span class="s5">0</span><span class="s1">:  </span><span class="s4"># By default, none of this is needed.</span>
                <span class="s1">angles = [_get_angle(angle</span><span class="s2">, </span><span class="s1">rotation) </span><span class="s2">for </span><span class="s1">angle </span><span class="s2">in </span><span class="s1">angles]</span>
                <span class="s1">rotate = Affine2D().rotate_deg(rotation * </span><span class="s5">90</span><span class="s1">).transform_affine</span>
                <span class="s1">tips = rotate(tips)</span>
                <span class="s1">label_locations = rotate(label_locations)</span>
                <span class="s1">vertices = rotate(vertices)</span>
            <span class="s1">text = self.ax.text(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">s=patchlabel</span><span class="s2">, </span><span class="s1">ha=</span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">'center'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rotation = (self.diagrams[prior].angles[connect[</span><span class="s5">0</span><span class="s1">]] -</span>
                        <span class="s1">angles[connect[</span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s1">angles = [_get_angle(angle</span><span class="s2">, </span><span class="s1">rotation) </span><span class="s2">for </span><span class="s1">angle </span><span class="s2">in </span><span class="s1">angles]</span>
            <span class="s1">rotate = Affine2D().rotate_deg(rotation * </span><span class="s5">90</span><span class="s1">).transform_affine</span>
            <span class="s1">tips = rotate(tips)</span>
            <span class="s1">offset = self.diagrams[prior].tips[connect[</span><span class="s5">0</span><span class="s1">]] - tips[connect[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">translate = Affine2D().translate(*offset).transform_affine</span>
            <span class="s1">tips = translate(tips)</span>
            <span class="s1">label_locations = translate(rotate(label_locations))</span>
            <span class="s1">vertices = translate(rotate(vertices))</span>
            <span class="s1">kwds = dict(s=patchlabel</span><span class="s2">, </span><span class="s1">ha=</span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">'center'</span><span class="s1">)</span>
            <span class="s1">text = self.ax.text(*offset</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s1">fc = kwargs.pop(</span><span class="s3">'fc'</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s3">'facecolor'</span><span class="s2">, </span><span class="s3">'#bfd1d4'</span><span class="s1">))</span>
            <span class="s1">lw = kwargs.pop(</span><span class="s3">'lw'</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s3">'linewidth'</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fc = kwargs.pop(</span><span class="s3">'fc'</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s3">'facecolor'</span><span class="s2">, None</span><span class="s1">))</span>
            <span class="s1">lw = kwargs.pop(</span><span class="s3">'lw'</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s3">'linewidth'</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">fc </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fc = next(self.ax._get_patches_for_fill.prop_cycler)[</span><span class="s3">'color'</span><span class="s1">]</span>
        <span class="s1">patch = PathPatch(Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span><span class="s2">, </span><span class="s1">fc=fc</span><span class="s2">, </span><span class="s1">lw=lw</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.ax.add_patch(patch)</span>

        <span class="s4"># Add the path labels.</span>
        <span class="s1">texts = []</span>
        <span class="s2">for </span><span class="s1">number</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">location </span><span class="s2">in </span><span class="s1">zip(flows</span><span class="s2">, </span><span class="s1">angles</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">,</span>
                                                  <span class="s1">label_locations):</span>
            <span class="s2">if </span><span class="s1">label </span><span class="s2">is None or </span><span class="s1">angle </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">label = </span><span class="s3">''</span>
            <span class="s2">elif </span><span class="s1">self.unit </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">isinstance(self.format</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">quantity = self.format % abs(number) + self.unit</span>
                <span class="s2">elif </span><span class="s1">callable(self.format):</span>
                    <span class="s1">quantity = self.format(number)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">'format must be callable or a format string'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">label != </span><span class="s3">''</span><span class="s1">:</span>
                    <span class="s1">label += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s1">label += quantity</span>
            <span class="s1">texts.append(self.ax.text(x=location[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y=location[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                                      <span class="s1">s=label</span><span class="s2">,</span>
                                      <span class="s1">ha=</span><span class="s3">'center'</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">'center'</span><span class="s1">))</span>
        <span class="s4"># Text objects are placed even they are empty (as long as the magnitude</span>
        <span class="s4"># of the corresponding flow is larger than the tolerance) in case the</span>
        <span class="s4"># user wants to provide labels later.</span>

        <span class="s4"># Expand the size of the diagram if necessary.</span>
        <span class="s1">self.extent = (min(np.min(vertices[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.min(label_locations[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">self.extent[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                       <span class="s1">max(np.max(vertices[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.max(label_locations[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">self.extent[</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                       <span class="s1">min(np.min(vertices[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.min(label_locations[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">self.extent[</span><span class="s5">2</span><span class="s1">])</span><span class="s2">,</span>
                       <span class="s1">max(np.max(vertices[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.max(label_locations[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">self.extent[</span><span class="s5">3</span><span class="s1">]))</span>
        <span class="s4"># Include both vertices _and_ label locations in the extents; there are</span>
        <span class="s4"># where either could determine the margins (e.g., arrow shoulders).</span>

        <span class="s4"># Add this diagram as a subdiagram.</span>
        <span class="s1">self.diagrams.append(</span>
            <span class="s1">SimpleNamespace(patch=patch</span><span class="s2">, </span><span class="s1">flows=flows</span><span class="s2">, </span><span class="s1">angles=angles</span><span class="s2">, </span><span class="s1">tips=tips</span><span class="s2">,</span>
                            <span class="s1">text=text</span><span class="s2">, </span><span class="s1">texts=texts))</span>

        <span class="s4"># Allow a daisy-chained call structure (see docstring for the class).</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">finish(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust the axes and return a list of information about the Sankey 
        subdiagram(s). 
 
        Return value is a list of subdiagrams represented with the following 
        fields: 
 
          ===============   =================================================== 
          Field             Description 
          ===============   =================================================== 
          *patch*           Sankey outline (an instance of 
                            :class:`~matplotlib.patches.PathPatch`) 
          *flows*           values of the flows (positive for input, negative 
                            for output) 
          *angles*          list of angles of the arrows [deg/90] 
                            For example, if the diagram has not been rotated, 
                            an input to the top side will have an angle of 3 
                            (DOWN), and an output from the top side will have 
                            an angle of 1 (UP).  If a flow has been skipped 
                            (because its magnitude is less than *tolerance*), 
                            then its angle will be *None*. 
          *tips*            array in which each row is an [x, y] pair 
                            indicating the positions of the tips (or &quot;dips&quot;) of 
                            the flow paths 
                            If the magnitude of a flow is less the *tolerance* 
                            for the instance of :class:`Sankey`, the flow is 
                            skipped and its tip will be at the center of the 
                            diagram. 
          *text*            :class:`~matplotlib.text.Text` instance for the 
                            label of the diagram 
          *texts*           list of :class:`~matplotlib.text.Text` instances 
                            for the labels of flows 
          ===============   =================================================== 
 
        See Also 
        -------- 
        Sankey.add 
        &quot;&quot;&quot;</span>
        <span class="s1">self.ax.axis([self.extent[</span><span class="s5">0</span><span class="s1">] - self.margin</span><span class="s2">,</span>
                      <span class="s1">self.extent[</span><span class="s5">1</span><span class="s1">] + self.margin</span><span class="s2">,</span>
                      <span class="s1">self.extent[</span><span class="s5">2</span><span class="s1">] - self.margin</span><span class="s2">,</span>
                      <span class="s1">self.extent[</span><span class="s5">3</span><span class="s1">] + self.margin])</span>
        <span class="s1">self.ax.set_aspect(</span><span class="s3">'equal'</span><span class="s2">, </span><span class="s1">adjustable=</span><span class="s3">'datalim'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.diagrams</span>
</pre>
</body>
</html>