<html>
<head>
<title>test_cbook.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_cbook.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">pickle</span>

<span class="s0">from </span><span class="s1">weakref </span><span class="s0">import </span><span class="s1">ref</span>
<span class="s0">from </span><span class="s1">unittest.mock </span><span class="s0">import </span><span class="s1">patch</span><span class="s0">, </span><span class="s1">Mock</span>

<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span><span class="s0">, </span><span class="s1">date</span><span class="s0">, </span><span class="s1">timedelta</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_array_equal</span><span class="s0">, </span><span class="s1">assert_approx_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_almost_equal)</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">cbook</span>
<span class="s0">import </span><span class="s1">matplotlib.colors </span><span class="s0">as </span><span class="s1">mcolors</span>
<span class="s0">from </span><span class="s1">matplotlib.cbook </span><span class="s0">import </span><span class="s1">delete_masked_points</span>


<span class="s0">class </span><span class="s1">Test_delete_masked_points:</span>
    <span class="s0">def </span><span class="s1">test_bad_first_arg(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">delete_masked_points(</span><span class="s2">'a string'</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">7.0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_string_seq(self):</span>
        <span class="s1">a1 = [</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'d'</span><span class="s0">, </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s1">]</span>
        <span class="s1">a2 = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
        <span class="s1">result1</span><span class="s0">, </span><span class="s1">result2 = delete_masked_points(a1</span><span class="s0">, </span><span class="s1">a2)</span>
        <span class="s1">ind = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(result1</span><span class="s0">, </span><span class="s1">np.array(a1)[ind])</span>
        <span class="s1">assert_array_equal(result2</span><span class="s0">, </span><span class="s1">np.array(a2)[ind])</span>

    <span class="s0">def </span><span class="s1">test_datetime(self):</span>
        <span class="s1">dates = [datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">,</span>
                 <span class="s1">datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">datetime(</span><span class="s3">2008</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)]</span>
        <span class="s1">a_masked = np.ma.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">mask=[</span><span class="s0">False, False, True, True, False, False</span><span class="s1">])</span>
        <span class="s1">actual = delete_masked_points(dates</span><span class="s0">, </span><span class="s1">a_masked)</span>
        <span class="s1">ind = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(actual[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array(dates)[ind])</span>
        <span class="s1">assert_array_equal(actual[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a_masked[ind].compressed())</span>

    <span class="s0">def </span><span class="s1">test_rgba(self):</span>
        <span class="s1">a_masked = np.ma.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
                               <span class="s1">mask=[</span><span class="s0">False, False, True, True, False, False</span><span class="s1">])</span>
        <span class="s1">a_rgba = mcolors.to_rgba_array([</span><span class="s2">'r'</span><span class="s0">, </span><span class="s2">'g'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'m'</span><span class="s0">, </span><span class="s2">'y'</span><span class="s1">])</span>
        <span class="s1">actual = delete_masked_points(a_masked</span><span class="s0">, </span><span class="s1">a_rgba)</span>
        <span class="s1">ind = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(actual[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a_masked[ind].compressed())</span>
        <span class="s1">assert_array_equal(actual[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a_rgba[ind])</span>


<span class="s0">class </span><span class="s1">Test_boxplot_stats:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">937</span><span class="s1">)</span>
        <span class="s1">self.nrows = </span><span class="s3">37</span>
        <span class="s1">self.ncols = </span><span class="s3">4</span>
        <span class="s1">self.data = np.random.lognormal(size=(self.nrows</span><span class="s0">, </span><span class="s1">self.ncols)</span><span class="s0">,</span>
                                        <span class="s1">mean=</span><span class="s3">1.5</span><span class="s0">, </span><span class="s1">sigma=</span><span class="s3">1.75</span><span class="s1">)</span>
        <span class="s1">self.known_keys = sorted([</span>
            <span class="s2">'mean'</span><span class="s0">, </span><span class="s2">'med'</span><span class="s0">, </span><span class="s2">'q1'</span><span class="s0">, </span><span class="s2">'q3'</span><span class="s0">, </span><span class="s2">'iqr'</span><span class="s0">,</span>
            <span class="s2">'cilo'</span><span class="s0">, </span><span class="s2">'cihi'</span><span class="s0">, </span><span class="s2">'whislo'</span><span class="s0">, </span><span class="s2">'whishi'</span><span class="s0">,</span>
            <span class="s2">'fliers'</span><span class="s0">, </span><span class="s2">'label'</span>
        <span class="s1">])</span>
        <span class="s1">self.std_results = cbook.boxplot_stats(self.data)</span>

        <span class="s1">self.known_nonbootstrapped_res = {</span>
            <span class="s2">'cihi'</span><span class="s1">: </span><span class="s3">6.8161283264444847</span><span class="s0">,</span>
            <span class="s2">'cilo'</span><span class="s1">: -</span><span class="s3">0.1489815330368689</span><span class="s0">,</span>
            <span class="s2">'iqr'</span><span class="s1">: </span><span class="s3">13.492709959447094</span><span class="s0">,</span>
            <span class="s2">'mean'</span><span class="s1">: </span><span class="s3">13.00447442387868</span><span class="s0">,</span>
            <span class="s2">'med'</span><span class="s1">: </span><span class="s3">3.3335733967038079</span><span class="s0">,</span>
            <span class="s2">'fliers'</span><span class="s1">: np.array([</span>
                <span class="s3">92.55467075</span><span class="s0">,  </span><span class="s3">87.03819018</span><span class="s0">,  </span><span class="s3">42.23204914</span><span class="s0">,  </span><span class="s3">39.29390996</span>
            <span class="s1">])</span><span class="s0">,</span>
            <span class="s2">'q1'</span><span class="s1">: </span><span class="s3">1.3597529879465153</span><span class="s0">,</span>
            <span class="s2">'q3'</span><span class="s1">: </span><span class="s3">14.85246294739361</span><span class="s0">,</span>
            <span class="s2">'whishi'</span><span class="s1">: </span><span class="s3">27.899688243699629</span><span class="s0">,</span>
            <span class="s2">'whislo'</span><span class="s1">: </span><span class="s3">0.042143774965502923</span>
        <span class="s1">}</span>

        <span class="s1">self.known_bootstrapped_ci = {</span>
            <span class="s2">'cihi'</span><span class="s1">: </span><span class="s3">8.939577523357828</span><span class="s0">,</span>
            <span class="s2">'cilo'</span><span class="s1">: </span><span class="s3">1.8692703958676578</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">self.known_whis3_res = {</span>
            <span class="s2">'whishi'</span><span class="s1">: </span><span class="s3">42.232049135969874</span><span class="s0">,</span>
            <span class="s2">'whislo'</span><span class="s1">: </span><span class="s3">0.042143774965502923</span><span class="s0">,</span>
            <span class="s2">'fliers'</span><span class="s1">: np.array([</span><span class="s3">92.55467075</span><span class="s0">, </span><span class="s3">87.03819018</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

        <span class="s1">self.known_res_percentiles = {</span>
            <span class="s2">'whislo'</span><span class="s1">:   </span><span class="s3">0.1933685896907924</span><span class="s0">,</span>
            <span class="s2">'whishi'</span><span class="s1">:  </span><span class="s3">42.232049135969874</span>
        <span class="s1">}</span>

        <span class="s1">self.known_res_range = {</span>
            <span class="s2">'whislo'</span><span class="s1">: </span><span class="s3">0.042143774965502923</span><span class="s0">,</span>
            <span class="s2">'whishi'</span><span class="s1">: </span><span class="s3">92.554670752188699</span>

        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">test_form_main_list(self):</span>
        <span class="s0">assert </span><span class="s1">isinstance(self.std_results</span><span class="s0">, </span><span class="s1">list)</span>

    <span class="s0">def </span><span class="s1">test_form_each_dict(self):</span>
        <span class="s0">for </span><span class="s1">res </span><span class="s0">in </span><span class="s1">self.std_results:</span>
            <span class="s0">assert </span><span class="s1">isinstance(res</span><span class="s0">, </span><span class="s1">dict)</span>

    <span class="s0">def </span><span class="s1">test_form_dict_keys(self):</span>
        <span class="s0">for </span><span class="s1">res </span><span class="s0">in </span><span class="s1">self.std_results:</span>
            <span class="s0">assert </span><span class="s1">set(res) &lt;= set(self.known_keys)</span>

    <span class="s0">def </span><span class="s1">test_results_baseline(self):</span>
        <span class="s1">res = self.std_results[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.known_nonbootstrapped_res.items():</span>
            <span class="s1">assert_array_almost_equal(res[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_results_bootstrapped(self):</span>
        <span class="s1">results = cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">bootstrap=</span><span class="s3">10000</span><span class="s1">)</span>
        <span class="s1">res = results[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.known_bootstrapped_ci.items():</span>
            <span class="s1">assert_approx_equal(res[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_results_whiskers_float(self):</span>
        <span class="s1">results = cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">whis=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">res = results[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.known_whis3_res.items():</span>
            <span class="s1">assert_array_almost_equal(res[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_results_whiskers_range(self):</span>
        <span class="s1">results = cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">whis=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">])</span>
        <span class="s1">res = results[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.known_res_range.items():</span>
            <span class="s1">assert_array_almost_equal(res[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_results_whiskers_percentiles(self):</span>
        <span class="s1">results = cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">whis=[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">95</span><span class="s1">])</span>
        <span class="s1">res = results[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.known_res_percentiles.items():</span>
            <span class="s1">assert_array_almost_equal(res[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_results_withlabels(self):</span>
        <span class="s1">labels = [</span><span class="s2">'Test1'</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s2">'Aardvark'</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">results = cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">labels=labels)</span>
        <span class="s0">for </span><span class="s1">lab</span><span class="s0">, </span><span class="s1">res </span><span class="s0">in </span><span class="s1">zip(labels</span><span class="s0">, </span><span class="s1">results):</span>
            <span class="s0">assert </span><span class="s1">res[</span><span class="s2">'label'</span><span class="s1">] == lab</span>

        <span class="s1">results = cbook.boxplot_stats(self.data)</span>
        <span class="s0">for </span><span class="s1">res </span><span class="s0">in </span><span class="s1">results:</span>
            <span class="s0">assert </span><span class="s2">'label' </span><span class="s0">not in </span><span class="s1">res</span>

    <span class="s0">def </span><span class="s1">test_label_error(self):</span>
        <span class="s1">labels = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cbook.boxplot_stats(self.data</span><span class="s0">, </span><span class="s1">labels=labels)</span>

    <span class="s0">def </span><span class="s1">test_bad_dims(self):</span>
        <span class="s1">data = np.random.normal(size=(</span><span class="s3">34</span><span class="s0">, </span><span class="s3">34</span><span class="s0">, </span><span class="s3">34</span><span class="s1">))</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">cbook.boxplot_stats(data)</span>

    <span class="s0">def </span><span class="s1">test_boxplot_stats_autorange_false(self):</span>
        <span class="s1">x = np.zeros(shape=</span><span class="s3">140</span><span class="s1">)</span>
        <span class="s1">x = np.hstack([-</span><span class="s3">25</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s3">25</span><span class="s1">])</span>
        <span class="s1">bstats_false = cbook.boxplot_stats(x</span><span class="s0">, </span><span class="s1">autorange=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">bstats_true = cbook.boxplot_stats(x</span><span class="s0">, </span><span class="s1">autorange=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">bstats_false[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'whislo'</span><span class="s1">] == </span><span class="s3">0</span>
        <span class="s0">assert </span><span class="s1">bstats_false[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'whishi'</span><span class="s1">] == </span><span class="s3">0</span>
        <span class="s1">assert_array_almost_equal(bstats_false[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'fliers'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">25</span><span class="s0">, </span><span class="s3">25</span><span class="s1">])</span>

        <span class="s0">assert </span><span class="s1">bstats_true[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'whislo'</span><span class="s1">] == -</span><span class="s3">25</span>
        <span class="s0">assert </span><span class="s1">bstats_true[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'whishi'</span><span class="s1">] == </span><span class="s3">25</span>
        <span class="s1">assert_array_almost_equal(bstats_true[</span><span class="s3">0</span><span class="s1">][</span><span class="s2">'fliers'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[])</span>


<span class="s0">class </span><span class="s1">Test_callback_registry:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.signal = </span><span class="s2">'test'</span>
        <span class="s1">self.callbacks = cbook.CallbackRegistry()</span>

    <span class="s0">def </span><span class="s1">connect(self</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">pickle):</span>
        <span class="s0">if </span><span class="s1">pickle:</span>
            <span class="s0">return </span><span class="s1">self.callbacks.connect(s</span><span class="s0">, </span><span class="s1">func)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.callbacks._connect_picklable(s</span><span class="s0">, </span><span class="s1">func)</span>

    <span class="s0">def </span><span class="s1">disconnect(self</span><span class="s0">, </span><span class="s1">cid):</span>
        <span class="s0">return </span><span class="s1">self.callbacks.disconnect(cid)</span>

    <span class="s0">def </span><span class="s1">count(self):</span>
        <span class="s1">count1 = len(self.callbacks._func_cid_map.get(self.signal</span><span class="s0">, </span><span class="s1">[]))</span>
        <span class="s1">count2 = len(self.callbacks.callbacks.get(self.signal))</span>
        <span class="s0">assert </span><span class="s1">count1 == count2</span>
        <span class="s0">return </span><span class="s1">count1</span>

    <span class="s0">def </span><span class="s1">is_empty(self):</span>
        <span class="s1">np.testing.break_cycles()</span>
        <span class="s0">assert </span><span class="s1">self.callbacks._func_cid_map == {}</span>
        <span class="s0">assert </span><span class="s1">self.callbacks.callbacks == {}</span>
        <span class="s0">assert </span><span class="s1">self.callbacks._pickled_cids == set()</span>

    <span class="s0">def </span><span class="s1">is_not_empty(self):</span>
        <span class="s1">np.testing.break_cycles()</span>
        <span class="s0">assert </span><span class="s1">self.callbacks._func_cid_map != {}</span>
        <span class="s0">assert </span><span class="s1">self.callbacks.callbacks != {}</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'pickle'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_callback_complete(self</span><span class="s0">, </span><span class="s1">pickle):</span>
        <span class="s4"># ensure we start with an empty registry</span>
        <span class="s1">self.is_empty()</span>

        <span class="s4"># create a class for testing</span>
        <span class="s1">mini_me = Test_callback_registry()</span>

        <span class="s4"># test that we can add a callback</span>
        <span class="s1">cid1 = self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>
        <span class="s0">assert </span><span class="s1">type(cid1) == int</span>
        <span class="s1">self.is_not_empty()</span>

        <span class="s4"># test that we don't add a second callback</span>
        <span class="s1">cid2 = self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>
        <span class="s0">assert </span><span class="s1">cid1 == cid2</span>
        <span class="s1">self.is_not_empty()</span>
        <span class="s0">assert </span><span class="s1">len(self.callbacks._func_cid_map) == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">len(self.callbacks.callbacks) == </span><span class="s3">1</span>

        <span class="s0">del </span><span class="s1">mini_me</span>

        <span class="s4"># check we now have no callbacks registered</span>
        <span class="s1">self.is_empty()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'pickle'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_callback_disconnect(self</span><span class="s0">, </span><span class="s1">pickle):</span>
        <span class="s4"># ensure we start with an empty registry</span>
        <span class="s1">self.is_empty()</span>

        <span class="s4"># create a class for testing</span>
        <span class="s1">mini_me = Test_callback_registry()</span>

        <span class="s4"># test that we can add a callback</span>
        <span class="s1">cid1 = self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>
        <span class="s0">assert </span><span class="s1">type(cid1) == int</span>
        <span class="s1">self.is_not_empty()</span>

        <span class="s1">self.disconnect(cid1)</span>

        <span class="s4"># check we now have no callbacks registered</span>
        <span class="s1">self.is_empty()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'pickle'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_callback_wrong_disconnect(self</span><span class="s0">, </span><span class="s1">pickle):</span>
        <span class="s4"># ensure we start with an empty registry</span>
        <span class="s1">self.is_empty()</span>

        <span class="s4"># create a class for testing</span>
        <span class="s1">mini_me = Test_callback_registry()</span>

        <span class="s4"># test that we can add a callback</span>
        <span class="s1">cid1 = self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>
        <span class="s0">assert </span><span class="s1">type(cid1) == int</span>
        <span class="s1">self.is_not_empty()</span>

        <span class="s1">self.disconnect(</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s4"># check we still have callbacks registered</span>
        <span class="s1">self.is_not_empty()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s2">'pickle'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_registration_on_non_empty_registry(self</span><span class="s0">, </span><span class="s1">pickle):</span>
        <span class="s4"># ensure we start with an empty registry</span>
        <span class="s1">self.is_empty()</span>

        <span class="s4"># setup the registry with a callback</span>
        <span class="s1">mini_me = Test_callback_registry()</span>
        <span class="s1">self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>

        <span class="s4"># Add another callback</span>
        <span class="s1">mini_me2 = Test_callback_registry()</span>
        <span class="s1">self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me2.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>

        <span class="s4"># Remove and add the second callback</span>
        <span class="s1">mini_me2 = Test_callback_registry()</span>
        <span class="s1">self.connect(self.signal</span><span class="s0">, </span><span class="s1">mini_me2.dummy</span><span class="s0">, </span><span class="s1">pickle)</span>

        <span class="s4"># We still have 2 references</span>
        <span class="s1">self.is_not_empty()</span>
        <span class="s0">assert </span><span class="s1">self.count() == </span><span class="s3">2</span>

        <span class="s4"># Removing the last 2 references</span>
        <span class="s1">mini_me = </span><span class="s0">None</span>
        <span class="s1">mini_me2 = </span><span class="s0">None</span>
        <span class="s1">self.is_empty()</span>

    <span class="s0">def </span><span class="s1">dummy(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_pickling(self):</span>
        <span class="s0">assert </span><span class="s1">hasattr(pickle.loads(pickle.dumps(cbook.CallbackRegistry()))</span><span class="s0">,</span>
                       <span class="s2">&quot;callbacks&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_callbackregistry_default_exception_handler(capsys</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
    <span class="s1">cb = cbook.CallbackRegistry()</span>
    <span class="s1">cb.connect(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">monkeypatch.setattr(</span>
        <span class="s1">cbook</span><span class="s0">, </span><span class="s2">&quot;_get_running_interactive_framework&quot;</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;argument mismatch&quot;</span><span class="s1">)</span>
    <span class="s1">outerr = capsys.readouterr()</span>
    <span class="s0">assert </span><span class="s1">outerr.out == outerr.err == </span><span class="s2">&quot;&quot;</span>

    <span class="s1">monkeypatch.setattr(</span>
        <span class="s1">cbook</span><span class="s0">, </span><span class="s2">&quot;_get_running_interactive_framework&quot;</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s2">&quot;not-none&quot;</span><span class="s1">)</span>
    <span class="s1">cb.process(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;argument mismatch&quot;</span><span class="s1">)  </span><span class="s4"># No error in that case.</span>
    <span class="s1">outerr = capsys.readouterr()</span>
    <span class="s0">assert </span><span class="s1">outerr.out == </span><span class="s2">&quot;&quot;</span>
    <span class="s0">assert </span><span class="s2">&quot;takes 0 positional arguments but 1 was given&quot; </span><span class="s0">in </span><span class="s1">outerr.err</span>


<span class="s0">def </span><span class="s1">raising_cb_reg(func):</span>
    <span class="s0">class </span><span class="s1">TestException(Exception):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">raise_runtime_error():</span>
        <span class="s0">raise </span><span class="s1">RuntimeError</span>

    <span class="s0">def </span><span class="s1">raise_value_error():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">def </span><span class="s1">transformer(excp):</span>
        <span class="s0">if </span><span class="s1">isinstance(excp</span><span class="s0">, </span><span class="s1">RuntimeError):</span>
            <span class="s0">raise </span><span class="s1">TestException</span>
        <span class="s0">raise </span><span class="s1">excp</span>

    <span class="s4"># old default</span>
    <span class="s1">cb_old = cbook.CallbackRegistry(exception_handler=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">cb_old.connect(</span><span class="s2">'foo'</span><span class="s0">, </span><span class="s1">raise_runtime_error)</span>

    <span class="s4"># filter</span>
    <span class="s1">cb_filt = cbook.CallbackRegistry(exception_handler=transformer)</span>
    <span class="s1">cb_filt.connect(</span><span class="s2">'foo'</span><span class="s0">, </span><span class="s1">raise_runtime_error)</span>

    <span class="s4"># filter</span>
    <span class="s1">cb_filt_pass = cbook.CallbackRegistry(exception_handler=transformer)</span>
    <span class="s1">cb_filt_pass.connect(</span><span class="s2">'foo'</span><span class="s0">, </span><span class="s1">raise_value_error)</span>

    <span class="s0">return </span><span class="s1">pytest.mark.parametrize(</span><span class="s2">'cb, excp'</span><span class="s0">,</span>
                                   <span class="s1">[[cb_old</span><span class="s0">, </span><span class="s1">RuntimeError]</span><span class="s0">,</span>
                                    <span class="s1">[cb_filt</span><span class="s0">, </span><span class="s1">TestException]</span><span class="s0">,</span>
                                    <span class="s1">[cb_filt_pass</span><span class="s0">, </span><span class="s1">ValueError]])(func)</span>


<span class="s1">@raising_cb_reg</span>
<span class="s0">def </span><span class="s1">test_callbackregistry_custom_exception_handler(monkeypatch</span><span class="s0">, </span><span class="s1">cb</span><span class="s0">, </span><span class="s1">excp):</span>
    <span class="s1">monkeypatch.setattr(</span>
        <span class="s1">cbook</span><span class="s0">, </span><span class="s2">&quot;_get_running_interactive_framework&quot;</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(excp):</span>
        <span class="s1">cb.process(</span><span class="s2">'foo'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_callbackregistry_signals():</span>
    <span class="s1">cr = cbook.CallbackRegistry(signals=[</span><span class="s2">&quot;foo&quot;</span><span class="s1">])</span>
    <span class="s1">results = []</span>
    <span class="s0">def </span><span class="s1">cb(x): results.append(x)</span>
    <span class="s1">cr.connect(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">cb)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">cr.connect(</span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s1">cb)</span>
    <span class="s1">cr.process(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">cr.process(</span><span class="s2">&quot;bar&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">results == [</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_callbackregistry_blocking():</span>
    <span class="s4"># Needs an exception handler for interactive testing environments</span>
    <span class="s4"># that would only print this out instead of raising the exception</span>
    <span class="s0">def </span><span class="s1">raise_handler(excp):</span>
        <span class="s0">raise </span><span class="s1">excp</span>
    <span class="s1">cb = cbook.CallbackRegistry(exception_handler=raise_handler)</span>
    <span class="s0">def </span><span class="s1">test_func1():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;1 should be blocked&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_func2():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;2 should be blocked&quot;</span><span class="s1">)</span>
    <span class="s1">cb.connect(</span><span class="s2">&quot;test1&quot;</span><span class="s0">, </span><span class="s1">test_func1)</span>
    <span class="s1">cb.connect(</span><span class="s2">&quot;test2&quot;</span><span class="s0">, </span><span class="s1">test_func2)</span>

    <span class="s4"># block all of the callbacks to make sure they aren't processed</span>
    <span class="s0">with </span><span class="s1">cb.blocked():</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;test1&quot;</span><span class="s1">)</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;test2&quot;</span><span class="s1">)</span>

    <span class="s4"># block individual callbacks to make sure the other is still processed</span>
    <span class="s0">with </span><span class="s1">cb.blocked(signal=</span><span class="s2">&quot;test1&quot;</span><span class="s1">):</span>
        <span class="s4"># Blocked</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;test1&quot;</span><span class="s1">)</span>
        <span class="s4"># Should raise</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;2 should be blocked&quot;</span><span class="s1">):</span>
            <span class="s1">cb.process(</span><span class="s2">&quot;test2&quot;</span><span class="s1">)</span>

    <span class="s4"># Make sure the original callback functions are there after blocking</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;1 should be blocked&quot;</span><span class="s1">):</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;test1&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;2 should be blocked&quot;</span><span class="s1">):</span>
        <span class="s1">cb.process(</span><span class="s2">&quot;test2&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'line, result'</span><span class="s0">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s2">'a : no_comment'</span><span class="s0">, </span><span class="s2">'a : no_comment'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : &quot;quoted str&quot;'</span><span class="s0">, </span><span class="s2">'a : &quot;quoted str&quot;'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : &quot;quoted str&quot; # comment'</span><span class="s0">, </span><span class="s2">'a : &quot;quoted str&quot;'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : &quot;#000000&quot;'</span><span class="s0">, </span><span class="s2">'a : &quot;#000000&quot;'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : &quot;#000000&quot; # comment'</span><span class="s0">, </span><span class="s2">'a : &quot;#000000&quot;'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : [&quot;#000000&quot;, &quot;#FFFFFF&quot;]'</span><span class="s0">, </span><span class="s2">'a : [&quot;#000000&quot;, &quot;#FFFFFF&quot;]'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : [&quot;#000000&quot;, &quot;#FFFFFF&quot;] # comment'</span><span class="s0">, </span><span class="s2">'a : [&quot;#000000&quot;, &quot;#FFFFFF&quot;]'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'a : val  # a comment &quot;with quotes&quot;'</span><span class="s0">, </span><span class="s2">'a : val'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'# only comment &quot;with quotes&quot; xx'</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_strip_comment(line</span><span class="s0">, </span><span class="s1">result):</span>
    <span class="s5">&quot;&quot;&quot;Strip everything from the first unquoted #.&quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">cbook._strip_comment(line) == result</span>


<span class="s0">def </span><span class="s1">test_strip_comment_invalid():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Missing closing quote&quot;</span><span class="s1">):</span>
        <span class="s1">cbook._strip_comment(</span><span class="s2">'grid.color: &quot;aa'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_sanitize_sequence():</span>
    <span class="s1">d = {</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">'c'</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s1">k = [</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s1">]</span>
    <span class="s1">v = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">i = [(</span><span class="s2">'a'</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'b'</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'c'</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)]</span>
    <span class="s0">assert </span><span class="s1">k == sorted(cbook.sanitize_sequence(d.keys()))</span>
    <span class="s0">assert </span><span class="s1">v == sorted(cbook.sanitize_sequence(d.values()))</span>
    <span class="s0">assert </span><span class="s1">i == sorted(cbook.sanitize_sequence(d.items()))</span>
    <span class="s0">assert </span><span class="s1">i == cbook.sanitize_sequence(i)</span>
    <span class="s0">assert </span><span class="s1">k == cbook.sanitize_sequence(k)</span>


<span class="s1">fail_mapping = (</span>
    <span class="s1">({</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'alias_mapping'</span><span class="s1">: {</span><span class="s2">'a'</span><span class="s1">: [</span><span class="s2">'b'</span><span class="s1">]}})</span><span class="s0">,</span>
    <span class="s1">({</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'alias_mapping'</span><span class="s1">: {</span><span class="s2">'a'</span><span class="s1">: [</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">]}})</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">pass_mapping = (</span>
    <span class="s1">(</span><span class="s0">None, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">({</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">,</span>
    <span class="s1">({</span><span class="s2">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'a'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">'alias_mapping'</span><span class="s1">: {</span><span class="s2">'a'</span><span class="s1">: [</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s1">]}})</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'inp, kwargs_to_norm'</span><span class="s0">, </span><span class="s1">fail_mapping)</span>
<span class="s0">def </span><span class="s1">test_normalize_kwargs_fail(inp</span><span class="s0">, </span><span class="s1">kwargs_to_norm):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError)</span><span class="s0">, </span><span class="s1">\</span>
         <span class="s1">_api.suppress_matplotlib_deprecation_warning():</span>
        <span class="s1">cbook.normalize_kwargs(inp</span><span class="s0">, </span><span class="s1">**kwargs_to_norm)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'inp, expected, kwargs_to_norm'</span><span class="s0">,</span>
                         <span class="s1">pass_mapping)</span>
<span class="s0">def </span><span class="s1">test_normalize_kwargs_pass(inp</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">kwargs_to_norm):</span>
    <span class="s0">with </span><span class="s1">_api.suppress_matplotlib_deprecation_warning():</span>
        <span class="s4"># No other warning should be emitted.</span>
        <span class="s0">assert </span><span class="s1">expected == cbook.normalize_kwargs(inp</span><span class="s0">, </span><span class="s1">**kwargs_to_norm)</span>


<span class="s0">def </span><span class="s1">test_warn_external_frame_embedded_python():</span>
    <span class="s0">with </span><span class="s1">patch.object(cbook</span><span class="s0">, </span><span class="s2">&quot;sys&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">mock_sys:</span>
        <span class="s1">mock_sys._getframe = Mock(return_value=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">r&quot;\Adummy\Z&quot;</span><span class="s1">):</span>
            <span class="s1">_api.warn_external(</span><span class="s2">&quot;dummy&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_prestep():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y1 = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y2 = np.arange(</span><span class="s3">4</span><span class="s1">)[::-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s</span><span class="s0">, </span><span class="s1">y2s = cbook.pts_to_prestep(x</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2)</span>

    <span class="s1">x_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y1_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y2_target = np.asarray([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>

    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>
    <span class="s1">assert_array_equal(y2_target</span><span class="s0">, </span><span class="s1">y2s)</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s = cbook.pts_to_prestep(x</span><span class="s0">, </span><span class="s1">y1)</span>
    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>


<span class="s0">def </span><span class="s1">test_to_prestep_empty():</span>
    <span class="s1">steps = cbook.pts_to_prestep([]</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">assert </span><span class="s1">steps.shape == (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_poststep():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y1 = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y2 = np.arange(</span><span class="s3">4</span><span class="s1">)[::-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s</span><span class="s0">, </span><span class="s1">y2s = cbook.pts_to_poststep(x</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2)</span>

    <span class="s1">x_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y1_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y2_target = np.asarray([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>

    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>
    <span class="s1">assert_array_equal(y2_target</span><span class="s0">, </span><span class="s1">y2s)</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s = cbook.pts_to_poststep(x</span><span class="s0">, </span><span class="s1">y1)</span>
    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>


<span class="s0">def </span><span class="s1">test_to_poststep_empty():</span>
    <span class="s1">steps = cbook.pts_to_poststep([]</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">assert </span><span class="s1">steps.shape == (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_midstep():</span>
    <span class="s1">x = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y1 = np.arange(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">y2 = np.arange(</span><span class="s3">4</span><span class="s1">)[::-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s</span><span class="s0">, </span><span class="s1">y2s = cbook.pts_to_midstep(x</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2)</span>

    <span class="s1">x_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">.5</span><span class="s0">, </span><span class="s3">.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y1_target = np.asarray([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">y2_target = np.asarray([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=float)</span>

    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>
    <span class="s1">assert_array_equal(y2_target</span><span class="s0">, </span><span class="s1">y2s)</span>

    <span class="s1">xs</span><span class="s0">, </span><span class="s1">y1s = cbook.pts_to_midstep(x</span><span class="s0">, </span><span class="s1">y1)</span>
    <span class="s1">assert_array_equal(x_target</span><span class="s0">, </span><span class="s1">xs)</span>
    <span class="s1">assert_array_equal(y1_target</span><span class="s0">, </span><span class="s1">y1s)</span>


<span class="s0">def </span><span class="s1">test_to_midstep_empty():</span>
    <span class="s1">steps = cbook.pts_to_midstep([]</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">assert </span><span class="s1">steps.shape == (</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;args&quot;</span><span class="s0">,</span>
    <span class="s1">[(np.arange(</span><span class="s3">12</span><span class="s1">).reshape(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'a'</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(np.arange(</span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'a'</span><span class="s1">)</span><span class="s0">,</span>
     <span class="s1">(np.arange(</span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s3">3</span><span class="s1">))])</span>
<span class="s0">def </span><span class="s1">test_step_fails(args):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">cbook.pts_to_prestep(*args)</span>


<span class="s0">def </span><span class="s1">test_grouper():</span>
    <span class="s0">class </span><span class="s1">Dummy:</span>
        <span class="s0">pass</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">e = objs = [Dummy() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)]</span>
    <span class="s1">g = cbook.Grouper()</span>
    <span class="s1">g.join(*objs)</span>
    <span class="s0">assert </span><span class="s1">set(list(g)[</span><span class="s3">0</span><span class="s1">]) == set(objs)</span>
    <span class="s0">assert </span><span class="s1">set(g.get_siblings(a)) == set(objs)</span>

    <span class="s0">for </span><span class="s1">other </span><span class="s0">in </span><span class="s1">objs[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s0">assert </span><span class="s1">g.joined(a</span><span class="s0">, </span><span class="s1">other)</span>

    <span class="s1">g.remove(a)</span>
    <span class="s0">for </span><span class="s1">other </span><span class="s0">in </span><span class="s1">objs[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s0">assert not </span><span class="s1">g.joined(a</span><span class="s0">, </span><span class="s1">other)</span>

    <span class="s0">for </span><span class="s1">A</span><span class="s0">, </span><span class="s1">B </span><span class="s0">in </span><span class="s1">itertools.product(objs[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">objs[</span><span class="s3">1</span><span class="s1">:]):</span>
        <span class="s0">assert </span><span class="s1">g.joined(A</span><span class="s0">, </span><span class="s1">B)</span>


<span class="s0">def </span><span class="s1">test_grouper_private():</span>
    <span class="s0">class </span><span class="s1">Dummy:</span>
        <span class="s0">pass</span>
    <span class="s1">objs = [Dummy() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)]</span>
    <span class="s1">g = cbook.Grouper()</span>
    <span class="s1">g.join(*objs)</span>
    <span class="s4"># reach in and touch the internals !</span>
    <span class="s1">mapping = g._mapping</span>

    <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">objs:</span>
        <span class="s0">assert </span><span class="s1">ref(o) </span><span class="s0">in </span><span class="s1">mapping</span>

    <span class="s1">base_set = mapping[ref(objs[</span><span class="s3">0</span><span class="s1">])]</span>
    <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">objs[</span><span class="s3">1</span><span class="s1">:]:</span>
        <span class="s0">assert </span><span class="s1">mapping[ref(o)] </span><span class="s0">is </span><span class="s1">base_set</span>


<span class="s0">def </span><span class="s1">test_flatiter():</span>
    <span class="s1">x = np.arange(</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">it = x.flat</span>
    <span class="s0">assert </span><span class="s3">0 </span><span class="s1">== next(it)</span>
    <span class="s0">assert </span><span class="s3">1 </span><span class="s1">== next(it)</span>
    <span class="s1">ret = cbook._safe_first_finite(it)</span>
    <span class="s0">assert </span><span class="s1">ret == </span><span class="s3">0</span>

    <span class="s0">assert </span><span class="s3">0 </span><span class="s1">== next(it)</span>
    <span class="s0">assert </span><span class="s3">1 </span><span class="s1">== next(it)</span>


<span class="s0">def </span><span class="s1">test_reshape2d():</span>

    <span class="s0">class </span><span class="s1">Dummy:</span>
        <span class="s0">pass</span>

    <span class="s1">xnew = cbook._reshape_2D([]</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.shape(xnew) == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">x = [Dummy() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)]</span>

    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.shape(xnew) == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

    <span class="s1">x = np.arange(</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.shape(xnew) == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

    <span class="s1">x = [[Dummy() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">)]</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.shape(xnew) == (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>

    <span class="s4"># this is strange behaviour, but...</span>
    <span class="s1">x = np.random.rand(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.shape(xnew) == (</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

    <span class="s4"># Test a list of lists which are all of length 1</span>
    <span class="s1">x = [[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">]]</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew</span><span class="s0">, </span><span class="s1">list)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">0</span><span class="s1">].shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">1</span><span class="s1">].shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">2</span><span class="s1">].shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s4"># Test a list of zero-dimensional arrays</span>
    <span class="s1">x = [np.array(</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s3">2</span><span class="s1">)]</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew</span><span class="s0">, </span><span class="s1">list)</span>
    <span class="s0">assert </span><span class="s1">len(xnew) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">0</span><span class="s1">].shape == (</span><span class="s3">3</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s4"># Now test with a list of lists with different lengths, which means the</span>
    <span class="s4"># array will internally be converted to a 1D object array of lists</span>
    <span class="s1">x = [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]]</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew</span><span class="s0">, </span><span class="s1">list)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">0</span><span class="s1">].shape == (</span><span class="s3">3</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">1</span><span class="s1">].shape == (</span><span class="s3">2</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">xnew[</span><span class="s3">2</span><span class="s1">].shape == (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s4"># We now need to make sure that this works correctly for Numpy subclasses</span>
    <span class="s4"># where iterating over items can return subclasses too, which may be</span>
    <span class="s4"># iterable even if they are scalars. To emulate this, we make a Numpy</span>
    <span class="s4"># array subclass that returns Numpy 'scalars' when iterating or accessing</span>
    <span class="s4"># values, and these are technically iterable if checking for example</span>
    <span class="s4"># isinstance(x, collections.abc.Iterable).</span>

    <span class="s0">class </span><span class="s1">ArraySubclass(np.ndarray):</span>

        <span class="s0">def </span><span class="s1">__iter__(self):</span>
            <span class="s0">for </span><span class="s1">value </span><span class="s0">in </span><span class="s1">super().__iter__():</span>
                <span class="s0">yield </span><span class="s1">np.array(value)</span>

        <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
            <span class="s0">return </span><span class="s1">np.array(super().__getitem__(item))</span>

    <span class="s1">v = np.arange(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">x = ArraySubclass((</span><span class="s3">10</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float</span><span class="s0">, </span><span class="s1">buffer=v.data)</span>

    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>

    <span class="s4"># We check here that the array wasn't split up into many individual</span>
    <span class="s4"># ArraySubclass, which is what used to happen due to a bug in _reshape_2D</span>
    <span class="s0">assert </span><span class="s1">len(xnew) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ArraySubclass)</span>

    <span class="s4"># check list of strings:</span>
    <span class="s1">x = [</span><span class="s2">'a'</span><span class="s0">, </span><span class="s2">'b'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'c'</span><span class="s0">, </span><span class="s2">'dd'</span><span class="s0">, </span><span class="s2">'e'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s0">, </span><span class="s2">'ff'</span><span class="s0">, </span><span class="s2">'f'</span><span class="s1">]</span>
    <span class="s1">xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(xnew[</span><span class="s3">0</span><span class="s1">]) == len(x)</span>
    <span class="s0">assert </span><span class="s1">isinstance(xnew[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray)</span>


<span class="s0">def </span><span class="s1">test_reshape2d_pandas(pd):</span>
    <span class="s4"># separate to allow the rest of the tests to run if no pandas...</span>
    <span class="s1">X = np.arange(</span><span class="s3">30</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">x = pd.DataFrame(X</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">Xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s4"># Need to check each row because _reshape_2D returns a list of arrays:</span>
    <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">xnew </span><span class="s0">in </span><span class="s1">zip(X.T</span><span class="s0">, </span><span class="s1">Xnew):</span>
        <span class="s1">np.testing.assert_array_equal(x</span><span class="s0">, </span><span class="s1">xnew)</span>


<span class="s0">def </span><span class="s1">test_reshape2d_xarray(xr):</span>
    <span class="s4"># separate to allow the rest of the tests to run if no xarray...</span>
    <span class="s1">X = np.arange(</span><span class="s3">30</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">x = xr.DataArray(X</span><span class="s0">, </span><span class="s1">dims=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
    <span class="s1">Xnew = cbook._reshape_2D(x</span><span class="s0">, </span><span class="s2">'x'</span><span class="s1">)</span>
    <span class="s4"># Need to check each row because _reshape_2D returns a list of arrays:</span>
    <span class="s0">for </span><span class="s1">x</span><span class="s0">, </span><span class="s1">xnew </span><span class="s0">in </span><span class="s1">zip(X.T</span><span class="s0">, </span><span class="s1">Xnew):</span>
        <span class="s1">np.testing.assert_array_equal(x</span><span class="s0">, </span><span class="s1">xnew)</span>


<span class="s0">def </span><span class="s1">test_index_of_pandas(pd):</span>
    <span class="s4"># separate to allow the rest of the tests to run if no pandas...</span>
    <span class="s1">X = np.arange(</span><span class="s3">30</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">x = pd.DataFrame(X</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">Idx</span><span class="s0">, </span><span class="s1">Xnew = cbook.index_of(x)</span>
    <span class="s1">np.testing.assert_array_equal(X</span><span class="s0">, </span><span class="s1">Xnew)</span>
    <span class="s1">IdxRef = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_array_equal(Idx</span><span class="s0">, </span><span class="s1">IdxRef)</span>


<span class="s0">def </span><span class="s1">test_index_of_xarray(xr):</span>
    <span class="s4"># separate to allow the rest of the tests to run if no xarray...</span>
    <span class="s1">X = np.arange(</span><span class="s3">30</span><span class="s1">).reshape(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">x = xr.DataArray(X</span><span class="s0">, </span><span class="s1">dims=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">])</span>
    <span class="s1">Idx</span><span class="s0">, </span><span class="s1">Xnew = cbook.index_of(x)</span>
    <span class="s1">np.testing.assert_array_equal(X</span><span class="s0">, </span><span class="s1">Xnew)</span>
    <span class="s1">IdxRef = np.arange(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_array_equal(Idx</span><span class="s0">, </span><span class="s1">IdxRef)</span>


<span class="s0">def </span><span class="s1">test_contiguous_regions():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span>
    <span class="s4"># Starts and ends with True</span>
    <span class="s1">mask = [</span><span class="s0">True</span><span class="s1">]*a + [</span><span class="s0">False</span><span class="s1">]*b + [</span><span class="s0">True</span><span class="s1">]*c</span>
    <span class="s1">expected = [(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">(a+b</span><span class="s0">, </span><span class="s1">a+b+c)]</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions(mask) == expected</span>
    <span class="s1">d</span><span class="s0">, </span><span class="s1">e = </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span>
    <span class="s4"># Starts with True ends with False</span>
    <span class="s1">mask = mask + [</span><span class="s0">False</span><span class="s1">]*e</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions(mask) == expected</span>
    <span class="s4"># Starts with False ends with True</span>
    <span class="s1">mask = [</span><span class="s0">False</span><span class="s1">]*d + mask[:-e]</span>
    <span class="s1">expected = [(d</span><span class="s0">, </span><span class="s1">d+a)</span><span class="s0">, </span><span class="s1">(d+a+b</span><span class="s0">, </span><span class="s1">d+a+b+c)]</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions(mask) == expected</span>
    <span class="s4"># Starts and ends with False</span>
    <span class="s1">mask = mask + [</span><span class="s0">False</span><span class="s1">]*e</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions(mask) == expected</span>
    <span class="s4"># No True in mask</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions([</span><span class="s0">False</span><span class="s1">]*</span><span class="s3">5</span><span class="s1">) == []</span>
    <span class="s4"># Empty mask</span>
    <span class="s0">assert </span><span class="s1">cbook.contiguous_regions([]) == []</span>


<span class="s0">def </span><span class="s1">test_safe_first_element_pandas_series(pd):</span>
    <span class="s4"># deliberately create a pandas series with index not starting from 0</span>
    <span class="s1">s = pd.Series(range(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=range(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">15</span><span class="s1">))</span>
    <span class="s1">actual = cbook._safe_first_finite(s)</span>
    <span class="s0">assert </span><span class="s1">actual == </span><span class="s3">0</span>


<span class="s0">def </span><span class="s1">test_warn_external(recwarn):</span>
    <span class="s1">_api.warn_external(</span><span class="s2">&quot;oops&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(recwarn) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">recwarn[</span><span class="s3">0</span><span class="s1">].filename == __file__</span>


<span class="s0">def </span><span class="s1">test_array_patch_perimeters():</span>
    <span class="s4"># This compares the old implementation as a reference for the</span>
    <span class="s4"># vectorized one.</span>
    <span class="s0">def </span><span class="s1">check(x</span><span class="s0">, </span><span class="s1">rstride</span><span class="s0">, </span><span class="s1">cstride):</span>
        <span class="s1">rows</span><span class="s0">, </span><span class="s1">cols = x.shape</span>
        <span class="s1">row_inds = [*range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">rows-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">rstride)</span><span class="s0">, </span><span class="s1">rows-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">col_inds = [*range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cols-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">cstride)</span><span class="s0">, </span><span class="s1">cols-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">polys = []</span>
        <span class="s0">for </span><span class="s1">rs</span><span class="s0">, </span><span class="s1">rs_next </span><span class="s0">in </span><span class="s1">zip(row_inds[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">row_inds[</span><span class="s3">1</span><span class="s1">:]):</span>
            <span class="s0">for </span><span class="s1">cs</span><span class="s0">, </span><span class="s1">cs_next </span><span class="s0">in </span><span class="s1">zip(col_inds[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">col_inds[</span><span class="s3">1</span><span class="s1">:]):</span>
                <span class="s4"># +1 ensures we share edges between polygons</span>
                <span class="s1">ps = cbook._array_perimeter(x[rs:rs_next+</span><span class="s3">1</span><span class="s0">, </span><span class="s1">cs:cs_next+</span><span class="s3">1</span><span class="s1">]).T</span>
                <span class="s1">polys.append(ps)</span>
        <span class="s1">polys = np.asarray(polys)</span>
        <span class="s0">assert </span><span class="s1">np.array_equal(polys</span><span class="s0">,</span>
                              <span class="s1">cbook._array_patch_perimeters(</span>
                                  <span class="s1">x</span><span class="s0">, </span><span class="s1">rstride=rstride</span><span class="s0">, </span><span class="s1">cstride=cstride))</span>

    <span class="s0">def </span><span class="s1">divisors(n):</span>
        <span class="s0">return </span><span class="s1">[i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n + </span><span class="s3">1</span><span class="s1">) </span><span class="s0">if </span><span class="s1">n % i == </span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">for </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols </span><span class="s0">in </span><span class="s1">[(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">7</span><span class="s0">, </span><span class="s3">14</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">13</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)]:</span>
        <span class="s1">x = np.arange(rows * cols).reshape(rows</span><span class="s0">, </span><span class="s1">cols)</span>
        <span class="s0">for </span><span class="s1">rstride</span><span class="s0">, </span><span class="s1">cstride </span><span class="s0">in </span><span class="s1">itertools.product(divisors(rows - </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
                                                  <span class="s1">divisors(cols - </span><span class="s3">1</span><span class="s1">)):</span>
            <span class="s1">check(x</span><span class="s0">, </span><span class="s1">rstride=rstride</span><span class="s0">, </span><span class="s1">cstride=cstride)</span>


<span class="s0">def </span><span class="s1">test_setattr_cm():</span>
    <span class="s0">class </span><span class="s1">A:</span>
        <span class="s1">cls_level = object()</span>
        <span class="s1">override = object()</span>

        <span class="s0">def </span><span class="s1">__init__(self):</span>
            <span class="s1">self.aardvark = </span><span class="s2">'aardvark'</span>
            <span class="s1">self.override = </span><span class="s2">'override'</span>
            <span class="s1">self._p = </span><span class="s2">'p'</span>

        <span class="s0">def </span><span class="s1">meth(self):</span>
            <span class="s1">...</span>

        <span class="s1">@classmethod</span>
        <span class="s0">def </span><span class="s1">classy(cls):</span>
            <span class="s1">...</span>

        <span class="s1">@staticmethod</span>
        <span class="s0">def </span><span class="s1">static():</span>
            <span class="s1">...</span>

        <span class="s1">@property</span>
        <span class="s0">def </span><span class="s1">prop(self):</span>
            <span class="s0">return </span><span class="s1">self._p</span>

        <span class="s1">@prop.setter</span>
        <span class="s0">def </span><span class="s1">prop(self</span><span class="s0">, </span><span class="s1">val):</span>
            <span class="s1">self._p = val</span>

    <span class="s0">class </span><span class="s1">B(A):</span>
        <span class="s1">...</span>

    <span class="s1">other = A()</span>

    <span class="s0">def </span><span class="s1">verify_pre_post_state(obj):</span>
        <span class="s4"># When you access a Python method the function is bound</span>
        <span class="s4"># to the object at access time so you get a new instance</span>
        <span class="s4"># of MethodType every time.</span>
        <span class="s4">#</span>
        <span class="s4"># https://docs.python.org/3/howto/descriptor.html#functions-and-methods</span>
        <span class="s0">assert </span><span class="s1">obj.meth </span><span class="s0">is not </span><span class="s1">obj.meth</span>
        <span class="s4"># normal attribute should give you back the same instance every time</span>
        <span class="s0">assert </span><span class="s1">obj.aardvark </span><span class="s0">is </span><span class="s1">obj.aardvark</span>
        <span class="s0">assert </span><span class="s1">a.aardvark == </span><span class="s2">'aardvark'</span>
        <span class="s4"># and our property happens to give the same instance every time</span>
        <span class="s0">assert </span><span class="s1">obj.prop </span><span class="s0">is </span><span class="s1">obj.prop</span>
        <span class="s0">assert </span><span class="s1">obj.cls_level </span><span class="s0">is </span><span class="s1">A.cls_level</span>
        <span class="s0">assert </span><span class="s1">obj.override == </span><span class="s2">'override'</span>
        <span class="s0">assert not </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s2">'extra'</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">obj.prop == </span><span class="s2">'p'</span>
        <span class="s0">assert </span><span class="s1">obj.monkey == other.meth</span>
        <span class="s0">assert </span><span class="s1">obj.cls_level </span><span class="s0">is </span><span class="s1">A.cls_level</span>
        <span class="s0">assert </span><span class="s2">'cls_level' </span><span class="s0">not in </span><span class="s1">obj.__dict__</span>
        <span class="s0">assert </span><span class="s2">'classy' </span><span class="s0">not in </span><span class="s1">obj.__dict__</span>
        <span class="s0">assert </span><span class="s2">'static' </span><span class="s0">not in </span><span class="s1">obj.__dict__</span>

    <span class="s1">a = B()</span>

    <span class="s1">a.monkey = other.meth</span>
    <span class="s1">verify_pre_post_state(a)</span>
    <span class="s0">with </span><span class="s1">cbook._setattr_cm(</span>
            <span class="s1">a</span><span class="s0">, </span><span class="s1">prop=</span><span class="s2">'squirrel'</span><span class="s0">,</span>
            <span class="s1">aardvark=</span><span class="s2">'moose'</span><span class="s0">, </span><span class="s1">meth=</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None,</span>
            <span class="s1">override=</span><span class="s2">'boo'</span><span class="s0">, </span><span class="s1">extra=</span><span class="s2">'extra'</span><span class="s0">,</span>
            <span class="s1">monkey=</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None, </span><span class="s1">cls_level=</span><span class="s2">'bob'</span><span class="s0">,</span>
            <span class="s1">classy=</span><span class="s2">'classy'</span><span class="s0">, </span><span class="s1">static=</span><span class="s2">'static'</span><span class="s1">):</span>
        <span class="s4"># because we have set a lambda, it is normal attribute access</span>
        <span class="s4"># and the same every time</span>
        <span class="s0">assert </span><span class="s1">a.meth </span><span class="s0">is </span><span class="s1">a.meth</span>
        <span class="s0">assert </span><span class="s1">a.aardvark </span><span class="s0">is </span><span class="s1">a.aardvark</span>
        <span class="s0">assert </span><span class="s1">a.aardvark == </span><span class="s2">'moose'</span>
        <span class="s0">assert </span><span class="s1">a.override == </span><span class="s2">'boo'</span>
        <span class="s0">assert </span><span class="s1">a.extra == </span><span class="s2">'extra'</span>
        <span class="s0">assert </span><span class="s1">a.prop == </span><span class="s2">'squirrel'</span>
        <span class="s0">assert </span><span class="s1">a.monkey != other.meth</span>
        <span class="s0">assert </span><span class="s1">a.cls_level == </span><span class="s2">'bob'</span>
        <span class="s0">assert </span><span class="s1">a.classy == </span><span class="s2">'classy'</span>
        <span class="s0">assert </span><span class="s1">a.static == </span><span class="s2">'static'</span>

    <span class="s1">verify_pre_post_state(a)</span>


<span class="s0">def </span><span class="s1">test_format_approx():</span>
    <span class="s1">f = cbook._format_approx</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) == </span><span class="s2">'0'</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) == </span><span class="s2">'0'</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">) == </span><span class="s2">'0'</span>
    <span class="s0">assert </span><span class="s1">f(-</span><span class="s3">0.0123</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) == </span><span class="s2">'-0'</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">1e-7</span><span class="s0">, </span><span class="s3">5</span><span class="s1">) == </span><span class="s2">'0'</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">0.0012345600001</span><span class="s0">, </span><span class="s3">5</span><span class="s1">) == </span><span class="s2">'0.00123'</span>
    <span class="s0">assert </span><span class="s1">f(-</span><span class="s3">0.0012345600001</span><span class="s0">, </span><span class="s3">5</span><span class="s1">) == </span><span class="s2">'-0.00123'</span>
    <span class="s0">assert </span><span class="s1">f(</span><span class="s3">0.0012345600001</span><span class="s0">, </span><span class="s3">8</span><span class="s1">) == f(</span><span class="s3">0.0012345600001</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) == </span><span class="s2">'0.00123456'</span>


<span class="s0">def </span><span class="s1">test_safe_first_element_with_none():</span>
    <span class="s1">datetime_lst = [date.today() + timedelta(days=i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">)]</span>
    <span class="s1">datetime_lst[</span><span class="s3">0</span><span class="s1">] = </span><span class="s0">None</span>
    <span class="s1">actual = cbook._safe_first_finite(datetime_lst)</span>
    <span class="s0">assert </span><span class="s1">actual </span><span class="s0">is not None and </span><span class="s1">actual == datetime_lst[</span><span class="s3">1</span><span class="s1">]</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">'fmt, value, result'</span><span class="s0">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s2">'%.2f m'</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s2">'0.20 m'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'{:.2f} m'</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s2">'0.20 m'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'{} m'</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s2">'0.2 m'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'const'</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s2">'const'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'%d or {}'</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s2">'0 or {}'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'{{{:,.0f}}}'</span><span class="s0">, </span><span class="s3">2e5</span><span class="s0">, </span><span class="s2">'{200,000}'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'{:.2%}'</span><span class="s0">, </span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s0">, </span><span class="s2">'66.67%'</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s2">'$%g'</span><span class="s0">, </span><span class="s3">2.54</span><span class="s0">, </span><span class="s2">'$2.54'</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_auto_format_str(fmt</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">result):</span>
    <span class="s5">&quot;&quot;&quot;Apply *value* to the format string *fmt*.&quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">cbook._auto_format_str(fmt</span><span class="s0">, </span><span class="s1">value) == result</span>
    <span class="s0">assert </span><span class="s1">cbook._auto_format_str(fmt</span><span class="s0">, </span><span class="s1">np.float64(value)) == result</span>
</pre>
</body>
</html>