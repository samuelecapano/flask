<html>
<head>
<title>python_message.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6a8759;}
.s4 { color: #cc7832;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
python_message.py</font>
</center></td></tr></table>
<pre><span class="s0"># Protocol Buffers - Google's data interchange format</span>
<span class="s0"># Copyright 2008 Google Inc.  All rights reserved.</span>
<span class="s0"># https://developers.google.com/protocol-buffers/</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0">#     * Redistributions of source code must retain the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer.</span>
<span class="s0">#     * Redistributions in binary form must reproduce the above</span>
<span class="s0"># copyright notice, this list of conditions and the following disclaimer</span>
<span class="s0"># in the documentation and/or other materials provided with the</span>
<span class="s0"># distribution.</span>
<span class="s0">#     * Neither the name of Google Inc. nor the names of its</span>
<span class="s0"># contributors may be used to endorse or promote products derived from</span>
<span class="s0"># this software without specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="s0"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="s0"># A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="s0"># OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="s0"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="s0"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="s0"># DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="s0"># THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="s0"># (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="s0"># OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="s0"># This code is meant to work on Python 2.4 and above only.</span>
<span class="s0">#</span>
<span class="s0"># TODO(robinson): Helpers for verbose, common checks like seeing if a</span>
<span class="s0"># descriptor's cpp_type is CPPTYPE_MESSAGE.</span>

<span class="s2">&quot;&quot;&quot;Contains a metaclass and helper functions used to create 
protocol message classes from Descriptor objects at runtime. 
 
Recall that a metaclass is the &quot;type&quot; of a class. 
(A class is to a metaclass what an instance is to a class.) 
 
In this case, we use the GeneratedProtocolMessageType metaclass 
to inject all the useful functionality into the classes 
output by the protocol compiler at compile-time. 
 
The upshot of all this is that the real implementation 
details for ALL pure-Python protocol buffers are *here in 
this file*. 
&quot;&quot;&quot;</span>

<span class="s1">__author__ = </span><span class="s3">'robinson@google.com (Will Robinson)'</span>

<span class="s4">from </span><span class="s1">io </span><span class="s4">import </span><span class="s1">BytesIO</span>
<span class="s4">import </span><span class="s1">struct</span>
<span class="s4">import </span><span class="s1">sys</span>
<span class="s4">import </span><span class="s1">weakref</span>

<span class="s0"># We use &quot;as&quot; to avoid name collisions with variables.</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">api_implementation</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">containers</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">decoder</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">encoder</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">enum_type_wrapper</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">extension_dict</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">message_listener </span><span class="s4">as </span><span class="s1">message_listener_mod</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">type_checkers</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">well_known_types</span>
<span class="s4">from </span><span class="s1">google.protobuf.internal </span><span class="s4">import </span><span class="s1">wire_format</span>
<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">descriptor </span><span class="s4">as </span><span class="s1">descriptor_mod</span>
<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">message </span><span class="s4">as </span><span class="s1">message_mod</span>
<span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">text_format</span>

<span class="s1">_FieldDescriptor = descriptor_mod.FieldDescriptor</span>
<span class="s1">_AnyFullTypeName = </span><span class="s3">'google.protobuf.Any'</span>
<span class="s1">_ExtensionDict = extension_dict._ExtensionDict</span>

<span class="s4">class </span><span class="s1">GeneratedProtocolMessageType(type):</span>

  <span class="s2">&quot;&quot;&quot;Metaclass for protocol message classes created at runtime from Descriptors. 
 
  We add implementations for all methods described in the Message class.  We 
  also create properties to allow getting/setting all fields in the protocol 
  message.  Finally, we create slots to prevent users from accidentally 
  &quot;setting&quot; nonexistent fields in the protocol message, which then wouldn't get 
  serialized / deserialized properly. 
 
  The protocol compiler currently uses this metaclass to create protocol 
  message classes at runtime.  Clients can also manually create their own 
  classes at runtime, as in this example: 
 
  mydescriptor = Descriptor(.....) 
  factory = symbol_database.Default() 
  factory.pool.AddDescriptor(mydescriptor) 
  MyProtoClass = factory.GetPrototype(mydescriptor) 
  myproto_instance = MyProtoClass() 
  myproto.foo_field = 23 
  ... 
  &quot;&quot;&quot;</span>

  <span class="s0"># Must be consistent with the protocol-compiler code in</span>
  <span class="s0"># proto2/compiler/internal/generator.*.</span>
  <span class="s1">_DESCRIPTOR_KEY = </span><span class="s3">'DESCRIPTOR'</span>

  <span class="s4">def </span><span class="s1">__new__(cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">bases</span><span class="s4">, </span><span class="s1">dictionary):</span>
    <span class="s2">&quot;&quot;&quot;Custom allocation for runtime-generated class types. 
 
    We override __new__ because this is apparently the only place 
    where we can meaningfully set __slots__ on the class we're creating(?). 
    (The interplay between metaclasses and slots is not very well-documented). 
 
    Args: 
      name: Name of the class (ignored, but required by the 
        metaclass protocol). 
      bases: Base classes of the class we're constructing. 
        (Should be message.Message).  We ignore this field, but 
        it's required by the metaclass protocol 
      dictionary: The class dictionary of the class we're 
        constructing.  dictionary[_DESCRIPTOR_KEY] must contain 
        a Descriptor object describing this protocol message 
        type. 
 
    Returns: 
      Newly-allocated class. 
 
    Raises: 
      RuntimeError: Generated code only work with python cpp extension. 
    &quot;&quot;&quot;</span>
    <span class="s1">descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span>

    <span class="s4">if </span><span class="s1">isinstance(descriptor</span><span class="s4">, </span><span class="s1">str):</span>
      <span class="s4">raise </span><span class="s1">RuntimeError(</span><span class="s3">'The generated code only work with python cpp '</span>
                         <span class="s3">'extension, but it is using pure python runtime.'</span><span class="s1">)</span>

    <span class="s0"># If a concrete class already exists for this descriptor, don't try to</span>
    <span class="s0"># create another.  Doing so will break any messages that already exist with</span>
    <span class="s0"># the existing class.</span>
    <span class="s0">#</span>
    <span class="s0"># The C++ implementation appears to have its own internal `PyMessageFactory`</span>
    <span class="s0"># to achieve similar results.</span>
    <span class="s0">#</span>
    <span class="s0"># This most commonly happens in `text_format.py` when using descriptors from</span>
    <span class="s0"># a custom pool; it calls symbol_database.Global().getPrototype() on a</span>
    <span class="s0"># descriptor which already has an existing concrete class.</span>
    <span class="s1">new_class = getattr(descriptor</span><span class="s4">, </span><span class="s3">'_concrete_class'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">new_class:</span>
      <span class="s4">return </span><span class="s1">new_class</span>

    <span class="s4">if </span><span class="s1">descriptor.full_name </span><span class="s4">in </span><span class="s1">well_known_types.WKTBASES:</span>
      <span class="s1">bases += (well_known_types.WKTBASES[descriptor.full_name]</span><span class="s4">,</span><span class="s1">)</span>
    <span class="s1">_AddClassAttributesForNestedExtensions(descriptor</span><span class="s4">, </span><span class="s1">dictionary)</span>
    <span class="s1">_AddSlots(descriptor</span><span class="s4">, </span><span class="s1">dictionary)</span>

    <span class="s1">superclass = super(GeneratedProtocolMessageType</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">new_class = superclass.__new__(cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">bases</span><span class="s4">, </span><span class="s1">dictionary)</span>
    <span class="s4">return </span><span class="s1">new_class</span>

  <span class="s4">def </span><span class="s1">__init__(cls</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">bases</span><span class="s4">, </span><span class="s1">dictionary):</span>
    <span class="s2">&quot;&quot;&quot;Here we perform the majority of our work on the class. 
    We add enum getters, an __init__ method, implementations 
    of all Message methods, and properties for all fields 
    in the protocol type. 
 
    Args: 
      name: Name of the class (ignored, but required by the 
        metaclass protocol). 
      bases: Base classes of the class we're constructing. 
        (Should be message.Message).  We ignore this field, but 
        it's required by the metaclass protocol 
      dictionary: The class dictionary of the class we're 
        constructing.  dictionary[_DESCRIPTOR_KEY] must contain 
        a Descriptor object describing this protocol message 
        type. 
    &quot;&quot;&quot;</span>
    <span class="s1">descriptor = dictionary[GeneratedProtocolMessageType._DESCRIPTOR_KEY]</span>

    <span class="s0"># If this is an _existing_ class looked up via `_concrete_class` in the</span>
    <span class="s0"># __new__ method above, then we don't need to re-initialize anything.</span>
    <span class="s1">existing_class = getattr(descriptor</span><span class="s4">, </span><span class="s3">'_concrete_class'</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">existing_class:</span>
      <span class="s4">assert </span><span class="s1">existing_class </span><span class="s4">is </span><span class="s1">cls</span><span class="s4">, </span><span class="s1">(</span>
          <span class="s3">'Duplicate `GeneratedProtocolMessageType` created for descriptor %r'</span>
          <span class="s1">% (descriptor.full_name))</span>
      <span class="s4">return</span>

    <span class="s1">cls._decoders_by_tag = {}</span>
    <span class="s4">if </span><span class="s1">(descriptor.has_options </span><span class="s4">and</span>
        <span class="s1">descriptor.GetOptions().message_set_wire_format):</span>
      <span class="s1">cls._decoders_by_tag[decoder.MESSAGE_SET_ITEM_TAG] = (</span>
          <span class="s1">decoder.MessageSetItemDecoder(descriptor)</span><span class="s4">, None</span><span class="s1">)</span>

    <span class="s0"># Attach stuff to each FieldDescriptor for quick lookup later on.</span>
    <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">descriptor.fields:</span>
      <span class="s1">_AttachFieldHelpers(cls</span><span class="s4">, </span><span class="s1">field)</span>

    <span class="s1">descriptor._concrete_class = cls  </span><span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">_AddEnumValues(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">_AddInitMethod(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">_AddPropertiesForFields(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">_AddPropertiesForExtensions(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">_AddStaticMethods(cls)</span>
    <span class="s1">_AddMessageMethods(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">_AddPrivateHelperMethods(descriptor</span><span class="s4">, </span><span class="s1">cls)</span>

    <span class="s1">superclass = super(GeneratedProtocolMessageType</span><span class="s4">, </span><span class="s1">cls)</span>
    <span class="s1">superclass.__init__(name</span><span class="s4">, </span><span class="s1">bases</span><span class="s4">, </span><span class="s1">dictionary)</span>


<span class="s0"># Stateless helpers for GeneratedProtocolMessageType below.</span>
<span class="s0"># Outside clients should not access these directly.</span>
<span class="s0">#</span>
<span class="s0"># I opted not to make any of these methods on the metaclass, to make it more</span>
<span class="s0"># clear that I'm not really using any state there and to keep clients from</span>
<span class="s0"># thinking that they have direct access to these construction helpers.</span>


<span class="s4">def </span><span class="s1">_PropertyName(proto_field_name):</span>
  <span class="s2">&quot;&quot;&quot;Returns the name of the public property attribute which 
  clients can use to get and (in some cases) set the value 
  of a protocol message field. 
 
  Args: 
    proto_field_name: The protocol message field name, exactly 
      as it appears (or would appear) in a .proto file. 
  &quot;&quot;&quot;</span>
  <span class="s0"># TODO(robinson): Escape Python keywords (e.g., yield), and test this support.</span>
  <span class="s0"># nnorwitz makes my day by writing:</span>
  <span class="s0"># &quot;&quot;&quot;</span>
  <span class="s0"># FYI.  See the keyword module in the stdlib. This could be as simple as:</span>
  <span class="s0">#</span>
  <span class="s0"># if keyword.iskeyword(proto_field_name):</span>
  <span class="s0">#   return proto_field_name + &quot;_&quot;</span>
  <span class="s0"># return proto_field_name</span>
  <span class="s0"># &quot;&quot;&quot;</span>
  <span class="s0"># Kenton says:  The above is a BAD IDEA.  People rely on being able to use</span>
  <span class="s0">#   getattr() and setattr() to reflectively manipulate field values.  If we</span>
  <span class="s0">#   rename the properties, then every such user has to also make sure to apply</span>
  <span class="s0">#   the same transformation.  Note that currently if you name a field &quot;yield&quot;,</span>
  <span class="s0">#   you can still access it just fine using getattr/setattr -- it's not even</span>
  <span class="s0">#   that cumbersome to do so.</span>
  <span class="s0"># TODO(kenton):  Remove this method entirely if/when everyone agrees with my</span>
  <span class="s0">#   position.</span>
  <span class="s4">return </span><span class="s1">proto_field_name</span>


<span class="s4">def </span><span class="s1">_AddSlots(message_descriptor</span><span class="s4">, </span><span class="s1">dictionary):</span>
  <span class="s2">&quot;&quot;&quot;Adds a __slots__ entry to dictionary, containing the names of all valid 
  attributes for this message type. 
 
  Args: 
    message_descriptor: A Descriptor instance describing this message type. 
    dictionary: Class dictionary to which we'll add a '__slots__' entry. 
  &quot;&quot;&quot;</span>
  <span class="s1">dictionary[</span><span class="s3">'__slots__'</span><span class="s1">] = [</span><span class="s3">'_cached_byte_size'</span><span class="s4">,</span>
                             <span class="s3">'_cached_byte_size_dirty'</span><span class="s4">,</span>
                             <span class="s3">'_fields'</span><span class="s4">,</span>
                             <span class="s3">'_unknown_fields'</span><span class="s4">,</span>
                             <span class="s3">'_unknown_field_set'</span><span class="s4">,</span>
                             <span class="s3">'_is_present_in_parent'</span><span class="s4">,</span>
                             <span class="s3">'_listener'</span><span class="s4">,</span>
                             <span class="s3">'_listener_for_children'</span><span class="s4">,</span>
                             <span class="s3">'__weakref__'</span><span class="s4">,</span>
                             <span class="s3">'_oneofs'</span><span class="s1">]</span>


<span class="s4">def </span><span class="s1">_IsMessageSetExtension(field):</span>
  <span class="s4">return </span><span class="s1">(field.is_extension </span><span class="s4">and</span>
          <span class="s1">field.containing_type.has_options </span><span class="s4">and</span>
          <span class="s1">field.containing_type.GetOptions().message_set_wire_format </span><span class="s4">and</span>
          <span class="s1">field.type == _FieldDescriptor.TYPE_MESSAGE </span><span class="s4">and</span>
          <span class="s1">field.label == _FieldDescriptor.LABEL_OPTIONAL)</span>


<span class="s4">def </span><span class="s1">_IsMapField(field):</span>
  <span class="s4">return </span><span class="s1">(field.type == _FieldDescriptor.TYPE_MESSAGE </span><span class="s4">and</span>
          <span class="s1">field.message_type.has_options </span><span class="s4">and</span>
          <span class="s1">field.message_type.GetOptions().map_entry)</span>


<span class="s4">def </span><span class="s1">_IsMessageMapField(field):</span>
  <span class="s1">value_type = field.message_type.fields_by_name[</span><span class="s3">'value'</span><span class="s1">]</span>
  <span class="s4">return </span><span class="s1">value_type.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE</span>


<span class="s4">def </span><span class="s1">_AttachFieldHelpers(cls</span><span class="s4">, </span><span class="s1">field_descriptor):</span>
  <span class="s1">is_repeated = (field_descriptor.label == _FieldDescriptor.LABEL_REPEATED)</span>
  <span class="s1">is_packable = (is_repeated </span><span class="s4">and</span>
                 <span class="s1">wire_format.IsTypePackable(field_descriptor.type))</span>
  <span class="s1">is_proto3 = field_descriptor.containing_type.syntax == </span><span class="s3">'proto3'</span>
  <span class="s4">if not </span><span class="s1">is_packable:</span>
    <span class="s1">is_packed = </span><span class="s4">False</span>
  <span class="s4">elif </span><span class="s1">field_descriptor.containing_type.syntax == </span><span class="s3">'proto2'</span><span class="s1">:</span>
    <span class="s1">is_packed = (field_descriptor.has_options </span><span class="s4">and</span>
                <span class="s1">field_descriptor.GetOptions().packed)</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">has_packed_false = (field_descriptor.has_options </span><span class="s4">and</span>
                        <span class="s1">field_descriptor.GetOptions().HasField(</span><span class="s3">'packed'</span><span class="s1">) </span><span class="s4">and</span>
                        <span class="s1">field_descriptor.GetOptions().packed == </span><span class="s4">False</span><span class="s1">)</span>
    <span class="s1">is_packed = </span><span class="s4">not </span><span class="s1">has_packed_false</span>
  <span class="s1">is_map_entry = _IsMapField(field_descriptor)</span>

  <span class="s4">if </span><span class="s1">is_map_entry:</span>
    <span class="s1">field_encoder = encoder.MapEncoder(field_descriptor)</span>
    <span class="s1">sizer = encoder.MapSizer(field_descriptor</span><span class="s4">,</span>
                             <span class="s1">_IsMessageMapField(field_descriptor))</span>
  <span class="s4">elif </span><span class="s1">_IsMessageSetExtension(field_descriptor):</span>
    <span class="s1">field_encoder = encoder.MessageSetItemEncoder(field_descriptor.number)</span>
    <span class="s1">sizer = encoder.MessageSetItemSizer(field_descriptor.number)</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">field_encoder = type_checkers.TYPE_TO_ENCODER[field_descriptor.type](</span>
        <span class="s1">field_descriptor.number</span><span class="s4">, </span><span class="s1">is_repeated</span><span class="s4">, </span><span class="s1">is_packed)</span>
    <span class="s1">sizer = type_checkers.TYPE_TO_SIZER[field_descriptor.type](</span>
        <span class="s1">field_descriptor.number</span><span class="s4">, </span><span class="s1">is_repeated</span><span class="s4">, </span><span class="s1">is_packed)</span>

  <span class="s1">field_descriptor._encoder = field_encoder</span>
  <span class="s1">field_descriptor._sizer = sizer</span>
  <span class="s1">field_descriptor._default_constructor = _DefaultValueConstructorForField(</span>
      <span class="s1">field_descriptor)</span>

  <span class="s4">def </span><span class="s1">AddDecoder(wiretype</span><span class="s4">, </span><span class="s1">is_packed):</span>
    <span class="s1">tag_bytes = encoder.TagBytes(field_descriptor.number</span><span class="s4">, </span><span class="s1">wiretype)</span>
    <span class="s1">decode_type = field_descriptor.type</span>
    <span class="s4">if </span><span class="s1">(decode_type == _FieldDescriptor.TYPE_ENUM </span><span class="s4">and</span>
        <span class="s1">type_checkers.SupportsOpenEnums(field_descriptor)):</span>
      <span class="s1">decode_type = _FieldDescriptor.TYPE_INT32</span>

    <span class="s1">oneof_descriptor = </span><span class="s4">None</span>
    <span class="s1">clear_if_default = </span><span class="s4">False</span>
    <span class="s4">if </span><span class="s1">field_descriptor.containing_oneof </span><span class="s4">is not None</span><span class="s1">:</span>
      <span class="s1">oneof_descriptor = field_descriptor</span>
    <span class="s4">elif </span><span class="s1">(is_proto3 </span><span class="s4">and not </span><span class="s1">is_repeated </span><span class="s4">and</span>
          <span class="s1">field_descriptor.cpp_type != _FieldDescriptor.CPPTYPE_MESSAGE):</span>
      <span class="s1">clear_if_default = </span><span class="s4">True</span>

    <span class="s4">if </span><span class="s1">is_map_entry:</span>
      <span class="s1">is_message_map = _IsMessageMapField(field_descriptor)</span>

      <span class="s1">field_decoder = decoder.MapDecoder(</span>
          <span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">_GetInitializeDefaultForMap(field_descriptor)</span><span class="s4">,</span>
          <span class="s1">is_message_map)</span>
    <span class="s4">elif </span><span class="s1">decode_type == _FieldDescriptor.TYPE_STRING:</span>
      <span class="s1">field_decoder = decoder.StringDecoder(</span>
          <span class="s1">field_descriptor.number</span><span class="s4">, </span><span class="s1">is_repeated</span><span class="s4">, </span><span class="s1">is_packed</span><span class="s4">,</span>
          <span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">field_descriptor._default_constructor</span><span class="s4">,</span>
          <span class="s1">clear_if_default)</span>
    <span class="s4">elif </span><span class="s1">field_descriptor.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
      <span class="s1">field_decoder = type_checkers.TYPE_TO_DECODER[decode_type](</span>
          <span class="s1">field_descriptor.number</span><span class="s4">, </span><span class="s1">is_repeated</span><span class="s4">, </span><span class="s1">is_packed</span><span class="s4">,</span>
          <span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">field_descriptor._default_constructor)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">field_decoder = type_checkers.TYPE_TO_DECODER[decode_type](</span>
          <span class="s1">field_descriptor.number</span><span class="s4">, </span><span class="s1">is_repeated</span><span class="s4">, </span><span class="s1">is_packed</span><span class="s4">,</span>
          <span class="s0"># pylint: disable=protected-access</span>
          <span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">field_descriptor._default_constructor</span><span class="s4">,</span>
          <span class="s1">clear_if_default)</span>

    <span class="s1">cls._decoders_by_tag[tag_bytes] = (field_decoder</span><span class="s4">, </span><span class="s1">oneof_descriptor)</span>

  <span class="s1">AddDecoder(type_checkers.FIELD_TYPE_TO_WIRE_TYPE[field_descriptor.type]</span><span class="s4">,</span>
             <span class="s4">False</span><span class="s1">)</span>

  <span class="s4">if </span><span class="s1">is_repeated </span><span class="s4">and </span><span class="s1">wire_format.IsTypePackable(field_descriptor.type):</span>
    <span class="s0"># To support wire compatibility of adding packed = true, add a decoder for</span>
    <span class="s0"># packed values regardless of the field's options.</span>
    <span class="s1">AddDecoder(wire_format.WIRETYPE_LENGTH_DELIMITED</span><span class="s4">, True</span><span class="s1">)</span>


<span class="s4">def </span><span class="s1">_AddClassAttributesForNestedExtensions(descriptor</span><span class="s4">, </span><span class="s1">dictionary):</span>
  <span class="s1">extensions = descriptor.extensions_by_name</span>
  <span class="s4">for </span><span class="s1">extension_name</span><span class="s4">, </span><span class="s1">extension_field </span><span class="s4">in </span><span class="s1">extensions.items():</span>
    <span class="s4">assert </span><span class="s1">extension_name </span><span class="s4">not in </span><span class="s1">dictionary</span>
    <span class="s1">dictionary[extension_name] = extension_field</span>


<span class="s4">def </span><span class="s1">_AddEnumValues(descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Sets class-level attributes for all enum fields defined in this message. 
 
  Also exporting a class-level object that can name enum values. 
 
  Args: 
    descriptor: Descriptor object for this message type. 
    cls: Class we're constructing for this message type. 
  &quot;&quot;&quot;</span>
  <span class="s4">for </span><span class="s1">enum_type </span><span class="s4">in </span><span class="s1">descriptor.enum_types:</span>
    <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">enum_type.name</span><span class="s4">, </span><span class="s1">enum_type_wrapper.EnumTypeWrapper(enum_type))</span>
    <span class="s4">for </span><span class="s1">enum_value </span><span class="s4">in </span><span class="s1">enum_type.values:</span>
      <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">enum_value.name</span><span class="s4">, </span><span class="s1">enum_value.number)</span>


<span class="s4">def </span><span class="s1">_GetInitializeDefaultForMap(field):</span>
  <span class="s4">if </span><span class="s1">field.label != _FieldDescriptor.LABEL_REPEATED:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'map_entry set on non-repeated field %s' </span><span class="s1">% (</span>
        <span class="s1">field.name))</span>
  <span class="s1">fields_by_name = field.message_type.fields_by_name</span>
  <span class="s1">key_checker = type_checkers.GetTypeChecker(fields_by_name[</span><span class="s3">'key'</span><span class="s1">])</span>

  <span class="s1">value_field = fields_by_name[</span><span class="s3">'value'</span><span class="s1">]</span>
  <span class="s4">if </span><span class="s1">_IsMessageMapField(field):</span>
    <span class="s4">def </span><span class="s1">MakeMessageMapDefault(message):</span>
      <span class="s4">return </span><span class="s1">containers.MessageMap(</span>
          <span class="s1">message._listener_for_children</span><span class="s4">, </span><span class="s1">value_field.message_type</span><span class="s4">, </span><span class="s1">key_checker</span><span class="s4">,</span>
          <span class="s1">field.message_type)</span>
    <span class="s4">return </span><span class="s1">MakeMessageMapDefault</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">value_checker = type_checkers.GetTypeChecker(value_field)</span>
    <span class="s4">def </span><span class="s1">MakePrimitiveMapDefault(message):</span>
      <span class="s4">return </span><span class="s1">containers.ScalarMap(</span>
          <span class="s1">message._listener_for_children</span><span class="s4">, </span><span class="s1">key_checker</span><span class="s4">, </span><span class="s1">value_checker</span><span class="s4">,</span>
          <span class="s1">field.message_type)</span>
    <span class="s4">return </span><span class="s1">MakePrimitiveMapDefault</span>

<span class="s4">def </span><span class="s1">_DefaultValueConstructorForField(field):</span>
  <span class="s2">&quot;&quot;&quot;Returns a function which returns a default value for a field. 
 
  Args: 
    field: FieldDescriptor object for this field. 
 
  The returned function has one argument: 
    message: Message instance containing this field, or a weakref proxy 
      of same. 
 
  That function in turn returns a default value for this field.  The default 
    value may refer back to |message| via a weak reference. 
  &quot;&quot;&quot;</span>

  <span class="s4">if </span><span class="s1">_IsMapField(field):</span>
    <span class="s4">return </span><span class="s1">_GetInitializeDefaultForMap(field)</span>

  <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
    <span class="s4">if </span><span class="s1">field.has_default_value </span><span class="s4">and </span><span class="s1">field.default_value != []:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Repeated field default value not empty list: %s' </span><span class="s1">% (</span>
          <span class="s1">field.default_value))</span>
    <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
      <span class="s0"># We can't look at _concrete_class yet since it might not have</span>
      <span class="s0"># been set.  (Depends on order in which we initialize the classes).</span>
      <span class="s1">message_type = field.message_type</span>
      <span class="s4">def </span><span class="s1">MakeRepeatedMessageDefault(message):</span>
        <span class="s4">return </span><span class="s1">containers.RepeatedCompositeFieldContainer(</span>
            <span class="s1">message._listener_for_children</span><span class="s4">, </span><span class="s1">field.message_type)</span>
      <span class="s4">return </span><span class="s1">MakeRepeatedMessageDefault</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">type_checker = type_checkers.GetTypeChecker(field)</span>
      <span class="s4">def </span><span class="s1">MakeRepeatedScalarDefault(message):</span>
        <span class="s4">return </span><span class="s1">containers.RepeatedScalarFieldContainer(</span>
            <span class="s1">message._listener_for_children</span><span class="s4">, </span><span class="s1">type_checker)</span>
      <span class="s4">return </span><span class="s1">MakeRepeatedScalarDefault</span>

  <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
    <span class="s0"># _concrete_class may not yet be initialized.</span>
    <span class="s1">message_type = field.message_type</span>
    <span class="s4">def </span><span class="s1">MakeSubMessageDefault(message):</span>
      <span class="s4">assert </span><span class="s1">getattr(message_type</span><span class="s4">, </span><span class="s3">'_concrete_class'</span><span class="s4">, None</span><span class="s1">)</span><span class="s4">, </span><span class="s1">(</span>
          <span class="s3">'Uninitialized concrete class found for field %r (message type %r)'</span>
          <span class="s1">% (field.full_name</span><span class="s4">, </span><span class="s1">message_type.full_name))</span>
      <span class="s1">result = message_type._concrete_class()</span>
      <span class="s1">result._SetListener(</span>
          <span class="s1">_OneofListener(message</span><span class="s4">, </span><span class="s1">field)</span>
          <span class="s4">if </span><span class="s1">field.containing_oneof </span><span class="s4">is not None</span>
          <span class="s4">else </span><span class="s1">message._listener_for_children)</span>
      <span class="s4">return </span><span class="s1">result</span>
    <span class="s4">return </span><span class="s1">MakeSubMessageDefault</span>

  <span class="s4">def </span><span class="s1">MakeScalarDefault(message):</span>
    <span class="s0"># TODO(protobuf-team): This may be broken since there may not be</span>
    <span class="s0"># default_value.  Combine with has_default_value somehow.</span>
    <span class="s4">return </span><span class="s1">field.default_value</span>
  <span class="s4">return </span><span class="s1">MakeScalarDefault</span>


<span class="s4">def </span><span class="s1">_ReraiseTypeErrorWithFieldName(message_name</span><span class="s4">, </span><span class="s1">field_name):</span>
  <span class="s2">&quot;&quot;&quot;Re-raise the currently-handled TypeError with the field name added.&quot;&quot;&quot;</span>
  <span class="s1">exc = sys.exc_info()[</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s4">if </span><span class="s1">len(exc.args) == </span><span class="s5">1 </span><span class="s4">and </span><span class="s1">type(exc) </span><span class="s4">is </span><span class="s1">TypeError:</span>
    <span class="s0"># simple TypeError; add field name to exception message</span>
    <span class="s1">exc = TypeError(</span><span class="s3">'%s for field %s.%s' </span><span class="s1">% (str(exc)</span><span class="s4">, </span><span class="s1">message_name</span><span class="s4">, </span><span class="s1">field_name))</span>

  <span class="s0"># re-raise possibly-amended exception with original traceback:</span>
  <span class="s4">raise </span><span class="s1">exc.with_traceback(sys.exc_info()[</span><span class="s5">2</span><span class="s1">])</span>


<span class="s4">def </span><span class="s1">_AddInitMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds an __init__ method to cls.&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">_GetIntegerEnumValue(enum_type</span><span class="s4">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Convert a string or integer enum value to an integer. 
 
    If the value is a string, it is converted to the enum value in 
    enum_type with the same name.  If the value is not a string, it's 
    returned as-is.  (No conversion or bounds-checking is done.) 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance(value</span><span class="s4">, </span><span class="s1">str):</span>
      <span class="s4">try</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">enum_type.values_by_name[value].number</span>
      <span class="s4">except </span><span class="s1">KeyError:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Enum type %s: unknown label &quot;%s&quot;' </span><span class="s1">% (</span>
            <span class="s1">enum_type.full_name</span><span class="s4">, </span><span class="s1">value))</span>
    <span class="s4">return </span><span class="s1">value</span>

  <span class="s4">def </span><span class="s1">init(self</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">self._cached_byte_size = </span><span class="s5">0</span>
    <span class="s1">self._cached_byte_size_dirty = len(kwargs) &gt; </span><span class="s5">0</span>
    <span class="s1">self._fields = {}</span>
    <span class="s0"># Contains a mapping from oneof field descriptors to the descriptor</span>
    <span class="s0"># of the currently set field in that oneof field.</span>
    <span class="s1">self._oneofs = {}</span>

    <span class="s0"># _unknown_fields is () when empty for efficiency, and will be turned into</span>
    <span class="s0"># a list if fields are added.</span>
    <span class="s1">self._unknown_fields = ()</span>
    <span class="s0"># _unknown_field_set is None when empty for efficiency, and will be</span>
    <span class="s0"># turned into UnknownFieldSet struct if fields are added.</span>
    <span class="s1">self._unknown_field_set = </span><span class="s4">None      </span><span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">self._is_present_in_parent = </span><span class="s4">False</span>
    <span class="s1">self._listener = message_listener_mod.NullMessageListener()</span>
    <span class="s1">self._listener_for_children = _Listener(self)</span>
    <span class="s4">for </span><span class="s1">field_name</span><span class="s4">, </span><span class="s1">field_value </span><span class="s4">in </span><span class="s1">kwargs.items():</span>
      <span class="s1">field = _GetFieldByName(message_descriptor</span><span class="s4">, </span><span class="s1">field_name)</span>
      <span class="s4">if </span><span class="s1">field </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">raise </span><span class="s1">TypeError(</span><span class="s3">'%s() got an unexpected keyword argument &quot;%s&quot;' </span><span class="s1">%</span>
                        <span class="s1">(message_descriptor.name</span><span class="s4">, </span><span class="s1">field_name))</span>
      <span class="s4">if </span><span class="s1">field_value </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s0"># field=None is the same as no field at all.</span>
        <span class="s4">continue</span>
      <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
        <span class="s1">copy = field._default_constructor(self)</span>
        <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:  </span><span class="s0"># Composite</span>
          <span class="s4">if </span><span class="s1">_IsMapField(field):</span>
            <span class="s4">if </span><span class="s1">_IsMessageMapField(field):</span>
              <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">field_value:</span>
                <span class="s1">copy[key].MergeFrom(field_value[key])</span>
            <span class="s4">else</span><span class="s1">:</span>
              <span class="s1">copy.update(field_value)</span>
          <span class="s4">else</span><span class="s1">:</span>
            <span class="s4">for </span><span class="s1">val </span><span class="s4">in </span><span class="s1">field_value:</span>
              <span class="s4">if </span><span class="s1">isinstance(val</span><span class="s4">, </span><span class="s1">dict):</span>
                <span class="s1">copy.add(**val)</span>
              <span class="s4">else</span><span class="s1">:</span>
                <span class="s1">copy.add().MergeFrom(val)</span>
        <span class="s4">else</span><span class="s1">:  </span><span class="s0"># Scalar</span>
          <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_ENUM:</span>
            <span class="s1">field_value = [_GetIntegerEnumValue(field.enum_type</span><span class="s4">, </span><span class="s1">val)</span>
                           <span class="s4">for </span><span class="s1">val </span><span class="s4">in </span><span class="s1">field_value]</span>
          <span class="s1">copy.extend(field_value)</span>
        <span class="s1">self._fields[field] = copy</span>
      <span class="s4">elif </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
        <span class="s1">copy = field._default_constructor(self)</span>
        <span class="s1">new_val = field_value</span>
        <span class="s4">if </span><span class="s1">isinstance(field_value</span><span class="s4">, </span><span class="s1">dict):</span>
          <span class="s1">new_val = field.message_type._concrete_class(**field_value)</span>
        <span class="s4">try</span><span class="s1">:</span>
          <span class="s1">copy.MergeFrom(new_val)</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
          <span class="s1">_ReraiseTypeErrorWithFieldName(message_descriptor.name</span><span class="s4">, </span><span class="s1">field_name)</span>
        <span class="s1">self._fields[field] = copy</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_ENUM:</span>
          <span class="s1">field_value = _GetIntegerEnumValue(field.enum_type</span><span class="s4">, </span><span class="s1">field_value)</span>
        <span class="s4">try</span><span class="s1">:</span>
          <span class="s1">setattr(self</span><span class="s4">, </span><span class="s1">field_name</span><span class="s4">, </span><span class="s1">field_value)</span>
        <span class="s4">except </span><span class="s1">TypeError:</span>
          <span class="s1">_ReraiseTypeErrorWithFieldName(message_descriptor.name</span><span class="s4">, </span><span class="s1">field_name)</span>

  <span class="s1">init.__module__ = </span><span class="s4">None</span>
  <span class="s1">init.__doc__ = </span><span class="s4">None</span>
  <span class="s1">cls.__init__ = init</span>


<span class="s4">def </span><span class="s1">_GetFieldByName(message_descriptor</span><span class="s4">, </span><span class="s1">field_name):</span>
  <span class="s2">&quot;&quot;&quot;Returns a field descriptor by field name. 
 
  Args: 
    message_descriptor: A Descriptor describing all fields in message. 
    field_name: The name of the field to retrieve. 
  Returns: 
    The field descriptor associated with the field name. 
  &quot;&quot;&quot;</span>
  <span class="s4">try</span><span class="s1">:</span>
    <span class="s4">return </span><span class="s1">message_descriptor.fields_by_name[field_name]</span>
  <span class="s4">except </span><span class="s1">KeyError:</span>
    <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Protocol message %s has no &quot;%s&quot; field.' </span><span class="s1">%</span>
                     <span class="s1">(message_descriptor.name</span><span class="s4">, </span><span class="s1">field_name))</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForFields(descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds properties for all fields in this protocol message type.&quot;&quot;&quot;</span>
  <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">descriptor.fields:</span>
    <span class="s1">_AddPropertiesForField(field</span><span class="s4">, </span><span class="s1">cls)</span>

  <span class="s4">if </span><span class="s1">descriptor.is_extendable:</span>
    <span class="s0"># _ExtensionDict is just an adaptor with no state so we allocate a new one</span>
    <span class="s0"># every time it is accessed.</span>
    <span class="s1">cls.Extensions = property(</span><span class="s4">lambda </span><span class="s1">self: _ExtensionDict(self))</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForField(field</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds a public property for a protocol message field. 
  Clients can use this property to get and (in the case 
  of non-repeated scalar fields) directly set the value 
  of a protocol message field. 
 
  Args: 
    field: A FieldDescriptor for this field. 
    cls: The class we're constructing. 
  &quot;&quot;&quot;</span>
  <span class="s0"># Catch it if we add other types that we should</span>
  <span class="s0"># handle specially here.</span>
  <span class="s4">assert </span><span class="s1">_FieldDescriptor.MAX_CPPTYPE == </span><span class="s5">10</span>

  <span class="s1">constant_name = field.name.upper() + </span><span class="s3">'_FIELD_NUMBER'</span>
  <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">constant_name</span><span class="s4">, </span><span class="s1">field.number)</span>

  <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
    <span class="s1">_AddPropertiesForRepeatedField(field</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s4">elif </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
    <span class="s1">_AddPropertiesForNonRepeatedCompositeField(field</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">_AddPropertiesForNonRepeatedScalarField(field</span><span class="s4">, </span><span class="s1">cls)</span>


<span class="s4">class </span><span class="s1">_FieldProperty(property):</span>
  <span class="s1">__slots__ = (</span><span class="s3">'DESCRIPTOR'</span><span class="s4">,</span><span class="s1">)</span>

  <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">descriptor</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">setter</span><span class="s4">, </span><span class="s1">doc):</span>
    <span class="s1">property.__init__(self</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">setter</span><span class="s4">, </span><span class="s1">doc=doc)</span>
    <span class="s1">self.DESCRIPTOR = descriptor</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForRepeatedField(field</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds a public property for a &quot;repeated&quot; protocol message field.  Clients 
  can use this property to get the value of the field, which will be either a 
  RepeatedScalarFieldContainer or RepeatedCompositeFieldContainer (see 
  below). 
 
  Note that when clients add values to these containers, we perform 
  type-checking in the case of repeated scalar fields, and we also set any 
  necessary &quot;has&quot; bits as a side-effect. 
 
  Args: 
    field: A FieldDescriptor for this field. 
    cls: The class we're constructing. 
  &quot;&quot;&quot;</span>
  <span class="s1">proto_field_name = field.name</span>
  <span class="s1">property_name = _PropertyName(proto_field_name)</span>

  <span class="s4">def </span><span class="s1">getter(self):</span>
    <span class="s1">field_value = self._fields.get(field)</span>
    <span class="s4">if </span><span class="s1">field_value </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s0"># Construct a new object to represent this field.</span>
      <span class="s1">field_value = field._default_constructor(self)</span>

      <span class="s0"># Atomically check if another thread has preempted us and, if not, swap</span>
      <span class="s0"># in the new object we just created.  If someone has preempted us, we</span>
      <span class="s0"># take that object and discard ours.</span>
      <span class="s0"># WARNING:  We are relying on setdefault() being atomic.  This is true</span>
      <span class="s0">#   in CPython but we haven't investigated others.  This warning appears</span>
      <span class="s0">#   in several other locations in this file.</span>
      <span class="s1">field_value = self._fields.setdefault(field</span><span class="s4">, </span><span class="s1">field_value)</span>
    <span class="s4">return </span><span class="s1">field_value</span>
  <span class="s1">getter.__module__ = </span><span class="s4">None</span>
  <span class="s1">getter.__doc__ = </span><span class="s3">'Getter for %s.' </span><span class="s1">% proto_field_name</span>

  <span class="s0"># We define a setter just so we can throw an exception with a more</span>
  <span class="s0"># helpful error message.</span>
  <span class="s4">def </span><span class="s1">setter(self</span><span class="s4">, </span><span class="s1">new_value):</span>
    <span class="s4">raise </span><span class="s1">AttributeError(</span><span class="s3">'Assignment not allowed to repeated field '</span>
                         <span class="s3">'&quot;%s&quot; in protocol message object.' </span><span class="s1">% proto_field_name)</span>

  <span class="s1">doc = </span><span class="s3">'Magic attribute generated for &quot;%s&quot; proto field.' </span><span class="s1">% proto_field_name</span>
  <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">property_name</span><span class="s4">, </span><span class="s1">_FieldProperty(field</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">setter</span><span class="s4">, </span><span class="s1">doc=doc))</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForNonRepeatedScalarField(field</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds a public property for a nonrepeated, scalar protocol message field. 
  Clients can use this property to get and directly set the value of the field. 
  Note that when the client sets the value of a field by using this property, 
  all necessary &quot;has&quot; bits are set as a side-effect, and we also perform 
  type-checking. 
 
  Args: 
    field: A FieldDescriptor for this field. 
    cls: The class we're constructing. 
  &quot;&quot;&quot;</span>
  <span class="s1">proto_field_name = field.name</span>
  <span class="s1">property_name = _PropertyName(proto_field_name)</span>
  <span class="s1">type_checker = type_checkers.GetTypeChecker(field)</span>
  <span class="s1">default_value = field.default_value</span>
  <span class="s1">is_proto3 = field.containing_type.syntax == </span><span class="s3">'proto3'</span>

  <span class="s4">def </span><span class="s1">getter(self):</span>
    <span class="s0"># TODO(protobuf-team): This may be broken since there may not be</span>
    <span class="s0"># default_value.  Combine with has_default_value somehow.</span>
    <span class="s4">return </span><span class="s1">self._fields.get(field</span><span class="s4">, </span><span class="s1">default_value)</span>
  <span class="s1">getter.__module__ = </span><span class="s4">None</span>
  <span class="s1">getter.__doc__ = </span><span class="s3">'Getter for %s.' </span><span class="s1">% proto_field_name</span>

  <span class="s1">clear_when_set_to_default = is_proto3 </span><span class="s4">and not </span><span class="s1">field.containing_oneof</span>

  <span class="s4">def </span><span class="s1">field_setter(self</span><span class="s4">, </span><span class="s1">new_value):</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s0"># Testing the value for truthiness captures all of the proto3 defaults</span>
    <span class="s0"># (0, 0.0, enum 0, and False).</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">new_value = type_checker.CheckValue(new_value)</span>
    <span class="s4">except </span><span class="s1">TypeError </span><span class="s4">as </span><span class="s1">e:</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span>
          <span class="s3">'Cannot set %s to %.1024r: %s' </span><span class="s1">% (field.full_name</span><span class="s4">, </span><span class="s1">new_value</span><span class="s4">, </span><span class="s1">e))</span>
    <span class="s4">if </span><span class="s1">clear_when_set_to_default </span><span class="s4">and not </span><span class="s1">new_value:</span>
      <span class="s1">self._fields.pop(field</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">self._fields[field] = new_value</span>
    <span class="s0"># Check _cached_byte_size_dirty inline to improve performance, since scalar</span>
    <span class="s0"># setters are called frequently.</span>
    <span class="s4">if not </span><span class="s1">self._cached_byte_size_dirty:</span>
      <span class="s1">self._Modified()</span>

  <span class="s4">if </span><span class="s1">field.containing_oneof:</span>
    <span class="s4">def </span><span class="s1">setter(self</span><span class="s4">, </span><span class="s1">new_value):</span>
      <span class="s1">field_setter(self</span><span class="s4">, </span><span class="s1">new_value)</span>
      <span class="s1">self._UpdateOneofState(field)</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">setter = field_setter</span>

  <span class="s1">setter.__module__ = </span><span class="s4">None</span>
  <span class="s1">setter.__doc__ = </span><span class="s3">'Setter for %s.' </span><span class="s1">% proto_field_name</span>

  <span class="s0"># Add a property to encapsulate the getter/setter.</span>
  <span class="s1">doc = </span><span class="s3">'Magic attribute generated for &quot;%s&quot; proto field.' </span><span class="s1">% proto_field_name</span>
  <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">property_name</span><span class="s4">, </span><span class="s1">_FieldProperty(field</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">setter</span><span class="s4">, </span><span class="s1">doc=doc))</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForNonRepeatedCompositeField(field</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds a public property for a nonrepeated, composite protocol message field. 
  A composite field is a &quot;group&quot; or &quot;message&quot; field. 
 
  Clients can use this property to get the value of the field, but cannot 
  assign to the property directly. 
 
  Args: 
    field: A FieldDescriptor for this field. 
    cls: The class we're constructing. 
  &quot;&quot;&quot;</span>
  <span class="s0"># TODO(robinson): Remove duplication with similar method</span>
  <span class="s0"># for non-repeated scalars.</span>
  <span class="s1">proto_field_name = field.name</span>
  <span class="s1">property_name = _PropertyName(proto_field_name)</span>

  <span class="s4">def </span><span class="s1">getter(self):</span>
    <span class="s1">field_value = self._fields.get(field)</span>
    <span class="s4">if </span><span class="s1">field_value </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s0"># Construct a new object to represent this field.</span>
      <span class="s1">field_value = field._default_constructor(self)</span>

      <span class="s0"># Atomically check if another thread has preempted us and, if not, swap</span>
      <span class="s0"># in the new object we just created.  If someone has preempted us, we</span>
      <span class="s0"># take that object and discard ours.</span>
      <span class="s0"># WARNING:  We are relying on setdefault() being atomic.  This is true</span>
      <span class="s0">#   in CPython but we haven't investigated others.  This warning appears</span>
      <span class="s0">#   in several other locations in this file.</span>
      <span class="s1">field_value = self._fields.setdefault(field</span><span class="s4">, </span><span class="s1">field_value)</span>
    <span class="s4">return </span><span class="s1">field_value</span>
  <span class="s1">getter.__module__ = </span><span class="s4">None</span>
  <span class="s1">getter.__doc__ = </span><span class="s3">'Getter for %s.' </span><span class="s1">% proto_field_name</span>

  <span class="s0"># We define a setter just so we can throw an exception with a more</span>
  <span class="s0"># helpful error message.</span>
  <span class="s4">def </span><span class="s1">setter(self</span><span class="s4">, </span><span class="s1">new_value):</span>
    <span class="s4">raise </span><span class="s1">AttributeError(</span><span class="s3">'Assignment not allowed to composite field '</span>
                         <span class="s3">'&quot;%s&quot; in protocol message object.' </span><span class="s1">% proto_field_name)</span>

  <span class="s0"># Add a property to encapsulate the getter.</span>
  <span class="s1">doc = </span><span class="s3">'Magic attribute generated for &quot;%s&quot; proto field.' </span><span class="s1">% proto_field_name</span>
  <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">property_name</span><span class="s4">, </span><span class="s1">_FieldProperty(field</span><span class="s4">, </span><span class="s1">getter</span><span class="s4">, </span><span class="s1">setter</span><span class="s4">, </span><span class="s1">doc=doc))</span>


<span class="s4">def </span><span class="s1">_AddPropertiesForExtensions(descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds properties for all fields in this protocol message type.&quot;&quot;&quot;</span>
  <span class="s1">extensions = descriptor.extensions_by_name</span>
  <span class="s4">for </span><span class="s1">extension_name</span><span class="s4">, </span><span class="s1">extension_field </span><span class="s4">in </span><span class="s1">extensions.items():</span>
    <span class="s1">constant_name = extension_name.upper() + </span><span class="s3">'_FIELD_NUMBER'</span>
    <span class="s1">setattr(cls</span><span class="s4">, </span><span class="s1">constant_name</span><span class="s4">, </span><span class="s1">extension_field.number)</span>

  <span class="s0"># TODO(amauryfa): Migrate all users of these attributes to functions like</span>
  <span class="s0">#   pool.FindExtensionByNumber(descriptor).</span>
  <span class="s4">if </span><span class="s1">descriptor.file </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s0"># TODO(amauryfa): Use cls.MESSAGE_FACTORY.pool when available.</span>
    <span class="s1">pool = descriptor.file.pool</span>
    <span class="s1">cls._extensions_by_number = pool._extensions_by_number[descriptor]</span>
    <span class="s1">cls._extensions_by_name = pool._extensions_by_name[descriptor]</span>

<span class="s4">def </span><span class="s1">_AddStaticMethods(cls):</span>
  <span class="s0"># TODO(robinson): This probably needs to be thread-safe(?)</span>
  <span class="s4">def </span><span class="s1">RegisterExtension(extension_handle):</span>
    <span class="s1">extension_handle.containing_type = cls.DESCRIPTOR</span>
    <span class="s0"># TODO(amauryfa): Use cls.MESSAGE_FACTORY.pool when available.</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">cls.DESCRIPTOR.file.pool._AddExtensionDescriptor(extension_handle)</span>
    <span class="s1">_AttachFieldHelpers(cls</span><span class="s4">, </span><span class="s1">extension_handle)</span>
  <span class="s1">cls.RegisterExtension = staticmethod(RegisterExtension)</span>

  <span class="s4">def </span><span class="s1">FromString(s):</span>
    <span class="s1">message = cls()</span>
    <span class="s1">message.MergeFromString(s)</span>
    <span class="s4">return </span><span class="s1">message</span>
  <span class="s1">cls.FromString = staticmethod(FromString)</span>


<span class="s4">def </span><span class="s1">_IsPresent(item):</span>
  <span class="s2">&quot;&quot;&quot;Given a (FieldDescriptor, value) tuple from _fields, return true if the 
  value should be included in the list returned by ListFields().&quot;&quot;&quot;</span>

  <span class="s4">if </span><span class="s1">item[</span><span class="s5">0</span><span class="s1">].label == _FieldDescriptor.LABEL_REPEATED:</span>
    <span class="s4">return </span><span class="s1">bool(item[</span><span class="s5">1</span><span class="s1">])</span>
  <span class="s4">elif </span><span class="s1">item[</span><span class="s5">0</span><span class="s1">].cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
    <span class="s4">return </span><span class="s1">item[</span><span class="s5">1</span><span class="s1">]._is_present_in_parent</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s4">return True</span>


<span class="s4">def </span><span class="s1">_AddListFieldsMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">ListFields(self):</span>
    <span class="s1">all_fields = [item </span><span class="s4">for </span><span class="s1">item </span><span class="s4">in </span><span class="s1">self._fields.items() </span><span class="s4">if </span><span class="s1">_IsPresent(item)]</span>
    <span class="s1">all_fields.sort(key = </span><span class="s4">lambda </span><span class="s1">item: item[</span><span class="s5">0</span><span class="s1">].number)</span>
    <span class="s4">return </span><span class="s1">all_fields</span>

  <span class="s1">cls.ListFields = ListFields</span>

<span class="s1">_PROTO3_ERROR_TEMPLATE = \</span>
  <span class="s1">(</span><span class="s3">'Protocol message %s has no non-repeated submessage field &quot;%s&quot; '</span>
   <span class="s3">'nor marked as optional'</span><span class="s1">)</span>
<span class="s1">_PROTO2_ERROR_TEMPLATE = </span><span class="s3">'Protocol message %s has no non-repeated field &quot;%s&quot;'</span>

<span class="s4">def </span><span class="s1">_AddHasFieldMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s1">is_proto3 = (message_descriptor.syntax == </span><span class="s3">&quot;proto3&quot;</span><span class="s1">)</span>
  <span class="s1">error_msg = _PROTO3_ERROR_TEMPLATE </span><span class="s4">if </span><span class="s1">is_proto3 </span><span class="s4">else </span><span class="s1">_PROTO2_ERROR_TEMPLATE</span>

  <span class="s1">hassable_fields = {}</span>
  <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">message_descriptor.fields:</span>
    <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
      <span class="s4">continue</span>
    <span class="s0"># For proto3, only submessages and fields inside a oneof have presence.</span>
    <span class="s4">if </span><span class="s1">(is_proto3 </span><span class="s4">and </span><span class="s1">field.cpp_type != _FieldDescriptor.CPPTYPE_MESSAGE </span><span class="s4">and</span>
        <span class="s4">not </span><span class="s1">field.containing_oneof):</span>
      <span class="s4">continue</span>
    <span class="s1">hassable_fields[field.name] = field</span>

  <span class="s0"># Has methods are supported for oneof descriptors.</span>
  <span class="s4">for </span><span class="s1">oneof </span><span class="s4">in </span><span class="s1">message_descriptor.oneofs:</span>
    <span class="s1">hassable_fields[oneof.name] = oneof</span>

  <span class="s4">def </span><span class="s1">HasField(self</span><span class="s4">, </span><span class="s1">field_name):</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">field = hassable_fields[field_name]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">raise </span><span class="s1">ValueError(error_msg % (message_descriptor.full_name</span><span class="s4">, </span><span class="s1">field_name))</span>

    <span class="s4">if </span><span class="s1">isinstance(field</span><span class="s4">, </span><span class="s1">descriptor_mod.OneofDescriptor):</span>
      <span class="s4">try</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">HasField(self</span><span class="s4">, </span><span class="s1">self._oneofs[field].name)</span>
      <span class="s4">except </span><span class="s1">KeyError:</span>
        <span class="s4">return False</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
        <span class="s1">value = self._fields.get(field)</span>
        <span class="s4">return </span><span class="s1">value </span><span class="s4">is not None and </span><span class="s1">value._is_present_in_parent</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s4">return </span><span class="s1">field </span><span class="s4">in </span><span class="s1">self._fields</span>

  <span class="s1">cls.HasField = HasField</span>


<span class="s4">def </span><span class="s1">_AddClearFieldMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">ClearField(self</span><span class="s4">, </span><span class="s1">field_name):</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">field = message_descriptor.fields_by_name[field_name]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">try</span><span class="s1">:</span>
        <span class="s1">field = message_descriptor.oneofs_by_name[field_name]</span>
        <span class="s4">if </span><span class="s1">field </span><span class="s4">in </span><span class="s1">self._oneofs:</span>
          <span class="s1">field = self._oneofs[field]</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s4">return</span>
      <span class="s4">except </span><span class="s1">KeyError:</span>
        <span class="s4">raise </span><span class="s1">ValueError(</span><span class="s3">'Protocol message %s has no &quot;%s&quot; field.' </span><span class="s1">%</span>
                         <span class="s1">(message_descriptor.name</span><span class="s4">, </span><span class="s1">field_name))</span>

    <span class="s4">if </span><span class="s1">field </span><span class="s4">in </span><span class="s1">self._fields:</span>
      <span class="s0"># To match the C++ implementation, we need to invalidate iterators</span>
      <span class="s0"># for map fields when ClearField() happens.</span>
      <span class="s4">if </span><span class="s1">hasattr(self._fields[field]</span><span class="s4">, </span><span class="s3">'InvalidateIterators'</span><span class="s1">):</span>
        <span class="s1">self._fields[field].InvalidateIterators()</span>

      <span class="s0"># Note:  If the field is a sub-message, its listener will still point</span>
      <span class="s0">#   at us.  That's fine, because the worst than can happen is that it</span>
      <span class="s0">#   will call _Modified() and invalidate our byte size.  Big deal.</span>
      <span class="s4">del </span><span class="s1">self._fields[field]</span>

      <span class="s4">if </span><span class="s1">self._oneofs.get(field.containing_oneof</span><span class="s4">, None</span><span class="s1">) </span><span class="s4">is </span><span class="s1">field:</span>
        <span class="s4">del </span><span class="s1">self._oneofs[field.containing_oneof]</span>

    <span class="s0"># Always call _Modified() -- even if nothing was changed, this is</span>
    <span class="s0"># a mutating method, and thus calling it should cause the field to become</span>
    <span class="s0"># present in the parent message.</span>
    <span class="s1">self._Modified()</span>

  <span class="s1">cls.ClearField = ClearField</span>


<span class="s4">def </span><span class="s1">_AddClearExtensionMethod(cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">ClearExtension(self</span><span class="s4">, </span><span class="s1">extension_handle):</span>
    <span class="s1">extension_dict._VerifyExtensionHandle(self</span><span class="s4">, </span><span class="s1">extension_handle)</span>

    <span class="s0"># Similar to ClearField(), above.</span>
    <span class="s4">if </span><span class="s1">extension_handle </span><span class="s4">in </span><span class="s1">self._fields:</span>
      <span class="s4">del </span><span class="s1">self._fields[extension_handle]</span>
    <span class="s1">self._Modified()</span>
  <span class="s1">cls.ClearExtension = ClearExtension</span>


<span class="s4">def </span><span class="s1">_AddHasExtensionMethod(cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">HasExtension(self</span><span class="s4">, </span><span class="s1">extension_handle):</span>
    <span class="s1">extension_dict._VerifyExtensionHandle(self</span><span class="s4">, </span><span class="s1">extension_handle)</span>
    <span class="s4">if </span><span class="s1">extension_handle.label == _FieldDescriptor.LABEL_REPEATED:</span>
      <span class="s4">raise </span><span class="s1">KeyError(</span><span class="s3">'&quot;%s&quot; is repeated.' </span><span class="s1">% extension_handle.full_name)</span>

    <span class="s4">if </span><span class="s1">extension_handle.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
      <span class="s1">value = self._fields.get(extension_handle)</span>
      <span class="s4">return </span><span class="s1">value </span><span class="s4">is not None and </span><span class="s1">value._is_present_in_parent</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">return </span><span class="s1">extension_handle </span><span class="s4">in </span><span class="s1">self._fields</span>
  <span class="s1">cls.HasExtension = HasExtension</span>

<span class="s4">def </span><span class="s1">_InternalUnpackAny(msg):</span>
  <span class="s2">&quot;&quot;&quot;Unpacks Any message and returns the unpacked message. 
 
  This internal method is different from public Any Unpack method which takes 
  the target message as argument. _InternalUnpackAny method does not have 
  target message type and need to find the message type in descriptor pool. 
 
  Args: 
    msg: An Any message to be unpacked. 
 
  Returns: 
    The unpacked message. 
  &quot;&quot;&quot;</span>
  <span class="s0"># TODO(amauryfa): Don't use the factory of generated messages.</span>
  <span class="s0"># To make Any work with custom factories, use the message factory of the</span>
  <span class="s0"># parent message.</span>
  <span class="s0"># pylint: disable=g-import-not-at-top</span>
  <span class="s4">from </span><span class="s1">google.protobuf </span><span class="s4">import </span><span class="s1">symbol_database</span>
  <span class="s1">factory = symbol_database.Default()</span>

  <span class="s1">type_url = msg.type_url</span>

  <span class="s4">if not </span><span class="s1">type_url:</span>
    <span class="s4">return None</span>

  <span class="s0"># TODO(haberman): For now we just strip the hostname.  Better logic will be</span>
  <span class="s0"># required.</span>
  <span class="s1">type_name = type_url.split(</span><span class="s3">'/'</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>
  <span class="s1">descriptor = factory.pool.FindMessageTypeByName(type_name)</span>

  <span class="s4">if </span><span class="s1">descriptor </span><span class="s4">is None</span><span class="s1">:</span>
    <span class="s4">return None</span>

  <span class="s1">message_class = factory.GetPrototype(descriptor)</span>
  <span class="s1">message = message_class()</span>

  <span class="s1">message.ParseFromString(msg.value)</span>
  <span class="s4">return </span><span class="s1">message</span>


<span class="s4">def </span><span class="s1">_AddEqualsMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">__eq__(self</span><span class="s4">, </span><span class="s1">other):</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">not </span><span class="s1">isinstance(other</span><span class="s4">, </span><span class="s1">message_mod.Message) </span><span class="s4">or</span>
        <span class="s1">other.DESCRIPTOR != self.DESCRIPTOR):</span>
      <span class="s4">return False</span>

    <span class="s4">if </span><span class="s1">self </span><span class="s4">is </span><span class="s1">other:</span>
      <span class="s4">return True</span>

    <span class="s4">if </span><span class="s1">self.DESCRIPTOR.full_name == _AnyFullTypeName:</span>
      <span class="s1">any_a = _InternalUnpackAny(self)</span>
      <span class="s1">any_b = _InternalUnpackAny(other)</span>
      <span class="s4">if </span><span class="s1">any_a </span><span class="s4">and </span><span class="s1">any_b:</span>
        <span class="s4">return </span><span class="s1">any_a == any_b</span>

    <span class="s4">if not </span><span class="s1">self.ListFields() == other.ListFields():</span>
      <span class="s4">return False</span>

    <span class="s0"># TODO(jieluo): Fix UnknownFieldSet to consider MessageSet extensions,</span>
    <span class="s0"># then use it for the comparison.</span>
    <span class="s1">unknown_fields = list(self._unknown_fields)</span>
    <span class="s1">unknown_fields.sort()</span>
    <span class="s1">other_unknown_fields = list(other._unknown_fields)</span>
    <span class="s1">other_unknown_fields.sort()</span>
    <span class="s4">return </span><span class="s1">unknown_fields == other_unknown_fields</span>

  <span class="s1">cls.__eq__ = __eq__</span>


<span class="s4">def </span><span class="s1">_AddStrMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">__str__(self):</span>
    <span class="s4">return </span><span class="s1">text_format.MessageToString(self)</span>
  <span class="s1">cls.__str__ = __str__</span>


<span class="s4">def </span><span class="s1">_AddReprMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">__repr__(self):</span>
    <span class="s4">return </span><span class="s1">text_format.MessageToString(self)</span>
  <span class="s1">cls.__repr__ = __repr__</span>


<span class="s4">def </span><span class="s1">_AddUnicodeMethod(unused_message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">__unicode__(self):</span>
    <span class="s4">return </span><span class="s1">text_format.MessageToString(self</span><span class="s4">, </span><span class="s1">as_utf8=</span><span class="s4">True</span><span class="s1">).decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
  <span class="s1">cls.__unicode__ = __unicode__</span>


<span class="s4">def </span><span class="s1">_BytesForNonRepeatedElement(value</span><span class="s4">, </span><span class="s1">field_number</span><span class="s4">, </span><span class="s1">field_type):</span>
  <span class="s2">&quot;&quot;&quot;Returns the number of bytes needed to serialize a non-repeated element. 
  The returned byte count includes space for tag information and any 
  other additional space associated with serializing value. 
 
  Args: 
    value: Value we're serializing. 
    field_number: Field number of this value.  (Since the field number 
      is stored as part of a varint-encoded tag, this has an impact 
      on the total bytes required to serialize the value). 
    field_type: The type of the field.  One of the TYPE_* constants 
      within FieldDescriptor. 
  &quot;&quot;&quot;</span>
  <span class="s4">try</span><span class="s1">:</span>
    <span class="s1">fn = type_checkers.TYPE_TO_BYTE_SIZE_FN[field_type]</span>
    <span class="s4">return </span><span class="s1">fn(field_number</span><span class="s4">, </span><span class="s1">value)</span>
  <span class="s4">except </span><span class="s1">KeyError:</span>
    <span class="s4">raise </span><span class="s1">message_mod.EncodeError(</span><span class="s3">'Unrecognized field type: %d' </span><span class="s1">% field_type)</span>


<span class="s4">def </span><span class="s1">_AddByteSizeMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">ByteSize(self):</span>
    <span class="s4">if not </span><span class="s1">self._cached_byte_size_dirty:</span>
      <span class="s4">return </span><span class="s1">self._cached_byte_size</span>

    <span class="s1">size = </span><span class="s5">0</span>
    <span class="s1">descriptor = self.DESCRIPTOR</span>
    <span class="s4">if </span><span class="s1">descriptor.GetOptions().map_entry:</span>
      <span class="s0"># Fields of map entry should always be serialized.</span>
      <span class="s1">size = descriptor.fields_by_name[</span><span class="s3">'key'</span><span class="s1">]._sizer(self.key)</span>
      <span class="s1">size += descriptor.fields_by_name[</span><span class="s3">'value'</span><span class="s1">]._sizer(self.value)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">for </span><span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">field_value </span><span class="s4">in </span><span class="s1">self.ListFields():</span>
        <span class="s1">size += field_descriptor._sizer(field_value)</span>
      <span class="s4">for </span><span class="s1">tag_bytes</span><span class="s4">, </span><span class="s1">value_bytes </span><span class="s4">in </span><span class="s1">self._unknown_fields:</span>
        <span class="s1">size += len(tag_bytes) + len(value_bytes)</span>

    <span class="s1">self._cached_byte_size = size</span>
    <span class="s1">self._cached_byte_size_dirty = </span><span class="s4">False</span>
    <span class="s1">self._listener_for_children.dirty = </span><span class="s4">False</span>
    <span class="s4">return </span><span class="s1">size</span>

  <span class="s1">cls.ByteSize = ByteSize</span>


<span class="s4">def </span><span class="s1">_AddSerializeToStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">SerializeToString(self</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s0"># Check if the message has all of its required fields set.</span>
    <span class="s4">if not </span><span class="s1">self.IsInitialized():</span>
      <span class="s4">raise </span><span class="s1">message_mod.EncodeError(</span>
          <span class="s3">'Message %s is missing required fields: %s' </span><span class="s1">% (</span>
          <span class="s1">self.DESCRIPTOR.full_name</span><span class="s4">, </span><span class="s3">','</span><span class="s1">.join(self.FindInitializationErrors())))</span>
    <span class="s4">return </span><span class="s1">self.SerializePartialToString(**kwargs)</span>
  <span class="s1">cls.SerializeToString = SerializeToString</span>


<span class="s4">def </span><span class="s1">_AddSerializePartialToStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">SerializePartialToString(self</span><span class="s4">, </span><span class="s1">**kwargs):</span>
    <span class="s1">out = BytesIO()</span>
    <span class="s1">self._InternalSerialize(out.write</span><span class="s4">, </span><span class="s1">**kwargs)</span>
    <span class="s4">return </span><span class="s1">out.getvalue()</span>
  <span class="s1">cls.SerializePartialToString = SerializePartialToString</span>

  <span class="s4">def </span><span class="s1">InternalSerialize(self</span><span class="s4">, </span><span class="s1">write_bytes</span><span class="s4">, </span><span class="s1">deterministic=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s4">if </span><span class="s1">deterministic </span><span class="s4">is None</span><span class="s1">:</span>
      <span class="s1">deterministic = (</span>
          <span class="s1">api_implementation.IsPythonDefaultSerializationDeterministic())</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">deterministic = bool(deterministic)</span>

    <span class="s1">descriptor = self.DESCRIPTOR</span>
    <span class="s4">if </span><span class="s1">descriptor.GetOptions().map_entry:</span>
      <span class="s0"># Fields of map entry should always be serialized.</span>
      <span class="s1">descriptor.fields_by_name[</span><span class="s3">'key'</span><span class="s1">]._encoder(</span>
          <span class="s1">write_bytes</span><span class="s4">, </span><span class="s1">self.key</span><span class="s4">, </span><span class="s1">deterministic)</span>
      <span class="s1">descriptor.fields_by_name[</span><span class="s3">'value'</span><span class="s1">]._encoder(</span>
          <span class="s1">write_bytes</span><span class="s4">, </span><span class="s1">self.value</span><span class="s4">, </span><span class="s1">deterministic)</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">for </span><span class="s1">field_descriptor</span><span class="s4">, </span><span class="s1">field_value </span><span class="s4">in </span><span class="s1">self.ListFields():</span>
        <span class="s1">field_descriptor._encoder(write_bytes</span><span class="s4">, </span><span class="s1">field_value</span><span class="s4">, </span><span class="s1">deterministic)</span>
      <span class="s4">for </span><span class="s1">tag_bytes</span><span class="s4">, </span><span class="s1">value_bytes </span><span class="s4">in </span><span class="s1">self._unknown_fields:</span>
        <span class="s1">write_bytes(tag_bytes)</span>
        <span class="s1">write_bytes(value_bytes)</span>
  <span class="s1">cls._InternalSerialize = InternalSerialize</span>


<span class="s4">def </span><span class="s1">_AddMergeFromStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Helper for _AddMessageMethods().&quot;&quot;&quot;</span>
  <span class="s4">def </span><span class="s1">MergeFromString(self</span><span class="s4">, </span><span class="s1">serialized):</span>
    <span class="s1">serialized = memoryview(serialized)</span>
    <span class="s1">length = len(serialized)</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s4">if </span><span class="s1">self._InternalParse(serialized</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">length) != length:</span>
        <span class="s0"># The only reason _InternalParse would return early is if it</span>
        <span class="s0"># encountered an end-group tag.</span>
        <span class="s4">raise </span><span class="s1">message_mod.DecodeError(</span><span class="s3">'Unexpected end-group tag.'</span><span class="s1">)</span>
    <span class="s4">except </span><span class="s1">(IndexError</span><span class="s4">, </span><span class="s1">TypeError):</span>
      <span class="s0"># Now ord(buf[p:p+1]) == ord('') gets TypeError.</span>
      <span class="s4">raise </span><span class="s1">message_mod.DecodeError(</span><span class="s3">'Truncated message.'</span><span class="s1">)</span>
    <span class="s4">except </span><span class="s1">struct.error </span><span class="s4">as </span><span class="s1">e:</span>
      <span class="s4">raise </span><span class="s1">message_mod.DecodeError(e)</span>
    <span class="s4">return </span><span class="s1">length   </span><span class="s0"># Return this for legacy reasons.</span>
  <span class="s1">cls.MergeFromString = MergeFromString</span>

  <span class="s1">local_ReadTag = decoder.ReadTag</span>
  <span class="s1">local_SkipField = decoder.SkipField</span>
  <span class="s1">decoders_by_tag = cls._decoders_by_tag</span>

  <span class="s4">def </span><span class="s1">InternalParse(self</span><span class="s4">, </span><span class="s1">buffer</span><span class="s4">, </span><span class="s1">pos</span><span class="s4">, </span><span class="s1">end):</span>
    <span class="s2">&quot;&quot;&quot;Create a message from serialized bytes. 
 
    Args: 
      self: Message, instance of the proto message object. 
      buffer: memoryview of the serialized data. 
      pos: int, position to start in the serialized data. 
      end: int, end position of the serialized data. 
 
    Returns: 
      Message object. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Guard against internal misuse, since this function is called internally</span>
    <span class="s0"># quite extensively, and its easy to accidentally pass bytes.</span>
    <span class="s4">assert </span><span class="s1">isinstance(buffer</span><span class="s4">, </span><span class="s1">memoryview)</span>
    <span class="s1">self._Modified()</span>
    <span class="s1">field_dict = self._fields</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">unknown_field_set = self._unknown_field_set</span>
    <span class="s4">while </span><span class="s1">pos != end:</span>
      <span class="s1">(tag_bytes</span><span class="s4">, </span><span class="s1">new_pos) = local_ReadTag(buffer</span><span class="s4">, </span><span class="s1">pos)</span>
      <span class="s1">field_decoder</span><span class="s4">, </span><span class="s1">field_desc = decoders_by_tag.get(tag_bytes</span><span class="s4">, </span><span class="s1">(</span><span class="s4">None, None</span><span class="s1">))</span>
      <span class="s4">if </span><span class="s1">field_decoder </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s4">if not </span><span class="s1">self._unknown_fields:   </span><span class="s0"># pylint: disable=protected-access</span>
          <span class="s1">self._unknown_fields = []    </span><span class="s0"># pylint: disable=protected-access</span>
        <span class="s4">if </span><span class="s1">unknown_field_set </span><span class="s4">is None</span><span class="s1">:</span>
          <span class="s0"># pylint: disable=protected-access</span>
          <span class="s1">self._unknown_field_set = containers.UnknownFieldSet()</span>
          <span class="s0"># pylint: disable=protected-access</span>
          <span class="s1">unknown_field_set = self._unknown_field_set</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">(tag</span><span class="s4">, </span><span class="s1">_) = decoder._DecodeVarint(tag_bytes</span><span class="s4">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">field_number</span><span class="s4">, </span><span class="s1">wire_type = wire_format.UnpackTag(tag)</span>
        <span class="s4">if </span><span class="s1">field_number == </span><span class="s5">0</span><span class="s1">:</span>
          <span class="s4">raise </span><span class="s1">message_mod.DecodeError(</span><span class="s3">'Field number 0 is illegal.'</span><span class="s1">)</span>
        <span class="s0"># TODO(jieluo): remove old_pos.</span>
        <span class="s1">old_pos = new_pos</span>
        <span class="s1">(data</span><span class="s4">, </span><span class="s1">new_pos) = decoder._DecodeUnknownField(</span>
            <span class="s1">buffer</span><span class="s4">, </span><span class="s1">new_pos</span><span class="s4">, </span><span class="s1">wire_type)  </span><span class="s0"># pylint: disable=protected-access</span>
        <span class="s4">if </span><span class="s1">new_pos == -</span><span class="s5">1</span><span class="s1">:</span>
          <span class="s4">return </span><span class="s1">pos</span>
        <span class="s0"># pylint: disable=protected-access</span>
        <span class="s1">unknown_field_set._add(field_number</span><span class="s4">, </span><span class="s1">wire_type</span><span class="s4">, </span><span class="s1">data)</span>
        <span class="s0"># TODO(jieluo): remove _unknown_fields.</span>
        <span class="s1">new_pos = local_SkipField(buffer</span><span class="s4">, </span><span class="s1">old_pos</span><span class="s4">, </span><span class="s1">end</span><span class="s4">, </span><span class="s1">tag_bytes)</span>
        <span class="s4">if </span><span class="s1">new_pos == -</span><span class="s5">1</span><span class="s1">:</span>
          <span class="s4">return </span><span class="s1">pos</span>
        <span class="s1">self._unknown_fields.append(</span>
            <span class="s1">(tag_bytes</span><span class="s4">, </span><span class="s1">buffer[old_pos:new_pos].tobytes()))</span>
        <span class="s1">pos = new_pos</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">pos = field_decoder(buffer</span><span class="s4">, </span><span class="s1">new_pos</span><span class="s4">, </span><span class="s1">end</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">field_dict)</span>
        <span class="s4">if </span><span class="s1">field_desc:</span>
          <span class="s1">self._UpdateOneofState(field_desc)</span>
    <span class="s4">return </span><span class="s1">pos</span>
  <span class="s1">cls._InternalParse = InternalParse</span>


<span class="s4">def </span><span class="s1">_AddIsInitializedMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds the IsInitialized and FindInitializationError methods to the 
  protocol message class.&quot;&quot;&quot;</span>

  <span class="s1">required_fields = [field </span><span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">message_descriptor.fields</span>
                           <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REQUIRED]</span>

  <span class="s4">def </span><span class="s1">IsInitialized(self</span><span class="s4">, </span><span class="s1">errors=</span><span class="s4">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Checks if all required fields of a message are set. 
 
    Args: 
      errors:  A list which, if provided, will be populated with the field 
               paths of all missing required fields. 
 
    Returns: 
      True iff the specified message has all required fields set. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Performance is critical so we avoid HasField() and ListFields().</span>

    <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">required_fields:</span>
      <span class="s4">if </span><span class="s1">(field </span><span class="s4">not in </span><span class="s1">self._fields </span><span class="s4">or</span>
          <span class="s1">(field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE </span><span class="s4">and</span>
           <span class="s4">not </span><span class="s1">self._fields[field]._is_present_in_parent)):</span>
        <span class="s4">if </span><span class="s1">errors </span><span class="s4">is not None</span><span class="s1">:</span>
          <span class="s1">errors.extend(self.FindInitializationErrors())</span>
        <span class="s4">return False</span>

    <span class="s4">for </span><span class="s1">field</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">list(self._fields.items()):  </span><span class="s0"># dict can change size!</span>
      <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
        <span class="s4">if </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
          <span class="s4">if </span><span class="s1">(field.message_type.has_options </span><span class="s4">and</span>
              <span class="s1">field.message_type.GetOptions().map_entry):</span>
            <span class="s4">continue</span>
          <span class="s4">for </span><span class="s1">element </span><span class="s4">in </span><span class="s1">value:</span>
            <span class="s4">if not </span><span class="s1">element.IsInitialized():</span>
              <span class="s4">if </span><span class="s1">errors </span><span class="s4">is not None</span><span class="s1">:</span>
                <span class="s1">errors.extend(self.FindInitializationErrors())</span>
              <span class="s4">return False</span>
        <span class="s4">elif </span><span class="s1">value._is_present_in_parent </span><span class="s4">and not </span><span class="s1">value.IsInitialized():</span>
          <span class="s4">if </span><span class="s1">errors </span><span class="s4">is not None</span><span class="s1">:</span>
            <span class="s1">errors.extend(self.FindInitializationErrors())</span>
          <span class="s4">return False</span>

    <span class="s4">return True</span>

  <span class="s1">cls.IsInitialized = IsInitialized</span>

  <span class="s4">def </span><span class="s1">FindInitializationErrors(self):</span>
    <span class="s2">&quot;&quot;&quot;Finds required fields which are not initialized. 
 
    Returns: 
      A list of strings.  Each string is a path to an uninitialized field from 
      the top-level message, e.g. &quot;foo.bar[5].baz&quot;. 
    &quot;&quot;&quot;</span>

    <span class="s1">errors = []  </span><span class="s0"># simplify things</span>

    <span class="s4">for </span><span class="s1">field </span><span class="s4">in </span><span class="s1">required_fields:</span>
      <span class="s4">if not </span><span class="s1">self.HasField(field.name):</span>
        <span class="s1">errors.append(field.name)</span>

    <span class="s4">for </span><span class="s1">field</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">self.ListFields():</span>
      <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
        <span class="s4">if </span><span class="s1">field.is_extension:</span>
          <span class="s1">name = </span><span class="s3">'(%s)' </span><span class="s1">% field.full_name</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s1">name = field.name</span>

        <span class="s4">if </span><span class="s1">_IsMapField(field):</span>
          <span class="s4">if </span><span class="s1">_IsMessageMapField(field):</span>
            <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">value:</span>
              <span class="s1">element = value[key]</span>
              <span class="s1">prefix = </span><span class="s3">'%s[%s].' </span><span class="s1">% (name</span><span class="s4">, </span><span class="s1">key)</span>
              <span class="s1">sub_errors = element.FindInitializationErrors()</span>
              <span class="s1">errors += [prefix + error </span><span class="s4">for </span><span class="s1">error </span><span class="s4">in </span><span class="s1">sub_errors]</span>
          <span class="s4">else</span><span class="s1">:</span>
            <span class="s0"># ScalarMaps can't have any initialization errors.</span>
            <span class="s4">pass</span>
        <span class="s4">elif </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
          <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range(len(value)):</span>
            <span class="s1">element = value[i]</span>
            <span class="s1">prefix = </span><span class="s3">'%s[%d].' </span><span class="s1">% (name</span><span class="s4">, </span><span class="s1">i)</span>
            <span class="s1">sub_errors = element.FindInitializationErrors()</span>
            <span class="s1">errors += [prefix + error </span><span class="s4">for </span><span class="s1">error </span><span class="s4">in </span><span class="s1">sub_errors]</span>
        <span class="s4">else</span><span class="s1">:</span>
          <span class="s1">prefix = name + </span><span class="s3">'.'</span>
          <span class="s1">sub_errors = value.FindInitializationErrors()</span>
          <span class="s1">errors += [prefix + error </span><span class="s4">for </span><span class="s1">error </span><span class="s4">in </span><span class="s1">sub_errors]</span>

    <span class="s4">return </span><span class="s1">errors</span>

  <span class="s1">cls.FindInitializationErrors = FindInitializationErrors</span>


<span class="s4">def </span><span class="s1">_FullyQualifiedClassName(klass):</span>
  <span class="s1">module = klass.__module__</span>
  <span class="s1">name = getattr(klass</span><span class="s4">, </span><span class="s3">'__qualname__'</span><span class="s4">, </span><span class="s1">klass.__name__)</span>
  <span class="s4">if </span><span class="s1">module </span><span class="s4">in </span><span class="s1">(</span><span class="s4">None, </span><span class="s3">'builtins'</span><span class="s4">, </span><span class="s3">'__builtin__'</span><span class="s1">):</span>
    <span class="s4">return </span><span class="s1">name</span>
  <span class="s4">return </span><span class="s1">module + </span><span class="s3">'.' </span><span class="s1">+ name</span>


<span class="s4">def </span><span class="s1">_AddMergeFromMethod(cls):</span>
  <span class="s1">LABEL_REPEATED = _FieldDescriptor.LABEL_REPEATED</span>
  <span class="s1">CPPTYPE_MESSAGE = _FieldDescriptor.CPPTYPE_MESSAGE</span>

  <span class="s4">def </span><span class="s1">MergeFrom(self</span><span class="s4">, </span><span class="s1">msg):</span>
    <span class="s4">if not </span><span class="s1">isinstance(msg</span><span class="s4">, </span><span class="s1">cls):</span>
      <span class="s4">raise </span><span class="s1">TypeError(</span>
          <span class="s3">'Parameter to MergeFrom() must be instance of same class: '</span>
          <span class="s3">'expected %s got %s.' </span><span class="s1">% (_FullyQualifiedClassName(cls)</span><span class="s4">,</span>
                                   <span class="s1">_FullyQualifiedClassName(msg.__class__)))</span>

    <span class="s4">assert </span><span class="s1">msg </span><span class="s4">is not </span><span class="s1">self</span>
    <span class="s1">self._Modified()</span>

    <span class="s1">fields = self._fields</span>

    <span class="s4">for </span><span class="s1">field</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">msg._fields.items():</span>
      <span class="s4">if </span><span class="s1">field.label == LABEL_REPEATED:</span>
        <span class="s1">field_value = fields.get(field)</span>
        <span class="s4">if </span><span class="s1">field_value </span><span class="s4">is None</span><span class="s1">:</span>
          <span class="s0"># Construct a new object to represent this field.</span>
          <span class="s1">field_value = field._default_constructor(self)</span>
          <span class="s1">fields[field] = field_value</span>
        <span class="s1">field_value.MergeFrom(value)</span>
      <span class="s4">elif </span><span class="s1">field.cpp_type == CPPTYPE_MESSAGE:</span>
        <span class="s4">if </span><span class="s1">value._is_present_in_parent:</span>
          <span class="s1">field_value = fields.get(field)</span>
          <span class="s4">if </span><span class="s1">field_value </span><span class="s4">is None</span><span class="s1">:</span>
            <span class="s0"># Construct a new object to represent this field.</span>
            <span class="s1">field_value = field._default_constructor(self)</span>
            <span class="s1">fields[field] = field_value</span>
          <span class="s1">field_value.MergeFrom(value)</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">self._fields[field] = value</span>
        <span class="s4">if </span><span class="s1">field.containing_oneof:</span>
          <span class="s1">self._UpdateOneofState(field)</span>

    <span class="s4">if </span><span class="s1">msg._unknown_fields:</span>
      <span class="s4">if not </span><span class="s1">self._unknown_fields:</span>
        <span class="s1">self._unknown_fields = []</span>
      <span class="s1">self._unknown_fields.extend(msg._unknown_fields)</span>
      <span class="s0"># pylint: disable=protected-access</span>
      <span class="s4">if </span><span class="s1">self._unknown_field_set </span><span class="s4">is None</span><span class="s1">:</span>
        <span class="s1">self._unknown_field_set = containers.UnknownFieldSet()</span>
      <span class="s1">self._unknown_field_set._extend(msg._unknown_field_set)</span>

  <span class="s1">cls.MergeFrom = MergeFrom</span>


<span class="s4">def </span><span class="s1">_AddWhichOneofMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s4">def </span><span class="s1">WhichOneof(self</span><span class="s4">, </span><span class="s1">oneof_name):</span>
    <span class="s2">&quot;&quot;&quot;Returns the name of the currently set field inside a oneof, or None.&quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">field = message_descriptor.oneofs_by_name[oneof_name]</span>
    <span class="s4">except </span><span class="s1">KeyError:</span>
      <span class="s4">raise </span><span class="s1">ValueError(</span>
          <span class="s3">'Protocol message has no oneof &quot;%s&quot; field.' </span><span class="s1">% oneof_name)</span>

    <span class="s1">nested_field = self._oneofs.get(field</span><span class="s4">, None</span><span class="s1">)</span>
    <span class="s4">if </span><span class="s1">nested_field </span><span class="s4">is not None and </span><span class="s1">self.HasField(nested_field.name):</span>
      <span class="s4">return </span><span class="s1">nested_field.name</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s4">return None</span>

  <span class="s1">cls.WhichOneof = WhichOneof</span>


<span class="s4">def </span><span class="s1">_Clear(self):</span>
  <span class="s0"># Clear fields.</span>
  <span class="s1">self._fields = {}</span>
  <span class="s1">self._unknown_fields = ()</span>
  <span class="s0"># pylint: disable=protected-access</span>
  <span class="s4">if </span><span class="s1">self._unknown_field_set </span><span class="s4">is not None</span><span class="s1">:</span>
    <span class="s1">self._unknown_field_set._clear()</span>
    <span class="s1">self._unknown_field_set = </span><span class="s4">None</span>

  <span class="s1">self._oneofs = {}</span>
  <span class="s1">self._Modified()</span>


<span class="s4">def </span><span class="s1">_UnknownFields(self):</span>
  <span class="s4">if </span><span class="s1">self._unknown_field_set </span><span class="s4">is None</span><span class="s1">:  </span><span class="s0"># pylint: disable=protected-access</span>
    <span class="s0"># pylint: disable=protected-access</span>
    <span class="s1">self._unknown_field_set = containers.UnknownFieldSet()</span>
  <span class="s4">return </span><span class="s1">self._unknown_field_set    </span><span class="s0"># pylint: disable=protected-access</span>


<span class="s4">def </span><span class="s1">_DiscardUnknownFields(self):</span>
  <span class="s1">self._unknown_fields = []</span>
  <span class="s1">self._unknown_field_set = </span><span class="s4">None      </span><span class="s0"># pylint: disable=protected-access</span>
  <span class="s4">for </span><span class="s1">field</span><span class="s4">, </span><span class="s1">value </span><span class="s4">in </span><span class="s1">self.ListFields():</span>
    <span class="s4">if </span><span class="s1">field.cpp_type == _FieldDescriptor.CPPTYPE_MESSAGE:</span>
      <span class="s4">if </span><span class="s1">_IsMapField(field):</span>
        <span class="s4">if </span><span class="s1">_IsMessageMapField(field):</span>
          <span class="s4">for </span><span class="s1">key </span><span class="s4">in </span><span class="s1">value:</span>
            <span class="s1">value[key].DiscardUnknownFields()</span>
      <span class="s4">elif </span><span class="s1">field.label == _FieldDescriptor.LABEL_REPEATED:</span>
        <span class="s4">for </span><span class="s1">sub_message </span><span class="s4">in </span><span class="s1">value:</span>
          <span class="s1">sub_message.DiscardUnknownFields()</span>
      <span class="s4">else</span><span class="s1">:</span>
        <span class="s1">value.DiscardUnknownFields()</span>


<span class="s4">def </span><span class="s1">_SetListener(self</span><span class="s4">, </span><span class="s1">listener):</span>
  <span class="s4">if </span><span class="s1">listener </span><span class="s4">is None</span><span class="s1">:</span>
    <span class="s1">self._listener = message_listener_mod.NullMessageListener()</span>
  <span class="s4">else</span><span class="s1">:</span>
    <span class="s1">self._listener = listener</span>


<span class="s4">def </span><span class="s1">_AddMessageMethods(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds implementations of all Message methods to cls.&quot;&quot;&quot;</span>
  <span class="s1">_AddListFieldsMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddHasFieldMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddClearFieldMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s4">if </span><span class="s1">message_descriptor.is_extendable:</span>
    <span class="s1">_AddClearExtensionMethod(cls)</span>
    <span class="s1">_AddHasExtensionMethod(cls)</span>
  <span class="s1">_AddEqualsMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddStrMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddReprMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddUnicodeMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddByteSizeMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddSerializeToStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddSerializePartialToStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddMergeFromStringMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddIsInitializedMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s1">_AddMergeFromMethod(cls)</span>
  <span class="s1">_AddWhichOneofMethod(message_descriptor</span><span class="s4">, </span><span class="s1">cls)</span>
  <span class="s0"># Adds methods which do not depend on cls.</span>
  <span class="s1">cls.Clear = _Clear</span>
  <span class="s1">cls.UnknownFields = _UnknownFields</span>
  <span class="s1">cls.DiscardUnknownFields = _DiscardUnknownFields</span>
  <span class="s1">cls._SetListener = _SetListener</span>


<span class="s4">def </span><span class="s1">_AddPrivateHelperMethods(message_descriptor</span><span class="s4">, </span><span class="s1">cls):</span>
  <span class="s2">&quot;&quot;&quot;Adds implementation of private helper methods to cls.&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">Modified(self):</span>
    <span class="s2">&quot;&quot;&quot;Sets the _cached_byte_size_dirty bit to true, 
    and propagates this to our listener iff this was a state change. 
    &quot;&quot;&quot;</span>

    <span class="s0"># Note:  Some callers check _cached_byte_size_dirty before calling</span>
    <span class="s0">#   _Modified() as an extra optimization.  So, if this method is ever</span>
    <span class="s0">#   changed such that it does stuff even when _cached_byte_size_dirty is</span>
    <span class="s0">#   already true, the callers need to be updated.</span>
    <span class="s4">if not </span><span class="s1">self._cached_byte_size_dirty:</span>
      <span class="s1">self._cached_byte_size_dirty = </span><span class="s4">True</span>
      <span class="s1">self._listener_for_children.dirty = </span><span class="s4">True</span>
      <span class="s1">self._is_present_in_parent = </span><span class="s4">True</span>
      <span class="s1">self._listener.Modified()</span>

  <span class="s4">def </span><span class="s1">_UpdateOneofState(self</span><span class="s4">, </span><span class="s1">field):</span>
    <span class="s2">&quot;&quot;&quot;Sets field as the active field in its containing oneof. 
 
    Will also delete currently active field in the oneof, if it is different 
    from the argument. Does not mark the message as modified. 
    &quot;&quot;&quot;</span>
    <span class="s1">other_field = self._oneofs.setdefault(field.containing_oneof</span><span class="s4">, </span><span class="s1">field)</span>
    <span class="s4">if </span><span class="s1">other_field </span><span class="s4">is not </span><span class="s1">field:</span>
      <span class="s4">del </span><span class="s1">self._fields[other_field]</span>
      <span class="s1">self._oneofs[field.containing_oneof] = field</span>

  <span class="s1">cls._Modified = Modified</span>
  <span class="s1">cls.SetInParent = Modified</span>
  <span class="s1">cls._UpdateOneofState = _UpdateOneofState</span>


<span class="s4">class </span><span class="s1">_Listener(object):</span>

  <span class="s2">&quot;&quot;&quot;MessageListener implementation that a parent message registers with its 
  child message. 
 
  In order to support semantics like: 
 
    foo.bar.baz.qux = 23 
    assert foo.HasField('bar') 
 
  ...child objects must have back references to their parents. 
  This helper class is at the heart of this support. 
  &quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">parent_message):</span>
    <span class="s2">&quot;&quot;&quot;Args: 
      parent_message: The message whose _Modified() method we should call when 
        we receive Modified() messages. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This listener establishes a back reference from a child (contained) object</span>
    <span class="s0"># to its parent (containing) object.  We make this a weak reference to avoid</span>
    <span class="s0"># creating cyclic garbage when the client finishes with the 'parent' object</span>
    <span class="s0"># in the tree.</span>
    <span class="s4">if </span><span class="s1">isinstance(parent_message</span><span class="s4">, </span><span class="s1">weakref.ProxyType):</span>
      <span class="s1">self._parent_message_weakref = parent_message</span>
    <span class="s4">else</span><span class="s1">:</span>
      <span class="s1">self._parent_message_weakref = weakref.proxy(parent_message)</span>

    <span class="s0"># As an optimization, we also indicate directly on the listener whether</span>
    <span class="s0"># or not the parent message is dirty.  This way we can avoid traversing</span>
    <span class="s0"># up the tree in the common case.</span>
    <span class="s1">self.dirty = </span><span class="s4">False</span>

  <span class="s4">def </span><span class="s1">Modified(self):</span>
    <span class="s4">if </span><span class="s1">self.dirty:</span>
      <span class="s4">return</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s0"># Propagate the signal to our parents iff this is the first field set.</span>
      <span class="s1">self._parent_message_weakref._Modified()</span>
    <span class="s4">except </span><span class="s1">ReferenceError:</span>
      <span class="s0"># We can get here if a client has kept a reference to a child object,</span>
      <span class="s0"># and is now setting a field on it, but the child's parent has been</span>
      <span class="s0"># garbage-collected.  This is not an error.</span>
      <span class="s4">pass</span>


<span class="s4">class </span><span class="s1">_OneofListener(_Listener):</span>
  <span class="s2">&quot;&quot;&quot;Special listener implementation for setting composite oneof fields.&quot;&quot;&quot;</span>

  <span class="s4">def </span><span class="s1">__init__(self</span><span class="s4">, </span><span class="s1">parent_message</span><span class="s4">, </span><span class="s1">field):</span>
    <span class="s2">&quot;&quot;&quot;Args: 
      parent_message: The message whose _Modified() method we should call when 
        we receive Modified() messages. 
      field: The descriptor of the field being set in the parent message. 
    &quot;&quot;&quot;</span>
    <span class="s1">super(_OneofListener</span><span class="s4">, </span><span class="s1">self).__init__(parent_message)</span>
    <span class="s1">self._field = field</span>

  <span class="s4">def </span><span class="s1">Modified(self):</span>
    <span class="s2">&quot;&quot;&quot;Also updates the state of the containing oneof in the parent message.&quot;&quot;&quot;</span>
    <span class="s4">try</span><span class="s1">:</span>
      <span class="s1">self._parent_message_weakref._UpdateOneofState(self._field)</span>
      <span class="s1">super(_OneofListener</span><span class="s4">, </span><span class="s1">self).Modified()</span>
    <span class="s4">except </span><span class="s1">ReferenceError:</span>
      <span class="s4">pass</span>
</pre>
</body>
</html>