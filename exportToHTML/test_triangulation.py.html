<html>
<head>
<title>test_triangulation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_triangulation.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_array_less)</span>
<span class="s0">import </span><span class="s1">numpy.ma.testutils </span><span class="s0">as </span><span class="s1">matest</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">import </span><span class="s1">matplotlib.pyplot </span><span class="s0">as </span><span class="s1">plt</span>
<span class="s0">import </span><span class="s1">matplotlib.tri </span><span class="s0">as </span><span class="s1">mtri</span>
<span class="s0">from </span><span class="s1">matplotlib.path </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">matplotlib.testing.decorators </span><span class="s0">import </span><span class="s1">image_comparison</span><span class="s0">, </span><span class="s1">check_figures_equal</span>


<span class="s0">class </span><span class="s1">TestTriangulationParams:</span>
    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span>
    <span class="s1">mask = [</span><span class="s0">False, True</span><span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'args, kwargs, expected'</span><span class="s0">, </span><span class="s1">[</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, None, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles]</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">dict(triangles=triangles)</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">dict(mask=mask)</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, None, </span><span class="s1">mask])</span><span class="s0">,</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles]</span><span class="s0">, </span><span class="s1">dict(mask=mask)</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask])</span><span class="s0">,</span>
        <span class="s1">([x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">dict(triangles=triangles</span><span class="s0">, </span><span class="s1">mask=mask)</span><span class="s0">, </span><span class="s1">[x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask])</span>
    <span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_extract_triangulation_params(self</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s1">other_args = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">other_kwargs = {</span><span class="s3">'a'</span><span class="s1">: </span><span class="s2">3</span><span class="s0">, </span><span class="s3">'b'</span><span class="s1">: </span><span class="s3">'4'</span><span class="s1">}</span>
        <span class="s1">x_</span><span class="s0">, </span><span class="s1">y_</span><span class="s0">, </span><span class="s1">triangles_</span><span class="s0">, </span><span class="s1">mask_</span><span class="s0">, </span><span class="s1">args_</span><span class="s0">, </span><span class="s1">kwargs_ = \</span>
            <span class="s1">mtri.Triangulation._extract_triangulation_params(</span>
                <span class="s1">args + other_args</span><span class="s0">, </span><span class="s1">{**kwargs</span><span class="s0">, </span><span class="s1">**other_kwargs})</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask = expected</span>
        <span class="s0">assert </span><span class="s1">x_ </span><span class="s0">is </span><span class="s1">x</span>
        <span class="s0">assert </span><span class="s1">y_ </span><span class="s0">is </span><span class="s1">y</span>
        <span class="s1">assert_array_equal(triangles_</span><span class="s0">, </span><span class="s1">triangles)</span>
        <span class="s0">assert </span><span class="s1">mask_ </span><span class="s0">is </span><span class="s1">mask</span>
        <span class="s0">assert </span><span class="s1">args_ == other_args</span>
        <span class="s0">assert </span><span class="s1">kwargs_ == other_kwargs</span>


<span class="s0">def </span><span class="s1">test_extract_triangulation_positional_mask():</span>
    <span class="s4"># mask cannot be passed positionally</span>
    <span class="s1">mask = [</span><span class="s0">True</span><span class="s1">]</span>
    <span class="s1">args = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">mask]</span>
    <span class="s1">x_</span><span class="s0">, </span><span class="s1">y_</span><span class="s0">, </span><span class="s1">triangles_</span><span class="s0">, </span><span class="s1">mask_</span><span class="s0">, </span><span class="s1">args_</span><span class="s0">, </span><span class="s1">kwargs_ = \</span>
        <span class="s1">mtri.Triangulation._extract_triangulation_params(args</span><span class="s0">, </span><span class="s1">{})</span>
    <span class="s0">assert </span><span class="s1">mask_ </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">args_ == [mask]</span>
    <span class="s4"># the positional mask must be caught downstream because this must pass</span>
    <span class="s4"># unknown args through</span>


<span class="s0">def </span><span class="s1">test_triangulation_init():</span>
    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;x and y must be equal-length&quot;</span><span class="s1">):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r&quot;triangles must be a \(N, 3\) int array, but found shape &quot;</span>
                  <span class="s3">r&quot;\(3,\)&quot;</span><span class="s1">):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r&quot;triangles must be a \(N, 3\) int array, not 'other'&quot;</span><span class="s1">):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s3">'other'</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;found value 99&quot;</span><span class="s1">):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">99</span><span class="s1">]])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;found value -1&quot;</span><span class="s1">):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]])</span>


<span class="s0">def </span><span class="s1">test_triangulation_set_mask():</span>
    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>

    <span class="s4"># Check neighbors, which forces creation of C++ triangulation</span>
    <span class="s1">assert_array_equal(triang.neighbors</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s4"># Set mask</span>
    <span class="s1">triang.set_mask([</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(triang.mask</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>

    <span class="s4"># Reset mask</span>
    <span class="s1">triang.set_mask(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">triang.mask </span><span class="s0">is None</span>

    <span class="s1">msg = </span><span class="s3">r&quot;mask array must have same length as triangles array&quot;</span>
    <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">([</span><span class="s0">False, True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, False, True</span><span class="s1">):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">triang.set_mask(mask)</span>


<span class="s0">def </span><span class="s1">test_delaunay():</span>
    <span class="s4"># No duplicate points, regular grid.</span>
    <span class="s1">nx = </span><span class="s2">5</span>
    <span class="s1">ny = </span><span class="s2">4</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(np.linspace(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">nx)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">ny))</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>
    <span class="s1">npoints = nx*ny</span>
    <span class="s1">ntriangles = </span><span class="s2">2 </span><span class="s1">* (nx-</span><span class="s2">1</span><span class="s1">) * (ny-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">nedges = </span><span class="s2">3</span><span class="s1">*nx*ny - </span><span class="s2">2</span><span class="s1">*nx - </span><span class="s2">2</span><span class="s1">*ny + </span><span class="s2">1</span>

    <span class="s4"># Create delaunay triangulation.</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s4"># The tests in the remainder of this function should be passed by any</span>
    <span class="s4"># triangulation that does not contain duplicate points.</span>

    <span class="s4"># Points - floating point.</span>
    <span class="s1">assert_array_almost_equal(triang.x</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">assert_array_almost_equal(triang.y</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s4"># Triangles - integers.</span>
    <span class="s0">assert </span><span class="s1">len(triang.triangles) == ntriangles</span>
    <span class="s0">assert </span><span class="s1">np.min(triang.triangles) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">np.max(triang.triangles) == npoints-</span><span class="s2">1</span>

    <span class="s4"># Edges - integers.</span>
    <span class="s0">assert </span><span class="s1">len(triang.edges) == nedges</span>
    <span class="s0">assert </span><span class="s1">np.min(triang.edges) == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">np.max(triang.edges) == npoints-</span><span class="s2">1</span>

    <span class="s4"># Neighbors - integers.</span>
    <span class="s4"># Check that neighbors calculated by C++ triangulation class are the same</span>
    <span class="s4"># as those returned from delaunay routine.</span>
    <span class="s1">neighbors = triang.neighbors</span>
    <span class="s1">triang._neighbors = </span><span class="s0">None</span>
    <span class="s1">assert_array_equal(triang.neighbors</span><span class="s0">, </span><span class="s1">neighbors)</span>

    <span class="s4"># Is each point used in at least one triangle?</span>
    <span class="s1">assert_array_equal(np.unique(triang.triangles)</span><span class="s0">, </span><span class="s1">np.arange(npoints))</span>


<span class="s0">def </span><span class="s1">test_delaunay_duplicate_points():</span>
    <span class="s1">npoints = </span><span class="s2">10</span>
    <span class="s1">duplicate = </span><span class="s2">7</span>
    <span class="s1">duplicate_of = </span><span class="s2">3</span>

    <span class="s1">np.random.seed(</span><span class="s2">23</span><span class="s1">)</span>
    <span class="s1">x = np.random.random(npoints)</span>
    <span class="s1">y = np.random.random(npoints)</span>
    <span class="s1">x[duplicate] = x[duplicate_of]</span>
    <span class="s1">y[duplicate] = y[duplicate_of]</span>

    <span class="s4"># Create delaunay triangulation.</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s4"># Duplicate points should be ignored, so the index of the duplicate points</span>
    <span class="s4"># should not appear in any triangle.</span>
    <span class="s1">assert_array_equal(np.unique(triang.triangles)</span><span class="s0">,</span>
                       <span class="s1">np.delete(np.arange(npoints)</span><span class="s0">, </span><span class="s1">duplicate))</span>


<span class="s0">def </span><span class="s1">test_delaunay_points_in_line():</span>
    <span class="s4"># Cannot triangulate points that are all in a straight line, but check</span>
    <span class="s4"># that delaunay code fails gracefully.</span>
    <span class="s1">x = np.linspace(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>
    <span class="s1">y = np.linspace(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">10.0</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s4"># Add an extra point not on the line and the triangulation is OK.</span>
    <span class="s1">x = np.append(x</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">)</span>
    <span class="s1">y = np.append(y</span><span class="s0">, </span><span class="s2">8.0</span><span class="s1">)</span>
    <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'x, y'</span><span class="s0">, </span><span class="s1">[</span>
    <span class="s4"># Triangulation should raise a ValueError if passed less than 3 points.</span>
    <span class="s1">([]</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s4"># Triangulation should also raise a ValueError if passed duplicate points</span>
    <span class="s4"># such that there are less than 3 unique points.</span>
    <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])</span><span class="s0">,</span>
<span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_delaunay_insufficient_points(x</span><span class="s0">, </span><span class="s1">y):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s0">def </span><span class="s1">test_delaunay_robust():</span>
    <span class="s4"># Fails when mtri.Triangulation uses matplotlib.delaunay, works when using</span>
    <span class="s4"># qhull.</span>
    <span class="s1">tri_points = np.array([</span>
        <span class="s1">[</span><span class="s2">0.8660254037844384</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5000000000000004</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.7577722283113836</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5000000000000004</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.6495190528383288</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5000000000000003</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.5412658773652739</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.5000000000000003</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.811898816047911</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.40625000000000044</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.7036456405748561</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.4062500000000004</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.5953924651018013</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.40625000000000033</span><span class="s1">]])</span>
    <span class="s1">test_points = np.asarray([</span>
        <span class="s1">[</span><span class="s2">0.58</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.46</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.65</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.46</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.65</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.42</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.48</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.44</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.75</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.44</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">0.8</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.48</span><span class="s1">]])</span>

    <span class="s4"># Utility function that indicates if a triangle defined by 3 points</span>
    <span class="s4"># (xtri, ytri) contains the test point xy.  Avoid calling with a point that</span>
    <span class="s4"># lies on or very near to an edge of the triangle.</span>
    <span class="s0">def </span><span class="s1">tri_contains_point(xtri</span><span class="s0">, </span><span class="s1">ytri</span><span class="s0">, </span><span class="s1">xy):</span>
        <span class="s1">tri_points = np.vstack((xtri</span><span class="s0">, </span><span class="s1">ytri)).T</span>
        <span class="s0">return </span><span class="s1">Path(tri_points).contains_point(xy)</span>

    <span class="s4"># Utility function that returns how many triangles of the specified</span>
    <span class="s4"># triangulation contain the test point xy.  Avoid calling with a point that</span>
    <span class="s4"># lies on or very near to an edge of any triangle in the triangulation.</span>
    <span class="s0">def </span><span class="s1">tris_contain_point(triang</span><span class="s0">, </span><span class="s1">xy):</span>
        <span class="s0">return </span><span class="s1">sum(tri_contains_point(triang.x[tri]</span><span class="s0">, </span><span class="s1">triang.y[tri]</span><span class="s0">, </span><span class="s1">xy)</span>
                   <span class="s0">for </span><span class="s1">tri </span><span class="s0">in </span><span class="s1">triang.triangles)</span>

    <span class="s4"># Using matplotlib.delaunay, an invalid triangulation is created with</span>
    <span class="s4"># overlapping triangles; qhull is OK.</span>
    <span class="s1">triang = mtri.Triangulation(tri_points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tri_points[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s0">for </span><span class="s1">test_point </span><span class="s0">in </span><span class="s1">test_points:</span>
        <span class="s0">assert </span><span class="s1">tris_contain_point(triang</span><span class="s0">, </span><span class="s1">test_point) == </span><span class="s2">1</span>

    <span class="s4"># If ignore the first point of tri_points, matplotlib.delaunay throws a</span>
    <span class="s4"># KeyError when calculating the convex hull; qhull is OK.</span>
    <span class="s1">triang = mtri.Triangulation(tri_points[</span><span class="s2">1</span><span class="s1">:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">tri_points[</span><span class="s2">1</span><span class="s1">:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>


<span class="s1">@image_comparison([</span><span class="s3">'tripcolor1.png'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_tripcolor():</span>
    <span class="s1">x = np.asarray([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,   </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">,   </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.75</span><span class="s1">])</span>
    <span class="s1">y = np.asarray([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,   </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">,   </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.75</span><span class="s1">])</span>
    <span class="s1">triangles = np.asarray([</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>

    <span class="s4"># Triangulation with same number of points and triangles.</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>

    <span class="s1">Cpoints = x + </span><span class="s2">0.5</span><span class="s1">*y</span>

    <span class="s1">xmid = x[triang.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">ymid = y[triang.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">Cfaces = </span><span class="s2">0.5</span><span class="s1">*xmid + ymid</span>

    <span class="s1">plt.subplot(</span><span class="s2">121</span><span class="s1">)</span>
    <span class="s1">plt.tripcolor(triang</span><span class="s0">, </span><span class="s1">Cpoints</span><span class="s0">, </span><span class="s1">edgecolors=</span><span class="s3">'k'</span><span class="s1">)</span>
    <span class="s1">plt.title(</span><span class="s3">'point colors'</span><span class="s1">)</span>

    <span class="s1">plt.subplot(</span><span class="s2">122</span><span class="s1">)</span>
    <span class="s1">plt.tripcolor(triang</span><span class="s0">, </span><span class="s1">facecolors=Cfaces</span><span class="s0">, </span><span class="s1">edgecolors=</span><span class="s3">'k'</span><span class="s1">)</span>
    <span class="s1">plt.title(</span><span class="s3">'facecolors'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_tripcolor_color():</span>
    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">r&quot;tripcolor\(\) missing 1 required &quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;The length of c must match either&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">,</span>
                       <span class="s1">match=</span><span class="s3">&quot;length of facecolors must match .* triangles&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">facecolors=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">,</span>
                       <span class="s1">match=</span><span class="s3">&quot;'gouraud' .* at the points.* not at the faces&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">facecolors=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shading=</span><span class="s3">'gouraud'</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">,</span>
                       <span class="s1">match=</span><span class="s3">&quot;'gouraud' .* at the points.* not at the faces&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shading=</span><span class="s3">'gouraud'</span><span class="s1">)  </span><span class="s4"># faces</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">,</span>
                       <span class="s1">match=</span><span class="s3">&quot;positional.*'c'.*keyword-only.*'facecolors'&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">C=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

    <span class="s4"># smoke test for valid color specifications (via C or facecolors)</span>
    <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])  </span><span class="s4"># edges</span>
    <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shading=</span><span class="s3">'gouraud'</span><span class="s1">)  </span><span class="s4"># edges</span>
    <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])  </span><span class="s4"># faces</span>
    <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">facecolors=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])  </span><span class="s4"># faces</span>


<span class="s0">def </span><span class="s1">test_tripcolor_clim():</span>
    <span class="s1">np.random.seed(</span><span class="s2">19680801</span><span class="s1">)</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = np.random.rand(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.rand(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.random.rand(</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s1">ax = plt.figure().add_subplot()</span>
    <span class="s1">clim = (</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.75</span><span class="s1">)</span>
    <span class="s1">norm = ax.tripcolor(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">clim=clim).norm</span>
    <span class="s0">assert </span><span class="s1">(norm.vmin</span><span class="s0">, </span><span class="s1">norm.vmax) == clim</span>


<span class="s0">def </span><span class="s1">test_tripcolor_warnings():</span>
    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">c = [</span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s4"># additional parameters</span>
    <span class="s0">with </span><span class="s1">pytest.warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Additional positional param&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s3">'unused_positional'</span><span class="s1">)</span>
    <span class="s4"># facecolors takes precedence over c</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Positional parameter c .*no effect&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">facecolors=c)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Positional parameter c .*no effect&quot;</span><span class="s1">):</span>
        <span class="s1">ax.tripcolor(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s3">'interpreted as c'</span><span class="s0">, </span><span class="s1">facecolors=c)</span>


<span class="s0">def </span><span class="s1">test_no_modify():</span>
    <span class="s4"># Test that Triangulation does not modify triangles array passed to it.</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">points = np.array([(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1.1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)])</span>

    <span class="s1">old_triangles = triangles.copy()</span>
    <span class="s1">mtri.Triangulation(points[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">points[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">triangles).edges</span>
    <span class="s1">assert_array_equal(old_triangles</span><span class="s0">, </span><span class="s1">triangles)</span>


<span class="s0">def </span><span class="s1">test_trifinder():</span>
    <span class="s4"># Test points within triangles of masked triangulation.</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(np.arange(</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">11</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">14</span><span class="s1">]]</span>
    <span class="s1">mask = np.zeros(len(triangles))</span>
    <span class="s1">mask[</span><span class="s2">8</span><span class="s1">:</span><span class="s2">10</span><span class="s1">] = </span><span class="s2">1</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s1">trifinder = triang.get_trifinder()</span>

    <span class="s1">xs = [</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">2.25</span><span class="s0">, </span><span class="s2">3.25</span><span class="s1">]</span>
    <span class="s1">ys = [</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">2.25</span><span class="s0">, </span><span class="s2">3.25</span><span class="s1">]</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">xs = xs.ravel()</span>
    <span class="s1">ys = ys.ravel()</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">,</span>
                              <span class="s2">12</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">tris = trifinder(xs-</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">ys-</span><span class="s2">0.5</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">,</span>
                              <span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">17</span><span class="s1">])</span>

    <span class="s4"># Test points exactly on boundary edges of masked triangulation.</span>
    <span class="s1">xs = [</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span>
    <span class="s1">ys = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">]</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s1">])</span>

    <span class="s4"># Test points exactly on boundary corners of masked triangulation.</span>
    <span class="s1">xs = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span>
    <span class="s1">ys = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">17</span><span class="s1">])</span>

    <span class="s4">#</span>
    <span class="s4"># Test triangles with horizontal colinear points.  These are not valid</span>
    <span class="s4"># triangulations, but we try to deal with the simplest violations.</span>
    <span class="s4">#</span>

    <span class="s4"># If +ve, triangulation is OK, if -ve triangulation invalid,</span>
    <span class="s4"># if zero have colinear points but should pass tests anyway.</span>
    <span class="s1">delta = </span><span class="s2">0.0</span>

    <span class="s1">x = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">1</span><span class="s0">,  </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">,   </span><span class="s2">1.5</span><span class="s1">]</span>
    <span class="s1">y = [-</span><span class="s2">1</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">delta</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
    <span class="s1">trifinder = triang.get_trifinder()</span>

    <span class="s1">xs = [-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">1.9</span><span class="s0">, </span><span class="s2">2.4</span><span class="s0">, </span><span class="s2">2.9</span><span class="s1">]</span>
    <span class="s1">ys = [-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">]</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s4">#</span>
    <span class="s4"># Test triangles with vertical colinear points.  These are not valid</span>
    <span class="s4"># triangulations, but we try to deal with the simplest violations.</span>
    <span class="s4">#</span>

    <span class="s4"># If +ve, triangulation is OK, if -ve triangulation invalid,</span>
    <span class="s4"># if zero have colinear points but should pass tests anyway.</span>
    <span class="s1">delta = </span><span class="s2">0.0</span>

    <span class="s1">x = [-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-delta</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">,   </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">1</span><span class="s0">,  </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">]</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
    <span class="s1">trifinder = triang.get_trifinder()</span>

    <span class="s1">xs = [-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.1</span><span class="s1">]</span>
    <span class="s1">ys = [-</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">1.9</span><span class="s0">, </span><span class="s2">2.4</span><span class="s0">, </span><span class="s2">2.9</span><span class="s1">]</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">7</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s4"># Test that changing triangulation by setting a mask causes the trifinder</span>
    <span class="s4"># to be reinitialised.</span>
    <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
    <span class="s1">trifinder = triang.get_trifinder()</span>

    <span class="s1">xs = [-</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.8</span><span class="s0">, </span><span class="s2">1.2</span><span class="s1">]</span>
    <span class="s1">ys = [</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s1">triang.set_mask([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">trifinder == triang.get_trifinder()</span>
    <span class="s1">tris = trifinder(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_equal(tris</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_triinterp():</span>
    <span class="s4"># Test points within triangles of masked triangulation.</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(np.arange(</span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>
    <span class="s1">z = </span><span class="s2">1.23</span><span class="s1">*x - </span><span class="s2">4.79</span><span class="s1">*y</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">13</span><span class="s0">, </span><span class="s2">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">,</span>
                 <span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">14</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">11</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">14</span><span class="s1">]]</span>
    <span class="s1">mask = np.zeros(len(triangles))</span>
    <span class="s1">mask[</span><span class="s2">8</span><span class="s1">:</span><span class="s2">10</span><span class="s1">] = </span><span class="s2">1</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask)</span>
    <span class="s1">linear_interp = mtri.LinearTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">cubic_min_E = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>

    <span class="s1">xs = np.linspace(</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">2.75</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
    <span class="s1">ys = [</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">2.25</span><span class="s0">, </span><span class="s2">2.75</span><span class="s1">]</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)  </span><span class="s4"># Testing arrays with array.ndim = 2</span>
    <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(linear_interp</span><span class="s0">, </span><span class="s1">cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
        <span class="s1">zs = interp(xs</span><span class="s0">, </span><span class="s1">ys)</span>
        <span class="s1">assert_array_almost_equal(zs</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.23</span><span class="s1">*xs - </span><span class="s2">4.79</span><span class="s1">*ys))</span>

    <span class="s4"># Test points outside triangulation.</span>
    <span class="s1">xs = [-</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">1.75</span><span class="s0">, </span><span class="s2">3.25</span><span class="s1">]</span>
    <span class="s1">ys = xs</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(linear_interp</span><span class="s0">, </span><span class="s1">cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
        <span class="s1">zs = linear_interp(xs</span><span class="s0">, </span><span class="s1">ys)</span>
        <span class="s1">assert_array_equal(zs.mask</span><span class="s0">, </span><span class="s1">[[</span><span class="s0">True</span><span class="s1">]*</span><span class="s2">4</span><span class="s1">]*</span><span class="s2">4</span><span class="s1">)</span>

    <span class="s4"># Test mixed configuration (outside / inside).</span>
    <span class="s1">xs = np.linspace(</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">1.75</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
    <span class="s1">ys = [</span><span class="s2">0.25</span><span class="s0">, </span><span class="s2">0.75</span><span class="s0">, </span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">1.75</span><span class="s1">]</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(linear_interp</span><span class="s0">, </span><span class="s1">cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
        <span class="s1">zs = interp(xs</span><span class="s0">, </span><span class="s1">ys)</span>
        <span class="s1">matest.assert_array_almost_equal(zs</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.23</span><span class="s1">*xs - </span><span class="s2">4.79</span><span class="s1">*ys))</span>
        <span class="s1">mask = (xs &gt;= </span><span class="s2">1</span><span class="s1">) * (xs &lt;= </span><span class="s2">2</span><span class="s1">) * (ys &gt;= </span><span class="s2">1</span><span class="s1">) * (ys &lt;= </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(zs.mask</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s4"># 2nd order patch test: on a grid with an 'arbitrary shaped' triangle,</span>
    <span class="s4"># patch test shall be exact for quadratic functions and cubic</span>
    <span class="s4"># interpolator if *kind* = user</span>
    <span class="s1">(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c) = (</span><span class="s2">1.23</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.79</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">quad(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">return </span><span class="s1">a*(x-</span><span class="s2">0.5</span><span class="s1">)**</span><span class="s2">2 </span><span class="s1">+ b*(y-</span><span class="s2">0.5</span><span class="s1">)**</span><span class="s2">2 </span><span class="s1">+ c*x*y</span>

    <span class="s0">def </span><span class="s1">gradient_quad(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s2">2</span><span class="s1">*a*(x-</span><span class="s2">0.5</span><span class="s1">) + c*y</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*b*(y-</span><span class="s2">0.5</span><span class="s1">) + c*x)</span>

    <span class="s1">x = np.array([</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.33367</span><span class="s0">, </span><span class="s2">0.669</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.80755</span><span class="s0">, </span><span class="s2">0.4335</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
    <span class="s1">z = quad(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">dz = gradient_quad(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s4"># test points for 2nd order patch test</span>
    <span class="s1">xs = np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">ys = np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">cubic_user = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'user'</span><span class="s0">, </span><span class="s1">dz=dz)</span>
    <span class="s1">interp_zs = cubic_user(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">assert_array_almost_equal(interp_zs</span><span class="s0">, </span><span class="s1">quad(xs</span><span class="s0">, </span><span class="s1">ys))</span>
    <span class="s1">(interp_dzsdx</span><span class="s0">, </span><span class="s1">interp_dzsdy) = cubic_user.gradient(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">(dzsdx</span><span class="s0">, </span><span class="s1">dzsdy) = gradient_quad(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_almost_equal(interp_dzsdx</span><span class="s0">, </span><span class="s1">dzsdx)</span>
    <span class="s1">assert_array_almost_equal(interp_dzsdy</span><span class="s0">, </span><span class="s1">dzsdy)</span>

    <span class="s4"># Cubic improvement: cubic interpolation shall perform better than linear</span>
    <span class="s4"># on a sufficiently dense mesh for a quadratic function.</span>
    <span class="s1">n = </span><span class="s2">11</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>
    <span class="s1">z = quad(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles=meshgrid_triangles(n+</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(np.linspace(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.linspace(</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.9</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
    <span class="s1">xs = xs.ravel()</span>
    <span class="s1">ys = ys.ravel()</span>
    <span class="s1">linear_interp = mtri.LinearTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">cubic_min_E = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>
    <span class="s1">zs = quad(xs</span><span class="s0">, </span><span class="s1">ys)</span>
    <span class="s1">diff_lin = np.abs(linear_interp(xs</span><span class="s0">, </span><span class="s1">ys) - zs)</span>
    <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
        <span class="s1">diff_cubic = np.abs(interp(xs</span><span class="s0">, </span><span class="s1">ys) - zs)</span>
        <span class="s0">assert </span><span class="s1">np.max(diff_lin) &gt;= </span><span class="s2">10 </span><span class="s1">* np.max(diff_cubic)</span>
        <span class="s0">assert </span><span class="s1">(np.dot(diff_lin</span><span class="s0">, </span><span class="s1">diff_lin) &gt;=</span>
                <span class="s2">100 </span><span class="s1">* np.dot(diff_cubic</span><span class="s0">, </span><span class="s1">diff_cubic))</span>


<span class="s0">def </span><span class="s1">test_triinterpcubic_C1_continuity():</span>
    <span class="s4"># Below the 4 tests which demonstrate C1 continuity of the</span>
    <span class="s4"># TriCubicInterpolator (testing the cubic shape functions on arbitrary</span>
    <span class="s4"># triangle):</span>
    <span class="s4">#</span>
    <span class="s4"># 1) Testing continuity of function &amp; derivatives at corner for all 9</span>
    <span class="s4">#    shape functions. Testing also function values at same location.</span>
    <span class="s4"># 2) Testing C1 continuity along each edge (as gradient is polynomial of</span>
    <span class="s4">#    2nd order, it is sufficient to test at the middle).</span>
    <span class="s4"># 3) Testing C1 continuity at triangle barycenter (where the 3 subtriangles</span>
    <span class="s4">#    meet)</span>
    <span class="s4"># 4) Testing C1 continuity at median 1/3 points (midside between 2</span>
    <span class="s4">#    subtriangles)</span>

    <span class="s4"># Utility test function check_continuity</span>
    <span class="s0">def </span><span class="s1">check_continuity(interpolator</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">values=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Checks the continuity of interpolator (and its derivatives) near 
        location loc. Can check the value at loc itself if *values* is 
        provided. 
 
        *interpolator* TriInterpolator 
        *loc* location to test (x0, y0) 
        *values* (optional) array [z0, dzx0, dzy0] to check the value at *loc* 
        &quot;&quot;&quot;</span>
        <span class="s1">n_star = </span><span class="s2">24       </span><span class="s4"># Number of continuity points in a boundary of loc</span>
        <span class="s1">epsilon = </span><span class="s2">1.e-10  </span><span class="s4"># Distance for loc boundary</span>
        <span class="s1">k = </span><span class="s2">100.          </span><span class="s4"># Continuity coefficient</span>
        <span class="s1">(loc_x</span><span class="s0">, </span><span class="s1">loc_y) = loc</span>
        <span class="s1">star_x = loc_x + epsilon*np.cos(np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s1">n_star))</span>
        <span class="s1">star_y = loc_y + epsilon*np.sin(np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s1">n_star))</span>
        <span class="s1">z = interpolator([loc_x]</span><span class="s0">, </span><span class="s1">[loc_y])[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">(dzx</span><span class="s0">, </span><span class="s1">dzy) = interpolator.gradient([loc_x]</span><span class="s0">, </span><span class="s1">[loc_y])</span>
        <span class="s0">if </span><span class="s1">values </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">assert_array_almost_equal(z</span><span class="s0">, </span><span class="s1">values[</span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">assert_array_almost_equal(dzx[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">values[</span><span class="s2">1</span><span class="s1">])</span>
            <span class="s1">assert_array_almost_equal(dzy[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">values[</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">diff_z = interpolator(star_x</span><span class="s0">, </span><span class="s1">star_y) - z</span>
        <span class="s1">(tab_dzx</span><span class="s0">, </span><span class="s1">tab_dzy) = interpolator.gradient(star_x</span><span class="s0">, </span><span class="s1">star_y)</span>
        <span class="s1">diff_dzx = tab_dzx - dzx</span>
        <span class="s1">diff_dzy = tab_dzy - dzy</span>
        <span class="s1">assert_array_less(diff_z</span><span class="s0">, </span><span class="s1">epsilon*k)</span>
        <span class="s1">assert_array_less(diff_dzx</span><span class="s0">, </span><span class="s1">epsilon*k)</span>
        <span class="s1">assert_array_less(diff_dzy</span><span class="s0">, </span><span class="s1">epsilon*k)</span>

    <span class="s4"># Drawing arbitrary triangle (a, b, c) inside a unit square.</span>
    <span class="s1">(ax</span><span class="s0">, </span><span class="s1">ay) = (</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s1">)</span>
    <span class="s1">(bx</span><span class="s0">, </span><span class="s1">by) = (</span><span class="s2">0.33367</span><span class="s0">, </span><span class="s2">0.80755</span><span class="s1">)</span>
    <span class="s1">(cx</span><span class="s0">, </span><span class="s1">cy) = (</span><span class="s2">0.669</span><span class="s0">, </span><span class="s2">0.4335</span><span class="s1">)</span>
    <span class="s1">x = np.array([ax</span><span class="s0">, </span><span class="s1">bx</span><span class="s0">, </span><span class="s1">cx</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>
    <span class="s1">y = np.array([ay</span><span class="s0">, </span><span class="s1">by</span><span class="s0">, </span><span class="s1">cy</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                          <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>

    <span class="s0">for </span><span class="s1">idof </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">9</span><span class="s1">):</span>
        <span class="s1">z = np.zeros(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">dzx = np.zeros(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">dzy = np.zeros(</span><span class="s2">7</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">values = np.zeros([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">case = idof//</span><span class="s2">3</span>
        <span class="s1">values[case</span><span class="s0">, </span><span class="s1">idof % </span><span class="s2">3</span><span class="s1">] = </span><span class="s2">1.0</span>
        <span class="s0">if </span><span class="s1">case == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">z[idof] = </span><span class="s2">1.0</span>
        <span class="s0">elif </span><span class="s1">case == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s1">dzx[idof % </span><span class="s2">3</span><span class="s1">] = </span><span class="s2">1.0</span>
        <span class="s0">elif </span><span class="s1">case == </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s1">dzy[idof % </span><span class="s2">3</span><span class="s1">] = </span><span class="s2">1.0</span>
        <span class="s1">interp = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'user'</span><span class="s0">,</span>
                                           <span class="s1">dz=(dzx</span><span class="s0">, </span><span class="s1">dzy))</span>
        <span class="s4"># Test 1) Checking values and continuity at nodes</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">(ax</span><span class="s0">, </span><span class="s1">ay)</span><span class="s0">, </span><span class="s1">values[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">(bx</span><span class="s0">, </span><span class="s1">by)</span><span class="s0">, </span><span class="s1">values[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">(cx</span><span class="s0">, </span><span class="s1">cy)</span><span class="s0">, </span><span class="s1">values[:</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s4"># Test 2) Checking continuity at midside nodes</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((ax+bx)*</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">(ay+by)*</span><span class="s2">0.5</span><span class="s1">))</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((ax+cx)*</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">(ay+cy)*</span><span class="s2">0.5</span><span class="s1">))</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((cx+bx)*</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">(cy+by)*</span><span class="s2">0.5</span><span class="s1">))</span>
        <span class="s4"># Test 3) Checking continuity at barycenter</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((ax+bx+cx)/</span><span class="s2">3.</span><span class="s0">, </span><span class="s1">(ay+by+cy)/</span><span class="s2">3.</span><span class="s1">))</span>
        <span class="s4"># Test 4) Checking continuity at median 1/3-point</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((</span><span class="s2">4.</span><span class="s1">*ax+bx+cx)/</span><span class="s2">6.</span><span class="s0">, </span><span class="s1">(</span><span class="s2">4.</span><span class="s1">*ay+by+cy)/</span><span class="s2">6.</span><span class="s1">))</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((ax+</span><span class="s2">4.</span><span class="s1">*bx+cx)/</span><span class="s2">6.</span><span class="s0">, </span><span class="s1">(ay+</span><span class="s2">4.</span><span class="s1">*by+cy)/</span><span class="s2">6.</span><span class="s1">))</span>
        <span class="s1">check_continuity(interp</span><span class="s0">, </span><span class="s1">((ax+bx+</span><span class="s2">4.</span><span class="s1">*cx)/</span><span class="s2">6.</span><span class="s0">, </span><span class="s1">(ay+by+</span><span class="s2">4.</span><span class="s1">*cy)/</span><span class="s2">6.</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_triinterpcubic_cg_solver():</span>
    <span class="s4"># Now 3 basic tests of the Sparse CG solver, used for</span>
    <span class="s4"># TriCubicInterpolator with *kind* = 'min_E'</span>
    <span class="s4"># 1) A commonly used test involves a 2d Poisson matrix.</span>
    <span class="s0">def </span><span class="s1">poisson_sparse_matrix(n</span><span class="s0">, </span><span class="s1">m):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the sparse, (n*m, n*m) matrix in coo format resulting from the 
        discretisation of the 2-dimensional Poisson equation according to a 
        finite difference numerical scheme on a uniform (n, m) grid. 
        &quot;&quot;&quot;</span>
        <span class="s1">l = m*n</span>
        <span class="s1">rows = np.concatenate([</span>
            <span class="s1">np.arange(l</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">np.arange(l-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">np.arange(l-n</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">, </span><span class="s1">np.arange(n</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">dtype=np.int32)])</span>
        <span class="s1">cols = np.concatenate([</span>
            <span class="s1">np.arange(l</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">np.arange(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">, </span><span class="s1">np.arange(l-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">np.arange(n</span><span class="s0">, </span><span class="s1">l</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">, </span><span class="s1">np.arange(l-n</span><span class="s0">, </span><span class="s1">dtype=np.int32)])</span>
        <span class="s1">vals = np.concatenate([</span>
            <span class="s2">4</span><span class="s1">*np.ones(l</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">,</span>
            <span class="s1">-np.ones(l-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">, </span><span class="s1">-np.ones(l-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">,</span>
            <span class="s1">-np.ones(l-n</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span><span class="s0">, </span><span class="s1">-np.ones(l-n</span><span class="s0">, </span><span class="s1">dtype=np.float64)])</span>
        <span class="s4"># In fact +1 and -1 diags have some zeros</span>
        <span class="s1">vals[l:</span><span class="s2">2</span><span class="s1">*l-</span><span class="s2">1</span><span class="s1">][m-</span><span class="s2">1</span><span class="s1">::m] = </span><span class="s2">0.</span>
        <span class="s1">vals[</span><span class="s2">2</span><span class="s1">*l-</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">*l-</span><span class="s2">2</span><span class="s1">][m-</span><span class="s2">1</span><span class="s1">::m] = </span><span class="s2">0.</span>
        <span class="s0">return </span><span class="s1">vals</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">, </span><span class="s1">(n*m</span><span class="s0">, </span><span class="s1">n*m)</span>

    <span class="s4"># Instantiating a sparse Poisson matrix of size 48 x 48:</span>
    <span class="s1">(n</span><span class="s0">, </span><span class="s1">m) = (</span><span class="s2">12</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
    <span class="s1">mat = mtri._triinterpolate._Sparse_Matrix_coo(*poisson_sparse_matrix(n</span><span class="s0">, </span><span class="s1">m))</span>
    <span class="s1">mat.compress_csc()</span>
    <span class="s1">mat_dense = mat.to_dense()</span>
    <span class="s4"># Testing a sparse solve for all 48 basis vector</span>
    <span class="s0">for </span><span class="s1">itest </span><span class="s0">in </span><span class="s1">range(n*m):</span>
        <span class="s1">b = np.zeros(n*m</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">b[itest] = </span><span class="s2">1.</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">_ = mtri._triinterpolate._cg(A=mat</span><span class="s0">, </span><span class="s1">b=b</span><span class="s0">, </span><span class="s1">x0=np.zeros(n*m)</span><span class="s0">,</span>
                                        <span class="s1">tol=</span><span class="s2">1.e-10</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(np.dot(mat_dense</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s4"># 2) Same matrix with inserting 2 rows - cols with null diag terms</span>
    <span class="s4"># (but still linked with the rest of the matrix by extra-diag terms)</span>
    <span class="s1">(i_zero</span><span class="s0">, </span><span class="s1">j_zero) = (</span><span class="s2">12</span><span class="s0">, </span><span class="s2">49</span><span class="s1">)</span>
    <span class="s1">vals</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">, </span><span class="s1">_ = poisson_sparse_matrix(n</span><span class="s0">, </span><span class="s1">m)</span>
    <span class="s1">rows = rows + </span><span class="s2">1</span><span class="s1">*(rows &gt;= i_zero) + </span><span class="s2">1</span><span class="s1">*(rows &gt;= j_zero)</span>
    <span class="s1">cols = cols + </span><span class="s2">1</span><span class="s1">*(cols &gt;= i_zero) + </span><span class="s2">1</span><span class="s1">*(cols &gt;= j_zero)</span>
    <span class="s4"># adding extra-diag terms</span>
    <span class="s1">rows = np.concatenate([rows</span><span class="s0">, </span><span class="s1">[i_zero</span><span class="s0">, </span><span class="s1">i_zero-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">j_zero</span><span class="s0">, </span><span class="s1">j_zero-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s1">cols = np.concatenate([cols</span><span class="s0">, </span><span class="s1">[i_zero-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">i_zero</span><span class="s0">, </span><span class="s1">j_zero-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">j_zero]])</span>
    <span class="s1">vals = np.concatenate([vals</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]])</span>
    <span class="s1">mat = mtri._triinterpolate._Sparse_Matrix_coo(vals</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">,</span>
                                                  <span class="s1">(n*m + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">n*m + </span><span class="s2">2</span><span class="s1">))</span>
    <span class="s1">mat.compress_csc()</span>
    <span class="s1">mat_dense = mat.to_dense()</span>
    <span class="s4"># Testing a sparse solve for all 50 basis vec</span>
    <span class="s0">for </span><span class="s1">itest </span><span class="s0">in </span><span class="s1">range(n*m + </span><span class="s2">2</span><span class="s1">):</span>
        <span class="s1">b = np.zeros(n*m + </span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">b[itest] = </span><span class="s2">1.</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">_ = mtri._triinterpolate._cg(A=mat</span><span class="s0">, </span><span class="s1">b=b</span><span class="s0">, </span><span class="s1">x0=np.ones(n * m + </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
                                        <span class="s1">tol=</span><span class="s2">1.e-10</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(np.dot(mat_dense</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s4"># 3) Now a simple test that summation of duplicate (i.e. with same rows,</span>
    <span class="s4"># same cols) entries occurs when compressed.</span>
    <span class="s1">vals = np.ones(</span><span class="s2">17</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">rows = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">dtype=np.int32)</span>
    <span class="s1">cols = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">dtype=np.int32)</span>
    <span class="s1">dim = (</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
    <span class="s1">mat = mtri._triinterpolate._Sparse_Matrix_coo(vals</span><span class="s0">, </span><span class="s1">rows</span><span class="s0">, </span><span class="s1">cols</span><span class="s0">, </span><span class="s1">dim)</span>
    <span class="s1">mat.compress_csc()</span>
    <span class="s1">mat_dense = mat.to_dense()</span>
    <span class="s1">assert_array_almost_equal(mat_dense</span><span class="s0">, </span><span class="s1">np.array([</span>
        <span class="s1">[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">5.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">5.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span>


<span class="s0">def </span><span class="s1">test_triinterpcubic_geom_weights():</span>
    <span class="s4"># Tests to check computation of weights for _DOF_estimator_geom:</span>
    <span class="s4"># The weight sum per triangle can be 1. (in case all angles &lt; 90 degrees)</span>
    <span class="s4"># or (2*w_i) where w_i = 1-alpha_i/np.pi is the weight of apex i; alpha_i</span>
    <span class="s4"># is the apex angle &gt; 90 degrees.</span>
    <span class="s1">(ax</span><span class="s0">, </span><span class="s1">ay) = (</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.687</span><span class="s1">)</span>
    <span class="s1">x = np.array([ax</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">*ax</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">y = np.array([ay</span><span class="s0">, </span><span class="s1">-ay</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">])</span>
    <span class="s1">z = np.zeros(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
    <span class="s1">sum_w = np.zeros([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])  </span><span class="s4"># 4 possibilities; 2 triangles</span>
    <span class="s0">for </span><span class="s1">theta </span><span class="s0">in </span><span class="s1">np.linspace(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s2">14</span><span class="s1">):  </span><span class="s4"># rotating the figure...</span>
        <span class="s1">x_rot = np.cos(theta)*x + np.sin(theta)*y</span>
        <span class="s1">y_rot = -np.sin(theta)*x + np.cos(theta)*y</span>
        <span class="s1">triang = mtri.Triangulation(x_rot</span><span class="s0">, </span><span class="s1">y_rot</span><span class="s0">, </span><span class="s1">triangles)</span>
        <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>
        <span class="s1">dof_estimator = mtri._triinterpolate._DOF_estimator_geom(cubic_geom)</span>
        <span class="s1">weights = dof_estimator.compute_geom_weights()</span>
        <span class="s4"># Testing for the 4 possibilities...</span>
        <span class="s1">sum_w[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">:] = np.sum(weights</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) - </span><span class="s2">1</span>
        <span class="s0">for </span><span class="s1">itri </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">sum_w[itri+</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:] = np.sum(weights</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) - </span><span class="s2">2</span><span class="s1">*weights[:</span><span class="s0">, </span><span class="s1">itri]</span>
        <span class="s1">assert_array_almost_equal(np.min(np.abs(sum_w)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span>


<span class="s0">def </span><span class="s1">test_triinterp_colinear():</span>
    <span class="s4"># Tests interpolating inside a triangulation with horizontal colinear</span>
    <span class="s4"># points (refer also to the tests :func:`test_trifinder` ).</span>
    <span class="s4">#</span>
    <span class="s4"># These are not valid triangulations, but we try to deal with the</span>
    <span class="s4"># simplest violations (i. e. those handled by default TriFinder).</span>
    <span class="s4">#</span>
    <span class="s4"># Note that the LinearTriInterpolator and the CubicTriInterpolator with</span>
    <span class="s4"># kind='min_E' or 'geom' still pass a linear patch test.</span>
    <span class="s4"># We also test interpolation inside a flat triangle, by forcing</span>
    <span class="s4"># *tri_index* in a call to :meth:`_interpolate_multikeys`.</span>

    <span class="s4"># If +ve, triangulation is OK, if -ve triangulation invalid,</span>
    <span class="s4"># if zero have colinear points but should pass tests anyway.</span>
    <span class="s1">delta = </span><span class="s2">0.</span>

    <span class="s1">x0 = np.array([</span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">1</span><span class="s0">,  </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">,   </span><span class="s2">1.5</span><span class="s1">])</span>
    <span class="s1">y0 = np.array([-</span><span class="s2">1</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">,  </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">delta</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s4"># We test different affine transformations of the initial figure; to</span>
    <span class="s4"># avoid issues related to round-off errors we only use integer</span>
    <span class="s4"># coefficients (otherwise the Triangulation might become invalid even with</span>
    <span class="s4"># delta == 0).</span>
    <span class="s1">transformations = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span>
    <span class="s0">for </span><span class="s1">transformation </span><span class="s0">in </span><span class="s1">transformations:</span>
        <span class="s1">x_rot = transformation[</span><span class="s2">0</span><span class="s1">]*x0 + transformation[</span><span class="s2">1</span><span class="s1">]*y0</span>
        <span class="s1">y_rot = -transformation[</span><span class="s2">1</span><span class="s1">]*x0 + transformation[</span><span class="s2">0</span><span class="s1">]*y0</span>
        <span class="s1">(x</span><span class="s0">, </span><span class="s1">y) = (x_rot</span><span class="s0">, </span><span class="s1">y_rot)</span>
        <span class="s1">z = </span><span class="s2">1.23</span><span class="s1">*x - </span><span class="s2">4.79</span><span class="s1">*y</span>
        <span class="s1">triangles = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">,</span>
                     <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
        <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
        <span class="s1">xs = np.linspace(np.min(triang.x)</span><span class="s0">, </span><span class="s1">np.max(triang.x)</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>
        <span class="s1">ys = np.linspace(np.min(triang.y)</span><span class="s0">, </span><span class="s1">np.max(triang.y)</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>
        <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys = np.meshgrid(xs</span><span class="s0">, </span><span class="s1">ys)</span>
        <span class="s1">xs = xs.ravel()</span>
        <span class="s1">ys = ys.ravel()</span>
        <span class="s1">mask_out = (triang.get_trifinder()(xs</span><span class="s0">, </span><span class="s1">ys) == -</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">zs_target = np.ma.array(</span><span class="s2">1.23</span><span class="s1">*xs - </span><span class="s2">4.79</span><span class="s1">*ys</span><span class="s0">, </span><span class="s1">mask=mask_out)</span>

        <span class="s1">linear_interp = mtri.LinearTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
        <span class="s1">cubic_min_E = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z)</span>
        <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(linear_interp</span><span class="s0">, </span><span class="s1">cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
            <span class="s1">zs = interp(xs</span><span class="s0">, </span><span class="s1">ys)</span>
            <span class="s1">assert_array_almost_equal(zs_target</span><span class="s0">, </span><span class="s1">zs)</span>

        <span class="s4"># Testing interpolation inside the flat triangle number 4: [2, 3, 5]</span>
        <span class="s4"># by imposing *tri_index* in a call to :meth:`_interpolate_multikeys`</span>
        <span class="s1">itri = </span><span class="s2">4</span>
        <span class="s1">pt1 = triang.triangles[itri</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">pt2 = triang.triangles[itri</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">xs = np.linspace(triang.x[pt1]</span><span class="s0">, </span><span class="s1">triang.x[pt2]</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">ys = np.linspace(triang.y[pt1]</span><span class="s0">, </span><span class="s1">triang.y[pt2]</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">zs_target = </span><span class="s2">1.23</span><span class="s1">*xs - </span><span class="s2">4.79</span><span class="s1">*ys</span>
        <span class="s0">for </span><span class="s1">interp </span><span class="s0">in </span><span class="s1">(linear_interp</span><span class="s0">, </span><span class="s1">cubic_min_E</span><span class="s0">, </span><span class="s1">cubic_geom):</span>
            <span class="s1">zs</span><span class="s0">, </span><span class="s1">= interp._interpolate_multikeys(</span>
                <span class="s1">xs</span><span class="s0">, </span><span class="s1">ys</span><span class="s0">, </span><span class="s1">tri_index=itri*np.ones(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">dtype=np.int32))</span>
            <span class="s1">assert_array_almost_equal(zs_target</span><span class="s0">, </span><span class="s1">zs)</span>


<span class="s0">def </span><span class="s1">test_triinterp_transformations():</span>
    <span class="s4"># 1) Testing that the interpolation scheme is invariant by rotation of the</span>
    <span class="s4"># whole figure.</span>
    <span class="s4"># Note: This test is non-trivial for a CubicTriInterpolator with</span>
    <span class="s4"># kind='min_E'. It does fail for a non-isotropic stiffness matrix E of</span>
    <span class="s4"># :class:`_ReducedHCT_Element` (tested with E=np.diag([1., 1., 1.])), and</span>
    <span class="s4"># provides a good test for :meth:`get_Kff_and_Ff`of the same class.</span>
    <span class="s4">#</span>
    <span class="s4"># 2) Also testing that the interpolation scheme is invariant by expansion</span>
    <span class="s4"># of the whole figure along one axis.</span>
    <span class="s1">n_angles = </span><span class="s2">20</span>
    <span class="s1">n_radii = </span><span class="s2">10</span>
    <span class="s1">min_radius = </span><span class="s2">0.15</span>

    <span class="s0">def </span><span class="s1">z(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s1">r1 = np.hypot(</span><span class="s2">0.5 </span><span class="s1">- x</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- y)</span>
        <span class="s1">theta1 = np.arctan2(</span><span class="s2">0.5 </span><span class="s1">- x</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- y)</span>
        <span class="s1">r2 = np.hypot(-x - </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-y - </span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">theta2 = np.arctan2(-x - </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-y - </span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">z = -(</span><span class="s2">2</span><span class="s1">*(np.exp((r1/</span><span class="s2">10</span><span class="s1">)**</span><span class="s2">2</span><span class="s1">)-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">30. </span><span class="s1">* np.cos(</span><span class="s2">7.</span><span class="s1">*theta1) +</span>
              <span class="s1">(np.exp((r2/</span><span class="s2">10</span><span class="s1">)**</span><span class="s2">2</span><span class="s1">)-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">30. </span><span class="s1">* np.cos(</span><span class="s2">11.</span><span class="s1">*theta2) +</span>
              <span class="s2">0.7</span><span class="s1">*(x**</span><span class="s2">2 </span><span class="s1">+ y**</span><span class="s2">2</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">(np.max(z)-z)/(np.max(z)-np.min(z))</span>

    <span class="s4"># First create the x and y coordinates of the points.</span>
    <span class="s1">radii = np.linspace(min_radius</span><span class="s0">, </span><span class="s2">0.95</span><span class="s0">, </span><span class="s1">n_radii)</span>
    <span class="s1">angles = np.linspace(</span><span class="s2">0 </span><span class="s1">+ n_angles</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi + n_angles</span><span class="s0">,</span>
                         <span class="s1">n_angles</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">angles = np.repeat(angles[...</span><span class="s0">, </span><span class="s1">np.newaxis]</span><span class="s0">, </span><span class="s1">n_radii</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">angles[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] += np.pi/n_angles</span>
    <span class="s1">x0 = (radii*np.cos(angles)).flatten()</span>
    <span class="s1">y0 = (radii*np.sin(angles)).flatten()</span>
    <span class="s1">triang0 = mtri.Triangulation(x0</span><span class="s0">, </span><span class="s1">y0)  </span><span class="s4"># Delaunay triangulation</span>
    <span class="s1">z0 = z(x0</span><span class="s0">, </span><span class="s1">y0)</span>

    <span class="s4"># Then create the test points</span>
    <span class="s1">xs0 = np.linspace(-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">23</span><span class="s1">)</span>
    <span class="s1">ys0 = np.linspace(-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">23</span><span class="s1">)</span>
    <span class="s1">xs0</span><span class="s0">, </span><span class="s1">ys0 = np.meshgrid(xs0</span><span class="s0">, </span><span class="s1">ys0)</span>
    <span class="s1">xs0 = xs0.ravel()</span>
    <span class="s1">ys0 = ys0.ravel()</span>

    <span class="s1">interp_z0 = {}</span>
    <span class="s0">for </span><span class="s1">i_angle </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s1">):</span>
        <span class="s4"># Rotating everything</span>
        <span class="s1">theta = </span><span class="s2">2</span><span class="s1">*np.pi / n_angles * i_angle</span>
        <span class="s1">x = np.cos(theta)*x0 + np.sin(theta)*y0</span>
        <span class="s1">y = -np.sin(theta)*x0 + np.cos(theta)*y0</span>
        <span class="s1">xs = np.cos(theta)*xs0 + np.sin(theta)*ys0</span>
        <span class="s1">ys = -np.sin(theta)*xs0 + np.cos(theta)*ys0</span>
        <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triang0.triangles)</span>
        <span class="s1">linear_interp = mtri.LinearTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0)</span>
        <span class="s1">cubic_min_E = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0)</span>
        <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>
        <span class="s1">dic_interp = {</span><span class="s3">'lin'</span><span class="s1">: linear_interp</span><span class="s0">,</span>
                      <span class="s3">'min_E'</span><span class="s1">: cubic_min_E</span><span class="s0">,</span>
                      <span class="s3">'geom'</span><span class="s1">: cubic_geom}</span>
        <span class="s4"># Testing that the interpolation is invariant by rotation...</span>
        <span class="s0">for </span><span class="s1">interp_key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'lin'</span><span class="s0">, </span><span class="s3">'min_E'</span><span class="s0">, </span><span class="s3">'geom'</span><span class="s1">]:</span>
            <span class="s1">interp = dic_interp[interp_key]</span>
            <span class="s0">if </span><span class="s1">i_angle == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">interp_z0[interp_key] = interp(xs0</span><span class="s0">, </span><span class="s1">ys0)  </span><span class="s4"># storage</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">interpz = interp(xs</span><span class="s0">, </span><span class="s1">ys)</span>
                <span class="s1">matest.assert_array_almost_equal(interpz</span><span class="s0">,</span>
                                                 <span class="s1">interp_z0[interp_key])</span>

    <span class="s1">scale_factor = </span><span class="s2">987654.3210</span>
    <span class="s0">for </span><span class="s1">scaled_axis </span><span class="s0">in </span><span class="s1">(</span><span class="s3">'x'</span><span class="s0">, </span><span class="s3">'y'</span><span class="s1">):</span>
        <span class="s4"># Scaling everything (expansion along scaled_axis)</span>
        <span class="s0">if </span><span class="s1">scaled_axis == </span><span class="s3">'x'</span><span class="s1">:</span>
            <span class="s1">x = scale_factor * x0</span>
            <span class="s1">y = y0</span>
            <span class="s1">xs = scale_factor * xs0</span>
            <span class="s1">ys = ys0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = x0</span>
            <span class="s1">y = scale_factor * y0</span>
            <span class="s1">xs = xs0</span>
            <span class="s1">ys = scale_factor * ys0</span>
        <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triang0.triangles)</span>
        <span class="s1">linear_interp = mtri.LinearTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0)</span>
        <span class="s1">cubic_min_E = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0)</span>
        <span class="s1">cubic_geom = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">z0</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">'geom'</span><span class="s1">)</span>
        <span class="s1">dic_interp = {</span><span class="s3">'lin'</span><span class="s1">: linear_interp</span><span class="s0">,</span>
                      <span class="s3">'min_E'</span><span class="s1">: cubic_min_E</span><span class="s0">,</span>
                      <span class="s3">'geom'</span><span class="s1">: cubic_geom}</span>
        <span class="s4"># Test that the interpolation is invariant by expansion along 1 axis...</span>
        <span class="s0">for </span><span class="s1">interp_key </span><span class="s0">in </span><span class="s1">[</span><span class="s3">'lin'</span><span class="s0">, </span><span class="s3">'min_E'</span><span class="s0">, </span><span class="s3">'geom'</span><span class="s1">]:</span>
            <span class="s1">interpz = dic_interp[interp_key](xs</span><span class="s0">, </span><span class="s1">ys)</span>
            <span class="s1">matest.assert_array_almost_equal(interpz</span><span class="s0">, </span><span class="s1">interp_z0[interp_key])</span>


<span class="s1">@image_comparison([</span><span class="s3">'tri_smooth_contouring.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True, </span><span class="s1">tol=</span><span class="s2">0.072</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_tri_smooth_contouring():</span>
    <span class="s4"># Image comparison based on example tricontour_smooth_user.</span>
    <span class="s1">n_angles = </span><span class="s2">20</span>
    <span class="s1">n_radii = </span><span class="s2">10</span>
    <span class="s1">min_radius = </span><span class="s2">0.15</span>

    <span class="s0">def </span><span class="s1">z(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s1">r1 = np.hypot(</span><span class="s2">0.5 </span><span class="s1">- x</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- y)</span>
        <span class="s1">theta1 = np.arctan2(</span><span class="s2">0.5 </span><span class="s1">- x</span><span class="s0">, </span><span class="s2">0.5 </span><span class="s1">- y)</span>
        <span class="s1">r2 = np.hypot(-x - </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-y - </span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">theta2 = np.arctan2(-x - </span><span class="s2">0.2</span><span class="s0">, </span><span class="s1">-y - </span><span class="s2">0.2</span><span class="s1">)</span>
        <span class="s1">z = -(</span><span class="s2">2</span><span class="s1">*(np.exp((r1/</span><span class="s2">10</span><span class="s1">)**</span><span class="s2">2</span><span class="s1">)-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">30. </span><span class="s1">* np.cos(</span><span class="s2">7.</span><span class="s1">*theta1) +</span>
              <span class="s1">(np.exp((r2/</span><span class="s2">10</span><span class="s1">)**</span><span class="s2">2</span><span class="s1">)-</span><span class="s2">1</span><span class="s1">)*</span><span class="s2">30. </span><span class="s1">* np.cos(</span><span class="s2">11.</span><span class="s1">*theta2) +</span>
              <span class="s2">0.7</span><span class="s1">*(x**</span><span class="s2">2 </span><span class="s1">+ y**</span><span class="s2">2</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">(np.max(z)-z)/(np.max(z)-np.min(z))</span>

    <span class="s4"># First create the x and y coordinates of the points.</span>
    <span class="s1">radii = np.linspace(min_radius</span><span class="s0">, </span><span class="s2">0.95</span><span class="s0">, </span><span class="s1">n_radii)</span>
    <span class="s1">angles = np.linspace(</span><span class="s2">0 </span><span class="s1">+ n_angles</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi + n_angles</span><span class="s0">,</span>
                         <span class="s1">n_angles</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">angles = np.repeat(angles[...</span><span class="s0">, </span><span class="s1">np.newaxis]</span><span class="s0">, </span><span class="s1">n_radii</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">angles[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] += np.pi/n_angles</span>
    <span class="s1">x0 = (radii*np.cos(angles)).flatten()</span>
    <span class="s1">y0 = (radii*np.sin(angles)).flatten()</span>
    <span class="s1">triang0 = mtri.Triangulation(x0</span><span class="s0">, </span><span class="s1">y0)  </span><span class="s4"># Delaunay triangulation</span>
    <span class="s1">z0 = z(x0</span><span class="s0">, </span><span class="s1">y0)</span>
    <span class="s1">triang0.set_mask(np.hypot(x0[triang0.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                              <span class="s1">y0[triang0.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">))</span>
                     <span class="s1">&lt; min_radius)</span>

    <span class="s4"># Then the plot</span>
    <span class="s1">refiner = mtri.UniformTriRefiner(triang0)</span>
    <span class="s1">tri_refi</span><span class="s0">, </span><span class="s1">z_test_refi = refiner.refine_field(z0</span><span class="s0">, </span><span class="s1">subdiv=</span><span class="s2">4</span><span class="s1">)</span>
    <span class="s1">levels = np.arange(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.025</span><span class="s1">)</span>
    <span class="s1">plt.triplot(triang0</span><span class="s0">, </span><span class="s1">lw=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">color=</span><span class="s3">'0.5'</span><span class="s1">)</span>
    <span class="s1">plt.tricontour(tri_refi</span><span class="s0">, </span><span class="s1">z_test_refi</span><span class="s0">, </span><span class="s1">levels=levels</span><span class="s0">, </span><span class="s1">colors=</span><span class="s3">&quot;black&quot;</span><span class="s1">)</span>


<span class="s1">@image_comparison([</span><span class="s3">'tri_smooth_gradient.png'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">remove_text=</span><span class="s0">True, </span><span class="s1">tol=</span><span class="s2">0.092</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_tri_smooth_gradient():</span>
    <span class="s4"># Image comparison based on example trigradient_demo.</span>

    <span class="s0">def </span><span class="s1">dipole_potential(x</span><span class="s0">, </span><span class="s1">y):</span>
        <span class="s5">&quot;&quot;&quot;An electric dipole potential V.&quot;&quot;&quot;</span>
        <span class="s1">r_sq = x**</span><span class="s2">2 </span><span class="s1">+ y**</span><span class="s2">2</span>
        <span class="s1">theta = np.arctan2(y</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">z = np.cos(theta)/r_sq</span>
        <span class="s0">return </span><span class="s1">(np.max(z)-z) / (np.max(z)-np.min(z))</span>

    <span class="s4"># Creating a Triangulation</span>
    <span class="s1">n_angles = </span><span class="s2">30</span>
    <span class="s1">n_radii = </span><span class="s2">10</span>
    <span class="s1">min_radius = </span><span class="s2">0.2</span>
    <span class="s1">radii = np.linspace(min_radius</span><span class="s0">, </span><span class="s2">0.95</span><span class="s0">, </span><span class="s1">n_radii)</span>
    <span class="s1">angles = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">*np.pi</span><span class="s0">, </span><span class="s1">n_angles</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">angles = np.repeat(angles[...</span><span class="s0">, </span><span class="s1">np.newaxis]</span><span class="s0">, </span><span class="s1">n_radii</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">angles[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">] += np.pi/n_angles</span>
    <span class="s1">x = (radii*np.cos(angles)).flatten()</span>
    <span class="s1">y = (radii*np.sin(angles)).flatten()</span>
    <span class="s1">V = dipole_potential(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">triang.set_mask(np.hypot(x[triang.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                             <span class="s1">y[triang.triangles].mean(axis=</span><span class="s2">1</span><span class="s1">))</span>
                    <span class="s1">&lt; min_radius)</span>

    <span class="s4"># Refine data - interpolates the electrical potential V</span>
    <span class="s1">refiner = mtri.UniformTriRefiner(triang)</span>
    <span class="s1">tri_refi</span><span class="s0">, </span><span class="s1">z_test_refi = refiner.refine_field(V</span><span class="s0">, </span><span class="s1">subdiv=</span><span class="s2">3</span><span class="s1">)</span>

    <span class="s4"># Computes the electrical field (Ex, Ey) as gradient of -V</span>
    <span class="s1">tci = mtri.CubicTriInterpolator(triang</span><span class="s0">, </span><span class="s1">-V)</span>
    <span class="s1">Ex</span><span class="s0">, </span><span class="s1">Ey = tci.gradient(triang.x</span><span class="s0">, </span><span class="s1">triang.y)</span>
    <span class="s1">E_norm = np.hypot(Ex</span><span class="s0">, </span><span class="s1">Ey)</span>

    <span class="s4"># Plot the triangulation, the potential iso-contours and the vector field</span>
    <span class="s1">plt.figure()</span>
    <span class="s1">plt.gca().set_aspect(</span><span class="s3">'equal'</span><span class="s1">)</span>
    <span class="s1">plt.triplot(triang</span><span class="s0">, </span><span class="s1">color=</span><span class="s3">'0.8'</span><span class="s1">)</span>

    <span class="s1">levels = np.arange(</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">)</span>
    <span class="s1">cmap = mpl.colormaps[</span><span class="s3">'hot'</span><span class="s1">]</span>
    <span class="s1">plt.tricontour(tri_refi</span><span class="s0">, </span><span class="s1">z_test_refi</span><span class="s0">, </span><span class="s1">levels=levels</span><span class="s0">, </span><span class="s1">cmap=cmap</span><span class="s0">,</span>
                   <span class="s1">linewidths=[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
    <span class="s4"># Plots direction of the electrical vector field</span>
    <span class="s1">plt.quiver(triang.x</span><span class="s0">, </span><span class="s1">triang.y</span><span class="s0">, </span><span class="s1">Ex/E_norm</span><span class="s0">, </span><span class="s1">Ey/E_norm</span><span class="s0">,</span>
               <span class="s1">units=</span><span class="s3">'xy'</span><span class="s0">, </span><span class="s1">scale=</span><span class="s2">10.</span><span class="s0">, </span><span class="s1">zorder=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">color=</span><span class="s3">'blue'</span><span class="s0">,</span>
               <span class="s1">width=</span><span class="s2">0.007</span><span class="s0">, </span><span class="s1">headwidth=</span><span class="s2">3.</span><span class="s0">, </span><span class="s1">headlength=</span><span class="s2">4.</span><span class="s1">)</span>
    <span class="s4"># We are leaving ax.use_sticky_margins as True, so the</span>
    <span class="s4"># view limits are the contour data limits.</span>


<span class="s0">def </span><span class="s1">test_tritools():</span>
    <span class="s4"># Tests TriAnalyzer.scale_factors on masked triangulation</span>
    <span class="s4"># Tests circle_ratios on equilateral and right-angled triangle.</span>
    <span class="s1">x = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">*np.sqrt(</span><span class="s2">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">mask = np.array([</span><span class="s0">False, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask=mask)</span>
    <span class="s1">analyser = mtri.TriAnalyzer(triang)</span>
    <span class="s1">assert_array_almost_equal(analyser.scale_factors</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">/(</span><span class="s2">1</span><span class="s1">+</span><span class="s2">3</span><span class="s1">**</span><span class="s2">.5</span><span class="s1">/</span><span class="s2">2</span><span class="s1">)])</span>
    <span class="s1">assert_array_almost_equal(</span>
        <span class="s1">analyser.circle_ratios(rescale=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">np.ma.masked_array([</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">/(</span><span class="s2">1.</span><span class="s1">+np.sqrt(</span><span class="s2">2.</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">mask))</span>

    <span class="s4"># Tests circle ratio of a flat triangle</span>
    <span class="s1">x = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">+</span><span class="s2">3.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">+</span><span class="s2">6.</span><span class="s1">])</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles)</span>
    <span class="s1">analyser = mtri.TriAnalyzer(triang)</span>
    <span class="s1">assert_array_almost_equal(analyser.circle_ratios()</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0.</span><span class="s1">]))</span>

    <span class="s4"># Tests TriAnalyzer.get_flat_tri_mask</span>
    <span class="s4"># Creates a triangulation of [-1, 1] x [-1, 1] with contiguous groups of</span>
    <span class="s4"># 'flat' triangles at the 4 corners and at the center. Checks that only</span>
    <span class="s4"># those at the borders are eliminated by TriAnalyzer.get_flat_tri_mask</span>
    <span class="s1">n = </span><span class="s2">9</span>

    <span class="s0">def </span><span class="s1">power(x</span><span class="s0">, </span><span class="s1">a):</span>
        <span class="s0">return </span><span class="s1">np.abs(x)**a*np.sign(x)</span>

    <span class="s1">x = np.linspace(-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(power(x</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">power(x</span><span class="s0">, </span><span class="s2">0.25</span><span class="s1">))</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>

    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles=meshgrid_triangles(n+</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">analyser = mtri.TriAnalyzer(triang)</span>
    <span class="s1">mask_flat = analyser.get_flat_tri_mask(</span><span class="s2">0.2</span><span class="s1">)</span>
    <span class="s1">verif_mask = np.zeros(</span><span class="s2">162</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">corners_index = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">14</span><span class="s0">, </span><span class="s2">15</span><span class="s0">, </span><span class="s2">16</span><span class="s0">, </span><span class="s2">17</span><span class="s0">, </span><span class="s2">18</span><span class="s0">, </span><span class="s2">19</span><span class="s0">, </span><span class="s2">34</span><span class="s0">, </span><span class="s2">35</span><span class="s0">, </span><span class="s2">126</span><span class="s0">, </span><span class="s2">127</span><span class="s0">,</span>
                     <span class="s2">142</span><span class="s0">, </span><span class="s2">143</span><span class="s0">, </span><span class="s2">144</span><span class="s0">, </span><span class="s2">145</span><span class="s0">, </span><span class="s2">146</span><span class="s0">, </span><span class="s2">147</span><span class="s0">, </span><span class="s2">158</span><span class="s0">, </span><span class="s2">159</span><span class="s0">, </span><span class="s2">160</span><span class="s0">, </span><span class="s2">161</span><span class="s1">]</span>
    <span class="s1">verif_mask[corners_index] = </span><span class="s0">True</span>
    <span class="s1">assert_array_equal(mask_flat</span><span class="s0">, </span><span class="s1">verif_mask)</span>

    <span class="s4"># Now including a hole (masked triangle) at the center. The center also</span>
    <span class="s4"># shall be eliminated by get_flat_tri_mask.</span>
    <span class="s1">mask = np.zeros(</span><span class="s2">162</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">mask[</span><span class="s2">80</span><span class="s1">] = </span><span class="s0">True</span>
    <span class="s1">triang.set_mask(mask)</span>
    <span class="s1">mask_flat = analyser.get_flat_tri_mask(</span><span class="s2">0.2</span><span class="s1">)</span>
    <span class="s1">center_index = [</span><span class="s2">44</span><span class="s0">, </span><span class="s2">45</span><span class="s0">, </span><span class="s2">62</span><span class="s0">, </span><span class="s2">63</span><span class="s0">, </span><span class="s2">78</span><span class="s0">, </span><span class="s2">79</span><span class="s0">, </span><span class="s2">80</span><span class="s0">, </span><span class="s2">81</span><span class="s0">, </span><span class="s2">82</span><span class="s0">, </span><span class="s2">83</span><span class="s0">, </span><span class="s2">98</span><span class="s0">, </span><span class="s2">99</span><span class="s0">, </span><span class="s2">116</span><span class="s0">, </span><span class="s2">117</span><span class="s1">]</span>
    <span class="s1">verif_mask[center_index] = </span><span class="s0">True</span>
    <span class="s1">assert_array_equal(mask_flat</span><span class="s0">, </span><span class="s1">verif_mask)</span>


<span class="s0">def </span><span class="s1">test_trirefine():</span>
    <span class="s4"># Testing subdiv=2 refinement</span>
    <span class="s1">n = </span><span class="s2">3</span>
    <span class="s1">subdiv = </span><span class="s2">2</span>
    <span class="s1">x = np.linspace(-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">n+</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.meshgrid(x</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s1">x = x.ravel()</span>
    <span class="s1">y = y.ravel()</span>
    <span class="s1">mask = np.zeros(</span><span class="s2">2</span><span class="s1">*n**</span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">mask[n**</span><span class="s2">2</span><span class="s1">:] = </span><span class="s0">True</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles=meshgrid_triangles(n+</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                                <span class="s1">mask=mask)</span>
    <span class="s1">refiner = mtri.UniformTriRefiner(triang)</span>
    <span class="s1">refi_triang = refiner.refine_triangulation(subdiv=subdiv)</span>
    <span class="s1">x_refi = refi_triang.x</span>
    <span class="s1">y_refi = refi_triang.y</span>

    <span class="s1">n_refi = n * subdiv**</span><span class="s2">2</span>
    <span class="s1">x_verif = np.linspace(-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">n_refi+</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">x_verif</span><span class="s0">, </span><span class="s1">y_verif = np.meshgrid(x_verif</span><span class="s0">, </span><span class="s1">x_verif)</span>
    <span class="s1">x_verif = x_verif.ravel()</span>
    <span class="s1">y_verif = y_verif.ravel()</span>
    <span class="s1">ind1d = np.in1d(np.around(x_verif*(</span><span class="s2">2.5</span><span class="s1">+y_verif)</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">np.around(x_refi*(</span><span class="s2">2.5</span><span class="s1">+y_refi)</span><span class="s0">, </span><span class="s2">8</span><span class="s1">))</span>
    <span class="s1">assert_array_equal(ind1d</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s4"># Testing the mask of the refined triangulation</span>
    <span class="s1">refi_mask = refi_triang.mask</span>
    <span class="s1">refi_tri_barycenter_x = np.sum(refi_triang.x[refi_triang.triangles]</span><span class="s0">,</span>
                                   <span class="s1">axis=</span><span class="s2">1</span><span class="s1">) / </span><span class="s2">3.</span>
    <span class="s1">refi_tri_barycenter_y = np.sum(refi_triang.y[refi_triang.triangles]</span><span class="s0">,</span>
                                   <span class="s1">axis=</span><span class="s2">1</span><span class="s1">) / </span><span class="s2">3.</span>
    <span class="s1">tri_finder = triang.get_trifinder()</span>
    <span class="s1">refi_tri_indices = tri_finder(refi_tri_barycenter_x</span><span class="s0">,</span>
                                  <span class="s1">refi_tri_barycenter_y)</span>
    <span class="s1">refi_tri_mask = triang.mask[refi_tri_indices]</span>
    <span class="s1">assert_array_equal(refi_mask</span><span class="s0">, </span><span class="s1">refi_tri_mask)</span>

    <span class="s4"># Testing that the numbering of triangles does not change the</span>
    <span class="s4"># interpolation result.</span>
    <span class="s1">x = np.asarray([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
    <span class="s1">y = np.asarray([</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
    <span class="s1">triang = [mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
              <span class="s1">mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])]</span>
    <span class="s1">z = np.hypot(x - </span><span class="s2">0.3</span><span class="s0">, </span><span class="s1">y - </span><span class="s2">0.4</span><span class="s1">)</span>
    <span class="s4"># Refining the 2 triangulations and reordering the points</span>
    <span class="s1">xyz_data = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s1">):</span>
        <span class="s1">refiner = mtri.UniformTriRefiner(triang[i])</span>
        <span class="s1">refined_triang</span><span class="s0">, </span><span class="s1">refined_z = refiner.refine_field(z</span><span class="s0">, </span><span class="s1">subdiv=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">xyz = np.dstack((refined_triang.x</span><span class="s0">, </span><span class="s1">refined_triang.y</span><span class="s0">, </span><span class="s1">refined_z))[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">xyz = xyz[np.lexsort((xyz[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xyz[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))]</span>
        <span class="s1">xyz_data += [xyz]</span>
    <span class="s1">assert_array_almost_equal(xyz_data[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xyz_data[</span><span class="s2">1</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'interpolator'</span><span class="s0">,</span>
                         <span class="s1">[mtri.LinearTriInterpolator</span><span class="s0">,</span>
                          <span class="s1">mtri.CubicTriInterpolator]</span><span class="s0">,</span>
                         <span class="s1">ids=[</span><span class="s3">'linear'</span><span class="s0">, </span><span class="s3">'cubic'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_trirefine_masked(interpolator):</span>
    <span class="s4"># Repeated points means we will have fewer triangles than points, and thus</span>
    <span class="s4"># get masking.</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = np.mgrid[:</span><span class="s2">2</span><span class="s0">, </span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">x = np.repeat(x.flatten()</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">y = np.repeat(y.flatten()</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s1">z = np.zeros_like(x)</span>
    <span class="s1">tri = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">refiner = mtri.UniformTriRefiner(tri)</span>
    <span class="s1">interp = interpolator(tri</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">refiner.refine_field(z</span><span class="s0">, </span><span class="s1">triinterpolator=interp</span><span class="s0">, </span><span class="s1">subdiv=</span><span class="s2">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">meshgrid_triangles(n):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return (2*(N-1)**2, 3) array of triangles to mesh (N, N)-point np.meshgrid. 
    &quot;&quot;&quot;</span>
    <span class="s1">tri = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n-</span><span class="s2">1</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(n-</span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">a = i + j*n</span>
            <span class="s1">b = (i+</span><span class="s2">1</span><span class="s1">) + j*n</span>
            <span class="s1">c = i + (j+</span><span class="s2">1</span><span class="s1">)*n</span>
            <span class="s1">d = (i+</span><span class="s2">1</span><span class="s1">) + (j+</span><span class="s2">1</span><span class="s1">)*n</span>
            <span class="s1">tri += [[a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">d]</span><span class="s0">, </span><span class="s1">[a</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">c]]</span>
    <span class="s0">return </span><span class="s1">np.array(tri</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>


<span class="s0">def </span><span class="s1">test_triplot_return():</span>
    <span class="s4"># Check that triplot returns the artists it adds</span>
    <span class="s1">ax = plt.figure().add_subplot()</span>
    <span class="s1">triang = mtri.Triangulation(</span>
        <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">triangles=[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">ax.triplot(triang</span><span class="s0">, </span><span class="s3">&quot;b-&quot;</span><span class="s1">) </span><span class="s0">is not None, </span><span class="s1">\</span>
        <span class="s3">'triplot should return the artist it adds'</span>


<span class="s0">def </span><span class="s1">test_trirefiner_fortran_contiguous_triangles():</span>
    <span class="s4"># github issue 4180.  Test requires two arrays of triangles that are</span>
    <span class="s4"># identical except that one is C-contiguous and one is fortran-contiguous.</span>
    <span class="s1">triangles1 = np.array([[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s0">assert not </span><span class="s1">np.isfortran(triangles1)</span>

    <span class="s1">triangles2 = np.array(triangles1</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">np.isfortran(triangles2)</span>

    <span class="s1">x = np.array([</span><span class="s2">0.39</span><span class="s0">, </span><span class="s2">0.59</span><span class="s0">, </span><span class="s2">0.43</span><span class="s0">, </span><span class="s2">0.32</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">33.99</span><span class="s0">, </span><span class="s2">34.01</span><span class="s0">, </span><span class="s2">34.19</span><span class="s0">, </span><span class="s2">34.18</span><span class="s1">])</span>
    <span class="s1">triang1 = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles1)</span>
    <span class="s1">triang2 = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles2)</span>

    <span class="s1">refiner1 = mtri.UniformTriRefiner(triang1)</span>
    <span class="s1">refiner2 = mtri.UniformTriRefiner(triang2)</span>

    <span class="s1">fine_triang1 = refiner1.refine_triangulation(subdiv=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">fine_triang2 = refiner2.refine_triangulation(subdiv=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s1">assert_array_equal(fine_triang1.triangles</span><span class="s0">, </span><span class="s1">fine_triang2.triangles)</span>


<span class="s0">def </span><span class="s1">test_qhull_triangle_orientation():</span>
    <span class="s4"># github issue 4437.</span>
    <span class="s1">xi = np.linspace(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = map(np.ravel</span><span class="s0">, </span><span class="s1">np.meshgrid(xi</span><span class="s0">, </span><span class="s1">xi))</span>
    <span class="s1">w = (x &gt; y - </span><span class="s2">1</span><span class="s1">) &amp; (x &lt; -</span><span class="s2">1.95</span><span class="s1">) &amp; (y &gt; -</span><span class="s2">1.2</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y = x[w]</span><span class="s0">, </span><span class="s1">y[w]</span>
    <span class="s1">theta = np.radians(</span><span class="s2">25</span><span class="s1">)</span>
    <span class="s1">x1 = x*np.cos(theta) - y*np.sin(theta)</span>
    <span class="s1">y1 = x*np.sin(theta) + y*np.cos(theta)</span>

    <span class="s4"># Calculate Delaunay triangulation using Qhull.</span>
    <span class="s1">triang = mtri.Triangulation(x1</span><span class="s0">, </span><span class="s1">y1)</span>

    <span class="s4"># Neighbors returned by Qhull.</span>
    <span class="s1">qhull_neighbors = triang.neighbors</span>

    <span class="s4"># Obtain neighbors using own C++ calculation.</span>
    <span class="s1">triang._neighbors = </span><span class="s0">None</span>
    <span class="s1">own_neighbors = triang.neighbors</span>

    <span class="s1">assert_array_equal(qhull_neighbors</span><span class="s0">, </span><span class="s1">own_neighbors)</span>


<span class="s0">def </span><span class="s1">test_trianalyzer_mismatched_indices():</span>
    <span class="s4"># github issue 4999.</span>
    <span class="s1">x = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">2.</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">*np.sqrt(</span><span class="s2">3.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])</span>
    <span class="s1">triangles = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
    <span class="s1">mask = np.array([</span><span class="s0">False, False, True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">triangles</span><span class="s0">, </span><span class="s1">mask=mask)</span>
    <span class="s1">analyser = mtri.TriAnalyzer(triang)</span>
    <span class="s4"># numpy &gt;= 1.10 raises a VisibleDeprecationWarning in the following line</span>
    <span class="s4"># prior to the fix.</span>
    <span class="s1">analyser._get_compressed_triangulation()</span>


<span class="s0">def </span><span class="s1">test_tricontourf_decreasing_levels():</span>
    <span class="s4"># github issue 5477.</span>
    <span class="s1">x = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
    <span class="s1">z = [</span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]</span>
    <span class="s1">plt.figure()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">plt.tricontourf(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_internal_cpp_api():</span>
    <span class="s4"># Following github issue 8197.</span>
    <span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_tri  </span><span class="s4"># noqa: ensure lazy-loaded module *is* loaded.</span>

    <span class="s4"># C++ Triangulation.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'__init__\(\): incompatible constructor arguments.'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">r'x and y must be 1D arrays of the same length'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation([]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'triangles must be a 2D array of shape \(\?,3\)'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">tris = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'mask must be a 1D array with the same length as the '</span>
                  <span class="s3">r'triangles array'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">tris</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">r'edges must be a 2D array with shape \(\?,2\)'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">tris</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'neighbors must be a 2D array with the same shape as the '</span>
                  <span class="s3">r'triangles array'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">tris</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">[[-</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">triang = mpl._tri.Triangulation(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">tris</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'z must be a 1D array with the same length as the '</span>
                  <span class="s3">r'triangulation x and y arrays'</span><span class="s1">):</span>
        <span class="s1">triang.calculate_plane_coefficients([])</span>

    <span class="s0">for </span><span class="s1">mask </span><span class="s0">in </span><span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, None</span><span class="s1">):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(</span>
                <span class="s1">ValueError</span><span class="s0">,</span>
                <span class="s1">match=</span><span class="s3">r'mask must be a 1D array with the same length as the '</span>
                      <span class="s3">r'triangles array'</span><span class="s1">):</span>
            <span class="s1">triang.set_mask(mask)</span>

    <span class="s1">triang.set_mask([</span><span class="s0">True</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(triang.get_edges()</span><span class="s0">, </span><span class="s1">np.empty((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>

    <span class="s1">triang.set_mask(())  </span><span class="s4"># Equivalent to Python Triangulation mask=None</span>
    <span class="s1">assert_array_equal(triang.get_edges()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s4"># C++ TriContourGenerator.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'__init__\(\): incompatible constructor arguments.'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.TriContourGenerator()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'z must be a 1D array with the same length as the x and y '</span>
                  <span class="s3">r'arrays'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.TriContourGenerator(triang</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s1">z = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span>
    <span class="s1">tcg = mpl._tri.TriContourGenerator(triang</span><span class="s0">, </span><span class="s1">z)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">r'filled contour levels must be increasing'</span><span class="s1">):</span>
        <span class="s1">tcg.create_filled_contour(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s4"># C++ TrapezoidMapTriFinder.</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r'__init__\(\): incompatible constructor arguments.'</span><span class="s1">):</span>
        <span class="s1">mpl._tri.TrapezoidMapTriFinder()</span>

    <span class="s1">trifinder = mpl._tri.TrapezoidMapTriFinder(triang)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">r'x and y must be array-like with same shape'</span><span class="s1">):</span>
        <span class="s1">trifinder.find_many([</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_qhull_large_offset():</span>
    <span class="s4"># github issue 8682.</span>
    <span class="s1">x = np.asarray([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>
    <span class="s1">y = np.asarray([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">])</span>

    <span class="s1">offset = </span><span class="s2">1e10</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">triang_offset = mtri.Triangulation(x + offset</span><span class="s0">, </span><span class="s1">y + offset)</span>
    <span class="s0">assert </span><span class="s1">len(triang.triangles) == len(triang_offset.triangles)</span>


<span class="s0">def </span><span class="s1">test_tricontour_non_finite_z():</span>
    <span class="s4"># github issue 10167.</span>
    <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">triang = mtri.Triangulation(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">plt.figure()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'z array must not contain non-finite '</span>
                                         <span class="s3">'values within the triangulation'</span><span class="s1">):</span>
        <span class="s1">plt.tricontourf(triang</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.inf])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'z array must not contain non-finite '</span>
                                         <span class="s3">'values within the triangulation'</span><span class="s1">):</span>
        <span class="s1">plt.tricontourf(triang</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-np.inf])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'z array must not contain non-finite '</span>
                                         <span class="s3">'values within the triangulation'</span><span class="s1">):</span>
        <span class="s1">plt.tricontourf(triang</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.nan])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">'z must not contain masked points '</span>
                                         <span class="s3">'within the triangulation'</span><span class="s1">):</span>
        <span class="s1">plt.tricontourf(triang</span><span class="s0">, </span><span class="s1">np.ma.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mask=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_tricontourset_reuse():</span>
    <span class="s4"># If TriContourSet returned from one tricontour(f) call is passed as first</span>
    <span class="s4"># argument to another the underlying C++ contour generator will be reused.</span>
    <span class="s1">x = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span>
    <span class="s1">z = [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">tcs1 = ax.tricontourf(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s1">tcs2 = ax.tricontour(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s0">assert </span><span class="s1">tcs2._contour_generator != tcs1._contour_generator</span>
    <span class="s1">tcs3 = ax.tricontour(tcs1</span><span class="s0">, </span><span class="s1">z)</span>
    <span class="s0">assert </span><span class="s1">tcs3._contour_generator == tcs1._contour_generator</span>


<span class="s1">@check_figures_equal()</span>
<span class="s0">def </span><span class="s1">test_triplot_with_ls(fig_test</span><span class="s0">, </span><span class="s1">fig_ref):</span>
    <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">data = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
    <span class="s1">fig_test.subplots().triplot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">ls=</span><span class="s3">'--'</span><span class="s1">)</span>
    <span class="s1">fig_ref.subplots().triplot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">linestyle=</span><span class="s3">'--'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_triplot_label():</span>
    <span class="s1">x = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">y = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">data = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = plt.subplots()</span>
    <span class="s1">lines</span><span class="s0">, </span><span class="s1">markers = ax.triplot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">label=</span><span class="s3">'label'</span><span class="s1">)</span>
    <span class="s1">handles</span><span class="s0">, </span><span class="s1">labels = ax.get_legend_handles_labels()</span>
    <span class="s0">assert </span><span class="s1">labels == [</span><span class="s3">'label'</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">len(handles) == </span><span class="s2">1</span>
    <span class="s0">assert </span><span class="s1">handles[</span><span class="s2">0</span><span class="s1">] </span><span class="s0">is </span><span class="s1">lines</span>
</pre>
</body>
</html>