<html>
<head>
<title>_flag.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_flag.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2017 The Abseil Authors.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>

<span class="s2">&quot;&quot;&quot;Contains Flag class - information about single command-line flag. 
 
Do NOT import this module directly. Import the flags package and use the 
aliases defined at the package level instead. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">abc</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">functools</span>

<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_argument_parser</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_exceptions</span>
<span class="s3">from </span><span class="s1">absl.flags </span><span class="s3">import </span><span class="s1">_helpers</span>


<span class="s1">@functools.total_ordering</span>
<span class="s3">class </span><span class="s1">Flag(object):</span>
  <span class="s2">&quot;&quot;&quot;Information about a command-line flag. 
 
  Attributes: 
    name: the name for this flag 
    default: the default value for this flag 
    default_unparsed: the unparsed default value for this flag. 
    default_as_str: default value as repr'd string, e.g., &quot;'true'&quot; 
      (or None) 
    value: the most recent parsed value of this flag set by :meth:`parse` 
    help: a help string or None if no help is available 
    short_name: the single letter alias for this flag (or None) 
    boolean: if 'true', this flag does not accept arguments 
    present: true if this flag was parsed from command line flags 
    parser: an :class:`~absl.flags.ArgumentParser` object 
    serializer: an ArgumentSerializer object 
    allow_override: the flag may be redefined without raising an error, 
      and newly defined flag overrides the old one. 
    allow_override_cpp: use the flag from C++ if available the flag 
      definition is replaced by the C++ flag after init 
    allow_hide_cpp: use the Python flag despite having a C++ flag with 
      the same name (ignore the C++ flag) 
    using_default_value: the flag value has not been set by user 
    allow_overwrite: the flag may be parsed more than once without 
      raising an error, the last set value will be used 
    allow_using_method_names: whether this flag can be defined even if 
      it has a name that conflicts with a FlagValues method. 
    validators: list of the flag validators. 
 
  The only public method of a ``Flag`` object is :meth:`parse`, but it is 
  typically only called by a :class:`~absl.flags.FlagValues` object.  The 
  :meth:`parse` method is a thin wrapper around the 
  :meth:`ArgumentParser.parse()&lt;absl.flags.ArgumentParser.parse&gt;` method.  The 
  parsed value is saved in ``.value``, and the ``.present`` attribute is 
  updated.  If this flag was already present, an Error is raised. 
 
  :meth:`parse` is also called during ``__init__`` to parse the default value 
  and initialize the ``.value`` attribute.  This enables other python modules to 
  safely use flags even if the ``__main__`` module neglects to parse the 
  command line arguments.  The ``.present`` attribute is cleared after 
  ``__init__`` parsing.  If the default value is set to ``None``, then the 
  ``__init__`` parsing step is skipped and the ``.value`` attribute is 
  initialized to None. 
 
  Note: The default value is also presented to the user in the help 
  string, so it is important that it be a legal value for this flag. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">parser</span><span class="s3">, </span><span class="s1">serializer</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help_string</span><span class="s3">,</span>
               <span class="s1">short_name=</span><span class="s3">None, </span><span class="s1">boolean=</span><span class="s3">False, </span><span class="s1">allow_override=</span><span class="s3">False,</span>
               <span class="s1">allow_override_cpp=</span><span class="s3">False, </span><span class="s1">allow_hide_cpp=</span><span class="s3">False,</span>
               <span class="s1">allow_overwrite=</span><span class="s3">True, </span><span class="s1">allow_using_method_names=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s1">self.name = name</span>

    <span class="s3">if not </span><span class="s1">help_string:</span>
      <span class="s1">help_string = </span><span class="s4">'(no help available)'</span>

    <span class="s1">self.help = help_string</span>
    <span class="s1">self.short_name = short_name</span>
    <span class="s1">self.boolean = boolean</span>
    <span class="s1">self.present = </span><span class="s5">0</span>
    <span class="s1">self.parser = parser</span>
    <span class="s1">self.serializer = serializer</span>
    <span class="s1">self.allow_override = allow_override</span>
    <span class="s1">self.allow_override_cpp = allow_override_cpp</span>
    <span class="s1">self.allow_hide_cpp = allow_hide_cpp</span>
    <span class="s1">self.allow_overwrite = allow_overwrite</span>
    <span class="s1">self.allow_using_method_names = allow_using_method_names</span>

    <span class="s1">self.using_default_value = </span><span class="s3">True</span>
    <span class="s1">self._value = </span><span class="s3">None</span>
    <span class="s1">self.validators = []</span>
    <span class="s3">if </span><span class="s1">self.allow_hide_cpp </span><span class="s3">and </span><span class="s1">self.allow_override_cpp:</span>
      <span class="s3">raise </span><span class="s1">_exceptions.Error(</span>
          <span class="s4">&quot;Can't have both allow_hide_cpp (means use Python flag) and &quot;</span>
          <span class="s4">'allow_override_cpp (means use C++ flag after InitGoogle)'</span><span class="s1">)</span>

    <span class="s1">self._set_default(default)</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">value(self):</span>
    <span class="s3">return </span><span class="s1">self._value</span>

  <span class="s1">@value.setter</span>
  <span class="s3">def </span><span class="s1">value(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s1">self._value = value</span>

  <span class="s3">def </span><span class="s1">__hash__(self):</span>
    <span class="s3">return </span><span class="s1">hash(id(self))</span>

  <span class="s3">def </span><span class="s1">__eq__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">return </span><span class="s1">self </span><span class="s3">is </span><span class="s1">other</span>

  <span class="s3">def </span><span class="s1">__lt__(self</span><span class="s3">, </span><span class="s1">other):</span>
    <span class="s3">if </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Flag):</span>
      <span class="s3">return </span><span class="s1">id(self) &lt; id(other)</span>
    <span class="s3">return </span><span class="s1">NotImplemented</span>

  <span class="s3">def </span><span class="s1">__bool__(self):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'A Flag instance would always be True. '</span>
                    <span class="s4">'Did you mean to test the `.value` attribute?'</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__getstate__(self):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;can't pickle Flag objects&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__copy__(self):</span>
    <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">'%s does not support shallow copies. '</span>
                    <span class="s4">'Use copy.deepcopy instead.' </span><span class="s1">% type(self).__name__)</span>

  <span class="s3">def </span><span class="s1">__deepcopy__(self</span><span class="s3">, </span><span class="s1">memo):</span>
    <span class="s1">result = object.__new__(type(self))</span>
    <span class="s1">result.__dict__ = copy.deepcopy(self.__dict__</span><span class="s3">, </span><span class="s1">memo)</span>
    <span class="s3">return </span><span class="s1">result</span>

  <span class="s3">def </span><span class="s1">_get_parsed_value_as_string(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Returns parsed flag value as string.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return None</span>
    <span class="s3">if </span><span class="s1">self.serializer:</span>
      <span class="s3">return </span><span class="s1">repr(self.serializer.serialize(value))</span>
    <span class="s3">if </span><span class="s1">self.boolean:</span>
      <span class="s3">if </span><span class="s1">value:</span>
        <span class="s3">return </span><span class="s1">repr(</span><span class="s4">'true'</span><span class="s1">)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">repr(</span><span class="s4">'false'</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">repr(str(value))</span>

  <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">argument):</span>
    <span class="s2">&quot;&quot;&quot;Parses string and sets flag value. 
 
    Args: 
      argument: str or the correct flag value type, argument to be parsed. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self.present </span><span class="s3">and not </span><span class="s1">self.allow_overwrite:</span>
      <span class="s3">raise </span><span class="s1">_exceptions.IllegalFlagValueError(</span>
          <span class="s4">'flag --%s=%s: already defined as %s' </span><span class="s1">% (</span>
              <span class="s1">self.name</span><span class="s3">, </span><span class="s1">argument</span><span class="s3">, </span><span class="s1">self.value))</span>
    <span class="s1">self.value = self._parse(argument)</span>
    <span class="s1">self.present += </span><span class="s5">1</span>

  <span class="s3">def </span><span class="s1">_parse(self</span><span class="s3">, </span><span class="s1">argument):</span>
    <span class="s2">&quot;&quot;&quot;Internal parse function. 
 
    It returns the parsed value, and does not modify class states. 
 
    Args: 
      argument: str or the correct flag value type, argument to be parsed. 
 
    Returns: 
      The parsed value. 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">self.parser.parse(argument)</span>
    <span class="s3">except </span><span class="s1">(TypeError</span><span class="s3">, </span><span class="s1">ValueError) </span><span class="s3">as </span><span class="s1">e:  </span><span class="s0"># Recast as IllegalFlagValueError.</span>
      <span class="s3">raise </span><span class="s1">_exceptions.IllegalFlagValueError(</span>
          <span class="s4">'flag --%s=%s: %s' </span><span class="s1">% (self.name</span><span class="s3">, </span><span class="s1">argument</span><span class="s3">, </span><span class="s1">e))</span>

  <span class="s3">def </span><span class="s1">unparse(self):</span>
    <span class="s1">self.value = self.default</span>
    <span class="s1">self.using_default_value = </span><span class="s3">True</span>
    <span class="s1">self.present = </span><span class="s5">0</span>

  <span class="s3">def </span><span class="s1">serialize(self):</span>
    <span class="s2">&quot;&quot;&quot;Serializes the flag.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self._serialize(self.value)</span>

  <span class="s3">def </span><span class="s1">_serialize(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Internal serialize function.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">''</span>
    <span class="s3">if </span><span class="s1">self.boolean:</span>
      <span class="s3">if </span><span class="s1">value:</span>
        <span class="s3">return </span><span class="s4">'--%s' </span><span class="s1">% self.name</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">'--no%s' </span><span class="s1">% self.name</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">if not </span><span class="s1">self.serializer:</span>
        <span class="s3">raise </span><span class="s1">_exceptions.Error(</span>
            <span class="s4">'Serializer not present for flag %s' </span><span class="s1">% self.name)</span>
      <span class="s3">return </span><span class="s4">'--%s=%s' </span><span class="s1">% (self.name</span><span class="s3">, </span><span class="s1">self.serializer.serialize(value))</span>

  <span class="s3">def </span><span class="s1">_set_default(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Changes the default value (and current value too) for this Flag.&quot;&quot;&quot;</span>
    <span class="s1">self.default_unparsed = value</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s1">self.default = </span><span class="s3">None</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">self.default = self._parse_from_default(value)</span>
    <span class="s1">self.default_as_str = self._get_parsed_value_as_string(self.default)</span>
    <span class="s3">if </span><span class="s1">self.using_default_value:</span>
      <span class="s1">self.value = self.default</span>

  <span class="s0"># This is split out so that aliases can skip regular parsing of the default</span>
  <span class="s0"># value.</span>
  <span class="s3">def </span><span class="s1">_parse_from_default(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s3">return </span><span class="s1">self._parse(value)</span>

  <span class="s3">def </span><span class="s1">flag_type(self):</span>
    <span class="s2">&quot;&quot;&quot;Returns a str that describes the type of the flag. 
 
    NOTE: we use strings, and not the types.*Type constants because 
    our flags can have more exotic types, e.g., 'comma separated list 
    of strings', 'whitespace separated list of strings', etc. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">self.parser.flag_type()</span>

  <span class="s3">def </span><span class="s1">_create_xml_dom_element(self</span><span class="s3">, </span><span class="s1">doc</span><span class="s3">, </span><span class="s1">module_name</span><span class="s3">, </span><span class="s1">is_key=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Returns an XML element that contains this flag's information. 
 
    This is information that is relevant to all flags (e.g., name, 
    meaning, etc.).  If you defined a flag that has some other pieces of 
    info, then please override _ExtraXMLInfo. 
 
    Please do NOT override this method. 
 
    Args: 
      doc: minidom.Document, the DOM document it should create nodes from. 
      module_name: str,, the name of the module that defines this flag. 
      is_key: boolean, True iff this flag is key for main module. 
 
    Returns: 
      A minidom.Element instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">element = doc.createElement(</span><span class="s4">'flag'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">is_key:</span>
      <span class="s1">element.appendChild(_helpers.create_xml_dom_element(doc</span><span class="s3">, </span><span class="s4">'key'</span><span class="s3">, </span><span class="s4">'yes'</span><span class="s1">))</span>
    <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
        <span class="s1">doc</span><span class="s3">, </span><span class="s4">'file'</span><span class="s3">, </span><span class="s1">module_name))</span>
    <span class="s0"># Adds flag features that are relevant for all flags.</span>
    <span class="s1">element.appendChild(_helpers.create_xml_dom_element(doc</span><span class="s3">, </span><span class="s4">'name'</span><span class="s3">, </span><span class="s1">self.name))</span>
    <span class="s3">if </span><span class="s1">self.short_name:</span>
      <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
          <span class="s1">doc</span><span class="s3">, </span><span class="s4">'short_name'</span><span class="s3">, </span><span class="s1">self.short_name))</span>
    <span class="s3">if </span><span class="s1">self.help:</span>
      <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
          <span class="s1">doc</span><span class="s3">, </span><span class="s4">'meaning'</span><span class="s3">, </span><span class="s1">self.help))</span>
    <span class="s0"># The default flag value can either be represented as a string like on the</span>
    <span class="s0"># command line, or as a Python object.  We serialize this value in the</span>
    <span class="s0"># latter case in order to remain consistent.</span>
    <span class="s3">if </span><span class="s1">self.serializer </span><span class="s3">and not </span><span class="s1">isinstance(self.default</span><span class="s3">, </span><span class="s1">str):</span>
      <span class="s3">if </span><span class="s1">self.default </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">default_serialized = self.serializer.serialize(self.default)</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">default_serialized = </span><span class="s4">''</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">default_serialized = self.default</span>
    <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
        <span class="s1">doc</span><span class="s3">, </span><span class="s4">'default'</span><span class="s3">, </span><span class="s1">default_serialized))</span>
    <span class="s1">value_serialized = self._serialize_value_for_xml(self.value)</span>
    <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
        <span class="s1">doc</span><span class="s3">, </span><span class="s4">'current'</span><span class="s3">, </span><span class="s1">value_serialized))</span>
    <span class="s1">element.appendChild(_helpers.create_xml_dom_element(</span>
        <span class="s1">doc</span><span class="s3">, </span><span class="s4">'type'</span><span class="s3">, </span><span class="s1">self.flag_type()))</span>
    <span class="s0"># Adds extra flag features this flag may have.</span>
    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">self._extra_xml_dom_elements(doc):</span>
      <span class="s1">element.appendChild(e)</span>
    <span class="s3">return </span><span class="s1">element</span>

  <span class="s3">def </span><span class="s1">_serialize_value_for_xml(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;Returns the serialized value, for use in an XML help text.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">value</span>

  <span class="s3">def </span><span class="s1">_extra_xml_dom_elements(self</span><span class="s3">, </span><span class="s1">doc):</span>
    <span class="s2">&quot;&quot;&quot;Returns extra info about this flag in XML. 
 
    &quot;Extra&quot; means &quot;not already included by _create_xml_dom_element above.&quot; 
 
    Args: 
      doc: minidom.Document, the DOM document it should create nodes from. 
 
    Returns: 
      A list of minidom.Element. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Usually, the parser knows the extra details about the flag, so</span>
    <span class="s0"># we just forward the call to it.</span>
    <span class="s3">return </span><span class="s1">self.parser._custom_xml_dom_elements(doc)  </span><span class="s0"># pylint: disable=protected-access</span>


<span class="s3">class </span><span class="s1">BooleanFlag(Flag):</span>
  <span class="s2">&quot;&quot;&quot;Basic boolean flag. 
 
  Boolean flags do not take any arguments, and their value is either 
  ``True`` (1) or ``False`` (0).  The false value is specified on the command 
  line by prepending the word ``'no'`` to either the long or the short flag 
  name. 
 
  For example, if a Boolean flag was created whose long name was 
  ``'update'`` and whose short name was ``'x'``, then this flag could be 
  explicitly unset through either ``--noupdate`` or ``--nox``. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">short_name=</span><span class="s3">None, </span><span class="s1">**args):  </span><span class="s0"># pylint: disable=redefined-builtin</span>
    <span class="s1">p = _argument_parser.BooleanParser()</span>
    <span class="s1">super(BooleanFlag</span><span class="s3">, </span><span class="s1">self).__init__(</span>
        <span class="s1">p</span><span class="s3">, None, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">short_name</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">**args)</span>


<span class="s3">class </span><span class="s1">EnumFlag(Flag):</span>
  <span class="s2">&quot;&quot;&quot;Basic enum flag; its value can be any string from list of enum_values.&quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">enum_values</span><span class="s3">,  </span><span class="s0"># pylint: disable=redefined-builtin</span>
               <span class="s1">short_name=</span><span class="s3">None, </span><span class="s1">case_sensitive=</span><span class="s3">True, </span><span class="s1">**args):</span>
    <span class="s1">p = _argument_parser.EnumParser(enum_values</span><span class="s3">, </span><span class="s1">case_sensitive)</span>
    <span class="s1">g = _argument_parser.ArgumentSerializer()</span>
    <span class="s1">super(EnumFlag</span><span class="s3">, </span><span class="s1">self).__init__(</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">short_name</span><span class="s3">, </span><span class="s1">**args)</span>
    <span class="s1">self.help = </span><span class="s4">'&lt;%s&gt;: %s' </span><span class="s1">% (</span><span class="s4">'|'</span><span class="s1">.join(enum_values)</span><span class="s3">, </span><span class="s1">self.help)</span>

  <span class="s3">def </span><span class="s1">_extra_xml_dom_elements(self</span><span class="s3">, </span><span class="s1">doc):</span>
    <span class="s1">elements = []</span>
    <span class="s3">for </span><span class="s1">enum_value </span><span class="s3">in </span><span class="s1">self.parser.enum_values:</span>
      <span class="s1">elements.append(_helpers.create_xml_dom_element(</span>
          <span class="s1">doc</span><span class="s3">, </span><span class="s4">'enum_value'</span><span class="s3">, </span><span class="s1">enum_value))</span>
    <span class="s3">return </span><span class="s1">elements</span>


<span class="s3">class </span><span class="s1">EnumClassFlag(Flag):</span>
  <span class="s2">&quot;&quot;&quot;Basic enum flag; its value is an enum class's member.&quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">name</span><span class="s3">,</span>
      <span class="s1">default</span><span class="s3">,</span>
      <span class="s1">help</span><span class="s3">,  </span><span class="s0"># pylint: disable=redefined-builtin</span>
      <span class="s1">enum_class</span><span class="s3">,</span>
      <span class="s1">short_name=</span><span class="s3">None,</span>
      <span class="s1">case_sensitive=</span><span class="s3">False,</span>
      <span class="s1">**args):</span>
    <span class="s1">p = _argument_parser.EnumClassParser(</span>
        <span class="s1">enum_class</span><span class="s3">, </span><span class="s1">case_sensitive=case_sensitive)</span>
    <span class="s1">g = _argument_parser.EnumClassSerializer(lowercase=</span><span class="s3">not </span><span class="s1">case_sensitive)</span>
    <span class="s1">super(EnumClassFlag</span><span class="s3">, </span><span class="s1">self).__init__(</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help</span><span class="s3">, </span><span class="s1">short_name</span><span class="s3">, </span><span class="s1">**args)</span>
    <span class="s1">self.help = </span><span class="s4">'&lt;%s&gt;: %s' </span><span class="s1">% (</span><span class="s4">'|'</span><span class="s1">.join(p.member_names)</span><span class="s3">, </span><span class="s1">self.help)</span>

  <span class="s3">def </span><span class="s1">_extra_xml_dom_elements(self</span><span class="s3">, </span><span class="s1">doc):</span>
    <span class="s1">elements = []</span>
    <span class="s3">for </span><span class="s1">enum_value </span><span class="s3">in </span><span class="s1">self.parser.enum_class.__members__.keys():</span>
      <span class="s1">elements.append(_helpers.create_xml_dom_element(</span>
          <span class="s1">doc</span><span class="s3">, </span><span class="s4">'enum_value'</span><span class="s3">, </span><span class="s1">enum_value))</span>
    <span class="s3">return </span><span class="s1">elements</span>


<span class="s3">class </span><span class="s1">MultiFlag(Flag):</span>
  <span class="s2">&quot;&quot;&quot;A flag that can appear multiple time on the command-line. 
 
  The value of such a flag is a list that contains the individual values 
  from all the appearances of that flag on the command-line. 
 
  See the __doc__ for Flag for most behavior of this class.  Only 
  differences in behavior are described here: 
 
    * The default value may be either a single value or an iterable of values. 
      A single value is transformed into a single-item list of that value. 
 
    * The value of the flag is always a list, even if the option was 
      only supplied once, and even if the default value is a single 
      value 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s1">super(MultiFlag</span><span class="s3">, </span><span class="s1">self).__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">self.help += </span><span class="s4">';</span><span class="s3">\n    </span><span class="s4">repeat this option to specify a list of values'</span>

  <span class="s3">def </span><span class="s1">parse(self</span><span class="s3">, </span><span class="s1">arguments):</span>
    <span class="s2">&quot;&quot;&quot;Parses one or more arguments with the installed parser. 
 
    Args: 
      arguments: a single argument or a list of arguments (typically a 
        list of default values); a single argument is converted 
        internally into a list containing one item. 
    &quot;&quot;&quot;</span>
    <span class="s1">new_values = self._parse(arguments)</span>
    <span class="s3">if </span><span class="s1">self.present:</span>
      <span class="s1">self.value.extend(new_values)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">self.value = new_values</span>
    <span class="s1">self.present += len(new_values)</span>

  <span class="s3">def </span><span class="s1">_parse(self</span><span class="s3">, </span><span class="s1">arguments):</span>
    <span class="s3">if </span><span class="s1">(isinstance(arguments</span><span class="s3">, </span><span class="s1">abc.Iterable) </span><span class="s3">and</span>
        <span class="s3">not </span><span class="s1">isinstance(arguments</span><span class="s3">, </span><span class="s1">str)):</span>
      <span class="s1">arguments = list(arguments)</span>

    <span class="s3">if not </span><span class="s1">isinstance(arguments</span><span class="s3">, </span><span class="s1">list):</span>
      <span class="s0"># Default value may be a list of values.  Most other arguments</span>
      <span class="s0"># will not be, so convert them into a single-item list to make</span>
      <span class="s0"># processing simpler below.</span>
      <span class="s1">arguments = [arguments]</span>

    <span class="s3">return </span><span class="s1">[super(MultiFlag</span><span class="s3">, </span><span class="s1">self)._parse(item) </span><span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">arguments]</span>

  <span class="s3">def </span><span class="s1">_serialize(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;See base class.&quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">self.serializer:</span>
      <span class="s3">raise </span><span class="s1">_exceptions.Error(</span>
          <span class="s4">'Serializer not present for flag %s' </span><span class="s1">% self.name)</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s4">''</span>

    <span class="s1">serialized_items = [</span>
        <span class="s1">super(MultiFlag</span><span class="s3">, </span><span class="s1">self)._serialize(value_item) </span><span class="s3">for </span><span class="s1">value_item </span><span class="s3">in </span><span class="s1">value</span>
    <span class="s1">]</span>

    <span class="s3">return </span><span class="s4">'</span><span class="s3">\n</span><span class="s4">'</span><span class="s1">.join(serialized_items)</span>

  <span class="s3">def </span><span class="s1">flag_type(self):</span>
    <span class="s2">&quot;&quot;&quot;See base class.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s4">'multi ' </span><span class="s1">+ self.parser.flag_type()</span>

  <span class="s3">def </span><span class="s1">_extra_xml_dom_elements(self</span><span class="s3">, </span><span class="s1">doc):</span>
    <span class="s1">elements = []</span>
    <span class="s3">if </span><span class="s1">hasattr(self.parser</span><span class="s3">, </span><span class="s4">'enum_values'</span><span class="s1">):</span>
      <span class="s3">for </span><span class="s1">enum_value </span><span class="s3">in </span><span class="s1">self.parser.enum_values:</span>
        <span class="s1">elements.append(_helpers.create_xml_dom_element(</span>
            <span class="s1">doc</span><span class="s3">, </span><span class="s4">'enum_value'</span><span class="s3">, </span><span class="s1">enum_value))</span>
    <span class="s3">return </span><span class="s1">elements</span>


<span class="s3">class </span><span class="s1">MultiEnumClassFlag(MultiFlag):</span>
  <span class="s2">&quot;&quot;&quot;A multi_enum_class flag. 
 
  See the __doc__ for MultiFlag for most behaviors of this class.  In addition, 
  this class knows how to handle enum.Enum instances as values for this flag 
  type. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">name</span><span class="s3">,</span>
               <span class="s1">default</span><span class="s3">,</span>
               <span class="s1">help_string</span><span class="s3">,</span>
               <span class="s1">enum_class</span><span class="s3">,</span>
               <span class="s1">case_sensitive=</span><span class="s3">False,</span>
               <span class="s1">**args):</span>
    <span class="s1">p = _argument_parser.EnumClassParser(</span>
        <span class="s1">enum_class</span><span class="s3">, </span><span class="s1">case_sensitive=case_sensitive)</span>
    <span class="s1">g = _argument_parser.EnumClassListSerializer(</span>
        <span class="s1">list_sep=</span><span class="s4">','</span><span class="s3">, </span><span class="s1">lowercase=</span><span class="s3">not </span><span class="s1">case_sensitive)</span>
    <span class="s1">super(MultiEnumClassFlag</span><span class="s3">, </span><span class="s1">self).__init__(</span>
        <span class="s1">p</span><span class="s3">, </span><span class="s1">g</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">default</span><span class="s3">, </span><span class="s1">help_string</span><span class="s3">, </span><span class="s1">**args)</span>
    <span class="s1">self.help = (</span>
        <span class="s4">'&lt;%s&gt;: %s;</span><span class="s3">\n    </span><span class="s4">repeat this option to specify a list of values' </span><span class="s1">%</span>
        <span class="s1">(</span><span class="s4">'|'</span><span class="s1">.join(p.member_names)</span><span class="s3">, </span><span class="s1">help_string </span><span class="s3">or </span><span class="s4">'(no help available)'</span><span class="s1">))</span>

  <span class="s3">def </span><span class="s1">_extra_xml_dom_elements(self</span><span class="s3">, </span><span class="s1">doc):</span>
    <span class="s1">elements = []</span>
    <span class="s3">for </span><span class="s1">enum_value </span><span class="s3">in </span><span class="s1">self.parser.enum_class.__members__.keys():</span>
      <span class="s1">elements.append(_helpers.create_xml_dom_element(</span>
          <span class="s1">doc</span><span class="s3">, </span><span class="s4">'enum_value'</span><span class="s3">, </span><span class="s1">enum_value))</span>
    <span class="s3">return </span><span class="s1">elements</span>

  <span class="s3">def </span><span class="s1">_serialize_value_for_xml(self</span><span class="s3">, </span><span class="s1">value):</span>
    <span class="s2">&quot;&quot;&quot;See base class.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s1">:</span>
      <span class="s1">value_serialized = self.serializer.serialize(value)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s1">value_serialized = </span><span class="s4">''</span>
    <span class="s3">return </span><span class="s1">value_serialized</span>
</pre>
</body>
</html>