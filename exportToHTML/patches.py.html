<html>
<head>
<title>patches.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
patches.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
Patches are `.Artist`\s with a face color and an edge color. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">SimpleNamespace</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">Affine2D</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">(_api</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">colors</span><span class="s2">, </span><span class="s1">_docstring</span><span class="s2">, </span><span class="s1">hatch </span><span class="s2">as </span><span class="s1">mhatch</span><span class="s2">,</span>
               <span class="s1">lines </span><span class="s2">as </span><span class="s1">mlines</span><span class="s2">, </span><span class="s1">transforms)</span>
<span class="s2">from </span><span class="s1">.bezier </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NonIntersectingPathException</span><span class="s2">, </span><span class="s1">get_cos_sin</span><span class="s2">, </span><span class="s1">get_intersection</span><span class="s2">,</span>
    <span class="s1">get_parallels</span><span class="s2">, </span><span class="s1">inside_circle</span><span class="s2">, </span><span class="s1">make_wedged_bezier2</span><span class="s2">,</span>
    <span class="s1">split_bezier_intersecting_with_closedpath</span><span class="s2">, </span><span class="s1">split_path_inout)</span>
<span class="s2">from </span><span class="s1">.path </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">._enums </span><span class="s2">import </span><span class="s1">JoinStyle</span><span class="s2">, </span><span class="s1">CapStyle</span>


<span class="s1">@_docstring.interpd</span>
<span class="s1">@_api.define_aliases({</span>
    <span class="s3">&quot;antialiased&quot;</span><span class="s1">: [</span><span class="s3">&quot;aa&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s3">&quot;edgecolor&quot;</span><span class="s1">: [</span><span class="s3">&quot;ec&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s3">&quot;facecolor&quot;</span><span class="s1">: [</span><span class="s3">&quot;fc&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s3">&quot;linestyle&quot;</span><span class="s1">: [</span><span class="s3">&quot;ls&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s3">&quot;linewidth&quot;</span><span class="s1">: [</span><span class="s3">&quot;lw&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">})</span>
<span class="s2">class </span><span class="s1">Patch(artist.Artist):</span>
    <span class="s0">&quot;&quot;&quot; 
    A patch is a 2D artist with a face color and an edge color. 
 
    If any of *edgecolor*, *facecolor*, *linewidth*, or *antialiased* 
    are *None*, they default to their rc params setting. 
    &quot;&quot;&quot;</span>
    <span class="s1">zorder = </span><span class="s4">1</span>

    <span class="s5"># Whether to draw an edge by default.  Set on a</span>
    <span class="s5"># subclass-by-subclass basis.</span>
    <span class="s1">_edge_default = </span><span class="s2">False</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;edgecolor&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">edgecolor=</span><span class="s2">None,</span>
                 <span class="s1">facecolor=</span><span class="s2">None,</span>
                 <span class="s1">color=</span><span class="s2">None,</span>
                 <span class="s1">linewidth=</span><span class="s2">None,</span>
                 <span class="s1">linestyle=</span><span class="s2">None,</span>
                 <span class="s1">antialiased=</span><span class="s2">None,</span>
                 <span class="s1">hatch=</span><span class="s2">None,</span>
                 <span class="s1">fill=</span><span class="s2">True,</span>
                 <span class="s1">capstyle=</span><span class="s2">None,</span>
                 <span class="s1">joinstyle=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        The following kwarg properties are supported 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>

        <span class="s2">if </span><span class="s1">linestyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">linestyle = </span><span class="s3">&quot;solid&quot;</span>
        <span class="s2">if </span><span class="s1">capstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">capstyle = CapStyle.butt</span>
        <span class="s2">if </span><span class="s1">joinstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">joinstyle = JoinStyle.miter</span>

        <span class="s1">self._hatch_color = colors.to_rgba(mpl.rcParams[</span><span class="s3">'hatch.color'</span><span class="s1">])</span>
        <span class="s1">self._fill = </span><span class="s2">True  </span><span class="s5"># needed for set_facecolor call</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">edgecolor </span><span class="s2">is not None or </span><span class="s1">facecolor </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s3">&quot;Setting the 'color' property will override &quot;</span>
                    <span class="s3">&quot;the edgecolor or facecolor properties.&quot;</span><span class="s1">)</span>
            <span class="s1">self.set_color(color)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set_edgecolor(edgecolor)</span>
            <span class="s1">self.set_facecolor(facecolor)</span>

        <span class="s1">self._linewidth = </span><span class="s4">0</span>
        <span class="s1">self._unscaled_dash_pattern = (</span><span class="s4">0</span><span class="s2">, None</span><span class="s1">)  </span><span class="s5"># offset, dash</span>
        <span class="s1">self._dash_pattern = (</span><span class="s4">0</span><span class="s2">, None</span><span class="s1">)  </span><span class="s5"># offset, dash (scaled by linewidth)</span>

        <span class="s1">self.set_fill(fill)</span>
        <span class="s1">self.set_linestyle(linestyle)</span>
        <span class="s1">self.set_linewidth(linewidth)</span>
        <span class="s1">self.set_antialiased(antialiased)</span>
        <span class="s1">self.set_hatch(hatch)</span>
        <span class="s1">self.set_capstyle(capstyle)</span>
        <span class="s1">self.set_joinstyle(joinstyle)</span>

        <span class="s2">if </span><span class="s1">len(kwargs):</span>
            <span class="s1">self._internal_update(kwargs)</span>

    <span class="s2">def </span><span class="s1">get_verts(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the vertices used in this patch. 
 
        If the patch contains BÃ©zier curves, the curves will be interpolated by 
        line segments.  To access the curves as curves, use `get_path`. 
        &quot;&quot;&quot;</span>
        <span class="s1">trans = self.get_transform()</span>
        <span class="s1">path = self.get_path()</span>
        <span class="s1">polygons = path.to_polygons(trans)</span>
        <span class="s2">if </span><span class="s1">len(polygons):</span>
            <span class="s2">return </span><span class="s1">polygons[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_process_radius(self</span><span class="s2">, </span><span class="s1">radius):</span>
        <span class="s2">if </span><span class="s1">radius </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">radius</span>
        <span class="s2">if </span><span class="s1">isinstance(self._picker</span><span class="s2">, </span><span class="s1">Number):</span>
            <span class="s1">_radius = self._picker</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.get_edgecolor()[</span><span class="s4">3</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">_radius = </span><span class="s4">0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_radius = self.get_linewidth()</span>
        <span class="s2">return </span><span class="s1">_radius</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent</span><span class="s2">, </span><span class="s1">radius=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test whether the mouse event occurred in the patch. 
 
        Returns 
        ------- 
        (bool, empty dict) 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s1">radius = self._process_radius(radius)</span>
        <span class="s1">codes = self.get_path().codes</span>
        <span class="s2">if </span><span class="s1">codes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">vertices = self.get_path().vertices</span>
            <span class="s5"># if the current path is concatenated by multiple sub paths.</span>
            <span class="s5"># get the indexes of the starting code(MOVETO) of all sub paths</span>
            <span class="s1">idxs</span><span class="s2">, </span><span class="s1">= np.where(codes == Path.MOVETO)</span>
            <span class="s5"># Don't split before the first MOVETO.</span>
            <span class="s1">idxs = idxs[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s1">subpaths = map(</span>
                <span class="s1">Path</span><span class="s2">, </span><span class="s1">np.split(vertices</span><span class="s2">, </span><span class="s1">idxs)</span><span class="s2">, </span><span class="s1">np.split(codes</span><span class="s2">, </span><span class="s1">idxs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">subpaths = [self.get_path()]</span>
        <span class="s1">inside = any(</span>
            <span class="s1">subpath.contains_point(</span>
                <span class="s1">(mouseevent.x</span><span class="s2">, </span><span class="s1">mouseevent.y)</span><span class="s2">, </span><span class="s1">self.get_transform()</span><span class="s2">, </span><span class="s1">radius)</span>
            <span class="s2">for </span><span class="s1">subpath </span><span class="s2">in </span><span class="s1">subpaths)</span>
        <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">contains_point(self</span><span class="s2">, </span><span class="s1">point</span><span class="s2">, </span><span class="s1">radius=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the given point is inside the patch. 
 
        Parameters 
        ---------- 
        point : (float, float) 
            The point (x, y) to check, in target coordinates of 
            ``self.get_transform()``. These are display coordinates for patches 
            that are added to a figure or axes. 
        radius : float, optional 
            Additional margin on the patch in target coordinates of 
            ``self.get_transform()``. See `.Path.contains_point` for further 
            details. 
 
        Returns 
        ------- 
        bool 
 
        Notes 
        ----- 
        The proper use of this method depends on the transform of the patch. 
        Isolated patches do not have a transform. In this case, the patch 
        creation coordinates and the point coordinates match. The following 
        example checks that the center of a circle is within the circle 
 
        &gt;&gt;&gt; center = 0, 0 
        &gt;&gt;&gt; c = Circle(center, radius=1) 
        &gt;&gt;&gt; c.contains_point(center) 
        True 
 
        The convention of checking against the transformed patch stems from 
        the fact that this method is predominantly used to check if display 
        coordinates (e.g. from mouse events) are within the patch. If you want 
        to do the above check with data coordinates, you have to properly 
        transform them first: 
 
        &gt;&gt;&gt; center = 0, 0 
        &gt;&gt;&gt; c = Circle(center, radius=1) 
        &gt;&gt;&gt; plt.gca().add_patch(c) 
        &gt;&gt;&gt; transformed_center = c.get_transform().transform(center) 
        &gt;&gt;&gt; c.contains_point(transformed_center) 
        True 
 
        &quot;&quot;&quot;</span>
        <span class="s1">radius = self._process_radius(radius)</span>
        <span class="s2">return </span><span class="s1">self.get_path().contains_point(point</span><span class="s2">,</span>
                                              <span class="s1">self.get_transform()</span><span class="s2">,</span>
                                              <span class="s1">radius)</span>

    <span class="s2">def </span><span class="s1">contains_points(self</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">radius=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the given points are inside the patch. 
 
        Parameters 
        ---------- 
        points : (N, 2) array 
            The points to check, in target coordinates of 
            ``self.get_transform()``. These are display coordinates for patches 
            that are added to a figure or axes. Columns contain x and y values. 
        radius : float, optional 
            Additional margin on the patch in target coordinates of 
            ``self.get_transform()``. See `.Path.contains_point` for further 
            details. 
 
        Returns 
        ------- 
        length-N bool array 
 
        Notes 
        ----- 
        The proper use of this method depends on the transform of the patch. 
        See the notes on `.Patch.contains_point`. 
        &quot;&quot;&quot;</span>
        <span class="s1">radius = self._process_radius(radius)</span>
        <span class="s2">return </span><span class="s1">self.get_path().contains_points(points</span><span class="s2">,</span>
                                               <span class="s1">self.get_transform()</span><span class="s2">,</span>
                                               <span class="s1">radius)</span>

    <span class="s2">def </span><span class="s1">update_from(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s5"># docstring inherited.</span>
        <span class="s1">super().update_from(other)</span>
        <span class="s5"># For some properties we don't need or don't want to go through the</span>
        <span class="s5"># getters/setters, so we just copy them directly.</span>
        <span class="s1">self._edgecolor = other._edgecolor</span>
        <span class="s1">self._facecolor = other._facecolor</span>
        <span class="s1">self._original_edgecolor = other._original_edgecolor</span>
        <span class="s1">self._original_facecolor = other._original_facecolor</span>
        <span class="s1">self._fill = other._fill</span>
        <span class="s1">self._hatch = other._hatch</span>
        <span class="s1">self._hatch_color = other._hatch_color</span>
        <span class="s1">self._unscaled_dash_pattern = other._unscaled_dash_pattern</span>
        <span class="s1">self.set_linewidth(other._linewidth)  </span><span class="s5"># also sets scaled dashes</span>
        <span class="s1">self.set_transform(other.get_data_transform())</span>
        <span class="s5"># If the transform of other needs further initialization, then it will</span>
        <span class="s5"># be the case for this artist too.</span>
        <span class="s1">self._transformSet = other.is_transform_set()</span>

    <span class="s2">def </span><span class="s1">get_extents(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `Patch`'s axis-aligned extents as a `~.transforms.Bbox`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_path().get_extents(self.get_transform())</span>

    <span class="s2">def </span><span class="s1">get_transform(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `~.transforms.Transform` applied to the `Patch`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_patch_transform() + artist.Artist.get_transform(self)</span>

    <span class="s2">def </span><span class="s1">get_data_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `~.transforms.Transform` mapping data coordinates to 
        physical coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">artist.Artist.get_transform(self)</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `~.transforms.Transform` instance mapping patch coordinates 
        to data coordinates. 
 
        For example, one may define a patch of a circle which represents a 
        radius of 5 by providing coordinates for a unit circle, and a 
        transform which scales the coordinates (the patch coordinate) by 5. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">transforms.IdentityTransform()</span>

    <span class="s2">def </span><span class="s1">get_antialiased(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether antialiasing is used for drawing.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._antialiased</span>

    <span class="s2">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the edge color.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._edgecolor</span>

    <span class="s2">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the face color.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._facecolor</span>

    <span class="s2">def </span><span class="s1">get_linewidth(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the line width in points.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linewidth</span>

    <span class="s2">def </span><span class="s1">get_linestyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the linestyle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._linestyle</span>

    <span class="s2">def </span><span class="s1">set_antialiased(self</span><span class="s2">, </span><span class="s1">aa):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether to use antialiased rendering. 
 
        Parameters 
        ---------- 
        aa : bool or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">aa </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">aa = mpl.rcParams[</span><span class="s3">'patch.antialiased'</span><span class="s1">]</span>
        <span class="s1">self._antialiased = aa</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_set_edgecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s1">set_hatch_color = </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(mpl.rcParams[</span><span class="s3">'patch.force_edgecolor'</span><span class="s1">] </span><span class="s2">or</span>
                    <span class="s2">not </span><span class="s1">self._fill </span><span class="s2">or </span><span class="s1">self._edge_default):</span>
                <span class="s1">color = mpl.rcParams[</span><span class="s3">'patch.edgecolor'</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">color = </span><span class="s3">'none'</span>
                <span class="s1">set_hatch_color = </span><span class="s2">False</span>

        <span class="s1">self._edgecolor = colors.to_rgba(color</span><span class="s2">, </span><span class="s1">self._alpha)</span>
        <span class="s2">if </span><span class="s1">set_hatch_color:</span>
            <span class="s1">self._hatch_color = self._edgecolor</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_edgecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the patch edge color. 
 
        Parameters 
        ---------- 
        color : color or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self._original_edgecolor = color</span>
        <span class="s1">self._set_edgecolor(color)</span>

    <span class="s2">def </span><span class="s1">_set_facecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = mpl.rcParams[</span><span class="s3">'patch.facecolor'</span><span class="s1">]</span>
        <span class="s1">alpha = self._alpha </span><span class="s2">if </span><span class="s1">self._fill </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s1">self._facecolor = colors.to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_facecolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the patch face color. 
 
        Parameters 
        ---------- 
        color : color or None 
        &quot;&quot;&quot;</span>
        <span class="s1">self._original_facecolor = color</span>
        <span class="s1">self._set_facecolor(color)</span>

    <span class="s2">def </span><span class="s1">set_color(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set both the edgecolor and the facecolor. 
 
        Parameters 
        ---------- 
        c : color 
 
        See Also 
        -------- 
        Patch.set_facecolor, Patch.set_edgecolor 
            For setting the edge or face color individually. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_facecolor(c)</span>
        <span class="s1">self.set_edgecolor(c)</span>

    <span class="s2">def </span><span class="s1">set_alpha(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s1">super().set_alpha(alpha)</span>
        <span class="s1">self._set_facecolor(self._original_facecolor)</span>
        <span class="s1">self._set_edgecolor(self._original_edgecolor)</span>
        <span class="s5"># stale is already True</span>

    <span class="s2">def </span><span class="s1">set_linewidth(self</span><span class="s2">, </span><span class="s1">w):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the patch linewidth in points. 
 
        Parameters 
        ---------- 
        w : float or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">w </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">w = mpl.rcParams[</span><span class="s3">'patch.linewidth'</span><span class="s1">]</span>
        <span class="s1">self._linewidth = float(w)</span>
        <span class="s1">self._dash_pattern = mlines._scale_dashes(</span>
            <span class="s1">*self._unscaled_dash_pattern</span><span class="s2">, </span><span class="s1">w)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_linestyle(self</span><span class="s2">, </span><span class="s1">ls):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the patch linestyle. 
 
        ==========================================  ================= 
        linestyle                                   description 
        ==========================================  ================= 
        ``'-'`` or ``'solid'``                      solid line 
        ``'--'`` or  ``'dashed'``                   dashed line 
        ``'-.'`` or  ``'dashdot'``                  dash-dotted line 
        ``':'`` or ``'dotted'``                     dotted line 
        ``'none'``, ``'None'``, ``' '``, or ``''``  draw nothing 
        ==========================================  ================= 
 
        Alternatively a dash tuple of the following form can be provided:: 
 
            (offset, onoffseq) 
 
        where ``onoffseq`` is an even length tuple of on and off ink in points. 
 
        Parameters 
        ---------- 
        ls : {'-', '--', '-.', ':', '', (offset, on-off-seq), ...} 
            The line style. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">ls </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ls = </span><span class="s3">&quot;solid&quot;</span>
        <span class="s2">if </span><span class="s1">ls </span><span class="s2">in </span><span class="s1">[</span><span class="s3">' '</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s3">'none'</span><span class="s1">]:</span>
            <span class="s1">ls = </span><span class="s3">'None'</span>
        <span class="s1">self._linestyle = ls</span>
        <span class="s1">self._unscaled_dash_pattern = mlines._get_dash_pattern(ls)</span>
        <span class="s1">self._dash_pattern = mlines._scale_dashes(</span>
            <span class="s1">*self._unscaled_dash_pattern</span><span class="s2">, </span><span class="s1">self._linewidth)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fill(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether to fill the patch. 
 
        Parameters 
        ---------- 
        b : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fill = bool(b)</span>
        <span class="s1">self._set_facecolor(self._original_facecolor)</span>
        <span class="s1">self._set_edgecolor(self._original_edgecolor)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_fill(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the patch is filled.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fill</span>

    <span class="s5"># Make fill a property so as to preserve the long-standing</span>
    <span class="s5"># but somewhat inconsistent behavior in which fill was an</span>
    <span class="s5"># attribute.</span>
    <span class="s1">fill = property(get_fill</span><span class="s2">, </span><span class="s1">set_fill)</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_capstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the `.CapStyle`. 
 
        The default capstyle is 'round' for `.FancyArrowPatch` and 'butt' for 
        all other patches. 
 
        Parameters 
        ---------- 
        s : `.CapStyle` or %(CapStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">cs = CapStyle(s)</span>
        <span class="s1">self._capstyle = cs</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_capstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the capstyle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._capstyle.name</span>

    <span class="s1">@_docstring.interpd</span>
    <span class="s2">def </span><span class="s1">set_joinstyle(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the `.JoinStyle`. 
 
        The default joinstyle is 'round' for `.FancyArrowPatch` and 'miter' for 
        all other patches. 
 
        Parameters 
        ---------- 
        s : `.JoinStyle` or %(JoinStyle)s 
        &quot;&quot;&quot;</span>
        <span class="s1">js = JoinStyle(s)</span>
        <span class="s1">self._joinstyle = js</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_joinstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the joinstyle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._joinstyle.name</span>

    <span class="s2">def </span><span class="s1">set_hatch(self</span><span class="s2">, </span><span class="s1">hatch):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set the hatching pattern. 
 
        *hatch* can be one of:: 
 
          /   - diagonal hatching 
          \   - back diagonal 
          |   - vertical 
          -   - horizontal 
          +   - crossed 
          x   - crossed diagonal 
          o   - small circle 
          O   - large circle 
          .   - dots 
          *   - stars 
 
        Letters can be combined, in which case all the specified 
        hatchings are done.  If same letter repeats, it increases the 
        density of hatching of that pattern. 
 
        Hatching is supported in the PostScript, PDF, SVG and Agg 
        backends only. 
 
        Parameters 
        ---------- 
        hatch : {'/', '\\', '|', '-', '+', 'x', 'o', 'O', '.', '*'} 
        &quot;&quot;&quot;</span>
        <span class="s5"># Use validate_hatch(list) after deprecation.</span>
        <span class="s1">mhatch._validate_hatch_pattern(hatch)</span>
        <span class="s1">self._hatch = hatch</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_hatch(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the hatching pattern.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._hatch</span>

    <span class="s2">def </span><span class="s1">_draw_paths_with_artist_properties(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">draw_path_args_list):</span>
        <span class="s0">&quot;&quot;&quot; 
        ``draw()`` helper factored out for sharing with `FancyArrowPatch`. 
 
        Configure *renderer* and the associated graphics context *gc* 
        from the artist properties, then repeatedly call 
        ``renderer.draw_path(gc, *draw_path_args)`` for each tuple 
        *draw_path_args* in *draw_path_args_list*. 
        &quot;&quot;&quot;</span>

        <span class="s1">renderer.open_group(</span><span class="s3">'patch'</span><span class="s2">, </span><span class="s1">self.get_gid())</span>
        <span class="s1">gc = renderer.new_gc()</span>

        <span class="s1">gc.set_foreground(self._edgecolor</span><span class="s2">, </span><span class="s1">isRGBA=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">lw = self._linewidth</span>
        <span class="s2">if </span><span class="s1">self._edgecolor[</span><span class="s4">3</span><span class="s1">] == </span><span class="s4">0 </span><span class="s2">or </span><span class="s1">self._linestyle == </span><span class="s3">'None'</span><span class="s1">:</span>
            <span class="s1">lw = </span><span class="s4">0</span>
        <span class="s1">gc.set_linewidth(lw)</span>
        <span class="s1">gc.set_dashes(*self._dash_pattern)</span>
        <span class="s1">gc.set_capstyle(self._capstyle)</span>
        <span class="s1">gc.set_joinstyle(self._joinstyle)</span>

        <span class="s1">gc.set_antialiased(self._antialiased)</span>
        <span class="s1">self._set_gc_clip(gc)</span>
        <span class="s1">gc.set_url(self._url)</span>
        <span class="s1">gc.set_snap(self.get_snap())</span>

        <span class="s1">gc.set_alpha(self._alpha)</span>

        <span class="s2">if </span><span class="s1">self._hatch:</span>
            <span class="s1">gc.set_hatch(self._hatch)</span>
            <span class="s1">gc.set_hatch_color(self._hatch_color)</span>

        <span class="s2">if </span><span class="s1">self.get_sketch_params() </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">gc.set_sketch_params(*self.get_sketch_params())</span>

        <span class="s2">if </span><span class="s1">self.get_path_effects():</span>
            <span class="s2">from </span><span class="s1">matplotlib.patheffects </span><span class="s2">import </span><span class="s1">PathEffectRenderer</span>
            <span class="s1">renderer = PathEffectRenderer(self.get_path_effects()</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s2">for </span><span class="s1">draw_path_args </span><span class="s2">in </span><span class="s1">draw_path_args_list:</span>
            <span class="s1">renderer.draw_path(gc</span><span class="s2">, </span><span class="s1">*draw_path_args)</span>

        <span class="s1">gc.restore()</span>
        <span class="s1">renderer.close_group(</span><span class="s3">'patch'</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s5"># docstring inherited</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s1">path = self.get_path()</span>
        <span class="s1">transform = self.get_transform()</span>
        <span class="s1">tpath = transform.transform_path_non_affine(path)</span>
        <span class="s1">affine = transform.get_affine()</span>
        <span class="s1">self._draw_paths_with_artist_properties(</span>
            <span class="s1">renderer</span><span class="s2">,</span>
            <span class="s1">[(tpath</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">,</span>
              <span class="s5"># Work around a bug in the PDF and SVG renderers, which</span>
              <span class="s5"># do not draw the hatches if the facecolor is fully</span>
              <span class="s5"># transparent, but do if it is None.</span>
              <span class="s1">self._facecolor </span><span class="s2">if </span><span class="s1">self._facecolor[</span><span class="s4">3</span><span class="s1">] </span><span class="s2">else None</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the path of this patch.&quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Derived must override'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.get_path().get_extents(self.get_transform())</span>

    <span class="s2">def </span><span class="s1">_convert_xy_units(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot;Convert x and y units for a tuple (x, y).&quot;&quot;&quot;</span>
        <span class="s1">x = self.convert_xunits(xy[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">y = self.convert_yunits(xy[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>


<span class="s2">class </span><span class="s1">Shadow(Patch):</span>
    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">f&quot;Shadow(</span><span class="s2">{</span><span class="s1">self.patch</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">patch</span><span class="s2">, </span><span class="s1">ox</span><span class="s2">, </span><span class="s1">oy</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a shadow of the given *patch*. 
 
        By default, the shadow will have the same face color as the *patch*, 
        but darkened. 
 
        Parameters 
        ---------- 
        patch : `.Patch` 
            The patch to create the shadow for. 
        ox, oy : float 
            The shift of the shadow in data coordinates, scaled by a factor 
            of dpi/72. 
        **kwargs 
            Properties of the shadow patch. Supported keys are: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.patch = patch</span>
        <span class="s1">self._ox</span><span class="s2">, </span><span class="s1">self._oy = ox</span><span class="s2">, </span><span class="s1">oy</span>
        <span class="s1">self._shadow_transform = transforms.Affine2D()</span>

        <span class="s1">self.update_from(self.patch)</span>
        <span class="s1">color = </span><span class="s4">.3 </span><span class="s1">* np.asarray(colors.to_rgb(self.patch.get_facecolor()))</span>
        <span class="s1">self.update({</span><span class="s3">'facecolor'</span><span class="s1">: color</span><span class="s2">, </span><span class="s3">'edgecolor'</span><span class="s1">: color</span><span class="s2">, </span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s4">0.5</span><span class="s2">,</span>
                     <span class="s5"># Place shadow patch directly behind the inherited patch.</span>
                     <span class="s3">'zorder'</span><span class="s1">: np.nextafter(self.patch.zorder</span><span class="s2">, </span><span class="s1">-np.inf)</span><span class="s2">,</span>
                     <span class="s1">**kwargs})</span>

    <span class="s2">def </span><span class="s1">_update_transform(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">ox = renderer.points_to_pixels(self._ox)</span>
        <span class="s1">oy = renderer.points_to_pixels(self._oy)</span>
        <span class="s1">self._shadow_transform.clear().translate(ox</span><span class="s2">, </span><span class="s1">oy)</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">return </span><span class="s1">self.patch.get_path()</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s2">return </span><span class="s1">self.patch.get_patch_transform() + self._shadow_transform</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self._update_transform(renderer)</span>
        <span class="s1">super().draw(renderer)</span>


<span class="s2">class </span><span class="s1">Rectangle(Patch):</span>
    <span class="s0">&quot;&quot;&quot; 
    A rectangle defined via an anchor point *xy* and its *width* and *height*. 
 
    The rectangle extends from ``xy[0]`` to ``xy[0] + width`` in x-direction 
    and from ``xy[1]`` to ``xy[1] + height`` in y-direction. :: 
 
      :                +------------------+ 
      :                |                  | 
      :              height               | 
      :                |                  | 
      :               (xy)---- width -----+ 
 
    One may picture *xy* as the bottom left corner, but which corner *xy* is 
    actually depends on the direction of the axis and the sign of *width* 
    and *height*; e.g. *xy* would be the bottom right corner if the x-axis 
    was inverted or if *width* was negative. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">pars = self._x0</span><span class="s2">, </span><span class="s1">self._y0</span><span class="s2">, </span><span class="s1">self._width</span><span class="s2">, </span><span class="s1">self._height</span><span class="s2">, </span><span class="s1">self.angle</span>
        <span class="s1">fmt = </span><span class="s3">&quot;Rectangle(xy=(%g, %g), width=%g, height=%g, angle=%g)&quot;</span>
        <span class="s2">return </span><span class="s1">fmt % pars</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;angle&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">rotation_point=</span><span class="s3">'xy'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : (float, float) 
            The anchor point. 
        width : float 
            Rectangle width. 
        height : float 
            Rectangle height. 
        angle : float, default: 0 
            Rotation in degrees anti-clockwise about the rotation point. 
        rotation_point : {'xy', 'center', (number, number)}, default: 'xy' 
            If ``'xy'``, rotate around the anchor point. If ``'center'`` rotate 
            around the center. If 2-tuple of number, rotate around this 
            coordinate. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Patch` properties 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._x0 = xy[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._y0 = xy[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self._height = height</span>
        <span class="s1">self.angle = float(angle)</span>
        <span class="s1">self.rotation_point = rotation_point</span>
        <span class="s5"># Required for RectangleSelector with axes aspect ratio != 1</span>
        <span class="s5"># The patch is defined in data coordinates and when changing the</span>
        <span class="s5"># selector with square modifier and not in data coordinates, we need</span>
        <span class="s5"># to correct for the aspect ratio difference between the data and</span>
        <span class="s5"># display coordinate systems. Its value is typically provide by</span>
        <span class="s5"># Axes._get_aspect_ratio()</span>
        <span class="s1">self._aspect_ratio_correction = </span><span class="s4">1.0</span>
        <span class="s1">self._convert_units()  </span><span class="s5"># Validate the inputs.</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the vertices of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">Path.unit_rectangle()</span>

    <span class="s2">def </span><span class="s1">_convert_units(self):</span>
        <span class="s0">&quot;&quot;&quot;Convert bounds of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">x0 = self.convert_xunits(self._x0)</span>
        <span class="s1">y0 = self.convert_yunits(self._y0)</span>
        <span class="s1">x1 = self.convert_xunits(self._x0 + self._width)</span>
        <span class="s1">y1 = self.convert_yunits(self._y0 + self._height)</span>
        <span class="s2">return </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s5"># Note: This cannot be called until after this has been added to</span>
        <span class="s5"># an Axes, otherwise unit conversion will fail. This makes it very</span>
        <span class="s5"># important to call the accessor method and not directly access the</span>
        <span class="s5"># transformation member variable.</span>
        <span class="s1">bbox = self.get_bbox()</span>
        <span class="s2">if </span><span class="s1">self.rotation_point == </span><span class="s3">'center'</span><span class="s1">:</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = bbox.x1 - bbox.x0</span><span class="s2">, </span><span class="s1">bbox.y1 - bbox.y0</span>
            <span class="s1">rotation_point = bbox.x0 + width / </span><span class="s4">2.</span><span class="s2">, </span><span class="s1">bbox.y0 + height / </span><span class="s4">2.</span>
        <span class="s2">elif </span><span class="s1">self.rotation_point == </span><span class="s3">'xy'</span><span class="s1">:</span>
            <span class="s1">rotation_point = bbox.x0</span><span class="s2">, </span><span class="s1">bbox.y0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rotation_point = self.rotation_point</span>
        <span class="s2">return </span><span class="s1">transforms.BboxTransformTo(bbox) \</span>
                <span class="s1">+ transforms.Affine2D() \</span>
                <span class="s1">.translate(-rotation_point[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-rotation_point[</span><span class="s4">1</span><span class="s1">]) \</span>
                <span class="s1">.scale(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">self._aspect_ratio_correction) \</span>
                <span class="s1">.rotate_deg(self.angle) \</span>
                <span class="s1">.scale(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ self._aspect_ratio_correction) \</span>
                <span class="s1">.translate(*rotation_point)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">rotation_point(self):</span>
        <span class="s0">&quot;&quot;&quot;The rotation point of the patch.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._rotation_point</span>

    <span class="s1">@rotation_point.setter</span>
    <span class="s2">def </span><span class="s1">rotation_point(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">value </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'center'</span><span class="s2">, </span><span class="s3">'xy'</span><span class="s1">] </span><span class="s2">or </span><span class="s1">(</span>
                <span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">len(value) == </span><span class="s4">2 </span><span class="s2">and</span>
                <span class="s1">isinstance(value[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Number) </span><span class="s2">and </span><span class="s1">isinstance(value[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Number)</span>
                <span class="s1">):</span>
            <span class="s1">self._rotation_point = value</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;`rotation_point` must be one of &quot;</span>
                             <span class="s3">&quot;{'xy', 'center', (number, number)}.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_x(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the left coordinate of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._x0</span>

    <span class="s2">def </span><span class="s1">get_y(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the bottom coordinate of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._y0</span>

    <span class="s2">def </span><span class="s1">get_xy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the left and bottom coords of the rectangle as a tuple.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._x0</span><span class="s2">, </span><span class="s1">self._y0</span>

    <span class="s2">def </span><span class="s1">get_corners(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the corners of the rectangle, moving anti-clockwise from 
        (x0, y0). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_patch_transform().transform(</span>
            <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)])</span>

    <span class="s2">def </span><span class="s1">get_center(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the centre of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_patch_transform().transform((</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">get_width(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the width of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._width</span>

    <span class="s2">def </span><span class="s1">get_height(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the height of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._height</span>

    <span class="s2">def </span><span class="s1">get_angle(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the rotation angle in degrees.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.angle</span>

    <span class="s2">def </span><span class="s1">set_x(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot;Set the left coordinate of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">self._x0 = x</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_y(self</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot;Set the bottom coordinate of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">self._y0 = y</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_angle(self</span><span class="s2">, </span><span class="s1">angle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the rotation angle in degrees. 
 
        The rotation is performed anti-clockwise around *xy*. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.angle = angle</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_xy(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the left and bottom coordinates of the rectangle. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
        &quot;&quot;&quot;</span>
        <span class="s1">self._x0</span><span class="s2">, </span><span class="s1">self._y0 = xy</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">w):</span>
        <span class="s0">&quot;&quot;&quot;Set the width of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">self._width = w</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_height(self</span><span class="s2">, </span><span class="s1">h):</span>
        <span class="s0">&quot;&quot;&quot;Set the height of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">self._height = h</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_bounds(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the bounds of the rectangle as *left*, *bottom*, *width*, *height*. 
 
        The values may be passed as separate parameters or as a tuple:: 
 
            set_bounds(left, bottom, width, height) 
            set_bounds((left, bottom, width, height)) 
 
        .. ACCEPTS: (left, bottom, width, height) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h = args[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h = args</span>
        <span class="s1">self._x0 = l</span>
        <span class="s1">self._y0 = b</span>
        <span class="s1">self._width = w</span>
        <span class="s1">self._height = h</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_bbox(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.Bbox`.&quot;&quot;&quot;</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = self._convert_units()</span>
        <span class="s2">return </span><span class="s1">transforms.Bbox.from_extents(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1)</span>

    <span class="s1">xy = property(get_xy</span><span class="s2">, </span><span class="s1">set_xy)</span>


<span class="s2">class </span><span class="s1">RegularPolygon(Patch):</span>
    <span class="s0">&quot;&quot;&quot;A regular polygon patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">s = </span><span class="s3">&quot;RegularPolygon((%g, %g), %d, radius=%g, orientation=%g)&quot;</span>
        <span class="s2">return </span><span class="s1">s % (self.xy[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.numvertices</span><span class="s2">, </span><span class="s1">self.radius</span><span class="s2">,</span>
                    <span class="s1">self.orientation)</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;radius&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">numVertices</span><span class="s2">, </span><span class="s1">radius=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">orientation=</span><span class="s4">0</span><span class="s2">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : (float, float) 
            The center position. 
 
        numVertices : int 
            The number of vertices. 
 
        radius : float 
            The distance from the center to each of the vertices. 
 
        orientation : float 
            The polygon rotation angle (in radians). 
 
        **kwargs 
            `Patch` properties: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self.xy = xy</span>
        <span class="s1">self.numvertices = numVertices</span>
        <span class="s1">self.orientation = orientation</span>
        <span class="s1">self.radius = radius</span>
        <span class="s1">self._path = Path.unit_regular_polygon(numVertices)</span>
        <span class="s1">self._patch_transform = transforms.Affine2D()</span>
        <span class="s1">super().__init__(**kwargs)</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s2">return </span><span class="s1">self._patch_transform.clear() \</span>
            <span class="s1">.scale(self.radius) \</span>
            <span class="s1">.rotate(self.orientation) \</span>
            <span class="s1">.translate(*self.xy)</span>


<span class="s2">class </span><span class="s1">PathPatch(Patch):</span>
    <span class="s0">&quot;&quot;&quot;A general polycurve path patch.&quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">s = </span><span class="s3">&quot;PathPatch%d((%g, %g) ...)&quot;</span>
        <span class="s2">return </span><span class="s1">s % (len(self._path.vertices)</span><span class="s2">, </span><span class="s1">*tuple(self._path.vertices[</span><span class="s4">0</span><span class="s1">]))</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        *path* is a `.Path` object. 
 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._path = path</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">set_path(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">self._path = path</span>


<span class="s2">class </span><span class="s1">StepPatch(PathPatch):</span>
    <span class="s0">&quot;&quot;&quot; 
    A path patch describing a stepwise constant function. 
 
    By default, the path is not closed and starts and stops at 
    baseline value. 
    &quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">False</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">edges</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">orientation=</span><span class="s3">'vertical'</span><span class="s2">, </span><span class="s1">baseline=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        values : array-like 
            The step heights. 
 
        edges : array-like 
            The edge positions, with ``len(edges) == len(vals) + 1``, 
            between which the curve takes on vals values. 
 
        orientation : {'vertical', 'horizontal'}, default: 'vertical' 
            The direction of the steps. Vertical means that *values* are 
            along the y-axis, and edges are along the x-axis. 
 
        baseline : float, array-like or None, default: 0 
            The bottom value of the bounding edges or when 
            ``fill=True``, position of lower edge. If *fill* is 
            True or an array is passed to *baseline*, a closed 
            path is drawn. 
 
        Other valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self.orientation = orientation</span>
        <span class="s1">self._edges = np.asarray(edges)</span>
        <span class="s1">self._values = np.asarray(values)</span>
        <span class="s1">self._baseline = np.asarray(baseline) </span><span class="s2">if </span><span class="s1">baseline </span><span class="s2">is not None else None</span>
        <span class="s1">self._update_path()</span>
        <span class="s1">super().__init__(self._path</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_update_path(self):</span>
        <span class="s2">if </span><span class="s1">np.isnan(np.sum(self._edges)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Nan values in &quot;edges&quot; are disallowed'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._edges.size - </span><span class="s4">1 </span><span class="s1">!= self._values.size:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Size mismatch between &quot;values&quot; and &quot;edges&quot;. '</span>
                             <span class="s3">&quot;Expected `len(values) + 1 == len(edges)`, but &quot;</span>
                             <span class="s3">f&quot;`len(values) = </span><span class="s2">{</span><span class="s1">self._values.size</span><span class="s2">}</span><span class="s3">` and &quot;</span>
                             <span class="s3">f&quot;`len(edges) = </span><span class="s2">{</span><span class="s1">self._edges.size</span><span class="s2">}</span><span class="s3">`.&quot;</span><span class="s1">)</span>
        <span class="s5"># Initializing with empty arrays allows supporting empty stairs.</span>
        <span class="s1">verts</span><span class="s2">, </span><span class="s1">codes = [np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))]</span><span class="s2">, </span><span class="s1">[np.empty(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=Path.code_type)]</span>

        <span class="s1">_nan_mask = np.isnan(self._values)</span>
        <span class="s2">if </span><span class="s1">self._baseline </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">_nan_mask |= np.isnan(self._baseline)</span>
        <span class="s2">for </span><span class="s1">idx0</span><span class="s2">, </span><span class="s1">idx1 </span><span class="s2">in </span><span class="s1">cbook.contiguous_regions(~_nan_mask):</span>
            <span class="s1">x = np.repeat(self._edges[idx0:idx1+</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">y = np.repeat(self._values[idx0:idx1]</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self._baseline </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">y = np.concatenate([y[:</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">y[-</span><span class="s4">1</span><span class="s1">:]])</span>
            <span class="s2">elif </span><span class="s1">self._baseline.ndim == </span><span class="s4">0</span><span class="s1">:  </span><span class="s5"># single baseline value</span>
                <span class="s1">y = np.concatenate([[self._baseline]</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">[self._baseline]])</span>
            <span class="s2">elif </span><span class="s1">self._baseline.ndim == </span><span class="s4">1</span><span class="s1">:  </span><span class="s5"># baseline array</span>
                <span class="s1">base = np.repeat(self._baseline[idx0:idx1]</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)[::-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">x = np.concatenate([x</span><span class="s2">, </span><span class="s1">x[::-</span><span class="s4">1</span><span class="s1">]])</span>
                <span class="s1">y = np.concatenate([base[-</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">base[:</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                    <span class="s1">base[:</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">base[-</span><span class="s4">1</span><span class="s1">:]])</span>
            <span class="s2">else</span><span class="s1">:  </span><span class="s5"># no baseline</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'Invalid `baseline` specified'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.orientation == </span><span class="s3">'vertical'</span><span class="s1">:</span>
                <span class="s1">xy = np.column_stack([x</span><span class="s2">, </span><span class="s1">y])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">xy = np.column_stack([y</span><span class="s2">, </span><span class="s1">x])</span>
            <span class="s1">verts.append(xy)</span>
            <span class="s1">codes.append([Path.MOVETO] + [Path.LINETO]*(len(xy)-</span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">self._path = Path(np.concatenate(verts)</span><span class="s2">, </span><span class="s1">np.concatenate(codes))</span>

    <span class="s2">def </span><span class="s1">get_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Get `.StepPatch` values, edges and baseline as namedtuple.&quot;&quot;&quot;</span>
        <span class="s1">StairData = namedtuple(</span><span class="s3">'StairData'</span><span class="s2">, </span><span class="s3">'values edges baseline'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">StairData(self._values</span><span class="s2">, </span><span class="s1">self._edges</span><span class="s2">, </span><span class="s1">self._baseline)</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">values=</span><span class="s2">None, </span><span class="s1">edges=</span><span class="s2">None, </span><span class="s1">baseline=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set `.StepPatch` values, edges and baseline. 
 
        Parameters 
        ---------- 
        values : 1D array-like or None 
            Will not update values, if passing None 
        edges : 1D array-like, optional 
        baseline : float, 1D array-like or None 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">values </span><span class="s2">is None and </span><span class="s1">edges </span><span class="s2">is None and </span><span class="s1">baseline </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Must set *values*, *edges* or *baseline*.&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">values </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._values = np.asarray(values)</span>
        <span class="s2">if </span><span class="s1">edges </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._edges = np.asarray(edges)</span>
        <span class="s2">if </span><span class="s1">baseline </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._baseline = np.asarray(baseline)</span>
        <span class="s1">self._update_path()</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>


<span class="s2">class </span><span class="s1">Polygon(Patch):</span>
    <span class="s0">&quot;&quot;&quot;A general polygon patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">len(self._path.vertices):</span>
            <span class="s1">s = </span><span class="s3">&quot;Polygon%d((%g, %g) ...)&quot;</span>
            <span class="s2">return </span><span class="s1">s % (len(self._path.vertices)</span><span class="s2">, </span><span class="s1">*self._path.vertices[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">&quot;Polygon0()&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;closed&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        *xy* is a numpy array with shape Nx2. 
 
        If *closed* is *True*, the polygon will be closed so the 
        starting and ending points are the same. 
 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._closed = closed</span>
        <span class="s1">self.set_xy(xy)</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the `.Path` of the polygon.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">get_closed(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the polygon is closed.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._closed</span>

    <span class="s2">def </span><span class="s1">set_closed(self</span><span class="s2">, </span><span class="s1">closed):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the polygon is closed. 
 
        Parameters 
        ---------- 
        closed : bool 
           True if the polygon is closed 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._closed == bool(closed):</span>
            <span class="s2">return</span>
        <span class="s1">self._closed = bool(closed)</span>
        <span class="s1">self.set_xy(self.get_xy())</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_xy(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the vertices of the path. 
 
        Returns 
        ------- 
        (N, 2) numpy array 
            The coordinates of the vertices. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._path.vertices</span>

    <span class="s2">def </span><span class="s1">set_xy(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the vertices of the polygon. 
 
        Parameters 
        ---------- 
        xy : (N, 2) array-like 
            The coordinates of the vertices. 
 
        Notes 
        ----- 
        Unlike `.Path`, we do not ignore the last input vertex. If the 
        polygon is meant to be closed, and the last point of the polygon is not 
        equal to the first, we assume that the user has not explicitly passed a 
        ``CLOSEPOLY`` vertex, and add it ourselves. 
        &quot;&quot;&quot;</span>
        <span class="s1">xy = np.asarray(xy)</span>
        <span class="s1">nverts</span><span class="s2">, </span><span class="s1">_ = xy.shape</span>
        <span class="s2">if </span><span class="s1">self._closed:</span>
            <span class="s5"># if the first and last vertex are the &quot;same&quot;, then we assume that</span>
            <span class="s5"># the user explicitly passed the CLOSEPOLY vertex. Otherwise, we</span>
            <span class="s5"># have to append one since the last vertex will be &quot;ignored&quot; by</span>
            <span class="s5"># Path</span>
            <span class="s2">if </span><span class="s1">nverts == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">nverts &gt; </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">(xy[</span><span class="s4">0</span><span class="s1">] != xy[-</span><span class="s4">1</span><span class="s1">]).any():</span>
                <span class="s1">xy = np.concatenate([xy</span><span class="s2">, </span><span class="s1">[xy[</span><span class="s4">0</span><span class="s1">]]])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># if we aren't closed, and the last vertex matches the first, then</span>
            <span class="s5"># we assume we have an unnecessary CLOSEPOLY vertex and remove it</span>
            <span class="s2">if </span><span class="s1">nverts &gt; </span><span class="s4">2 </span><span class="s2">and </span><span class="s1">(xy[</span><span class="s4">0</span><span class="s1">] == xy[-</span><span class="s4">1</span><span class="s1">]).all():</span>
                <span class="s1">xy = xy[:-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self._path = Path(xy</span><span class="s2">, </span><span class="s1">closed=self._closed)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">xy = property(get_xy</span><span class="s2">, </span><span class="s1">set_xy</span><span class="s2">,</span>
                  <span class="s1">doc=</span><span class="s3">'The vertices of the path as (N, 2) numpy array.'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Wedge(Patch):</span>
    <span class="s0">&quot;&quot;&quot;Wedge shaped patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">pars = (self.center[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.center[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.r</span><span class="s2">,</span>
                <span class="s1">self.theta1</span><span class="s2">, </span><span class="s1">self.theta2</span><span class="s2">, </span><span class="s1">self.width)</span>
        <span class="s1">fmt = </span><span class="s3">&quot;Wedge(center=(%g, %g), r=%g, theta1=%g, theta2=%g, width=%s)&quot;</span>
        <span class="s2">return </span><span class="s1">fmt % pars</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;width&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">center</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">theta1</span><span class="s2">, </span><span class="s1">theta2</span><span class="s2">, </span><span class="s1">width=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        A wedge centered at *x*, *y* center with radius *r* that 
        sweeps *theta1* to *theta2* (in degrees).  If *width* is given, 
        then a partial wedge is drawn from inner radius *r* - *width* 
        to outer radius *r*. 
 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self.center = center</span>
        <span class="s1">self.r</span><span class="s2">, </span><span class="s1">self.width = r</span><span class="s2">, </span><span class="s1">width</span>
        <span class="s1">self.theta1</span><span class="s2">, </span><span class="s1">self.theta2 = theta1</span><span class="s2">, </span><span class="s1">theta2</span>
        <span class="s1">self._patch_transform = transforms.IdentityTransform()</span>
        <span class="s1">self._recompute_path()</span>

    <span class="s2">def </span><span class="s1">_recompute_path(self):</span>
        <span class="s5"># Inner and outer rings are connected unless the annulus is complete</span>
        <span class="s2">if </span><span class="s1">abs((self.theta2 - self.theta1) - </span><span class="s4">360</span><span class="s1">) &lt;= </span><span class="s4">1e-12</span><span class="s1">:</span>
            <span class="s1">theta1</span><span class="s2">, </span><span class="s1">theta2 = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">360</span>
            <span class="s1">connector = Path.MOVETO</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">theta1</span><span class="s2">, </span><span class="s1">theta2 = self.theta1</span><span class="s2">, </span><span class="s1">self.theta2</span>
            <span class="s1">connector = Path.LINETO</span>

        <span class="s5"># Form the outer ring</span>
        <span class="s1">arc = Path.arc(theta1</span><span class="s2">, </span><span class="s1">theta2)</span>

        <span class="s2">if </span><span class="s1">self.width </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s5"># Partial annulus needs to draw the outer ring</span>
            <span class="s5"># followed by a reversed and scaled inner ring</span>
            <span class="s1">v1 = arc.vertices</span>
            <span class="s1">v2 = arc.vertices[::-</span><span class="s4">1</span><span class="s1">] * (self.r - self.width) / self.r</span>
            <span class="s1">v = np.concatenate([v1</span><span class="s2">, </span><span class="s1">v2</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]])</span>
            <span class="s1">c = [*arc.codes</span><span class="s2">, </span><span class="s1">connector</span><span class="s2">, </span><span class="s1">*arc.codes[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">Path.CLOSEPOLY]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Wedge doesn't need an inner ring</span>
            <span class="s1">v = np.concatenate([arc.vertices</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]])</span>
            <span class="s1">c = [*arc.codes</span><span class="s2">, </span><span class="s1">connector</span><span class="s2">, </span><span class="s1">Path.CLOSEPOLY]</span>

        <span class="s5"># Shift and scale the wedge to the final location.</span>
        <span class="s1">self._path = Path(v * self.r + self.center</span><span class="s2">, </span><span class="s1">c)</span>

    <span class="s2">def </span><span class="s1">set_center(self</span><span class="s2">, </span><span class="s1">center):</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.center = center</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_radius(self</span><span class="s2">, </span><span class="s1">radius):</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.r = radius</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_theta1(self</span><span class="s2">, </span><span class="s1">theta1):</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.theta1 = theta1</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_theta2(self</span><span class="s2">, </span><span class="s1">theta2):</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.theta2 = theta2</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">if </span><span class="s1">self._path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._recompute_path()</span>
        <span class="s2">return </span><span class="s1">self._path</span>


<span class="s5"># COVERAGE NOTE: Not used internally or from examples</span>
<span class="s2">class </span><span class="s1">Arrow(Patch):</span>
    <span class="s0">&quot;&quot;&quot;An arrow patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;Arrow()&quot;</span>

    <span class="s1">_path = Path._create_closed([</span>
        <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]])</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;width&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">width=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draws an arrow from (*x*, *y*) to (*x* + *dx*, *y* + *dy*). 
        The width of the arrow is scaled by *width*. 
 
        Parameters 
        ---------- 
        x : float 
            x coordinate of the arrow tail. 
        y : float 
            y coordinate of the arrow tail. 
        dx : float 
            Arrow length in the x direction. 
        dy : float 
            Arrow length in the y direction. 
        width : float, default: 1 
            Scale factor for the width of the arrow. With a default value of 1, 
            the tail width is 0.2 and head width is 0.6. 
        **kwargs 
            Keyword arguments control the `Patch` properties: 
 
            %(Patch:kwdoc)s 
 
        See Also 
        -------- 
        FancyArrow 
            Patch that allows independent control of the head and tail 
            properties. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._patch_transform = (</span>
            <span class="s1">transforms.Affine2D()</span>
            <span class="s1">.scale(np.hypot(dx</span><span class="s2">, </span><span class="s1">dy)</span><span class="s2">, </span><span class="s1">width)</span>
            <span class="s1">.rotate(np.arctan2(dy</span><span class="s2">, </span><span class="s1">dx))</span>
            <span class="s1">.translate(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">.frozen())</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s2">return </span><span class="s1">self._patch_transform</span>


<span class="s2">class </span><span class="s1">FancyArrow(Polygon):</span>
    <span class="s0">&quot;&quot;&quot; 
    Like Arrow, but lets you set head width and head height independently. 
    &quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;FancyArrow()&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;width&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, </span><span class="s1">dy</span><span class="s2">, </span><span class="s1">width=</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">length_includes_head=</span><span class="s2">False,</span>
                 <span class="s1">head_width=</span><span class="s2">None, </span><span class="s1">head_length=</span><span class="s2">None, </span><span class="s1">shape=</span><span class="s3">'full'</span><span class="s2">, </span><span class="s1">overhang=</span><span class="s4">0</span><span class="s2">,</span>
                 <span class="s1">head_starts_at_zero=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        x, y : float 
            The x and y coordinates of the arrow base. 
 
        dx, dy : float 
            The length of the arrow along x and y direction. 
 
        width : float, default: 0.001 
            Width of full arrow tail. 
 
        length_includes_head : bool, default: False 
            True if head is to be counted in calculating the length. 
 
        head_width : float or None, default: 3*width 
            Total width of the full arrow head. 
 
        head_length : float or None, default: 1.5*head_width 
            Length of arrow head. 
 
        shape : {'full', 'left', 'right'}, default: 'full' 
            Draw the left-half, right-half, or full arrow. 
 
        overhang : float, default: 0 
            Fraction that the arrow is swept back (0 overhang means 
            triangular shape). Can be negative or greater than one. 
 
        head_starts_at_zero : bool, default: False 
            If True, the head starts being drawn at coordinate 0 
            instead of ending at coordinate 0. 
 
        **kwargs 
            `.Patch` properties: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">self._x = x</span>
        <span class="s1">self._y = y</span>
        <span class="s1">self._dx = dx</span>
        <span class="s1">self._dy = dy</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self._length_includes_head = length_includes_head</span>
        <span class="s1">self._head_width = head_width</span>
        <span class="s1">self._head_length = head_length</span>
        <span class="s1">self._shape = shape</span>
        <span class="s1">self._overhang = overhang</span>
        <span class="s1">self._head_starts_at_zero = head_starts_at_zero</span>
        <span class="s1">self._make_verts()</span>
        <span class="s1">super().__init__(self.verts</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">set_data(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">dx=</span><span class="s2">None, </span><span class="s1">dy=</span><span class="s2">None, </span><span class="s1">width=</span><span class="s2">None,</span>
                 <span class="s1">head_width=</span><span class="s2">None, </span><span class="s1">head_length=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set `.FancyArrow` x, y, dx, dy, width, head_with, and head_length. 
        Values left as None will not be updated. 
 
        Parameters 
        ---------- 
        x, y : float or None, default: None 
            The x and y coordinates of the arrow base. 
 
        dx, dy : float or None, default: None 
            The length of the arrow along x and y direction. 
 
        width : float or None, default: None 
            Width of full arrow tail. 
 
        head_width : float or None, default: None 
            Total width of the full arrow head. 
 
        head_length : float or None, default: None 
            Length of arrow head. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._x = x</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._y = y</span>
        <span class="s2">if </span><span class="s1">dx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._dx = dx</span>
        <span class="s2">if </span><span class="s1">dy </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._dy = dy</span>
        <span class="s2">if </span><span class="s1">width </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._width = width</span>
        <span class="s2">if </span><span class="s1">head_width </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._head_width = head_width</span>
        <span class="s2">if </span><span class="s1">head_length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._head_length = head_length</span>
        <span class="s1">self._make_verts()</span>
        <span class="s1">self.set_xy(self.verts)</span>

    <span class="s2">def </span><span class="s1">_make_verts(self):</span>
        <span class="s2">if </span><span class="s1">self._head_width </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">head_width = </span><span class="s4">3 </span><span class="s1">* self._width</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">head_width = self._head_width</span>
        <span class="s2">if </span><span class="s1">self._head_length </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">head_length = </span><span class="s4">1.5 </span><span class="s1">* head_width</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">head_length = self._head_length</span>

        <span class="s1">distance = np.hypot(self._dx</span><span class="s2">, </span><span class="s1">self._dy)</span>

        <span class="s2">if </span><span class="s1">self._length_includes_head:</span>
            <span class="s1">length = distance</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">length = distance + head_length</span>
        <span class="s2">if not </span><span class="s1">length:</span>
            <span class="s1">self.verts = np.empty([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])  </span><span class="s5"># display nothing if empty</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># start by drawing horizontal arrow, point at (0, 0)</span>
            <span class="s1">hw</span><span class="s2">, </span><span class="s1">hl = head_width</span><span class="s2">, </span><span class="s1">head_length</span>
            <span class="s1">hs</span><span class="s2">, </span><span class="s1">lw = self._overhang</span><span class="s2">, </span><span class="s1">self._width</span>
            <span class="s1">left_half_arrow = np.array([</span>
                <span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,                 </span><span class="s5"># tip</span>
                <span class="s1">[-hl</span><span class="s2">, </span><span class="s1">-hw / </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,             </span><span class="s5"># leftmost</span>
                <span class="s1">[-hl * (</span><span class="s4">1 </span><span class="s1">- hs)</span><span class="s2">, </span><span class="s1">-lw / </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># meets stem</span>
                <span class="s1">[-length</span><span class="s2">, </span><span class="s1">-lw / </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,         </span><span class="s5"># bottom left</span>
                <span class="s1">[-length</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">])</span>
            <span class="s5"># if we're not including the head, shift up by head length</span>
            <span class="s2">if not </span><span class="s1">self._length_includes_head:</span>
                <span class="s1">left_half_arrow += [head_length</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s5"># if the head starts at 0, shift up by another head length</span>
            <span class="s2">if </span><span class="s1">self._head_starts_at_zero:</span>
                <span class="s1">left_half_arrow += [head_length / </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s5"># figure out the shape, and complete accordingly</span>
            <span class="s2">if </span><span class="s1">self._shape == </span><span class="s3">'left'</span><span class="s1">:</span>
                <span class="s1">coords = left_half_arrow</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">right_half_arrow = left_half_arrow * [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">self._shape == </span><span class="s3">'right'</span><span class="s1">:</span>
                    <span class="s1">coords = right_half_arrow</span>
                <span class="s2">elif </span><span class="s1">self._shape == </span><span class="s3">'full'</span><span class="s1">:</span>
                    <span class="s5"># The half-arrows contain the midpoint of the stem,</span>
                    <span class="s5"># which we can omit from the full arrow. Including it</span>
                    <span class="s5"># twice caused a problem with xpdf.</span>
                    <span class="s1">coords = np.concatenate([left_half_arrow[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                             <span class="s1">right_half_arrow[-</span><span class="s4">2</span><span class="s1">::-</span><span class="s4">1</span><span class="s1">]])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Got unknown shape: </span><span class="s2">{</span><span class="s1">self._shape</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">distance != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">cx = self._dx / distance</span>
                <span class="s1">sx = self._dy / distance</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># Account for division by zero</span>
                <span class="s1">cx</span><span class="s2">, </span><span class="s1">sx = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span>
            <span class="s1">M = [[cx</span><span class="s2">, </span><span class="s1">sx]</span><span class="s2">, </span><span class="s1">[-sx</span><span class="s2">, </span><span class="s1">cx]]</span>
            <span class="s1">self.verts = np.dot(coords</span><span class="s2">, </span><span class="s1">M) + [</span>
                <span class="s1">self._x + self._dx</span><span class="s2">,</span>
                <span class="s1">self._y + self._dy</span><span class="s2">,</span>
            <span class="s1">]</span>


<span class="s1">_docstring.interpd.update(</span>
    <span class="s1">FancyArrow=</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.join(</span>
        <span class="s1">(inspect.getdoc(FancyArrow.__init__) </span><span class="s2">or </span><span class="s3">&quot;&quot;</span><span class="s1">).splitlines()[</span><span class="s4">2</span><span class="s1">:]))</span>


<span class="s2">class </span><span class="s1">CirclePolygon(RegularPolygon):</span>
    <span class="s0">&quot;&quot;&quot;A polygon-approximation of a circle patch.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">s = </span><span class="s3">&quot;CirclePolygon((%g, %g), radius=%g, resolution=%d)&quot;</span>
        <span class="s2">return </span><span class="s1">s % (self.xy[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.radius</span><span class="s2">, </span><span class="s1">self.numvertices)</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;resolution&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">radius=</span><span class="s4">5</span><span class="s2">,</span>
                 <span class="s1">resolution=</span><span class="s4">20</span><span class="s2">,  </span><span class="s5"># the number of vertices</span>
                 <span class="s1">** kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a circle at *xy* = (*x*, *y*) with given *radius*. 
 
        This circle is approximated by a regular polygon with *resolution* 
        sides.  For a smoother circle drawn with splines, see `Circle`. 
 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">xy</span><span class="s2">, </span><span class="s1">resolution</span><span class="s2">, </span><span class="s1">radius=radius</span><span class="s2">, </span><span class="s1">orientation=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">Ellipse(Patch):</span>
    <span class="s0">&quot;&quot;&quot;A scale-free ellipse.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">pars = (self._center[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._center[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.height</span><span class="s2">, </span><span class="s1">self.angle)</span>
        <span class="s1">fmt = </span><span class="s3">&quot;Ellipse(xy=(%s, %s), width=%s, height=%s, angle=%s)&quot;</span>
        <span class="s2">return </span><span class="s1">fmt % pars</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;angle&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : (float, float) 
            xy coordinates of ellipse centre. 
        width : float 
            Total length (diameter) of horizontal axis. 
        height : float 
            Total length (diameter) of vertical axis. 
        angle : float, default: 0 
            Rotation in degrees anti-clockwise. 
 
        Notes 
        ----- 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s1">self._center = xy</span>
        <span class="s1">self._width</span><span class="s2">, </span><span class="s1">self._height = width</span><span class="s2">, </span><span class="s1">height</span>
        <span class="s1">self._angle = angle</span>
        <span class="s1">self._path = Path.unit_circle()</span>
        <span class="s5"># Required for EllipseSelector with axes aspect ratio != 1</span>
        <span class="s5"># The patch is defined in data coordinates and when changing the</span>
        <span class="s5"># selector with square modifier and not in data coordinates, we need</span>
        <span class="s5"># to correct for the aspect ratio difference between the data and</span>
        <span class="s5"># display coordinate systems.</span>
        <span class="s1">self._aspect_ratio_correction = </span><span class="s4">1.0</span>
        <span class="s5"># Note: This cannot be calculated until this is added to an Axes</span>
        <span class="s1">self._patch_transform = transforms.IdentityTransform()</span>

    <span class="s2">def </span><span class="s1">_recompute_transform(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Notes 
        ----- 
        This cannot be called until after this has been added to an Axes, 
        otherwise unit conversion will fail. This makes it very important to 
        call the accessor method and not directly access the transformation 
        member variable. 
        &quot;&quot;&quot;</span>
        <span class="s1">center = (self.convert_xunits(self._center[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                  <span class="s1">self.convert_yunits(self._center[</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">width = self.convert_xunits(self._width)</span>
        <span class="s1">height = self.convert_yunits(self._height)</span>
        <span class="s1">self._patch_transform = transforms.Affine2D() \</span>
            <span class="s1">.scale(width * </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">height * </span><span class="s4">0.5 </span><span class="s1">* self._aspect_ratio_correction) \</span>
            <span class="s1">.rotate_deg(self.angle) \</span>
            <span class="s1">.scale(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">/ self._aspect_ratio_correction) \</span>
            <span class="s1">.translate(*center)</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the path of the ellipse.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._path</span>

    <span class="s2">def </span><span class="s1">get_patch_transform(self):</span>
        <span class="s1">self._recompute_transform()</span>
        <span class="s2">return </span><span class="s1">self._patch_transform</span>

    <span class="s2">def </span><span class="s1">set_center(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the center of the ellipse. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
        &quot;&quot;&quot;</span>
        <span class="s1">self._center = xy</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_center(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the center of the ellipse.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._center</span>

    <span class="s1">center = property(get_center</span><span class="s2">, </span><span class="s1">set_center)</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the width of the ellipse. 
 
        Parameters 
        ---------- 
        width : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_width(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the width of the ellipse. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._width</span>

    <span class="s1">width = property(get_width</span><span class="s2">, </span><span class="s1">set_width)</span>

    <span class="s2">def </span><span class="s1">set_height(self</span><span class="s2">, </span><span class="s1">height):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the height of the ellipse. 
 
        Parameters 
        ---------- 
        height : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._height = height</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_height(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the height of the ellipse.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._height</span>

    <span class="s1">height = property(get_height</span><span class="s2">, </span><span class="s1">set_height)</span>

    <span class="s2">def </span><span class="s1">set_angle(self</span><span class="s2">, </span><span class="s1">angle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the angle of the ellipse. 
 
        Parameters 
        ---------- 
        angle : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._angle = angle</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_angle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the angle of the ellipse.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._angle</span>

    <span class="s1">angle = property(get_angle</span><span class="s2">, </span><span class="s1">set_angle)</span>

    <span class="s2">def </span><span class="s1">get_corners(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the corners of the ellipse bounding box. 
 
        The bounding box orientation is moving anti-clockwise from the 
        lower left corner defined before rotation. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_patch_transform().transform(</span>
            <span class="s1">[(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)])</span>


<span class="s2">class </span><span class="s1">Annulus(Patch):</span>
    <span class="s0">&quot;&quot;&quot; 
    An elliptical annulus. 
    &quot;&quot;&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : (float, float) 
            xy coordinates of annulus centre. 
        r : float or (float, float) 
            The radius, or semi-axes: 
 
            - If float: radius of the outer circle. 
            - If two floats: semi-major and -minor axes of outer ellipse. 
        width : float 
            Width (thickness) of the annular ring. The width is measured inward 
            from the outer ellipse so that for the inner ellipse the semi-axes 
            are given by ``r - width``. *width* must be less than or equal to 
            the semi-minor axis. 
        angle : float, default: 0 
            Rotation angle in degrees (anti-clockwise from the positive 
            x-axis). Ignored for circular annuli (i.e., if *r* is a scalar). 
        **kwargs 
            Keyword arguments control the `Patch` properties: 
 
            %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s1">self.set_radii(r)</span>
        <span class="s1">self.center = xy</span>
        <span class="s1">self.width = width</span>
        <span class="s1">self.angle = angle</span>
        <span class="s1">self._path = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self.a == self.b:</span>
            <span class="s1">r = self.a</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">r = (self.a</span><span class="s2">, </span><span class="s1">self.b)</span>

        <span class="s2">return </span><span class="s3">&quot;Annulus(xy=(%s, %s), r=%s, width=%s, angle=%s)&quot; </span><span class="s1">% \</span>
                <span class="s1">(*self.center</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">self.width</span><span class="s2">, </span><span class="s1">self.angle)</span>

    <span class="s2">def </span><span class="s1">set_center(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the center of the annulus. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
        &quot;&quot;&quot;</span>
        <span class="s1">self._center = xy</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_center(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the center of the annulus.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._center</span>

    <span class="s1">center = property(get_center</span><span class="s2">, </span><span class="s1">set_center)</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">width):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the width (thickness) of the annulus ring. 
 
        The width is measured inwards from the outer ellipse. 
 
        Parameters 
        ---------- 
        width : float 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">min(self.a</span><span class="s2">, </span><span class="s1">self.b) &lt;= width:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">'Width of annulus must be less than or equal semi-minor axis'</span><span class="s1">)</span>

        <span class="s1">self._width = width</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_width(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the width (thickness) of the annulus ring.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._width</span>

    <span class="s1">width = property(get_width</span><span class="s2">, </span><span class="s1">set_width)</span>

    <span class="s2">def </span><span class="s1">set_angle(self</span><span class="s2">, </span><span class="s1">angle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the tilt angle of the annulus. 
 
        Parameters 
        ---------- 
        angle : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._angle = angle</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_angle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the angle of the annulus.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._angle</span>

    <span class="s1">angle = property(get_angle</span><span class="s2">, </span><span class="s1">set_angle)</span>

    <span class="s2">def </span><span class="s1">set_semimajor(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the semi-major axis *a* of the annulus. 
 
        Parameters 
        ---------- 
        a : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.a = float(a)</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_semiminor(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the semi-minor axis *b* of the annulus. 
 
        Parameters 
        ---------- 
        b : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.b = float(b)</span>
        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_radii(self</span><span class="s2">, </span><span class="s1">r):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the semi-major (*a*) and semi-minor radii (*b*) of the annulus. 
 
        Parameters 
        ---------- 
        r : float or (float, float) 
            The radius, or semi-axes: 
 
            - If float: radius of the outer circle. 
            - If two floats: semi-major and -minor axes of outer ellipse. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">np.shape(r) == (</span><span class="s4">2</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s1">self.a</span><span class="s2">, </span><span class="s1">self.b = r</span>
        <span class="s2">elif </span><span class="s1">np.shape(r) == ():</span>
            <span class="s1">self.a = self.b = float(r)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Parameter 'r' must be one or two floats.&quot;</span><span class="s1">)</span>

        <span class="s1">self._path = </span><span class="s2">None</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_radii(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the semi-major and semi-minor radii of the annulus.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.a</span><span class="s2">, </span><span class="s1">self.b</span>

    <span class="s1">radii = property(get_radii</span><span class="s2">, </span><span class="s1">set_radii)</span>

    <span class="s2">def </span><span class="s1">_transform_verts(self</span><span class="s2">, </span><span class="s1">verts</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s2">return </span><span class="s1">transforms.Affine2D() \</span>
            <span class="s1">.scale(*self._convert_xy_units((a</span><span class="s2">, </span><span class="s1">b))) \</span>
            <span class="s1">.rotate_deg(self.angle) \</span>
            <span class="s1">.translate(*self._convert_xy_units(self.center)) \</span>
            <span class="s1">.transform(verts)</span>

    <span class="s2">def </span><span class="s1">_recompute_path(self):</span>
        <span class="s5"># circular arc</span>
        <span class="s1">arc = Path.arc(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">360</span><span class="s1">)</span>

        <span class="s5"># annulus needs to draw an outer ring</span>
        <span class="s5"># followed by a reversed and scaled inner ring</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">w = self.a</span><span class="s2">, </span><span class="s1">self.b</span><span class="s2">, </span><span class="s1">self.width</span>
        <span class="s1">v1 = self._transform_verts(arc.vertices</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">v2 = self._transform_verts(arc.vertices[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">a - w</span><span class="s2">, </span><span class="s1">b - w)</span>
        <span class="s1">v = np.vstack([v1</span><span class="s2">, </span><span class="s1">v2</span><span class="s2">, </span><span class="s1">v1[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)])</span>
        <span class="s1">c = np.hstack([arc.codes</span><span class="s2">, </span><span class="s1">Path.MOVETO</span><span class="s2">,</span>
                       <span class="s1">arc.codes[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">Path.MOVETO</span><span class="s2">,</span>
                       <span class="s1">Path.CLOSEPOLY])</span>
        <span class="s1">self._path = Path(v</span><span class="s2">, </span><span class="s1">c)</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s2">if </span><span class="s1">self._path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._recompute_path()</span>
        <span class="s2">return </span><span class="s1">self._path</span>


<span class="s2">class </span><span class="s1">Circle(Ellipse):</span>
    <span class="s0">&quot;&quot;&quot; 
    A circle patch. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">pars = self.center[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.center[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.radius</span>
        <span class="s1">fmt = </span><span class="s3">&quot;Circle(xy=(%g, %g), radius=%g)&quot;</span>
        <span class="s2">return </span><span class="s1">fmt % pars</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">radius=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a true circle at center *xy* = (*x*, *y*) with given *radius*. 
 
        Unlike `CirclePolygon` which is a polygonal approximation, this uses 
        Bezier splines and is much closer to a scale-free circle. 
 
        Valid keyword arguments are: 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(xy</span><span class="s2">, </span><span class="s1">radius * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">radius * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.radius = radius</span>

    <span class="s2">def </span><span class="s1">set_radius(self</span><span class="s2">, </span><span class="s1">radius):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the radius of the circle. 
 
        Parameters 
        ---------- 
        radius : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self.width = self.height = </span><span class="s4">2 </span><span class="s1">* radius</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_radius(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the radius of the circle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.width / </span><span class="s4">2.</span>

    <span class="s1">radius = property(get_radius</span><span class="s2">, </span><span class="s1">set_radius)</span>


<span class="s2">class </span><span class="s1">Arc(Ellipse):</span>
    <span class="s0">&quot;&quot;&quot; 
    An elliptical arc, i.e. a segment of an ellipse. 
 
    Due to internal optimizations, the arc cannot be filled. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">pars = (self.center[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.center[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.width</span><span class="s2">,</span>
                <span class="s1">self.height</span><span class="s2">, </span><span class="s1">self.angle</span><span class="s2">, </span><span class="s1">self.theta1</span><span class="s2">, </span><span class="s1">self.theta2)</span>
        <span class="s1">fmt = (</span><span class="s3">&quot;Arc(xy=(%g, %g), width=%g, &quot;</span>
               <span class="s3">&quot;height=%g, angle=%g, theta1=%g, theta2=%g)&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">fmt % pars</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;angle&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=</span><span class="s4">0.0</span><span class="s2">,</span>
                 <span class="s1">theta1=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">theta2=</span><span class="s4">360.0</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : (float, float) 
            The center of the ellipse. 
 
        width : float 
            The length of the horizontal axis. 
 
        height : float 
            The length of the vertical axis. 
 
        angle : float 
            Rotation of the ellipse in degrees (counterclockwise). 
 
        theta1, theta2 : float, default: 0, 360 
            Starting and ending angles of the arc in degrees. These values 
            are relative to *angle*, e.g. if *angle* = 45 and *theta1* = 90 
            the absolute starting angle is 135. 
            Default *theta1* = 0, *theta2* = 360, i.e. a complete ellipse. 
            The arc is drawn in the counterclockwise direction. 
            Angles greater than or equal to 360, or smaller than 0, are 
            represented by an equivalent angle in the range [0, 360), by 
            taking the input value mod 360. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Patch` properties 
            Most `.Patch` properties are supported as keyword arguments, 
            except *fill* and *facecolor* because filling is not supported. 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">fill = kwargs.setdefault(</span><span class="s3">'fill'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Arc objects can not be filled&quot;</span><span class="s1">)</span>

        <span class="s1">super().__init__(xy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">angle=angle</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.theta1 = theta1</span>
        <span class="s1">self.theta2 = theta2</span>
        <span class="s1">(self._theta1</span><span class="s2">, </span><span class="s1">self._theta2</span><span class="s2">, </span><span class="s1">self._stretched_width</span><span class="s2">,</span>
         <span class="s1">self._stretched_height) = self._theta_stretch()</span>
        <span class="s1">self._path = Path.arc(self._theta1</span><span class="s2">, </span><span class="s1">self._theta2)</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw the arc to the given *renderer*. 
 
        Notes 
        ----- 
        Ellipses are normally drawn using an approximation that uses 
        eight cubic Bezier splines.  The error of this approximation 
        is 1.89818e-6, according to this unverified source: 
 
          Lancaster, Don.  *Approximating a Circle or an Ellipse Using 
          Four Bezier Cubic Splines.* 
 
          https://www.tinaja.com/glib/ellipse4.pdf 
 
        There is a use case where very large ellipses must be drawn 
        with very high accuracy, and it is too expensive to render the 
        entire ellipse with enough segments (either splines or line 
        segments).  Therefore, in the case where either radius of the 
        ellipse is large enough that the error of the spline 
        approximation will be visible (greater than one pixel offset 
        from the ideal), a different technique is used. 
 
        In that case, only the visible parts of the ellipse are drawn, 
        with each visible arc using a fixed number of spline segments 
        (8).  The algorithm proceeds as follows: 
 
        1. The points where the ellipse intersects the axes (or figure) 
           bounding box are located.  (This is done by performing an inverse 
           transformation on the bbox such that it is relative to the unit 
           circle -- this makes the intersection calculation much easier than 
           doing rotated ellipse intersection directly.) 
 
           This uses the &quot;line intersecting a circle&quot; algorithm from: 
 
               Vince, John.  *Geometry for Computer Graphics: Formulae, 
               Examples &amp; Proofs.*  London: Springer-Verlag, 2005. 
 
        2. The angles of each of the intersection points are calculated. 
 
        3. Proceeding counterclockwise starting in the positive 
           x-direction, each of the visible arc-segments between the 
           pairs of vertices are drawn using the Bezier arc 
           approximation technique implemented in `.Path.arc`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s1">self._recompute_transform()</span>

        <span class="s1">self._update_path()</span>
        <span class="s5"># Get width and height in pixels we need to use</span>
        <span class="s5"># `self.get_data_transform` rather than `self.get_transform`</span>
        <span class="s5"># because we want the transform from dataspace to the</span>
        <span class="s5"># screen space to estimate how big the arc will be in physical</span>
        <span class="s5"># units when rendered (the transform that we get via</span>
        <span class="s5"># `self.get_transform()` goes from an idealized unit-radius</span>
        <span class="s5"># space to screen space).</span>
        <span class="s1">data_to_screen_trans = self.get_data_transform()</span>
        <span class="s1">pwidth</span><span class="s2">, </span><span class="s1">pheight = (</span>
            <span class="s1">data_to_screen_trans.transform((self._stretched_width</span><span class="s2">,</span>
                                            <span class="s1">self._stretched_height)) -</span>
            <span class="s1">data_to_screen_trans.transform((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)))</span>
        <span class="s1">inv_error = (</span><span class="s4">1.0 </span><span class="s1">/ </span><span class="s4">1.89818e-6</span><span class="s1">) * </span><span class="s4">0.5</span>

        <span class="s2">if </span><span class="s1">pwidth &lt; inv_error </span><span class="s2">and </span><span class="s1">pheight &lt; inv_error:</span>
            <span class="s2">return </span><span class="s1">Patch.draw(self</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s2">def </span><span class="s1">line_circle_intersect(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1):</span>
            <span class="s1">dx = x1 - x0</span>
            <span class="s1">dy = y1 - y0</span>
            <span class="s1">dr2 = dx * dx + dy * dy</span>
            <span class="s1">D = x0 * y1 - x1 * y0</span>
            <span class="s1">D2 = D * D</span>
            <span class="s1">discrim = dr2 - D2</span>
            <span class="s2">if </span><span class="s1">discrim &gt;= </span><span class="s4">0.0</span><span class="s1">:</span>
                <span class="s1">sign_dy = np.copysign(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dy)  </span><span class="s5"># +/-1, never 0.</span>
                <span class="s1">sqrt_discrim = np.sqrt(discrim)</span>
                <span class="s2">return </span><span class="s1">np.array(</span>
                    <span class="s1">[[(D * dy + sign_dy * dx * sqrt_discrim) / dr2</span><span class="s2">,</span>
                      <span class="s1">(-D * dx + abs(dy) * sqrt_discrim) / dr2]</span><span class="s2">,</span>
                     <span class="s1">[(D * dy - sign_dy * dx * sqrt_discrim) / dr2</span><span class="s2">,</span>
                      <span class="s1">(-D * dx - abs(dy) * sqrt_discrim) / dr2]])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s2">def </span><span class="s1">segment_circle_intersect(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1):</span>
            <span class="s1">epsilon = </span><span class="s4">1e-9</span>
            <span class="s2">if </span><span class="s1">x1 &lt; x0:</span>
                <span class="s1">x0e</span><span class="s2">, </span><span class="s1">x1e = x1</span><span class="s2">, </span><span class="s1">x0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x0e</span><span class="s2">, </span><span class="s1">x1e = x0</span><span class="s2">, </span><span class="s1">x1</span>
            <span class="s2">if </span><span class="s1">y1 &lt; y0:</span>
                <span class="s1">y0e</span><span class="s2">, </span><span class="s1">y1e = y1</span><span class="s2">, </span><span class="s1">y0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y0e</span><span class="s2">, </span><span class="s1">y1e = y0</span><span class="s2">, </span><span class="s1">y1</span>
            <span class="s1">xys = line_circle_intersect(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1)</span>
            <span class="s1">xs</span><span class="s2">, </span><span class="s1">ys = xys.T</span>
            <span class="s2">return </span><span class="s1">xys[</span>
                <span class="s1">(x0e - epsilon &lt; xs) &amp; (xs &lt; x1e + epsilon)</span>
                <span class="s1">&amp; (y0e - epsilon &lt; ys) &amp; (ys &lt; y1e + epsilon)</span>
            <span class="s1">]</span>

        <span class="s5"># Transform the axes (or figure) box_path so that it is relative to</span>
        <span class="s5"># the unit circle in the same way that it is relative to the desired</span>
        <span class="s5"># ellipse.</span>
        <span class="s1">box_path_transform = (</span>
            <span class="s1">transforms.BboxTransformTo((self.axes </span><span class="s2">or </span><span class="s1">self.figure).bbox)</span>
            <span class="s1">- self.get_transform())</span>
        <span class="s1">box_path = Path.unit_rectangle().transformed(box_path_transform)</span>

        <span class="s1">thetas = set()</span>
        <span class="s5"># For each of the point pairs, there is a line segment</span>
        <span class="s2">for </span><span class="s1">p0</span><span class="s2">, </span><span class="s1">p1 </span><span class="s2">in </span><span class="s1">zip(box_path.vertices[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">box_path.vertices[</span><span class="s4">1</span><span class="s1">:]):</span>
            <span class="s1">xy = segment_circle_intersect(*p0</span><span class="s2">, </span><span class="s1">*p1)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = xy.T</span>
            <span class="s5"># arctan2 return [-pi, pi), the rest of our angles are in</span>
            <span class="s5"># [0, 360], adjust as needed.</span>
            <span class="s1">theta = (np.rad2deg(np.arctan2(y</span><span class="s2">, </span><span class="s1">x)) + </span><span class="s4">360</span><span class="s1">) % </span><span class="s4">360</span>
            <span class="s1">thetas.update(</span>
                <span class="s1">theta[(self._theta1 &lt; theta) &amp; (theta &lt; self._theta2)])</span>
        <span class="s1">thetas = sorted(thetas) + [self._theta2]</span>
        <span class="s1">last_theta = self._theta1</span>
        <span class="s1">theta1_rad = np.deg2rad(self._theta1)</span>
        <span class="s1">inside = box_path.contains_point(</span>
            <span class="s1">(np.cos(theta1_rad)</span><span class="s2">, </span><span class="s1">np.sin(theta1_rad))</span>
        <span class="s1">)</span>

        <span class="s5"># save original path</span>
        <span class="s1">path_original = self._path</span>
        <span class="s2">for </span><span class="s1">theta </span><span class="s2">in </span><span class="s1">thetas:</span>
            <span class="s2">if </span><span class="s1">inside:</span>
                <span class="s1">self._path = Path.arc(last_theta</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
                <span class="s1">Patch.draw(self</span><span class="s2">, </span><span class="s1">renderer)</span>
                <span class="s1">inside = </span><span class="s2">False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">inside = </span><span class="s2">True</span>
            <span class="s1">last_theta = theta</span>

        <span class="s5"># restore original path</span>
        <span class="s1">self._path = path_original</span>

    <span class="s2">def </span><span class="s1">_update_path(self):</span>
        <span class="s5"># Compute new values and update and set new _path if any value changed</span>
        <span class="s1">stretched = self._theta_stretch()</span>
        <span class="s2">if </span><span class="s1">any(a != b </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">zip(</span>
                <span class="s1">stretched</span><span class="s2">, </span><span class="s1">(self._theta1</span><span class="s2">, </span><span class="s1">self._theta2</span><span class="s2">, </span><span class="s1">self._stretched_width</span><span class="s2">,</span>
                            <span class="s1">self._stretched_height))):</span>
            <span class="s1">(self._theta1</span><span class="s2">, </span><span class="s1">self._theta2</span><span class="s2">, </span><span class="s1">self._stretched_width</span><span class="s2">,</span>
             <span class="s1">self._stretched_height) = stretched</span>
            <span class="s1">self._path = Path.arc(self._theta1</span><span class="s2">, </span><span class="s1">self._theta2)</span>

    <span class="s2">def </span><span class="s1">_theta_stretch(self):</span>
        <span class="s5"># If the width and height of ellipse are not equal, take into account</span>
        <span class="s5"># stretching when calculating angles to draw between</span>
        <span class="s2">def </span><span class="s1">theta_stretch(theta</span><span class="s2">, </span><span class="s1">scale):</span>
            <span class="s1">theta = np.deg2rad(theta)</span>
            <span class="s1">x = np.cos(theta)</span>
            <span class="s1">y = np.sin(theta)</span>
            <span class="s1">stheta = np.rad2deg(np.arctan2(scale * y</span><span class="s2">, </span><span class="s1">x))</span>
            <span class="s5"># arctan2 has the range [-pi, pi], we expect [0, 2*pi]</span>
            <span class="s2">return </span><span class="s1">(stheta + </span><span class="s4">360</span><span class="s1">) % </span><span class="s4">360</span>

        <span class="s1">width = self.convert_xunits(self.width)</span>
        <span class="s1">height = self.convert_yunits(self.height)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s5"># if we need to stretch the angles because we are distorted</span>
            <span class="s1">width != height</span>
            <span class="s5"># and we are not doing a full circle.</span>
            <span class="s5">#</span>
            <span class="s5"># 0 and 360 do not exactly round-trip through the angle</span>
            <span class="s5"># stretching (due to both float precision limitations and</span>
            <span class="s5"># the difference between the range of arctan2 [-pi, pi] and</span>
            <span class="s5"># this method [0, 360]) so avoid doing it if we don't have to.</span>
            <span class="s2">and not </span><span class="s1">(self.theta1 != self.theta2 </span><span class="s2">and</span>
                     <span class="s1">self.theta1 % </span><span class="s4">360 </span><span class="s1">== self.theta2 % </span><span class="s4">360</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">theta1 = theta_stretch(self.theta1</span><span class="s2">, </span><span class="s1">width / height)</span>
            <span class="s1">theta2 = theta_stretch(self.theta2</span><span class="s2">, </span><span class="s1">width / height)</span>
            <span class="s2">return </span><span class="s1">theta1</span><span class="s2">, </span><span class="s1">theta2</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span>
        <span class="s2">return </span><span class="s1">self.theta1</span><span class="s2">, </span><span class="s1">self.theta2</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span>


<span class="s2">def </span><span class="s1">bbox_artist(artist</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">props=</span><span class="s2">None, </span><span class="s1">fill=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A debug function to draw a rectangle around the bounding 
    box returned by an artist's `.Artist.get_window_extent` 
    to test whether the artist is returning the correct bbox. 
 
    *props* is a dict of rectangle props with the additional property 
    'pad' that sets the padding around the bbox in points. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">props </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">props = {}</span>
    <span class="s1">props = props.copy()  </span><span class="s5"># don't want to alter the pad externally</span>
    <span class="s1">pad = props.pop(</span><span class="s3">'pad'</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">pad = renderer.points_to_pixels(pad)</span>
    <span class="s1">bbox = artist.get_window_extent(renderer)</span>
    <span class="s1">r = Rectangle(</span>
        <span class="s1">xy=(bbox.x0 - pad / </span><span class="s4">2</span><span class="s2">, </span><span class="s1">bbox.y0 - pad / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">width=bbox.width + pad</span><span class="s2">, </span><span class="s1">height=bbox.height + pad</span><span class="s2">,</span>
        <span class="s1">fill=fill</span><span class="s2">, </span><span class="s1">transform=transforms.IdentityTransform()</span><span class="s2">, </span><span class="s1">clip_on=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">r.update(props)</span>
    <span class="s1">r.draw(renderer)</span>


<span class="s2">def </span><span class="s1">draw_bbox(bbox</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">trans=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    A debug function to draw a rectangle around the bounding 
    box returned by an artist's `.Artist.get_window_extent` 
    to test whether the artist is returning the correct bbox. 
    &quot;&quot;&quot;</span>
    <span class="s1">r = Rectangle(xy=bbox.p0</span><span class="s2">, </span><span class="s1">width=bbox.width</span><span class="s2">, </span><span class="s1">height=bbox.height</span><span class="s2">,</span>
                  <span class="s1">edgecolor=color</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">False, </span><span class="s1">clip_on=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">trans </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">r.set_transform(trans)</span>
    <span class="s1">r.draw(renderer)</span>


<span class="s2">class </span><span class="s1">_Style:</span>
    <span class="s0">&quot;&quot;&quot; 
    A base class for the Styles. It is meant to be a container class, 
    where actual styles are declared as subclass of it, and it 
    provides some helper functions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init_subclass__(cls):</span>
        <span class="s5"># Automatically perform docstring interpolation on the subclasses:</span>
        <span class="s5"># This allows listing the supported styles via</span>
        <span class="s5"># - %(BoxStyle:table)s</span>
        <span class="s5"># - %(ConnectionStyle:table)s</span>
        <span class="s5"># - %(ArrowStyle:table)s</span>
        <span class="s5"># and additionally adding .. ACCEPTS: blocks via</span>
        <span class="s5"># - %(BoxStyle:table_and_accepts)s</span>
        <span class="s5"># - %(ConnectionStyle:table_and_accepts)s</span>
        <span class="s5"># - %(ArrowStyle:table_and_accepts)s</span>
        <span class="s1">_docstring.interpd.update({</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">cls.__name__</span><span class="s2">}</span><span class="s3">:table&quot;</span><span class="s1">: cls.pprint_styles()</span><span class="s2">,</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">cls.__name__</span><span class="s2">}</span><span class="s3">:table_and_accepts&quot;</span><span class="s1">: (</span>
                <span class="s1">cls.pprint_styles()</span>
                <span class="s1">+ </span><span class="s3">&quot;</span><span class="s2">\n\n    </span><span class="s3">.. ACCEPTS: [&quot;</span>
                <span class="s1">+ </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(map(</span><span class="s3">&quot; '{}' &quot;</span><span class="s1">.format</span><span class="s2">, </span><span class="s1">cls._style_list))</span>
                <span class="s1">+ </span><span class="s3">&quot;]&quot;</span><span class="s1">)</span>
        <span class="s1">})</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">stylename</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot;Return the instance of the subclass with the given style name.&quot;&quot;&quot;</span>
        <span class="s5"># The &quot;class&quot; should have the _style_list attribute, which is a mapping</span>
        <span class="s5"># of style names to style classes.</span>
        <span class="s1">_list = stylename.replace(</span><span class="s3">&quot; &quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">).split(</span><span class="s3">&quot;,&quot;</span><span class="s1">)</span>
        <span class="s1">_name = _list[</span><span class="s4">0</span><span class="s1">].lower()</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">_cls = cls._style_list[_name]</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Unknown style: </span><span class="s2">{</span><span class="s1">stylename</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">_args_pair = [cs.split(</span><span class="s3">&quot;=&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">cs </span><span class="s2">in </span><span class="s1">_list[</span><span class="s4">1</span><span class="s1">:]]</span>
            <span class="s1">_args = {k: float(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_args_pair}</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Incorrect style argument: </span><span class="s2">{</span><span class="s1">stylename</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">_cls(**{**_args</span><span class="s2">, </span><span class="s1">**kwargs})</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">get_styles(cls):</span>
        <span class="s0">&quot;&quot;&quot;Return a dictionary of available styles.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">cls._style_list</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">pprint_styles(cls):</span>
        <span class="s0">&quot;&quot;&quot;Return the available styles as pretty-printed string.&quot;&quot;&quot;</span>
        <span class="s1">table = [(</span><span class="s3">'Class'</span><span class="s2">, </span><span class="s3">'Name'</span><span class="s2">, </span><span class="s3">'Attrs'</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">*[(cls.__name__</span><span class="s2">,</span>
                    <span class="s5"># Add backquotes, as - and | have special meaning in reST.</span>
                    <span class="s3">f'``</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">``'</span><span class="s2">,</span>
                    <span class="s5"># [1:-1] drops the surrounding parentheses.</span>
                    <span class="s1">str(inspect.signature(cls))[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">] </span><span class="s2">or </span><span class="s3">'None'</span><span class="s1">)</span>
                   <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">cls._style_list.items()]]</span>
        <span class="s5"># Convert to rst table.</span>
        <span class="s1">col_len = [max(len(cell) </span><span class="s2">for </span><span class="s1">cell </span><span class="s2">in </span><span class="s1">column) </span><span class="s2">for </span><span class="s1">column </span><span class="s2">in </span><span class="s1">zip(*table)]</span>
        <span class="s1">table_formatstr = </span><span class="s3">'  '</span><span class="s1">.join(</span><span class="s3">'=' </span><span class="s1">* cl </span><span class="s2">for </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">col_len)</span>
        <span class="s1">rst_table = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join([</span>
            <span class="s3">''</span><span class="s2">,</span>
            <span class="s1">table_formatstr</span><span class="s2">,</span>
            <span class="s3">'  '</span><span class="s1">.join(cell.ljust(cl) </span><span class="s2">for </span><span class="s1">cell</span><span class="s2">, </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">zip(table[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">col_len))</span><span class="s2">,</span>
            <span class="s1">table_formatstr</span><span class="s2">,</span>
            <span class="s1">*[</span><span class="s3">'  '</span><span class="s1">.join(cell.ljust(cl) </span><span class="s2">for </span><span class="s1">cell</span><span class="s2">, </span><span class="s1">cl </span><span class="s2">in </span><span class="s1">zip(row</span><span class="s2">, </span><span class="s1">col_len))</span>
              <span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">table[</span><span class="s4">1</span><span class="s1">:]]</span><span class="s2">,</span>
            <span class="s1">table_formatstr</span><span class="s2">,</span>
        <span class="s1">])</span>
        <span class="s2">return </span><span class="s1">textwrap.indent(rst_table</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s3">' ' </span><span class="s1">* </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">register(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">style):</span>
        <span class="s0">&quot;&quot;&quot;Register a new style.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">issubclass(style</span><span class="s2">, </span><span class="s1">cls._Base):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;%s must be a subclass of %s&quot; </span><span class="s1">% (style</span><span class="s2">,</span>
                                                              <span class="s1">cls._Base))</span>
        <span class="s1">cls._style_list[name] = style</span>


<span class="s2">def </span><span class="s1">_register_style(style_list</span><span class="s2">, </span><span class="s1">cls=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Class decorator that stashes a class in a (style) dictionary.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cls </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">functools.partial(_register_style</span><span class="s2">, </span><span class="s1">style_list</span><span class="s2">, </span><span class="s1">name=name)</span>
    <span class="s1">style_list[name </span><span class="s2">or </span><span class="s1">cls.__name__.lower()] = cls</span>
    <span class="s2">return </span><span class="s1">cls</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">class </span><span class="s1">BoxStyle(_Style):</span>
    <span class="s0">&quot;&quot;&quot; 
    `BoxStyle` is a container class which defines several 
    boxstyle classes, which are used for `FancyBboxPatch`. 
 
    A style object can be created as:: 
 
           BoxStyle.Round(pad=0.2) 
 
    or:: 
 
           BoxStyle(&quot;Round&quot;, pad=0.2) 
 
    or:: 
 
           BoxStyle(&quot;Round, pad=0.2&quot;) 
 
    The following boxstyle classes are defined. 
 
    %(BoxStyle:table)s 
 
    An instance of a boxstyle class is a callable object, with the signature :: 
 
       __call__(self, x0, y0, width, height, mutation_size) -&gt; Path 
 
    *x0*, *y0*, *width* and *height* specify the location and size of the box 
    to be drawn; *mutation_size* scales the outline properties such as padding. 
    &quot;&quot;&quot;</span>

    <span class="s1">_style_list = {}</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Square:</span>
        <span class="s0">&quot;&quot;&quot;A square box.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">pad = mutation_size * self.pad</span>
            <span class="s5"># width and height with padding added.</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = width + </span><span class="s4">2 </span><span class="s1">* pad</span><span class="s2">, </span><span class="s1">height + </span><span class="s4">2 </span><span class="s1">* pad</span>
            <span class="s5"># boundary of the padded box</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>
            <span class="s2">return </span><span class="s1">Path._create_closed(</span>
                <span class="s1">[(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y1)])</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Circle:</span>
        <span class="s0">&quot;&quot;&quot;A circular box.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">pad = mutation_size * self.pad</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = width + </span><span class="s4">2 </span><span class="s1">* pad</span><span class="s2">, </span><span class="s1">height + </span><span class="s4">2 </span><span class="s1">* pad</span>
            <span class="s5"># boundary of the padded box</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span>
            <span class="s2">return </span><span class="s1">Path.circle((x0 + width / </span><span class="s4">2</span><span class="s2">, </span><span class="s1">y0 + height / </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                                <span class="s1">max(width</span><span class="s2">, </span><span class="s1">height) / </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Ellipse:</span>
        <span class="s0">&quot;&quot;&quot; 
        An elliptical box. 
 
        .. versionadded:: 3.7 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">pad = mutation_size * self.pad</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = width + </span><span class="s4">2 </span><span class="s1">* pad</span><span class="s2">, </span><span class="s1">height + </span><span class="s4">2 </span><span class="s1">* pad</span>
            <span class="s5"># boundary of the padded box</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span>
            <span class="s1">a = width / math.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">b = height / math.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">trans = Affine2D().scale(a</span><span class="s2">, </span><span class="s1">b).translate(x0 + width / </span><span class="s4">2</span><span class="s2">,</span>
                                                     <span class="s1">y0 + height / </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">trans.transform_path(Path.unit_circle())</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">LArrow:</span>
        <span class="s0">&quot;&quot;&quot;A box in the shape of a left-pointing arrow.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s5"># padding</span>
            <span class="s1">pad = mutation_size * self.pad</span>
            <span class="s5"># width and height with padding added.</span>
            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = width + </span><span class="s4">2 </span><span class="s1">* pad</span><span class="s2">, </span><span class="s1">height + </span><span class="s4">2 </span><span class="s1">* pad</span>
            <span class="s5"># boundary of the padded box</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span><span class="s2">,</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>

            <span class="s1">dx = (y1 - y0) / </span><span class="s4">2</span>
            <span class="s1">dxx = dx / </span><span class="s4">2</span>
            <span class="s1">x0 = x0 + pad / </span><span class="s4">1.4  </span><span class="s5"># adjust by ~sqrt(2)</span>

            <span class="s2">return </span><span class="s1">Path._create_closed(</span>
                <span class="s1">[(x0 + dxx</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                 <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y1 + dxx)</span><span class="s2">, </span><span class="s1">(x0 - dx</span><span class="s2">, </span><span class="s1">y0 + dx)</span><span class="s2">,</span>
                 <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y0 - dxx)</span><span class="s2">,  </span><span class="s5"># arrow</span>
                 <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y0)])</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">RArrow(LArrow):</span>
        <span class="s0">&quot;&quot;&quot;A box in the shape of a right-pointing arrow.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">p = BoxStyle.LArrow.__call__(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size)</span>
            <span class="s1">p.vertices[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = </span><span class="s4">2 </span><span class="s1">* x0 + width - p.vertices[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">p</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">DArrow:</span>
        <span class="s0">&quot;&quot;&quot;A box in the shape of a two-way arrow.&quot;&quot;&quot;</span>
        <span class="s5"># Modified from LArrow to add a right arrow to the bbox.</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s5"># padding</span>
            <span class="s1">pad = mutation_size * self.pad</span>
            <span class="s5"># width and height with padding added.</span>
            <span class="s5"># The width is padded by the arrows, so we don't need to pad it.</span>
            <span class="s1">height = height + </span><span class="s4">2 </span><span class="s1">* pad</span>
            <span class="s5"># boundary of the padded box</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>

            <span class="s1">dx = (y1 - y0) / </span><span class="s4">2</span>
            <span class="s1">dxx = dx / </span><span class="s4">2</span>
            <span class="s1">x0 = x0 + pad / </span><span class="s4">1.4  </span><span class="s5"># adjust by ~sqrt(2)</span>

            <span class="s2">return </span><span class="s1">Path._create_closed([</span>
                <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,  </span><span class="s5"># bot-segment</span>
                <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0 - dxx)</span><span class="s2">, </span><span class="s1">(x1 + dx + dxx</span><span class="s2">, </span><span class="s1">y0 + dx)</span><span class="s2">,</span>
                <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1 + dxx)</span><span class="s2">,  </span><span class="s5"># right-arrow</span>
                <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,  </span><span class="s5"># top-segment</span>
                <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y1 + dxx)</span><span class="s2">, </span><span class="s1">(x0 - dx</span><span class="s2">, </span><span class="s1">y0 + dx)</span><span class="s2">,</span>
                <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y0 - dxx)</span><span class="s2">,  </span><span class="s5"># left-arrow</span>
                <span class="s1">(x0 + dxx</span><span class="s2">, </span><span class="s1">y0)])</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Round:</span>
        <span class="s0">&quot;&quot;&quot;A box with round corners.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">rounding_size=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            rounding_size : float, default: *pad* 
                Radius of the corners. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>
            <span class="s1">self.rounding_size = rounding_size</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>

            <span class="s5"># padding</span>
            <span class="s1">pad = mutation_size * self.pad</span>

            <span class="s5"># size of the rounding corner</span>
            <span class="s2">if </span><span class="s1">self.rounding_size:</span>
                <span class="s1">dr = mutation_size * self.rounding_size</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dr = pad</span>

            <span class="s1">width</span><span class="s2">, </span><span class="s1">height = width + </span><span class="s4">2 </span><span class="s1">* pad</span><span class="s2">, </span><span class="s1">height + </span><span class="s4">2 </span><span class="s1">* pad</span>

            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad</span><span class="s2">, </span><span class="s1">y0 - pad</span><span class="s2">,</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>

            <span class="s5"># Round corners are implemented as quadratic Bezier, e.g.,</span>
            <span class="s5"># [(x0, y0-dr), (x0, y0), (x0+dr, y0)] for lower left corner.</span>
            <span class="s1">cp = [(x0 + dr</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x1 - dr</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0 + dr)</span><span class="s2">,</span>
                  <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1 - dr)</span><span class="s2">,</span>
                  <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x1 - dr</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                  <span class="s1">(x0 + dr</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                  <span class="s1">(x0</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y1 - dr)</span><span class="s2">,</span>
                  <span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0 + dr)</span><span class="s2">,</span>
                  <span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x0 + dr</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x0 + dr</span><span class="s2">, </span><span class="s1">y0)]</span>

            <span class="s1">com = [Path.MOVETO</span><span class="s2">,</span>
                   <span class="s1">Path.LINETO</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">,</span>
                   <span class="s1">Path.LINETO</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">,</span>
                   <span class="s1">Path.LINETO</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">,</span>
                   <span class="s1">Path.LINETO</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">,</span>
                   <span class="s1">Path.CLOSEPOLY]</span>

            <span class="s2">return </span><span class="s1">Path(cp</span><span class="s2">, </span><span class="s1">com)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Round4:</span>
        <span class="s0">&quot;&quot;&quot;A box with rounded edges.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">rounding_size=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            rounding_size : float, default: *pad*/2 
                Rounding of edges. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>
            <span class="s1">self.rounding_size = rounding_size</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>

            <span class="s5"># padding</span>
            <span class="s1">pad = mutation_size * self.pad</span>

            <span class="s5"># Rounding size; defaults to half of the padding.</span>
            <span class="s2">if </span><span class="s1">self.rounding_size:</span>
                <span class="s1">dr = mutation_size * self.rounding_size</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dr = pad / </span><span class="s4">2.</span>

            <span class="s1">width = width + </span><span class="s4">2 </span><span class="s1">* pad - </span><span class="s4">2 </span><span class="s1">* dr</span>
            <span class="s1">height = height + </span><span class="s4">2 </span><span class="s1">* pad - </span><span class="s4">2 </span><span class="s1">* dr</span>

            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad + dr</span><span class="s2">, </span><span class="s1">y0 - pad + dr</span><span class="s2">,</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>

            <span class="s1">cp = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x0 + dr</span><span class="s2">, </span><span class="s1">y0 - dr)</span><span class="s2">, </span><span class="s1">(x1 - dr</span><span class="s2">, </span><span class="s1">y0 - dr)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x1 + dr</span><span class="s2">, </span><span class="s1">y0 + dr)</span><span class="s2">, </span><span class="s1">(x1 + dr</span><span class="s2">, </span><span class="s1">y1 - dr)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                  <span class="s1">(x1 - dr</span><span class="s2">, </span><span class="s1">y1 + dr)</span><span class="s2">, </span><span class="s1">(x0 + dr</span><span class="s2">, </span><span class="s1">y1 + dr)</span><span class="s2">, </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                  <span class="s1">(x0 - dr</span><span class="s2">, </span><span class="s1">y1 - dr)</span><span class="s2">, </span><span class="s1">(x0 - dr</span><span class="s2">, </span><span class="s1">y0 + dr)</span><span class="s2">, </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">,</span>
                  <span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0)]</span>

            <span class="s1">com = [Path.MOVETO</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">,</span>
                   <span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">, </span><span class="s1">Path.CURVE4</span><span class="s2">,</span>
                   <span class="s1">Path.CLOSEPOLY]</span>

            <span class="s2">return </span><span class="s1">Path(cp</span><span class="s2">, </span><span class="s1">com)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Sawtooth:</span>
        <span class="s0">&quot;&quot;&quot;A box with a sawtooth outline.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pad=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">tooth_size=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            pad : float, default: 0.3 
                The amount of padding around the original box. 
            tooth_size : float, default: *pad*/2 
                Size of the sawtooth. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.pad = pad</span>
            <span class="s1">self.tooth_size = tooth_size</span>

        <span class="s2">def </span><span class="s1">_get_sawtooth_vertices(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>

            <span class="s5"># padding</span>
            <span class="s1">pad = mutation_size * self.pad</span>

            <span class="s5"># size of sawtooth</span>
            <span class="s2">if </span><span class="s1">self.tooth_size </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">tooth_size = self.pad * </span><span class="s4">.5 </span><span class="s1">* mutation_size</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tooth_size = self.tooth_size * mutation_size</span>

            <span class="s1">hsz = tooth_size / </span><span class="s4">2</span>
            <span class="s1">width = width + </span><span class="s4">2 </span><span class="s1">* pad - tooth_size</span>
            <span class="s1">height = height + </span><span class="s4">2 </span><span class="s1">* pad - tooth_size</span>

            <span class="s5"># the sizes of the vertical and horizontal sawtooth are</span>
            <span class="s5"># separately adjusted to fit the given box size.</span>
            <span class="s1">dsx_n = round((width - tooth_size) / (tooth_size * </span><span class="s4">2</span><span class="s1">)) * </span><span class="s4">2</span>
            <span class="s1">dsx = (width - tooth_size) / dsx_n</span>
            <span class="s1">dsy_n = round((height - tooth_size) / (tooth_size * </span><span class="s4">2</span><span class="s1">)) * </span><span class="s4">2</span>
            <span class="s1">dsy = (height - tooth_size) / dsy_n</span>

            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = x0 - pad + hsz</span><span class="s2">, </span><span class="s1">y0 - pad + hsz</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = x0 + width</span><span class="s2">, </span><span class="s1">y0 + height</span>

            <span class="s1">xs = [</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">*np.linspace(x0 + hsz</span><span class="s2">, </span><span class="s1">x1 - hsz</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* dsx_n + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># bottom</span>
                <span class="s1">*([x1</span><span class="s2">, </span><span class="s1">x1 + hsz</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x1 - hsz] * dsy_n)[:</span><span class="s4">2</span><span class="s1">*dsy_n+</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># right</span>
                <span class="s1">x1</span><span class="s2">, </span><span class="s1">*np.linspace(x1 - hsz</span><span class="s2">, </span><span class="s1">x0 + hsz</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* dsx_n + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># top</span>
                <span class="s1">*([x0</span><span class="s2">, </span><span class="s1">x0 - hsz</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x0 + hsz] * dsy_n)[:</span><span class="s4">2</span><span class="s1">*dsy_n+</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># left</span>
            <span class="s1">]</span>
            <span class="s1">ys = [</span>
                <span class="s1">*([y0</span><span class="s2">, </span><span class="s1">y0 - hsz</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">y0 + hsz] * dsx_n)[:</span><span class="s4">2</span><span class="s1">*dsx_n+</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># bottom</span>
                <span class="s1">y0</span><span class="s2">, </span><span class="s1">*np.linspace(y0 + hsz</span><span class="s2">, </span><span class="s1">y1 - hsz</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* dsy_n + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># right</span>
                <span class="s1">*([y1</span><span class="s2">, </span><span class="s1">y1 + hsz</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">y1 - hsz] * dsx_n)[:</span><span class="s4">2</span><span class="s1">*dsx_n+</span><span class="s4">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s5"># top</span>
                <span class="s1">y1</span><span class="s2">, </span><span class="s1">*np.linspace(y1 - hsz</span><span class="s2">, </span><span class="s1">y0 + hsz</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">* dsy_n + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,  </span><span class="s5"># left</span>
            <span class="s1">]</span>

            <span class="s2">return </span><span class="s1">[*zip(xs</span><span class="s2">, </span><span class="s1">ys)</span><span class="s2">, </span><span class="s1">(xs[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ys[</span><span class="s4">0</span><span class="s1">])]</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">saw_vertices = self._get_sawtooth_vertices(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">,</span>
                                                       <span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size)</span>
            <span class="s2">return </span><span class="s1">Path(saw_vertices</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Roundtooth(Sawtooth):</span>
        <span class="s0">&quot;&quot;&quot;A box with a rounded sawtooth outline.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">mutation_size):</span>
            <span class="s1">saw_vertices = self._get_sawtooth_vertices(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">,</span>
                                                       <span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">,</span>
                                                       <span class="s1">mutation_size)</span>
            <span class="s5"># Add a trailing vertex to allow us to close the polygon correctly</span>
            <span class="s1">saw_vertices = np.concatenate([saw_vertices</span><span class="s2">, </span><span class="s1">[saw_vertices[</span><span class="s4">0</span><span class="s1">]]])</span>
            <span class="s1">codes = ([Path.MOVETO] +</span>
                     <span class="s1">[Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3] * ((len(saw_vertices)-</span><span class="s4">1</span><span class="s1">)//</span><span class="s4">2</span><span class="s1">) +</span>
                     <span class="s1">[Path.CLOSEPOLY])</span>
            <span class="s2">return </span><span class="s1">Path(saw_vertices</span><span class="s2">, </span><span class="s1">codes)</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">class </span><span class="s1">ConnectionStyle(_Style):</span>
    <span class="s0">&quot;&quot;&quot; 
    `ConnectionStyle` is a container class which defines 
    several connectionstyle classes, which is used to create a path 
    between two points.  These are mainly used with `FancyArrowPatch`. 
 
    A connectionstyle object can be either created as:: 
 
           ConnectionStyle.Arc3(rad=0.2) 
 
    or:: 
 
           ConnectionStyle(&quot;Arc3&quot;, rad=0.2) 
 
    or:: 
 
           ConnectionStyle(&quot;Arc3, rad=0.2&quot;) 
 
    The following classes are defined 
 
    %(ConnectionStyle:table)s 
 
    An instance of any connection style class is a callable object, 
    whose call signature is:: 
 
        __call__(self, posA, posB, 
                 patchA=None, patchB=None, 
                 shrinkA=2., shrinkB=2.) 
 
    and it returns a `.Path` instance. *posA* and *posB* are 
    tuples of (x, y) coordinates of the two points to be 
    connected. *patchA* (or *patchB*) is given, the returned path is 
    clipped so that it start (or end) from the boundary of the 
    patch. The path is further shrunk by *shrinkA* (or *shrinkB*) 
    which is given in points. 
    &quot;&quot;&quot;</span>

    <span class="s1">_style_list = {}</span>

    <span class="s2">class </span><span class="s1">_Base:</span>
        <span class="s0">&quot;&quot;&quot; 
        A base class for connectionstyle classes. The subclass needs 
        to implement a *connect* method whose call signature is:: 
 
          connect(posA, posB) 
 
        where posA and posB are tuples of x, y coordinates to be 
        connected.  The method needs to return a path connecting two 
        points. This base class defines a __call__ method, and a few 
        helper methods. 
        &quot;&quot;&quot;</span>

        <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.7&quot;</span><span class="s1">)</span>
        <span class="s2">class </span><span class="s1">SimpleEvent:</span>
            <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy):</span>
                <span class="s1">self.x</span><span class="s2">, </span><span class="s1">self.y = xy</span>

        <span class="s2">def </span><span class="s1">_in_patch(self</span><span class="s2">, </span><span class="s1">patch):</span>
            <span class="s0">&quot;&quot;&quot; 
            Return a predicate function testing whether a point *xy* is 
            contained in *patch*. 
            &quot;&quot;&quot;</span>
            <span class="s2">return lambda </span><span class="s1">xy: patch.contains(</span>
                <span class="s1">SimpleNamespace(x=xy[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y=xy[</span><span class="s4">1</span><span class="s1">]))[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">_clip(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">in_start</span><span class="s2">, </span><span class="s1">in_stop):</span>
            <span class="s0">&quot;&quot;&quot; 
            Clip *path* at its start by the region where *in_start* returns 
            True, and at its stop by the region where *in_stop* returns True. 
 
            The original path is assumed to start in the *in_start* region and 
            to stop in the *in_stop* region. 
            &quot;&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">in_start:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">_</span><span class="s2">, </span><span class="s1">path = split_path_inout(path</span><span class="s2">, </span><span class="s1">in_start)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">pass</span>
            <span class="s2">if </span><span class="s1">in_stop:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">path</span><span class="s2">, </span><span class="s1">_ = split_path_inout(path</span><span class="s2">, </span><span class="s1">in_stop)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">pass</span>
            <span class="s2">return </span><span class="s1">path</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB</span><span class="s2">,</span>
                     <span class="s1">shrinkA=</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">shrinkB=</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">patchA=</span><span class="s2">None, </span><span class="s1">patchB=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Call the *connect* method to create a path between *posA* and 
            *posB*; then clip and shrink the path. 
            &quot;&quot;&quot;</span>
            <span class="s1">path = self.connect(posA</span><span class="s2">, </span><span class="s1">posB)</span>
            <span class="s1">path = self._clip(</span>
                <span class="s1">path</span><span class="s2">,</span>
                <span class="s1">self._in_patch(patchA) </span><span class="s2">if </span><span class="s1">patchA </span><span class="s2">else None,</span>
                <span class="s1">self._in_patch(patchB) </span><span class="s2">if </span><span class="s1">patchB </span><span class="s2">else None,</span>
            <span class="s1">)</span>
            <span class="s1">path = self._clip(</span>
                <span class="s1">path</span><span class="s2">,</span>
                <span class="s1">inside_circle(*path.vertices[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shrinkA) </span><span class="s2">if </span><span class="s1">shrinkA </span><span class="s2">else None,</span>
                <span class="s1">inside_circle(*path.vertices[-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">shrinkB) </span><span class="s2">if </span><span class="s1">shrinkB </span><span class="s2">else None</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">path</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Arc3(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates a simple quadratic BÃ©zier curve between two 
        points. The curve is created so that the middle control point 
        (C1) is located at the same distance from the start (C0) and 
        end points(C2) and the distance of the C1 to the line 
        connecting C0-C2 is *rad* times the distance of C0-C2. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rad=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            rad : float 
              Curvature of the curve. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.rad = rad</span>

        <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = posA</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = posB</span>
            <span class="s1">x12</span><span class="s2">, </span><span class="s1">y12 = (x1 + x2) / </span><span class="s4">2.</span><span class="s2">, </span><span class="s1">(y1 + y2) / </span><span class="s4">2.</span>
            <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x2 - x1</span><span class="s2">, </span><span class="s1">y2 - y1</span>

            <span class="s1">f = self.rad</span>

            <span class="s1">cx</span><span class="s2">, </span><span class="s1">cy = x12 + f * dy</span><span class="s2">, </span><span class="s1">y12 - f * dx</span>

            <span class="s1">vertices = [(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                        <span class="s1">(cx</span><span class="s2">, </span><span class="s1">cy)</span><span class="s2">,</span>
                        <span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>
            <span class="s1">codes = [Path.MOVETO</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE3</span><span class="s2">,</span>
                     <span class="s1">Path.CURVE3]</span>

            <span class="s2">return </span><span class="s1">Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Angle3(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates a simple quadratic BÃ©zier curve between two points. The middle 
        control point is placed at the intersecting point of two lines which 
        cross the start and end point, and have a slope of *angleA* and 
        *angleB*, respectively. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">90</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            angleA : float 
              Starting angle of the path. 
 
            angleB : float 
              Ending angle of the path. 
            &quot;&quot;&quot;</span>

            <span class="s1">self.angleA = angleA</span>
            <span class="s1">self.angleB = angleB</span>

        <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = posA</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = posB</span>

            <span class="s1">cosA = math.cos(math.radians(self.angleA))</span>
            <span class="s1">sinA = math.sin(math.radians(self.angleA))</span>
            <span class="s1">cosB = math.cos(math.radians(self.angleB))</span>
            <span class="s1">sinB = math.sin(math.radians(self.angleB))</span>

            <span class="s1">cx</span><span class="s2">, </span><span class="s1">cy = get_intersection(x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">cosA</span><span class="s2">, </span><span class="s1">sinA</span><span class="s2">,</span>
                                      <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">cosB</span><span class="s2">, </span><span class="s1">sinB)</span>

            <span class="s1">vertices = [(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(cx</span><span class="s2">, </span><span class="s1">cy)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>
            <span class="s1">codes = [Path.MOVETO</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3]</span>

            <span class="s2">return </span><span class="s1">Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Angle(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates a piecewise continuous quadratic BÃ©zier path between two 
        points. The path has a one passing-through point placed at the 
        intersecting point of two lines which cross the start and end point, 
        and have a slope of *angleA* and *angleB*, respectively. 
        The connecting edges are rounded with *rad*. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">90</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rad=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            angleA : float 
              Starting angle of the path. 
 
            angleB : float 
              Ending angle of the path. 
 
            rad : float 
              Rounding radius of the edge. 
            &quot;&quot;&quot;</span>

            <span class="s1">self.angleA = angleA</span>
            <span class="s1">self.angleB = angleB</span>

            <span class="s1">self.rad = rad</span>

        <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = posA</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = posB</span>

            <span class="s1">cosA = math.cos(math.radians(self.angleA))</span>
            <span class="s1">sinA = math.sin(math.radians(self.angleA))</span>
            <span class="s1">cosB = math.cos(math.radians(self.angleB))</span>
            <span class="s1">sinB = math.sin(math.radians(self.angleB))</span>

            <span class="s1">cx</span><span class="s2">, </span><span class="s1">cy = get_intersection(x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">cosA</span><span class="s2">, </span><span class="s1">sinA</span><span class="s2">,</span>
                                      <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">cosB</span><span class="s2">, </span><span class="s1">sinB)</span>

            <span class="s1">vertices = [(x1</span><span class="s2">, </span><span class="s1">y1)]</span>
            <span class="s1">codes = [Path.MOVETO]</span>

            <span class="s2">if </span><span class="s1">self.rad == </span><span class="s4">0.</span><span class="s1">:</span>
                <span class="s1">vertices.append((cx</span><span class="s2">, </span><span class="s1">cy))</span>
                <span class="s1">codes.append(Path.LINETO)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">dx1</span><span class="s2">, </span><span class="s1">dy1 = x1 - cx</span><span class="s2">, </span><span class="s1">y1 - cy</span>
                <span class="s1">d1 = np.hypot(dx1</span><span class="s2">, </span><span class="s1">dy1)</span>
                <span class="s1">f1 = self.rad / d1</span>
                <span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2 = x2 - cx</span><span class="s2">, </span><span class="s1">y2 - cy</span>
                <span class="s1">d2 = np.hypot(dx2</span><span class="s2">, </span><span class="s1">dy2)</span>
                <span class="s1">f2 = self.rad / d2</span>
                <span class="s1">vertices.extend([(cx + dx1 * f1</span><span class="s2">, </span><span class="s1">cy + dy1 * f1)</span><span class="s2">,</span>
                                 <span class="s1">(cx</span><span class="s2">, </span><span class="s1">cy)</span><span class="s2">,</span>
                                 <span class="s1">(cx + dx2 * f2</span><span class="s2">, </span><span class="s1">cy + dy2 * f2)])</span>
                <span class="s1">codes.extend([Path.LINETO</span><span class="s2">, </span><span class="s1">Path.CURVE3</span><span class="s2">, </span><span class="s1">Path.CURVE3])</span>

            <span class="s1">vertices.append((x2</span><span class="s2">, </span><span class="s1">y2))</span>
            <span class="s1">codes.append(Path.LINETO)</span>

            <span class="s2">return </span><span class="s1">Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Arc(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Creates a piecewise continuous quadratic BÃ©zier path between two 
        points. The path can have two passing-through points, a 
        point placed at the distance of *armA* and angle of *angleA* from 
        point A, another point with respect to point B. The edges are 
        rounded with *rad*. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">armA=</span><span class="s2">None, </span><span class="s1">armB=</span><span class="s2">None, </span><span class="s1">rad=</span><span class="s4">0.</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            angleA : float 
              Starting angle of the path. 
 
            angleB : float 
              Ending angle of the path. 
 
            armA : float or None 
              Length of the starting arm. 
 
            armB : float or None 
              Length of the ending arm. 
 
            rad : float 
              Rounding radius of the edges. 
            &quot;&quot;&quot;</span>

            <span class="s1">self.angleA = angleA</span>
            <span class="s1">self.angleB = angleB</span>
            <span class="s1">self.armA = armA</span>
            <span class="s1">self.armB = armB</span>

            <span class="s1">self.rad = rad</span>

        <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = posA</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = posB</span>

            <span class="s1">vertices = [(x1</span><span class="s2">, </span><span class="s1">y1)]</span>
            <span class="s1">rounded = []</span>
            <span class="s1">codes = [Path.MOVETO]</span>

            <span class="s2">if </span><span class="s1">self.armA:</span>
                <span class="s1">cosA = math.cos(math.radians(self.angleA))</span>
                <span class="s1">sinA = math.sin(math.radians(self.angleA))</span>
                <span class="s5"># x_armA, y_armB</span>
                <span class="s1">d = self.armA - self.rad</span>
                <span class="s1">rounded.append((x1 + d * cosA</span><span class="s2">, </span><span class="s1">y1 + d * sinA))</span>
                <span class="s1">d = self.armA</span>
                <span class="s1">rounded.append((x1 + d * cosA</span><span class="s2">, </span><span class="s1">y1 + d * sinA))</span>

            <span class="s2">if </span><span class="s1">self.armB:</span>
                <span class="s1">cosB = math.cos(math.radians(self.angleB))</span>
                <span class="s1">sinB = math.sin(math.radians(self.angleB))</span>
                <span class="s1">x_armB</span><span class="s2">, </span><span class="s1">y_armB = x2 + self.armB * cosB</span><span class="s2">, </span><span class="s1">y2 + self.armB * sinB</span>

                <span class="s2">if </span><span class="s1">rounded:</span>
                    <span class="s1">xp</span><span class="s2">, </span><span class="s1">yp = rounded[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x_armB - xp</span><span class="s2">, </span><span class="s1">y_armB - yp</span>
                    <span class="s1">dd = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>

                    <span class="s1">rounded.append((xp + self.rad * dx / dd</span><span class="s2">,</span>
                                    <span class="s1">yp + self.rad * dy / dd))</span>
                    <span class="s1">vertices.extend(rounded)</span>
                    <span class="s1">codes.extend([Path.LINETO</span><span class="s2">,</span>
                                  <span class="s1">Path.CURVE3</span><span class="s2">,</span>
                                  <span class="s1">Path.CURVE3])</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">xp</span><span class="s2">, </span><span class="s1">yp = vertices[-</span><span class="s4">1</span><span class="s1">]</span>
                    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x_armB - xp</span><span class="s2">, </span><span class="s1">y_armB - yp</span>
                    <span class="s1">dd = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>

                <span class="s1">d = dd - self.rad</span>
                <span class="s1">rounded = [(xp + d * dx / dd</span><span class="s2">, </span><span class="s1">yp + d * dy / dd)</span><span class="s2">,</span>
                           <span class="s1">(x_armB</span><span class="s2">, </span><span class="s1">y_armB)]</span>

            <span class="s2">if </span><span class="s1">rounded:</span>
                <span class="s1">xp</span><span class="s2">, </span><span class="s1">yp = rounded[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x2 - xp</span><span class="s2">, </span><span class="s1">y2 - yp</span>
                <span class="s1">dd = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>

                <span class="s1">rounded.append((xp + self.rad * dx / dd</span><span class="s2">,</span>
                                <span class="s1">yp + self.rad * dy / dd))</span>
                <span class="s1">vertices.extend(rounded)</span>
                <span class="s1">codes.extend([Path.LINETO</span><span class="s2">,</span>
                              <span class="s1">Path.CURVE3</span><span class="s2">,</span>
                              <span class="s1">Path.CURVE3])</span>

            <span class="s1">vertices.append((x2</span><span class="s2">, </span><span class="s1">y2))</span>
            <span class="s1">codes.append(Path.LINETO)</span>

            <span class="s2">return </span><span class="s1">Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Bar(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        A line with *angle* between A and B with *armA* and *armB*. One of the 
        arms is extended so that they are connected in a right angle. The 
        length of *armA* is determined by (*armA* + *fraction* x AB distance). 
        Same for *armB*. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">armA=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">armB=</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">fraction=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">angle=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            armA : float 
                Minimum length of armA. 
 
            armB : float 
                Minimum length of armB. 
 
            fraction : float 
                A fraction of the distance between two points that will be 
                added to armA and armB. 
 
            angle : float or None 
                Angle of the connecting line (if None, parallel to A and B). 
            &quot;&quot;&quot;</span>
            <span class="s1">self.armA = armA</span>
            <span class="s1">self.armB = armB</span>
            <span class="s1">self.fraction = fraction</span>
            <span class="s1">self.angle = angle</span>

        <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = posA</span>
            <span class="s1">x20</span><span class="s2">, </span><span class="s1">y20 = x2</span><span class="s2">, </span><span class="s1">y2 = posB</span>

            <span class="s1">theta1 = math.atan2(y2 - y1</span><span class="s2">, </span><span class="s1">x2 - x1)</span>
            <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x2 - x1</span><span class="s2">, </span><span class="s1">y2 - y1</span>
            <span class="s1">dd = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>
            <span class="s1">ddx</span><span class="s2">, </span><span class="s1">ddy = dx / dd</span><span class="s2">, </span><span class="s1">dy / dd</span>

            <span class="s1">armA</span><span class="s2">, </span><span class="s1">armB = self.armA</span><span class="s2">, </span><span class="s1">self.armB</span>

            <span class="s2">if </span><span class="s1">self.angle </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">theta0 = np.deg2rad(self.angle)</span>
                <span class="s1">dtheta = theta1 - theta0</span>
                <span class="s1">dl = dd * math.sin(dtheta)</span>
                <span class="s1">dL = dd * math.cos(dtheta)</span>
                <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = x1 + dL * math.cos(theta0)</span><span class="s2">, </span><span class="s1">y1 + dL * math.sin(theta0)</span>
                <span class="s1">armB = armB - dl</span>

                <span class="s5"># update</span>
                <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x2 - x1</span><span class="s2">, </span><span class="s1">y2 - y1</span>
                <span class="s1">dd2 = (dx * dx + dy * dy) ** </span><span class="s4">.5</span>
                <span class="s1">ddx</span><span class="s2">, </span><span class="s1">ddy = dx / dd2</span><span class="s2">, </span><span class="s1">dy / dd2</span>

            <span class="s1">arm = max(armA</span><span class="s2">, </span><span class="s1">armB)</span>
            <span class="s1">f = self.fraction * dd + arm</span>

            <span class="s1">cx1</span><span class="s2">, </span><span class="s1">cy1 = x1 + f * ddy</span><span class="s2">, </span><span class="s1">y1 - f * ddx</span>
            <span class="s1">cx2</span><span class="s2">, </span><span class="s1">cy2 = x2 + f * ddy</span><span class="s2">, </span><span class="s1">y2 - f * ddx</span>

            <span class="s1">vertices = [(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                        <span class="s1">(cx1</span><span class="s2">, </span><span class="s1">cy1)</span><span class="s2">,</span>
                        <span class="s1">(cx2</span><span class="s2">, </span><span class="s1">cy2)</span><span class="s2">,</span>
                        <span class="s1">(x20</span><span class="s2">, </span><span class="s1">y20)]</span>
            <span class="s1">codes = [Path.MOVETO</span><span class="s2">,</span>
                     <span class="s1">Path.LINETO</span><span class="s2">,</span>
                     <span class="s1">Path.LINETO</span><span class="s2">,</span>
                     <span class="s1">Path.LINETO]</span>

            <span class="s2">return </span><span class="s1">Path(vertices</span><span class="s2">, </span><span class="s1">codes)</span>


<span class="s2">def </span><span class="s1">_point_along_a_line(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">d):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the point on the line connecting (*x0*, *y0*) -- (*x1*, *y1*) whose 
    distance from (*x0*, *y0*) is *d*. 
    &quot;&quot;&quot;</span>
    <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x0 - x1</span><span class="s2">, </span><span class="s1">y0 - y1</span>
    <span class="s1">ff = d / (dx * dx + dy * dy) ** </span><span class="s4">.5</span>
    <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = x0 - ff * dx</span><span class="s2">, </span><span class="s1">y0 - ff * dy</span>

    <span class="s2">return </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span>


<span class="s1">@_docstring.dedent_interpd</span>
<span class="s2">class </span><span class="s1">ArrowStyle(_Style):</span>
    <span class="s0">&quot;&quot;&quot; 
    `ArrowStyle` is a container class which defines several 
    arrowstyle classes, which is used to create an arrow path along a 
    given path.  These are mainly used with `FancyArrowPatch`. 
 
    An arrowstyle object can be either created as:: 
 
           ArrowStyle.Fancy(head_length=.4, head_width=.4, tail_width=.4) 
 
    or:: 
 
           ArrowStyle(&quot;Fancy&quot;, head_length=.4, head_width=.4, tail_width=.4) 
 
    or:: 
 
           ArrowStyle(&quot;Fancy, head_length=.4, head_width=.4, tail_width=.4&quot;) 
 
    The following classes are defined 
 
    %(ArrowStyle:table)s 
 
    An instance of any arrow style class is a callable object, 
    whose call signature is:: 
 
        __call__(self, path, mutation_size, linewidth, aspect_ratio=1.) 
 
    and it returns a tuple of a `.Path` instance and a boolean 
    value. *path* is a `.Path` instance along which the arrow 
    will be drawn. *mutation_size* and *aspect_ratio* have the same 
    meaning as in `BoxStyle`. *linewidth* is a line width to be 
    stroked. This is meant to be used to correct the location of the 
    head so that it does not overshoot the destination point, but not all 
    classes support it. 
 
    Notes 
    ----- 
    *angleA* and *angleB* specify the orientation of the bracket, as either a 
    clockwise or counterclockwise angle depending on the arrow type. 0 degrees 
    means perpendicular to the line connecting the arrow's head and tail. 
 
    .. plot:: gallery/text_labels_and_annotations/angles_on_bracket_arrows.py 
    &quot;&quot;&quot;</span>

    <span class="s1">_style_list = {}</span>

    <span class="s2">class </span><span class="s1">_Base:</span>
        <span class="s0">&quot;&quot;&quot; 
        Arrow Transmuter Base class 
 
        ArrowTransmuterBase and its derivatives are used to make a fancy 
        arrow around a given path. The __call__ method returns a path 
        (which will be used to create a PathPatch instance) and a boolean 
        value indicating the path is open therefore is not fillable.  This 
        class is not an artist and actual drawing of the fancy arrow is 
        done by the FancyArrowPatch class. 
        &quot;&quot;&quot;</span>

        <span class="s5"># The derived classes are required to be able to be initialized</span>
        <span class="s5"># w/o arguments, i.e., all its argument (except self) must have</span>
        <span class="s5"># the default values.</span>

        <span class="s1">@staticmethod</span>
        <span class="s2">def </span><span class="s1">ensure_quadratic_bezier(path):</span>
            <span class="s0">&quot;&quot;&quot; 
            Some ArrowStyle classes only works with a simple quadratic 
            BÃ©zier curve (created with `.ConnectionStyle.Arc3` or 
            `.ConnectionStyle.Angle3`). This static method checks if the 
            provided path is a simple quadratic BÃ©zier curve and returns its 
            control points if true. 
            &quot;&quot;&quot;</span>
            <span class="s1">segments = list(path.iter_segments())</span>
            <span class="s2">if </span><span class="s1">(len(segments) != </span><span class="s4">2 </span><span class="s2">or </span><span class="s1">segments[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] != Path.MOVETO </span><span class="s2">or</span>
                    <span class="s1">segments[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] != Path.CURVE3):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;'path' is not a valid quadratic Bezier curve&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[*segments[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">*segments[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]]</span>

        <span class="s2">def </span><span class="s1">transmute(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s0">&quot;&quot;&quot; 
            The transmute method is the very core of the ArrowStyle class and 
            must be overridden in the subclasses. It receives the *path* 
            object along which the arrow will be drawn, and the 
            *mutation_size*, with which the arrow head etc. will be scaled. 
            The *linewidth* may be used to adjust the path so that it does not 
            pass beyond the given points. It returns a tuple of a `.Path` 
            instance and a boolean. The boolean value indicate whether the 
            path can be filled or not. The return value can also be a list of 
            paths and list of booleans of the same length. 
            &quot;&quot;&quot;</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">'Derived must override'</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth</span><span class="s2">,</span>
                     <span class="s1">aspect_ratio=</span><span class="s4">1.</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            The __call__ method is a thin wrapper around the transmute method 
            and takes care of the aspect ratio. 
            &quot;&quot;&quot;</span>

            <span class="s2">if </span><span class="s1">aspect_ratio </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s5"># Squeeze the given height by the aspect_ratio</span>
                <span class="s1">vertices = path.vertices / [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">aspect_ratio]</span>
                <span class="s1">path_shrunk = Path(vertices</span><span class="s2">, </span><span class="s1">path.codes)</span>
                <span class="s5"># call transmute method with squeezed height.</span>
                <span class="s1">path_mutated</span><span class="s2">, </span><span class="s1">fillable = self.transmute(path_shrunk</span><span class="s2">,</span>
                                                        <span class="s1">mutation_size</span><span class="s2">,</span>
                                                        <span class="s1">linewidth)</span>
                <span class="s2">if </span><span class="s1">np.iterable(fillable):</span>
                    <span class="s5"># Restore the height</span>
                    <span class="s1">path_list = [Path(p.vertices * [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">aspect_ratio]</span><span class="s2">, </span><span class="s1">p.codes)</span>
                                 <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">path_mutated]</span>
                    <span class="s2">return </span><span class="s1">path_list</span><span class="s2">, </span><span class="s1">fillable</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">path_mutated</span><span class="s2">, </span><span class="s1">fillable</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self.transmute(path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth)</span>

    <span class="s2">class </span><span class="s1">_Curve(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        A simple arrow which will work with any path instance. The 
        returned path is the concatenation of the original path, and at 
        most two paths representing the arrow head or bracket at the start 
        point and at the end point. The arrow heads can be either open 
        or closed. 
        &quot;&quot;&quot;</span>

        <span class="s1">arrow = </span><span class="s3">&quot;-&quot;</span>
        <span class="s1">fillbegin = fillend = </span><span class="s2">False  </span><span class="s5"># Whether arrows are filled.</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">head_length=</span><span class="s4">.4</span><span class="s2">, </span><span class="s1">head_width=</span><span class="s4">.2</span><span class="s2">, </span><span class="s1">widthA=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">widthB=</span><span class="s4">1.</span><span class="s2">,</span>
                     <span class="s1">lengthA=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">lengthB=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scaleA=</span><span class="s2">None,</span>
                     <span class="s1">scaleB=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            head_length : float, default: 0.4 
                Length of the arrow head, relative to *mutation_scale*. 
            head_width : float, default: 0.2 
                Width of the arrow head, relative to *mutation_scale*. 
            widthA : float, default: 1.0 
                Width of the bracket at the beginning of the arrow 
            widthB : float, default: 1.0 
                Width of the bracket at the end of the arrow 
            lengthA : float, default: 0.2 
                Length of the bracket at the beginning of the arrow 
            lengthB : float, default: 0.2 
                Length of the bracket at the end of the arrow 
            angleA : float, default 0 
                Orientation of the bracket at the beginning, as a 
                counterclockwise angle. 0 degrees means perpendicular 
                to the line. 
            angleB : float, default 0 
                Orientation of the bracket at the beginning, as a 
                counterclockwise angle. 0 degrees means perpendicular 
                to the line. 
            scaleA : float, default *mutation_size* 
                The mutation_size for the beginning bracket 
            scaleB : float, default *mutation_size* 
                The mutation_size for the end bracket 
            &quot;&quot;&quot;</span>

            <span class="s1">self.head_length</span><span class="s2">, </span><span class="s1">self.head_width = head_length</span><span class="s2">, </span><span class="s1">head_width</span>
            <span class="s1">self.widthA</span><span class="s2">, </span><span class="s1">self.widthB = widthA</span><span class="s2">, </span><span class="s1">widthB</span>
            <span class="s1">self.lengthA</span><span class="s2">, </span><span class="s1">self.lengthB = lengthA</span><span class="s2">, </span><span class="s1">lengthB</span>
            <span class="s1">self.angleA</span><span class="s2">, </span><span class="s1">self.angleB = angleA</span><span class="s2">, </span><span class="s1">angleB</span>
            <span class="s1">self.scaleA</span><span class="s2">, </span><span class="s1">self.scaleB = scaleA</span><span class="s2">, </span><span class="s1">scaleB</span>

            <span class="s1">self._beginarrow_head = </span><span class="s2">False</span>
            <span class="s1">self._beginarrow_bracket = </span><span class="s2">False</span>
            <span class="s1">self._endarrow_head = </span><span class="s2">False</span>
            <span class="s1">self._endarrow_bracket = </span><span class="s2">False</span>

            <span class="s2">if </span><span class="s3">&quot;-&quot; </span><span class="s2">not in </span><span class="s1">self.arrow:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;arrow must have the '-' between &quot;</span>
                                 <span class="s3">&quot;the two heads&quot;</span><span class="s1">)</span>

            <span class="s1">beginarrow</span><span class="s2">, </span><span class="s1">endarrow = self.arrow.split(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">beginarrow == </span><span class="s3">&quot;&lt;&quot;</span><span class="s1">:</span>
                <span class="s1">self._beginarrow_head = </span><span class="s2">True</span>
                <span class="s1">self._beginarrow_bracket = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">beginarrow == </span><span class="s3">&quot;&lt;|&quot;</span><span class="s1">:</span>
                <span class="s1">self._beginarrow_head = </span><span class="s2">True</span>
                <span class="s1">self._beginarrow_bracket = </span><span class="s2">False</span>
                <span class="s1">self.fillbegin = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">beginarrow </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;]&quot;</span><span class="s2">, </span><span class="s3">&quot;|&quot;</span><span class="s1">):</span>
                <span class="s1">self._beginarrow_head = </span><span class="s2">False</span>
                <span class="s1">self._beginarrow_bracket = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">endarrow == </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">:</span>
                <span class="s1">self._endarrow_head = </span><span class="s2">True</span>
                <span class="s1">self._endarrow_bracket = </span><span class="s2">False</span>
            <span class="s2">elif </span><span class="s1">endarrow == </span><span class="s3">&quot;|&gt;&quot;</span><span class="s1">:</span>
                <span class="s1">self._endarrow_head = </span><span class="s2">True</span>
                <span class="s1">self._endarrow_bracket = </span><span class="s2">False</span>
                <span class="s1">self.fillend = </span><span class="s2">True</span>
            <span class="s2">elif </span><span class="s1">endarrow </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;[&quot;</span><span class="s2">, </span><span class="s3">&quot;|&quot;</span><span class="s1">):</span>
                <span class="s1">self._endarrow_head = </span><span class="s2">False</span>
                <span class="s1">self._endarrow_bracket = </span><span class="s2">True</span>

            <span class="s1">super().__init__()</span>

        <span class="s2">def </span><span class="s1">_get_arrow_wedge(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">,</span>
                             <span class="s1">head_dist</span><span class="s2">, </span><span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s0">&quot;&quot;&quot; 
            Return the paths for arrow heads. Since arrow lines are 
            drawn with capstyle=projected, The arrow goes beyond the 
            desired point. This method also returns the amount of the path 
            to be shrunken so that it does not overshoot. 
            &quot;&quot;&quot;</span>

            <span class="s5"># arrow from x0, y0 to x1, y1</span>
            <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = x0 - x1</span><span class="s2">, </span><span class="s1">y0 - y1</span>

            <span class="s1">cp_distance = np.hypot(dx</span><span class="s2">, </span><span class="s1">dy)</span>

            <span class="s5"># pad_projected : amount of pad to account the</span>
            <span class="s5"># overshooting of the projection of the wedge</span>
            <span class="s1">pad_projected = (</span><span class="s4">.5 </span><span class="s1">* linewidth / sin_t)</span>

            <span class="s5"># Account for division by zero</span>
            <span class="s2">if </span><span class="s1">cp_distance == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">cp_distance = </span><span class="s4">1</span>

            <span class="s5"># apply pad for projected edge</span>
            <span class="s1">ddx = pad_projected * dx / cp_distance</span>
            <span class="s1">ddy = pad_projected * dy / cp_distance</span>

            <span class="s5"># offset for arrow wedge</span>
            <span class="s1">dx = dx / cp_distance * head_dist</span>
            <span class="s1">dy = dy / cp_distance * head_dist</span>

            <span class="s1">dx1</span><span class="s2">, </span><span class="s1">dy1 = cos_t * dx + sin_t * dy</span><span class="s2">, </span><span class="s1">-sin_t * dx + cos_t * dy</span>
            <span class="s1">dx2</span><span class="s2">, </span><span class="s1">dy2 = cos_t * dx - sin_t * dy</span><span class="s2">, </span><span class="s1">sin_t * dx + cos_t * dy</span>

            <span class="s1">vertices_arrow = [(x1 + ddx + dx1</span><span class="s2">, </span><span class="s1">y1 + ddy + dy1)</span><span class="s2">,</span>
                              <span class="s1">(x1 + ddx</span><span class="s2">, </span><span class="s1">y1 + ddy)</span><span class="s2">,</span>
                              <span class="s1">(x1 + ddx + dx2</span><span class="s2">, </span><span class="s1">y1 + ddy + dy2)]</span>
            <span class="s1">codes_arrow = [Path.MOVETO</span><span class="s2">,</span>
                           <span class="s1">Path.LINETO</span><span class="s2">,</span>
                           <span class="s1">Path.LINETO]</span>

            <span class="s2">return </span><span class="s1">vertices_arrow</span><span class="s2">, </span><span class="s1">codes_arrow</span><span class="s2">, </span><span class="s1">ddx</span><span class="s2">, </span><span class="s1">ddy</span>

        <span class="s2">def </span><span class="s1">_get_bracket(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">,</span>
                         <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">angle):</span>

            <span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t = get_cos_sin(x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0)</span>

            <span class="s5"># arrow from x0, y0 to x1, y1</span>
            <span class="s2">from </span><span class="s1">matplotlib.bezier </span><span class="s2">import </span><span class="s1">get_normal_points</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = get_normal_points(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t</span><span class="s2">, </span><span class="s1">width)</span>

            <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = length * cos_t</span><span class="s2">, </span><span class="s1">length * sin_t</span>

            <span class="s1">vertices_arrow = [(x1 + dx</span><span class="s2">, </span><span class="s1">y1 + dy)</span><span class="s2">,</span>
                              <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">,</span>
                              <span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">,</span>
                              <span class="s1">(x2 + dx</span><span class="s2">, </span><span class="s1">y2 + dy)]</span>
            <span class="s1">codes_arrow = [Path.MOVETO</span><span class="s2">,</span>
                           <span class="s1">Path.LINETO</span><span class="s2">,</span>
                           <span class="s1">Path.LINETO</span><span class="s2">,</span>
                           <span class="s1">Path.LINETO]</span>

            <span class="s2">if </span><span class="s1">angle:</span>
                <span class="s1">trans = transforms.Affine2D().rotate_deg_around(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">angle)</span>
                <span class="s1">vertices_arrow = trans.transform(vertices_arrow)</span>

            <span class="s2">return </span><span class="s1">vertices_arrow</span><span class="s2">, </span><span class="s1">codes_arrow</span>

        <span class="s2">def </span><span class="s1">transmute(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s2">if </span><span class="s1">self._beginarrow_head </span><span class="s2">or </span><span class="s1">self._endarrow_head:</span>
                <span class="s1">head_length = self.head_length * mutation_size</span>
                <span class="s1">head_width = self.head_width * mutation_size</span>
                <span class="s1">head_dist = np.hypot(head_length</span><span class="s2">, </span><span class="s1">head_width)</span>
                <span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t = head_length / head_dist</span><span class="s2">, </span><span class="s1">head_width / head_dist</span>

            <span class="s1">scaleA = mutation_size </span><span class="s2">if </span><span class="s1">self.scaleA </span><span class="s2">is None else </span><span class="s1">self.scaleA</span>
            <span class="s1">scaleB = mutation_size </span><span class="s2">if </span><span class="s1">self.scaleB </span><span class="s2">is None else </span><span class="s1">self.scaleB</span>

            <span class="s5"># begin arrow</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = path.vertices[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = path.vertices[</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s5"># If there is no room for an arrow and a line, then skip the arrow</span>
            <span class="s1">has_begin_arrow = self._beginarrow_head </span><span class="s2">and </span><span class="s1">(x0</span><span class="s2">, </span><span class="s1">y0) != (x1</span><span class="s2">, </span><span class="s1">y1)</span>
            <span class="s1">verticesA</span><span class="s2">, </span><span class="s1">codesA</span><span class="s2">, </span><span class="s1">ddxA</span><span class="s2">, </span><span class="s1">ddyA = (</span>
                <span class="s1">self._get_arrow_wedge(x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">,</span>
                                      <span class="s1">head_dist</span><span class="s2">, </span><span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t</span><span class="s2">, </span><span class="s1">linewidth)</span>
                <span class="s2">if </span><span class="s1">has_begin_arrow</span>
                <span class="s2">else </span><span class="s1">([]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s5"># end arrow</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = path.vertices[-</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">x3</span><span class="s2">, </span><span class="s1">y3 = path.vertices[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s5"># If there is no room for an arrow and a line, then skip the arrow</span>
            <span class="s1">has_end_arrow = self._endarrow_head </span><span class="s2">and </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2) != (x3</span><span class="s2">, </span><span class="s1">y3)</span>
            <span class="s1">verticesB</span><span class="s2">, </span><span class="s1">codesB</span><span class="s2">, </span><span class="s1">ddxB</span><span class="s2">, </span><span class="s1">ddyB = (</span>
                <span class="s1">self._get_arrow_wedge(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x3</span><span class="s2">, </span><span class="s1">y3</span><span class="s2">,</span>
                                      <span class="s1">head_dist</span><span class="s2">, </span><span class="s1">cos_t</span><span class="s2">, </span><span class="s1">sin_t</span><span class="s2">, </span><span class="s1">linewidth)</span>
                <span class="s2">if </span><span class="s1">has_end_arrow</span>
                <span class="s2">else </span><span class="s1">([]</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s5"># This simple code will not work if ddx, ddy is greater than the</span>
            <span class="s5"># separation between vertices.</span>
            <span class="s1">paths = [Path(np.concatenate([[(x0 + ddxA</span><span class="s2">, </span><span class="s1">y0 + ddyA)]</span><span class="s2">,</span>
                                          <span class="s1">path.vertices[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                          <span class="s1">[(x3 + ddxB</span><span class="s2">, </span><span class="s1">y3 + ddyB)]])</span><span class="s2">,</span>
                          <span class="s1">path.codes)]</span>
            <span class="s1">fills = [</span><span class="s2">False</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">has_begin_arrow:</span>
                <span class="s2">if </span><span class="s1">self.fillbegin:</span>
                    <span class="s1">paths.append(</span>
                        <span class="s1">Path([*verticesA</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[*codesA</span><span class="s2">, </span><span class="s1">Path.CLOSEPOLY]))</span>
                    <span class="s1">fills.append(</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">paths.append(Path(verticesA</span><span class="s2">, </span><span class="s1">codesA))</span>
                    <span class="s1">fills.append(</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">self._beginarrow_bracket:</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = path.vertices[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = path.vertices[</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">verticesA</span><span class="s2">, </span><span class="s1">codesA = self._get_bracket(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">,</span>
                                                      <span class="s1">self.widthA * scaleA</span><span class="s2">,</span>
                                                      <span class="s1">self.lengthA * scaleA</span><span class="s2">,</span>
                                                      <span class="s1">self.angleA)</span>

                <span class="s1">paths.append(Path(verticesA</span><span class="s2">, </span><span class="s1">codesA))</span>
                <span class="s1">fills.append(</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">has_end_arrow:</span>
                <span class="s2">if </span><span class="s1">self.fillend:</span>
                    <span class="s1">fills.append(</span><span class="s2">True</span><span class="s1">)</span>
                    <span class="s1">paths.append(</span>
                        <span class="s1">Path([*verticesB</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[*codesB</span><span class="s2">, </span><span class="s1">Path.CLOSEPOLY]))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">fills.append(</span><span class="s2">False</span><span class="s1">)</span>
                    <span class="s1">paths.append(Path(verticesB</span><span class="s2">, </span><span class="s1">codesB))</span>
            <span class="s2">elif </span><span class="s1">self._endarrow_bracket:</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = path.vertices[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1 = path.vertices[-</span><span class="s4">2</span><span class="s1">]</span>
                <span class="s1">verticesB</span><span class="s2">, </span><span class="s1">codesB = self._get_bracket(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">,</span>
                                                      <span class="s1">self.widthB * scaleB</span><span class="s2">,</span>
                                                      <span class="s1">self.lengthB * scaleB</span><span class="s2">,</span>
                                                      <span class="s1">self.angleB)</span>

                <span class="s1">paths.append(Path(verticesB</span><span class="s2">, </span><span class="s1">codesB))</span>
                <span class="s1">fills.append(</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">paths</span><span class="s2">, </span><span class="s1">fills</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;-&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">Curve(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;A simple curve without any arrow head.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self):  </span><span class="s5"># hide head_length, head_width</span>
            <span class="s5"># These attributes (whose values come from backcompat) only matter</span>
            <span class="s5"># if someone modifies beginarrow/etc. on an ArrowStyle instance.</span>
            <span class="s1">super().__init__(head_length=</span><span class="s4">.2</span><span class="s2">, </span><span class="s1">head_width=</span><span class="s4">.1</span><span class="s1">)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&lt;-&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveA(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with a head at its start point.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;&lt;-&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;-&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with a head at its end point.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;-&gt;&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&lt;-&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveAB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with heads both at the start and the end point.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;&lt;-&gt;&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&lt;|-&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveFilledA(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with filled triangle head at the start.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;&lt;|-&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;-|&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveFilledB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with filled triangle head at the end.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;-|&gt;&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;&lt;|-|&gt;&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveFilledAB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with filled triangle heads at both ends.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;&lt;|-|&gt;&quot;</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;]-&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">BracketA(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with an outward square bracket at its start.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;]-&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widthA=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthA=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthA : float, default: 1.0 
                Width of the bracket. 
            lengthA : float, default: 0.2 
                Length of the bracket. 
            angleA : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthA=widthA</span><span class="s2">, </span><span class="s1">lengthA=lengthA</span><span class="s2">, </span><span class="s1">angleA=angleA)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;-[&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">BracketB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with an outward square bracket at its end.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;-[&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widthB=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthB=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthB : float, default: 1.0 
                Width of the bracket. 
            lengthB : float, default: 0.2 
                Length of the bracket. 
            angleB : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthB=widthB</span><span class="s2">, </span><span class="s1">lengthB=lengthB</span><span class="s2">, </span><span class="s1">angleB=angleB)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;]-[&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">BracketAB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with outward square brackets at both ends.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;]-[&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                     <span class="s1">widthA=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthA=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">0</span><span class="s2">,</span>
                     <span class="s1">widthB=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthB=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthA, widthB : float, default: 1.0 
                Width of the bracket. 
            lengthA, lengthB : float, default: 0.2 
                Length of the bracket. 
            angleA, angleB : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthA=widthA</span><span class="s2">, </span><span class="s1">lengthA=lengthA</span><span class="s2">, </span><span class="s1">angleA=angleA</span><span class="s2">,</span>
                             <span class="s1">widthB=widthB</span><span class="s2">, </span><span class="s1">lengthB=lengthB</span><span class="s2">, </span><span class="s1">angleB=angleB)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;|-|&quot;</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">BarAB(_Curve):</span>
        <span class="s0">&quot;&quot;&quot;An arrow with vertical bars ``|`` at both ends.&quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;|-|&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widthA=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">widthB=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s4">0</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthA, widthB : float, default: 1.0 
                Width of the bracket. 
            angleA, angleB : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthA=widthA</span><span class="s2">, </span><span class="s1">lengthA=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">angleA=angleA</span><span class="s2">,</span>
                             <span class="s1">widthB=widthB</span><span class="s2">, </span><span class="s1">lengthB=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">angleB=angleB)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">']-&gt;'</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">BracketCurve(_Curve):</span>
        <span class="s0">&quot;&quot;&quot; 
        An arrow with an outward square bracket at its start and a head at 
        the end. 
        &quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;]-&gt;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widthA=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthA=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleA=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthA : float, default: 1.0 
                Width of the bracket. 
            lengthA : float, default: 0.2 
                Length of the bracket. 
            angleA : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthA=widthA</span><span class="s2">, </span><span class="s1">lengthA=lengthA</span><span class="s2">, </span><span class="s1">angleA=angleA)</span>

    <span class="s1">@_register_style(_style_list</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">'&lt;-['</span><span class="s1">)</span>
    <span class="s2">class </span><span class="s1">CurveBracket(_Curve):</span>
        <span class="s0">&quot;&quot;&quot; 
        An arrow with an outward square bracket at its end and a head at 
        the start. 
        &quot;&quot;&quot;</span>
        <span class="s1">arrow = </span><span class="s3">&quot;&lt;-[&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">widthB=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">lengthB=</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">angleB=</span><span class="s2">None</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            widthB : float, default: 1.0 
                Width of the bracket. 
            lengthB : float, default: 0.2 
                Length of the bracket. 
            angleB : float, default: 0 degrees 
                Orientation of the bracket, as a counterclockwise angle. 
                0 degrees means perpendicular to the line. 
            &quot;&quot;&quot;</span>
            <span class="s1">super().__init__(widthB=widthB</span><span class="s2">, </span><span class="s1">lengthB=lengthB</span><span class="s2">, </span><span class="s1">angleB=angleB)</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Simple(_Base):</span>
        <span class="s0">&quot;&quot;&quot;A simple arrow. Only works with a quadratic BÃ©zier curve.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">head_length=</span><span class="s4">.5</span><span class="s2">, </span><span class="s1">head_width=</span><span class="s4">.5</span><span class="s2">, </span><span class="s1">tail_width=</span><span class="s4">.2</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            head_length : float, default: 0.5 
                Length of the arrow head. 
 
            head_width : float, default: 0.5 
                Width of the arrow head. 
 
            tail_width : float, default: 0.2 
                Width of the arrow tail. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.head_length</span><span class="s2">, </span><span class="s1">self.head_width</span><span class="s2">, </span><span class="s1">self.tail_width = \</span>
                <span class="s1">head_length</span><span class="s2">, </span><span class="s1">head_width</span><span class="s2">, </span><span class="s1">tail_width</span>
            <span class="s1">super().__init__()</span>

        <span class="s2">def </span><span class="s1">transmute(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = self.ensure_quadratic_bezier(path)</span>

            <span class="s5"># divide the path into a head and a tail</span>
            <span class="s1">head_length = self.head_length * mutation_size</span>
            <span class="s1">in_f = inside_circle(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">head_length)</span>
            <span class="s1">arrow_path = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">arrow_out</span><span class="s2">, </span><span class="s1">arrow_in = \</span>
                    <span class="s1">split_bezier_intersecting_with_closedpath(arrow_path</span><span class="s2">, </span><span class="s1">in_f)</span>
            <span class="s2">except </span><span class="s1">NonIntersectingPathException:</span>
                <span class="s5"># if this happens, make a straight line of the head_length</span>
                <span class="s5"># long.</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = _point_along_a_line(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">head_length)</span>
                <span class="s1">x1n</span><span class="s2">, </span><span class="s1">y1n = </span><span class="s4">0.5 </span><span class="s1">* (x0 + x2)</span><span class="s2">, </span><span class="s4">0.5 </span><span class="s1">* (y0 + y2)</span>
                <span class="s1">arrow_in = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1n</span><span class="s2">, </span><span class="s1">y1n)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>
                <span class="s1">arrow_out = </span><span class="s2">None</span>

            <span class="s5"># head</span>
            <span class="s1">head_width = self.head_width * mutation_size</span>
            <span class="s1">head_left</span><span class="s2">, </span><span class="s1">head_right = make_wedged_bezier2(arrow_in</span><span class="s2">,</span>
                                                        <span class="s1">head_width / </span><span class="s4">2.</span><span class="s2">, </span><span class="s1">wm=</span><span class="s4">.5</span><span class="s1">)</span>

            <span class="s5"># tail</span>
            <span class="s2">if </span><span class="s1">arrow_out </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">tail_width = self.tail_width * mutation_size</span>
                <span class="s1">tail_left</span><span class="s2">, </span><span class="s1">tail_right = get_parallels(arrow_out</span><span class="s2">,</span>
                                                      <span class="s1">tail_width / </span><span class="s4">2.</span><span class="s1">)</span>

                <span class="s1">patch_path = [(Path.MOVETO</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CLOSEPOLY</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">patch_path = [(Path.MOVETO</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">(Path.CLOSEPOLY</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                              <span class="s1">]</span>

            <span class="s1">path = Path([p </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path]</span><span class="s2">, </span><span class="s1">[c </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path])</span>

            <span class="s2">return </span><span class="s1">path</span><span class="s2">, True</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Fancy(_Base):</span>
        <span class="s0">&quot;&quot;&quot;A fancy arrow. Only works with a quadratic BÃ©zier curve.&quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">head_length=</span><span class="s4">.4</span><span class="s2">, </span><span class="s1">head_width=</span><span class="s4">.4</span><span class="s2">, </span><span class="s1">tail_width=</span><span class="s4">.4</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            head_length : float, default: 0.4 
                Length of the arrow head. 
 
            head_width : float, default: 0.4 
                Width of the arrow head. 
 
            tail_width : float, default: 0.4 
                Width of the arrow tail. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.head_length</span><span class="s2">, </span><span class="s1">self.head_width</span><span class="s2">, </span><span class="s1">self.tail_width = \</span>
                <span class="s1">head_length</span><span class="s2">, </span><span class="s1">head_width</span><span class="s2">, </span><span class="s1">tail_width</span>
            <span class="s1">super().__init__()</span>

        <span class="s2">def </span><span class="s1">transmute(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = self.ensure_quadratic_bezier(path)</span>

            <span class="s5"># divide the path into a head and a tail</span>
            <span class="s1">head_length = self.head_length * mutation_size</span>
            <span class="s1">arrow_path = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>

            <span class="s5"># path for head</span>
            <span class="s1">in_f = inside_circle(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">head_length)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">path_out</span><span class="s2">, </span><span class="s1">path_in = split_bezier_intersecting_with_closedpath(</span>
                    <span class="s1">arrow_path</span><span class="s2">, </span><span class="s1">in_f)</span>
            <span class="s2">except </span><span class="s1">NonIntersectingPathException:</span>
                <span class="s5"># if this happens, make a straight line of the head_length</span>
                <span class="s5"># long.</span>
                <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = _point_along_a_line(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">head_length)</span>
                <span class="s1">x1n</span><span class="s2">, </span><span class="s1">y1n = </span><span class="s4">0.5 </span><span class="s1">* (x0 + x2)</span><span class="s2">, </span><span class="s4">0.5 </span><span class="s1">* (y0 + y2)</span>
                <span class="s1">arrow_path = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1n</span><span class="s2">, </span><span class="s1">y1n)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>
                <span class="s1">path_head = arrow_path</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">path_head = path_in</span>

            <span class="s5"># path for head</span>
            <span class="s1">in_f = inside_circle(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">head_length * </span><span class="s4">.8</span><span class="s1">)</span>
            <span class="s1">path_out</span><span class="s2">, </span><span class="s1">path_in = split_bezier_intersecting_with_closedpath(</span>
                <span class="s1">arrow_path</span><span class="s2">, </span><span class="s1">in_f)</span>
            <span class="s1">path_tail = path_out</span>

            <span class="s5"># head</span>
            <span class="s1">head_width = self.head_width * mutation_size</span>
            <span class="s1">head_l</span><span class="s2">, </span><span class="s1">head_r = make_wedged_bezier2(path_head</span><span class="s2">,</span>
                                                 <span class="s1">head_width / </span><span class="s4">2.</span><span class="s2">,</span>
                                                 <span class="s1">wm=</span><span class="s4">.6</span><span class="s1">)</span>

            <span class="s5"># tail</span>
            <span class="s1">tail_width = self.tail_width * mutation_size</span>
            <span class="s1">tail_left</span><span class="s2">, </span><span class="s1">tail_right = make_wedged_bezier2(path_tail</span><span class="s2">,</span>
                                                        <span class="s1">tail_width * </span><span class="s4">.5</span><span class="s2">,</span>
                                                        <span class="s1">w1=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">wm=</span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">w2=</span><span class="s4">0.3</span><span class="s1">)</span>

            <span class="s5"># path for head</span>
            <span class="s1">in_f = inside_circle(x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">tail_width * </span><span class="s4">.3</span><span class="s1">)</span>
            <span class="s1">path_in</span><span class="s2">, </span><span class="s1">path_out = split_bezier_intersecting_with_closedpath(</span>
                <span class="s1">arrow_path</span><span class="s2">, </span><span class="s1">in_f)</span>
            <span class="s1">tail_start = path_in[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s1">head_right</span><span class="s2">, </span><span class="s1">head_left = head_r</span><span class="s2">, </span><span class="s1">head_l</span>
            <span class="s1">patch_path = [(Path.MOVETO</span><span class="s2">, </span><span class="s1">tail_start)</span><span class="s2">,</span>
                          <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_right[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_right[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">head_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">tail_left[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">tail_start)</span><span class="s2">,</span>
                          <span class="s1">(Path.CLOSEPOLY</span><span class="s2">, </span><span class="s1">tail_start)</span><span class="s2">,</span>
                          <span class="s1">]</span>
            <span class="s1">path = Path([p </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path]</span><span class="s2">, </span><span class="s1">[c </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path])</span>

            <span class="s2">return </span><span class="s1">path</span><span class="s2">, True</span>

    <span class="s1">@_register_style(_style_list)</span>
    <span class="s2">class </span><span class="s1">Wedge(_Base):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wedge(?) shape. Only works with a quadratic BÃ©zier curve.  The 
        start point has a width of the *tail_width* and the end point has a 
        width of 0. At the middle, the width is *shrink_factor*x*tail_width*. 
        &quot;&quot;&quot;</span>

        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">tail_width=</span><span class="s4">.3</span><span class="s2">, </span><span class="s1">shrink_factor=</span><span class="s4">0.5</span><span class="s1">):</span>
            <span class="s0">&quot;&quot;&quot; 
            Parameters 
            ---------- 
            tail_width : float, default: 0.3 
                Width of the tail. 
 
            shrink_factor : float, default: 0.5 
                Fraction of the arrow width at the middle point. 
            &quot;&quot;&quot;</span>
            <span class="s1">self.tail_width = tail_width</span>
            <span class="s1">self.shrink_factor = shrink_factor</span>
            <span class="s1">super().__init__()</span>

        <span class="s2">def </span><span class="s1">transmute(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">mutation_size</span><span class="s2">, </span><span class="s1">linewidth):</span>
            <span class="s5"># docstring inherited</span>
            <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">x2</span><span class="s2">, </span><span class="s1">y2 = self.ensure_quadratic_bezier(path)</span>

            <span class="s1">arrow_path = [(x0</span><span class="s2">, </span><span class="s1">y0)</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2)]</span>
            <span class="s1">b_plus</span><span class="s2">, </span><span class="s1">b_minus = make_wedged_bezier2(</span>
                                    <span class="s1">arrow_path</span><span class="s2">,</span>
                                    <span class="s1">self.tail_width * mutation_size / </span><span class="s4">2.</span><span class="s2">,</span>
                                    <span class="s1">wm=self.shrink_factor)</span>

            <span class="s1">patch_path = [(Path.MOVETO</span><span class="s2">, </span><span class="s1">b_plus[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">b_plus[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">b_plus[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.LINETO</span><span class="s2">, </span><span class="s1">b_minus[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">b_minus[</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CURVE3</span><span class="s2">, </span><span class="s1">b_minus[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">(Path.CLOSEPOLY</span><span class="s2">, </span><span class="s1">b_minus[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">]</span>
            <span class="s1">path = Path([p </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path]</span><span class="s2">, </span><span class="s1">[c </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">patch_path])</span>

            <span class="s2">return </span><span class="s1">path</span><span class="s2">, True</span>


<span class="s2">class </span><span class="s1">FancyBboxPatch(Patch):</span>
    <span class="s0">&quot;&quot;&quot; 
    A fancy box around a rectangle with lower left at *xy* = (*x*, *y*) 
    with specified width and height. 
 
    `.FancyBboxPatch` is similar to `.Rectangle`, but it draws a fancy box 
    around the rectangle. The transformation of the rectangle box to the 
    fancy box is delegated to the style classes defined in `.BoxStyle`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">s = self.__class__.__name__ + </span><span class="s3">&quot;((%g, %g), width=%g, height=%g)&quot;</span>
        <span class="s2">return </span><span class="s1">s % (self._x</span><span class="s2">, </span><span class="s1">self._y</span><span class="s2">, </span><span class="s1">self._width</span><span class="s2">, </span><span class="s1">self._height)</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">boxstyle=</span><span class="s3">&quot;round&quot;</span><span class="s2">, </span><span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">mutation_scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mutation_aspect=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        xy : float, float 
          The lower left corner of the box. 
 
        width : float 
            The width of the box. 
 
        height : float 
            The height of the box. 
 
        boxstyle : str or `matplotlib.patches.BoxStyle` 
            The style of the fancy box. This can either be a `.BoxStyle` 
            instance or a string of the style name and optionally comma 
            separated attributes (e.g. &quot;Round, pad=0.2&quot;). This string is 
            passed to `.BoxStyle` to construct a `.BoxStyle` object. See 
            there for a full documentation. 
 
            The following box styles are available: 
 
            %(BoxStyle:table)s 
 
        mutation_scale : float, default: 1 
            Scaling factor applied to the attributes of the box style 
            (e.g. pad or rounding_size). 
 
        mutation_aspect : float, default: 1 
            The height of the rectangle will be squeezed by this value before 
            the mutation and the mutated box will be stretched by the inverse 
            of it. For example, this allows different horizontal and vertical 
            padding. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Patch` properties 
 
        %(Patch:kwdoc)s 
        &quot;&quot;&quot;</span>

        <span class="s1">super().__init__(**kwargs)</span>
        <span class="s1">self._x</span><span class="s2">, </span><span class="s1">self._y = xy</span>
        <span class="s1">self._width = width</span>
        <span class="s1">self._height = height</span>
        <span class="s1">self.set_boxstyle(boxstyle)</span>
        <span class="s1">self._mutation_scale = mutation_scale</span>
        <span class="s1">self._mutation_aspect = mutation_aspect</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">set_boxstyle(self</span><span class="s2">, </span><span class="s1">boxstyle=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the box style, possibly with further attributes. 
 
        Attributes from the previous box style are not reused. 
 
        Without argument (or with ``boxstyle=None``), the available box styles 
        are returned as a human-readable string. 
 
        Parameters 
        ---------- 
        boxstyle : str or `matplotlib.patches.BoxStyle` 
            The style of the box: either a `.BoxStyle` instance, or a string, 
            which is the style name and optionally comma separated attributes 
            (e.g. &quot;Round,pad=0.2&quot;). Such a string is used to construct a 
            `.BoxStyle` object, as documented in that class. 
 
            The following box styles are available: 
 
            %(BoxStyle:table_and_accepts)s 
 
        **kwargs 
            Additional attributes for the box style. See the table above for 
            supported parameters. 
 
        Examples 
        -------- 
        :: 
 
            set_boxstyle(&quot;Round,pad=0.2&quot;) 
            set_boxstyle(&quot;round&quot;, pad=0.2) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">boxstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">BoxStyle.pprint_styles()</span>
        <span class="s1">self._bbox_transmuter = (</span>
            <span class="s1">BoxStyle(boxstyle</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">isinstance(boxstyle</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s1">boxstyle)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_boxstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the boxstyle object.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._bbox_transmuter</span>

    <span class="s2">def </span><span class="s1">set_mutation_scale(self</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the mutation scale. 
 
        Parameters 
        ---------- 
        scale : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mutation_scale = scale</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_mutation_scale(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the mutation scale.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._mutation_scale</span>

    <span class="s2">def </span><span class="s1">set_mutation_aspect(self</span><span class="s2">, </span><span class="s1">aspect):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the aspect ratio of the bbox mutation. 
 
        Parameters 
        ---------- 
        aspect : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mutation_aspect = aspect</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_mutation_aspect(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the aspect ratio of the bbox mutation.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self._mutation_aspect </span><span class="s2">if </span><span class="s1">self._mutation_aspect </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># backcompat.</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the mutated path of the rectangle.&quot;&quot;&quot;</span>
        <span class="s1">boxstyle = self.get_boxstyle()</span>
        <span class="s1">m_aspect = self.get_mutation_aspect()</span>
        <span class="s5"># Call boxstyle with y, height squeezed by aspect_ratio.</span>
        <span class="s1">path = boxstyle(self._x</span><span class="s2">, </span><span class="s1">self._y / m_aspect</span><span class="s2">,</span>
                        <span class="s1">self._width</span><span class="s2">, </span><span class="s1">self._height / m_aspect</span><span class="s2">,</span>
                        <span class="s1">self.get_mutation_scale())</span>
        <span class="s2">return </span><span class="s1">Path(path.vertices * [</span><span class="s4">1</span><span class="s2">, </span><span class="s1">m_aspect]</span><span class="s2">, </span><span class="s1">path.codes)  </span><span class="s5"># Unsqueeze y.</span>

    <span class="s5"># Following methods are borrowed from the Rectangle class.</span>

    <span class="s2">def </span><span class="s1">get_x(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the left coord of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._x</span>

    <span class="s2">def </span><span class="s1">get_y(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the bottom coord of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._y</span>

    <span class="s2">def </span><span class="s1">get_width(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the width of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._width</span>

    <span class="s2">def </span><span class="s1">get_height(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the height of the rectangle.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._height</span>

    <span class="s2">def </span><span class="s1">set_x(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the left coord of the rectangle. 
 
        Parameters 
        ---------- 
        x : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._x = x</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_y(self</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the bottom coord of the rectangle. 
 
        Parameters 
        ---------- 
        y : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._y = y</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_width(self</span><span class="s2">, </span><span class="s1">w):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the rectangle width. 
 
        Parameters 
        ---------- 
        w : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._width = w</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_height(self</span><span class="s2">, </span><span class="s1">h):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the rectangle height. 
 
        Parameters 
        ---------- 
        h : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._height = h</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_bounds(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the bounds of the rectangle. 
 
        Call signatures:: 
 
            set_bounds(left, bottom, width, height) 
            set_bounds((left, bottom, width, height)) 
 
        Parameters 
        ---------- 
        left, bottom : float 
            The coordinates of the bottom left corner of the rectangle. 
        width, height : float 
            The width/height of the rectangle. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">len(args) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h = args[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">l</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">h = args</span>
        <span class="s1">self._x = l</span>
        <span class="s1">self._y = b</span>
        <span class="s1">self._width = w</span>
        <span class="s1">self._height = h</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_bbox(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.Bbox`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">transforms.Bbox.from_bounds(self._x</span><span class="s2">, </span><span class="s1">self._y</span><span class="s2">,</span>
                                           <span class="s1">self._width</span><span class="s2">, </span><span class="s1">self._height)</span>


<span class="s2">class </span><span class="s1">FancyArrowPatch(Patch):</span>
    <span class="s0">&quot;&quot;&quot; 
    A fancy arrow patch. It draws an arrow using the `ArrowStyle`. 
 
    The head and tail positions are fixed at the specified start and end points 
    of the arrow, but the size and shape (in display coordinates) of the arrow 
    does not change when the axis is moved or zoomed. 
    &quot;&quot;&quot;</span>
    <span class="s1">_edge_default = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self._posA_posB </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">(x1</span><span class="s2">, </span><span class="s1">y1)</span><span class="s2">, </span><span class="s1">(x2</span><span class="s2">, </span><span class="s1">y2) = self._posA_posB</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s3">((</span><span class="s2">{</span><span class="s1">x1</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">y1</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">)-&gt;(</span><span class="s2">{</span><span class="s1">x2</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">, </span><span class="s2">{</span><span class="s1">y2</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">))&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">}</span><span class="s3">(</span><span class="s2">{</span><span class="s1">self._path_original</span><span class="s2">}</span><span class="s3">)&quot;</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;path&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">posA=</span><span class="s2">None, </span><span class="s1">posB=</span><span class="s2">None, </span><span class="s1">path=</span><span class="s2">None,</span>
                 <span class="s1">arrowstyle=</span><span class="s3">&quot;simple&quot;</span><span class="s2">, </span><span class="s1">connectionstyle=</span><span class="s3">&quot;arc3&quot;</span><span class="s2">,</span>
                 <span class="s1">patchA=</span><span class="s2">None, </span><span class="s1">patchB=</span><span class="s2">None,</span>
                 <span class="s1">shrinkA=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">shrinkB=</span><span class="s4">2</span><span class="s2">,</span>
                 <span class="s1">mutation_scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mutation_aspect=</span><span class="s4">1</span><span class="s2">,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        There are two ways for defining an arrow: 
 
        - If *posA* and *posB* are given, a path connecting two points is 
          created according to *connectionstyle*. The path will be 
          clipped with *patchA* and *patchB* and further shrunken by 
          *shrinkA* and *shrinkB*. An arrow is drawn along this 
          resulting path using the *arrowstyle* parameter. 
 
        - Alternatively if *path* is provided, an arrow is drawn along this 
          path and *patchA*, *patchB*, *shrinkA*, and *shrinkB* are ignored. 
 
        Parameters 
        ---------- 
        posA, posB : (float, float), default: None 
            (x, y) coordinates of arrow tail and arrow head respectively. 
 
        path : `~matplotlib.path.Path`, default: None 
            If provided, an arrow is drawn along this path and *patchA*, 
            *patchB*, *shrinkA*, and *shrinkB* are ignored. 
 
        arrowstyle : str or `.ArrowStyle`, default: 'simple' 
            The `.ArrowStyle` with which the fancy arrow is drawn.  If a 
            string, it should be one of the available arrowstyle names, with 
            optional comma-separated attributes.  The optional attributes are 
            meant to be scaled with the *mutation_scale*.  The following arrow 
            styles are available: 
 
            %(ArrowStyle:table)s 
 
        connectionstyle : str or `.ConnectionStyle` or None, optional, \ 
default: 'arc3' 
            The `.ConnectionStyle` with which *posA* and *posB* are connected. 
            If a string, it should be one of the available connectionstyle 
            names, with optional comma-separated attributes.  The following 
            connection styles are available: 
 
            %(ConnectionStyle:table)s 
 
        patchA, patchB : `.Patch`, default: None 
            Head and tail patches, respectively. 
 
        shrinkA, shrinkB : float, default: 2 
            Shrinking factor of the tail and head of the arrow respectively. 
 
        mutation_scale : float, default: 1 
            Value with which attributes of *arrowstyle* (e.g., *head_length*) 
            will be scaled. 
 
        mutation_aspect : None or float, default: None 
            The height of the rectangle will be squeezed by this value before 
            the mutation and the mutated box will be stretched by the inverse 
            of it. 
 
        Other Parameters 
        ---------------- 
        **kwargs : `.Patch` properties, optional 
            Here is a list of available `.Patch` properties: 
 
        %(Patch:kwdoc)s 
 
            In contrast to other patches, the default ``capstyle`` and 
            ``joinstyle`` for `FancyArrowPatch` are set to ``&quot;round&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s5"># Traditionally, the cap- and joinstyle for FancyArrowPatch are round</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">&quot;joinstyle&quot;</span><span class="s2">, </span><span class="s1">JoinStyle.round)</span>
        <span class="s1">kwargs.setdefault(</span><span class="s3">&quot;capstyle&quot;</span><span class="s2">, </span><span class="s1">CapStyle.round)</span>

        <span class="s1">super().__init__(**kwargs)</span>

        <span class="s2">if </span><span class="s1">posA </span><span class="s2">is not None and </span><span class="s1">posB </span><span class="s2">is not None and </span><span class="s1">path </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._posA_posB = [posA</span><span class="s2">, </span><span class="s1">posB]</span>

            <span class="s2">if </span><span class="s1">connectionstyle </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">connectionstyle = </span><span class="s3">&quot;arc3&quot;</span>
            <span class="s1">self.set_connectionstyle(connectionstyle)</span>

        <span class="s2">elif </span><span class="s1">posA </span><span class="s2">is None and </span><span class="s1">posB </span><span class="s2">is None and </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._posA_posB = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Either posA and posB, or path need to provided&quot;</span><span class="s1">)</span>

        <span class="s1">self.patchA = patchA</span>
        <span class="s1">self.patchB = patchB</span>
        <span class="s1">self.shrinkA = shrinkA</span>
        <span class="s1">self.shrinkB = shrinkB</span>

        <span class="s1">self._path_original = path</span>

        <span class="s1">self.set_arrowstyle(arrowstyle)</span>

        <span class="s1">self._mutation_scale = mutation_scale</span>
        <span class="s1">self._mutation_aspect = mutation_aspect</span>

        <span class="s1">self._dpi_cor = </span><span class="s4">1.0</span>

    <span class="s2">def </span><span class="s1">set_positions(self</span><span class="s2">, </span><span class="s1">posA</span><span class="s2">, </span><span class="s1">posB):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the start and end positions of the connecting path. 
 
        Parameters 
        ---------- 
        posA, posB : None, tuple 
            (x, y) coordinates of arrow tail and arrow head respectively. If 
            `None` use current value. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">posA </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._posA_posB[</span><span class="s4">0</span><span class="s1">] = posA</span>
        <span class="s2">if </span><span class="s1">posB </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._posA_posB[</span><span class="s4">1</span><span class="s1">] = posB</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_patchA(self</span><span class="s2">, </span><span class="s1">patchA):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the tail patch. 
 
        Parameters 
        ---------- 
        patchA : `.patches.Patch` 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patchA = patchA</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_patchB(self</span><span class="s2">, </span><span class="s1">patchB):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the head patch. 
 
        Parameters 
        ---------- 
        patchB : `.patches.Patch` 
        &quot;&quot;&quot;</span>
        <span class="s1">self.patchB = patchB</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s2">def </span><span class="s1">set_connectionstyle(self</span><span class="s2">, </span><span class="s1">connectionstyle=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the connection style, possibly with further attributes. 
 
        Attributes from the previous connection style are not reused. 
 
        Without argument (or with ``connectionstyle=None``), the available box 
        styles are returned as a human-readable string. 
 
        Parameters 
        ---------- 
        connectionstyle : str or `matplotlib.patches.ConnectionStyle` 
            The style of the connection: either a `.ConnectionStyle` instance, 
            or a string, which is the style name and optionally comma separated 
            attributes (e.g. &quot;Arc,armA=30,rad=10&quot;). Such a string is used to 
            construct a `.ConnectionStyle` object, as documented in that class. 
 
            The following connection styles are available: 
 
            %(ConnectionStyle:table_and_accepts)s 
 
        **kwargs 
            Additional attributes for the connection style. See the table above 
            for supported parameters. 
 
        Examples 
        -------- 
        :: 
 
            set_connectionstyle(&quot;Arc,armA=30,rad=10&quot;) 
            set_connectionstyle(&quot;arc&quot;, armA=30, rad=10) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">connectionstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ConnectionStyle.pprint_styles()</span>
        <span class="s1">self._connector = (</span>
            <span class="s1">ConnectionStyle(connectionstyle</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">isinstance(connectionstyle</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s1">connectionstyle)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_connectionstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `ConnectionStyle` used.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._connector</span>

    <span class="s2">def </span><span class="s1">set_arrowstyle(self</span><span class="s2">, </span><span class="s1">arrowstyle=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the arrow style, possibly with further attributes. 
 
        Attributes from the previous arrow style are not reused. 
 
        Without argument (or with ``arrowstyle=None``), the available box 
        styles are returned as a human-readable string. 
 
        Parameters 
        ---------- 
        arrowstyle : str or `matplotlib.patches.ArrowStyle` 
            The style of the arrow: either a `.ArrowStyle` instance, or a 
            string, which is the style name and optionally comma separated 
            attributes (e.g. &quot;Fancy,head_length=0.2&quot;). Such a string is used to 
            construct a `.ArrowStyle` object, as documented in that class. 
 
            The following arrow styles are available: 
 
            %(ArrowStyle:table_and_accepts)s 
 
        **kwargs 
            Additional attributes for the arrow style. See the table above for 
            supported parameters. 
 
        Examples 
        -------- 
        :: 
 
            set_arrowstyle(&quot;Fancy,head_length=0.2&quot;) 
            set_arrowstyle(&quot;fancy&quot;, head_length=0.2) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">arrowstyle </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">ArrowStyle.pprint_styles()</span>
        <span class="s1">self._arrow_transmuter = (</span>
            <span class="s1">ArrowStyle(arrowstyle</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">isinstance(arrowstyle</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">else </span><span class="s1">arrowstyle)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_arrowstyle(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the arrowstyle object.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._arrow_transmuter</span>

    <span class="s2">def </span><span class="s1">set_mutation_scale(self</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the mutation scale. 
 
        Parameters 
        ---------- 
        scale : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mutation_scale = scale</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_mutation_scale(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the mutation scale. 
 
        Returns 
        ------- 
        scalar 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._mutation_scale</span>

    <span class="s2">def </span><span class="s1">set_mutation_aspect(self</span><span class="s2">, </span><span class="s1">aspect):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the aspect ratio of the bbox mutation. 
 
        Parameters 
        ---------- 
        aspect : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._mutation_aspect = aspect</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_mutation_aspect(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the aspect ratio of the bbox mutation.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self._mutation_aspect </span><span class="s2">if </span><span class="s1">self._mutation_aspect </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s4">1</span><span class="s1">)  </span><span class="s5"># backcompat.</span>

    <span class="s2">def </span><span class="s1">get_path(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the path of the arrow in the data coordinates.&quot;&quot;&quot;</span>
        <span class="s5"># The path is generated in display coordinates, then converted back to</span>
        <span class="s5"># data coordinates.</span>
        <span class="s1">_path</span><span class="s2">, </span><span class="s1">fillable = self._get_path_in_displaycoord()</span>
        <span class="s2">if </span><span class="s1">np.iterable(fillable):</span>
            <span class="s1">_path = Path.make_compound_path(*_path)</span>
        <span class="s2">return </span><span class="s1">self.get_transform().inverted().transform_path(_path)</span>

    <span class="s2">def </span><span class="s1">_get_path_in_displaycoord(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the mutated path of the arrow in display coordinates.&quot;&quot;&quot;</span>
        <span class="s1">dpi_cor = self._dpi_cor</span>

        <span class="s2">if </span><span class="s1">self._posA_posB </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">posA = self._convert_xy_units(self._posA_posB[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">posB = self._convert_xy_units(self._posA_posB[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">(posA</span><span class="s2">, </span><span class="s1">posB) = self.get_transform().transform((posA</span><span class="s2">, </span><span class="s1">posB))</span>
            <span class="s1">_path = self.get_connectionstyle()(posA</span><span class="s2">, </span><span class="s1">posB</span><span class="s2">,</span>
                                               <span class="s1">patchA=self.patchA</span><span class="s2">,</span>
                                               <span class="s1">patchB=self.patchB</span><span class="s2">,</span>
                                               <span class="s1">shrinkA=self.shrinkA * dpi_cor</span><span class="s2">,</span>
                                               <span class="s1">shrinkB=self.shrinkB * dpi_cor</span>
                                               <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_path = self.get_transform().transform_path(self._path_original)</span>

        <span class="s1">_path</span><span class="s2">, </span><span class="s1">fillable = self.get_arrowstyle()(</span>
            <span class="s1">_path</span><span class="s2">,</span>
            <span class="s1">self.get_mutation_scale() * dpi_cor</span><span class="s2">,</span>
            <span class="s1">self.get_linewidth() * dpi_cor</span><span class="s2">,</span>
            <span class="s1">self.get_mutation_aspect())</span>

        <span class="s2">return </span><span class="s1">_path</span><span class="s2">, </span><span class="s1">fillable</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>

        <span class="s5"># FIXME: dpi_cor is for the dpi-dependency of the linewidth.  There</span>
        <span class="s5"># could be room for improvement.  Maybe _get_path_in_displaycoord could</span>
        <span class="s5"># take a renderer argument, but get_path should be adapted too.</span>
        <span class="s1">self._dpi_cor = renderer.points_to_pixels(</span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">fillable = self._get_path_in_displaycoord()</span>

        <span class="s2">if not </span><span class="s1">np.iterable(fillable):</span>
            <span class="s1">path = [path]</span>
            <span class="s1">fillable = [fillable]</span>

        <span class="s1">affine = transforms.IdentityTransform()</span>

        <span class="s1">self._draw_paths_with_artist_properties(</span>
            <span class="s1">renderer</span><span class="s2">,</span>
            <span class="s1">[(p</span><span class="s2">, </span><span class="s1">affine</span><span class="s2">, </span><span class="s1">self._facecolor </span><span class="s2">if </span><span class="s1">f </span><span class="s2">and </span><span class="s1">self._facecolor[</span><span class="s4">3</span><span class="s1">] </span><span class="s2">else None</span><span class="s1">)</span>
             <span class="s2">for </span><span class="s1">p</span><span class="s2">, </span><span class="s1">f </span><span class="s2">in </span><span class="s1">zip(path</span><span class="s2">, </span><span class="s1">fillable)])</span>


<span class="s2">class </span><span class="s1">ConnectionPatch(FancyArrowPatch):</span>
    <span class="s0">&quot;&quot;&quot;A patch that connects two points (possibly in different axes).&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;ConnectionPatch((%g, %g), (%g, %g))&quot; </span><span class="s1">% \</span>
               <span class="s1">(self.xy1[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy1[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy2[</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">@_docstring.dedent_interpd</span>
    <span class="s1">@_api.make_keyword_only(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;axesA&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xyA</span><span class="s2">, </span><span class="s1">xyB</span><span class="s2">, </span><span class="s1">coordsA</span><span class="s2">, </span><span class="s1">coordsB=</span><span class="s2">None,</span>
                 <span class="s1">axesA=</span><span class="s2">None, </span><span class="s1">axesB=</span><span class="s2">None,</span>
                 <span class="s1">arrowstyle=</span><span class="s3">&quot;-&quot;</span><span class="s2">,</span>
                 <span class="s1">connectionstyle=</span><span class="s3">&quot;arc3&quot;</span><span class="s2">,</span>
                 <span class="s1">patchA=</span><span class="s2">None,</span>
                 <span class="s1">patchB=</span><span class="s2">None,</span>
                 <span class="s1">shrinkA=</span><span class="s4">0.</span><span class="s2">,</span>
                 <span class="s1">shrinkB=</span><span class="s4">0.</span><span class="s2">,</span>
                 <span class="s1">mutation_scale=</span><span class="s4">10.</span><span class="s2">,</span>
                 <span class="s1">mutation_aspect=</span><span class="s2">None,</span>
                 <span class="s1">clip_on=</span><span class="s2">False,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Connect point *xyA* in *coordsA* with point *xyB* in *coordsB*. 
 
        Valid keys are 
 
        ===============  ====================================================== 
        Key              Description 
        ===============  ====================================================== 
        arrowstyle       the arrow style 
        connectionstyle  the connection style 
        relpos           default is (0.5, 0.5) 
        patchA           default is bounding box of the text 
        patchB           default is None 
        shrinkA          default is 2 points 
        shrinkB          default is 2 points 
        mutation_scale   default is text size (in points) 
        mutation_aspect  default is 1. 
        ?                any key for `matplotlib.patches.PathPatch` 
        ===============  ====================================================== 
 
        *coordsA* and *coordsB* are strings that indicate the 
        coordinates of *xyA* and *xyB*. 
 
        ==================== ================================================== 
        Property             Description 
        ==================== ================================================== 
        'figure points'      points from the lower left corner of the figure 
        'figure pixels'      pixels from the lower left corner of the figure 
        'figure fraction'    0, 0 is lower left of figure and 1, 1 is upper 
                             right 
        'subfigure points'   points from the lower left corner of the subfigure 
        'subfigure pixels'   pixels from the lower left corner of the subfigure 
        'subfigure fraction' fraction of the subfigure, 0, 0 is lower left. 
        'axes points'        points from lower left corner of axes 
        'axes pixels'        pixels from lower left corner of axes 
        'axes fraction'      0, 0 is lower left of axes and 1, 1 is upper right 
        'data'               use the coordinate system of the object being 
                             annotated (default) 
        'offset points'      offset (in points) from the *xy* value 
        'polar'              you can specify *theta*, *r* for the annotation, 
                             even in cartesian plots.  Note that if you are 
                             using a polar axes, you do not need to specify 
                             polar for the coordinate system since that is the 
                             native &quot;data&quot; coordinate system. 
        ==================== ================================================== 
 
        Alternatively they can be set to any valid 
        `~matplotlib.transforms.Transform`. 
 
        Note that 'subfigure pixels' and 'figure pixels' are the same 
        for the parent figure, so users who want code that is usable in 
        a subfigure can use 'subfigure pixels'. 
 
        .. note:: 
 
           Using `ConnectionPatch` across two `~.axes.Axes` instances 
           is not directly compatible with :doc:`constrained layout 
           &lt;/tutorials/intermediate/constrainedlayout_guide&gt;`. Add the artist 
           directly to the `.Figure` instead of adding it to a specific Axes, 
           or exclude it from the layout using ``con.set_in_layout(False)``. 
 
           .. code-block:: default 
 
              fig, ax = plt.subplots(1, 2, constrained_layout=True) 
              con = ConnectionPatch(..., axesA=ax[0], axesB=ax[1]) 
              fig.add_artist(con) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">coordsB </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">coordsB = coordsA</span>
        <span class="s5"># we'll draw ourself after the artist we annotate by default</span>
        <span class="s1">self.xy1 = xyA</span>
        <span class="s1">self.xy2 = xyB</span>
        <span class="s1">self.coords1 = coordsA</span>
        <span class="s1">self.coords2 = coordsB</span>

        <span class="s1">self.axesA = axesA</span>
        <span class="s1">self.axesB = axesB</span>

        <span class="s1">super().__init__(posA=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">posB=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">arrowstyle=arrowstyle</span><span class="s2">,</span>
                         <span class="s1">connectionstyle=connectionstyle</span><span class="s2">,</span>
                         <span class="s1">patchA=patchA</span><span class="s2">, </span><span class="s1">patchB=patchB</span><span class="s2">,</span>
                         <span class="s1">shrinkA=shrinkA</span><span class="s2">, </span><span class="s1">shrinkB=shrinkB</span><span class="s2">,</span>
                         <span class="s1">mutation_scale=mutation_scale</span><span class="s2">,</span>
                         <span class="s1">mutation_aspect=mutation_aspect</span><span class="s2">,</span>
                         <span class="s1">clip_on=clip_on</span><span class="s2">,</span>
                         <span class="s1">**kwargs)</span>
        <span class="s5"># if True, draw annotation only if self.xy is inside the axes</span>
        <span class="s1">self._annotation_clip = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_get_xy(self</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">axes=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Calculate the pixel position of given point.&quot;&quot;&quot;</span>
        <span class="s1">s0 = s  </span><span class="s5"># For the error message, if needed.</span>
        <span class="s2">if </span><span class="s1">axes </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">axes = self.axes</span>
        <span class="s1">xy = np.array(xy)</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;figure points&quot;</span><span class="s2">, </span><span class="s3">&quot;axes points&quot;</span><span class="s1">]:</span>
            <span class="s1">xy *= self.figure.dpi / </span><span class="s4">72</span>
            <span class="s1">s = s.replace(</span><span class="s3">&quot;points&quot;</span><span class="s2">, </span><span class="s3">&quot;pixels&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">&quot;figure fraction&quot;</span><span class="s1">:</span>
            <span class="s1">s = self.figure.transFigure</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">&quot;subfigure fraction&quot;</span><span class="s1">:</span>
            <span class="s1">s = self.figure.transSubfigure</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">&quot;axes fraction&quot;</span><span class="s1">:</span>
            <span class="s1">s = axes.transAxes</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = xy</span>

        <span class="s2">if </span><span class="s1">s == </span><span class="s3">'data'</span><span class="s1">:</span>
            <span class="s1">trans = axes.transData</span>
            <span class="s1">x = float(self.convert_xunits(x))</span>
            <span class="s1">y = float(self.convert_yunits(y))</span>
            <span class="s2">return </span><span class="s1">trans.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">'offset points'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.xycoords == </span><span class="s3">'offset points'</span><span class="s1">:  </span><span class="s5"># prevent recursion</span>
                <span class="s2">return </span><span class="s1">self._get_xy(self.xy</span><span class="s2">, </span><span class="s3">'data'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">self._get_xy(self.xy</span><span class="s2">, </span><span class="s1">self.xycoords)  </span><span class="s5"># converted data point</span>
                <span class="s1">+ xy * self.figure.dpi / </span><span class="s4">72</span><span class="s1">)  </span><span class="s5"># converted offset</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">'polar'</span><span class="s1">:</span>
            <span class="s1">theta</span><span class="s2">, </span><span class="s1">r = x</span><span class="s2">, </span><span class="s1">y</span>
            <span class="s1">x = r * np.cos(theta)</span>
            <span class="s1">y = r * np.sin(theta)</span>
            <span class="s1">trans = axes.transData</span>
            <span class="s2">return </span><span class="s1">trans.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">'figure pixels'</span><span class="s1">:</span>
            <span class="s5"># pixels from the lower left corner of the figure</span>
            <span class="s1">bb = self.figure.figbbox</span>
            <span class="s1">x = bb.x0 + x </span><span class="s2">if </span><span class="s1">x &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.x1 + x</span>
            <span class="s1">y = bb.y0 + y </span><span class="s2">if </span><span class="s1">y &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.y1 + y</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">'subfigure pixels'</span><span class="s1">:</span>
            <span class="s5"># pixels from the lower left corner of the figure</span>
            <span class="s1">bb = self.figure.bbox</span>
            <span class="s1">x = bb.x0 + x </span><span class="s2">if </span><span class="s1">x &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.x1 + x</span>
            <span class="s1">y = bb.y0 + y </span><span class="s2">if </span><span class="s1">y &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.y1 + y</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s3">'axes pixels'</span><span class="s1">:</span>
            <span class="s5"># pixels from the lower left corner of the axes</span>
            <span class="s1">bb = axes.bbox</span>
            <span class="s1">x = bb.x0 + x </span><span class="s2">if </span><span class="s1">x &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.x1 + x</span>
            <span class="s1">y = bb.y0 + y </span><span class="s2">if </span><span class="s1">y &gt;= </span><span class="s4">0 </span><span class="s2">else </span><span class="s1">bb.y1 + y</span>
            <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">transforms.Transform):</span>
            <span class="s2">return </span><span class="s1">s.transform(xy)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">s0</span><span class="s2">} </span><span class="s3">is not a valid coordinate transformation&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_annotation_clip(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the annotation's clipping behavior. 
 
        Parameters 
        ---------- 
        b : bool or None 
            - True: The annotation will be clipped when ``self.xy`` is 
              outside the axes. 
            - False: The annotation will always be drawn. 
            - None: The annotation will be clipped when ``self.xy`` is 
              outside the axes and ``self.xycoords == &quot;data&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._annotation_clip = b</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_annotation_clip(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the clipping behavior. 
 
        See `.set_annotation_clip` for the meaning of the return value. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._annotation_clip</span>

    <span class="s2">def </span><span class="s1">_get_path_in_displaycoord(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the mutated path of the arrow in display coordinates.&quot;&quot;&quot;</span>
        <span class="s1">dpi_cor = self._dpi_cor</span>
        <span class="s1">posA = self._get_xy(self.xy1</span><span class="s2">, </span><span class="s1">self.coords1</span><span class="s2">, </span><span class="s1">self.axesA)</span>
        <span class="s1">posB = self._get_xy(self.xy2</span><span class="s2">, </span><span class="s1">self.coords2</span><span class="s2">, </span><span class="s1">self.axesB)</span>
        <span class="s1">path = self.get_connectionstyle()(</span>
            <span class="s1">posA</span><span class="s2">, </span><span class="s1">posB</span><span class="s2">,</span>
            <span class="s1">patchA=self.patchA</span><span class="s2">, </span><span class="s1">patchB=self.patchB</span><span class="s2">,</span>
            <span class="s1">shrinkA=self.shrinkA * dpi_cor</span><span class="s2">, </span><span class="s1">shrinkB=self.shrinkB * dpi_cor</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">fillable = self.get_arrowstyle()(</span>
            <span class="s1">path</span><span class="s2">,</span>
            <span class="s1">self.get_mutation_scale() * dpi_cor</span><span class="s2">,</span>
            <span class="s1">self.get_linewidth() * dpi_cor</span><span class="s2">,</span>
            <span class="s1">self.get_mutation_aspect()</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">path</span><span class="s2">, </span><span class="s1">fillable</span>

    <span class="s2">def </span><span class="s1">_check_xy(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Check whether the annotation needs to be drawn.&quot;&quot;&quot;</span>

        <span class="s1">b = self.get_annotation_clip()</span>

        <span class="s2">if </span><span class="s1">b </span><span class="s2">or </span><span class="s1">(b </span><span class="s2">is None and </span><span class="s1">self.coords1 == </span><span class="s3">&quot;data&quot;</span><span class="s1">):</span>
            <span class="s1">xy_pixel = self._get_xy(self.xy1</span><span class="s2">, </span><span class="s1">self.coords1</span><span class="s2">, </span><span class="s1">self.axesA)</span>
            <span class="s2">if </span><span class="s1">self.axesA </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">axes = self.axes</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">axes = self.axesA</span>
            <span class="s2">if not </span><span class="s1">axes.contains_point(xy_pixel):</span>
                <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">b </span><span class="s2">or </span><span class="s1">(b </span><span class="s2">is None and </span><span class="s1">self.coords2 == </span><span class="s3">&quot;data&quot;</span><span class="s1">):</span>
            <span class="s1">xy_pixel = self._get_xy(self.xy2</span><span class="s2">, </span><span class="s1">self.coords2</span><span class="s2">, </span><span class="s1">self.axesB)</span>
            <span class="s2">if </span><span class="s1">self.axesB </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">axes = self.axes</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">axes = self.axesB</span>
            <span class="s2">if not </span><span class="s1">axes.contains_point(xy_pixel):</span>
                <span class="s2">return False</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if not </span><span class="s1">self.get_visible() </span><span class="s2">or not </span><span class="s1">self._check_xy(renderer):</span>
            <span class="s2">return</span>
        <span class="s1">super().draw(renderer)</span>
</pre>
</body>
</html>