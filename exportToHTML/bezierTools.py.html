<html>
<head>
<title>bezierTools.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
bezierTools.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot;fontTools.misc.bezierTools.py -- tools for working with Bezier path segments. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">fontTools.misc.arrayTools </span><span class="s3">import </span><span class="s1">calcBounds</span><span class="s3">, </span><span class="s1">sectRect</span><span class="s3">, </span><span class="s1">rectArea</span>
<span class="s3">from </span><span class="s1">fontTools.misc.transform </span><span class="s3">import </span><span class="s1">Identity</span>
<span class="s3">import </span><span class="s1">math</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">namedtuple</span>

<span class="s1">Intersection = namedtuple(</span><span class="s4">&quot;Intersection&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;pt&quot;</span><span class="s3">, </span><span class="s4">&quot;t1&quot;</span><span class="s3">, </span><span class="s4">&quot;t2&quot;</span><span class="s1">])</span>


<span class="s1">__all__ = [</span>
    <span class="s4">&quot;approximateCubicArcLength&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;approximateCubicArcLengthC&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;approximateQuadraticArcLength&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;approximateQuadraticArcLengthC&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcCubicArcLength&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcCubicArcLengthC&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcQuadraticArcLength&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcQuadraticArcLengthC&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcCubicBounds&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;calcQuadraticBounds&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;splitLine&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;splitQuadratic&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;splitCubic&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;splitQuadraticAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;splitCubicAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;solveQuadratic&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;solveCubic&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;quadraticPointAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;cubicPointAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;linePointAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;segmentPointAtT&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;lineLineIntersections&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;curveLineIntersections&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;curveCurveIntersections&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;segmentSegmentIntersections&quot;</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s3">def </span><span class="s1">calcCubicArcLength(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4</span><span class="s3">, </span><span class="s1">tolerance=</span><span class="s5">0.005</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a cubic Bezier segment. 
 
    Whereas :func:`approximateCubicArcLength` approximates the length, this 
    function calculates it by &quot;measuring&quot;, recursively dividing the curve 
    until the divided segments are shorter than ``tolerance``. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        tolerance: Controls the precision of the calcuation. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">calcCubicArcLengthC(</span>
        <span class="s1">complex(*pt1)</span><span class="s3">, </span><span class="s1">complex(*pt2)</span><span class="s3">, </span><span class="s1">complex(*pt3)</span><span class="s3">, </span><span class="s1">complex(*pt4)</span><span class="s3">, </span><span class="s1">tolerance</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_split_cubic_into_two(p0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3):</span>
    <span class="s1">mid = (p0 + </span><span class="s5">3 </span><span class="s1">* (p1 + p2) + p3) * </span><span class="s5">0.125</span>
    <span class="s1">deriv3 = (p3 + p2 - p1 - p0) * </span><span class="s5">0.125</span>
    <span class="s3">return </span><span class="s1">(</span>
        <span class="s1">(p0</span><span class="s3">, </span><span class="s1">(p0 + p1) * </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">mid - deriv3</span><span class="s3">, </span><span class="s1">mid)</span><span class="s3">,</span>
        <span class="s1">(mid</span><span class="s3">, </span><span class="s1">mid + deriv3</span><span class="s3">, </span><span class="s1">(p2 + p3) * </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">p3)</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_calcCubicArcLengthCRecurse(mult</span><span class="s3">, </span><span class="s1">p0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3):</span>
    <span class="s1">arch = abs(p0 - p3)</span>
    <span class="s1">box = abs(p0 - p1) + abs(p1 - p2) + abs(p2 - p3)</span>
    <span class="s3">if </span><span class="s1">arch * mult &gt;= box:</span>
        <span class="s3">return </span><span class="s1">(arch + box) * </span><span class="s5">0.5</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">one</span><span class="s3">, </span><span class="s1">two = _split_cubic_into_two(p0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3)</span>
        <span class="s3">return </span><span class="s1">_calcCubicArcLengthCRecurse(mult</span><span class="s3">, </span><span class="s1">*one) + _calcCubicArcLengthCRecurse(</span>
            <span class="s1">mult</span><span class="s3">, </span><span class="s1">*two</span>
        <span class="s1">)</span>


<span class="s3">def </span><span class="s1">calcCubicArcLengthC(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4</span><span class="s3">, </span><span class="s1">tolerance=</span><span class="s5">0.005</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a cubic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers. 
        tolerance: Controls the precision of the calcuation. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s1">mult = </span><span class="s5">1.0 </span><span class="s1">+ </span><span class="s5">1.5 </span><span class="s1">* tolerance  </span><span class="s0"># The 1.5 is a empirical hack; no math</span>
    <span class="s3">return </span><span class="s1">_calcCubicArcLengthCRecurse(mult</span><span class="s3">, </span><span class="s1">pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4)</span>


<span class="s1">epsilonDigits = </span><span class="s5">6</span>
<span class="s1">epsilon = </span><span class="s5">1e-10</span>


<span class="s3">def </span><span class="s1">_dot(v1</span><span class="s3">, </span><span class="s1">v2):</span>
    <span class="s3">return </span><span class="s1">(v1 * v2.conjugate()).real</span>


<span class="s3">def </span><span class="s1">_intSecAtan(x):</span>
    <span class="s0"># In : sympy.integrate(sp.sec(sp.atan(x)))</span>
    <span class="s0"># Out: x*sqrt(x**2 + 1)/2 + asinh(x)/2</span>
    <span class="s3">return </span><span class="s1">x * math.sqrt(x ** </span><span class="s5">2 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2 </span><span class="s1">+ math.asinh(x) / </span><span class="s5">2</span>


<span class="s3">def </span><span class="s1">calcQuadraticArcLength(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as 2D tuple. 
        pt2: Handle point of the Bezier as 2D tuple. 
        pt3: End point of the Bezier as 2D tuple. 
 
    Returns: 
        Arc length value. 
 
    Example:: 
 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 0), (0, 0)) # empty segment 
        0.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, 0), (80, 0)) # collinear points 
        80.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 50), (0, 80)) # collinear points vertical 
        80.0 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, 20), (100, 40)) # collinear points 
        107.70329614269008 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 100), (100, 0)) 
        154.02976155645263 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (0, 50), (100, 0)) 
        120.21581243984076 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (50, -10), (80, 50)) 
        102.53273816445825 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (40, 0), (-40, 0)) # collinear points, control point outside 
        66.66666666666667 
        &gt;&gt;&gt; calcQuadraticArcLength((0, 0), (40, 0), (0, 0)) # collinear points, looping back 
        40.0 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">calcQuadraticArcLengthC(complex(*pt1)</span><span class="s3">, </span><span class="s1">complex(*pt2)</span><span class="s3">, </span><span class="s1">complex(*pt3))</span>


<span class="s3">def </span><span class="s1">calcQuadraticArcLengthC(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as a complex number. 
        pt2: Handle point of the Bezier as a complex number. 
        pt3: End point of the Bezier as a complex number. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Analytical solution to the length of a quadratic bezier.</span>
    <span class="s0"># I'll explain how I arrived at this later.</span>
    <span class="s1">d0 = pt2 - pt1</span>
    <span class="s1">d1 = pt3 - pt2</span>
    <span class="s1">d = d1 - d0</span>
    <span class="s1">n = d * </span><span class="s5">1j</span>
    <span class="s1">scale = abs(n)</span>
    <span class="s3">if </span><span class="s1">scale == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">abs(pt3 - pt1)</span>
    <span class="s1">origDist = _dot(n</span><span class="s3">, </span><span class="s1">d0)</span>
    <span class="s3">if </span><span class="s1">abs(origDist) &lt; epsilon:</span>
        <span class="s3">if </span><span class="s1">_dot(d0</span><span class="s3">, </span><span class="s1">d1) &gt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">abs(pt3 - pt1)</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b = abs(d0)</span><span class="s3">, </span><span class="s1">abs(d1)</span>
        <span class="s3">return </span><span class="s1">(a * a + b * b) / (a + b)</span>
    <span class="s1">x0 = _dot(d</span><span class="s3">, </span><span class="s1">d0) / origDist</span>
    <span class="s1">x1 = _dot(d</span><span class="s3">, </span><span class="s1">d1) / origDist</span>
    <span class="s1">Len = abs(</span><span class="s5">2 </span><span class="s1">* (_intSecAtan(x1) - _intSecAtan(x0)) * origDist / (scale * (x1 - x0)))</span>
    <span class="s3">return </span><span class="s1">Len</span>


<span class="s3">def </span><span class="s1">approximateQuadraticArcLength(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Uses Gauss-Legendre quadrature for a branch-free approximation. 
    See :func:`calcQuadraticArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1: Start point of the Bezier as 2D tuple. 
        pt2: Handle point of the Bezier as 2D tuple. 
        pt3: End point of the Bezier as 2D tuple. 
 
    Returns: 
        Approximate arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">approximateQuadraticArcLengthC(complex(*pt1)</span><span class="s3">, </span><span class="s1">complex(*pt2)</span><span class="s3">, </span><span class="s1">complex(*pt3))</span>


<span class="s3">def </span><span class="s1">approximateQuadraticArcLengthC(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the arc length for a quadratic Bezier segment. 
 
    Uses Gauss-Legendre quadrature for a branch-free approximation. 
    See :func:`calcQuadraticArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1: Start point of the Bezier as a complex number. 
        pt2: Handle point of the Bezier as a complex number. 
        pt3: End point of the Bezier as a complex number. 
 
    Returns: 
        Approximate arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This, essentially, approximates the length-of-derivative function</span>
    <span class="s0"># to be integrated with the best-matching fifth-degree polynomial</span>
    <span class="s0"># approximation of it.</span>
    <span class="s0">#</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Legendre_quadrature</span>

    <span class="s0"># abs(BezierCurveC[2].diff(t).subs({t:T})) for T in sorted(.5, .5±sqrt(3/5)/2),</span>
    <span class="s0"># weighted 5/18, 8/18, 5/18 respectively.</span>
    <span class="s1">v0 = abs(</span>
        <span class="s1">-</span><span class="s5">0.492943519233745 </span><span class="s1">* pt1 + </span><span class="s5">0.430331482911935 </span><span class="s1">* pt2 + </span><span class="s5">0.0626120363218102 </span><span class="s1">* pt3</span>
    <span class="s1">)</span>
    <span class="s1">v1 = abs(pt3 - pt1) * </span><span class="s5">0.4444444444444444</span>
    <span class="s1">v2 = abs(</span>
        <span class="s1">-</span><span class="s5">0.0626120363218102 </span><span class="s1">* pt1 - </span><span class="s5">0.430331482911935 </span><span class="s1">* pt2 + </span><span class="s5">0.492943519233745 </span><span class="s1">* pt3</span>
    <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">v0 + v1 + v2</span>


<span class="s3">def </span><span class="s1">calcQuadraticBounds(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the bounding rectangle for a quadratic Bezier segment. 
 
    Args: 
        pt1: Start point of the Bezier as a 2D tuple. 
        pt2: Handle point of the Bezier as a 2D tuple. 
        pt3: End point of the Bezier as a 2D tuple. 
 
    Returns: 
        A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``. 
 
    Example:: 
 
        &gt;&gt;&gt; calcQuadraticBounds((0, 0), (50, 100), (100, 0)) 
        (0, 0, 100, 50.0) 
        &gt;&gt;&gt; calcQuadraticBounds((0, 0), (100, 0), (100, 100)) 
        (0.0, 0.0, 100, 100) 
    &quot;&quot;&quot;</span>
    <span class="s1">(ax</span><span class="s3">, </span><span class="s1">ay)</span><span class="s3">, </span><span class="s1">(bx</span><span class="s3">, </span><span class="s1">by)</span><span class="s3">, </span><span class="s1">(cx</span><span class="s3">, </span><span class="s1">cy) = calcQuadraticParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3)</span>
    <span class="s1">ax2 = ax * </span><span class="s5">2.0</span>
    <span class="s1">ay2 = ay * </span><span class="s5">2.0</span>
    <span class="s1">roots = []</span>
    <span class="s3">if </span><span class="s1">ax2 != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">roots.append(-bx / ax2)</span>
    <span class="s3">if </span><span class="s1">ay2 != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">roots.append(-by / ay2)</span>
    <span class="s1">points = [</span>
        <span class="s1">(ax * t * t + bx * t + cx</span><span class="s3">, </span><span class="s1">ay * t * t + by * t + cy)</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">roots</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span>
    <span class="s1">] + [pt1</span><span class="s3">, </span><span class="s1">pt3]</span>
    <span class="s3">return </span><span class="s1">calcBounds(points)</span>


<span class="s3">def </span><span class="s1">approximateCubicArcLength(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4):</span>
    <span class="s2">&quot;&quot;&quot;Approximates the arc length for a cubic Bezier segment. 
 
    Uses Gauss-Lobatto quadrature with n=5 points to approximate arc length. 
    See :func:`calcCubicArcLength` for a slower but more accurate result. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
 
    Returns: 
        Arc length value. 
 
    Example:: 
 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (25, 100), (75, 100), (100, 0)) 
        190.04332968932817 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 50), (100, 100)) 
        154.8852074945903 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 0), (150, 0)) # line; exact result should be 150. 
        149.99999999999991 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, 0), (-50, 0)) # cusp; exact result should be 150. 
        136.9267662156362 
        &gt;&gt;&gt; approximateCubicArcLength((0, 0), (50, 0), (100, -50), (-50, 0)) # cusp 
        154.80848416537057 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">approximateCubicArcLengthC(</span>
        <span class="s1">complex(*pt1)</span><span class="s3">, </span><span class="s1">complex(*pt2)</span><span class="s3">, </span><span class="s1">complex(*pt3)</span><span class="s3">, </span><span class="s1">complex(*pt4)</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">approximateCubicArcLengthC(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4):</span>
    <span class="s2">&quot;&quot;&quot;Approximates the arc length for a cubic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as complex numbers. 
 
    Returns: 
        Arc length value. 
    &quot;&quot;&quot;</span>
    <span class="s0"># This, essentially, approximates the length-of-derivative function</span>
    <span class="s0"># to be integrated with the best-matching seventh-degree polynomial</span>
    <span class="s0"># approximation of it.</span>
    <span class="s0">#</span>
    <span class="s0"># https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules</span>

    <span class="s0"># abs(BezierCurveC[3].diff(t).subs({t:T})) for T in sorted(0, .5±(3/7)**.5/2, .5, 1),</span>
    <span class="s0"># weighted 1/20, 49/180, 32/90, 49/180, 1/20 respectively.</span>
    <span class="s1">v0 = abs(pt2 - pt1) * </span><span class="s5">0.15</span>
    <span class="s1">v1 = abs(</span>
        <span class="s1">-</span><span class="s5">0.558983582205757 </span><span class="s1">* pt1</span>
        <span class="s1">+ </span><span class="s5">0.325650248872424 </span><span class="s1">* pt2</span>
        <span class="s1">+ </span><span class="s5">0.208983582205757 </span><span class="s1">* pt3</span>
        <span class="s1">+ </span><span class="s5">0.024349751127576 </span><span class="s1">* pt4</span>
    <span class="s1">)</span>
    <span class="s1">v2 = abs(pt4 - pt1 + pt3 - pt2) * </span><span class="s5">0.26666666666666666</span>
    <span class="s1">v3 = abs(</span>
        <span class="s1">-</span><span class="s5">0.024349751127576 </span><span class="s1">* pt1</span>
        <span class="s1">- </span><span class="s5">0.208983582205757 </span><span class="s1">* pt2</span>
        <span class="s1">- </span><span class="s5">0.325650248872424 </span><span class="s1">* pt3</span>
        <span class="s1">+ </span><span class="s5">0.558983582205757 </span><span class="s1">* pt4</span>
    <span class="s1">)</span>
    <span class="s1">v4 = abs(pt4 - pt3) * </span><span class="s5">0.15</span>

    <span class="s3">return </span><span class="s1">v0 + v1 + v2 + v3 + v4</span>


<span class="s3">def </span><span class="s1">calcCubicBounds(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4):</span>
    <span class="s2">&quot;&quot;&quot;Calculates the bounding rectangle for a quadratic Bezier segment. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
 
    Returns: 
        A four-item tuple representing the bounding rectangle ``(xMin, yMin, xMax, yMax)``. 
 
    Example:: 
 
        &gt;&gt;&gt; calcCubicBounds((0, 0), (25, 100), (75, 100), (100, 0)) 
        (0, 0, 100, 75.0) 
        &gt;&gt;&gt; calcCubicBounds((0, 0), (50, 0), (100, 50), (100, 100)) 
        (0.0, 0.0, 100, 100) 
        &gt;&gt;&gt; print(&quot;%f %f %f %f&quot; % calcCubicBounds((50, 0), (0, 100), (100, 100), (50, 0))) 
        35.566243 0.000000 64.433757 75.000000 
    &quot;&quot;&quot;</span>
    <span class="s1">(ax</span><span class="s3">, </span><span class="s1">ay)</span><span class="s3">, </span><span class="s1">(bx</span><span class="s3">, </span><span class="s1">by)</span><span class="s3">, </span><span class="s1">(cx</span><span class="s3">, </span><span class="s1">cy)</span><span class="s3">, </span><span class="s1">(dx</span><span class="s3">, </span><span class="s1">dy) = calcCubicParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4)</span>
    <span class="s0"># calc first derivative</span>
    <span class="s1">ax3 = ax * </span><span class="s5">3.0</span>
    <span class="s1">ay3 = ay * </span><span class="s5">3.0</span>
    <span class="s1">bx2 = bx * </span><span class="s5">2.0</span>
    <span class="s1">by2 = by * </span><span class="s5">2.0</span>
    <span class="s1">xRoots = [t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solveQuadratic(ax3</span><span class="s3">, </span><span class="s1">bx2</span><span class="s3">, </span><span class="s1">cx) </span><span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">yRoots = [t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solveQuadratic(ay3</span><span class="s3">, </span><span class="s1">by2</span><span class="s3">, </span><span class="s1">cy) </span><span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">roots = xRoots + yRoots</span>

    <span class="s1">points = [</span>
        <span class="s1">(</span>
            <span class="s1">ax * t * t * t + bx * t * t + cx * t + dx</span><span class="s3">,</span>
            <span class="s1">ay * t * t * t + by * t * t + cy * t + dy</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">roots</span>
    <span class="s1">] + [pt1</span><span class="s3">, </span><span class="s1">pt4]</span>
    <span class="s3">return </span><span class="s1">calcBounds(points)</span>


<span class="s3">def </span><span class="s1">splitLine(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">where</span><span class="s3">, </span><span class="s1">isHorizontal):</span>
    <span class="s2">&quot;&quot;&quot;Split a line at a given coordinate. 
 
    Args: 
        pt1: Start point of line as 2D tuple. 
        pt2: End point of line as 2D tuple. 
        where: Position at which to split the line. 
        isHorizontal: Direction of the ray splitting the line. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two line segments (each line segment being two 2D tuples) 
        if the line was successfully split, or a list containing the original 
        line. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 50, True)) 
        ((0, 0), (50, 50)) 
        ((50, 50), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 100, True)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 0, True)) 
        ((0, 0), (0, 0)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 0), (100, 100), 0, False)) 
        ((0, 0), (0, 0)) 
        ((0, 0), (100, 100)) 
        &gt;&gt;&gt; printSegments(splitLine((100, 0), (0, 0), 50, False)) 
        ((100, 0), (50, 0)) 
        ((50, 0), (0, 0)) 
        &gt;&gt;&gt; printSegments(splitLine((0, 100), (0, 0), 50, True)) 
        ((0, 100), (0, 50)) 
        ((0, 50), (0, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">pt1x</span><span class="s3">, </span><span class="s1">pt1y = pt1</span>
    <span class="s1">pt2x</span><span class="s3">, </span><span class="s1">pt2y = pt2</span>

    <span class="s1">ax = pt2x - pt1x</span>
    <span class="s1">ay = pt2y - pt1y</span>

    <span class="s1">bx = pt1x</span>
    <span class="s1">by = pt1y</span>

    <span class="s1">a = (ax</span><span class="s3">, </span><span class="s1">ay)[isHorizontal]</span>

    <span class="s3">if </span><span class="s1">a == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[(pt1</span><span class="s3">, </span><span class="s1">pt2)]</span>
    <span class="s1">t = (where - (bx</span><span class="s3">, </span><span class="s1">by)[isHorizontal]) / a</span>
    <span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">midPt = ax * t + bx</span><span class="s3">, </span><span class="s1">ay * t + by</span>
        <span class="s3">return </span><span class="s1">[(pt1</span><span class="s3">, </span><span class="s1">midPt)</span><span class="s3">, </span><span class="s1">(midPt</span><span class="s3">, </span><span class="s1">pt2)]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">[(pt1</span><span class="s3">, </span><span class="s1">pt2)]</span>


<span class="s3">def </span><span class="s1">splitQuadratic(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">where</span><span class="s3">, </span><span class="s1">isHorizontal):</span>
    <span class="s2">&quot;&quot;&quot;Split a quadratic Bezier curve at a given coordinate. 
 
    Args: 
        pt1,pt2,pt3: Control points of the Bezier as 2D tuples. 
        where: Position at which to split the curve. 
        isHorizontal: Direction of the ray splitting the curve. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two curve segments (each curve segment being three 2D tuples) 
        if the curve was successfully split, or a list containing the original 
        curve. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 150, False)) 
        ((0, 0), (50, 100), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, False)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, False)) 
        ((0, 0), (12.5, 25), (25, 37.5)) 
        ((25, 37.5), (62.5, 75), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 25, True)) 
        ((0, 0), (7.32233, 14.6447), (14.6447, 25)) 
        ((14.6447, 25), (50, 75), (85.3553, 25)) 
        ((85.3553, 25), (92.6777, 14.6447), (100, -7.10543e-15)) 
        &gt;&gt;&gt; # XXX I'm not at all sure if the following behavior is desirable: 
        &gt;&gt;&gt; printSegments(splitQuadratic((0, 0), (50, 100), (100, 0), 50, True)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (50, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = calcQuadraticParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3)</span>
    <span class="s1">solutions = solveQuadratic(</span>
        <span class="s1">a[isHorizontal]</span><span class="s3">, </span><span class="s1">b[isHorizontal]</span><span class="s3">, </span><span class="s1">c[isHorizontal] - where</span>
    <span class="s1">)</span>
    <span class="s1">solutions = sorted(t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solutions </span><span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">solutions:</span>
        <span class="s3">return </span><span class="s1">[(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3)]</span>
    <span class="s3">return </span><span class="s1">_splitQuadraticAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">*solutions)</span>


<span class="s3">def </span><span class="s1">splitCubic(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4</span><span class="s3">, </span><span class="s1">where</span><span class="s3">, </span><span class="s1">isHorizontal):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at a given coordinate. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        where: Position at which to split the curve. 
        isHorizontal: Direction of the ray splitting the curve. If true, 
            ``where`` is interpreted as a Y coordinate; if false, then 
            ``where`` is interpreted as an X coordinate. 
 
    Returns: 
        A list of two curve segments (each curve segment being four 2D tuples) 
        if the curve was successfully split, or a list containing the original 
        curve. 
 
    Example:: 
 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 150, False)) 
        ((0, 0), (25, 100), (75, 100), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 50, False)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (68.75, 75), (87.5, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubic((0, 0), (25, 100), (75, 100), (100, 0), 25, True)) 
        ((0, 0), (2.29379, 9.17517), (4.79804, 17.5085), (7.47414, 25)) 
        ((7.47414, 25), (31.2886, 91.6667), (68.7114, 91.6667), (92.5259, 25)) 
        ((92.5259, 25), (95.202, 17.5085), (97.7062, 9.17517), (100, 1.77636e-15)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d = calcCubicParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4)</span>
    <span class="s1">solutions = solveCubic(</span>
        <span class="s1">a[isHorizontal]</span><span class="s3">, </span><span class="s1">b[isHorizontal]</span><span class="s3">, </span><span class="s1">c[isHorizontal]</span><span class="s3">, </span><span class="s1">d[isHorizontal] - where</span>
    <span class="s1">)</span>
    <span class="s1">solutions = sorted(t </span><span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">solutions </span><span class="s3">if </span><span class="s5">0 </span><span class="s1">&lt;= t &lt; </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">solutions:</span>
        <span class="s3">return </span><span class="s1">[(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4)]</span>
    <span class="s3">return </span><span class="s1">_splitCubicAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">*solutions)</span>


<span class="s3">def </span><span class="s1">splitQuadraticAtT(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">*ts):</span>
    <span class="s2">&quot;&quot;&quot;Split a quadratic Bezier curve at one or more values of t. 
 
    Args: 
        pt1,pt2,pt3: Control points of the Bezier as 2D tuples. 
        *ts: Positions at which to split the curve. 
 
    Returns: 
        A list of curve segments (each curve segment being three 2D tuples). 
 
    Examples:: 
 
        &gt;&gt;&gt; printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (75, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitQuadraticAtT((0, 0), (50, 100), (100, 0), 0.5, 0.75)) 
        ((0, 0), (25, 50), (50, 50)) 
        ((50, 50), (62.5, 50), (75, 37.5)) 
        ((75, 37.5), (87.5, 25), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = calcQuadraticParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3)</span>
    <span class="s3">return </span><span class="s1">_splitQuadraticAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">*ts)</span>


<span class="s3">def </span><span class="s1">splitCubicAtT(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4</span><span class="s3">, </span><span class="s1">*ts):</span>
    <span class="s2">&quot;&quot;&quot;Split a cubic Bezier curve at one or more values of t. 
 
    Args: 
        pt1,pt2,pt3,pt4: Control points of the Bezier as 2D tuples. 
        *ts: Positions at which to split the curve. 
 
    Returns: 
        A list of curve segments (each curve segment being four 2D tuples). 
 
    Examples:: 
 
        &gt;&gt;&gt; printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (68.75, 75), (87.5, 50), (100, 0)) 
        &gt;&gt;&gt; printSegments(splitCubicAtT((0, 0), (25, 100), (75, 100), (100, 0), 0.5, 0.75)) 
        ((0, 0), (12.5, 50), (31.25, 75), (50, 75)) 
        ((50, 75), (59.375, 75), (68.75, 68.75), (77.3438, 56.25)) 
        ((77.3438, 56.25), (85.9375, 43.75), (93.75, 25), (100, 0)) 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d = calcCubicParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4)</span>
    <span class="s3">return </span><span class="s1">_splitCubicAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">*ts)</span>


<span class="s3">def </span><span class="s1">_splitQuadraticAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">*ts):</span>
    <span class="s1">ts = list(ts)</span>
    <span class="s1">segments = []</span>
    <span class="s1">ts.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>
    <span class="s1">ts.append(</span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">ax</span><span class="s3">, </span><span class="s1">ay = a</span>
    <span class="s1">bx</span><span class="s3">, </span><span class="s1">by = b</span>
    <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = c</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(ts) - </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">t1 = ts[i]</span>
        <span class="s1">t2 = ts[i + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">delta = t2 - t1</span>
        <span class="s0"># calc new a, b and c</span>
        <span class="s1">delta_2 = delta * delta</span>
        <span class="s1">a1x = ax * delta_2</span>
        <span class="s1">a1y = ay * delta_2</span>
        <span class="s1">b1x = (</span><span class="s5">2 </span><span class="s1">* ax * t1 + bx) * delta</span>
        <span class="s1">b1y = (</span><span class="s5">2 </span><span class="s1">* ay * t1 + by) * delta</span>
        <span class="s1">t1_2 = t1 * t1</span>
        <span class="s1">c1x = ax * t1_2 + bx * t1 + cx</span>
        <span class="s1">c1y = ay * t1_2 + by * t1 + cy</span>

        <span class="s1">pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3 = calcQuadraticPoints((a1x</span><span class="s3">, </span><span class="s1">a1y)</span><span class="s3">, </span><span class="s1">(b1x</span><span class="s3">, </span><span class="s1">b1y)</span><span class="s3">, </span><span class="s1">(c1x</span><span class="s3">, </span><span class="s1">c1y))</span>
        <span class="s1">segments.append((pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3))</span>
    <span class="s3">return </span><span class="s1">segments</span>


<span class="s3">def </span><span class="s1">_splitCubicAtT(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">*ts):</span>
    <span class="s1">ts = list(ts)</span>
    <span class="s1">ts.insert(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>
    <span class="s1">ts.append(</span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">segments = []</span>
    <span class="s1">ax</span><span class="s3">, </span><span class="s1">ay = a</span>
    <span class="s1">bx</span><span class="s3">, </span><span class="s1">by = b</span>
    <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = c</span>
    <span class="s1">dx</span><span class="s3">, </span><span class="s1">dy = d</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(ts) - </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">t1 = ts[i]</span>
        <span class="s1">t2 = ts[i + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">delta = t2 - t1</span>

        <span class="s1">delta_2 = delta * delta</span>
        <span class="s1">delta_3 = delta * delta_2</span>
        <span class="s1">t1_2 = t1 * t1</span>
        <span class="s1">t1_3 = t1 * t1_2</span>

        <span class="s0"># calc new a, b, c and d</span>
        <span class="s1">a1x = ax * delta_3</span>
        <span class="s1">a1y = ay * delta_3</span>
        <span class="s1">b1x = (</span><span class="s5">3 </span><span class="s1">* ax * t1 + bx) * delta_2</span>
        <span class="s1">b1y = (</span><span class="s5">3 </span><span class="s1">* ay * t1 + by) * delta_2</span>
        <span class="s1">c1x = (</span><span class="s5">2 </span><span class="s1">* bx * t1 + cx + </span><span class="s5">3 </span><span class="s1">* ax * t1_2) * delta</span>
        <span class="s1">c1y = (</span><span class="s5">2 </span><span class="s1">* by * t1 + cy + </span><span class="s5">3 </span><span class="s1">* ay * t1_2) * delta</span>
        <span class="s1">d1x = ax * t1_3 + bx * t1_2 + cx * t1 + dx</span>
        <span class="s1">d1y = ay * t1_3 + by * t1_2 + cy * t1 + dy</span>
        <span class="s1">pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4 = calcCubicPoints(</span>
            <span class="s1">(a1x</span><span class="s3">, </span><span class="s1">a1y)</span><span class="s3">, </span><span class="s1">(b1x</span><span class="s3">, </span><span class="s1">b1y)</span><span class="s3">, </span><span class="s1">(c1x</span><span class="s3">, </span><span class="s1">c1y)</span><span class="s3">, </span><span class="s1">(d1x</span><span class="s3">, </span><span class="s1">d1y)</span>
        <span class="s1">)</span>
        <span class="s1">segments.append((pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4))</span>
    <span class="s3">return </span><span class="s1">segments</span>


<span class="s0">#</span>
<span class="s0"># Equation solvers.</span>
<span class="s0">#</span>

<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">acos</span><span class="s3">, </span><span class="s1">cos</span><span class="s3">, </span><span class="s1">pi</span>


<span class="s3">def </span><span class="s1">solveQuadratic(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">sqrt=sqrt):</span>
    <span class="s2">&quot;&quot;&quot;Solve a quadratic equation. 
 
    Solves *a*x*x + b*x + c = 0* where a, b and c are real. 
 
    Args: 
        a: coefficient of *x²* 
        b: coefficient of *x* 
        c: constant term 
 
    Returns: 
        A list of roots. Note that the returned list is neither guaranteed to 
        be sorted nor to contain unique values! 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">abs(a) &lt; epsilon:</span>
        <span class="s3">if </span><span class="s1">abs(b) &lt; epsilon:</span>
            <span class="s0"># We have a non-equation; therefore, we have no valid solution</span>
            <span class="s1">roots = []</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># We have a linear equation with 1 root.</span>
            <span class="s1">roots = [-c / b]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># We have a true quadratic equation.  Apply the quadratic formula to find two roots.</span>
        <span class="s1">DD = b * b - </span><span class="s5">4.0 </span><span class="s1">* a * c</span>
        <span class="s3">if </span><span class="s1">DD &gt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s1">rDD = sqrt(DD)</span>
            <span class="s1">roots = [(-b + rDD) / </span><span class="s5">2.0 </span><span class="s1">/ a</span><span class="s3">, </span><span class="s1">(-b - rDD) / </span><span class="s5">2.0 </span><span class="s1">/ a]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># complex roots, ignore</span>
            <span class="s1">roots = []</span>
    <span class="s3">return </span><span class="s1">roots</span>


<span class="s3">def </span><span class="s1">solveCubic(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d):</span>
    <span class="s2">&quot;&quot;&quot;Solve a cubic equation. 
 
    Solves *a*x*x*x + b*x*x + c*x + d = 0* where a, b, c and d are real. 
 
    Args: 
        a: coefficient of *x³* 
        b: coefficient of *x²* 
        c: coefficient of *x* 
        d: constant term 
 
    Returns: 
        A list of roots. Note that the returned list is neither guaranteed to 
        be sorted nor to contain unique values! 
 
    Examples:: 
 
        &gt;&gt;&gt; solveCubic(1, 1, -6, 0) 
        [-3.0, -0.0, 2.0] 
        &gt;&gt;&gt; solveCubic(-10.0, -9.0, 48.0, -29.0) 
        [-2.9, 1.0, 1.0] 
        &gt;&gt;&gt; solveCubic(-9.875, -9.0, 47.625, -28.75) 
        [-2.911392, 1.0, 1.0] 
        &gt;&gt;&gt; solveCubic(1.0, -4.5, 6.75, -3.375) 
        [1.5, 1.5, 1.5] 
        &gt;&gt;&gt; solveCubic(-12.0, 18.0, -9.0, 1.50023651123) 
        [0.5, 0.5, 0.5] 
        &gt;&gt;&gt; solveCubic( 
        ...     9.0, 0.0, 0.0, -7.62939453125e-05 
        ... ) == [-0.0, -0.0, -0.0] 
        True 
    &quot;&quot;&quot;</span>
    <span class="s0">#</span>
    <span class="s0"># adapted from:</span>
    <span class="s0">#   CUBIC.C - Solve a cubic polynomial</span>
    <span class="s0">#   public domain by Ross Cottrell</span>
    <span class="s0"># found at: http://www.strangecreations.com/library/snippets/Cubic.C</span>
    <span class="s0">#</span>
    <span class="s3">if </span><span class="s1">abs(a) &lt; epsilon:</span>
        <span class="s0"># don't just test for zero; for very small values of 'a' solveCubic()</span>
        <span class="s0"># returns unreliable results, so we fall back to quad.</span>
        <span class="s3">return </span><span class="s1">solveQuadratic(b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d)</span>
    <span class="s1">a = float(a)</span>
    <span class="s1">a1 = b / a</span>
    <span class="s1">a2 = c / a</span>
    <span class="s1">a3 = d / a</span>

    <span class="s1">Q = (a1 * a1 - </span><span class="s5">3.0 </span><span class="s1">* a2) / </span><span class="s5">9.0</span>
    <span class="s1">R = (</span><span class="s5">2.0 </span><span class="s1">* a1 * a1 * a1 - </span><span class="s5">9.0 </span><span class="s1">* a1 * a2 + </span><span class="s5">27.0 </span><span class="s1">* a3) / </span><span class="s5">54.0</span>

    <span class="s1">R2 = R * R</span>
    <span class="s1">Q3 = Q * Q * Q</span>
    <span class="s1">R2 = </span><span class="s5">0 </span><span class="s3">if </span><span class="s1">R2 &lt; epsilon </span><span class="s3">else </span><span class="s1">R2</span>
    <span class="s1">Q3 = </span><span class="s5">0 </span><span class="s3">if </span><span class="s1">abs(Q3) &lt; epsilon </span><span class="s3">else </span><span class="s1">Q3</span>

    <span class="s1">R2_Q3 = R2 - Q3</span>

    <span class="s3">if </span><span class="s1">R2 == </span><span class="s5">0.0 </span><span class="s3">and </span><span class="s1">Q3 == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s1">x = round(-a1 / </span><span class="s5">3.0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">return </span><span class="s1">[x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">x]</span>
    <span class="s3">elif </span><span class="s1">R2_Q3 &lt;= epsilon * </span><span class="s5">0.5</span><span class="s1">:</span>
        <span class="s0"># The epsilon * .5 above ensures that Q3 is not zero.</span>
        <span class="s1">theta = acos(max(min(R / sqrt(Q3)</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1.0</span><span class="s1">))</span>
        <span class="s1">rQ2 = -</span><span class="s5">2.0 </span><span class="s1">* sqrt(Q)</span>
        <span class="s1">a1_3 = a1 / </span><span class="s5">3.0</span>
        <span class="s1">x0 = rQ2 * cos(theta / </span><span class="s5">3.0</span><span class="s1">) - a1_3</span>
        <span class="s1">x1 = rQ2 * cos((theta + </span><span class="s5">2.0 </span><span class="s1">* pi) / </span><span class="s5">3.0</span><span class="s1">) - a1_3</span>
        <span class="s1">x2 = rQ2 * cos((theta + </span><span class="s5">4.0 </span><span class="s1">* pi) / </span><span class="s5">3.0</span><span class="s1">) - a1_3</span>
        <span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2 = sorted([x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2])</span>
        <span class="s0"># Merge roots that are close-enough</span>
        <span class="s3">if </span><span class="s1">x1 - x0 &lt; epsilon </span><span class="s3">and </span><span class="s1">x2 - x1 &lt; epsilon:</span>
            <span class="s1">x0 = x1 = x2 = round((x0 + x1 + x2) / </span><span class="s5">3.0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">elif </span><span class="s1">x1 - x0 &lt; epsilon:</span>
            <span class="s1">x0 = x1 = round((x0 + x1) / </span><span class="s5">2.0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
            <span class="s1">x2 = round(x2</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">elif </span><span class="s1">x2 - x1 &lt; epsilon:</span>
            <span class="s1">x0 = round(x0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
            <span class="s1">x1 = x2 = round((x1 + x2) / </span><span class="s5">2.0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">x0 = round(x0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
            <span class="s1">x1 = round(x1</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
            <span class="s1">x2 = round(x2</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">return </span><span class="s1">[x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">x = pow(sqrt(R2_Q3) + abs(R)</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">3.0</span><span class="s1">)</span>
        <span class="s1">x = x + Q / x</span>
        <span class="s3">if </span><span class="s1">R &gt;= </span><span class="s5">0.0</span><span class="s1">:</span>
            <span class="s1">x = -x</span>
        <span class="s1">x = round(x - a1 / </span><span class="s5">3.0</span><span class="s3">, </span><span class="s1">epsilonDigits)</span>
        <span class="s3">return </span><span class="s1">[x]</span>


<span class="s0">#</span>
<span class="s0"># Conversion routines for points to parameters and vice versa</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">calcQuadraticParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3):</span>
    <span class="s1">x2</span><span class="s3">, </span><span class="s1">y2 = pt2</span>
    <span class="s1">x3</span><span class="s3">, </span><span class="s1">y3 = pt3</span>
    <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = pt1</span>
    <span class="s1">bx = (x2 - cx) * </span><span class="s5">2.0</span>
    <span class="s1">by = (y2 - cy) * </span><span class="s5">2.0</span>
    <span class="s1">ax = x3 - cx - bx</span>
    <span class="s1">ay = y3 - cy - by</span>
    <span class="s3">return </span><span class="s1">(ax</span><span class="s3">, </span><span class="s1">ay)</span><span class="s3">, </span><span class="s1">(bx</span><span class="s3">, </span><span class="s1">by)</span><span class="s3">, </span><span class="s1">(cx</span><span class="s3">, </span><span class="s1">cy)</span>


<span class="s3">def </span><span class="s1">calcCubicParameters(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4):</span>
    <span class="s1">x2</span><span class="s3">, </span><span class="s1">y2 = pt2</span>
    <span class="s1">x3</span><span class="s3">, </span><span class="s1">y3 = pt3</span>
    <span class="s1">x4</span><span class="s3">, </span><span class="s1">y4 = pt4</span>
    <span class="s1">dx</span><span class="s3">, </span><span class="s1">dy = pt1</span>
    <span class="s1">cx = (x2 - dx) * </span><span class="s5">3.0</span>
    <span class="s1">cy = (y2 - dy) * </span><span class="s5">3.0</span>
    <span class="s1">bx = (x3 - x2) * </span><span class="s5">3.0 </span><span class="s1">- cx</span>
    <span class="s1">by = (y3 - y2) * </span><span class="s5">3.0 </span><span class="s1">- cy</span>
    <span class="s1">ax = x4 - dx - cx - bx</span>
    <span class="s1">ay = y4 - dy - cy - by</span>
    <span class="s3">return </span><span class="s1">(ax</span><span class="s3">, </span><span class="s1">ay)</span><span class="s3">, </span><span class="s1">(bx</span><span class="s3">, </span><span class="s1">by)</span><span class="s3">, </span><span class="s1">(cx</span><span class="s3">, </span><span class="s1">cy)</span><span class="s3">, </span><span class="s1">(dx</span><span class="s3">, </span><span class="s1">dy)</span>


<span class="s3">def </span><span class="s1">calcQuadraticPoints(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c):</span>
    <span class="s1">ax</span><span class="s3">, </span><span class="s1">ay = a</span>
    <span class="s1">bx</span><span class="s3">, </span><span class="s1">by = b</span>
    <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = c</span>
    <span class="s1">x1 = cx</span>
    <span class="s1">y1 = cy</span>
    <span class="s1">x2 = (bx * </span><span class="s5">0.5</span><span class="s1">) + cx</span>
    <span class="s1">y2 = (by * </span><span class="s5">0.5</span><span class="s1">) + cy</span>
    <span class="s1">x3 = ax + bx + cx</span>
    <span class="s1">y3 = ay + by + cy</span>
    <span class="s3">return </span><span class="s1">(x1</span><span class="s3">, </span><span class="s1">y1)</span><span class="s3">, </span><span class="s1">(x2</span><span class="s3">, </span><span class="s1">y2)</span><span class="s3">, </span><span class="s1">(x3</span><span class="s3">, </span><span class="s1">y3)</span>


<span class="s3">def </span><span class="s1">calcCubicPoints(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d):</span>
    <span class="s1">ax</span><span class="s3">, </span><span class="s1">ay = a</span>
    <span class="s1">bx</span><span class="s3">, </span><span class="s1">by = b</span>
    <span class="s1">cx</span><span class="s3">, </span><span class="s1">cy = c</span>
    <span class="s1">dx</span><span class="s3">, </span><span class="s1">dy = d</span>
    <span class="s1">x1 = dx</span>
    <span class="s1">y1 = dy</span>
    <span class="s1">x2 = (cx / </span><span class="s5">3.0</span><span class="s1">) + dx</span>
    <span class="s1">y2 = (cy / </span><span class="s5">3.0</span><span class="s1">) + dy</span>
    <span class="s1">x3 = (bx + cx) / </span><span class="s5">3.0 </span><span class="s1">+ x2</span>
    <span class="s1">y3 = (by + cy) / </span><span class="s5">3.0 </span><span class="s1">+ y2</span>
    <span class="s1">x4 = ax + dx + cx + bx</span>
    <span class="s1">y4 = ay + dy + cy + by</span>
    <span class="s3">return </span><span class="s1">(x1</span><span class="s3">, </span><span class="s1">y1)</span><span class="s3">, </span><span class="s1">(x2</span><span class="s3">, </span><span class="s1">y2)</span><span class="s3">, </span><span class="s1">(x3</span><span class="s3">, </span><span class="s1">y3)</span><span class="s3">, </span><span class="s1">(x4</span><span class="s3">, </span><span class="s1">y4)</span>


<span class="s0">#</span>
<span class="s0"># Point at time</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">linePointAtT(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a line. 
 
    Args: 
        pt1, pt2: Coordinates of the line as 2D tuples. 
        t: The time along the line. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">((pt1[</span><span class="s5">0</span><span class="s1">] * (</span><span class="s5">1 </span><span class="s1">- t) + pt2[</span><span class="s5">0</span><span class="s1">] * t)</span><span class="s3">, </span><span class="s1">(pt1[</span><span class="s5">1</span><span class="s1">] * (</span><span class="s5">1 </span><span class="s1">- t) + pt2[</span><span class="s5">1</span><span class="s1">] * t))</span>


<span class="s3">def </span><span class="s1">quadraticPointAtT(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a quadratic curve. 
 
    Args: 
        pt1, pt2, pt3: Coordinates of the curve as 2D tuples. 
        t: The time along the curve. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * pt1[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">2 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * t * pt2[</span><span class="s5">0</span><span class="s1">] + t * t * pt3[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">y = (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * pt1[</span><span class="s5">1</span><span class="s1">] + </span><span class="s5">2 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * t * pt2[</span><span class="s5">1</span><span class="s1">] + t * t * pt3[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y)</span>


<span class="s3">def </span><span class="s1">cubicPointAtT(pt1</span><span class="s3">, </span><span class="s1">pt2</span><span class="s3">, </span><span class="s1">pt3</span><span class="s3">, </span><span class="s1">pt4</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s2">&quot;&quot;&quot;Finds the point at time `t` on a cubic curve. 
 
    Args: 
        pt1, pt2, pt3, pt4: Coordinates of the curve as 2D tuples. 
        t: The time along the curve. 
 
    Returns: 
        A 2D tuple with the coordinates of the point. 
    &quot;&quot;&quot;</span>
    <span class="s1">x = (</span>
        <span class="s1">(</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * pt1[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s5">3 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * t * pt2[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s5">3 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * t * t * pt3[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">+ t * t * t * pt4[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">y = (</span>
        <span class="s1">(</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * pt1[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s5">3 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * (</span><span class="s5">1 </span><span class="s1">- t) * t * pt2[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">+ </span><span class="s5">3 </span><span class="s1">* (</span><span class="s5">1 </span><span class="s1">- t) * t * t * pt3[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">+ t * t * t * pt4[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y)</span>


<span class="s3">def </span><span class="s1">segmentPointAtT(seg</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s3">if </span><span class="s1">len(seg) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">linePointAtT(*seg</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">elif </span><span class="s1">len(seg) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">quadraticPointAtT(*seg</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">elif </span><span class="s1">len(seg) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">cubicPointAtT(*seg</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown curve degree&quot;</span><span class="s1">)</span>


<span class="s0">#</span>
<span class="s0"># Intersection finders</span>
<span class="s0">#</span>


<span class="s3">def </span><span class="s1">_line_t_of_pt(s</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">pt):</span>
    <span class="s1">sx</span><span class="s3">, </span><span class="s1">sy = s</span>
    <span class="s1">ex</span><span class="s3">, </span><span class="s1">ey = e</span>
    <span class="s1">px</span><span class="s3">, </span><span class="s1">py = pt</span>
    <span class="s3">if </span><span class="s1">abs(sx - ex) &lt; epsilon </span><span class="s3">and </span><span class="s1">abs(sy - ey) &lt; epsilon:</span>
        <span class="s0"># Line is a point!</span>
        <span class="s3">return </span><span class="s1">-</span><span class="s5">1</span>
    <span class="s0"># Use the largest</span>
    <span class="s3">if </span><span class="s1">abs(sx - ex) &gt; abs(sy - ey):</span>
        <span class="s3">return </span><span class="s1">(px - sx) / (ex - sx)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">(py - sy) / (ey - sy)</span>


<span class="s3">def </span><span class="s1">_both_points_are_on_same_side_of_origin(a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">origin):</span>
    <span class="s1">xDiff = (a[</span><span class="s5">0</span><span class="s1">] - origin[</span><span class="s5">0</span><span class="s1">]) * (b[</span><span class="s5">0</span><span class="s1">] - origin[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">yDiff = (a[</span><span class="s5">1</span><span class="s1">] - origin[</span><span class="s5">1</span><span class="s1">]) * (b[</span><span class="s5">1</span><span class="s1">] - origin[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return not </span><span class="s1">(xDiff &lt;= </span><span class="s5">0.0 </span><span class="s3">and </span><span class="s1">yDiff &lt;= </span><span class="s5">0.0</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">lineLineIntersections(s1</span><span class="s3">, </span><span class="s1">e1</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">e2):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between two line segments. 
 
    Args: 
        s1, e1: Coordinates of the first line as 2D tuples. 
        s2, e2: Coordinates of the second line as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
 
        &gt;&gt;&gt; a = lineLineIntersections( (310,389), (453, 222), (289, 251), (447, 367)) 
        &gt;&gt;&gt; len(a) 
        1 
        &gt;&gt;&gt; intersection = a[0] 
        &gt;&gt;&gt; intersection.pt 
        (374.44882952482897, 313.73458370177315) 
        &gt;&gt;&gt; (intersection.t1, intersection.t2) 
        (0.45069111555824465, 0.5408153767394238) 
    &quot;&quot;&quot;</span>
    <span class="s1">s1x</span><span class="s3">, </span><span class="s1">s1y = s1</span>
    <span class="s1">e1x</span><span class="s3">, </span><span class="s1">e1y = e1</span>
    <span class="s1">s2x</span><span class="s3">, </span><span class="s1">s2y = s2</span>
    <span class="s1">e2x</span><span class="s3">, </span><span class="s1">e2y = e2</span>
    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">math.isclose(s2x</span><span class="s3">, </span><span class="s1">e2x) </span><span class="s3">and </span><span class="s1">math.isclose(s1x</span><span class="s3">, </span><span class="s1">e1x) </span><span class="s3">and not </span><span class="s1">math.isclose(s1x</span><span class="s3">, </span><span class="s1">s2x)</span>
    <span class="s1">):  </span><span class="s0"># Parallel vertical</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">math.isclose(s2y</span><span class="s3">, </span><span class="s1">e2y) </span><span class="s3">and </span><span class="s1">math.isclose(s1y</span><span class="s3">, </span><span class="s1">e1y) </span><span class="s3">and not </span><span class="s1">math.isclose(s1y</span><span class="s3">, </span><span class="s1">s2y)</span>
    <span class="s1">):  </span><span class="s0"># Parallel horizontal</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">math.isclose(s2x</span><span class="s3">, </span><span class="s1">e2x) </span><span class="s3">and </span><span class="s1">math.isclose(s2y</span><span class="s3">, </span><span class="s1">e2y):  </span><span class="s0"># Line segment is tiny</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">math.isclose(s1x</span><span class="s3">, </span><span class="s1">e1x) </span><span class="s3">and </span><span class="s1">math.isclose(s1y</span><span class="s3">, </span><span class="s1">e1y):  </span><span class="s0"># Line segment is tiny</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">math.isclose(e1x</span><span class="s3">, </span><span class="s1">s1x):</span>
        <span class="s1">x = s1x</span>
        <span class="s1">slope34 = (e2y - s2y) / (e2x - s2x)</span>
        <span class="s1">y = slope34 * (x - s2x) + s2y</span>
        <span class="s1">pt = (x</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">Intersection(</span>
                <span class="s1">pt=pt</span><span class="s3">, </span><span class="s1">t1=_line_t_of_pt(s1</span><span class="s3">, </span><span class="s1">e1</span><span class="s3">, </span><span class="s1">pt)</span><span class="s3">, </span><span class="s1">t2=_line_t_of_pt(s2</span><span class="s3">, </span><span class="s1">e2</span><span class="s3">, </span><span class="s1">pt)</span>
            <span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s3">if </span><span class="s1">math.isclose(s2x</span><span class="s3">, </span><span class="s1">e2x):</span>
        <span class="s1">x = s2x</span>
        <span class="s1">slope12 = (e1y - s1y) / (e1x - s1x)</span>
        <span class="s1">y = slope12 * (x - s1x) + s1y</span>
        <span class="s1">pt = (x</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">Intersection(</span>
                <span class="s1">pt=pt</span><span class="s3">, </span><span class="s1">t1=_line_t_of_pt(s1</span><span class="s3">, </span><span class="s1">e1</span><span class="s3">, </span><span class="s1">pt)</span><span class="s3">, </span><span class="s1">t2=_line_t_of_pt(s2</span><span class="s3">, </span><span class="s1">e2</span><span class="s3">, </span><span class="s1">pt)</span>
            <span class="s1">)</span>
        <span class="s1">]</span>

    <span class="s1">slope12 = (e1y - s1y) / (e1x - s1x)</span>
    <span class="s1">slope34 = (e2y - s2y) / (e2x - s2x)</span>
    <span class="s3">if </span><span class="s1">math.isclose(slope12</span><span class="s3">, </span><span class="s1">slope34):</span>
        <span class="s3">return </span><span class="s1">[]</span>
    <span class="s1">x = (slope12 * s1x - s1y - slope34 * s2x + s2y) / (slope12 - slope34)</span>
    <span class="s1">y = slope12 * (x - s1x) + s1y</span>
    <span class="s1">pt = (x</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s3">if </span><span class="s1">_both_points_are_on_same_side_of_origin(</span>
        <span class="s1">pt</span><span class="s3">, </span><span class="s1">e1</span><span class="s3">, </span><span class="s1">s1</span>
    <span class="s1">) </span><span class="s3">and </span><span class="s1">_both_points_are_on_same_side_of_origin(pt</span><span class="s3">, </span><span class="s1">s2</span><span class="s3">, </span><span class="s1">e2):</span>
        <span class="s3">return </span><span class="s1">[</span>
            <span class="s1">Intersection(</span>
                <span class="s1">pt=pt</span><span class="s3">, </span><span class="s1">t1=_line_t_of_pt(s1</span><span class="s3">, </span><span class="s1">e1</span><span class="s3">, </span><span class="s1">pt)</span><span class="s3">, </span><span class="s1">t2=_line_t_of_pt(s2</span><span class="s3">, </span><span class="s1">e2</span><span class="s3">, </span><span class="s1">pt)</span>
            <span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s3">return </span><span class="s1">[]</span>


<span class="s3">def </span><span class="s1">_alignment_transformation(segment):</span>
    <span class="s0"># Returns a transformation which aligns a segment horizontally at the</span>
    <span class="s0"># origin. Apply this transformation to curves and root-find to find</span>
    <span class="s0"># intersections with the segment.</span>
    <span class="s1">start = segment[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">end = segment[-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">angle = math.atan2(end[</span><span class="s5">1</span><span class="s1">] - start[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">end[</span><span class="s5">0</span><span class="s1">] - start[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">Identity.rotate(-angle).translate(-start[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">-start[</span><span class="s5">1</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_curve_line_intersections_t(curve</span><span class="s3">, </span><span class="s1">line):</span>
    <span class="s1">aligned_curve = _alignment_transformation(line).transformPoints(curve)</span>
    <span class="s3">if </span><span class="s1">len(curve) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c = calcQuadraticParameters(*aligned_curve)</span>
        <span class="s1">intersections = solveQuadratic(a[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">b[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">c[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">elif </span><span class="s1">len(curve) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">d = calcCubicParameters(*aligned_curve)</span>
        <span class="s1">intersections = solveCubic(a[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">b[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">c[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">d[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown curve degree&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">sorted(i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">intersections </span><span class="s3">if </span><span class="s5">0.0 </span><span class="s1">&lt;= i &lt;= </span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">curveLineIntersections(curve</span><span class="s3">, </span><span class="s1">line):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between a curve and a line. 
 
    Args: 
        curve: List of coordinates of the curve segment as 2D tuples. 
        line: List of coordinates of the line segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve = [ (100, 240), (30, 60), (210, 230), (160, 30) ] 
        &gt;&gt;&gt; line  = [ (25, 260), (230, 20) ] 
        &gt;&gt;&gt; intersections = curveLineIntersections(curve, line) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (84.9000930760723, 189.87306176459828) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len(curve) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s1">pointFinder = quadraticPointAtT</span>
    <span class="s3">elif </span><span class="s1">len(curve) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s1">pointFinder = cubicPointAtT</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown curve degree&quot;</span><span class="s1">)</span>
    <span class="s1">intersections = []</span>
    <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s1">_curve_line_intersections_t(curve</span><span class="s3">, </span><span class="s1">line):</span>
        <span class="s1">pt = pointFinder(*curve</span><span class="s3">, </span><span class="s1">t)</span>
        <span class="s0"># Back-project the point onto the line, to avoid problems with</span>
        <span class="s0"># numerical accuracy in the case of vertical and horizontal lines</span>
        <span class="s1">line_t = _line_t_of_pt(*line</span><span class="s3">, </span><span class="s1">pt)</span>
        <span class="s1">pt = linePointAtT(*line</span><span class="s3">, </span><span class="s1">line_t)</span>
        <span class="s1">intersections.append(Intersection(pt=pt</span><span class="s3">, </span><span class="s1">t1=t</span><span class="s3">, </span><span class="s1">t2=line_t))</span>
    <span class="s3">return </span><span class="s1">intersections</span>


<span class="s3">def </span><span class="s1">_curve_bounds(c):</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">calcQuadraticBounds(*c)</span>
    <span class="s3">elif </span><span class="s1">len(c) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">calcCubicBounds(*c)</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown curve degree&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_split_segment_at_t(c</span><span class="s3">, </span><span class="s1">t):</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">s</span><span class="s3">, </span><span class="s1">e = c</span>
        <span class="s1">midpoint = linePointAtT(s</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">t)</span>
        <span class="s3">return </span><span class="s1">[(s</span><span class="s3">, </span><span class="s1">midpoint)</span><span class="s3">, </span><span class="s1">(midpoint</span><span class="s3">, </span><span class="s1">e)]</span>
    <span class="s3">if </span><span class="s1">len(c) == </span><span class="s5">3</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">splitQuadraticAtT(*c</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">elif </span><span class="s1">len(c) == </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">splitCubicAtT(*c</span><span class="s3">, </span><span class="s1">t)</span>
    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unknown curve degree&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_curve_curve_intersections_t(</span>
    <span class="s1">curve1</span><span class="s3">, </span><span class="s1">curve2</span><span class="s3">, </span><span class="s1">precision=</span><span class="s5">1e-3</span><span class="s3">, </span><span class="s1">range1=</span><span class="s3">None, </span><span class="s1">range2=</span><span class="s3">None</span>
<span class="s1">):</span>
    <span class="s1">bounds1 = _curve_bounds(curve1)</span>
    <span class="s1">bounds2 = _curve_bounds(curve2)</span>

    <span class="s3">if not </span><span class="s1">range1:</span>
        <span class="s1">range1 = (</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">range2:</span>
        <span class="s1">range2 = (</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s1">)</span>

    <span class="s0"># If bounds don't intersect, go home</span>
    <span class="s1">intersects</span><span class="s3">, </span><span class="s1">_ = sectRect(bounds1</span><span class="s3">, </span><span class="s1">bounds2)</span>
    <span class="s3">if not </span><span class="s1">intersects:</span>
        <span class="s3">return </span><span class="s1">[]</span>

    <span class="s3">def </span><span class="s1">midpoint(r):</span>
        <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">* (r[</span><span class="s5">0</span><span class="s1">] + r[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s0"># If they do overlap but they're tiny, approximate</span>
    <span class="s3">if </span><span class="s1">rectArea(bounds1) &lt; precision </span><span class="s3">and </span><span class="s1">rectArea(bounds2) &lt; precision:</span>
        <span class="s3">return </span><span class="s1">[(midpoint(range1)</span><span class="s3">, </span><span class="s1">midpoint(range2))]</span>

    <span class="s1">c11</span><span class="s3">, </span><span class="s1">c12 = _split_segment_at_t(curve1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">c11_range = (range1[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">midpoint(range1))</span>
    <span class="s1">c12_range = (midpoint(range1)</span><span class="s3">, </span><span class="s1">range1[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">c21</span><span class="s3">, </span><span class="s1">c22 = _split_segment_at_t(curve2</span><span class="s3">, </span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">c21_range = (range2[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">midpoint(range2))</span>
    <span class="s1">c22_range = (midpoint(range2)</span><span class="s3">, </span><span class="s1">range2[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s1">found = []</span>
    <span class="s1">found.extend(</span>
        <span class="s1">_curve_curve_intersections_t(</span>
            <span class="s1">c11</span><span class="s3">, </span><span class="s1">c21</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">range1=c11_range</span><span class="s3">, </span><span class="s1">range2=c21_range</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">found.extend(</span>
        <span class="s1">_curve_curve_intersections_t(</span>
            <span class="s1">c12</span><span class="s3">, </span><span class="s1">c21</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">range1=c12_range</span><span class="s3">, </span><span class="s1">range2=c21_range</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">found.extend(</span>
        <span class="s1">_curve_curve_intersections_t(</span>
            <span class="s1">c11</span><span class="s3">, </span><span class="s1">c22</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">range1=c11_range</span><span class="s3">, </span><span class="s1">range2=c22_range</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">found.extend(</span>
        <span class="s1">_curve_curve_intersections_t(</span>
            <span class="s1">c12</span><span class="s3">, </span><span class="s1">c22</span><span class="s3">, </span><span class="s1">precision</span><span class="s3">, </span><span class="s1">range1=c12_range</span><span class="s3">, </span><span class="s1">range2=c22_range</span>
        <span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">unique_key = </span><span class="s3">lambda </span><span class="s1">ts: (int(ts[</span><span class="s5">0</span><span class="s1">] / precision)</span><span class="s3">, </span><span class="s1">int(ts[</span><span class="s5">1</span><span class="s1">] / precision))</span>
    <span class="s1">seen = set()</span>
    <span class="s1">unique_values = []</span>

    <span class="s3">for </span><span class="s1">ts </span><span class="s3">in </span><span class="s1">found:</span>
        <span class="s1">key = unique_key(ts)</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">seen:</span>
            <span class="s3">continue</span>
        <span class="s1">seen.add(key)</span>
        <span class="s1">unique_values.append(ts)</span>

    <span class="s3">return </span><span class="s1">unique_values</span>


<span class="s3">def </span><span class="s1">curveCurveIntersections(curve1</span><span class="s3">, </span><span class="s1">curve2):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between a curve and a curve. 
 
    Args: 
        curve1: List of coordinates of the first curve segment as 2D tuples. 
        curve2: List of coordinates of the second curve segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve1 = [ (10,100), (90,30), (40,140), (220,220) ] 
        &gt;&gt;&gt; curve2 = [ (5,150), (180,20), (80,250), (210,190) ] 
        &gt;&gt;&gt; intersections = curveCurveIntersections(curve1, curve2) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (81.7831487395506, 109.88904552375288) 
    &quot;&quot;&quot;</span>
    <span class="s1">intersection_ts = _curve_curve_intersections_t(curve1</span><span class="s3">, </span><span class="s1">curve2)</span>
    <span class="s3">return </span><span class="s1">[</span>
        <span class="s1">Intersection(pt=segmentPointAtT(curve1</span><span class="s3">, </span><span class="s1">ts[</span><span class="s5">0</span><span class="s1">])</span><span class="s3">, </span><span class="s1">t1=ts[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">t2=ts[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s3">for </span><span class="s1">ts </span><span class="s3">in </span><span class="s1">intersection_ts</span>
    <span class="s1">]</span>


<span class="s3">def </span><span class="s1">segmentSegmentIntersections(seg1</span><span class="s3">, </span><span class="s1">seg2):</span>
    <span class="s2">&quot;&quot;&quot;Finds intersections between two segments. 
 
    Args: 
        seg1: List of coordinates of the first segment as 2D tuples. 
        seg2: List of coordinates of the second segment as 2D tuples. 
 
    Returns: 
        A list of ``Intersection`` objects, each object having ``pt``, ``t1`` 
        and ``t2`` attributes containing the intersection point, time on first 
        segment and time on second segment respectively. 
 
    Examples:: 
        &gt;&gt;&gt; curve1 = [ (10,100), (90,30), (40,140), (220,220) ] 
        &gt;&gt;&gt; curve2 = [ (5,150), (180,20), (80,250), (210,190) ] 
        &gt;&gt;&gt; intersections = segmentSegmentIntersections(curve1, curve2) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (81.7831487395506, 109.88904552375288) 
        &gt;&gt;&gt; curve3 = [ (100, 240), (30, 60), (210, 230), (160, 30) ] 
        &gt;&gt;&gt; line  = [ (25, 260), (230, 20) ] 
        &gt;&gt;&gt; intersections = segmentSegmentIntersections(curve3, line) 
        &gt;&gt;&gt; len(intersections) 
        3 
        &gt;&gt;&gt; intersections[0].pt 
        (84.9000930760723, 189.87306176459828) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Arrange by degree</span>
    <span class="s1">swapped = </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">len(seg2) &gt; len(seg1):</span>
        <span class="s1">seg2</span><span class="s3">, </span><span class="s1">seg1 = seg1</span><span class="s3">, </span><span class="s1">seg2</span>
        <span class="s1">swapped = </span><span class="s3">True</span>
    <span class="s3">if </span><span class="s1">len(seg1) &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">len(seg2) &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">intersections = curveCurveIntersections(seg1</span><span class="s3">, </span><span class="s1">seg2)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">intersections = curveLineIntersections(seg1</span><span class="s3">, </span><span class="s1">seg2)</span>
    <span class="s3">elif </span><span class="s1">len(seg1) == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">len(seg2) == </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">intersections = lineLineIntersections(*seg1</span><span class="s3">, </span><span class="s1">*seg2)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Couldn't work out which intersection function to use&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">swapped:</span>
        <span class="s3">return </span><span class="s1">intersections</span>
    <span class="s3">return </span><span class="s1">[Intersection(pt=i.pt</span><span class="s3">, </span><span class="s1">t1=i.t2</span><span class="s3">, </span><span class="s1">t2=i.t1) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">intersections]</span>


<span class="s3">def </span><span class="s1">_segmentrepr(obj):</span>
    <span class="s2">&quot;&quot;&quot; 
    &gt;&gt;&gt; _segmentrepr([1, [2, 3], [], [[2, [3, 4], [0.1, 2.2]]]]) 
    '(1, (2, 3), (), ((2, (3, 4), (0.1, 2.2))))' 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">it = iter(obj)</span>
    <span class="s3">except </span><span class="s1">TypeError:</span>
        <span class="s3">return </span><span class="s4">&quot;%g&quot; </span><span class="s1">% obj</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s4">&quot;(%s)&quot; </span><span class="s1">% </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(_segmentrepr(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">it)</span>


<span class="s3">def </span><span class="s1">printSegments(segments):</span>
    <span class="s2">&quot;&quot;&quot;Helper for the doctests, displaying each segment in a list of 
    segments on a single line as a tuple. 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">segment </span><span class="s3">in </span><span class="s1">segments:</span>
        <span class="s1">print(_segmentrepr(segment))</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">sys</span>
    <span class="s3">import </span><span class="s1">doctest</span>

    <span class="s1">sys.exit(doctest.testmod().failed)</span>
</pre>
</body>
</html>