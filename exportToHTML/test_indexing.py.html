<html>
<head>
<title>test_indexing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #a5c261;}
.s6 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_indexing.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">operator</span>

<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.core._multiarray_tests </span><span class="s0">import </span><span class="s1">array_indexing</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_raises</span><span class="s0">, </span><span class="s1">assert_raises_regex</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_warns</span><span class="s0">, </span><span class="s1">HAS_REFCOUNT</span><span class="s0">, </span><span class="s1">IS_WASM</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestIndexing:</span>
    <span class="s0">def </span><span class="s1">test_index_no_floats(self):</span>
        <span class="s1">a = np.array([[[</span><span class="s2">5</span><span class="s1">]]])</span>

        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[-</span><span class="s2">1.4</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[-</span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[-</span><span class="s2">1.4</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[-</span><span class="s2">1.4</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[-</span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">:])</span>

    <span class="s0">def </span><span class="s1">test_slicing_no_floats(self):</span>
        <span class="s1">a = np.array([[</span><span class="s2">5</span><span class="s1">]])</span>

        <span class="s3"># start as float.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">:])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s1">:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">:</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">::</span><span class="s2">2</span><span class="s0">, </span><span class="s1">:</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0.0</span><span class="s1">:</span><span class="s2">1</span><span class="s1">:</span><span class="s2">2</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">:])</span>
        <span class="s3"># stop as float.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s2">0.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s2">0.0</span><span class="s1">:</span><span class="s2">2</span><span class="s0">, </span><span class="s1">:</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s2">0.0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">4.0</span><span class="s1">:</span><span class="s2">2</span><span class="s1">])</span>
        <span class="s3"># step as float.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[::</span><span class="s2">1.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">2</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">:</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[::</span><span class="s2">5.0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">:</span><span class="s2">4</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s3"># mixed.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">1.0</span><span class="s1">:</span><span class="s2">2</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">1.0</span><span class="s1">::</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">0</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">1.0</span><span class="s1">:</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4.0</span><span class="s0">, </span><span class="s1">:</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s2">1.0</span><span class="s1">:</span><span class="s2">5.0</span><span class="s1">:</span><span class="s2">5.0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[:</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">:</span><span class="s2">4.0</span><span class="s1">:</span><span class="s2">2.0</span><span class="s1">])</span>
        <span class="s3"># should still get the DeprecationWarning if step = 0.</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[::</span><span class="s2">0.0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_index_no_array_to_index(self):</span>
        <span class="s3"># No non-scalar arrays.</span>
        <span class="s1">a = np.array([[[</span><span class="s2">1</span><span class="s1">]]])</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: a[a:a:a])</span>

    <span class="s0">def </span><span class="s1">test_none_index(self):</span>
        <span class="s3"># `None` index adds newaxis</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a[np.newaxis])</span>
        <span class="s1">assert_equal(a[</span><span class="s0">None</span><span class="s1">].ndim</span><span class="s0">, </span><span class="s1">a.ndim + </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_empty_tuple_index(self):</span>
        <span class="s3"># Empty tuple index creates a view</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[()]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s1">assert_(a[()].base </span><span class="s0">is </span><span class="s1">a)</span>
        <span class="s1">a = np.array(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(a[()]</span><span class="s0">, </span><span class="s1">np.int_))</span>

    <span class="s0">def </span><span class="s1">test_void_scalar_empty_tuple(self):</span>
        <span class="s1">s = np.zeros(()</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">'V4'</span><span class="s1">)</span>
        <span class="s1">assert_equal(s[()].dtype</span><span class="s0">, </span><span class="s1">s.dtype)</span>
        <span class="s1">assert_equal(s[()]</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s1">assert_equal(type(s[...])</span><span class="s0">, </span><span class="s1">np.ndarray)</span>

    <span class="s0">def </span><span class="s1">test_same_kind_index_casting(self):</span>
        <span class="s3"># Indexes should be cast with same-kind and not safe, even if that</span>
        <span class="s3"># is somewhat unsafe. So test various different code paths.</span>
        <span class="s1">index = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">u_index = index.astype(np.uintp)</span>
        <span class="s1">arr = np.arange(</span><span class="s2">10</span><span class="s1">)</span>

        <span class="s1">assert_array_equal(arr[index]</span><span class="s0">, </span><span class="s1">arr[u_index])</span>
        <span class="s1">arr[u_index] = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s1">))</span>

        <span class="s1">arr = np.arange(</span><span class="s2">10</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr[index]</span><span class="s0">, </span><span class="s1">arr[u_index])</span>

        <span class="s1">arr[u_index] = np.arange(</span><span class="s2">5</span><span class="s1">)[:</span><span class="s0">,None</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">5</span><span class="s1">)[:</span><span class="s0">,None</span><span class="s1">].repeat(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">))</span>

        <span class="s1">arr = np.arange(</span><span class="s2">25</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr[u_index</span><span class="s0">, </span><span class="s1">u_index]</span><span class="s0">, </span><span class="s1">arr[index</span><span class="s0">, </span><span class="s1">index])</span>

    <span class="s0">def </span><span class="s1">test_empty_fancy_index(self):</span>
        <span class="s3"># Empty list index creates an empty array</span>
        <span class="s3"># with the same dtype (but with weird shape)</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[[]]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_equal(a[[]].dtype</span><span class="s0">, </span><span class="s1">a.dtype)</span>

        <span class="s1">b = np.array([]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">assert_equal(a[[]]</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_equal(a[[]].dtype</span><span class="s0">, </span><span class="s1">a.dtype)</span>

        <span class="s1">b = np.array([])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_ellipsis_index(self):</span>
        <span class="s1">a = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>
        <span class="s1">assert_(a[...] </span><span class="s0">is not </span><span class="s1">a)</span>
        <span class="s1">assert_equal(a[...]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s3"># `a[...]` was `a` in numpy &lt;1.9.</span>
        <span class="s1">assert_(a[...].base </span><span class="s0">is </span><span class="s1">a)</span>

        <span class="s3"># Slicing with ellipsis can skip an</span>
        <span class="s3"># arbitrary number of dimensions</span>
        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">0</span><span class="s0">,</span><span class="s1">:])</span>
        <span class="s1">assert_equal(a[...</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

        <span class="s3"># Slicing with ellipsis always results</span>
        <span class="s3"># in an array, not a scalar</span>
        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">...</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s2">2</span><span class="s1">))</span>

        <span class="s3"># Assignment with `(Ellipsis,)` on 0-d arrays</span>
        <span class="s1">b = np.array(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">b[(Ellipsis</span><span class="s0">,</span><span class="s1">)] = </span><span class="s2">2</span>
        <span class="s1">assert_equal(b</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single_int_index(self):</span>
        <span class="s3"># Single integer index selects one row</span>
        <span class="s1">a = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>

        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>

        <span class="s3"># Index out of bounds produces IndexError</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">&lt;&lt; </span><span class="s2">30</span><span class="s1">)</span>
        <span class="s3"># Index overflow produces IndexError</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">&lt;&lt; </span><span class="s2">64</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_single_bool_index(self):</span>
        <span class="s3"># Single boolean index</span>
        <span class="s1">a = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>

        <span class="s1">assert_equal(a[np.array(</span><span class="s0">True</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">a[</span><span class="s0">None</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[np.array(</span><span class="s0">False</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">a[</span><span class="s0">None</span><span class="s1">][</span><span class="s2">0</span><span class="s1">:</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_boolean_shape_mismatch(self):</span>
        <span class="s1">arr = np.ones((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>

        <span class="s1">index = np.array([</span><span class="s0">True</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">index)</span>

        <span class="s1">index = np.array([</span><span class="s0">False</span><span class="s1">] * </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">index)</span>

        <span class="s1">index = np.zeros((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">index)</span>

        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index))</span>

    <span class="s0">def </span><span class="s1">test_boolean_indexing_onedim(self):</span>
        <span class="s3"># Indexing a 2-dimensional array with</span>
        <span class="s3"># boolean array of length one</span>
        <span class="s1">a = np.array([[ </span><span class="s2">0.</span><span class="s0">,  </span><span class="s2">0.</span><span class="s0">,  </span><span class="s2">0.</span><span class="s1">]])</span>
        <span class="s1">b = np.array([ </span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_equal(a[b]</span><span class="s0">, </span><span class="s1">a)</span>
        <span class="s3"># boolean assignment</span>
        <span class="s1">a[b] = </span><span class="s2">1.</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_boolean_assignment_value_mismatch(self):</span>
        <span class="s3"># A boolean assignment should fail when the shape of the values</span>
        <span class="s3"># cannot be broadcast to the subscription. (see also gh-3458)</span>
        <span class="s1">a = np.arange(</span><span class="s2">4</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">f(a</span><span class="s0">, </span><span class="s1">v):</span>
            <span class="s1">a[a &gt; -</span><span class="s2">1</span><span class="s1">] = v</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a[:</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_boolean_assignment_needs_api(self):</span>
        <span class="s3"># See also gh-7666</span>
        <span class="s3"># This caused a segfault on Python 2 due to the GIL not being</span>
        <span class="s3"># held when the iterator does not need it, but the transfer function</span>
        <span class="s3"># does</span>
        <span class="s1">arr = np.zeros(</span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s1">indx = np.zeros(</span><span class="s2">1000</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">indx[:</span><span class="s2">100</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">arr[indx] = np.ones(</span><span class="s2">100</span><span class="s0">, </span><span class="s1">dtype=object)</span>

        <span class="s1">expected = np.zeros(</span><span class="s2">1000</span><span class="s1">)</span>
        <span class="s1">expected[:</span><span class="s2">100</span><span class="s1">] = </span><span class="s2">1</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_boolean_indexing_twodim(self):</span>
        <span class="s3"># Indexing a 2-dimensional array with</span>
        <span class="s3"># 2-dimensional boolean array</span>
        <span class="s1">a = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">]])</span>
        <span class="s1">b = np.array([[ </span><span class="s0">True, False,  True</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[</span><span class="s0">False,  True, False</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">[ </span><span class="s0">True, False,  True</span><span class="s1">]])</span>
        <span class="s1">assert_equal(a[b]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[b[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]])</span>
        <span class="s1">assert_equal(a[b[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">a[b[</span><span class="s2">2</span><span class="s1">]])</span>

        <span class="s3"># boolean assignment</span>
        <span class="s1">a[b] = </span><span class="s2">0</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_boolean_indexing_list(self):</span>
        <span class="s3"># Regression test for #13715. It's a use-after-free bug which the</span>
        <span class="s3"># test won't directly catch, but it will show up in valgrind.</span>
        <span class="s1">a = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">b = [</span><span class="s0">True, False, True</span><span class="s1">]</span>
        <span class="s3"># Two variants of the test because the first takes a fast path</span>
        <span class="s1">assert_equal(a[b]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">assert_equal(a[</span><span class="s0">None, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_reverse_strides_and_subspace_bufferinit(self):</span>
        <span class="s3"># This tests that the strides are not reversed for simple and</span>
        <span class="s3"># subspace fancy indexing.</span>
        <span class="s1">a = np.ones(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">b = np.zeros(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.intp)[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">c = np.arange(</span><span class="s2">5</span><span class="s1">)[::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">a[b] = c</span>
        <span class="s3"># If the strides are not reversed, the 0 in the arange comes last.</span>
        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s3"># This also tests that the subspace buffer is initialized:</span>
        <span class="s1">a = np.ones((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">c = np.arange(</span><span class="s2">10</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">a[b</span><span class="s0">, </span><span class="s1">:] = c</span>
        <span class="s1">assert_equal(a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_reversed_strides_result_allocation(self):</span>
        <span class="s3"># Test a bug when calculating the output strides for a result array</span>
        <span class="s3"># when the subspace size was 1 (and test other cases as well)</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s1">i = np.arange(</span><span class="s2">10</span><span class="s1">)[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(a[i]</span><span class="s0">, </span><span class="s1">a[i.copy(</span><span class="s4">'C'</span><span class="s1">)])</span>

        <span class="s1">a = np.arange(</span><span class="s2">20</span><span class="s1">).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_uncontiguous_subspace_assignment(self):</span>
        <span class="s3"># During development there was a bug activating a skip logic</span>
        <span class="s3"># based on ndim instead of size.</span>
        <span class="s1">a = np.full((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">b = np.full((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]] = np.arange(</span><span class="s2">2 </span><span class="s1">* </span><span class="s2">4 </span><span class="s1">* </span><span class="s2">2</span><span class="s1">).reshape(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">).T</span>
        <span class="s1">b[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]] = np.arange(</span><span class="s2">2 </span><span class="s1">* </span><span class="s2">4 </span><span class="s1">* </span><span class="s2">2</span><span class="s1">).reshape(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s1">).T.copy()</span>

        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_too_many_fancy_indices_special_case(self):</span>
        <span class="s3"># Just documents behaviour, this is a small limitation.</span>
        <span class="s1">a = np.ones((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">) * </span><span class="s2">32</span><span class="s1">)  </span><span class="s3"># 32 is NPY_MAXDIMS</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">(np.array([</span><span class="s2">0</span><span class="s1">])</span><span class="s0">,</span><span class="s1">) * </span><span class="s2">32</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_scalar_array_bool(self):</span>
        <span class="s3"># NumPy bools can be used as boolean index (python ones as of yet not)</span>
        <span class="s1">a = np.array(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a[np.bool_(</span><span class="s0">True</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">a[np.array(</span><span class="s0">True</span><span class="s1">)])</span>
        <span class="s1">assert_equal(a[np.bool_(</span><span class="s0">False</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">a[np.array(</span><span class="s0">False</span><span class="s1">)])</span>

        <span class="s3"># After deprecating bools as integers:</span>
        <span class="s3">#a = np.array([0,1,2])</span>
        <span class="s3">#assert_equal(a[True, :], a[None, :])</span>
        <span class="s3">#assert_equal(a[:, True], a[:, None])</span>
        <span class="s3">#</span>
        <span class="s3">#assert_(not np.may_share_memory(a, a[True, :]))</span>

    <span class="s0">def </span><span class="s1">test_everything_returns_views(self):</span>
        <span class="s3"># Before `...` would return a itself.</span>
        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">assert_(a </span><span class="s0">is not </span><span class="s1">a[()])</span>
        <span class="s1">assert_(a </span><span class="s0">is not </span><span class="s1">a[...])</span>
        <span class="s1">assert_(a </span><span class="s0">is not </span><span class="s1">a[:])</span>

    <span class="s0">def </span><span class="s1">test_broaderrors_indexing(self):</span>
        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__setitem__</span><span class="s0">, </span><span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_trivial_fancy_out_of_bounds(self):</span>
        <span class="s1">a = np.zeros(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">ind = np.ones(</span><span class="s2">20</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">ind[-</span><span class="s2">1</span><span class="s1">] = </span><span class="s2">10</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">ind)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__setitem__</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">ind = np.ones(</span><span class="s2">20</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">ind[</span><span class="s2">0</span><span class="s1">] = </span><span class="s2">11</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">ind)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__setitem__</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_trivial_fancy_not_possible(self):</span>
        <span class="s3"># Test that the fast path for trivial assignment is not incorrectly</span>
        <span class="s3"># used when the index is not contiguous or 1D, see also gh-11467.</span>
        <span class="s1">a = np.arange(</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">idx = np.arange(</span><span class="s2">6</span><span class="s0">, </span><span class="s1">dtype=np.intp).reshape(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(a[idx]</span><span class="s0">, </span><span class="s1">idx)</span>

        <span class="s3"># this case must not go into the fast path, note that idx is</span>
        <span class="s3"># a non-contiuguous none 1D array here.</span>
        <span class="s1">a[idx] = -</span><span class="s2">1</span>
        <span class="s1">res = np.arange(</span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">res[</span><span class="s2">0</span><span class="s1">] = -</span><span class="s2">1</span>
        <span class="s1">res[</span><span class="s2">3</span><span class="s1">] = -</span><span class="s2">1</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">res)</span>

    <span class="s0">def </span><span class="s1">test_nonbaseclass_values(self):</span>
        <span class="s0">class </span><span class="s1">SubClass(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_finalize__(self</span><span class="s0">, </span><span class="s1">old):</span>
                <span class="s3"># Have array finalize do funny things</span>
                <span class="s1">self.fill(</span><span class="s2">99</span><span class="s1">)</span>

        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">s = a.copy().view(type=SubClass)</span>
        <span class="s1">s.fill(</span><span class="s2">1</span><span class="s1">)</span>

        <span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:] = s</span>
        <span class="s1">assert_((a == </span><span class="s2">1</span><span class="s1">).all())</span>

        <span class="s3"># Subspace is last, so transposing might want to finalize</span>
        <span class="s1">a[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]] = s</span>
        <span class="s1">assert_((a == </span><span class="s2">1</span><span class="s1">).all())</span>

        <span class="s1">a.fill(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">a[...] = s</span>
        <span class="s1">assert_((a == </span><span class="s2">1</span><span class="s1">).all())</span>

    <span class="s0">def </span><span class="s1">test_array_like_values(self):</span>
        <span class="s3"># Similar to the above test, but use a memoryview instead</span>
        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">s = np.arange(</span><span class="s2">25</span><span class="s0">, </span><span class="s1">dtype=np.float64).reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>

        <span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:] = memoryview(s)</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">a[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]] = memoryview(s)</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">a[...] = memoryview(s)</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">s)</span>

    <span class="s0">def </span><span class="s1">test_subclass_writeable(self):</span>
        <span class="s1">d = np.rec.array([(</span><span class="s4">'NGC1001'</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">'NGC1002'</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">'NGC1003'</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)]</span><span class="s0">,</span>
                         <span class="s1">dtype=[(</span><span class="s4">'target'</span><span class="s0">, </span><span class="s4">'S20'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">'V_mag'</span><span class="s0">, </span><span class="s4">'&gt;f4'</span><span class="s1">)])</span>
        <span class="s1">ind = np.array([</span><span class="s0">False,  True,  True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">assert_(d[ind].flags.writeable)</span>
        <span class="s1">ind = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_(d[ind].flags.writeable)</span>
        <span class="s1">assert_(d[...].flags.writeable)</span>
        <span class="s1">assert_(d[</span><span class="s2">0</span><span class="s1">].flags.writeable)</span>

    <span class="s0">def </span><span class="s1">test_memory_order(self):</span>
        <span class="s3"># This is not necessary to preserve. Memory layouts for</span>
        <span class="s3"># more complex indices are not as simple.</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">b = np.arange(</span><span class="s2">10</span><span class="s1">).reshape(</span><span class="s2">5</span><span class="s0">,</span><span class="s2">2</span><span class="s1">).T</span>
        <span class="s1">assert_(a[b].flags.f_contiguous)</span>

        <span class="s3"># Takes a different implementation branch:</span>
        <span class="s1">a = a.reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(a[b</span><span class="s0">, </span><span class="s2">0</span><span class="s1">].flags.f_contiguous)</span>

    <span class="s0">def </span><span class="s1">test_scalar_return_type(self):</span>
        <span class="s3"># Full scalar indices should return scalars and object</span>
        <span class="s3"># arrays should not call PyArray_Return on their items</span>
        <span class="s0">class </span><span class="s1">Zero:</span>
            <span class="s3"># The most basic valid indexing</span>
            <span class="s0">def </span><span class="s1">__index__(self):</span>
                <span class="s0">return </span><span class="s2">0</span>

        <span class="s1">z = Zero()</span>

        <span class="s0">class </span><span class="s1">ArrayLike:</span>
            <span class="s3"># Simple array, should behave like the array</span>
            <span class="s0">def </span><span class="s1">__array__(self):</span>
                <span class="s0">return </span><span class="s1">np.array(</span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">a = np.zeros(())</span>
        <span class="s1">assert_(isinstance(a[()]</span><span class="s0">, </span><span class="s1">np.float_))</span>
        <span class="s1">a = np.zeros(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(a[z]</span><span class="s0">, </span><span class="s1">np.float_))</span>
        <span class="s1">a = np.zeros((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_(isinstance(a[z</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">np.float_))</span>
        <span class="s1">assert_(isinstance(a[z</span><span class="s0">, </span><span class="s1">ArrayLike()]</span><span class="s0">, </span><span class="s1">np.float_))</span>

        <span class="s3"># And object arrays do not call it too often:</span>
        <span class="s1">b = np.array(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">a = np.array(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">a[()] = b</span>
        <span class="s1">assert_(isinstance(a[()]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">a = np.array([b</span><span class="s0">, None</span><span class="s1">])</span>
        <span class="s1">assert_(isinstance(a[z]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">a = np.array([[b</span><span class="s0">, None</span><span class="s1">]])</span>
        <span class="s1">assert_(isinstance(a[z</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s2">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">assert_(isinstance(a[z</span><span class="s0">, </span><span class="s1">ArrayLike()]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>

    <span class="s0">def </span><span class="s1">test_small_regressions(self):</span>
        <span class="s3"># Reference count of intp for index checks</span>
        <span class="s1">a = np.array([</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
            <span class="s1">refcount = sys.getrefcount(np.dtype(np.intp))</span>
        <span class="s3"># item setting always checks indices in separate function:</span>
        <span class="s1">a[np.array([</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)] = </span><span class="s2">1</span>
        <span class="s1">a[np.array([</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint8)] = </span><span class="s2">1</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__setitem__</span><span class="s0">,</span>
                      <span class="s1">np.array([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__setitem__</span><span class="s0">,</span>
                      <span class="s1">np.array([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
            <span class="s1">assert_equal(sys.getrefcount(np.dtype(np.intp))</span><span class="s0">, </span><span class="s1">refcount)</span>

    <span class="s0">def </span><span class="s1">test_unaligned(self):</span>
        <span class="s1">v = (np.zeros(</span><span class="s2">64</span><span class="s0">, </span><span class="s1">dtype=np.int8) + ord(</span><span class="s4">'a'</span><span class="s1">))[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">7</span><span class="s1">]</span>
        <span class="s1">d = v.view(np.dtype(</span><span class="s4">&quot;S8&quot;</span><span class="s1">))</span>
        <span class="s3"># unaligned source</span>
        <span class="s1">x = (np.zeros(</span><span class="s2">16</span><span class="s0">, </span><span class="s1">dtype=np.int8) + ord(</span><span class="s4">'a'</span><span class="s1">))[</span><span class="s2">1</span><span class="s1">:-</span><span class="s2">7</span><span class="s1">]</span>
        <span class="s1">x = x.view(np.dtype(</span><span class="s4">&quot;S8&quot;</span><span class="s1">))</span>
        <span class="s1">x[...] = np.array(</span><span class="s4">&quot;b&quot; </span><span class="s1">* </span><span class="s2">8</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;S&quot;</span><span class="s1">)</span>
        <span class="s1">b = np.arange(d.size)</span>
        <span class="s3">#trivial</span>
        <span class="s1">assert_equal(d[b]</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s1">d[b] = x</span>
        <span class="s3"># nontrivial</span>
        <span class="s3"># unaligned index array</span>
        <span class="s1">b = np.zeros(d.size + </span><span class="s2">1</span><span class="s1">).view(np.int8)[</span><span class="s2">1</span><span class="s1">:-(np.intp(</span><span class="s2">0</span><span class="s1">).itemsize - </span><span class="s2">1</span><span class="s1">)]</span>
        <span class="s1">b = b.view(np.intp)[:d.size]</span>
        <span class="s1">b[...] = np.arange(d.size)</span>
        <span class="s1">assert_equal(d[b.astype(np.int16)]</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s1">d[b.astype(np.int16)] = x</span>
        <span class="s3"># boolean</span>
        <span class="s1">d[b % </span><span class="s2">2 </span><span class="s1">== </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">d[b % </span><span class="s2">2 </span><span class="s1">== </span><span class="s2">0</span><span class="s1">] = x[::</span><span class="s2">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_tuple_subclass(self):</span>
        <span class="s1">arr = np.ones((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>

        <span class="s3"># A tuple subclass should also be an nd-index</span>
        <span class="s0">class </span><span class="s1">TupleSubclass(tuple):</span>
            <span class="s0">pass</span>
        <span class="s1">index = ([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">index = TupleSubclass(index)</span>
        <span class="s1">assert_(arr[index].shape == (</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s3"># Unlike the non nd-index:</span>
        <span class="s1">assert_(arr[index</span><span class="s0">,</span><span class="s1">].shape != (</span><span class="s2">1</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_broken_sequence_not_nd_index(self):</span>
        <span class="s3"># See gh-5063:</span>
        <span class="s3"># If we have an object which claims to be a sequence, but fails</span>
        <span class="s3"># on item getting, this should not be converted to an nd-index (tuple)</span>
        <span class="s3"># If this object happens to be a valid index otherwise, it should work</span>
        <span class="s3"># This object here is very dubious and probably bad though:</span>
        <span class="s0">class </span><span class="s1">SequenceLike:</span>
            <span class="s0">def </span><span class="s1">__index__(self):</span>
                <span class="s0">return </span><span class="s2">0</span>

            <span class="s0">def </span><span class="s1">__len__(self):</span>
                <span class="s0">return </span><span class="s2">1</span>

            <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item):</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s4">'Not possible'</span><span class="s1">)</span>

        <span class="s1">arr = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(arr[SequenceLike()]</span><span class="s0">, </span><span class="s1">arr[SequenceLike()</span><span class="s0">,</span><span class="s1">])</span>

        <span class="s3"># also test that field indexing does not segfault</span>
        <span class="s3"># for a similar reason, by indexing a structured array</span>
        <span class="s1">arr = np.zeros((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s4">'f1'</span><span class="s0">, </span><span class="s4">'i8'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">'f2'</span><span class="s0">, </span><span class="s4">'i8'</span><span class="s1">)])</span>
        <span class="s1">assert_array_equal(arr[SequenceLike()]</span><span class="s0">, </span><span class="s1">arr[SequenceLike()</span><span class="s0">,</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_indexing_array_weird_strides(self):</span>
        <span class="s3"># See also gh-6221</span>
        <span class="s3"># the shapes used here come from the issue and create the correct</span>
        <span class="s3"># size for the iterator buffering size.</span>
        <span class="s1">x = np.ones(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">x2 = np.ones((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">ind = np.arange(</span><span class="s2">10</span><span class="s1">)[:</span><span class="s0">, None, None, None</span><span class="s1">]</span>
        <span class="s1">ind = np.broadcast_to(ind</span><span class="s0">, </span><span class="s1">(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">55</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>

        <span class="s3"># single advanced index case</span>
        <span class="s1">assert_array_equal(x[ind]</span><span class="s0">, </span><span class="s1">x[ind.copy()])</span>
        <span class="s3"># higher dimensional advanced index</span>
        <span class="s1">zind = np.zeros(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s1">assert_array_equal(x2[ind</span><span class="s0">, </span><span class="s1">zind]</span><span class="s0">, </span><span class="s1">x2[ind.copy()</span><span class="s0">, </span><span class="s1">zind])</span>

    <span class="s0">def </span><span class="s1">test_indexing_array_negative_strides(self):</span>
        <span class="s3"># From gh-8264,</span>
        <span class="s3"># core dumps if negative strides are used in iteration</span>
        <span class="s1">arro = np.zeros((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
        <span class="s1">arr = arro[::-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">::-</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">slices = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
        <span class="s1">arr[slices] = </span><span class="s2">10</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s2">10.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_character_assignment(self):</span>
        <span class="s3"># This is an example a function going through CopyObject which</span>
        <span class="s3"># used to have an untested special path for scalars</span>
        <span class="s3"># (the character special dtype case, should be deprecated probably)</span>
        <span class="s1">arr = np.zeros((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
        <span class="s1">arr[</span><span class="s2">0</span><span class="s1">] = np.str_(</span><span class="s4">&quot;asdfg&quot;</span><span class="s1">)  </span><span class="s3"># must assign as a sequence</span>
        <span class="s1">assert_array_equal(arr[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s4">&quot;asdfg&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;c&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">arr[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] == </span><span class="s5">b&quot;s&quot;  </span><span class="s3"># make sure not all were set to &quot;a&quot; for both</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;index&quot;</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s0">True, False, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s1">])])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;num&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">32</span><span class="s0">, </span><span class="s2">40</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;original_ndim&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">32</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_too_many_advanced_indices(self</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">original_ndim):</span>
        <span class="s3"># These are limitations based on the number of arguments we can process.</span>
        <span class="s3"># For `num=32` (and all boolean cases), the result is actually define;</span>
        <span class="s3"># but the use of NpyIter (NPY_MAXARGS) limits it for technical reasons.</span>
        <span class="s1">arr = np.ones((</span><span class="s2">1</span><span class="s0">,</span><span class="s1">) * original_ndim)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(IndexError):</span>
            <span class="s1">arr[(index</span><span class="s0">,</span><span class="s1">) * num]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(IndexError):</span>
            <span class="s1">arr[(index</span><span class="s0">,</span><span class="s1">) * num] = </span><span class="s2">1.</span>

    <span class="s1">@pytest.mark.skipif(IS_WASM</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;no threading&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_structured_advanced_indexing(self):</span>
        <span class="s3"># Test that copyswap(n) used by integer array indexing is threadsafe</span>
        <span class="s3"># for structured datatypes, see gh-15387. This test can behave randomly.</span>
        <span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ThreadPoolExecutor</span>

        <span class="s3"># Create a deeply nested dtype to make a failure more likely:</span>
        <span class="s1">dt = np.dtype([(</span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s4">&quot;f8&quot;</span><span class="s1">)])</span>
        <span class="s1">dt = np.dtype([(</span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">dt)] * </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">dt = np.dtype([(</span><span class="s4">&quot;&quot;</span><span class="s0">, </span><span class="s1">dt)] * </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s3"># The array should be large enough to likely run into threading issues</span>
        <span class="s1">arr = np.random.uniform(size=(</span><span class="s2">6000</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)).view(dt)[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>

        <span class="s1">rng = np.random.default_rng()</span>
        <span class="s0">def </span><span class="s1">func(arr):</span>
            <span class="s1">indx = rng.integers(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">len(arr)</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">6000</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s1">arr[indx]</span>

        <span class="s1">tpe = ThreadPoolExecutor(max_workers=</span><span class="s2">8</span><span class="s1">)</span>
        <span class="s1">futures = [tpe.submit(func</span><span class="s0">, </span><span class="s1">arr) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">10</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">futures:</span>
            <span class="s1">f.result()</span>

        <span class="s0">assert </span><span class="s1">arr.dtype </span><span class="s0">is </span><span class="s1">dt</span>

    <span class="s0">def </span><span class="s1">test_nontuple_ndindex(self):</span>
        <span class="s1">a = np.arange(</span><span class="s2">25</span><span class="s1">).reshape((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">assert_equal(a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.array([a[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a[</span><span class="s2">1</span><span class="s1">]]))</span>
        <span class="s1">assert_equal(a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">[slice(</span><span class="s0">None</span><span class="s1">)])</span>


<span class="s0">class </span><span class="s1">TestFieldIndexing:</span>
    <span class="s0">def </span><span class="s1">test_scalar_return_type(self):</span>
        <span class="s3"># Field access on an array should return an array, even if it</span>
        <span class="s3"># is 0-d.</span>
        <span class="s1">a = np.zeros(()</span><span class="s0">, </span><span class="s1">[(</span><span class="s4">'a'</span><span class="s0">,</span><span class="s4">'f8'</span><span class="s1">)])</span>
        <span class="s1">assert_(isinstance(a[</span><span class="s4">'a'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>
        <span class="s1">assert_(isinstance(a[[</span><span class="s4">'a'</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.ndarray))</span>


<span class="s0">class </span><span class="s1">TestBroadcastedAssignments:</span>
    <span class="s0">def </span><span class="s1">assign(self</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">val):</span>
        <span class="s1">a[ind] = val</span>
        <span class="s0">return </span><span class="s1">a</span>

    <span class="s0">def </span><span class="s1">test_prepending_ones(self):</span>
        <span class="s1">a = np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

        <span class="s1">a[...] = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s3"># Fancy with subspace with and without transpose</span>
        <span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:] = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">a[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]] = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s3"># Fancy without subspace (with broadcasting)</span>
        <span class="s1">a[[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]] = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_prepend_not_one(self):</span>
        <span class="s1">assign = self.assign</span>
        <span class="s1">s_ = np.s_</span>
        <span class="s1">a = np.zeros(</span><span class="s2">5</span><span class="s1">)</span>

        <span class="s3"># Too large and not only ones.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[...]</span><span class="s0">,  </span><span class="s1">np.ones((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">2</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">1</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">test_simple_broadcasting_errors(self):</span>
        <span class="s1">assign = self.assign</span>
        <span class="s1">s_ = np.s_</span>
        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[...]</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[...]</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">s_[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;index&quot;</span><span class="s0">, </span><span class="s1">[</span>
            <span class="s1">(...</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">...</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(...</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])])</span>
    <span class="s0">def </span><span class="s1">test_broadcast_error_reports_correct_shape(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s1">values = np.zeros((</span><span class="s2">100</span><span class="s0">, </span><span class="s2">100</span><span class="s1">))  </span><span class="s3"># will never broadcast below  </span>

        <span class="s1">arr = np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s1">))</span>
        <span class="s3"># We currently report without any spaces (could be changed)</span>
        <span class="s1">shape_str = str(arr[index].shape).replace(</span><span class="s4">&quot; &quot;</span><span class="s0">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">arr[index] = values</span>

        <span class="s0">assert </span><span class="s1">str(e.value).endswith(shape_str)</span>

    <span class="s0">def </span><span class="s1">test_index_is_larger(self):</span>
        <span class="s3"># Simple case of fancy index broadcasting of the index.</span>
        <span class="s1">a = np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
        <span class="s1">a[[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]] = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>

        <span class="s1">assert_((a[:</span><span class="s2">3</span><span class="s0">, </span><span class="s1">:</span><span class="s2">3</span><span class="s1">] == [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]).all())</span>

    <span class="s0">def </span><span class="s1">test_broadcast_subspace(self):</span>
        <span class="s1">a = np.zeros((</span><span class="s2">100</span><span class="s0">, </span><span class="s2">100</span><span class="s1">))</span>
        <span class="s1">v = np.arange(</span><span class="s2">100</span><span class="s1">)[:</span><span class="s0">,None</span><span class="s1">]</span>
        <span class="s1">b = np.arange(</span><span class="s2">100</span><span class="s1">)[::-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">a[b] = v</span>
        <span class="s1">assert_((a[::-</span><span class="s2">1</span><span class="s1">] == v).all())</span>


<span class="s0">class </span><span class="s1">TestSubclasses:</span>
    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s3"># Test that indexing in various ways produces SubClass instances,</span>
        <span class="s3"># and that the base is set up correctly: the original subclass</span>
        <span class="s3"># instance for views, and a new ndarray for advanced/boolean indexing</span>
        <span class="s3"># where a copy was made (latter a regression test for gh-11983).</span>
        <span class="s0">class </span><span class="s1">SubClass(np.ndarray):</span>
            <span class="s0">pass</span>

        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">s = a.view(SubClass)</span>
        <span class="s1">s_slice = s[:</span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_(type(s_slice) </span><span class="s0">is </span><span class="s1">SubClass)</span>
        <span class="s1">assert_(s_slice.base </span><span class="s0">is </span><span class="s1">s)</span>
        <span class="s1">assert_array_equal(s_slice</span><span class="s0">, </span><span class="s1">a[:</span><span class="s2">3</span><span class="s1">])</span>

        <span class="s1">s_fancy = s[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
        <span class="s1">assert_(type(s_fancy) </span><span class="s0">is </span><span class="s1">SubClass)</span>
        <span class="s1">assert_(s_fancy.base </span><span class="s0">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(type(s_fancy.base) </span><span class="s0">is </span><span class="s1">np.ndarray)</span>
        <span class="s1">assert_array_equal(s_fancy</span><span class="s0">, </span><span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(s_fancy.base</span><span class="s0">, </span><span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>

        <span class="s1">s_bool = s[s &gt; </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_(type(s_bool) </span><span class="s0">is </span><span class="s1">SubClass)</span>
        <span class="s1">assert_(s_bool.base </span><span class="s0">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(type(s_bool.base) </span><span class="s0">is </span><span class="s1">np.ndarray)</span>
        <span class="s1">assert_array_equal(s_bool</span><span class="s0">, </span><span class="s1">a[a &gt; </span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(s_bool.base</span><span class="s0">, </span><span class="s1">a[a &gt; </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_fancy_on_read_only(self):</span>
        <span class="s3"># Test that fancy indexing on read-only SubClass does not make a</span>
        <span class="s3"># read-only copy (gh-14132)</span>
        <span class="s0">class </span><span class="s1">SubClass(np.ndarray):</span>
            <span class="s0">pass</span>

        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">s = a.view(SubClass)</span>
        <span class="s1">s.flags.writeable = </span><span class="s0">False</span>
        <span class="s1">s_fancy = s[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span>
        <span class="s1">assert_(s_fancy.flags.writeable)</span>


    <span class="s0">def </span><span class="s1">test_finalize_gets_full_info(self):</span>
        <span class="s3"># Array finalize should be called on the filled array.</span>
        <span class="s0">class </span><span class="s1">SubClass(np.ndarray):</span>
            <span class="s0">def </span><span class="s1">__array_finalize__(self</span><span class="s0">, </span><span class="s1">old):</span>
                <span class="s1">self.finalize_status = np.array(self)</span>
                <span class="s1">self.old = old</span>

        <span class="s1">s = np.arange(</span><span class="s2">10</span><span class="s1">).view(SubClass)</span>
        <span class="s1">new_s = s[:</span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(new_s.finalize_status</span><span class="s0">, </span><span class="s1">new_s)</span>
        <span class="s1">assert_array_equal(new_s.old</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">new_s = s[[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s1">]]</span>
        <span class="s1">assert_array_equal(new_s.finalize_status</span><span class="s0">, </span><span class="s1">new_s)</span>
        <span class="s1">assert_array_equal(new_s.old</span><span class="s0">, </span><span class="s1">s)</span>

        <span class="s1">new_s = s[s &gt; </span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(new_s.finalize_status</span><span class="s0">, </span><span class="s1">new_s)</span>
        <span class="s1">assert_array_equal(new_s.old</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s0">class </span><span class="s1">TestFancyIndexingCast:</span>
    <span class="s0">def </span><span class="s1">test_boolean_index_cast_assign(self):</span>
        <span class="s3"># Setup the boolean index and float arrays.</span>
        <span class="s1">shape = (</span><span class="s2">8</span><span class="s0">, </span><span class="s2">63</span><span class="s1">)</span>
        <span class="s1">bool_index = np.zeros(shape).astype(bool)</span>
        <span class="s1">bool_index[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s0">True</span>
        <span class="s1">zero_array = np.zeros(shape)</span>

        <span class="s3"># Assigning float is fine.</span>
        <span class="s1">zero_array[bool_index] = np.array([</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(zero_array[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s3"># Fancy indexing works, although we get a cast warning.</span>
        <span class="s1">assert_warns(np.ComplexWarning</span><span class="s0">,</span>
                     <span class="s1">zero_array.__setitem__</span><span class="s0">, </span><span class="s1">([</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">1j</span><span class="s1">]))</span>
        <span class="s1">assert_equal(zero_array[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)  </span><span class="s3"># No complex part</span>

        <span class="s3"># Cast complex to float, throwing away the imaginary portion.</span>
        <span class="s1">assert_warns(np.ComplexWarning</span><span class="s0">,</span>
                     <span class="s1">zero_array.__setitem__</span><span class="s0">, </span><span class="s1">bool_index</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1j</span><span class="s1">]))</span>
        <span class="s1">assert_equal(zero_array[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

<span class="s0">class </span><span class="s1">TestFancyIndexingEquivalence:</span>
    <span class="s0">def </span><span class="s1">test_object_assign(self):</span>
        <span class="s3"># Check that the field and object special case using copyto is active.</span>
        <span class="s3"># The right hand side cannot be converted to an array here.</span>
        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">b = a.copy()</span>
        <span class="s1">a[:</span><span class="s2">3</span><span class="s1">] = [</span><span class="s2">1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">b[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]] = [</span><span class="s2">1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s3"># test same for subspace fancy indexing</span>
        <span class="s1">b = np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=object)[</span><span class="s0">None, </span><span class="s1">:]</span>
        <span class="s1">b[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:</span><span class="s2">3</span><span class="s1">] = [[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s3"># Check that swapping of axes works.</span>
        <span class="s3"># There was a bug that made the later assignment throw a ValueError</span>
        <span class="s3"># do to an incorrectly transposed temporary right hand side (gh-5714)</span>
        <span class="s1">b = b.T</span>
        <span class="s1">b[:</span><span class="s2">3</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]] = [[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

        <span class="s3"># Another test for the memory order of the subspace</span>
        <span class="s1">arr = np.ones((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s3"># Equivalent slicing assignment for comparison</span>
        <span class="s1">cmp_arr = arr.copy()</span>
        <span class="s1">cmp_arr[:</span><span class="s2">1</span><span class="s0">, </span><span class="s1">...] = [[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">]]]</span>
        <span class="s1">arr[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">...] = [[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">]]]</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">cmp_arr)</span>
        <span class="s1">arr = arr.copy(</span><span class="s4">'F'</span><span class="s1">)</span>
        <span class="s1">arr[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">...] = [[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">]]]</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">cmp_arr)</span>

    <span class="s0">def </span><span class="s1">test_cast_equivalence(self):</span>
        <span class="s3"># Yes, normal slicing uses unsafe casting.</span>
        <span class="s1">a = np.arange(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">b = a.copy()</span>

        <span class="s1">a[:</span><span class="s2">3</span><span class="s1">] = np.array([</span><span class="s4">'2'</span><span class="s0">, </span><span class="s4">'-3'</span><span class="s0">, </span><span class="s4">'-1'</span><span class="s1">])</span>
        <span class="s1">b[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]] = np.array([</span><span class="s4">'2'</span><span class="s0">, </span><span class="s4">'-1'</span><span class="s0">, </span><span class="s4">'-3'</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s3"># test the same for subspace fancy indexing</span>
        <span class="s1">b = np.arange(</span><span class="s2">5</span><span class="s1">)[</span><span class="s0">None, </span><span class="s1">:]</span>
        <span class="s1">b[[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">:</span><span class="s2">3</span><span class="s1">] = np.array([[</span><span class="s4">'2'</span><span class="s0">, </span><span class="s4">'-3'</span><span class="s0">, </span><span class="s4">'-1'</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(a</span><span class="s0">, </span><span class="s1">b[</span><span class="s2">0</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestMultiIndexingAutomated:</span>
    <span class="s6">&quot;&quot;&quot; 
    These tests use code to mimic the C-Code indexing for selection. 
 
    NOTE: 
 
        * This still lacks tests for complex item setting. 
        * If you change behavior of indexing, you might want to modify 
          these tests to try more combinations. 
        * Behavior was written to match numpy version 1.8. (though a 
          first version matched 1.7.) 
        * Only tuple indices are supported by the mimicking code. 
          (and tested as of writing this) 
        * Error types should match most of the time as long as there 
          is only one error. For multiple errors, what gets raised 
          will usually not be the same one. They are *not* tested. 
 
    Update 2016-11-30: It is probably not worth maintaining this test 
    indefinitely and it can be dropped if maintenance becomes a burden. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.a = np.arange(np.prod([</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">])).reshape(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">)</span>
        <span class="s1">self.b = np.empty((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">))</span>
        <span class="s1">self.complex_indices = [</span><span class="s4">'skip'</span><span class="s0">, </span><span class="s1">Ellipsis</span><span class="s0">,</span>
            <span class="s2">0</span><span class="s0">,</span>
            <span class="s3"># Boolean indices, up to 3-d for some special cases of eating up</span>
            <span class="s3"># dimensions, also need to test all False</span>
            <span class="s1">np.array([</span><span class="s0">True, False, False</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s0">True, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">np.array([[[</span><span class="s0">False, False</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, False</span><span class="s1">]]])</span><span class="s0">,</span>
            <span class="s3"># Some slices:</span>
            <span class="s1">slice(-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s3"># Some Fancy indexes:</span>
            <span class="s1">np.empty((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span><span class="s0">,  </span><span class="s3"># empty and can be broadcast</span>
            <span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.dtype(</span><span class="s4">'intp'</span><span class="s1">).newbyteorder())</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span><span class="s0">,</span>
            <span class="s1">np.zeros([</span><span class="s2">1</span><span class="s1">]*</span><span class="s2">31</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,  </span><span class="s3"># trigger too large array.</span>
            <span class="s1">np.array([</span><span class="s2">0.</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">])]  </span><span class="s3"># invalid datatype</span>
        <span class="s3"># Some simpler indices that still cover a bit more</span>
        <span class="s1">self.simple_indices = [Ellipsis</span><span class="s0">, None, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s0">True</span><span class="s1">])</span><span class="s0">,</span>
                               <span class="s4">'skip'</span><span class="s1">]</span>
        <span class="s3"># Very simple ones to fill the rest:</span>
        <span class="s1">self.fill_indices = [slice(</span><span class="s0">None, None</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_get_multi_index(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">indices):</span>
        <span class="s6">&quot;&quot;&quot;Mimic multi dimensional indexing. 
 
        Parameters 
        ---------- 
        arr : ndarray 
            Array to be indexed. 
        indices : tuple of index objects 
 
        Returns 
        ------- 
        out : ndarray 
            An array equivalent to the indexing operation (but always a copy). 
            `arr[indices]` should be identical. 
        no_copy : bool 
            Whether the indexing operation requires a copy. If this is `True`, 
            `np.may_share_memory(arr, arr[indices])` should be `True` (with 
            some exceptions for scalars and possibly 0-d arrays). 
 
        Notes 
        ----- 
        While the function may mostly match the errors of normal indexing this 
        is generally not the case. 
        &quot;&quot;&quot;</span>
        <span class="s1">in_indices = list(indices)</span>
        <span class="s1">indices = []</span>
        <span class="s3"># if False, this is a fancy or boolean index</span>
        <span class="s1">no_copy = </span><span class="s0">True</span>
        <span class="s3"># number of fancy/scalar indexes that are not consecutive</span>
        <span class="s1">num_fancy = </span><span class="s2">0</span>
        <span class="s3"># number of dimensions indexed by a &quot;fancy&quot; index</span>
        <span class="s1">fancy_dim = </span><span class="s2">0</span>
        <span class="s3"># NOTE: This is a funny twist (and probably OK to change).</span>
        <span class="s3"># The boolean array has illegal indexes, but this is</span>
        <span class="s3"># allowed if the broadcast fancy-indices are 0-sized.</span>
        <span class="s3"># This variable is to catch that case.</span>
        <span class="s1">error_unless_broadcast_to_empty = </span><span class="s0">False</span>

        <span class="s3"># We need to handle Ellipsis and make arrays from indices, also</span>
        <span class="s3"># check if this is fancy indexing (set no_copy).</span>
        <span class="s1">ndim = </span><span class="s2">0</span>
        <span class="s1">ellipsis_pos = </span><span class="s0">None  </span><span class="s3"># define here mostly to replace all but first.</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">indx </span><span class="s0">in </span><span class="s1">enumerate(in_indices):</span>
            <span class="s0">if </span><span class="s1">indx </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">isinstance(indx</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">indx.dtype == bool:</span>
                <span class="s1">no_copy = </span><span class="s0">False</span>
                <span class="s0">if </span><span class="s1">indx.ndim == </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>
                <span class="s3"># boolean indices can have higher dimensions</span>
                <span class="s1">ndim += indx.ndim</span>
                <span class="s1">fancy_dim += indx.ndim</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">indx </span><span class="s0">is </span><span class="s1">Ellipsis:</span>
                <span class="s0">if </span><span class="s1">ellipsis_pos </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">ellipsis_pos = i</span>
                    <span class="s0">continue  </span><span class="s3"># do not increment ndim counter</span>
                <span class="s0">raise </span><span class="s1">IndexError</span>
            <span class="s0">if </span><span class="s1">isinstance(indx</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">ndim += </span><span class="s2">1</span>
                <span class="s0">continue</span>
            <span class="s0">if not </span><span class="s1">isinstance(indx</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s3"># This could be open for changes in numpy.</span>
                <span class="s3"># numpy should maybe raise an error if casting to intp</span>
                <span class="s3"># is not safe. It rejects np.array([1., 2.]) but not</span>
                <span class="s3"># [1., 2.] as index (same for ie. np.take).</span>
                <span class="s3"># (Note the importance of empty lists if changing this here)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">indx = np.array(indx</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>
                <span class="s1">in_indices[i] = indx</span>
            <span class="s0">elif </span><span class="s1">indx.dtype.kind != </span><span class="s4">'b' </span><span class="s0">and </span><span class="s1">indx.dtype.kind != </span><span class="s4">'i'</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s4">'arrays used as indices must be of '</span>
                                 <span class="s4">'integer (or boolean) type'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">indx.ndim != </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s1">no_copy = </span><span class="s0">False</span>
            <span class="s1">ndim += </span><span class="s2">1</span>
            <span class="s1">fancy_dim += </span><span class="s2">1</span>

        <span class="s0">if </span><span class="s1">arr.ndim - ndim &lt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s3"># we can't take more dimensions then we have, not even for 0-d</span>
            <span class="s3"># arrays.  since a[()] makes sense, but not a[(),]. We will</span>
            <span class="s3"># raise an error later on, unless a broadcasting error occurs</span>
            <span class="s3"># first.</span>
            <span class="s0">raise </span><span class="s1">IndexError</span>

        <span class="s0">if </span><span class="s1">ndim == </span><span class="s2">0 </span><span class="s0">and None not in </span><span class="s1">in_indices:</span>
            <span class="s3"># Well we have no indexes or one Ellipsis. This is legal.</span>
            <span class="s0">return </span><span class="s1">arr.copy()</span><span class="s0">, </span><span class="s1">no_copy</span>

        <span class="s0">if </span><span class="s1">ellipsis_pos </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">in_indices[ellipsis_pos:ellipsis_pos+</span><span class="s2">1</span><span class="s1">] = ([slice(</span><span class="s0">None, None</span><span class="s1">)] *</span>
                                                       <span class="s1">(arr.ndim - ndim))</span>

        <span class="s0">for </span><span class="s1">ax</span><span class="s0">, </span><span class="s1">indx </span><span class="s0">in </span><span class="s1">enumerate(in_indices):</span>
            <span class="s0">if </span><span class="s1">isinstance(indx</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s3"># convert to an index array</span>
                <span class="s1">indx = np.arange(*indx.indices(arr.shape[ax]))</span>
                <span class="s1">indices.append([</span><span class="s4">'s'</span><span class="s0">, </span><span class="s1">indx])</span>
                <span class="s0">continue</span>
            <span class="s0">elif </span><span class="s1">indx </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s3"># this is like taking a slice with one element from a new axis:</span>
                <span class="s1">indices.append([</span><span class="s4">'n'</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp)])</span>
                <span class="s1">arr = arr.reshape((arr.shape[:ax] + (</span><span class="s2">1</span><span class="s0">,</span><span class="s1">) + arr.shape[ax:]))</span>
                <span class="s0">continue</span>
            <span class="s0">if </span><span class="s1">isinstance(indx</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">indx.dtype == bool:</span>
                <span class="s0">if </span><span class="s1">indx.shape != arr.shape[ax:ax+indx.ndim]:</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">flat_indx = np.ravel_multi_index(np.nonzero(indx)</span><span class="s0">,</span>
                                    <span class="s1">arr.shape[ax:ax+indx.ndim]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">'raise'</span><span class="s1">)</span>
                <span class="s0">except </span><span class="s1">Exception:</span>
                    <span class="s1">error_unless_broadcast_to_empty = </span><span class="s0">True</span>
                    <span class="s3"># fill with 0s instead, and raise error later</span>
                    <span class="s1">flat_indx = np.array([</span><span class="s2">0</span><span class="s1">]*indx.sum()</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
                <span class="s3"># concatenate axis into a single one:</span>
                <span class="s0">if </span><span class="s1">indx.ndim != </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s1">arr = arr.reshape((arr.shape[:ax]</span>
                                  <span class="s1">+ (np.prod(arr.shape[ax:ax+indx.ndim])</span><span class="s0">,</span><span class="s1">)</span>
                                  <span class="s1">+ arr.shape[ax+indx.ndim:]))</span>
                    <span class="s1">indx = flat_indx</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># This could be changed, a 0-d boolean index can</span>
                    <span class="s3"># make sense (even outside the 0-d indexed array case)</span>
                    <span class="s3"># Note that originally this is could be interpreted as</span>
                    <span class="s3"># integer in the full integer special case.</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># If the index is a singleton, the bounds check is done</span>
                <span class="s3"># before the broadcasting. This used to be different in &lt;1.9</span>
                <span class="s0">if </span><span class="s1">indx.ndim == </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">indx &gt;= arr.shape[ax] </span><span class="s0">or </span><span class="s1">indx &lt; -arr.shape[ax]:</span>
                        <span class="s0">raise </span><span class="s1">IndexError</span>
            <span class="s0">if </span><span class="s1">indx.ndim == </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s3"># The index is a scalar. This used to be two fold, but if</span>
                <span class="s3"># fancy indexing was active, the check was done later,</span>
                <span class="s3"># possibly after broadcasting it away (1.7. or earlier).</span>
                <span class="s3"># Now it is always done.</span>
                <span class="s0">if </span><span class="s1">indx &gt;= arr.shape[ax] </span><span class="s0">or </span><span class="s1">indx &lt; - arr.shape[ax]:</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>
            <span class="s0">if </span><span class="s1">(len(indices) &gt; </span><span class="s2">0 </span><span class="s0">and</span>
                    <span class="s1">indices[-</span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">] == </span><span class="s4">'f' </span><span class="s0">and</span>
                    <span class="s1">ax != ellipsis_pos):</span>
                <span class="s3"># NOTE: There could still have been a 0-sized Ellipsis</span>
                <span class="s3"># between them. Checked that with ellipsis_pos.</span>
                <span class="s1">indices[-</span><span class="s2">1</span><span class="s1">].append(indx)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># We have a fancy index that is not after an existing one.</span>
                <span class="s3"># NOTE: A 0-d array triggers this as well, while one may</span>
                <span class="s3"># expect it to not trigger it, since a scalar would not be</span>
                <span class="s3"># considered fancy indexing.</span>
                <span class="s1">num_fancy += </span><span class="s2">1</span>
                <span class="s1">indices.append([</span><span class="s4">'f'</span><span class="s0">, </span><span class="s1">indx])</span>

        <span class="s0">if </span><span class="s1">num_fancy &gt; </span><span class="s2">1 </span><span class="s0">and not </span><span class="s1">no_copy:</span>
            <span class="s3"># We have to flush the fancy indexes left</span>
            <span class="s1">new_indices = indices[:]</span>
            <span class="s1">axes = list(range(arr.ndim))</span>
            <span class="s1">fancy_axes = []</span>
            <span class="s1">new_indices.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'f'</span><span class="s1">])</span>
            <span class="s1">ni = </span><span class="s2">0</span>
            <span class="s1">ai = </span><span class="s2">0</span>
            <span class="s0">for </span><span class="s1">indx </span><span class="s0">in </span><span class="s1">indices:</span>
                <span class="s1">ni += </span><span class="s2">1</span>
                <span class="s0">if </span><span class="s1">indx[</span><span class="s2">0</span><span class="s1">] == </span><span class="s4">'f'</span><span class="s1">:</span>
                    <span class="s1">new_indices[</span><span class="s2">0</span><span class="s1">].extend(indx[</span><span class="s2">1</span><span class="s1">:])</span>
                    <span class="s0">del </span><span class="s1">new_indices[ni]</span>
                    <span class="s1">ni -= </span><span class="s2">1</span>
                    <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(ai</span><span class="s0">, </span><span class="s1">ai + len(indx[</span><span class="s2">1</span><span class="s1">:])):</span>
                        <span class="s1">fancy_axes.append(ax)</span>
                        <span class="s1">axes.remove(ax)</span>
                <span class="s1">ai += len(indx) - </span><span class="s2">1  </span><span class="s3"># axis we are at</span>
            <span class="s1">indices = new_indices</span>
            <span class="s3"># and now we need to transpose arr:</span>
            <span class="s1">arr = arr.transpose(*(fancy_axes + axes))</span>

        <span class="s3"># We only have one 'f' index now and arr is transposed accordingly.</span>
        <span class="s3"># Now handle newaxis by reshaping...</span>
        <span class="s1">ax = </span><span class="s2">0</span>
        <span class="s0">for </span><span class="s1">indx </span><span class="s0">in </span><span class="s1">indices:</span>
            <span class="s0">if </span><span class="s1">indx[</span><span class="s2">0</span><span class="s1">] == </span><span class="s4">'f'</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">len(indx) == </span><span class="s2">1</span><span class="s1">:</span>
                    <span class="s0">continue</span>
                <span class="s3"># First of all, reshape arr to combine fancy axes into one:</span>
                <span class="s1">orig_shape = arr.shape</span>
                <span class="s1">orig_slice = orig_shape[ax:ax + len(indx[</span><span class="s2">1</span><span class="s1">:])]</span>
                <span class="s1">arr = arr.reshape((arr.shape[:ax]</span>
                                    <span class="s1">+ (np.prod(orig_slice).astype(int)</span><span class="s0">,</span><span class="s1">)</span>
                                    <span class="s1">+ arr.shape[ax + len(indx[</span><span class="s2">1</span><span class="s1">:]):]))</span>

                <span class="s3"># Check if broadcasting works</span>
                <span class="s1">res = np.broadcast(*indx[</span><span class="s2">1</span><span class="s1">:])</span>
                <span class="s3"># unfortunately the indices might be out of bounds. So check</span>
                <span class="s3"># that first, and use mode='wrap' then. However only if</span>
                <span class="s3"># there are any indices...</span>
                <span class="s0">if </span><span class="s1">res.size != </span><span class="s2">0</span><span class="s1">:</span>
                    <span class="s0">if </span><span class="s1">error_unless_broadcast_to_empty:</span>
                        <span class="s0">raise </span><span class="s1">IndexError</span>
                    <span class="s0">for </span><span class="s1">_indx</span><span class="s0">, </span><span class="s1">_size </span><span class="s0">in </span><span class="s1">zip(indx[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">orig_slice):</span>
                        <span class="s0">if </span><span class="s1">_indx.size == </span><span class="s2">0</span><span class="s1">:</span>
                            <span class="s0">continue</span>
                        <span class="s0">if </span><span class="s1">np.any(_indx &gt;= _size) </span><span class="s0">or </span><span class="s1">np.any(_indx &lt; -_size):</span>
                                <span class="s0">raise </span><span class="s1">IndexError</span>
                <span class="s0">if </span><span class="s1">len(indx[</span><span class="s2">1</span><span class="s1">:]) == len(orig_slice):</span>
                    <span class="s0">if </span><span class="s1">np.product(orig_slice) == </span><span class="s2">0</span><span class="s1">:</span>
                        <span class="s3"># Work around for a crash or IndexError with 'wrap'</span>
                        <span class="s3"># in some 0-sized cases.</span>
                        <span class="s0">try</span><span class="s1">:</span>
                            <span class="s1">mi = np.ravel_multi_index(indx[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">orig_slice</span><span class="s0">,</span>
                                                      <span class="s1">mode=</span><span class="s4">'raise'</span><span class="s1">)</span>
                        <span class="s0">except </span><span class="s1">Exception:</span>
                            <span class="s3"># This happens with 0-sized orig_slice (sometimes?)</span>
                            <span class="s3"># here it is a ValueError, but indexing gives a:</span>
                            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s4">'invalid index into 0-sized'</span><span class="s1">)</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s1">mi = np.ravel_multi_index(indx[</span><span class="s2">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">orig_slice</span><span class="s0">,</span>
                                                  <span class="s1">mode=</span><span class="s4">'wrap'</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># Maybe never happens...</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span>
                <span class="s1">arr = arr.take(mi.ravel()</span><span class="s0">, </span><span class="s1">axis=ax)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">arr = arr.reshape((arr.shape[:ax]</span>
                                        <span class="s1">+ mi.shape</span>
                                        <span class="s1">+ arr.shape[ax+</span><span class="s2">1</span><span class="s1">:]))</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s3"># too many dimensions, probably</span>
                    <span class="s0">raise </span><span class="s1">IndexError</span>
                <span class="s1">ax += mi.ndim</span>
                <span class="s0">continue</span>

            <span class="s3"># If we are here, we have a 1D array for take:</span>
            <span class="s1">arr = arr.take(indx[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axis=ax)</span>
            <span class="s1">ax += </span><span class="s2">1</span>

        <span class="s0">return </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">no_copy</span>

    <span class="s0">def </span><span class="s1">_check_multi_index(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s6">&quot;&quot;&quot;Check a multi index item getting and simple setting. 
 
        Parameters 
        ---------- 
        arr : ndarray 
            Array to be indexed, must be a reshaped arange. 
        index : tuple of indexing objects 
            Index being tested. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Test item getting</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">mimic_get</span><span class="s0">, </span><span class="s1">no_copy = self._get_multi_index(arr</span><span class="s0">, </span><span class="s1">index)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
                <span class="s1">prev_refcount = sys.getrefcount(arr)</span>
            <span class="s1">assert_raises(type(e)</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">index)</span>
            <span class="s1">assert_raises(type(e)</span><span class="s0">, </span><span class="s1">arr.__setitem__</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
                <span class="s1">assert_equal(prev_refcount</span><span class="s0">, </span><span class="s1">sys.getrefcount(arr))</span>
            <span class="s0">return</span>

        <span class="s1">self._compare_index_result(arr</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">mimic_get</span><span class="s0">, </span><span class="s1">no_copy)</span>

    <span class="s0">def </span><span class="s1">_check_single_index(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s6">&quot;&quot;&quot;Check a single index item getting and simple setting. 
 
        Parameters 
        ---------- 
        arr : ndarray 
            Array to be indexed, must be an arange. 
        index : indexing object 
            Index being tested. Must be a single index and not a tuple 
            of indexing objects (see also `_check_multi_index`). 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">mimic_get</span><span class="s0">, </span><span class="s1">no_copy = self._get_multi_index(arr</span><span class="s0">, </span><span class="s1">(index</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
                <span class="s1">prev_refcount = sys.getrefcount(arr)</span>
            <span class="s1">assert_raises(type(e)</span><span class="s0">, </span><span class="s1">arr.__getitem__</span><span class="s0">, </span><span class="s1">index)</span>
            <span class="s1">assert_raises(type(e)</span><span class="s0">, </span><span class="s1">arr.__setitem__</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
                <span class="s1">assert_equal(prev_refcount</span><span class="s0">, </span><span class="s1">sys.getrefcount(arr))</span>
            <span class="s0">return</span>

        <span class="s1">self._compare_index_result(arr</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">mimic_get</span><span class="s0">, </span><span class="s1">no_copy)</span>

    <span class="s0">def </span><span class="s1">_compare_index_result(self</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">mimic_get</span><span class="s0">, </span><span class="s1">no_copy):</span>
        <span class="s6">&quot;&quot;&quot;Compare mimicked result to indexing result. 
        &quot;&quot;&quot;</span>
        <span class="s1">arr = arr.copy()</span>
        <span class="s1">indexed_arr = arr[index]</span>
        <span class="s1">assert_array_equal(indexed_arr</span><span class="s0">, </span><span class="s1">mimic_get)</span>
        <span class="s3"># Check if we got a view, unless its a 0-sized or 0-d array.</span>
        <span class="s3"># (then its not a view, and that does not matter)</span>
        <span class="s0">if </span><span class="s1">indexed_arr.size != </span><span class="s2">0 </span><span class="s0">and </span><span class="s1">indexed_arr.ndim != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">assert_(np.may_share_memory(indexed_arr</span><span class="s0">, </span><span class="s1">arr) == no_copy)</span>
            <span class="s3"># Check reference count of the original array</span>
            <span class="s0">if </span><span class="s1">HAS_REFCOUNT:</span>
                <span class="s0">if </span><span class="s1">no_copy:</span>
                    <span class="s3"># refcount increases by one:</span>
                    <span class="s1">assert_equal(sys.getrefcount(arr)</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_equal(sys.getrefcount(arr)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s3"># Test non-broadcast setitem:</span>
        <span class="s1">b = arr.copy()</span>
        <span class="s1">b[index] = mimic_get + </span><span class="s2">1000</span>
        <span class="s0">if </span><span class="s1">b.size == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">return  </span><span class="s3"># nothing to compare here...</span>
        <span class="s0">if </span><span class="s1">no_copy </span><span class="s0">and </span><span class="s1">indexed_arr.ndim != </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s3"># change indexed_arr in-place to manipulate original:</span>
            <span class="s1">indexed_arr += </span><span class="s2">1000</span>
            <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s0">return</span>
        <span class="s3"># Use the fact that the array is originally an arange:</span>
        <span class="s1">arr.flat[indexed_arr.ravel()] += </span><span class="s2">1000</span>
        <span class="s1">assert_array_equal(arr</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_boolean(self):</span>
        <span class="s1">a = np.array(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(a[np.array(</span><span class="s0">True</span><span class="s1">)]</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
        <span class="s1">a[np.array(</span><span class="s0">True</span><span class="s1">)] = </span><span class="s2">1</span>
        <span class="s1">assert_equal(a</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s3"># NOTE: This is different from normal broadcasting, as</span>
        <span class="s3"># arr[boolean_array] works like in a multi index. Which means</span>
        <span class="s3"># it is aligned to the left. This is probably correct for</span>
        <span class="s3"># consistency with arr[boolean_array,] also no broadcasting</span>
        <span class="s3"># is done at all</span>
        <span class="s1">self._check_multi_index(</span>
            <span class="s1">self.a</span><span class="s0">, </span><span class="s1">(np.zeros_like(self.a</span><span class="s0">, </span><span class="s1">dtype=bool)</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self._check_multi_index(</span>
            <span class="s1">self.a</span><span class="s0">, </span><span class="s1">(np.zeros_like(self.a</span><span class="s0">, </span><span class="s1">dtype=bool)[...</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">self._check_multi_index(</span>
            <span class="s1">self.a</span><span class="s0">, </span><span class="s1">(np.zeros_like(self.a</span><span class="s0">, </span><span class="s1">dtype=bool)[</span><span class="s0">None, </span><span class="s1">...]</span><span class="s0">,</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_multidim(self):</span>
        <span class="s3"># Automatically test combinations with complex indexes on 2nd (or 1st)</span>
        <span class="s3"># spot and the simple ones in one other spot.</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s3"># This is so that np.array(True) is not accepted in a full integer</span>
            <span class="s3"># index, when running the file separately.</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s4">'error'</span><span class="s0">, </span><span class="s4">''</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>
            <span class="s1">warnings.filterwarnings(</span><span class="s4">'error'</span><span class="s0">, </span><span class="s4">''</span><span class="s0">, </span><span class="s1">np.VisibleDeprecationWarning)</span>

            <span class="s0">def </span><span class="s1">isskip(idx):</span>
                <span class="s0">return </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">idx == </span><span class="s4">&quot;skip&quot;</span>

            <span class="s0">for </span><span class="s1">simple_pos </span><span class="s0">in </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]:</span>
                <span class="s1">tocheck = [self.fill_indices</span><span class="s0">, </span><span class="s1">self.complex_indices</span><span class="s0">,</span>
                           <span class="s1">self.fill_indices</span><span class="s0">, </span><span class="s1">self.fill_indices]</span>
                <span class="s1">tocheck[simple_pos] = self.simple_indices</span>
                <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">product(*tocheck):</span>
                    <span class="s1">index = tuple(i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">index </span><span class="s0">if not </span><span class="s1">isskip(i))</span>
                    <span class="s1">self._check_multi_index(self.a</span><span class="s0">, </span><span class="s1">index)</span>
                    <span class="s1">self._check_multi_index(self.b</span><span class="s0">, </span><span class="s1">index)</span>

        <span class="s3"># Check very simple item getting:</span>
        <span class="s1">self._check_multi_index(self.a</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">self._check_multi_index(self.b</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s3"># Also check (simple cases of) too many indices:</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">self.a.__getitem__</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">self.a.__setitem__</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">self.a.__getitem__</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">self.a.__setitem__</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_1d(self):</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">self.complex_indices:</span>
            <span class="s1">self._check_single_index(a</span><span class="s0">, </span><span class="s1">index)</span>

<span class="s0">class </span><span class="s1">TestFloatNonIntegerArgument:</span>
    <span class="s6">&quot;&quot;&quot; 
    These test that ``TypeError`` is raised when you try to use 
    non-integers as arguments to for indexing and slicing e.g. ``a[0.0:5]`` 
    and ``a[0.5]``, or other functions like ``array.reshape(1., -1)``. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_valid_indexing(self):</span>
        <span class="s3"># These should raise no errors.</span>
        <span class="s1">a = np.array([[[</span><span class="s2">5</span><span class="s1">]]])</span>

        <span class="s1">a[np.array([</span><span class="s2">0</span><span class="s1">])]</span>
        <span class="s1">a[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">a[:</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]</span>
        <span class="s1">a[:</span><span class="s0">, </span><span class="s2">0</span><span class="s0">,</span><span class="s1">:]</span>
        <span class="s1">a[:</span><span class="s0">,</span><span class="s1">:</span><span class="s0">,</span><span class="s1">:]</span>

    <span class="s0">def </span><span class="s1">test_valid_slicing(self):</span>
        <span class="s3"># These should raise no errors.</span>
        <span class="s1">a = np.array([[[</span><span class="s2">5</span><span class="s1">]]])</span>

        <span class="s1">a[::]</span>
        <span class="s1">a[</span><span class="s2">0</span><span class="s1">:]</span>
        <span class="s1">a[:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">a[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">a[::</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">a[</span><span class="s2">1</span><span class="s1">::</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">a[:</span><span class="s2">2</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">a[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">2</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_non_integer_argument_errors(self):</span>
        <span class="s1">a = np.array([[</span><span class="s2">5</span><span class="s1">]])</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.reshape</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1.</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.reshape</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(np.array(</span><span class="s2">1.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.take</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">1.</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.take</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.float64(</span><span class="s2">1.</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_non_integer_sequence_multiplication(self):</span>
        <span class="s3"># NumPy scalar sequence multiply should not work with non-integers</span>
        <span class="s0">def </span><span class="s1">mult(a</span><span class="s0">, </span><span class="s1">b):</span>
            <span class="s0">return </span><span class="s1">a * b</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">mult</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.float_(</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s3"># following should be OK</span>
        <span class="s1">mult([</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.int_(</span><span class="s2">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_reduce_axis_float_index(self):</span>
        <span class="s1">d = np.zeros((</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">3</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.min</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.min</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.min</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2.2</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.min</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">(</span><span class="s2">.2</span><span class="s0">, </span><span class="s2">1.2</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestBooleanIndexing:</span>
    <span class="s3"># Using a boolean as integer argument/indexing is an error.</span>
    <span class="s0">def </span><span class="s1">test_bool_as_int_argument_errors(self):</span>
        <span class="s1">a = np.array([[[</span><span class="s2">1</span><span class="s1">]]])</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.reshape</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.reshape</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(np.bool_(</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s3"># Note that operator.index(np.array(True)) does not work, a boolean</span>
        <span class="s3"># array is thus also deprecated, but not with the same message:</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.index</span><span class="s0">, </span><span class="s1">np.array(</span><span class="s0">True</span><span class="s1">))</span>
        <span class="s1">assert_warns(DeprecationWarning</span><span class="s0">, </span><span class="s1">operator.index</span><span class="s0">, </span><span class="s1">np.True_)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.take</span><span class="s0">, </span><span class="s1">args=(a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_boolean_indexing_weirdness(self):</span>
        <span class="s3"># Weird boolean indexing things</span>
        <span class="s1">a = np.ones((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">a[</span><span class="s0">False, True, </span><span class="s1">...].shape == (</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">a[</span><span class="s0">True, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, True, True, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">2</span><span class="s1">]]].shape == (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[</span><span class="s0">False, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">...])</span>

    <span class="s0">def </span><span class="s1">test_boolean_indexing_fast_path(self):</span>
        <span class="s3"># These used to either give the wrong error, or incorrectly give no</span>
        <span class="s3"># error.</span>
        <span class="s1">a = np.ones((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>

        <span class="s3"># This used to incorrectly work (and give an array of shape (0,))</span>
        <span class="s1">idx1 = np.array([[</span><span class="s0">False</span><span class="s1">]*</span><span class="s2">9</span><span class="s1">])</span>
        <span class="s1">assert_raises_regex(IndexError</span><span class="s0">,</span>
            <span class="s4">&quot;boolean index did not match indexed array along dimension 0; &quot;</span>
            <span class="s4">&quot;dimension is 3 but corresponding boolean dimension is 1&quot;</span><span class="s0">,</span>
            <span class="s0">lambda</span><span class="s1">: a[idx1])</span>

        <span class="s3"># This used to incorrectly give a ValueError: operands could not be broadcast together</span>
        <span class="s1">idx2 = np.array([[</span><span class="s0">False</span><span class="s1">]*</span><span class="s2">8 </span><span class="s1">+ [</span><span class="s0">True</span><span class="s1">]])</span>
        <span class="s1">assert_raises_regex(IndexError</span><span class="s0">,</span>
            <span class="s4">&quot;boolean index did not match indexed array along dimension 0; &quot;</span>
            <span class="s4">&quot;dimension is 3 but corresponding boolean dimension is 1&quot;</span><span class="s0">,</span>
            <span class="s0">lambda</span><span class="s1">: a[idx2])</span>

        <span class="s3"># This is the same as it used to be. The above two should work like this.</span>
        <span class="s1">idx3 = np.array([[</span><span class="s0">False</span><span class="s1">]*</span><span class="s2">10</span><span class="s1">])</span>
        <span class="s1">assert_raises_regex(IndexError</span><span class="s0">,</span>
            <span class="s4">&quot;boolean index did not match indexed array along dimension 0; &quot;</span>
            <span class="s4">&quot;dimension is 3 but corresponding boolean dimension is 1&quot;</span><span class="s0">,</span>
            <span class="s0">lambda</span><span class="s1">: a[idx3])</span>

        <span class="s3"># This used to give ValueError: non-broadcastable operand</span>
        <span class="s1">a = np.ones((</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">idx = np.array([[[</span><span class="s0">True</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False</span><span class="s1">]]])</span>
        <span class="s1">assert_raises_regex(IndexError</span><span class="s0">,</span>
            <span class="s4">&quot;boolean index did not match indexed array along dimension 1; &quot;</span>
            <span class="s4">&quot;dimension is 1 but corresponding boolean dimension is 2&quot;</span><span class="s0">,</span>
            <span class="s0">lambda</span><span class="s1">: a[idx])</span>


<span class="s0">class </span><span class="s1">TestArrayToIndexDeprecation:</span>
    <span class="s6">&quot;&quot;&quot;Creating an index from array not 0-D is an error. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_array_to_index_error(self):</span>
        <span class="s3"># so no exception is expected. The raising is effectively tested above.</span>
        <span class="s1">a = np.array([[[</span><span class="s2">1</span><span class="s1">]]])</span>

        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">operator.index</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.reshape</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">np.take</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a)</span>


<span class="s0">class </span><span class="s1">TestNonIntegerArrayLike:</span>
    <span class="s6">&quot;&quot;&quot;Tests that array_likes only valid if can safely cast to integer. 
 
    For instance, lists give IndexError when they cannot be safely cast to 
    an integer. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>

        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">1.5</span><span class="s1">])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">([</span><span class="s4">'1'</span><span class="s0">, </span><span class="s4">'2'</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>

        <span class="s3"># The following is valid</span>
        <span class="s1">a.__getitem__([])</span>


<span class="s0">class </span><span class="s1">TestMultipleEllipsisError:</span>
    <span class="s6">&quot;&quot;&quot;An index can only have a single ellipsis. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: a[...</span><span class="s0">, </span><span class="s1">...])</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">((Ellipsis</span><span class="s0">,</span><span class="s1">) * </span><span class="s2">2</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">a.__getitem__</span><span class="s0">, </span><span class="s1">((Ellipsis</span><span class="s0">,</span><span class="s1">) * </span><span class="s2">3</span><span class="s0">,</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestCApiAccess:</span>
    <span class="s0">def </span><span class="s1">test_getitem(self):</span>
        <span class="s1">subscript = functools.partial(array_indexing</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s3"># 0-d arrays don't work:</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">subscript</span><span class="s0">, </span><span class="s1">np.ones(())</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s3"># Out of bound values:</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">subscript</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">subscript</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">subscript</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">subscript</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11</span><span class="s1">)</span>

        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(a[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">subscript(a</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
        <span class="s1">a = a.reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(a[-</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">subscript(a</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_setitem(self):</span>
        <span class="s1">assign = functools.partial(array_indexing</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s3"># Deletion is impossible:</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s3"># 0-d arrays don't work:</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones(())</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s3"># Out of bound values:</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_raises(IndexError</span><span class="s0">, </span><span class="s1">assign</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span><span class="s0">, </span><span class="s1">-</span><span class="s2">11</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

        <span class="s1">a = np.arange(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assign(a</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assert_(a[</span><span class="s2">4</span><span class="s1">] == </span><span class="s2">10</span><span class="s1">)</span>

        <span class="s1">a = a.reshape(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">assign(a</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(a[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">])</span>
</pre>
</body>
</html>