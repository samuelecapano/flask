<html>
<head>
<title>_backend_tk.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_backend_tk.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">uuid</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span>
<span class="s0">import </span><span class="s1">logging</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">os.path</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">tkinter </span><span class="s0">as </span><span class="s1">tk</span>
<span class="s0">import </span><span class="s1">tkinter.filedialog</span>
<span class="s0">import </span><span class="s1">tkinter.font</span>
<span class="s0">import </span><span class="s1">tkinter.messagebox</span>
<span class="s0">from </span><span class="s1">tkinter.simpledialog </span><span class="s0">import </span><span class="s1">SimpleDialog</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">PIL </span><span class="s0">import </span><span class="s1">Image</span><span class="s0">, </span><span class="s1">ImageTk</span>

<span class="s0">import </span><span class="s1">matplotlib </span><span class="s0">as </span><span class="s1">mpl</span>
<span class="s0">from </span><span class="s1">matplotlib </span><span class="s0">import </span><span class="s1">_api</span><span class="s0">, </span><span class="s1">backend_tools</span><span class="s0">, </span><span class="s1">cbook</span><span class="s0">, </span><span class="s1">_c_internal_utils</span>
<span class="s0">from </span><span class="s1">matplotlib.backend_bases </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_Backend</span><span class="s0">, </span><span class="s1">FigureCanvasBase</span><span class="s0">, </span><span class="s1">FigureManagerBase</span><span class="s0">, </span><span class="s1">NavigationToolbar2</span><span class="s0">,</span>
    <span class="s1">TimerBase</span><span class="s0">, </span><span class="s1">ToolContainerBase</span><span class="s0">, </span><span class="s1">cursors</span><span class="s0">, </span><span class="s1">_Mode</span><span class="s0">,</span>
    <span class="s1">CloseEvent</span><span class="s0">, </span><span class="s1">KeyEvent</span><span class="s0">, </span><span class="s1">LocationEvent</span><span class="s0">, </span><span class="s1">MouseEvent</span><span class="s0">, </span><span class="s1">ResizeEvent)</span>
<span class="s0">from </span><span class="s1">matplotlib._pylab_helpers </span><span class="s0">import </span><span class="s1">Gcf</span>
<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">_tkagg</span>


<span class="s1">_log = logging.getLogger(__name__)</span>
<span class="s1">cursord = {</span>
    <span class="s1">cursors.MOVE: </span><span class="s2">&quot;fleur&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.HAND: </span><span class="s2">&quot;hand2&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.POINTER: </span><span class="s2">&quot;arrow&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.SELECT_REGION: </span><span class="s2">&quot;tcross&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.WAIT: </span><span class="s2">&quot;watch&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.RESIZE_HORIZONTAL: </span><span class="s2">&quot;sb_h_double_arrow&quot;</span><span class="s0">,</span>
    <span class="s1">cursors.RESIZE_VERTICAL: </span><span class="s2">&quot;sb_v_double_arrow&quot;</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s1">@contextmanager</span>
<span class="s0">def </span><span class="s1">_restore_foreground_window_at_end():</span>
    <span class="s1">foreground = _c_internal_utils.Win32_GetForegroundWindow()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">yield</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s2">'tk.window_focus'</span><span class="s1">]:</span>
            <span class="s1">_c_internal_utils.Win32_SetForegroundWindow(foreground)</span>


<span class="s1">_blit_args = {}</span>
<span class="s3"># Initialize to a non-empty string that is not a Tcl command</span>
<span class="s1">_blit_tcl_name = </span><span class="s2">&quot;mpl_blit_&quot; </span><span class="s1">+ uuid.uuid4().hex</span>

<span class="s1">TK_PHOTO_COMPOSITE_OVERLAY = </span><span class="s4">0  </span><span class="s3"># apply transparency rules pixel-wise</span>
<span class="s1">TK_PHOTO_COMPOSITE_SET = </span><span class="s4">1  </span><span class="s3"># set image buffer directly</span>


<span class="s0">def </span><span class="s1">_blit(argsid):</span>
    <span class="s5">&quot;&quot;&quot; 
    Thin wrapper to blit called via tkapp.call. 
 
    *argsid* is a unique string identifier to fetch the correct arguments from 
    the ``_blit_args`` dict, since arguments cannot be passed directly. 
    &quot;&quot;&quot;</span>
    <span class="s1">photoimage</span><span class="s0">, </span><span class="s1">dataptr</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">bboxptr</span><span class="s0">, </span><span class="s1">comp_rule = _blit_args.pop(argsid)</span>
    <span class="s1">_tkagg.blit(photoimage.tk.interpaddr()</span><span class="s0">, </span><span class="s1">str(photoimage)</span><span class="s0">, </span><span class="s1">dataptr</span><span class="s0">,</span>
                <span class="s1">comp_rule</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">bboxptr)</span>


<span class="s0">def </span><span class="s1">blit(photoimage</span><span class="s0">, </span><span class="s1">aggimage</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">bbox=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Blit *aggimage* to *photoimage*. 
 
    *offsets* is a tuple describing how to fill the ``offset`` field of the 
    ``Tk_PhotoImageBlock`` struct: it should be (0, 1, 2, 3) for RGBA8888 data, 
    (2, 1, 0, 3) for little-endian ARBG32 (i.e. GBRA8888) data and (1, 2, 3, 0) 
    for big-endian ARGB32 (i.e. ARGB8888) data. 
 
    If *bbox* is passed, it defines the region that gets blitted. That region 
    will be composed with the previous data according to the alpha channel. 
    Blitting will be clipped to pixels inside the canvas, including silently 
    doing nothing if the *bbox* region is entirely outside the canvas. 
 
    Tcl events must be dispatched to trigger a blit from a non-Tcl thread. 
    &quot;&quot;&quot;</span>
    <span class="s1">data = np.asarray(aggimage)</span>
    <span class="s1">height</span><span class="s0">, </span><span class="s1">width = data.shape[:</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">dataptr = (height</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">data.ctypes.data)</span>
    <span class="s0">if </span><span class="s1">bbox </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">(x1</span><span class="s0">, </span><span class="s1">y1)</span><span class="s0">, </span><span class="s1">(x2</span><span class="s0">, </span><span class="s1">y2) = bbox.__array__()</span>
        <span class="s1">x1 = max(math.floor(x1)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">x2 = min(math.ceil(x2)</span><span class="s0">, </span><span class="s1">width)</span>
        <span class="s1">y1 = max(math.floor(y1)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">y2 = min(math.ceil(y2)</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s0">if </span><span class="s1">(x1 &gt; x2) </span><span class="s0">or </span><span class="s1">(y1 &gt; y2):</span>
            <span class="s0">return</span>
        <span class="s1">bboxptr = (x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">y2)</span>
        <span class="s1">comp_rule = TK_PHOTO_COMPOSITE_OVERLAY</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">bboxptr = (</span><span class="s4">0</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">height)</span>
        <span class="s1">comp_rule = TK_PHOTO_COMPOSITE_SET</span>

    <span class="s3"># NOTE: _tkagg.blit is thread unsafe and will crash the process if called</span>
    <span class="s3"># from a thread (GH#13293). Instead of blanking and blitting here,</span>
    <span class="s3"># use tkapp.call to post a cross-thread event if this function is called</span>
    <span class="s3"># from a non-Tcl thread.</span>

    <span class="s3"># tkapp.call coerces all arguments to strings, so to avoid string parsing</span>
    <span class="s3"># within _blit, pack up the arguments into a global data structure.</span>
    <span class="s1">args = photoimage</span><span class="s0">, </span><span class="s1">dataptr</span><span class="s0">, </span><span class="s1">offsets</span><span class="s0">, </span><span class="s1">bboxptr</span><span class="s0">, </span><span class="s1">comp_rule</span>
    <span class="s3"># Need a unique key to avoid thread races.</span>
    <span class="s3"># Again, make the key a string to avoid string parsing in _blit.</span>
    <span class="s1">argsid = str(id(args))</span>
    <span class="s1">_blit_args[argsid] = args</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">photoimage.tk.call(_blit_tcl_name</span><span class="s0">, </span><span class="s1">argsid)</span>
    <span class="s0">except </span><span class="s1">tk.TclError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">if </span><span class="s2">&quot;invalid command name&quot; </span><span class="s0">not in </span><span class="s1">str(e):</span>
            <span class="s0">raise</span>
        <span class="s1">photoimage.tk.createcommand(_blit_tcl_name</span><span class="s0">, </span><span class="s1">_blit)</span>
        <span class="s1">photoimage.tk.call(_blit_tcl_name</span><span class="s0">, </span><span class="s1">argsid)</span>


<span class="s0">class </span><span class="s1">TimerTk(TimerBase):</span>
    <span class="s5">&quot;&quot;&quot;Subclass of `backend_bases.TimerBase` using Tk timer events.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">parent</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._timer = </span><span class="s0">None</span>
        <span class="s1">super().__init__(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.parent = parent</span>

    <span class="s0">def </span><span class="s1">_timer_start(self):</span>
        <span class="s1">self._timer_stop()</span>
        <span class="s1">self._timer = self.parent.after(self._interval</span><span class="s0">, </span><span class="s1">self._on_timer)</span>

    <span class="s0">def </span><span class="s1">_timer_stop(self):</span>
        <span class="s0">if </span><span class="s1">self._timer </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">self.parent.after_cancel(self._timer)</span>
        <span class="s1">self._timer = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_on_timer(self):</span>
        <span class="s1">super()._on_timer()</span>
        <span class="s3"># Tk after() is only a single shot, so we need to add code here to</span>
        <span class="s3"># reset the timer if we're not operating in single shot mode.  However,</span>
        <span class="s3"># if _timer is None, this means that _timer_stop has been called; so</span>
        <span class="s3"># don't recreate the timer in that case.</span>
        <span class="s0">if not </span><span class="s1">self._single </span><span class="s0">and </span><span class="s1">self._timer:</span>
            <span class="s0">if </span><span class="s1">self._interval &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._timer = self.parent.after(self._interval</span><span class="s0">, </span><span class="s1">self._on_timer)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># Edge case: Tcl after 0 *prepends* events to the queue</span>
                <span class="s3"># so a 0 interval does not allow any other events to run.</span>
                <span class="s3"># This incantation is cancellable and runs as fast as possible</span>
                <span class="s3"># while also allowing events and drawing every frame. GH#18236</span>
                <span class="s1">self._timer = self.parent.after_idle(</span>
                    <span class="s0">lambda</span><span class="s1">: self.parent.after(self._interval</span><span class="s0">, </span><span class="s1">self._on_timer)</span>
                <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self._timer = </span><span class="s0">None</span>


<span class="s0">class </span><span class="s1">FigureCanvasTk(FigureCanvasBase):</span>
    <span class="s1">required_interactive_framework = </span><span class="s2">&quot;tk&quot;</span>
    <span class="s1">manager_class = _api.classproperty(</span><span class="s0">lambda </span><span class="s1">cls: FigureManagerTk)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">figure=</span><span class="s0">None, </span><span class="s1">master=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(figure)</span>
        <span class="s1">self._idle_draw_id = </span><span class="s0">None</span>
        <span class="s1">self._event_loop_id = </span><span class="s0">None</span>
        <span class="s1">w</span><span class="s0">, </span><span class="s1">h = self.get_width_height(physical=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self._tkcanvas = tk.Canvas(</span>
            <span class="s1">master=master</span><span class="s0">, </span><span class="s1">background=</span><span class="s2">&quot;white&quot;</span><span class="s0">,</span>
            <span class="s1">width=w</span><span class="s0">, </span><span class="s1">height=h</span><span class="s0">, </span><span class="s1">borderwidth=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">highlightthickness=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self._tkphoto = tk.PhotoImage(</span>
            <span class="s1">master=self._tkcanvas</span><span class="s0">, </span><span class="s1">width=w</span><span class="s0">, </span><span class="s1">height=h)</span>
        <span class="s1">self._tkcanvas.create_image(w//</span><span class="s4">2</span><span class="s0">, </span><span class="s1">h//</span><span class="s4">2</span><span class="s0">, </span><span class="s1">image=self._tkphoto)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Configure&gt;&quot;</span><span class="s0">, </span><span class="s1">self.resize)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'win32'</span><span class="s1">:</span>
            <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Map&gt;&quot;</span><span class="s0">, </span><span class="s1">self._update_device_pixel_ratio)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Key&gt;&quot;</span><span class="s0">, </span><span class="s1">self.key_press)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Motion&gt;&quot;</span><span class="s0">, </span><span class="s1">self.motion_notify_event)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Enter&gt;&quot;</span><span class="s0">, </span><span class="s1">self.enter_notify_event)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;Leave&gt;&quot;</span><span class="s0">, </span><span class="s1">self.leave_notify_event)</span>
        <span class="s1">self._tkcanvas.bind(</span><span class="s2">&quot;&lt;KeyRelease&gt;&quot;</span><span class="s0">, </span><span class="s1">self.key_release)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;&lt;Button-1&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;Button-2&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;Button-3&gt;&quot;</span><span class="s1">]:</span>
            <span class="s1">self._tkcanvas.bind(name</span><span class="s0">, </span><span class="s1">self.button_press_event)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span>
                <span class="s2">&quot;&lt;Double-Button-1&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;Double-Button-2&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;Double-Button-3&gt;&quot;</span><span class="s1">]:</span>
            <span class="s1">self._tkcanvas.bind(name</span><span class="s0">, </span><span class="s1">self.button_dblclick_event)</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span>
                <span class="s2">&quot;&lt;ButtonRelease-1&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;ButtonRelease-2&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;ButtonRelease-3&gt;&quot;</span><span class="s1">]:</span>
            <span class="s1">self._tkcanvas.bind(name</span><span class="s0">, </span><span class="s1">self.button_release_event)</span>

        <span class="s3"># Mouse wheel on Linux generates button 4/5 events</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s2">&quot;&lt;Button-4&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;Button-5&gt;&quot;</span><span class="s1">:</span>
            <span class="s1">self._tkcanvas.bind(name</span><span class="s0">, </span><span class="s1">self.scroll_event)</span>
        <span class="s3"># Mouse wheel for windows goes to the window with the focus.</span>
        <span class="s3"># Since the canvas won't usually have the focus, bind the</span>
        <span class="s3"># event to the window containing the canvas instead.</span>
        <span class="s3"># See https://wiki.tcl-lang.org/3893 (mousewheel) for details</span>
        <span class="s1">root = self._tkcanvas.winfo_toplevel()</span>

        <span class="s3"># Prevent long-lived references via tkinter callback structure GH-24820</span>
        <span class="s1">weakself = weakref.ref(self)</span>
        <span class="s1">weakroot = weakref.ref(root)</span>

        <span class="s0">def </span><span class="s1">scroll_event_windows(event):</span>
            <span class="s1">self = weakself()</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">root = weakroot()</span>
                <span class="s0">if </span><span class="s1">root </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">root.unbind(</span><span class="s2">&quot;&lt;MouseWheel&gt;&quot;</span><span class="s0">, </span><span class="s1">scroll_event_windows_id)</span>
                <span class="s0">return</span>
            <span class="s0">return </span><span class="s1">self.scroll_event_windows(event)</span>
        <span class="s1">scroll_event_windows_id = root.bind(</span><span class="s2">&quot;&lt;MouseWheel&gt;&quot;</span><span class="s0">, </span><span class="s1">scroll_event_windows</span><span class="s0">, </span><span class="s2">&quot;+&quot;</span><span class="s1">)</span>

        <span class="s3"># Can't get destroy events by binding to _tkcanvas. Therefore, bind</span>
        <span class="s3"># to the window and filter.</span>
        <span class="s0">def </span><span class="s1">filter_destroy(event):</span>
            <span class="s1">self = weakself()</span>
            <span class="s0">if </span><span class="s1">self </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">root = weakroot()</span>
                <span class="s0">if </span><span class="s1">root </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">root.unbind(</span><span class="s2">&quot;&lt;Destroy&gt;&quot;</span><span class="s0">, </span><span class="s1">filter_destroy_id)</span>
                <span class="s0">return</span>
            <span class="s0">if </span><span class="s1">event.widget </span><span class="s0">is </span><span class="s1">self._tkcanvas:</span>
                <span class="s1">CloseEvent(</span><span class="s2">&quot;close_event&quot;</span><span class="s0">, </span><span class="s1">self)._process()</span>
        <span class="s1">filter_destroy_id = root.bind(</span><span class="s2">&quot;&lt;Destroy&gt;&quot;</span><span class="s0">, </span><span class="s1">filter_destroy</span><span class="s0">, </span><span class="s2">&quot;+&quot;</span><span class="s1">)</span>

        <span class="s1">self._tkcanvas.focus_set()</span>

        <span class="s1">self._rubberband_rect_black = </span><span class="s0">None</span>
        <span class="s1">self._rubberband_rect_white = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_update_device_pixel_ratio(self</span><span class="s0">, </span><span class="s1">event=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3"># Tk gives scaling with respect to 72 DPI, but Windows screens are</span>
        <span class="s3"># scaled vs 96 dpi, and pixel ratio settings are given in whole</span>
        <span class="s3"># percentages, so round to 2 digits.</span>
        <span class="s1">ratio = round(self._tkcanvas.tk.call(</span><span class="s2">'tk'</span><span class="s0">, </span><span class="s2">'scaling'</span><span class="s1">) / (</span><span class="s4">96 </span><span class="s1">/ </span><span class="s4">72</span><span class="s1">)</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._set_device_pixel_ratio(ratio):</span>
            <span class="s3"># The easiest way to resize the canvas is to resize the canvas</span>
            <span class="s3"># widget itself, since we implement all the logic for resizing the</span>
            <span class="s3"># canvas backing store on that event.</span>
            <span class="s1">w</span><span class="s0">, </span><span class="s1">h = self.get_width_height(physical=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self._tkcanvas.configure(width=w</span><span class="s0">, </span><span class="s1">height=h)</span>

    <span class="s0">def </span><span class="s1">resize(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">width</span><span class="s0">, </span><span class="s1">height = event.width</span><span class="s0">, </span><span class="s1">event.height</span>

        <span class="s3"># compute desired figure size in inches</span>
        <span class="s1">dpival = self.figure.dpi</span>
        <span class="s1">winch = width / dpival</span>
        <span class="s1">hinch = height / dpival</span>
        <span class="s1">self.figure.set_size_inches(winch</span><span class="s0">, </span><span class="s1">hinch</span><span class="s0">, </span><span class="s1">forward=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">self._tkcanvas.delete(self._tkphoto)</span>
        <span class="s1">self._tkphoto = tk.PhotoImage(</span>
            <span class="s1">master=self._tkcanvas</span><span class="s0">, </span><span class="s1">width=int(width)</span><span class="s0">, </span><span class="s1">height=int(height))</span>
        <span class="s1">self._tkcanvas.create_image(</span>
            <span class="s1">int(width / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">int(height / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">image=self._tkphoto)</span>
        <span class="s1">ResizeEvent(</span><span class="s2">&quot;resize_event&quot;</span><span class="s0">, </span><span class="s1">self)._process()</span>
        <span class="s1">self.draw_idle()</span>

    <span class="s0">def </span><span class="s1">draw_idle(self):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">self._idle_draw_id:</span>
            <span class="s0">return</span>

        <span class="s0">def </span><span class="s1">idle_draw(*args):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.draw()</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">self._idle_draw_id = </span><span class="s0">None</span>

        <span class="s1">self._idle_draw_id = self._tkcanvas.after_idle(idle_draw)</span>

    <span class="s0">def </span><span class="s1">get_tk_widget(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the Tk widget used to implement FigureCanvasTkAgg. 
 
        Although the initial implementation uses a Tk canvas,  this routine 
        is intended to hide that fact. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._tkcanvas</span>

    <span class="s0">def </span><span class="s1">_event_mpl_coords(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s3"># calling canvasx/canvasy allows taking scrollbars into account (i.e.</span>
        <span class="s3"># the top of the widget may have been scrolled out of view).</span>
        <span class="s0">return </span><span class="s1">(self._tkcanvas.canvasx(event.x)</span><span class="s0">,</span>
                <span class="s3"># flipy so y=0 is bottom of canvas</span>
                <span class="s1">self.figure.bbox.height - self._tkcanvas.canvasy(event.y))</span>

    <span class="s0">def </span><span class="s1">motion_notify_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">MouseEvent(</span><span class="s2">&quot;motion_notify_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                   <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">,</span>
                   <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                   <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">enter_notify_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">LocationEvent(</span><span class="s2">&quot;figure_enter_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                      <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">,</span>
                      <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                      <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">leave_notify_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">LocationEvent(</span><span class="s2">&quot;figure_leave_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                      <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">,</span>
                      <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                      <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">button_press_event(self</span><span class="s0">, </span><span class="s1">event</span><span class="s0">, </span><span class="s1">dblclick=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s3"># set focus to the canvas so that it can receive keyboard events</span>
        <span class="s1">self._tkcanvas.focus_set()</span>

        <span class="s1">num = getattr(event</span><span class="s0">, </span><span class="s2">'num'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:  </span><span class="s3"># 2 and 3 are reversed.</span>
            <span class="s1">num = {</span><span class="s4">2</span><span class="s1">: </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}.get(num</span><span class="s0">, </span><span class="s1">num)</span>
        <span class="s1">MouseEvent(</span><span class="s2">&quot;button_press_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                   <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">dblclick=dblclick</span><span class="s0">,</span>
                   <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                   <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">button_dblclick_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">self.button_press_event(event</span><span class="s0">, </span><span class="s1">dblclick=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">button_release_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">num = getattr(event</span><span class="s0">, </span><span class="s2">'num'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">'darwin'</span><span class="s1">:  </span><span class="s3"># 2 and 3 are reversed.</span>
            <span class="s1">num = {</span><span class="s4">2</span><span class="s1">: </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}.get(num</span><span class="s0">, </span><span class="s1">num)</span>
        <span class="s1">MouseEvent(</span><span class="s2">&quot;button_release_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                   <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">, </span><span class="s1">num</span><span class="s0">,</span>
                   <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                   <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">scroll_event(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">num = getattr(event</span><span class="s0">, </span><span class="s2">'num'</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">step = </span><span class="s4">1 </span><span class="s0">if </span><span class="s1">num == </span><span class="s4">4 </span><span class="s0">else </span><span class="s1">-</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">num == </span><span class="s4">5 </span><span class="s0">else </span><span class="s4">0</span>
        <span class="s1">MouseEvent(</span><span class="s2">&quot;scroll_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                   <span class="s1">*self._event_mpl_coords(event)</span><span class="s0">, </span><span class="s1">step=step</span><span class="s0">,</span>
                   <span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                   <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">scroll_event_windows(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s5">&quot;&quot;&quot;MouseWheel event processor&quot;&quot;&quot;</span>
        <span class="s3"># need to find the window that contains the mouse</span>
        <span class="s1">w = event.widget.winfo_containing(event.x_root</span><span class="s0">, </span><span class="s1">event.y_root)</span>
        <span class="s0">if </span><span class="s1">w != self._tkcanvas:</span>
            <span class="s0">return</span>
        <span class="s1">x = self._tkcanvas.canvasx(event.x_root - w.winfo_rootx())</span>
        <span class="s1">y = (self.figure.bbox.height</span>
             <span class="s1">- self._tkcanvas.canvasy(event.y_root - w.winfo_rooty()))</span>
        <span class="s1">step = event.delta / </span><span class="s4">120</span>
        <span class="s1">MouseEvent(</span><span class="s2">&quot;scroll_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                   <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">step=step</span><span class="s0">, </span><span class="s1">modifiers=self._mpl_modifiers(event)</span><span class="s0">,</span>
                   <span class="s1">guiEvent=event)._process()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_mpl_modifiers(event</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">exclude=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s3"># add modifier keys to the key string. Bit details originate from</span>
        <span class="s3"># http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm</span>
        <span class="s3"># BIT_SHIFT = 0x001; BIT_CAPSLOCK = 0x002; BIT_CONTROL = 0x004;</span>
        <span class="s3"># BIT_LEFT_ALT = 0x008; BIT_NUMLOCK = 0x010; BIT_RIGHT_ALT = 0x080;</span>
        <span class="s3"># BIT_MB_1 = 0x100; BIT_MB_2 = 0x200; BIT_MB_3 = 0x400;</span>
        <span class="s3"># In general, the modifier key is excluded from the modifier flag,</span>
        <span class="s3"># however this is not the case on &quot;darwin&quot;, so double check that</span>
        <span class="s3"># we aren't adding repeat modifier flags to a modifier key.</span>
        <span class="s1">modifiers = [</span>
            <span class="s1">(</span><span class="s2">&quot;ctrl&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;control&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;alt&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">17</span><span class="s0">, </span><span class="s2">&quot;alt&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;shift&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">] </span><span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">&quot;win32&quot; </span><span class="s0">else </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;ctrl&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;control&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;alt&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">4</span><span class="s0">, </span><span class="s2">&quot;alt&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;shift&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;super&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;super&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">] </span><span class="s0">if </span><span class="s1">sys.platform == </span><span class="s2">&quot;darwin&quot; </span><span class="s0">else </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s2">&quot;ctrl&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">2</span><span class="s0">, </span><span class="s2">&quot;control&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;alt&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;alt&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;shift&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s2">&quot;super&quot;</span><span class="s0">, </span><span class="s4">1 </span><span class="s1">&lt;&lt; </span><span class="s4">6</span><span class="s0">, </span><span class="s2">&quot;super&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">[name </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">key </span><span class="s0">in </span><span class="s1">modifiers</span>
                <span class="s0">if </span><span class="s1">event.state &amp; mask </span><span class="s0">and </span><span class="s1">exclude != key]</span>

    <span class="s0">def </span><span class="s1">_get_key(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">unikey = event.char</span>
        <span class="s1">key = cbook._unikey_or_keysym_to_mplkey(unikey</span><span class="s0">, </span><span class="s1">event.keysym)</span>
        <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">mods = self._mpl_modifiers(event</span><span class="s0">, </span><span class="s1">exclude=key)</span>
            <span class="s3"># shift is not added to the keys as this is already accounted for.</span>
            <span class="s0">if </span><span class="s2">&quot;shift&quot; </span><span class="s0">in </span><span class="s1">mods </span><span class="s0">and </span><span class="s1">unikey:</span>
                <span class="s1">mods.remove(</span><span class="s2">&quot;shift&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s2">&quot;+&quot;</span><span class="s1">.join([*mods</span><span class="s0">, </span><span class="s1">key])</span>

    <span class="s0">def </span><span class="s1">key_press(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">KeyEvent(</span><span class="s2">&quot;key_press_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                 <span class="s1">self._get_key(event)</span><span class="s0">, </span><span class="s1">*self._event_mpl_coords(event)</span><span class="s0">,</span>
                 <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">key_release(self</span><span class="s0">, </span><span class="s1">event):</span>
        <span class="s1">KeyEvent(</span><span class="s2">&quot;key_release_event&quot;</span><span class="s0">, </span><span class="s1">self</span><span class="s0">,</span>
                 <span class="s1">self._get_key(event)</span><span class="s0">, </span><span class="s1">*self._event_mpl_coords(event)</span><span class="s0">,</span>
                 <span class="s1">guiEvent=event)._process()</span>

    <span class="s0">def </span><span class="s1">new_timer(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">return </span><span class="s1">TimerTk(self._tkcanvas</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">flush_events(self):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">self._tkcanvas.update()</span>

    <span class="s0">def </span><span class="s1">start_event_loop(self</span><span class="s0">, </span><span class="s1">timeout=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">timeout &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">milliseconds = int(</span><span class="s4">1000 </span><span class="s1">* timeout)</span>
            <span class="s0">if </span><span class="s1">milliseconds &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">self._event_loop_id = self._tkcanvas.after(</span>
                    <span class="s1">milliseconds</span><span class="s0">, </span><span class="s1">self.stop_event_loop)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._event_loop_id = self._tkcanvas.after_idle(</span>
                    <span class="s1">self.stop_event_loop)</span>
        <span class="s1">self._tkcanvas.mainloop()</span>

    <span class="s0">def </span><span class="s1">stop_event_loop(self):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">if </span><span class="s1">self._event_loop_id:</span>
            <span class="s1">self._tkcanvas.after_cancel(self._event_loop_id)</span>
            <span class="s1">self._event_loop_id = </span><span class="s0">None</span>
        <span class="s1">self._tkcanvas.quit()</span>

    <span class="s0">def </span><span class="s1">set_cursor(self</span><span class="s0">, </span><span class="s1">cursor):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self._tkcanvas.configure(cursor=cursord[cursor])</span>
        <span class="s0">except </span><span class="s1">tkinter.TclError:</span>
            <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">FigureManagerTk(FigureManagerBase):</span>
    <span class="s5">&quot;&quot;&quot; 
    Attributes 
    ---------- 
    canvas : `FigureCanvas` 
        The FigureCanvas instance 
    num : int or str 
        The Figure number 
    toolbar : tk.Toolbar 
        The tk.Toolbar 
    window : tk.Window 
        The tk.Window 
    &quot;&quot;&quot;</span>

    <span class="s1">_owns_mainloop = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">canvas</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window):</span>
        <span class="s1">self.window = window</span>
        <span class="s1">super().__init__(canvas</span><span class="s0">, </span><span class="s1">num)</span>
        <span class="s1">self.window.withdraw()</span>
        <span class="s3"># packing toolbar first, because if space is getting low, last packed</span>
        <span class="s3"># widget is getting shrunk first (-&gt; the canvas)</span>
        <span class="s1">self.canvas._tkcanvas.pack(side=tk.TOP</span><span class="s0">, </span><span class="s1">fill=tk.BOTH</span><span class="s0">, </span><span class="s1">expand=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3"># If the window has per-monitor DPI awareness, then setup a Tk variable</span>
        <span class="s3"># to store the DPI, which will be updated by the C code, and the trace</span>
        <span class="s3"># will handle it on the Python side.</span>
        <span class="s1">window_frame = int(window.wm_frame()</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">self._window_dpi = tk.IntVar(master=window</span><span class="s0">, </span><span class="s1">value=</span><span class="s4">96</span><span class="s0">,</span>
                                     <span class="s1">name=</span><span class="s2">f'window_dpi</span><span class="s0">{</span><span class="s1">window_frame</span><span class="s0">}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">self._window_dpi_cbname = </span><span class="s2">''</span>
        <span class="s0">if </span><span class="s1">_tkagg.enable_dpi_awareness(window_frame</span><span class="s0">, </span><span class="s1">window.tk.interpaddr()):</span>
            <span class="s1">self._window_dpi_cbname = self._window_dpi.trace_add(</span>
                <span class="s2">'write'</span><span class="s0">, </span><span class="s1">self._update_window_dpi)</span>

        <span class="s1">self._shown = </span><span class="s0">False</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">create_with_canvas(cls</span><span class="s0">, </span><span class="s1">canvas_class</span><span class="s0">, </span><span class="s1">figure</span><span class="s0">, </span><span class="s1">num):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s0">with </span><span class="s1">_restore_foreground_window_at_end():</span>
            <span class="s0">if </span><span class="s1">cbook._get_running_interactive_framework() </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">cbook._setup_new_guiapp()</span>
                <span class="s1">_c_internal_utils.Win32_SetProcessDpiAwareness_max()</span>
            <span class="s1">window = tk.Tk(className=</span><span class="s2">&quot;matplotlib&quot;</span><span class="s1">)</span>
            <span class="s1">window.withdraw()</span>

            <span class="s3"># Put a Matplotlib icon on the window rather than the default tk</span>
            <span class="s3"># icon. See https://www.tcl.tk/man/tcl/TkCmd/wm.html#M50</span>
            <span class="s3">#</span>
            <span class="s3"># `ImageTk` can be replaced with `tk` whenever the minimum</span>
            <span class="s3"># supported Tk version is increased to 8.6, as Tk 8.6+ natively</span>
            <span class="s3"># supports PNG images.</span>
            <span class="s1">icon_fname = str(cbook._get_data_path(</span>
                <span class="s2">'images/matplotlib.png'</span><span class="s1">))</span>
            <span class="s1">icon_img = ImageTk.PhotoImage(file=icon_fname</span><span class="s0">, </span><span class="s1">master=window)</span>

            <span class="s1">icon_fname_large = str(cbook._get_data_path(</span>
                <span class="s2">'images/matplotlib_large.png'</span><span class="s1">))</span>
            <span class="s1">icon_img_large = ImageTk.PhotoImage(</span>
                <span class="s1">file=icon_fname_large</span><span class="s0">, </span><span class="s1">master=window)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">window.iconphoto(</span><span class="s0">False, </span><span class="s1">icon_img_large</span><span class="s0">, </span><span class="s1">icon_img)</span>
            <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">exc:</span>
                <span class="s3"># log the failure (due e.g. to Tk version), but carry on</span>
                <span class="s1">_log.info(</span><span class="s2">'Could not load matplotlib icon: %s'</span><span class="s0">, </span><span class="s1">exc)</span>

            <span class="s1">canvas = canvas_class(figure</span><span class="s0">, </span><span class="s1">master=window)</span>
            <span class="s1">manager = cls(canvas</span><span class="s0">, </span><span class="s1">num</span><span class="s0">, </span><span class="s1">window)</span>
            <span class="s0">if </span><span class="s1">mpl.is_interactive():</span>
                <span class="s1">manager.show()</span>
                <span class="s1">canvas.draw_idle()</span>
            <span class="s0">return </span><span class="s1">manager</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">start_main_loop(cls):</span>
        <span class="s1">managers = Gcf.get_all_fig_managers()</span>
        <span class="s0">if </span><span class="s1">managers:</span>
            <span class="s1">first_manager = managers[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">manager_class = type(first_manager)</span>
            <span class="s0">if </span><span class="s1">manager_class._owns_mainloop:</span>
                <span class="s0">return</span>
            <span class="s1">manager_class._owns_mainloop = </span><span class="s0">True</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">first_manager.window.mainloop()</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">manager_class._owns_mainloop = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">_update_window_dpi(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">newdpi = self._window_dpi.get()</span>
        <span class="s1">self.window.call(</span><span class="s2">'tk'</span><span class="s0">, </span><span class="s2">'scaling'</span><span class="s0">, </span><span class="s1">newdpi / </span><span class="s4">72</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.toolbar </span><span class="s0">and </span><span class="s1">hasattr(self.toolbar</span><span class="s0">, </span><span class="s2">'_rescale'</span><span class="s1">):</span>
            <span class="s1">self.toolbar._rescale()</span>
        <span class="s1">self.canvas._update_device_pixel_ratio()</span>

    <span class="s0">def </span><span class="s1">resize(self</span><span class="s0">, </span><span class="s1">width</span><span class="s0">, </span><span class="s1">height):</span>
        <span class="s1">max_size = </span><span class="s4">1_400_000  </span><span class="s3"># the measured max on xorg 1.20.8 was 1_409_023</span>

        <span class="s0">if </span><span class="s1">(width &gt; max_size </span><span class="s0">or </span><span class="s1">height &gt; max_size) </span><span class="s0">and </span><span class="s1">sys.platform == </span><span class="s2">'linux'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">'You have requested to resize the '</span>
                <span class="s2">f'Tk window to (</span><span class="s0">{</span><span class="s1">width</span><span class="s0">}</span><span class="s2">, </span><span class="s0">{</span><span class="s1">height</span><span class="s0">}</span><span class="s2">), one of which '</span>
                <span class="s2">f'is bigger than </span><span class="s0">{</span><span class="s1">max_size</span><span class="s0">}</span><span class="s2">.  At larger sizes xorg will '</span>
                <span class="s2">'either exit with an error on newer versions (~1.20) or '</span>
                <span class="s2">'cause corruption on older version (~1.19).  We '</span>
                <span class="s2">'do not expect a window over a million pixel wide or tall '</span>
                <span class="s2">'to be intended behavior.'</span><span class="s1">)</span>
        <span class="s1">self.canvas._tkcanvas.configure(width=width</span><span class="s0">, </span><span class="s1">height=height)</span>

    <span class="s0">def </span><span class="s1">show(self):</span>
        <span class="s0">with </span><span class="s1">_restore_foreground_window_at_end():</span>
            <span class="s0">if not </span><span class="s1">self._shown:</span>
                <span class="s0">def </span><span class="s1">destroy(*args):</span>
                    <span class="s1">Gcf.destroy(self)</span>
                <span class="s1">self.window.protocol(</span><span class="s2">&quot;WM_DELETE_WINDOW&quot;</span><span class="s0">, </span><span class="s1">destroy)</span>
                <span class="s1">self.window.deiconify()</span>
                <span class="s1">self.canvas._tkcanvas.focus_set()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.canvas.draw_idle()</span>
            <span class="s0">if </span><span class="s1">mpl.rcParams[</span><span class="s2">'figure.raise_window'</span><span class="s1">]:</span>
                <span class="s1">self.canvas.manager.window.attributes(</span><span class="s2">'-topmost'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">self.canvas.manager.window.attributes(</span><span class="s2">'-topmost'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._shown = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">destroy(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s0">if </span><span class="s1">self.canvas._idle_draw_id:</span>
            <span class="s1">self.canvas._tkcanvas.after_cancel(self.canvas._idle_draw_id)</span>
        <span class="s0">if </span><span class="s1">self.canvas._event_loop_id:</span>
            <span class="s1">self.canvas._tkcanvas.after_cancel(self.canvas._event_loop_id)</span>
        <span class="s0">if </span><span class="s1">self._window_dpi_cbname:</span>
            <span class="s1">self._window_dpi.trace_remove(</span><span class="s2">'write'</span><span class="s0">, </span><span class="s1">self._window_dpi_cbname)</span>

        <span class="s3"># NOTE: events need to be flushed before issuing destroy (GH #9956),</span>
        <span class="s3"># however, self.window.update() can break user code. An async callback</span>
        <span class="s3"># is the safest way to achieve a complete draining of the event queue,</span>
        <span class="s3"># but it leaks if no tk event loop is running. Therefore we explicitly</span>
        <span class="s3"># check for an event loop and choose our best guess.</span>
        <span class="s0">def </span><span class="s1">delayed_destroy():</span>
            <span class="s1">self.window.destroy()</span>

            <span class="s0">if </span><span class="s1">self._owns_mainloop </span><span class="s0">and not </span><span class="s1">Gcf.get_num_fig_managers():</span>
                <span class="s1">self.window.quit()</span>

        <span class="s0">if </span><span class="s1">cbook._get_running_interactive_framework() == </span><span class="s2">&quot;tk&quot;</span><span class="s1">:</span>
            <span class="s3"># &quot;after idle after 0&quot; avoids Tcl error/race (GH #19940)</span>
            <span class="s1">self.window.after_idle(self.window.after</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">delayed_destroy)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.window.update()</span>
            <span class="s1">delayed_destroy()</span>

    <span class="s0">def </span><span class="s1">get_window_title(self):</span>
        <span class="s0">return </span><span class="s1">self.window.wm_title()</span>

    <span class="s0">def </span><span class="s1">set_window_title(self</span><span class="s0">, </span><span class="s1">title):</span>
        <span class="s1">self.window.wm_title(title)</span>

    <span class="s0">def </span><span class="s1">full_screen_toggle(self):</span>
        <span class="s1">is_fullscreen = bool(self.window.attributes(</span><span class="s2">'-fullscreen'</span><span class="s1">))</span>
        <span class="s1">self.window.attributes(</span><span class="s2">'-fullscreen'</span><span class="s0">, not </span><span class="s1">is_fullscreen)</span>


<span class="s0">class </span><span class="s1">NavigationToolbar2Tk(NavigationToolbar2</span><span class="s0">, </span><span class="s1">tk.Frame):</span>
    <span class="s1">window = _api.deprecated(</span><span class="s2">&quot;3.6&quot;</span><span class="s0">, </span><span class="s1">alternative=</span><span class="s2">&quot;self.master&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s0">lambda </span><span class="s1">self: self.master))</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">canvas</span><span class="s0">, </span><span class="s1">window=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">pack_toolbar=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        canvas : `FigureCanvas` 
            The figure canvas on which to operate. 
        window : tk.Window 
            The tk.Window which owns this toolbar. 
        pack_toolbar : bool, default: True 
            If True, add the toolbar to the parent's pack manager's packing 
            list during initialization with ``side=&quot;bottom&quot;`` and ``fill=&quot;x&quot;``. 
            If you want to use the toolbar with a different layout manager, use 
            ``pack_toolbar=False``. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">window </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">window = canvas.get_tk_widget().master</span>
        <span class="s1">tk.Frame.__init__(self</span><span class="s0">, </span><span class="s1">master=window</span><span class="s0">, </span><span class="s1">borderwidth=</span><span class="s4">2</span><span class="s0">,</span>
                          <span class="s1">width=int(canvas.figure.bbox.width)</span><span class="s0">, </span><span class="s1">height=</span><span class="s4">50</span><span class="s1">)</span>

        <span class="s1">self._buttons = {}</span>
        <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">tooltip_text</span><span class="s0">, </span><span class="s1">image_file</span><span class="s0">, </span><span class="s1">callback </span><span class="s0">in </span><span class="s1">self.toolitems:</span>
            <span class="s0">if </span><span class="s1">text </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s3"># Add a spacer; return value is unused.</span>
                <span class="s1">self._Spacer()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self._buttons[text] = button = self._Button(</span>
                    <span class="s1">text</span><span class="s0">,</span>
                    <span class="s1">str(cbook._get_data_path(</span><span class="s2">f&quot;images/</span><span class="s0">{</span><span class="s1">image_file</span><span class="s0">}</span><span class="s2">.png&quot;</span><span class="s1">))</span><span class="s0">,</span>
                    <span class="s1">toggle=callback </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;zoom&quot;</span><span class="s0">, </span><span class="s2">&quot;pan&quot;</span><span class="s1">]</span><span class="s0">,</span>
                    <span class="s1">command=getattr(self</span><span class="s0">, </span><span class="s1">callback)</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">tooltip_text </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">ToolTip.createToolTip(button</span><span class="s0">, </span><span class="s1">tooltip_text)</span>

        <span class="s1">self._label_font = tkinter.font.Font(root=window</span><span class="s0">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>

        <span class="s3"># This filler item ensures the toolbar is always at least two text</span>
        <span class="s3"># lines high. Otherwise the canvas gets redrawn as the mouse hovers</span>
        <span class="s3"># over images because those use two-line messages which resize the</span>
        <span class="s3"># toolbar.</span>
        <span class="s1">label = tk.Label(master=self</span><span class="s0">, </span><span class="s1">font=self._label_font</span><span class="s0">,</span>
                         <span class="s1">text=</span><span class="s2">'</span><span class="s0">\N{NO-BREAK SPACE}\n\N{NO-BREAK SPACE}</span><span class="s2">'</span><span class="s1">)</span>
        <span class="s1">label.pack(side=tk.RIGHT)</span>

        <span class="s1">self.message = tk.StringVar(master=self)</span>
        <span class="s1">self._message_label = tk.Label(master=self</span><span class="s0">, </span><span class="s1">font=self._label_font</span><span class="s0">,</span>
                                       <span class="s1">textvariable=self.message</span><span class="s0">,</span>
                                       <span class="s1">justify=tk.RIGHT)</span>
        <span class="s1">self._message_label.pack(side=tk.RIGHT)</span>

        <span class="s1">NavigationToolbar2.__init__(self</span><span class="s0">, </span><span class="s1">canvas)</span>
        <span class="s0">if </span><span class="s1">pack_toolbar:</span>
            <span class="s1">self.pack(side=tk.BOTTOM</span><span class="s0">, </span><span class="s1">fill=tk.X)</span>

    <span class="s0">def </span><span class="s1">_rescale(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Scale all children of the toolbar to current DPI setting. 
 
        Before this is called, the Tk scaling setting will have been updated to 
        match the new DPI. Tk widgets do not update for changes to scaling, but 
        all measurements made after the change will match the new scaling. Thus 
        this function re-applies all the same sizes in points, which Tk will 
        scale correctly to pixels. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">widget </span><span class="s0">in </span><span class="s1">self.winfo_children():</span>
            <span class="s0">if </span><span class="s1">isinstance(widget</span><span class="s0">, </span><span class="s1">(tk.Button</span><span class="s0">, </span><span class="s1">tk.Checkbutton)):</span>
                <span class="s0">if </span><span class="s1">hasattr(widget</span><span class="s0">, </span><span class="s2">'_image_file'</span><span class="s1">):</span>
                    <span class="s3"># Explicit class because ToolbarTk calls _rescale.</span>
                    <span class="s1">NavigationToolbar2Tk._set_image_for_button(self</span><span class="s0">, </span><span class="s1">widget)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s3"># Text-only button is handled by the font setting instead.</span>
                    <span class="s0">pass</span>
            <span class="s0">elif </span><span class="s1">isinstance(widget</span><span class="s0">, </span><span class="s1">tk.Frame):</span>
                <span class="s1">widget.configure(height=</span><span class="s2">'22p'</span><span class="s0">, </span><span class="s1">pady=</span><span class="s2">'1p'</span><span class="s1">)</span>
                <span class="s1">widget.pack_configure(padx=</span><span class="s2">'4p'</span><span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">isinstance(widget</span><span class="s0">, </span><span class="s1">tk.Label):</span>
                <span class="s0">pass  </span><span class="s3"># Text is handled by the font setting instead.</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">_log.warning(</span><span class="s2">'Unknown child class %s'</span><span class="s0">, </span><span class="s1">widget.winfo_class)</span>
        <span class="s1">self._label_font.configure(size=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_update_buttons_checked(self):</span>
        <span class="s3"># sync button checkstates to match active mode</span>
        <span class="s0">for </span><span class="s1">text</span><span class="s0">, </span><span class="s1">mode </span><span class="s0">in </span><span class="s1">[(</span><span class="s2">'Zoom'</span><span class="s0">, </span><span class="s1">_Mode.ZOOM)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">'Pan'</span><span class="s0">, </span><span class="s1">_Mode.PAN)]:</span>
            <span class="s0">if </span><span class="s1">text </span><span class="s0">in </span><span class="s1">self._buttons:</span>
                <span class="s0">if </span><span class="s1">self.mode == mode:</span>
                    <span class="s1">self._buttons[text].select()  </span><span class="s3"># NOT .invoke()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self._buttons[text].deselect()</span>

    <span class="s0">def </span><span class="s1">pan(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">super().pan(*args)</span>
        <span class="s1">self._update_buttons_checked()</span>

    <span class="s0">def </span><span class="s1">zoom(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">super().zoom(*args)</span>
        <span class="s1">self._update_buttons_checked()</span>

    <span class="s0">def </span><span class="s1">set_message(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">self.message.set(s)</span>

    <span class="s0">def </span><span class="s1">draw_rubberband(self</span><span class="s0">, </span><span class="s1">event</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1):</span>
        <span class="s3"># Block copied from remove_rubberband for backend_tools convenience.</span>
        <span class="s0">if </span><span class="s1">self.canvas._rubberband_rect_white:</span>
            <span class="s1">self.canvas._tkcanvas.delete(self.canvas._rubberband_rect_white)</span>
        <span class="s0">if </span><span class="s1">self.canvas._rubberband_rect_black:</span>
            <span class="s1">self.canvas._tkcanvas.delete(self.canvas._rubberband_rect_black)</span>
        <span class="s1">height = self.canvas.figure.bbox.height</span>
        <span class="s1">y0 = height - y0</span>
        <span class="s1">y1 = height - y1</span>
        <span class="s1">self.canvas._rubberband_rect_black = (</span>
            <span class="s1">self.canvas._tkcanvas.create_rectangle(</span>
                <span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1))</span>
        <span class="s1">self.canvas._rubberband_rect_white = (</span>
            <span class="s1">self.canvas._tkcanvas.create_rectangle(</span>
                <span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1</span><span class="s0">, </span><span class="s1">outline=</span><span class="s2">'white'</span><span class="s0">, </span><span class="s1">dash=(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)))</span>

    <span class="s0">def </span><span class="s1">remove_rubberband(self):</span>
        <span class="s0">if </span><span class="s1">self.canvas._rubberband_rect_white:</span>
            <span class="s1">self.canvas._tkcanvas.delete(self.canvas._rubberband_rect_white)</span>
            <span class="s1">self.canvas._rubberband_rect_white = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">self.canvas._rubberband_rect_black:</span>
            <span class="s1">self.canvas._tkcanvas.delete(self.canvas._rubberband_rect_black)</span>
            <span class="s1">self.canvas._rubberband_rect_black = </span><span class="s0">None</span>

    <span class="s1">lastrect = _api.deprecated(</span><span class="s2">&quot;3.6&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s0">lambda </span><span class="s1">self: self.canvas._rubberband_rect_black))</span>

    <span class="s0">def </span><span class="s1">_set_image_for_button(self</span><span class="s0">, </span><span class="s1">button):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the image for a button based on its pixel size. 
 
        The pixel size is determined by the DPI scaling of the window. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">button._image_file </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return</span>

        <span class="s3"># Allow _image_file to be relative to Matplotlib's &quot;images&quot; data</span>
        <span class="s3"># directory.</span>
        <span class="s1">path_regular = cbook._get_data_path(</span><span class="s2">'images'</span><span class="s0">, </span><span class="s1">button._image_file)</span>
        <span class="s1">path_large = path_regular.with_name(</span>
            <span class="s1">path_regular.name.replace(</span><span class="s2">'.png'</span><span class="s0">, </span><span class="s2">'_large.png'</span><span class="s1">))</span>
        <span class="s1">size = button.winfo_pixels(</span><span class="s2">'18p'</span><span class="s1">)</span>

        <span class="s3"># Nested functions because ToolbarTk calls  _Button.</span>
        <span class="s0">def </span><span class="s1">_get_color(color_name):</span>
            <span class="s3"># `winfo_rgb` returns an (r, g, b) tuple in the range 0-65535</span>
            <span class="s0">return </span><span class="s1">button.winfo_rgb(button.cget(color_name))</span>

        <span class="s0">def </span><span class="s1">_is_dark(color):</span>
            <span class="s0">if </span><span class="s1">isinstance(color</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">color = _get_color(color)</span>
            <span class="s0">return </span><span class="s1">max(color) &lt; </span><span class="s4">65535 </span><span class="s1">/ </span><span class="s4">2</span>

        <span class="s0">def </span><span class="s1">_recolor_icon(image</span><span class="s0">, </span><span class="s1">color):</span>
            <span class="s1">image_data = np.asarray(image).copy()</span>
            <span class="s1">black_mask = (image_data[...</span><span class="s0">, </span><span class="s1">:</span><span class="s4">3</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">).all(axis=-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">image_data[black_mask</span><span class="s0">, </span><span class="s1">:</span><span class="s4">3</span><span class="s1">] = color</span>
            <span class="s0">return </span><span class="s1">Image.fromarray(image_data</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">&quot;RGBA&quot;</span><span class="s1">)</span>

        <span class="s3"># Use the high-resolution (48x48 px) icon if it exists and is needed</span>
        <span class="s0">with </span><span class="s1">Image.open(path_large </span><span class="s0">if </span><span class="s1">(size &gt; </span><span class="s4">24 </span><span class="s0">and </span><span class="s1">path_large.exists())</span>
                        <span class="s0">else </span><span class="s1">path_regular) </span><span class="s0">as </span><span class="s1">im:</span>
            <span class="s3"># assure a RGBA image as foreground color is RGB</span>
            <span class="s1">im = im.convert(</span><span class="s2">&quot;RGBA&quot;</span><span class="s1">)</span>
            <span class="s1">image = ImageTk.PhotoImage(im.resize((size</span><span class="s0">, </span><span class="s1">size))</span><span class="s0">, </span><span class="s1">master=self)</span>
            <span class="s1">button._ntimage = image</span>

            <span class="s3"># create a version of the icon with the button's text color</span>
            <span class="s1">foreground = (</span><span class="s4">255 </span><span class="s1">/ </span><span class="s4">65535</span><span class="s1">) * np.array(</span>
                <span class="s1">button.winfo_rgb(button.cget(</span><span class="s2">&quot;foreground&quot;</span><span class="s1">)))</span>
            <span class="s1">im_alt = _recolor_icon(im</span><span class="s0">, </span><span class="s1">foreground)</span>
            <span class="s1">image_alt = ImageTk.PhotoImage(</span>
                <span class="s1">im_alt.resize((size</span><span class="s0">, </span><span class="s1">size))</span><span class="s0">, </span><span class="s1">master=self)</span>
            <span class="s1">button._ntimage_alt = image_alt</span>

        <span class="s0">if </span><span class="s1">_is_dark(</span><span class="s2">&quot;background&quot;</span><span class="s1">):</span>
            <span class="s3"># For Checkbuttons, we need to set `image` and `selectimage` at</span>
            <span class="s3"># the same time. Otherwise, when updating the `image` option</span>
            <span class="s3"># (such as when changing DPI), if the old `selectimage` has</span>
            <span class="s3"># just been overwritten, Tk will throw an error.</span>
            <span class="s1">image_kwargs = {</span><span class="s2">&quot;image&quot;</span><span class="s1">: image_alt}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">image_kwargs = {</span><span class="s2">&quot;image&quot;</span><span class="s1">: image}</span>
        <span class="s3"># Checkbuttons may switch the background to `selectcolor` in the</span>
        <span class="s3"># checked state, so check separately which image it needs to use in</span>
        <span class="s3"># that state to still ensure enough contrast with the background.</span>
        <span class="s0">if </span><span class="s1">(</span>
            <span class="s1">isinstance(button</span><span class="s0">, </span><span class="s1">tk.Checkbutton)</span>
            <span class="s0">and </span><span class="s1">button.cget(</span><span class="s2">&quot;selectcolor&quot;</span><span class="s1">) != </span><span class="s2">&quot;&quot;</span>
        <span class="s1">):</span>
            <span class="s0">if </span><span class="s1">self._windowingsystem != </span><span class="s2">&quot;x11&quot;</span><span class="s1">:</span>
                <span class="s1">selectcolor = </span><span class="s2">&quot;selectcolor&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># On X11, selectcolor isn't used directly for indicator-less</span>
                <span class="s3"># buttons. See `::tk::CheckEnter` in the Tk button.tcl source</span>
                <span class="s3"># code for details.</span>
                <span class="s1">r1</span><span class="s0">, </span><span class="s1">g1</span><span class="s0">, </span><span class="s1">b1 = _get_color(</span><span class="s2">&quot;selectcolor&quot;</span><span class="s1">)</span>
                <span class="s1">r2</span><span class="s0">, </span><span class="s1">g2</span><span class="s0">, </span><span class="s1">b2 = _get_color(</span><span class="s2">&quot;activebackground&quot;</span><span class="s1">)</span>
                <span class="s1">selectcolor = ((r1+r2)/</span><span class="s4">2</span><span class="s0">, </span><span class="s1">(g1+g2)/</span><span class="s4">2</span><span class="s0">, </span><span class="s1">(b1+b2)/</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">_is_dark(selectcolor):</span>
                <span class="s1">image_kwargs[</span><span class="s2">&quot;selectimage&quot;</span><span class="s1">] = image_alt</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">image_kwargs[</span><span class="s2">&quot;selectimage&quot;</span><span class="s1">] = image</span>

        <span class="s1">button.configure(**image_kwargs</span><span class="s0">, </span><span class="s1">height=</span><span class="s2">'18p'</span><span class="s0">, </span><span class="s1">width=</span><span class="s2">'18p'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_Button(self</span><span class="s0">, </span><span class="s1">text</span><span class="s0">, </span><span class="s1">image_file</span><span class="s0">, </span><span class="s1">toggle</span><span class="s0">, </span><span class="s1">command):</span>
        <span class="s0">if not </span><span class="s1">toggle:</span>
            <span class="s1">b = tk.Button(</span>
                <span class="s1">master=self</span><span class="s0">, </span><span class="s1">text=text</span><span class="s0">, </span><span class="s1">command=command</span><span class="s0">,</span>
                <span class="s1">relief=</span><span class="s2">&quot;flat&quot;</span><span class="s0">, </span><span class="s1">overrelief=</span><span class="s2">&quot;groove&quot;</span><span class="s0">, </span><span class="s1">borderwidth=</span><span class="s4">1</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># There is a bug in tkinter included in some python 3.6 versions</span>
            <span class="s3"># that without this variable, produces a &quot;visual&quot; toggling of</span>
            <span class="s3"># other near checkbuttons</span>
            <span class="s3"># https://bugs.python.org/issue29402</span>
            <span class="s3"># https://bugs.python.org/issue25684</span>
            <span class="s1">var = tk.IntVar(master=self)</span>
            <span class="s1">b = tk.Checkbutton(</span>
                <span class="s1">master=self</span><span class="s0">, </span><span class="s1">text=text</span><span class="s0">, </span><span class="s1">command=command</span><span class="s0">, </span><span class="s1">indicatoron=</span><span class="s0">False,</span>
                <span class="s1">variable=var</span><span class="s0">, </span><span class="s1">offrelief=</span><span class="s2">&quot;flat&quot;</span><span class="s0">, </span><span class="s1">overrelief=</span><span class="s2">&quot;groove&quot;</span><span class="s0">,</span>
                <span class="s1">borderwidth=</span><span class="s4">1</span>
            <span class="s1">)</span>
            <span class="s1">b.var = var</span>
        <span class="s1">b._image_file = image_file</span>
        <span class="s0">if </span><span class="s1">image_file </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># Explicit class because ToolbarTk calls _Button.</span>
            <span class="s1">NavigationToolbar2Tk._set_image_for_button(self</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">b.configure(font=self._label_font)</span>
        <span class="s1">b.pack(side=tk.LEFT)</span>
        <span class="s0">return </span><span class="s1">b</span>

    <span class="s0">def </span><span class="s1">_Spacer(self):</span>
        <span class="s3"># Buttons are also 18pt high.</span>
        <span class="s1">s = tk.Frame(master=self</span><span class="s0">, </span><span class="s1">height=</span><span class="s2">'18p'</span><span class="s0">, </span><span class="s1">relief=tk.RIDGE</span><span class="s0">, </span><span class="s1">bg=</span><span class="s2">'DarkGray'</span><span class="s1">)</span>
        <span class="s1">s.pack(side=tk.LEFT</span><span class="s0">, </span><span class="s1">padx=</span><span class="s2">'3p'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">s</span>

    <span class="s0">def </span><span class="s1">save_figure(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">filetypes = self.canvas.get_supported_filetypes().copy()</span>
        <span class="s1">default_filetype = self.canvas.get_default_filetype()</span>

        <span class="s3"># Tk doesn't provide a way to choose a default filetype,</span>
        <span class="s3"># so we just have to put it first</span>
        <span class="s1">default_filetype_name = filetypes.pop(default_filetype)</span>
        <span class="s1">sorted_filetypes = ([(default_filetype</span><span class="s0">, </span><span class="s1">default_filetype_name)]</span>
                            <span class="s1">+ sorted(filetypes.items()))</span>
        <span class="s1">tk_filetypes = [(name</span><span class="s0">, </span><span class="s2">'*.%s' </span><span class="s1">% ext) </span><span class="s0">for </span><span class="s1">ext</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">sorted_filetypes]</span>

        <span class="s3"># adding a default extension seems to break the</span>
        <span class="s3"># asksaveasfilename dialog when you choose various save types</span>
        <span class="s3"># from the dropdown.  Passing in the empty string seems to</span>
        <span class="s3"># work - JDH!</span>
        <span class="s3"># defaultextension = self.canvas.get_default_filetype()</span>
        <span class="s1">defaultextension = </span><span class="s2">''</span>
        <span class="s1">initialdir = os.path.expanduser(mpl.rcParams[</span><span class="s2">'savefig.directory'</span><span class="s1">])</span>
        <span class="s1">initialfile = self.canvas.get_default_filename()</span>
        <span class="s1">fname = tkinter.filedialog.asksaveasfilename(</span>
            <span class="s1">master=self.canvas.get_tk_widget().master</span><span class="s0">,</span>
            <span class="s1">title=</span><span class="s2">'Save the figure'</span><span class="s0">,</span>
            <span class="s1">filetypes=tk_filetypes</span><span class="s0">,</span>
            <span class="s1">defaultextension=defaultextension</span><span class="s0">,</span>
            <span class="s1">initialdir=initialdir</span><span class="s0">,</span>
            <span class="s1">initialfile=initialfile</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">fname </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">()]:</span>
            <span class="s0">return</span>
        <span class="s3"># Save dir for next time, unless empty str (i.e., use cwd).</span>
        <span class="s0">if </span><span class="s1">initialdir != </span><span class="s2">&quot;&quot;</span><span class="s1">:</span>
            <span class="s1">mpl.rcParams[</span><span class="s2">'savefig.directory'</span><span class="s1">] = (</span>
                <span class="s1">os.path.dirname(str(fname)))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s3"># This method will handle the delegation to the correct type</span>
            <span class="s1">self.canvas.figure.savefig(fname)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">tkinter.messagebox.showerror(</span><span class="s2">&quot;Error saving file&quot;</span><span class="s0">, </span><span class="s1">str(e))</span>

    <span class="s0">def </span><span class="s1">set_history_buttons(self):</span>
        <span class="s1">state_map = {</span><span class="s0">True</span><span class="s1">: tk.NORMAL</span><span class="s0">, False</span><span class="s1">: tk.DISABLED}</span>
        <span class="s1">can_back = self._nav_stack._pos &gt; </span><span class="s4">0</span>
        <span class="s1">can_forward = self._nav_stack._pos &lt; len(self._nav_stack._elements) - </span><span class="s4">1</span>

        <span class="s0">if </span><span class="s2">&quot;Back&quot; </span><span class="s0">in </span><span class="s1">self._buttons:</span>
            <span class="s1">self._buttons[</span><span class="s2">'Back'</span><span class="s1">][</span><span class="s2">'state'</span><span class="s1">] = state_map[can_back]</span>

        <span class="s0">if </span><span class="s2">&quot;Forward&quot; </span><span class="s0">in </span><span class="s1">self._buttons:</span>
            <span class="s1">self._buttons[</span><span class="s2">'Forward'</span><span class="s1">][</span><span class="s2">'state'</span><span class="s1">] = state_map[can_forward]</span>


<span class="s0">class </span><span class="s1">ToolTip:</span>
    <span class="s5">&quot;&quot;&quot; 
    Tooltip recipe from 
    http://www.voidspace.org.uk/python/weblog/arch_d7_2006_07_01.shtml#e387 
    &quot;&quot;&quot;</span>
    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">createToolTip(widget</span><span class="s0">, </span><span class="s1">text):</span>
        <span class="s1">toolTip = ToolTip(widget)</span>
        <span class="s0">def </span><span class="s1">enter(event):</span>
            <span class="s1">toolTip.showtip(text)</span>
        <span class="s0">def </span><span class="s1">leave(event):</span>
            <span class="s1">toolTip.hidetip()</span>
        <span class="s1">widget.bind(</span><span class="s2">'&lt;Enter&gt;'</span><span class="s0">, </span><span class="s1">enter)</span>
        <span class="s1">widget.bind(</span><span class="s2">'&lt;Leave&gt;'</span><span class="s0">, </span><span class="s1">leave)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">widget):</span>
        <span class="s1">self.widget = widget</span>
        <span class="s1">self.tipwindow = </span><span class="s0">None</span>
        <span class="s1">self.id = </span><span class="s0">None</span>
        <span class="s1">self.x = self.y = </span><span class="s4">0</span>

    <span class="s0">def </span><span class="s1">showtip(self</span><span class="s0">, </span><span class="s1">text):</span>
        <span class="s5">&quot;&quot;&quot;Display text in tooltip window.&quot;&quot;&quot;</span>
        <span class="s1">self.text = text</span>
        <span class="s0">if </span><span class="s1">self.tipwindow </span><span class="s0">or not </span><span class="s1">self.text:</span>
            <span class="s0">return</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = self.widget.bbox(</span><span class="s2">&quot;insert&quot;</span><span class="s1">)</span>
        <span class="s1">x = x + self.widget.winfo_rootx() + self.widget.winfo_width()</span>
        <span class="s1">y = y + self.widget.winfo_rooty()</span>
        <span class="s1">self.tipwindow = tw = tk.Toplevel(self.widget)</span>
        <span class="s1">tw.wm_overrideredirect(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">tw.wm_geometry(</span><span class="s2">&quot;+%d+%d&quot; </span><span class="s1">% (x</span><span class="s0">, </span><span class="s1">y))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s3"># For Mac OS</span>
            <span class="s1">tw.tk.call(</span><span class="s2">&quot;::tk::unsupported::MacWindowStyle&quot;</span><span class="s0">,</span>
                       <span class="s2">&quot;style&quot;</span><span class="s0">, </span><span class="s1">tw._w</span><span class="s0">,</span>
                       <span class="s2">&quot;help&quot;</span><span class="s0">, </span><span class="s2">&quot;noActivates&quot;</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">tk.TclError:</span>
            <span class="s0">pass</span>
        <span class="s1">label = tk.Label(tw</span><span class="s0">, </span><span class="s1">text=self.text</span><span class="s0">, </span><span class="s1">justify=tk.LEFT</span><span class="s0">,</span>
                         <span class="s1">relief=tk.SOLID</span><span class="s0">, </span><span class="s1">borderwidth=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">label.pack(ipadx=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">hidetip(self):</span>
        <span class="s1">tw = self.tipwindow</span>
        <span class="s1">self.tipwindow = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">tw:</span>
            <span class="s1">tw.destroy()</span>


<span class="s1">@backend_tools._register_tool_class(FigureCanvasTk)</span>
<span class="s0">class </span><span class="s1">RubberbandTk(backend_tools.RubberbandBase):</span>
    <span class="s0">def </span><span class="s1">draw_rubberband(self</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1):</span>
        <span class="s1">NavigationToolbar2Tk.draw_rubberband(</span>
            <span class="s1">self._make_classic_style_pseudo_toolbar()</span><span class="s0">, None, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">y1)</span>

    <span class="s0">def </span><span class="s1">remove_rubberband(self):</span>
        <span class="s1">NavigationToolbar2Tk.remove_rubberband(</span>
            <span class="s1">self._make_classic_style_pseudo_toolbar())</span>

    <span class="s1">lastrect = _api.deprecated(</span><span class="s2">&quot;3.6&quot;</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s0">lambda </span><span class="s1">self: self.figure.canvas._rubberband_rect_black))</span>


<span class="s0">class </span><span class="s1">ToolbarTk(ToolContainerBase</span><span class="s0">, </span><span class="s1">tk.Frame):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">toolmanager</span><span class="s0">, </span><span class="s1">window=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">ToolContainerBase.__init__(self</span><span class="s0">, </span><span class="s1">toolmanager)</span>
        <span class="s0">if </span><span class="s1">window </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">window = self.toolmanager.canvas.get_tk_widget().master</span>
        <span class="s1">xmin</span><span class="s0">, </span><span class="s1">xmax = self.toolmanager.canvas.figure.bbox.intervalx</span>
        <span class="s1">height</span><span class="s0">, </span><span class="s1">width = </span><span class="s4">50</span><span class="s0">, </span><span class="s1">xmax - xmin</span>
        <span class="s1">tk.Frame.__init__(self</span><span class="s0">, </span><span class="s1">master=window</span><span class="s0">,</span>
                          <span class="s1">width=int(width)</span><span class="s0">, </span><span class="s1">height=int(height)</span><span class="s0">,</span>
                          <span class="s1">borderwidth=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self._label_font = tkinter.font.Font(size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">self._message = tk.StringVar(master=self)</span>
        <span class="s1">self._message_label = tk.Label(master=self</span><span class="s0">, </span><span class="s1">font=self._label_font</span><span class="s0">,</span>
                                       <span class="s1">textvariable=self._message)</span>
        <span class="s1">self._message_label.pack(side=tk.RIGHT)</span>
        <span class="s1">self._toolitems = {}</span>
        <span class="s1">self.pack(side=tk.TOP</span><span class="s0">, </span><span class="s1">fill=tk.X)</span>
        <span class="s1">self._groups = {}</span>

    <span class="s0">def </span><span class="s1">_rescale(self):</span>
        <span class="s0">return </span><span class="s1">NavigationToolbar2Tk._rescale(self)</span>

    <span class="s0">def </span><span class="s1">add_toolitem(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">group</span><span class="s0">, </span><span class="s1">position</span><span class="s0">, </span><span class="s1">image_file</span><span class="s0">, </span><span class="s1">description</span><span class="s0">, </span><span class="s1">toggle):</span>
        <span class="s1">frame = self._get_groupframe(group)</span>
        <span class="s1">buttons = frame.pack_slaves()</span>
        <span class="s0">if </span><span class="s1">position &gt;= len(buttons) </span><span class="s0">or </span><span class="s1">position &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">before = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">before = buttons[position]</span>
        <span class="s1">button = NavigationToolbar2Tk._Button(frame</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">image_file</span><span class="s0">, </span><span class="s1">toggle</span><span class="s0">,</span>
                                              <span class="s0">lambda</span><span class="s1">: self._button_click(name))</span>
        <span class="s1">button.pack_configure(before=before)</span>
        <span class="s0">if </span><span class="s1">description </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">ToolTip.createToolTip(button</span><span class="s0">, </span><span class="s1">description)</span>
        <span class="s1">self._toolitems.setdefault(name</span><span class="s0">, </span><span class="s1">[])</span>
        <span class="s1">self._toolitems[name].append(button)</span>

    <span class="s0">def </span><span class="s1">_get_groupframe(self</span><span class="s0">, </span><span class="s1">group):</span>
        <span class="s0">if </span><span class="s1">group </span><span class="s0">not in </span><span class="s1">self._groups:</span>
            <span class="s0">if </span><span class="s1">self._groups:</span>
                <span class="s1">self._add_separator()</span>
            <span class="s1">frame = tk.Frame(master=self</span><span class="s0">, </span><span class="s1">borderwidth=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">frame.pack(side=tk.LEFT</span><span class="s0">, </span><span class="s1">fill=tk.Y)</span>
            <span class="s1">frame._label_font = self._label_font</span>
            <span class="s1">self._groups[group] = frame</span>
        <span class="s0">return </span><span class="s1">self._groups[group]</span>

    <span class="s0">def </span><span class="s1">_add_separator(self):</span>
        <span class="s0">return </span><span class="s1">NavigationToolbar2Tk._Spacer(self)</span>

    <span class="s0">def </span><span class="s1">_button_click(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self.trigger_tool(name)</span>

    <span class="s0">def </span><span class="s1">toggle_toolitem(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">toggled):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self._toolitems:</span>
            <span class="s0">return</span>
        <span class="s0">for </span><span class="s1">toolitem </span><span class="s0">in </span><span class="s1">self._toolitems[name]:</span>
            <span class="s0">if </span><span class="s1">toggled:</span>
                <span class="s1">toolitem.select()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">toolitem.deselect()</span>

    <span class="s0">def </span><span class="s1">remove_toolitem(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">for </span><span class="s1">toolitem </span><span class="s0">in </span><span class="s1">self._toolitems[name]:</span>
            <span class="s1">toolitem.pack_forget()</span>
        <span class="s0">del </span><span class="s1">self._toolitems[name]</span>

    <span class="s0">def </span><span class="s1">set_message(self</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">self._message.set(s)</span>


<span class="s1">@backend_tools._register_tool_class(FigureCanvasTk)</span>
<span class="s0">class </span><span class="s1">SaveFigureTk(backend_tools.SaveFigureBase):</span>
    <span class="s0">def </span><span class="s1">trigger(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">NavigationToolbar2Tk.save_figure(</span>
            <span class="s1">self._make_classic_style_pseudo_toolbar())</span>


<span class="s1">@backend_tools._register_tool_class(FigureCanvasTk)</span>
<span class="s0">class </span><span class="s1">ConfigureSubplotsTk(backend_tools.ConfigureSubplotsBase):</span>
    <span class="s0">def </span><span class="s1">trigger(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">NavigationToolbar2Tk.configure_subplots(self)</span>


<span class="s1">@backend_tools._register_tool_class(FigureCanvasTk)</span>
<span class="s0">class </span><span class="s1">HelpTk(backend_tools.ToolHelpBase):</span>
    <span class="s0">def </span><span class="s1">trigger(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">dialog = SimpleDialog(</span>
            <span class="s1">self.figure.canvas._tkcanvas</span><span class="s0">, </span><span class="s1">self._get_help_text()</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;OK&quot;</span><span class="s1">])</span>
        <span class="s1">dialog.done = </span><span class="s0">lambda </span><span class="s1">num: dialog.frame.master.withdraw()</span>


<span class="s1">Toolbar = ToolbarTk</span>
<span class="s1">FigureManagerTk._toolbar2_class = NavigationToolbar2Tk</span>
<span class="s1">FigureManagerTk._toolmanager_toolbar_class = ToolbarTk</span>


<span class="s1">@_Backend.export</span>
<span class="s0">class </span><span class="s1">_BackendTk(_Backend):</span>
    <span class="s1">backend_version = tk.TkVersion</span>
    <span class="s1">FigureCanvas = FigureCanvasTk</span>
    <span class="s1">FigureManager = FigureManagerTk</span>
    <span class="s1">mainloop = FigureManagerTk.start_main_loop</span>
</pre>
</body>
</html>