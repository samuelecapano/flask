<html>
<head>
<title>metadata_info.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
metadata_info.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright 2022 The MediaPipe Authors. All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s0"># you may not use this file except in compliance with the License.</span>
<span class="s0"># You may obtain a copy of the License at</span>
<span class="s0">#</span>
<span class="s0">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="s0">#</span>
<span class="s0"># Unless required by applicable law or agreed to in writing, software</span>
<span class="s0"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s0"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s0"># See the License for the specific language governing permissions and</span>
<span class="s0"># limitations under the License.</span>
<span class="s0"># ==============================================================================</span>
<span class="s2">&quot;&quot;&quot;Helper classes for common model metadata information.&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">csv</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Type</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">mediapipe.tasks.metadata </span><span class="s3">import </span><span class="s1">metadata_schema_py_generated </span><span class="s3">as </span><span class="s1">_metadata_fb</span>
<span class="s3">from </span><span class="s1">mediapipe.tasks.metadata </span><span class="s3">import </span><span class="s1">schema_py_generated </span><span class="s3">as </span><span class="s1">_schema_fb</span>
<span class="s3">from </span><span class="s1">mediapipe.tasks.python.metadata.metadata_writers </span><span class="s3">import </span><span class="s1">writer_utils</span>

<span class="s0"># Min and max values for UINT8 tensors.</span>
<span class="s1">_MIN_UINT8 = </span><span class="s4">0</span>
<span class="s1">_MAX_UINT8 = </span><span class="s4">255</span>

<span class="s0"># Default description for vocabulary files.</span>
<span class="s1">_VOCAB_FILE_DESCRIPTION = (</span><span class="s5">&quot;Vocabulary file to convert natural language &quot;</span>
                           <span class="s5">&quot;words to embedding vectors.&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">GeneralMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for common metadata information of a model. 
 
  Attributes: 
    name: name of the model. 
    version: version of the model. 
    description: description of what the model does. 
    author: author of the model. 
    licenses: licenses of the model. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">name: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">version: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">author: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">licenses: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self.name = name</span>
    <span class="s1">self.version = version</span>
    <span class="s1">self.description = description</span>
    <span class="s1">self.author = author</span>
    <span class="s1">self.licenses = licenses</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ModelMetadataT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the model metadata based on the general model information. 
 
    Returns: 
      A Flatbuffers Python object of the model metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">model_metadata = _metadata_fb.ModelMetadataT()</span>
    <span class="s1">model_metadata.name = self.name</span>
    <span class="s1">model_metadata.version = self.version</span>
    <span class="s1">model_metadata.description = self.description</span>
    <span class="s1">model_metadata.author = self.author</span>
    <span class="s1">model_metadata.license = self.licenses</span>
    <span class="s3">return </span><span class="s1">model_metadata</span>


<span class="s3">class </span><span class="s1">AssociatedFileMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for common associated file metadata information. 
 
  Attributes: 
    file_path: path to the associated file. 
    description: description of the associated file. 
    file_type: file type of the associated file [1]. 
    locale: locale of the associated file [2]. 
    [1]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L77 
    [2]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L176 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">file_path: str</span><span class="s3">,</span>
      <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">file_type: Optional[int] = _metadata_fb.AssociatedFileType.UNKNOWN</span><span class="s3">,</span>
      <span class="s1">locale: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self.file_path = file_path</span>
    <span class="s1">self.description = description</span>
    <span class="s1">self.file_type = file_type</span>
    <span class="s1">self.locale = locale</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.AssociatedFileT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the associated file metadata. 
 
    Returns: 
      A Flatbuffers Python object of the associated file metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">file_metadata = _metadata_fb.AssociatedFileT()</span>
    <span class="s1">file_metadata.name = os.path.basename(self.file_path)</span>
    <span class="s1">file_metadata.description = self.description</span>
    <span class="s1">file_metadata.type = self.file_type</span>
    <span class="s1">file_metadata.locale = self.locale</span>
    <span class="s3">return </span><span class="s1">file_metadata</span>


<span class="s3">class </span><span class="s1">LabelFileMd(AssociatedFileMd):</span>
  <span class="s2">&quot;&quot;&quot;A container for label file metadata information.&quot;&quot;&quot;</span>

  <span class="s1">_LABEL_FILE_DESCRIPTION = (</span><span class="s5">&quot;Labels for categories that the model can &quot;</span>
                             <span class="s5">&quot;recognize.&quot;</span><span class="s1">)</span>
  <span class="s1">_FILE_TYPE = _metadata_fb.AssociatedFileType.TENSOR_AXIS_LABELS</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">file_path: str</span><span class="s3">, </span><span class="s1">locale: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Creates a LabelFileMd object. 
 
    Args: 
      file_path: file_path of the label file. 
      locale: locale of the label file [1]. 
      [1]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L176 
    &quot;&quot;&quot;</span>
    <span class="s1">super().__init__(file_path</span><span class="s3">, </span><span class="s1">self._LABEL_FILE_DESCRIPTION</span><span class="s3">, </span><span class="s1">self._FILE_TYPE</span><span class="s3">,</span>
                     <span class="s1">locale)</span>


<span class="s3">class </span><span class="s1">ScoreCalibrationMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for score calibration [1] metadata information. 
 
  [1]: 
    https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L456 
  &quot;&quot;&quot;</span>

  <span class="s1">_SCORE_CALIBRATION_FILE_DESCRIPTION = (</span>
      <span class="s5">&quot;Contains sigmoid-based score calibration parameters. The main purposes &quot;</span>
      <span class="s5">&quot;of score calibration is to make scores across classes comparable, so &quot;</span>
      <span class="s5">&quot;that a common threshold can be used for all output classes.&quot;</span><span class="s1">)</span>
  <span class="s1">_FILE_TYPE = _metadata_fb.AssociatedFileType.TENSOR_AXIS_SCORE_CALIBRATION</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">score_transformation_type: _metadata_fb.ScoreTransformationType</span><span class="s3">,</span>
               <span class="s1">default_score: float</span><span class="s3">, </span><span class="s1">file_path: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Creates a ScoreCalibrationMd object. 
 
    Args: 
      score_transformation_type: type of the function used for transforming the 
        uncalibrated score before applying score calibration. 
      default_score: the default calibrated score to apply if the uncalibrated 
        score is below min_score or if no parameters were specified for a given 
        index. 
      file_path: file_path of the score calibration file [1]. 
      [1]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L133 
 
    Raises: 
      ValueError: if the score_calibration file is malformed. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._score_transformation_type = score_transformation_type</span>
    <span class="s1">self._default_score = default_score</span>
    <span class="s1">self._file_path = file_path</span>

    <span class="s0"># Sanity check the score calibration file.</span>
    <span class="s3">with </span><span class="s1">open(self._file_path) </span><span class="s3">as </span><span class="s1">calibration_file:</span>
      <span class="s1">csv_reader = csv.reader(calibration_file</span><span class="s3">, </span><span class="s1">delimiter=</span><span class="s5">&quot;,&quot;</span><span class="s1">)</span>
      <span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">csv_reader:</span>
        <span class="s3">if </span><span class="s1">row </span><span class="s3">and </span><span class="s1">len(row) != </span><span class="s4">3 </span><span class="s3">and </span><span class="s1">len(row) != </span><span class="s4">4</span><span class="s1">:</span>
          <span class="s3">raise </span><span class="s1">ValueError(</span>
              <span class="s5">f&quot;Expected empty lines or 3 or 4 parameters per line in score&quot;</span>
              <span class="s5">f&quot; calibration file, but got </span><span class="s3">{</span><span class="s1">len(row)</span><span class="s3">}</span><span class="s5">.&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">row </span><span class="s3">and </span><span class="s1">float(row[</span><span class="s4">0</span><span class="s1">]) &lt; </span><span class="s4">0</span><span class="s1">:</span>
          <span class="s3">raise </span><span class="s1">ValueError(</span>
              <span class="s5">f&quot;Expected scale to be a non-negative value, but got &quot;</span>
              <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">float(row[</span><span class="s4">0</span><span class="s1">])</span><span class="s3">}</span><span class="s5">.&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ProcessUnitT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the score calibration metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the score calibration metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">score_calibration = _metadata_fb.ProcessUnitT()</span>
    <span class="s1">score_calibration.optionsType = (</span>
        <span class="s1">_metadata_fb.ProcessUnitOptions.ScoreCalibrationOptions)</span>
    <span class="s1">options = _metadata_fb.ScoreCalibrationOptionsT()</span>
    <span class="s1">options.scoreTransformation = self._score_transformation_type</span>
    <span class="s1">options.defaultScore = self._default_score</span>
    <span class="s1">score_calibration.options = options</span>
    <span class="s3">return </span><span class="s1">score_calibration</span>

  <span class="s3">def </span><span class="s1">create_score_calibration_file_md(self) -&gt; AssociatedFileMd:</span>
    <span class="s3">return </span><span class="s1">AssociatedFileMd(self._file_path</span><span class="s3">,</span>
                            <span class="s1">self._SCORE_CALIBRATION_FILE_DESCRIPTION</span><span class="s3">,</span>
                            <span class="s1">self._FILE_TYPE)</span>


<span class="s3">class </span><span class="s1">ScoreThresholdingMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for score thresholding [1] metadata information. 
 
  [1]: 
    https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L468 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">global_score_threshold: float) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Creates a ScoreThresholdingMd object. 
 
    Args: 
      global_score_threshold: The recommended global threshold below which 
        results are considered low-confidence and should be filtered out. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._global_score_threshold = global_score_threshold</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ProcessUnitT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the score thresholding metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the score thresholding metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">score_thresholding = _metadata_fb.ProcessUnitT()</span>
    <span class="s1">score_thresholding.optionsType = (</span>
        <span class="s1">_metadata_fb.ProcessUnitOptions.ScoreThresholdingOptions)</span>
    <span class="s1">options = _metadata_fb.ScoreThresholdingOptionsT()</span>
    <span class="s1">options.globalScoreThreshold = self._global_score_threshold</span>
    <span class="s1">score_thresholding.options = options</span>
    <span class="s3">return </span><span class="s1">score_thresholding</span>


<span class="s3">class </span><span class="s1">RegexTokenizerMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for the Regex tokenizer [1] metadata information. 
 
  [1]: 
    https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L500 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">delim_regex_pattern: str</span><span class="s3">, </span><span class="s1">vocab_file_path: str):</span>
    <span class="s2">&quot;&quot;&quot;Initializes a RegexTokenizerMd object. 
 
    Args: 
      delim_regex_pattern: the regular expression to segment strings and create 
        tokens. 
      vocab_file_path: path to the vocabulary file. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._delim_regex_pattern = delim_regex_pattern</span>
    <span class="s1">self._vocab_file_path = vocab_file_path</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ProcessUnitT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the Regex tokenizer metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the Regex tokenizer metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">vocab = _metadata_fb.AssociatedFileT()</span>
    <span class="s1">vocab.name = self._vocab_file_path</span>
    <span class="s1">vocab.description = _VOCAB_FILE_DESCRIPTION</span>
    <span class="s1">vocab.type = _metadata_fb.AssociatedFileType.VOCABULARY</span>

    <span class="s0"># Create the RegexTokenizer.</span>
    <span class="s1">tokenizer = _metadata_fb.ProcessUnitT()</span>
    <span class="s1">tokenizer.optionsType = (</span>
        <span class="s1">_metadata_fb.ProcessUnitOptions.RegexTokenizerOptions)</span>
    <span class="s1">tokenizer.options = _metadata_fb.RegexTokenizerOptionsT()</span>
    <span class="s1">tokenizer.options.delimRegexPattern = self._delim_regex_pattern</span>
    <span class="s1">tokenizer.options.vocabFile = [vocab]</span>
    <span class="s3">return </span><span class="s1">tokenizer</span>


<span class="s3">class </span><span class="s1">BertTokenizerMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for the Bert tokenizer [1] metadata information. 
 
  [1]: 
    https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L477 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">vocab_file_path: str):</span>
    <span class="s2">&quot;&quot;&quot;Initializes a BertTokenizerMd object. 
 
    Args: 
      vocab_file_path: path to the vocabulary file. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._vocab_file_path = vocab_file_path</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ProcessUnitT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the Bert tokenizer metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the Bert tokenizer metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">vocab = _metadata_fb.AssociatedFileT()</span>
    <span class="s1">vocab.name = self._vocab_file_path</span>
    <span class="s1">vocab.description = _VOCAB_FILE_DESCRIPTION</span>
    <span class="s1">vocab.type = _metadata_fb.AssociatedFileType.VOCABULARY</span>
    <span class="s1">tokenizer = _metadata_fb.ProcessUnitT()</span>
    <span class="s1">tokenizer.optionsType = _metadata_fb.ProcessUnitOptions.BertTokenizerOptions</span>
    <span class="s1">tokenizer.options = _metadata_fb.BertTokenizerOptionsT()</span>
    <span class="s1">tokenizer.options.vocabFile = [vocab]</span>
    <span class="s3">return </span><span class="s1">tokenizer</span>


<span class="s3">class </span><span class="s1">SentencePieceTokenizerMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for the sentence piece tokenizer [1] metadata information. 
 
  [1]: 
    https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L485 
  &quot;&quot;&quot;</span>

  <span class="s1">_SP_MODEL_DESCRIPTION = </span><span class="s5">&quot;The sentence piece model file.&quot;</span>
  <span class="s1">_SP_VOCAB_FILE_DESCRIPTION = _VOCAB_FILE_DESCRIPTION + (</span>
      <span class="s5">&quot; This file is optional during tokenization, while the sentence piece &quot;</span>
      <span class="s5">&quot;model is mandatory.&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">sentence_piece_model_path: str</span><span class="s3">,</span>
               <span class="s1">vocab_file_path: Optional[str] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes a SentencePieceTokenizerMd object. 
 
    Args: 
      sentence_piece_model_path: path to the sentence piece model file. 
      vocab_file_path: path to the vocabulary file. 
    &quot;&quot;&quot;</span>
    <span class="s1">self._sentence_piece_model_path = sentence_piece_model_path</span>
    <span class="s1">self._vocab_file_path = vocab_file_path</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.ProcessUnitT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the sentence piece tokenizer metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the sentence piece tokenizer metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">tokenizer = _metadata_fb.ProcessUnitT()</span>
    <span class="s1">tokenizer.optionsType = (</span>
        <span class="s1">_metadata_fb.ProcessUnitOptions.SentencePieceTokenizerOptions)</span>
    <span class="s1">tokenizer.options = _metadata_fb.SentencePieceTokenizerOptionsT()</span>

    <span class="s1">sp_model = _metadata_fb.AssociatedFileT()</span>
    <span class="s1">sp_model.name = self._sentence_piece_model_path</span>
    <span class="s1">sp_model.description = self._SP_MODEL_DESCRIPTION</span>
    <span class="s1">tokenizer.options.sentencePieceModel = [sp_model]</span>
    <span class="s3">if </span><span class="s1">self._vocab_file_path:</span>
      <span class="s1">vocab = _metadata_fb.AssociatedFileT()</span>
      <span class="s1">vocab.name = self._vocab_file_path</span>
      <span class="s1">vocab.description = self._SP_VOCAB_FILE_DESCRIPTION</span>
      <span class="s1">vocab.type = _metadata_fb.AssociatedFileType.VOCABULARY</span>
      <span class="s1">tokenizer.options.vocabFile = [vocab]</span>
    <span class="s3">return </span><span class="s1">tokenizer</span>


<span class="s3">class </span><span class="s1">TensorMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for common tensor metadata information. 
 
  Attributes: 
    name: name of the tensor. 
    description: description of what the tensor is. 
    min_values: per-channel minimum value of the tensor. 
    max_values: per-channel maximum value of the tensor. 
    content_type: content_type of the tensor. 
    associated_files: information of the associated files in the tensor. 
    tensor_name: name of the corresponding tensor [1] in the TFLite model. It is 
      used to locate the corresponding tensor and decide the order of the tensor 
      metadata [2] when populating model metadata. 
    [1]: 
      https://github.com/tensorflow/tensorflow/blob/cb67fef35567298b40ac166b0581cd8ad68e5a3a/tensorflow/lite/schema/schema.fbs#L1129-L1136 
    [2]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L623-L640 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">name: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">min_values: Optional[List[float]] = </span><span class="s3">None,</span>
      <span class="s1">max_values: Optional[List[float]] = </span><span class="s3">None,</span>
      <span class="s1">content_type: int = _metadata_fb.ContentProperties.FeatureProperties</span><span class="s3">,</span>
      <span class="s1">associated_files: Optional[List[Type[AssociatedFileMd]]] = </span><span class="s3">None,</span>
      <span class="s1">tensor_name: Optional[str] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">self.name = name</span>
    <span class="s1">self.description = description</span>
    <span class="s1">self.min_values = min_values</span>
    <span class="s1">self.max_values = max_values</span>
    <span class="s1">self.content_type = content_type</span>
    <span class="s1">self.associated_files = associated_files</span>
    <span class="s1">self.tensor_name = tensor_name</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.TensorMetadataT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the input tensor metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the input metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">tensor_metadata = _metadata_fb.TensorMetadataT()</span>
    <span class="s1">tensor_metadata.name = self.name</span>
    <span class="s1">tensor_metadata.description = self.description</span>

    <span class="s0"># Create min and max values</span>
    <span class="s1">stats = _metadata_fb.StatsT()</span>
    <span class="s1">stats.max = self.max_values</span>
    <span class="s1">stats.min = self.min_values</span>
    <span class="s1">tensor_metadata.stats = stats</span>

    <span class="s0"># Create content properties</span>
    <span class="s1">content = _metadata_fb.ContentT()</span>
    <span class="s3">if </span><span class="s1">self.content_type </span><span class="s3">is </span><span class="s1">_metadata_fb.ContentProperties.FeatureProperties:</span>
      <span class="s1">content.contentProperties = _metadata_fb.FeaturePropertiesT()</span>
    <span class="s3">elif </span><span class="s1">self.content_type </span><span class="s3">is </span><span class="s1">_metadata_fb.ContentProperties.ImageProperties:</span>
      <span class="s1">content.contentProperties = _metadata_fb.ImagePropertiesT()</span>
    <span class="s3">elif </span><span class="s1">self.content_type </span><span class="s3">is </span><span class="s1">(</span>
        <span class="s1">_metadata_fb.ContentProperties.BoundingBoxProperties):</span>
      <span class="s1">content.contentProperties = _metadata_fb.BoundingBoxPropertiesT()</span>
    <span class="s3">elif </span><span class="s1">self.content_type </span><span class="s3">is </span><span class="s1">_metadata_fb.ContentProperties.AudioProperties:</span>
      <span class="s1">content.contentProperties = _metadata_fb.AudioPropertiesT()</span>

    <span class="s1">content.contentPropertiesType = self.content_type</span>
    <span class="s1">tensor_metadata.content = content</span>

    <span class="s0"># TODO: check if multiple label files have populated locale.</span>
    <span class="s0"># Create associated files</span>
    <span class="s3">if </span><span class="s1">self.associated_files:</span>
      <span class="s1">tensor_metadata.associatedFiles = [</span>
          <span class="s1">file.create_metadata() </span><span class="s3">for </span><span class="s1">file </span><span class="s3">in </span><span class="s1">self.associated_files</span>
      <span class="s1">]</span>
    <span class="s3">return </span><span class="s1">tensor_metadata</span>


<span class="s3">class </span><span class="s1">InputImageTensorMd(TensorMd):</span>
  <span class="s2">&quot;&quot;&quot;A container for input image tensor metadata information. 
 
  Attributes: 
    norm_mean: the mean value used in tensor normalization [1]. 
    norm_std: the std value used in the tensor normalization [1]. norm_mean and 
      norm_std must have the same dimension. 
    color_space_type: the color space type of the input image [2]. 
    [1]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L389 
    [2]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L198 
  &quot;&quot;&quot;</span>

  <span class="s0"># Min and max float values for image pixels.</span>
  <span class="s1">_MIN_PIXEL = </span><span class="s4">0.0</span>
  <span class="s1">_MAX_PIXEL = </span><span class="s4">255.0</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">name: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">norm_mean: Optional[List[float]] = </span><span class="s3">None,</span>
      <span class="s1">norm_std: Optional[List[float]] = </span><span class="s3">None,</span>
      <span class="s1">color_space_type: Optional[int] = _metadata_fb.ColorSpaceType.UNKNOWN</span><span class="s3">,</span>
      <span class="s1">tensor_type: Optional[</span><span class="s5">&quot;_schema_fb.TensorType&quot;</span><span class="s1">] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Initializes the instance of InputImageTensorMd. 
 
    Args: 
      name: name of the tensor. 
      description: description of what the tensor is. 
      norm_mean: the mean value used in tensor normalization [1]. 
      norm_std: the std value used in the tensor normalization [1]. norm_mean 
        and norm_std must have the same dimension. 
      color_space_type: the color space type of the input image [2]. 
      tensor_type: data type of the tensor. 
      [1]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L389 
      [2]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L198 
 
    Raises: 
      ValueError: if norm_mean and norm_std have different dimensions. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">norm_std </span><span class="s3">and </span><span class="s1">norm_mean </span><span class="s3">and </span><span class="s1">len(norm_std) != len(norm_mean):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s5">f&quot;norm_mean and norm_std are expected to be the same dim. But got &quot;</span>
          <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">len(norm_mean)</span><span class="s3">} </span><span class="s5">and </span><span class="s3">{</span><span class="s1">len(norm_std)</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">tensor_type </span><span class="s3">is </span><span class="s1">_schema_fb.TensorType.UINT8:</span>
      <span class="s1">min_values = [_MIN_UINT8]</span>
      <span class="s1">max_values = [_MAX_UINT8]</span>
    <span class="s3">elif </span><span class="s1">tensor_type </span><span class="s3">is </span><span class="s1">_schema_fb.TensorType.FLOAT32 </span><span class="s3">and </span><span class="s1">norm_std </span><span class="s3">and </span><span class="s1">norm_mean:</span>
      <span class="s1">min_values = [</span>
          <span class="s1">float(self._MIN_PIXEL - mean) / std</span>
          <span class="s3">for </span><span class="s1">mean</span><span class="s3">, </span><span class="s1">std </span><span class="s3">in </span><span class="s1">zip(norm_mean</span><span class="s3">, </span><span class="s1">norm_std)</span>
      <span class="s1">]</span>
      <span class="s1">max_values = [</span>
          <span class="s1">float(self._MAX_PIXEL - mean) / std</span>
          <span class="s3">for </span><span class="s1">mean</span><span class="s3">, </span><span class="s1">std </span><span class="s3">in </span><span class="s1">zip(norm_mean</span><span class="s3">, </span><span class="s1">norm_std)</span>
      <span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># Uint8 and Float32 are the two major types currently. And Task library</span>
      <span class="s0"># doesn't support other types so far.</span>
      <span class="s1">min_values = </span><span class="s3">None</span>
      <span class="s1">max_values = </span><span class="s3">None</span>

    <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">description</span><span class="s3">, </span><span class="s1">min_values</span><span class="s3">, </span><span class="s1">max_values</span><span class="s3">,</span>
                     <span class="s1">_metadata_fb.ContentProperties.ImageProperties)</span>
    <span class="s1">self.norm_mean = norm_mean</span>
    <span class="s1">self.norm_std = norm_std</span>
    <span class="s1">self.color_space_type = color_space_type</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.TensorMetadataT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the input image metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the input image metadata. 
    &quot;&quot;&quot;</span>
    <span class="s1">tensor_metadata = super().create_metadata()</span>
    <span class="s1">tensor_metadata.content.contentProperties.colorSpace = self.color_space_type</span>
    <span class="s0"># Create normalization parameters</span>
    <span class="s3">if </span><span class="s1">self.norm_mean </span><span class="s3">and </span><span class="s1">self.norm_std:</span>
      <span class="s1">normalization = _metadata_fb.ProcessUnitT()</span>
      <span class="s1">normalization.optionsType = (</span>
          <span class="s1">_metadata_fb.ProcessUnitOptions.NormalizationOptions)</span>
      <span class="s1">normalization.options = _metadata_fb.NormalizationOptionsT()</span>
      <span class="s1">normalization.options.mean = self.norm_mean</span>
      <span class="s1">normalization.options.std = self.norm_std</span>
      <span class="s1">tensor_metadata.processUnits = [normalization]</span>
    <span class="s3">return </span><span class="s1">tensor_metadata</span>


<span class="s3">class </span><span class="s1">InputTextTensorMd(TensorMd):</span>
  <span class="s2">&quot;&quot;&quot;A container for the input text tensor metadata information. 
 
  Attributes: 
    tokenizer_md: information of the tokenizer in the input text tensor, if any. 
  &quot;&quot;&quot;</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">name: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
               <span class="s1">tokenizer_md: Optional[RegexTokenizerMd] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes the instance of InputTextTensorMd. 
 
    Args: 
      name: name of the tensor. 
      description: description of what the tensor is. 
      tokenizer_md: information of the tokenizer in the input text tensor, if 
        any. Only `RegexTokenizer` [1] is currenly supported. If the tokenizer 
        is `BertTokenizer` [2] or `SentencePieceTokenizer` [3], refer to 
        `BertInputTensorsMd` class. 
      [1]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L500 
      [2]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L477 
      [3]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L485 
    &quot;&quot;&quot;</span>
    <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">description)</span>
    <span class="s1">self.tokenizer_md = tokenizer_md</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.TensorMetadataT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the input text metadata based on the information. 
 
    Returns: 
      A Flatbuffers Python object of the input text metadata. 
 
    Raises: 
      ValueError: if the type of tokenizer_md is unsupported. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(self.tokenizer_md</span><span class="s3">, </span><span class="s1">(type(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">RegexTokenizerMd)):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s5">f&quot;The type of tokenizer_options, </span><span class="s3">{</span><span class="s1">type(self.tokenizer_md)</span><span class="s3">}</span><span class="s5">, is &quot;</span>
          <span class="s5">f&quot;unsupported&quot;</span><span class="s1">)</span>

    <span class="s1">tensor_metadata = super().create_metadata()</span>
    <span class="s3">if </span><span class="s1">self.tokenizer_md:</span>
      <span class="s1">tensor_metadata.processUnits = [self.tokenizer_md.create_metadata()]</span>
    <span class="s3">return </span><span class="s1">tensor_metadata</span>


<span class="s3">def </span><span class="s1">_get_file_paths(files: List[_metadata_fb.AssociatedFileT]) -&gt; List[str]:</span>
  <span class="s2">&quot;&quot;&quot;Gets file paths from a list of associated files.&quot;&quot;&quot;</span>
  <span class="s3">if not </span><span class="s1">files:</span>
    <span class="s3">return </span><span class="s1">[]</span>
  <span class="s3">return </span><span class="s1">[file.name </span><span class="s3">for </span><span class="s1">file </span><span class="s3">in </span><span class="s1">files]</span>


<span class="s3">def </span><span class="s1">_get_tokenizer_associated_files(</span>
    <span class="s1">tokenizer_options: Optional[</span>
        <span class="s1">Union[_metadata_fb.BertTokenizerOptionsT</span><span class="s3">,</span>
              <span class="s1">_metadata_fb.SentencePieceTokenizerOptionsT]]</span>
<span class="s1">) -&gt; List[str]:</span>
  <span class="s2">&quot;&quot;&quot;Gets a list of associated files packed in the tokenizer_options. 
 
  Args: 
    tokenizer_options: a tokenizer metadata object. Support the following 
      tokenizer types: 
      1. BertTokenizerOptions: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L477 
      2. SentencePieceTokenizerOptions: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L485 
 
  Returns: 
    A list of associated files included in tokenizer_options. 
  &quot;&quot;&quot;</span>

  <span class="s3">if not </span><span class="s1">tokenizer_options:</span>
    <span class="s3">return </span><span class="s1">[]</span>

  <span class="s3">if </span><span class="s1">isinstance(tokenizer_options</span><span class="s3">, </span><span class="s1">_metadata_fb.BertTokenizerOptionsT):</span>
    <span class="s3">return </span><span class="s1">_get_file_paths(tokenizer_options.vocabFile)</span>
  <span class="s3">elif </span><span class="s1">isinstance(tokenizer_options</span><span class="s3">,</span>
                  <span class="s1">_metadata_fb.SentencePieceTokenizerOptionsT):</span>
    <span class="s3">return </span><span class="s1">_get_file_paths(tokenizer_options.vocabFile) + _get_file_paths(</span>
        <span class="s1">tokenizer_options.sentencePieceModel)</span>
  <span class="s3">else</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">[]</span>


<span class="s3">class </span><span class="s1">BertInputTensorsMd:</span>
  <span class="s2">&quot;&quot;&quot;A container for the input tensor metadata information of Bert models.&quot;&quot;&quot;</span>

  <span class="s1">_IDS_NAME = </span><span class="s5">&quot;ids&quot;</span>
  <span class="s1">_IDS_DESCRIPTION = </span><span class="s5">&quot;Tokenized ids of the input text.&quot;</span>
  <span class="s1">_MASK_NAME = </span><span class="s5">&quot;mask&quot;</span>
  <span class="s1">_MASK_DESCRIPTION = (</span><span class="s5">&quot;Mask with 1 for real tokens and 0 for padding &quot;</span>
                       <span class="s5">&quot;tokens.&quot;</span><span class="s1">)</span>
  <span class="s1">_SEGMENT_IDS_NAME = </span><span class="s5">&quot;segment_ids&quot;</span>
  <span class="s1">_SEGMENT_IDS_DESCRIPTION = (</span>
      <span class="s5">&quot;0 for the first sequence, 1 for the second sequence if exists.&quot;</span><span class="s1">)</span>

  <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">,</span>
               <span class="s1">model_buffer: bytearray</span><span class="s3">,</span>
               <span class="s1">ids_name: str</span><span class="s3">,</span>
               <span class="s1">mask_name: str</span><span class="s3">,</span>
               <span class="s1">segment_name: str</span><span class="s3">,</span>
               <span class="s1">tokenizer_md: Union[</span><span class="s3">None, </span><span class="s1">BertTokenizerMd</span><span class="s3">,</span>
                                   <span class="s1">SentencePieceTokenizerMd] = </span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Initializes a BertInputTensorsMd object. 
 
    `ids_name`, `mask_name`, and `segment_name` correspond to the `Tensor.name` 
    in the TFLite schema, which help to determine the tensor order when 
    populating metadata. 
 
    Args: 
      model_buffer: valid buffer of the model file. 
      ids_name: name of the ids tensor, which represents the tokenized ids of 
        the input text. 
      mask_name: name of the mask tensor, which represents the mask with `1` for 
        real tokens and `0` for padding tokens. 
      segment_name: name of the segment ids tensor, where `0` stands for the 
        first sequence, and `1` stands for the second sequence if exists. 
      tokenizer_md: information of the tokenizer used to process the input 
        string, if any. Supported tokenizers are: `BertTokenizer` [1] and 
        `SentencePieceTokenizer` [2]. If the tokenizer is `RegexTokenizer` [3], 
        refer to `InputTensorsMd`. 
      [1]: 
        https://github.com/tensorflow/tflite-support/blob/b80289c4cd1224d0e1836c7654e82f070f9eefaa/tensorflow_lite_support/metadata/metadata_schema.fbs#L436 
      [2]: 
        https://github.com/tensorflow/tflite-support/blob/b80289c4cd1224d0e1836c7654e82f070f9eefaa/tensorflow_lite_support/metadata/metadata_schema.fbs#L473 
      [3]: 
        https://github.com/tensorflow/tflite-support/blob/b80289c4cd1224d0e1836c7654e82f070f9eefaa/tensorflow_lite_support/metadata/metadata_schema.fbs#L475 
    &quot;&quot;&quot;</span>
    <span class="s0"># Verify that tflite_input_names (read from the model) and</span>
    <span class="s0"># input_name (collected from users) are aligned.</span>
    <span class="s1">tflite_input_names = writer_utils.get_input_tensor_names(model_buffer)</span>
    <span class="s1">input_names = [ids_name</span><span class="s3">, </span><span class="s1">mask_name</span><span class="s3">, </span><span class="s1">segment_name]</span>
    <span class="s3">if </span><span class="s1">collections.Counter(tflite_input_names) != collections.Counter(</span>
        <span class="s1">input_names):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s5">f&quot;The input tensor names (</span><span class="s3">{</span><span class="s1">input_names</span><span class="s3">}</span><span class="s5">) do not match the tensor &quot;</span>
          <span class="s5">f&quot;names read from the model (</span><span class="s3">{</span><span class="s1">tflite_input_names</span><span class="s3">}</span><span class="s5">).&quot;</span><span class="s1">)</span>

    <span class="s1">ids_md = TensorMd(</span>
        <span class="s1">name=self._IDS_NAME</span><span class="s3">,</span>
        <span class="s1">description=self._IDS_DESCRIPTION</span><span class="s3">,</span>
        <span class="s1">tensor_name=ids_name)</span>

    <span class="s1">mask_md = TensorMd(</span>
        <span class="s1">name=self._MASK_NAME</span><span class="s3">,</span>
        <span class="s1">description=self._MASK_DESCRIPTION</span><span class="s3">,</span>
        <span class="s1">tensor_name=mask_name)</span>

    <span class="s1">segment_ids_md = TensorMd(</span>
        <span class="s1">name=self._SEGMENT_IDS_NAME</span><span class="s3">,</span>
        <span class="s1">description=self._SEGMENT_IDS_DESCRIPTION</span><span class="s3">,</span>
        <span class="s1">tensor_name=segment_name)</span>

    <span class="s1">self._input_md = [ids_md</span><span class="s3">, </span><span class="s1">mask_md</span><span class="s3">, </span><span class="s1">segment_ids_md]</span>

    <span class="s3">if not </span><span class="s1">isinstance(tokenizer_md</span><span class="s3">,</span>
                      <span class="s1">(type(</span><span class="s3">None</span><span class="s1">)</span><span class="s3">, </span><span class="s1">BertTokenizerMd</span><span class="s3">, </span><span class="s1">SentencePieceTokenizerMd)):</span>
      <span class="s3">raise </span><span class="s1">ValueError(</span>
          <span class="s5">f&quot;The type of tokenizer_options, </span><span class="s3">{</span><span class="s1">type(tokenizer_md)</span><span class="s3">}</span><span class="s5">, is unsupported&quot;</span>
      <span class="s1">)</span>

    <span class="s1">self._tokenizer_md = tokenizer_md</span>

  <span class="s3">def </span><span class="s1">create_input_process_unit_metadata(</span>
      <span class="s1">self) -&gt; List[_metadata_fb.ProcessUnitT]:</span>
    <span class="s2">&quot;&quot;&quot;Creates the input process unit metadata.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self._tokenizer_md:</span>
      <span class="s3">return </span><span class="s1">[self._tokenizer_md.create_metadata()]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">[]</span>

  <span class="s3">def </span><span class="s1">get_tokenizer_associated_files(self) -&gt; List[str]:</span>
    <span class="s2">&quot;&quot;&quot;Gets the associated files that are packed in the tokenizer.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">self._tokenizer_md:</span>
      <span class="s3">return </span><span class="s1">_get_tokenizer_associated_files(</span>
          <span class="s1">self._tokenizer_md.create_metadata().options)</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s3">return </span><span class="s1">[]</span>

  <span class="s1">@property</span>
  <span class="s3">def </span><span class="s1">input_md(self) -&gt; List[TensorMd]:</span>
    <span class="s3">return </span><span class="s1">self._input_md</span>


<span class="s3">class </span><span class="s1">ClassificationTensorMd(TensorMd):</span>
  <span class="s2">&quot;&quot;&quot;A container for the classification tensor metadata information. 
 
  Attributes: 
    label_files: information of the label files [1] in the classification 
      tensor. 
    score_calibration_md: information of the score calibration operation [2] in 
      the classification tensor. 
    score_thresholding_md: information of the score thresholding [3] in the 
        classification tensor. 
    [1]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L99 
    [2]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L456 
    [3]: 
      https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L468 
  &quot;&quot;&quot;</span>

  <span class="s0"># Min and max float values for classification results.</span>
  <span class="s1">_MIN_FLOAT = </span><span class="s4">0.0</span>
  <span class="s1">_MAX_FLOAT = </span><span class="s4">1.0</span>

  <span class="s3">def </span><span class="s1">__init__(</span>
      <span class="s1">self</span><span class="s3">,</span>
      <span class="s1">name: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">description: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">label_files: Optional[List[LabelFileMd]] = </span><span class="s3">None,</span>
      <span class="s1">tensor_type: Optional[int] = </span><span class="s3">None,</span>
      <span class="s1">score_calibration_md: Optional[ScoreCalibrationMd] = </span><span class="s3">None,</span>
      <span class="s1">tensor_name: Optional[str] = </span><span class="s3">None,</span>
      <span class="s1">score_thresholding_md: Optional[ScoreThresholdingMd] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Initializes the instance of ClassificationTensorMd. 
 
    Args: 
      name: name of the tensor. 
      description: description of what the tensor is. 
      label_files: information of the label files [1] in the classification 
        tensor. 
      tensor_type: data type of the tensor. 
      score_calibration_md: information of the score calibration files operation 
        [2] in the classification tensor. 
      tensor_name: name of the corresponding tensor [3] in the TFLite model. It 
        is used to locate the corresponding classification tensor and decide the 
        order of the tensor metadata [4] when populating model metadata. 
      score_thresholding_md: information of the score thresholding [5] in the 
        classification tensor. 
      [1]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L99 
      [2]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L456 
      [3]: 
        https://github.com/tensorflow/tensorflow/blob/cb67fef35567298b40ac166b0581cd8ad68e5a3a/tensorflow/lite/schema/schema.fbs#L1129-L1136 
      [4]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L623-L640 
      [5]: 
        https://github.com/google/mediapipe/blob/f8af41b1eb49ff4bdad756ff19d1d36f486be614/mediapipe/tasks/metadata/metadata_schema.fbs#L468 
    &quot;&quot;&quot;</span>
    <span class="s1">self.score_calibration_md = score_calibration_md</span>
    <span class="s1">self.score_thresholding_md = score_thresholding_md</span>

    <span class="s3">if </span><span class="s1">tensor_type </span><span class="s3">is </span><span class="s1">_schema_fb.TensorType.UINT8:</span>
      <span class="s1">min_values = [_MIN_UINT8]</span>
      <span class="s1">max_values = [_MAX_UINT8]</span>
    <span class="s3">elif </span><span class="s1">tensor_type </span><span class="s3">is </span><span class="s1">_schema_fb.TensorType.FLOAT32:</span>
      <span class="s1">min_values = [self._MIN_FLOAT]</span>
      <span class="s1">max_values = [self._MAX_FLOAT]</span>
    <span class="s3">else</span><span class="s1">:</span>
      <span class="s0"># Uint8 and Float32 are the two major types currently. And Task library</span>
      <span class="s0"># doesn't support other types so far.</span>
      <span class="s1">min_values = </span><span class="s3">None</span>
      <span class="s1">max_values = </span><span class="s3">None</span>

    <span class="s1">associated_files = label_files </span><span class="s3">or </span><span class="s1">[]</span>
    <span class="s3">if </span><span class="s1">self.score_calibration_md:</span>
      <span class="s1">associated_files.append(</span>
          <span class="s1">score_calibration_md.create_score_calibration_file_md())</span>

    <span class="s1">super().__init__(name</span><span class="s3">, </span><span class="s1">description</span><span class="s3">, </span><span class="s1">min_values</span><span class="s3">, </span><span class="s1">max_values</span><span class="s3">,</span>
                     <span class="s1">_metadata_fb.ContentProperties.FeatureProperties</span><span class="s3">,</span>
                     <span class="s1">associated_files</span><span class="s3">, </span><span class="s1">tensor_name)</span>

  <span class="s3">def </span><span class="s1">create_metadata(self) -&gt; _metadata_fb.TensorMetadataT:</span>
    <span class="s2">&quot;&quot;&quot;Creates the classification tensor metadata based on the information.&quot;&quot;&quot;</span>
    <span class="s1">tensor_metadata = super().create_metadata()</span>
    <span class="s3">if </span><span class="s1">self.score_calibration_md:</span>
      <span class="s1">tensor_metadata.processUnits = [</span>
          <span class="s1">self.score_calibration_md.create_metadata()</span>
      <span class="s1">]</span>
    <span class="s3">if </span><span class="s1">self.score_thresholding_md:</span>
      <span class="s3">if </span><span class="s1">tensor_metadata.processUnits:</span>
        <span class="s1">tensor_metadata.processUnits.append(</span>
            <span class="s1">self.score_thresholding_md.create_metadata())</span>
      <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tensor_metadata.processUnits = [</span>
            <span class="s1">self.score_thresholding_md.create_metadata()</span>
        <span class="s1">]</span>
    <span class="s3">return </span><span class="s1">tensor_metadata</span>
</pre>
</body>
</html>