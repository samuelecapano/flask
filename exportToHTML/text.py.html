<html>
<head>
<title>text.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
text.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Classes for including text in a figure. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Real</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">cbook</span><span class="s2">, </span><span class="s1">_docstring</span>
<span class="s2">from </span><span class="s1">.artist </span><span class="s2">import </span><span class="s1">Artist</span>
<span class="s2">from </span><span class="s1">.font_manager </span><span class="s2">import </span><span class="s1">FontProperties</span>
<span class="s2">from </span><span class="s1">.patches </span><span class="s2">import </span><span class="s1">FancyArrowPatch</span><span class="s2">, </span><span class="s1">FancyBboxPatch</span><span class="s2">, </span><span class="s1">Rectangle</span>
<span class="s2">from </span><span class="s1">.textpath </span><span class="s2">import </span><span class="s1">TextPath</span><span class="s2">, </span><span class="s1">TextToPath  </span><span class="s3"># noqa # Logically located here</span>
<span class="s2">from </span><span class="s1">.transforms </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Affine2D</span><span class="s2">, </span><span class="s1">Bbox</span><span class="s2">, </span><span class="s1">BboxBase</span><span class="s2">, </span><span class="s1">BboxTransformTo</span><span class="s2">, </span><span class="s1">IdentityTransform</span><span class="s2">, </span><span class="s1">Transform)</span>


<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.6&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">get_rotation(rotation):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return *rotation* normalized to an angle between 0 and 360 degrees. 
 
    Parameters 
    ---------- 
    rotation : float or {None, 'horizontal', 'vertical'} 
        Rotation angle in degrees. *None* and 'horizontal' equal 0, 
        'vertical' equals 90. 
 
    Returns 
    ------- 
    float 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">float(rotation) % </span><span class="s5">360</span>
    <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError) </span><span class="s2">as </span><span class="s1">err:</span>
        <span class="s2">if </span><span class="s1">cbook._str_equal(rotation</span><span class="s2">, </span><span class="s4">'horizontal'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">rotation </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">0.</span>
        <span class="s2">elif </span><span class="s1">cbook._str_equal(rotation</span><span class="s2">, </span><span class="s4">'vertical'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s5">90.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;rotation is {!r}; expected either 'horizontal', &quot;</span>
                             <span class="s4">&quot;'vertical', numeric value, or None&quot;</span>
                             <span class="s1">.format(rotation)) </span><span class="s2">from </span><span class="s1">err</span>


<span class="s2">def </span><span class="s1">_get_textbox(text</span><span class="s2">, </span><span class="s1">renderer):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the bounding box of the text. 
 
    The bbox position takes text rotation into account, but the width and 
    height are those of the unrotated box (unlike `.Text.get_window_extent`). 
    &quot;&quot;&quot;</span>
    <span class="s3"># TODO : This function may move into the Text class as a method. As a</span>
    <span class="s3"># matter of fact, the information from the _get_textbox function</span>
    <span class="s3"># should be available during the Text._get_layout() call, which is</span>
    <span class="s3"># called within the _get_textbox. So, it would better to move this</span>
    <span class="s3"># function as a method with some refactoring of _get_layout method.</span>

    <span class="s1">projected_xs = []</span>
    <span class="s1">projected_ys = []</span>

    <span class="s1">theta = np.deg2rad(text.get_rotation())</span>
    <span class="s1">tr = Affine2D().rotate(-theta)</span>

    <span class="s1">_</span><span class="s2">, </span><span class="s1">parts</span><span class="s2">, </span><span class="s1">d = text._get_layout(renderer)</span>

    <span class="s2">for </span><span class="s1">t</span><span class="s2">, </span><span class="s1">wh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">parts:</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h = wh</span>

        <span class="s1">xt1</span><span class="s2">, </span><span class="s1">yt1 = tr.transform((x</span><span class="s2">, </span><span class="s1">y))</span>
        <span class="s1">yt1 -= d</span>
        <span class="s1">xt2</span><span class="s2">, </span><span class="s1">yt2 = xt1 + w</span><span class="s2">, </span><span class="s1">yt1 + h</span>

        <span class="s1">projected_xs.extend([xt1</span><span class="s2">, </span><span class="s1">xt2])</span>
        <span class="s1">projected_ys.extend([yt1</span><span class="s2">, </span><span class="s1">yt2])</span>

    <span class="s1">xt_box</span><span class="s2">, </span><span class="s1">yt_box = min(projected_xs)</span><span class="s2">, </span><span class="s1">min(projected_ys)</span>
    <span class="s1">w_box</span><span class="s2">, </span><span class="s1">h_box = max(projected_xs) - xt_box</span><span class="s2">, </span><span class="s1">max(projected_ys) - yt_box</span>

    <span class="s1">x_box</span><span class="s2">, </span><span class="s1">y_box = Affine2D().rotate(theta).transform((xt_box</span><span class="s2">, </span><span class="s1">yt_box))</span>

    <span class="s2">return </span><span class="s1">x_box</span><span class="s2">, </span><span class="s1">y_box</span><span class="s2">, </span><span class="s1">w_box</span><span class="s2">, </span><span class="s1">h_box</span>


<span class="s2">def </span><span class="s1">_get_text_metrics_with_cache(renderer</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">fontprop</span><span class="s2">, </span><span class="s1">ismath</span><span class="s2">, </span><span class="s1">dpi):</span>
    <span class="s0">&quot;&quot;&quot;Call ``renderer.get_text_width_height_descent``, caching the results.&quot;&quot;&quot;</span>
    <span class="s3"># Cached based on a copy of fontprop so that later in-place mutations of</span>
    <span class="s3"># the passed-in argument do not mess up the cache.</span>
    <span class="s2">return </span><span class="s1">_get_text_metrics_with_cache_impl(</span>
        <span class="s1">weakref.ref(renderer)</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">fontprop.copy()</span><span class="s2">, </span><span class="s1">ismath</span><span class="s2">, </span><span class="s1">dpi)</span>


<span class="s1">@functools.lru_cache(</span><span class="s5">4096</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_get_text_metrics_with_cache_impl(</span>
        <span class="s1">renderer_ref</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">fontprop</span><span class="s2">, </span><span class="s1">ismath</span><span class="s2">, </span><span class="s1">dpi):</span>
    <span class="s3"># dpi is unused, but participates in cache invalidation (via the renderer).</span>
    <span class="s2">return </span><span class="s1">renderer_ref().get_text_width_height_descent(text</span><span class="s2">, </span><span class="s1">fontprop</span><span class="s2">, </span><span class="s1">ismath)</span>


<span class="s1">@_docstring.interpd</span>
<span class="s1">@_api.define_aliases({</span>
    <span class="s4">&quot;color&quot;</span><span class="s1">: [</span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontfamily&quot;</span><span class="s1">: [</span><span class="s4">&quot;family&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontproperties&quot;</span><span class="s1">: [</span><span class="s4">&quot;font&quot;</span><span class="s2">, </span><span class="s4">&quot;font_properties&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;horizontalalignment&quot;</span><span class="s1">: [</span><span class="s4">&quot;ha&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;multialignment&quot;</span><span class="s1">: [</span><span class="s4">&quot;ma&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontname&quot;</span><span class="s1">: [</span><span class="s4">&quot;name&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontsize&quot;</span><span class="s1">: [</span><span class="s4">&quot;size&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontstretch&quot;</span><span class="s1">: [</span><span class="s4">&quot;stretch&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontstyle&quot;</span><span class="s1">: [</span><span class="s4">&quot;style&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontvariant&quot;</span><span class="s1">: [</span><span class="s4">&quot;variant&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;verticalalignment&quot;</span><span class="s1">: [</span><span class="s4">&quot;va&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s4">&quot;fontweight&quot;</span><span class="s1">: [</span><span class="s4">&quot;weight&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">})</span>
<span class="s2">class </span><span class="s1">Text(Artist):</span>
    <span class="s0">&quot;&quot;&quot;Handle storing and drawing of text in window or data coordinates.&quot;&quot;&quot;</span>

    <span class="s1">zorder = </span><span class="s5">3</span>
    <span class="s1">_charsize_cache = dict()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;Text(%s, %s, %s)&quot; </span><span class="s1">% (self._x</span><span class="s2">, </span><span class="s1">self._y</span><span class="s2">, </span><span class="s1">repr(self._text))</span>

    <span class="s1">@_api.make_keyword_only(</span><span class="s4">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;color&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">x=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">y=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">text=</span><span class="s4">''</span><span class="s2">,</span>
                 <span class="s1">color=</span><span class="s2">None,           </span><span class="s3"># defaults to rc params</span>
                 <span class="s1">verticalalignment=</span><span class="s4">'baseline'</span><span class="s2">,</span>
                 <span class="s1">horizontalalignment=</span><span class="s4">'left'</span><span class="s2">,</span>
                 <span class="s1">multialignment=</span><span class="s2">None,</span>
                 <span class="s1">fontproperties=</span><span class="s2">None,  </span><span class="s3"># defaults to FontProperties()</span>
                 <span class="s1">rotation=</span><span class="s2">None,</span>
                 <span class="s1">linespacing=</span><span class="s2">None,</span>
                 <span class="s1">rotation_mode=</span><span class="s2">None,</span>
                 <span class="s1">usetex=</span><span class="s2">None,          </span><span class="s3"># defaults to rcParams['text.usetex']</span>
                 <span class="s1">wrap=</span><span class="s2">False,</span>
                 <span class="s1">transform_rotates_text=</span><span class="s2">False,</span>
                 <span class="s1">*</span><span class="s2">,</span>
                 <span class="s1">parse_math=</span><span class="s2">None,    </span><span class="s3"># defaults to rcParams['text.parse_math']</span>
                 <span class="s1">**kwargs</span>
                 <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Create a `.Text` instance at *x*, *y* with string *text*. 
 
        The text is aligned relative to the anchor point (*x*, *y*) according 
        to ``horizontalalignment`` (default: 'left') and ``verticalalignment`` 
        (default: 'bottom'). See also 
        :doc:`/gallery/text_labels_and_annotations/text_alignment`. 
 
        While Text accepts the 'label' keyword argument, by default it is not 
        added to the handles of a legend. 
 
        Valid keyword arguments are: 
 
        %(Text:kwdoc)s 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self._x</span><span class="s2">, </span><span class="s1">self._y = x</span><span class="s2">, </span><span class="s1">y</span>
        <span class="s1">self._text = </span><span class="s4">''</span>
        <span class="s1">self._reset_visual_defaults(</span>
            <span class="s1">text=text</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">,</span>
            <span class="s1">fontproperties=fontproperties</span><span class="s2">,</span>
            <span class="s1">usetex=usetex</span><span class="s2">,</span>
            <span class="s1">parse_math=parse_math</span><span class="s2">,</span>
            <span class="s1">wrap=wrap</span><span class="s2">,</span>
            <span class="s1">verticalalignment=verticalalignment</span><span class="s2">,</span>
            <span class="s1">horizontalalignment=horizontalalignment</span><span class="s2">,</span>
            <span class="s1">multialignment=multialignment</span><span class="s2">,</span>
            <span class="s1">rotation=rotation</span><span class="s2">,</span>
            <span class="s1">transform_rotates_text=transform_rotates_text</span><span class="s2">,</span>
            <span class="s1">linespacing=linespacing</span><span class="s2">,</span>
            <span class="s1">rotation_mode=rotation_mode</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.update(kwargs)</span>

    <span class="s2">def </span><span class="s1">_reset_visual_defaults(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">text=</span><span class="s4">''</span><span class="s2">,</span>
        <span class="s1">color=</span><span class="s2">None,</span>
        <span class="s1">fontproperties=</span><span class="s2">None,</span>
        <span class="s1">usetex=</span><span class="s2">None,</span>
        <span class="s1">parse_math=</span><span class="s2">None,</span>
        <span class="s1">wrap=</span><span class="s2">False,</span>
        <span class="s1">verticalalignment=</span><span class="s4">'baseline'</span><span class="s2">,</span>
        <span class="s1">horizontalalignment=</span><span class="s4">'left'</span><span class="s2">,</span>
        <span class="s1">multialignment=</span><span class="s2">None,</span>
        <span class="s1">rotation=</span><span class="s2">None,</span>
        <span class="s1">transform_rotates_text=</span><span class="s2">False,</span>
        <span class="s1">linespacing=</span><span class="s2">None,</span>
        <span class="s1">rotation_mode=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.set_text(text)</span>
        <span class="s1">self.set_color(</span>
            <span class="s1">color </span><span class="s2">if </span><span class="s1">color </span><span class="s2">is not None else </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;text.color&quot;</span><span class="s1">])</span>
        <span class="s1">self.set_fontproperties(fontproperties)</span>
        <span class="s1">self.set_usetex(usetex)</span>
        <span class="s1">self.set_parse_math(parse_math </span><span class="s2">if </span><span class="s1">parse_math </span><span class="s2">is not None else</span>
                            <span class="s1">mpl.rcParams[</span><span class="s4">'text.parse_math'</span><span class="s1">])</span>
        <span class="s1">self.set_wrap(wrap)</span>
        <span class="s1">self.set_verticalalignment(verticalalignment)</span>
        <span class="s1">self.set_horizontalalignment(horizontalalignment)</span>
        <span class="s1">self._multialignment = multialignment</span>
        <span class="s1">self.set_rotation(rotation)</span>
        <span class="s1">self._transform_rotates_text = transform_rotates_text</span>
        <span class="s1">self._bbox_patch = </span><span class="s2">None  </span><span class="s3"># a FancyBboxPatch instance</span>
        <span class="s1">self._renderer = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">linespacing </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">linespacing = </span><span class="s5">1.2  </span><span class="s3"># Maybe use rcParam later.</span>
        <span class="s1">self.set_linespacing(linespacing)</span>
        <span class="s1">self.set_rotation_mode(rotation_mode)</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">kwargs):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">kwargs = cbook.normalize_kwargs(kwargs</span><span class="s2">, </span><span class="s1">Text)</span>
        <span class="s1">sentinel = object()  </span><span class="s3"># bbox can be None, so use another sentinel.</span>
        <span class="s3"># Update fontproperties first, as it has lowest priority.</span>
        <span class="s1">fontproperties = kwargs.pop(</span><span class="s4">&quot;fontproperties&quot;</span><span class="s2">, </span><span class="s1">sentinel)</span>
        <span class="s2">if </span><span class="s1">fontproperties </span><span class="s2">is not </span><span class="s1">sentinel:</span>
            <span class="s1">self.set_fontproperties(fontproperties)</span>
        <span class="s3"># Update bbox last, as it depends on font properties.</span>
        <span class="s1">bbox = kwargs.pop(</span><span class="s4">&quot;bbox&quot;</span><span class="s2">, </span><span class="s1">sentinel)</span>
        <span class="s1">super().update(kwargs)</span>
        <span class="s2">if </span><span class="s1">bbox </span><span class="s2">is not </span><span class="s1">sentinel:</span>
            <span class="s1">self.set_bbox(bbox)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s1">d = super().__getstate__()</span>
        <span class="s3"># remove the cached _renderer (if it exists)</span>
        <span class="s1">d[</span><span class="s4">'_renderer'</span><span class="s1">] = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">d</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">mouseevent):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether the mouse event occurred inside the axis-aligned 
        bounding-box of the text. 
        &quot;&quot;&quot;</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(mouseevent)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>

        <span class="s2">if not </span><span class="s1">self.get_visible() </span><span class="s2">or </span><span class="s1">self._renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return False, </span><span class="s1">{}</span>

        <span class="s3"># Explicitly use Text.get_window_extent(self) and not</span>
        <span class="s3"># self.get_window_extent() so that Annotation.contains does not</span>
        <span class="s3"># accidentally cover the entire annotation bounding box.</span>
        <span class="s1">bbox = Text.get_window_extent(self)</span>
        <span class="s1">inside = (bbox.x0 &lt;= mouseevent.x &lt;= bbox.x1</span>
                  <span class="s2">and </span><span class="s1">bbox.y0 &lt;= mouseevent.y &lt;= bbox.y1)</span>

        <span class="s1">cattr = {}</span>
        <span class="s3"># if the text has a surrounding patch, also check containment for it,</span>
        <span class="s3"># and merge the results with the results for the text.</span>
        <span class="s2">if </span><span class="s1">self._bbox_patch:</span>
            <span class="s1">patch_inside</span><span class="s2">, </span><span class="s1">patch_cattr = self._bbox_patch.contains(mouseevent)</span>
            <span class="s1">inside = inside </span><span class="s2">or </span><span class="s1">patch_inside</span>
            <span class="s1">cattr[</span><span class="s4">&quot;bbox_patch&quot;</span><span class="s1">] = patch_cattr</span>

        <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">cattr</span>

    <span class="s2">def </span><span class="s1">_get_xy_display(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the (possibly unit converted) transformed x, y in display coords. 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.get_unitless_position()</span>
        <span class="s2">return </span><span class="s1">self.get_transform().transform((x</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s2">def </span><span class="s1">_get_multialignment(self):</span>
        <span class="s2">if </span><span class="s1">self._multialignment </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._multialignment</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._horizontalalignment</span>

    <span class="s2">def </span><span class="s1">_char_index_at(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Calculate the index closest to the coordinate x in display space. 
 
        The position of text[index] is assumed to be the sum of the widths 
        of all preceding characters text[:index]. 
 
        This works only on single line texts. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._text:</span>
            <span class="s2">return </span><span class="s5">0</span>

        <span class="s1">text = self._text</span>

        <span class="s1">fontproperties = str(self._fontproperties)</span>
        <span class="s2">if </span><span class="s1">fontproperties </span><span class="s2">not in </span><span class="s1">Text._charsize_cache:</span>
            <span class="s1">Text._charsize_cache[fontproperties] = dict()</span>

        <span class="s1">charsize_cache = Text._charsize_cache[fontproperties]</span>
        <span class="s2">for </span><span class="s1">char </span><span class="s2">in </span><span class="s1">set(text):</span>
            <span class="s2">if </span><span class="s1">char </span><span class="s2">not in </span><span class="s1">charsize_cache:</span>
                <span class="s1">self.set_text(char)</span>
                <span class="s1">bb = self.get_window_extent()</span>
                <span class="s1">charsize_cache[char] = bb.x1 - bb.x0</span>

        <span class="s1">self.set_text(text)</span>
        <span class="s1">bb = self.get_window_extent()</span>

        <span class="s1">size_accum = np.cumsum([</span><span class="s5">0</span><span class="s1">] + [charsize_cache[x] </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">text])</span>
        <span class="s1">std_x = x - bb.x0</span>
        <span class="s2">return </span><span class="s1">(np.abs(size_accum - std_x)).argmin()</span>

    <span class="s2">def </span><span class="s1">get_rotation(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the text angle in degrees between 0 and 360.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.get_transform_rotates_text():</span>
            <span class="s2">return </span><span class="s1">self.get_transform().transform_angles(</span>
                <span class="s1">[self._rotation]</span><span class="s2">, </span><span class="s1">[self.get_unitless_position()]).item(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._rotation</span>

    <span class="s2">def </span><span class="s1">get_transform_rotates_text(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether rotations of the transform affect the text direction. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._transform_rotates_text</span>

    <span class="s2">def </span><span class="s1">set_rotation_mode(self</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set text rotation mode. 
 
        Parameters 
        ---------- 
        m : {None, 'default', 'anchor'} 
            If ``None`` or ``&quot;default&quot;``, the text will be first rotated, then 
            aligned according to their horizontal and vertical alignments.  If 
            ``&quot;anchor&quot;``, then alignment occurs before rotation. 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">&quot;anchor&quot;</span><span class="s2">, </span><span class="s4">&quot;default&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rotation_mode=m)</span>
        <span class="s1">self._rotation_mode = m</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_rotation_mode(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the text rotation mode.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._rotation_mode</span>

    <span class="s2">def </span><span class="s1">update_from(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s1">super().update_from(other)</span>
        <span class="s1">self._color = other._color</span>
        <span class="s1">self._multialignment = other._multialignment</span>
        <span class="s1">self._verticalalignment = other._verticalalignment</span>
        <span class="s1">self._horizontalalignment = other._horizontalalignment</span>
        <span class="s1">self._fontproperties = other._fontproperties.copy()</span>
        <span class="s1">self._usetex = other._usetex</span>
        <span class="s1">self._rotation = other._rotation</span>
        <span class="s1">self._transform_rotates_text = other._transform_rotates_text</span>
        <span class="s1">self._picker = other._picker</span>
        <span class="s1">self._linespacing = other._linespacing</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_get_layout(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the extent (bbox) of the text together with 
        multiple-alignment information. Note that it returns an extent 
        of a rotated text when necessary. 
        &quot;&quot;&quot;</span>
        <span class="s1">thisx</span><span class="s2">, </span><span class="s1">thisy = </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span>
        <span class="s1">lines = self.get_text().split(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)  </span><span class="s3"># Ensures lines is not empty.</span>

        <span class="s1">ws = []</span>
        <span class="s1">hs = []</span>
        <span class="s1">xs = []</span>
        <span class="s1">ys = []</span>

        <span class="s3"># Full vertical extent of font, including ascenders and descenders:</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">lp_h</span><span class="s2">, </span><span class="s1">lp_d = _get_text_metrics_with_cache(</span>
            <span class="s1">renderer</span><span class="s2">, </span><span class="s4">&quot;lp&quot;</span><span class="s2">, </span><span class="s1">self._fontproperties</span><span class="s2">,</span>
            <span class="s1">ismath=</span><span class="s4">&quot;TeX&quot; </span><span class="s2">if </span><span class="s1">self.get_usetex() </span><span class="s2">else False, </span><span class="s1">dpi=self.figure.dpi)</span>
        <span class="s1">min_dy = (lp_h - lp_d) * self._linespacing</span>

        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">line </span><span class="s2">in </span><span class="s1">enumerate(lines):</span>
            <span class="s1">clean_line</span><span class="s2">, </span><span class="s1">ismath = self._preprocess_math(line)</span>
            <span class="s2">if </span><span class="s1">clean_line:</span>
                <span class="s1">w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">d = _get_text_metrics_with_cache(</span>
                    <span class="s1">renderer</span><span class="s2">, </span><span class="s1">clean_line</span><span class="s2">, </span><span class="s1">self._fontproperties</span><span class="s2">,</span>
                    <span class="s1">ismath=ismath</span><span class="s2">, </span><span class="s1">dpi=self.figure.dpi)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">w = h = d = </span><span class="s5">0</span>

            <span class="s3"># For multiline text, increase the line spacing when the text</span>
            <span class="s3"># net-height (excluding baseline) is larger than that of a &quot;l&quot;</span>
            <span class="s3"># (e.g., use of superscripts), which seems what TeX does.</span>
            <span class="s1">h = max(h</span><span class="s2">, </span><span class="s1">lp_h)</span>
            <span class="s1">d = max(d</span><span class="s2">, </span><span class="s1">lp_d)</span>

            <span class="s1">ws.append(w)</span>
            <span class="s1">hs.append(h)</span>

            <span class="s3"># Metrics of the last line that are needed later:</span>
            <span class="s1">baseline = (h - d) - thisy</span>

            <span class="s2">if </span><span class="s1">i == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3"># position at baseline</span>
                <span class="s1">thisy = -(h - d)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># put baseline a good distance from bottom of previous line</span>
                <span class="s1">thisy -= max(min_dy</span><span class="s2">, </span><span class="s1">(h - d) * self._linespacing)</span>

            <span class="s1">xs.append(thisx)  </span><span class="s3"># == 0.</span>
            <span class="s1">ys.append(thisy)</span>

            <span class="s1">thisy -= d</span>

        <span class="s3"># Metrics of the last line that are needed later:</span>
        <span class="s1">descent = d</span>

        <span class="s3"># Bounding box definition:</span>
        <span class="s1">width = max(ws)</span>
        <span class="s1">xmin = </span><span class="s5">0</span>
        <span class="s1">xmax = width</span>
        <span class="s1">ymax = </span><span class="s5">0</span>
        <span class="s1">ymin = ys[-</span><span class="s5">1</span><span class="s1">] - descent  </span><span class="s3"># baseline of last line minus its descent</span>

        <span class="s3"># get the rotation matrix</span>
        <span class="s1">M = Affine2D().rotate_deg(self.get_rotation())</span>

        <span class="s3"># now offset the individual text lines within the box</span>
        <span class="s1">malign = self._get_multialignment()</span>
        <span class="s2">if </span><span class="s1">malign == </span><span class="s4">'left'</span><span class="s1">:</span>
            <span class="s1">offset_layout = [(x</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">ys)]</span>
        <span class="s2">elif </span><span class="s1">malign == </span><span class="s4">'center'</span><span class="s1">:</span>
            <span class="s1">offset_layout = [(x + width / </span><span class="s5">2 </span><span class="s1">- w / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">y)</span>
                             <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">ws)]</span>
        <span class="s2">elif </span><span class="s1">malign == </span><span class="s4">'right'</span><span class="s1">:</span>
            <span class="s1">offset_layout = [(x + width - w</span><span class="s2">, </span><span class="s1">y)</span>
                             <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">zip(xs</span><span class="s2">, </span><span class="s1">ys</span><span class="s2">, </span><span class="s1">ws)]</span>

        <span class="s3"># the corners of the unrotated bounding box</span>
        <span class="s1">corners_horiz = np.array(</span>
            <span class="s1">[(xmin</span><span class="s2">, </span><span class="s1">ymin)</span><span class="s2">, </span><span class="s1">(xmin</span><span class="s2">, </span><span class="s1">ymax)</span><span class="s2">, </span><span class="s1">(xmax</span><span class="s2">, </span><span class="s1">ymax)</span><span class="s2">, </span><span class="s1">(xmax</span><span class="s2">, </span><span class="s1">ymin)])</span>

        <span class="s3"># now rotate the bbox</span>
        <span class="s1">corners_rotated = M.transform(corners_horiz)</span>
        <span class="s3"># compute the bounds of the rotated box</span>
        <span class="s1">xmin = corners_rotated[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">].min()</span>
        <span class="s1">xmax = corners_rotated[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">].max()</span>
        <span class="s1">ymin = corners_rotated[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">].min()</span>
        <span class="s1">ymax = corners_rotated[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">].max()</span>
        <span class="s1">width = xmax - xmin</span>
        <span class="s1">height = ymax - ymin</span>

        <span class="s3"># Now move the box to the target position offset the display</span>
        <span class="s3"># bbox by alignment</span>
        <span class="s1">halign = self._horizontalalignment</span>
        <span class="s1">valign = self._verticalalignment</span>

        <span class="s1">rotation_mode = self.get_rotation_mode()</span>
        <span class="s2">if </span><span class="s1">rotation_mode != </span><span class="s4">&quot;anchor&quot;</span><span class="s1">:</span>
            <span class="s3"># compute the text location in display coords and the offsets</span>
            <span class="s3"># necessary to align the bbox with that location</span>
            <span class="s2">if </span><span class="s1">halign == </span><span class="s4">'center'</span><span class="s1">:</span>
                <span class="s1">offsetx = (xmin + xmax) / </span><span class="s5">2</span>
            <span class="s2">elif </span><span class="s1">halign == </span><span class="s4">'right'</span><span class="s1">:</span>
                <span class="s1">offsetx = xmax</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">offsetx = xmin</span>

            <span class="s2">if </span><span class="s1">valign == </span><span class="s4">'center'</span><span class="s1">:</span>
                <span class="s1">offsety = (ymin + ymax) / </span><span class="s5">2</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'top'</span><span class="s1">:</span>
                <span class="s1">offsety = ymax</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'baseline'</span><span class="s1">:</span>
                <span class="s1">offsety = ymin + descent</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'center_baseline'</span><span class="s1">:</span>
                <span class="s1">offsety = ymin + height - baseline / </span><span class="s5">2.0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">offsety = ymin</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xmin1</span><span class="s2">, </span><span class="s1">ymin1 = corners_horiz[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">xmax1</span><span class="s2">, </span><span class="s1">ymax1 = corners_horiz[</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s2">if </span><span class="s1">halign == </span><span class="s4">'center'</span><span class="s1">:</span>
                <span class="s1">offsetx = (xmin1 + xmax1) / </span><span class="s5">2.0</span>
            <span class="s2">elif </span><span class="s1">halign == </span><span class="s4">'right'</span><span class="s1">:</span>
                <span class="s1">offsetx = xmax1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">offsetx = xmin1</span>

            <span class="s2">if </span><span class="s1">valign == </span><span class="s4">'center'</span><span class="s1">:</span>
                <span class="s1">offsety = (ymin1 + ymax1) / </span><span class="s5">2.0</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'top'</span><span class="s1">:</span>
                <span class="s1">offsety = ymax1</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'baseline'</span><span class="s1">:</span>
                <span class="s1">offsety = ymax1 - baseline</span>
            <span class="s2">elif </span><span class="s1">valign == </span><span class="s4">'center_baseline'</span><span class="s1">:</span>
                <span class="s1">offsety = ymax1 - baseline / </span><span class="s5">2.0</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">offsety = ymin1</span>

            <span class="s1">offsetx</span><span class="s2">, </span><span class="s1">offsety = M.transform((offsetx</span><span class="s2">, </span><span class="s1">offsety))</span>

        <span class="s1">xmin -= offsetx</span>
        <span class="s1">ymin -= offsety</span>

        <span class="s1">bbox = Bbox.from_bounds(xmin</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">height)</span>

        <span class="s3"># now rotate the positions around the first (x, y) position</span>
        <span class="s1">xys = M.transform(offset_layout) - (offsetx</span><span class="s2">, </span><span class="s1">offsety)</span>

        <span class="s2">return </span><span class="s1">bbox</span><span class="s2">, </span><span class="s1">list(zip(lines</span><span class="s2">, </span><span class="s1">zip(ws</span><span class="s2">, </span><span class="s1">hs)</span><span class="s2">, </span><span class="s1">*xys.T))</span><span class="s2">, </span><span class="s1">descent</span>

    <span class="s2">def </span><span class="s1">set_bbox(self</span><span class="s2">, </span><span class="s1">rectprops):</span>
        <span class="s0">&quot;&quot;&quot; 
        Draw a bounding box around self. 
 
        Parameters 
        ---------- 
        rectprops : dict with properties for `.patches.FancyBboxPatch` 
             The default boxstyle is 'square'. The mutation 
             scale of the `.patches.FancyBboxPatch` is set to the fontsize. 
 
        Examples 
        -------- 
        :: 
 
            t.set_bbox(dict(facecolor='red', alpha=0.5)) 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">rectprops </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">props = rectprops.copy()</span>
            <span class="s1">boxstyle = props.pop(</span><span class="s4">&quot;boxstyle&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">pad = props.pop(</span><span class="s4">&quot;pad&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">boxstyle </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">boxstyle = </span><span class="s4">&quot;square&quot;</span>
                <span class="s2">if </span><span class="s1">pad </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">pad = </span><span class="s5">4  </span><span class="s3"># points</span>
                <span class="s1">pad /= self.get_size()  </span><span class="s3"># to fraction of font size</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">pad </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">pad = </span><span class="s5">0.3</span>
            <span class="s3"># boxstyle could be a callable or a string</span>
            <span class="s2">if </span><span class="s1">isinstance(boxstyle</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s4">&quot;pad&quot; </span><span class="s2">not in </span><span class="s1">boxstyle:</span>
                <span class="s1">boxstyle += </span><span class="s4">&quot;,pad=%0.2f&quot; </span><span class="s1">% pad</span>
            <span class="s1">self._bbox_patch = FancyBboxPatch(</span>
                <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">,</span>
                <span class="s1">boxstyle=boxstyle</span><span class="s2">, </span><span class="s1">transform=IdentityTransform()</span><span class="s2">, </span><span class="s1">**props)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._bbox_patch = </span><span class="s2">None</span>

        <span class="s1">self._update_clip_properties()</span>

    <span class="s2">def </span><span class="s1">get_bbox_patch(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the bbox Patch, or None if the `.patches.FancyBboxPatch` 
        is not made. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._bbox_patch</span>

    <span class="s2">def </span><span class="s1">update_bbox_position_size(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the location and the size of the bbox. 
 
        This method should be used when the position and size of the bbox needs 
        to be updated before actually drawing the bbox. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._bbox_patch:</span>
            <span class="s3"># don't use self.get_unitless_position here, which refers to text</span>
            <span class="s3"># position in Text:</span>
            <span class="s1">posx = float(self.convert_xunits(self._x))</span>
            <span class="s1">posy = float(self.convert_yunits(self._y))</span>
            <span class="s1">posx</span><span class="s2">, </span><span class="s1">posy = self.get_transform().transform((posx</span><span class="s2">, </span><span class="s1">posy))</span>

            <span class="s1">x_box</span><span class="s2">, </span><span class="s1">y_box</span><span class="s2">, </span><span class="s1">w_box</span><span class="s2">, </span><span class="s1">h_box = _get_textbox(self</span><span class="s2">, </span><span class="s1">renderer)</span>
            <span class="s1">self._bbox_patch.set_bounds(</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s1">w_box</span><span class="s2">, </span><span class="s1">h_box)</span>
            <span class="s1">self._bbox_patch.set_transform(</span>
                <span class="s1">Affine2D()</span>
                <span class="s1">.rotate_deg(self.get_rotation())</span>
                <span class="s1">.translate(posx + x_box</span><span class="s2">, </span><span class="s1">posy + y_box))</span>
            <span class="s1">fontsize_in_pixel = renderer.points_to_pixels(self.get_size())</span>
            <span class="s1">self._bbox_patch.set_mutation_scale(fontsize_in_pixel)</span>

    <span class="s2">def </span><span class="s1">_update_clip_properties(self):</span>
        <span class="s1">clipprops = dict(clip_box=self.clipbox</span><span class="s2">,</span>
                         <span class="s1">clip_path=self._clippath</span><span class="s2">,</span>
                         <span class="s1">clip_on=self._clipon)</span>
        <span class="s2">if </span><span class="s1">self._bbox_patch:</span>
            <span class="s1">self._bbox_patch.update(clipprops)</span>

    <span class="s2">def </span><span class="s1">set_clip_box(self</span><span class="s2">, </span><span class="s1">clipbox):</span>
        <span class="s3"># docstring inherited.</span>
        <span class="s1">super().set_clip_box(clipbox)</span>
        <span class="s1">self._update_clip_properties()</span>

    <span class="s2">def </span><span class="s1">set_clip_path(self</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">transform=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited.</span>
        <span class="s1">super().set_clip_path(path</span><span class="s2">, </span><span class="s1">transform)</span>
        <span class="s1">self._update_clip_properties()</span>

    <span class="s2">def </span><span class="s1">set_clip_on(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s3"># docstring inherited.</span>
        <span class="s1">super().set_clip_on(b)</span>
        <span class="s1">self._update_clip_properties()</span>

    <span class="s2">def </span><span class="s1">get_wrap(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the text can be wrapped.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._wrap</span>

    <span class="s2">def </span><span class="s1">set_wrap(self</span><span class="s2">, </span><span class="s1">wrap):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the text can be wrapped. 
 
        Parameters 
        ---------- 
        wrap : bool 
 
        Notes 
        ----- 
        Wrapping does not work together with 
        ``savefig(..., bbox_inches='tight')`` (which is also used internally 
        by ``%matplotlib inline`` in IPython/Jupyter). The 'tight' setting 
        rescales the canvas to accommodate all content and happens before 
        wrapping. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._wrap = wrap</span>

    <span class="s2">def </span><span class="s1">_get_wrap_line_width(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the maximum line width for wrapping text based on the current 
        orientation. 
        &quot;&quot;&quot;</span>
        <span class="s1">x0</span><span class="s2">, </span><span class="s1">y0 = self.get_transform().transform(self.get_position())</span>
        <span class="s1">figure_box = self.get_figure().get_window_extent()</span>

        <span class="s3"># Calculate available width based on text alignment</span>
        <span class="s1">alignment = self.get_horizontalalignment()</span>
        <span class="s1">self.set_rotation_mode(</span><span class="s4">'anchor'</span><span class="s1">)</span>
        <span class="s1">rotation = self.get_rotation()</span>

        <span class="s1">left = self._get_dist_to_box(rotation</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">figure_box)</span>
        <span class="s1">right = self._get_dist_to_box(</span>
            <span class="s1">(</span><span class="s5">180 </span><span class="s1">+ rotation) % </span><span class="s5">360</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">figure_box)</span>

        <span class="s2">if </span><span class="s1">alignment == </span><span class="s4">'left'</span><span class="s1">:</span>
            <span class="s1">line_width = left</span>
        <span class="s2">elif </span><span class="s1">alignment == </span><span class="s4">'right'</span><span class="s1">:</span>
            <span class="s1">line_width = right</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">line_width = </span><span class="s5">2 </span><span class="s1">* min(left</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s2">return </span><span class="s1">line_width</span>

    <span class="s2">def </span><span class="s1">_get_dist_to_box(self</span><span class="s2">, </span><span class="s1">rotation</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">figure_box):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the distance from the given points to the boundaries of a 
        rotated box, in pixels. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">rotation &gt; </span><span class="s5">270</span><span class="s1">:</span>
            <span class="s1">quad = rotation - </span><span class="s5">270</span>
            <span class="s1">h1 = y0 / math.cos(math.radians(quad))</span>
            <span class="s1">h2 = (figure_box.x1 - x0) / math.cos(math.radians(</span><span class="s5">90 </span><span class="s1">- quad))</span>
        <span class="s2">elif </span><span class="s1">rotation &gt; </span><span class="s5">180</span><span class="s1">:</span>
            <span class="s1">quad = rotation - </span><span class="s5">180</span>
            <span class="s1">h1 = x0 / math.cos(math.radians(quad))</span>
            <span class="s1">h2 = y0 / math.cos(math.radians(</span><span class="s5">90 </span><span class="s1">- quad))</span>
        <span class="s2">elif </span><span class="s1">rotation &gt; </span><span class="s5">90</span><span class="s1">:</span>
            <span class="s1">quad = rotation - </span><span class="s5">90</span>
            <span class="s1">h1 = (figure_box.y1 - y0) / math.cos(math.radians(quad))</span>
            <span class="s1">h2 = x0 / math.cos(math.radians(</span><span class="s5">90 </span><span class="s1">- quad))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">h1 = (figure_box.x1 - x0) / math.cos(math.radians(rotation))</span>
            <span class="s1">h2 = (figure_box.y1 - y0) / math.cos(math.radians(</span><span class="s5">90 </span><span class="s1">- rotation))</span>

        <span class="s2">return </span><span class="s1">min(h1</span><span class="s2">, </span><span class="s1">h2)</span>

    <span class="s2">def </span><span class="s1">_get_rendered_text_width(self</span><span class="s2">, </span><span class="s1">text):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the width of a given text string, in pixels. 
        &quot;&quot;&quot;</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">d = self._renderer.get_text_width_height_descent(</span>
            <span class="s1">text</span><span class="s2">,</span>
            <span class="s1">self.get_fontproperties()</span><span class="s2">,</span>
            <span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">math.ceil(w)</span>

    <span class="s2">def </span><span class="s1">_get_wrapped_text(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the text string with new lines added so that the text 
        is wrapped relative to the parent figure (if `get_wrap` is True). 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.get_wrap():</span>
            <span class="s2">return </span><span class="s1">self.get_text()</span>

        <span class="s3"># Not fit to handle breaking up latex syntax correctly, so</span>
        <span class="s3"># ignore latex for now.</span>
        <span class="s2">if </span><span class="s1">self.get_usetex():</span>
            <span class="s2">return </span><span class="s1">self.get_text()</span>

        <span class="s3"># Build the line incrementally, for a more accurate measure of length</span>
        <span class="s1">line_width = self._get_wrap_line_width()</span>
        <span class="s1">wrapped_lines = []</span>

        <span class="s3"># New lines in the user's text force a split</span>
        <span class="s1">unwrapped_lines = self.get_text().split(</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>

        <span class="s3"># Now wrap each individual unwrapped line</span>
        <span class="s2">for </span><span class="s1">unwrapped_line </span><span class="s2">in </span><span class="s1">unwrapped_lines:</span>

            <span class="s1">sub_words = unwrapped_line.split(</span><span class="s4">' '</span><span class="s1">)</span>
            <span class="s3"># Remove items from sub_words as we go, so stop when empty</span>
            <span class="s2">while </span><span class="s1">len(sub_words) &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(sub_words) == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s3"># Only one word, so just add it to the end</span>
                    <span class="s1">wrapped_lines.append(sub_words.pop(</span><span class="s5">0</span><span class="s1">))</span>
                    <span class="s2">continue</span>

                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">len(sub_words) + </span><span class="s5">1</span><span class="s1">):</span>
                    <span class="s3"># Get width of all words up to and including here</span>
                    <span class="s1">line = </span><span class="s4">' '</span><span class="s1">.join(sub_words[:i])</span>
                    <span class="s1">current_width = self._get_rendered_text_width(line)</span>

                    <span class="s3"># If all these words are too wide, append all not including</span>
                    <span class="s3"># last word</span>
                    <span class="s2">if </span><span class="s1">current_width &gt; line_width:</span>
                        <span class="s1">wrapped_lines.append(</span><span class="s4">' '</span><span class="s1">.join(sub_words[:i - </span><span class="s5">1</span><span class="s1">]))</span>
                        <span class="s1">sub_words = sub_words[i - </span><span class="s5">1</span><span class="s1">:]</span>
                        <span class="s2">break</span>

                    <span class="s3"># Otherwise if all words fit in the width, append them all</span>
                    <span class="s2">elif </span><span class="s1">i == len(sub_words):</span>
                        <span class="s1">wrapped_lines.append(</span><span class="s4">' '</span><span class="s1">.join(sub_words[:i]))</span>
                        <span class="s1">sub_words = []</span>
                        <span class="s2">break</span>

        <span class="s2">return </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">.join(wrapped_lines)</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>

        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self.get_text() == </span><span class="s4">''</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">renderer.open_group(</span><span class="s4">'text'</span><span class="s2">, </span><span class="s1">self.get_gid())</span>

        <span class="s2">with </span><span class="s1">self._cm_set(text=self._get_wrapped_text()):</span>
            <span class="s1">bbox</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">descent = self._get_layout(renderer)</span>
            <span class="s1">trans = self.get_transform()</span>

            <span class="s3"># don't use self.get_position here, which refers to text</span>
            <span class="s3"># position in Text:</span>
            <span class="s1">posx = float(self.convert_xunits(self._x))</span>
            <span class="s1">posy = float(self.convert_yunits(self._y))</span>
            <span class="s1">posx</span><span class="s2">, </span><span class="s1">posy = trans.transform((posx</span><span class="s2">, </span><span class="s1">posy))</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(posx) </span><span class="s2">or not </span><span class="s1">np.isfinite(posy):</span>
                <span class="s1">_log.warning(</span><span class="s4">&quot;posx and posy should be finite values&quot;</span><span class="s1">)</span>
                <span class="s2">return</span>
            <span class="s1">canvasw</span><span class="s2">, </span><span class="s1">canvash = renderer.get_canvas_width_height()</span>

            <span class="s3"># Update the location and size of the bbox</span>
            <span class="s3"># (`.patches.FancyBboxPatch`), and draw it.</span>
            <span class="s2">if </span><span class="s1">self._bbox_patch:</span>
                <span class="s1">self.update_bbox_position_size(renderer)</span>
                <span class="s1">self._bbox_patch.draw(renderer)</span>

            <span class="s1">gc = renderer.new_gc()</span>
            <span class="s1">gc.set_foreground(self.get_color())</span>
            <span class="s1">gc.set_alpha(self.get_alpha())</span>
            <span class="s1">gc.set_url(self._url)</span>
            <span class="s1">self._set_gc_clip(gc)</span>

            <span class="s1">angle = self.get_rotation()</span>

            <span class="s2">for </span><span class="s1">line</span><span class="s2">, </span><span class="s1">wh</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">info:</span>

                <span class="s1">mtext = self </span><span class="s2">if </span><span class="s1">len(info) == </span><span class="s5">1 </span><span class="s2">else None</span>
                <span class="s1">x = x + posx</span>
                <span class="s1">y = y + posy</span>
                <span class="s2">if </span><span class="s1">renderer.flipy():</span>
                    <span class="s1">y = canvash - y</span>
                <span class="s1">clean_line</span><span class="s2">, </span><span class="s1">ismath = self._preprocess_math(line)</span>

                <span class="s2">if </span><span class="s1">self.get_path_effects():</span>
                    <span class="s2">from </span><span class="s1">matplotlib.patheffects </span><span class="s2">import </span><span class="s1">PathEffectRenderer</span>
                    <span class="s1">textrenderer = PathEffectRenderer(</span>
                        <span class="s1">self.get_path_effects()</span><span class="s2">, </span><span class="s1">renderer)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">textrenderer = renderer</span>

                <span class="s2">if </span><span class="s1">self.get_usetex():</span>
                    <span class="s1">textrenderer.draw_tex(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">clean_line</span><span class="s2">,</span>
                                          <span class="s1">self._fontproperties</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">,</span>
                                          <span class="s1">mtext=mtext)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">textrenderer.draw_text(gc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">clean_line</span><span class="s2">,</span>
                                           <span class="s1">self._fontproperties</span><span class="s2">, </span><span class="s1">angle</span><span class="s2">,</span>
                                           <span class="s1">ismath=ismath</span><span class="s2">, </span><span class="s1">mtext=mtext)</span>

        <span class="s1">gc.restore()</span>
        <span class="s1">renderer.close_group(</span><span class="s4">'text'</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">get_color(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the color of the text.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._color</span>

    <span class="s2">def </span><span class="s1">get_fontproperties(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the `.font_manager.FontProperties`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties</span>

    <span class="s2">def </span><span class="s1">get_fontfamily(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the list of font families used for font lookup. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_family 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_family()</span>

    <span class="s2">def </span><span class="s1">get_fontname(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font name as a string. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_name 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_name()</span>

    <span class="s2">def </span><span class="s1">get_fontstyle(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font style as a string. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_style 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_style()</span>

    <span class="s2">def </span><span class="s1">get_fontsize(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font size as an integer. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_size_in_points 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_size_in_points()</span>

    <span class="s2">def </span><span class="s1">get_fontvariant(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font variant as a string. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_variant 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_variant()</span>

    <span class="s2">def </span><span class="s1">get_fontweight(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font weight as a string or a number. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_weight 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_weight()</span>

    <span class="s2">def </span><span class="s1">get_stretch(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font stretch as a string or a number. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.get_stretch 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_stretch()</span>

    <span class="s2">def </span><span class="s1">get_horizontalalignment(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the horizontal alignment as a string.  Will be one of 
        'left', 'center' or 'right'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._horizontalalignment</span>

    <span class="s2">def </span><span class="s1">get_unitless_position(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the (x, y) unitless position of the text.&quot;&quot;&quot;</span>
        <span class="s3"># This will get the position with all unit information stripped away.</span>
        <span class="s3"># This is here for convenience since it is done in several locations.</span>
        <span class="s1">x = float(self.convert_xunits(self._x))</span>
        <span class="s1">y = float(self.convert_yunits(self._y))</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">get_position(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the (x, y) position of the text.&quot;&quot;&quot;</span>
        <span class="s3"># This should return the same data (possible unitized) as was</span>
        <span class="s3"># specified with 'set_x' and 'set_y'.</span>
        <span class="s2">return </span><span class="s1">self._x</span><span class="s2">, </span><span class="s1">self._y</span>

    <span class="s2">def </span><span class="s1">get_text(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the text string.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._text</span>

    <span class="s2">def </span><span class="s1">get_verticalalignment(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the vertical alignment as a string.  Will be one of 
        'top', 'center', 'bottom', 'baseline' or 'center_baseline'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._verticalalignment</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">dpi=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the `.Bbox` bounding the text, in display units. 
 
        In addition to being used internally, this is useful for specifying 
        clickable regions in a png file on a web page. 
 
        Parameters 
        ---------- 
        renderer : Renderer, optional 
            A renderer is needed to compute the bounding box.  If the artist 
            has already been drawn, the renderer is cached; thus, it is only 
            necessary to pass this argument when calling `get_window_extent` 
            before the first draw.  In practice, it is usually easier to 
            trigger a draw first, e.g. by calling 
            `~.Figure.draw_without_rendering` or ``plt.show()``. 
 
        dpi : float, optional 
            The dpi value for computing the bbox, defaults to 
            ``self.figure.dpi`` (*not* the renderer dpi); should be set e.g. if 
            to match regions with a figure saved with a custom dpi value. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return </span><span class="s1">Bbox.unit()</span>
        <span class="s2">if </span><span class="s1">dpi </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dpi = self.figure.dpi</span>
        <span class="s2">if </span><span class="s1">self.get_text() == </span><span class="s4">''</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">cbook._setattr_cm(self.figure</span><span class="s2">, </span><span class="s1">dpi=dpi):</span>
                <span class="s1">tx</span><span class="s2">, </span><span class="s1">ty = self._get_xy_display()</span>
                <span class="s2">return </span><span class="s1">Bbox.from_bounds(tx</span><span class="s2">, </span><span class="s1">ty</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if </span><span class="s1">self._renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._renderer = self.figure._get_renderer()</span>
        <span class="s2">if </span><span class="s1">self._renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s4">&quot;Cannot get window extent of text w/o renderer. You likely &quot;</span>
                <span class="s4">&quot;want to call 'figure.draw_without_rendering()' first.&quot;</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">cbook._setattr_cm(self.figure</span><span class="s2">, </span><span class="s1">dpi=dpi):</span>
            <span class="s1">bbox</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">descent = self._get_layout(self._renderer)</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.get_unitless_position()</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.get_transform().transform((x</span><span class="s2">, </span><span class="s1">y))</span>
            <span class="s1">bbox = bbox.translated(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s2">return </span><span class="s1">bbox</span>

    <span class="s2">def </span><span class="s1">set_backgroundcolor(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the background color of the text by updating the bbox. 
 
        Parameters 
        ---------- 
        color : color 
 
        See Also 
        -------- 
        .set_bbox : To change the position of the bounding box 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._bbox_patch </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.set_bbox(dict(facecolor=color</span><span class="s2">, </span><span class="s1">edgecolor=color))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._bbox_patch.update(dict(facecolor=color))</span>

        <span class="s1">self._update_clip_properties()</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_color(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the foreground color of the text 
 
        Parameters 
        ---------- 
        color : color 
        &quot;&quot;&quot;</span>
        <span class="s3"># &quot;auto&quot; is only supported by axisartist, but we can just let it error</span>
        <span class="s3"># out at draw time for simplicity.</span>
        <span class="s2">if not </span><span class="s1">cbook._str_equal(color</span><span class="s2">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">):</span>
            <span class="s1">mpl.colors._check_color_like(color=color)</span>
        <span class="s1">self._color = color</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_horizontalalignment(self</span><span class="s2">, </span><span class="s1">align):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the horizontal alignment relative to the anchor point. 
 
        See also :doc:`/gallery/text_labels_and_annotations/text_alignment`. 
 
        Parameters 
        ---------- 
        align : {'left', 'center', 'right'} 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'right'</span><span class="s2">, </span><span class="s4">'left'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">align=align)</span>
        <span class="s1">self._horizontalalignment = align</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_multialignment(self</span><span class="s2">, </span><span class="s1">align):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the text alignment for multiline texts. 
 
        The layout of the bounding box of all the lines is determined by the 
        horizontalalignment and verticalalignment properties. This property 
        controls the alignment of the text lines within that box. 
 
        Parameters 
        ---------- 
        align : {'left', 'right', 'center'} 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'right'</span><span class="s2">, </span><span class="s4">'left'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">align=align)</span>
        <span class="s1">self._multialignment = align</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_linespacing(self</span><span class="s2">, </span><span class="s1">spacing):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the line spacing as a multiple of the font size. 
 
        The default line spacing is 1.2. 
 
        Parameters 
        ---------- 
        spacing : float (multiple of font size) 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_isinstance(Real</span><span class="s2">, </span><span class="s1">spacing=spacing)</span>
        <span class="s1">self._linespacing = spacing</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fontfamily(self</span><span class="s2">, </span><span class="s1">fontname):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font family.  Can be either a single string, or a list of 
        strings in decreasing priority.  Each string may be either a real font 
        name or a generic font class name.  If the latter, the specific font 
        names will be looked up in the corresponding rcParams. 
 
        If a `Text` instance is constructed with ``fontfamily=None``, then the 
        font is set to :rc:`font.family`, and the 
        same is done when `set_fontfamily()` is called on an existing 
        `Text` instance. 
 
        Parameters 
        ---------- 
        fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \ 
'monospace'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_family 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_family(fontname)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fontvariant(self</span><span class="s2">, </span><span class="s1">variant):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font variant. 
 
        Parameters 
        ---------- 
        variant : {'normal', 'small-caps'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_variant 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_variant(variant)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fontstyle(self</span><span class="s2">, </span><span class="s1">fontstyle):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font style. 
 
        Parameters 
        ---------- 
        fontstyle : {'normal', 'italic', 'oblique'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_style 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_style(fontstyle)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fontsize(self</span><span class="s2">, </span><span class="s1">fontsize):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font size. 
 
        Parameters 
        ---------- 
        fontsize : float or {'xx-small', 'x-small', 'small', 'medium', \ 
'large', 'x-large', 'xx-large'} 
            If a float, the fontsize in points. The string values denote sizes 
            relative to the default font size. 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_size 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_size(fontsize)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_math_fontfamily(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the font family name for math text rendered by Matplotlib. 
 
        The default value is :rc:`mathtext.fontset`. 
 
        See Also 
        -------- 
        set_math_fontfamily 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fontproperties.get_math_fontfamily()</span>

    <span class="s2">def </span><span class="s1">set_math_fontfamily(self</span><span class="s2">, </span><span class="s1">fontfamily):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font family for math text rendered by Matplotlib. 
 
        This does only affect Matplotlib's own math renderer. It has no effect 
        when rendering with TeX (``usetex=True``). 
 
        Parameters 
        ---------- 
        fontfamily : str 
            The name of the font family. 
 
            Available font families are defined in the 
            :ref:`matplotlibrc.template file 
            &lt;customizing-with-matplotlibrc-files&gt;`. 
 
        See Also 
        -------- 
        get_math_fontfamily 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_math_fontfamily(fontfamily)</span>

    <span class="s2">def </span><span class="s1">set_fontweight(self</span><span class="s2">, </span><span class="s1">weight):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font weight. 
 
        Parameters 
        ---------- 
        weight : {a numeric value in range 0-1000, 'ultralight', 'light', \ 
'normal', 'regular', 'book', 'medium', 'roman', 'semibold', 'demibold', \ 
'demi', 'bold', 'heavy', 'extra bold', 'black'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_weight 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_weight(weight)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_fontstretch(self</span><span class="s2">, </span><span class="s1">stretch):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font stretch (horizontal condensation or expansion). 
 
        Parameters 
        ---------- 
        stretch : {a numeric value in range 0-1000, 'ultra-condensed', \ 
'extra-condensed', 'condensed', 'semi-condensed', 'normal', 'semi-expanded', \ 
'expanded', 'extra-expanded', 'ultra-expanded'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_stretch 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties.set_stretch(stretch)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_position(self</span><span class="s2">, </span><span class="s1">xy):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the (*x*, *y*) position of the text. 
 
        Parameters 
        ---------- 
        xy : (float, float) 
        &quot;&quot;&quot;</span>
        <span class="s1">self.set_x(xy[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">self.set_y(xy[</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">set_x(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the *x* position of the text. 
 
        Parameters 
        ---------- 
        x : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._x = x</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_y(self</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the *y* position of the text. 
 
        Parameters 
        ---------- 
        y : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._y = y</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_rotation(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the rotation of the text. 
 
        Parameters 
        ---------- 
        s : float or {'vertical', 'horizontal'} 
            The rotation angle in degrees in mathematically positive direction 
            (counterclockwise). 'horizontal' equals 0, 'vertical' equals 90. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">Real):</span>
            <span class="s1">self._rotation = float(s) % </span><span class="s5">360</span>
        <span class="s2">elif </span><span class="s1">cbook._str_equal(s</span><span class="s2">, </span><span class="s4">'horizontal'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">s </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._rotation = </span><span class="s5">0.</span>
        <span class="s2">elif </span><span class="s1">cbook._str_equal(s</span><span class="s2">, </span><span class="s4">'vertical'</span><span class="s1">):</span>
            <span class="s1">self._rotation = </span><span class="s5">90.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;rotation must be 'vertical', 'horizontal' or &quot;</span>
                             <span class="s4">f&quot;a number, not </span><span class="s2">{</span><span class="s1">s</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_transform_rotates_text(self</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether rotations of the transform affect the text direction. 
 
        Parameters 
        ---------- 
        t : bool 
        &quot;&quot;&quot;</span>
        <span class="s1">self._transform_rotates_text = t</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_verticalalignment(self</span><span class="s2">, </span><span class="s1">align):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the vertical alignment relative to the anchor point. 
 
        See also :doc:`/gallery/text_labels_and_annotations/text_alignment`. 
 
        Parameters 
        ---------- 
        align : {'bottom', 'baseline', 'center', 'center_baseline', 'top'} 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list(</span>
            <span class="s1">[</span><span class="s4">'top'</span><span class="s2">, </span><span class="s4">'bottom'</span><span class="s2">, </span><span class="s4">'center'</span><span class="s2">, </span><span class="s4">'baseline'</span><span class="s2">, </span><span class="s4">'center_baseline'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">align=align)</span>
        <span class="s1">self._verticalalignment = align</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_text(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Set the text string *s*. 
 
        It may contain newlines (``\n``) or math in LaTeX syntax. 
 
        Parameters 
        ---------- 
        s : object 
            Any object gets converted to its `str` representation, except for 
            ``None`` which is converted to an empty string. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">s </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">s = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">s != self._text:</span>
            <span class="s1">self._text = str(s)</span>
            <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">_preprocess_math(self</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the string *s* after mathtext preprocessing, and the kind of 
        mathtext support needed. 
 
        - If *self* is configured to use TeX, return *s* unchanged except that 
          a single space gets escaped, and the flag &quot;TeX&quot;. 
        - Otherwise, if *s* is mathtext (has an even number of unescaped dollar 
          signs) and ``parse_math`` is not set to False, return *s* and the 
          flag True. 
        - Otherwise, return *s* with dollar signs unescaped, and the flag 
          False. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.get_usetex():</span>
            <span class="s2">if </span><span class="s1">s == </span><span class="s4">&quot; &quot;</span><span class="s1">:</span>
                <span class="s1">s = </span><span class="s4">r&quot;\ &quot;</span>
            <span class="s2">return </span><span class="s1">s</span><span class="s2">, </span><span class="s4">&quot;TeX&quot;</span>
        <span class="s2">elif not </span><span class="s1">self.get_parse_math():</span>
            <span class="s2">return </span><span class="s1">s</span><span class="s2">, False</span>
        <span class="s2">elif </span><span class="s1">cbook.is_math_text(s):</span>
            <span class="s2">return </span><span class="s1">s</span><span class="s2">, True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">s.replace(</span><span class="s4">r&quot;\$&quot;</span><span class="s2">, </span><span class="s4">&quot;$&quot;</span><span class="s1">)</span><span class="s2">, False</span>

    <span class="s2">def </span><span class="s1">set_fontproperties(self</span><span class="s2">, </span><span class="s1">fp):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the font properties that control the text. 
 
        Parameters 
        ---------- 
        fp : `.font_manager.FontProperties` or `str` or `pathlib.Path` 
            If a `str`, it is interpreted as a fontconfig pattern parsed by 
            `.FontProperties`.  If a `pathlib.Path`, it is interpreted as the 
            absolute path to a font file. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fontproperties = FontProperties._from_any(fp).copy()</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_usetex(self</span><span class="s2">, </span><span class="s1">usetex):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        usetex : bool or None 
            Whether to render using TeX, ``None`` means to use 
            :rc:`text.usetex`. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">usetex </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._usetex = mpl.rcParams[</span><span class="s4">'text.usetex'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._usetex = bool(usetex)</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_usetex(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether this `Text` object uses TeX for rendering.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._usetex</span>

    <span class="s2">def </span><span class="s1">set_parse_math(self</span><span class="s2">, </span><span class="s1">parse_math):</span>
        <span class="s0">&quot;&quot;&quot; 
        Override switch to disable any mathtext parsing for this `Text`. 
 
        Parameters 
        ---------- 
        parse_math : bool 
            If False, this `Text` will never use mathtext.  If True, mathtext 
            will be used if there is an even number of unescaped dollar signs. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._parse_math = bool(parse_math)</span>

    <span class="s2">def </span><span class="s1">get_parse_math(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether mathtext parsing is considered for this `Text`.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._parse_math</span>

    <span class="s2">def </span><span class="s1">set_fontname(self</span><span class="s2">, </span><span class="s1">fontname):</span>
        <span class="s0">&quot;&quot;&quot; 
        Alias for `set_family`. 
 
        One-way alias only: the getter differs. 
 
        Parameters 
        ---------- 
        fontname : {FONTNAME, 'serif', 'sans-serif', 'cursive', 'fantasy', \ 
'monospace'} 
 
        See Also 
        -------- 
        .font_manager.FontProperties.set_family 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.set_family(fontname)</span>


<span class="s2">class </span><span class="s1">OffsetFrom:</span>
    <span class="s0">&quot;&quot;&quot;Callable helper class for working with `Annotation`.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">ref_coord</span><span class="s2">, </span><span class="s1">unit=</span><span class="s4">&quot;points&quot;</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        artist : `.Artist` or `.BboxBase` or `.Transform` 
            The object to compute the offset from. 
 
        ref_coord : (float, float) 
            If *artist* is an `.Artist` or `.BboxBase`, this values is 
            the location to of the offset origin in fractions of the 
            *artist* bounding box. 
 
            If *artist* is a transform, the offset origin is the 
            transform applied to this value. 
 
        unit : {'points, 'pixels'}, default: 'points' 
            The screen units to use (pixels or points) for the offset input. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._artist = artist</span>
        <span class="s1">self._ref_coord = ref_coord</span>
        <span class="s1">self.set_unit(unit)</span>

    <span class="s2">def </span><span class="s1">set_unit(self</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the unit for input to the transform used by ``__call__``. 
 
        Parameters 
        ---------- 
        unit : {'points', 'pixels'} 
        &quot;&quot;&quot;</span>
        <span class="s1">_api.check_in_list([</span><span class="s4">&quot;points&quot;</span><span class="s2">, </span><span class="s4">&quot;pixels&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s1">self._unit = unit</span>

    <span class="s2">def </span><span class="s1">get_unit(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the unit for input to the transform used by ``__call__``.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._unit</span>

    <span class="s2">def </span><span class="s1">_get_scale(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">unit = self.get_unit()</span>
        <span class="s2">if </span><span class="s1">unit == </span><span class="s4">&quot;pixels&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">renderer.points_to_pixels(</span><span class="s5">1.</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the offset transform. 
 
        Parameters 
        ---------- 
        renderer : `RendererBase` 
            The renderer to use to compute the offset 
 
        Returns 
        ------- 
        `Transform` 
            Maps (x, y) in pixel or point units to screen units 
            relative to the given artist. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self._artist</span><span class="s2">, </span><span class="s1">Artist):</span>
            <span class="s1">bbox = self._artist.get_window_extent(renderer)</span>
            <span class="s1">xf</span><span class="s2">, </span><span class="s1">yf = self._ref_coord</span>
            <span class="s1">x = bbox.x0 + bbox.width * xf</span>
            <span class="s1">y = bbox.y0 + bbox.height * yf</span>
        <span class="s2">elif </span><span class="s1">isinstance(self._artist</span><span class="s2">, </span><span class="s1">BboxBase):</span>
            <span class="s1">bbox = self._artist</span>
            <span class="s1">xf</span><span class="s2">, </span><span class="s1">yf = self._ref_coord</span>
            <span class="s1">x = bbox.x0 + bbox.width * xf</span>
            <span class="s1">y = bbox.y0 + bbox.height * yf</span>
        <span class="s2">elif </span><span class="s1">isinstance(self._artist</span><span class="s2">, </span><span class="s1">Transform):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self._artist.transform(self._ref_coord)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;unknown type&quot;</span><span class="s1">)</span>

        <span class="s1">sc = self._get_scale(renderer)</span>
        <span class="s1">tr = Affine2D().scale(sc).translate(x</span><span class="s2">, </span><span class="s1">y)</span>

        <span class="s2">return </span><span class="s1">tr</span>


<span class="s2">class </span><span class="s1">_AnnotationBase:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">,</span>
                 <span class="s1">xy</span><span class="s2">,</span>
                 <span class="s1">xycoords=</span><span class="s4">'data'</span><span class="s2">,</span>
                 <span class="s1">annotation_clip=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">self.xy = xy</span>
        <span class="s1">self.xycoords = xycoords</span>
        <span class="s1">self.set_annotation_clip(annotation_clip)</span>

        <span class="s1">self._draggable = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_get_xy(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">s):</span>
        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">s1</span><span class="s2">, </span><span class="s1">s2 = s</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">s1</span><span class="s2">, </span><span class="s1">s2 = s</span><span class="s2">, </span><span class="s1">s</span>
        <span class="s2">if </span><span class="s1">s1 == </span><span class="s4">'data'</span><span class="s1">:</span>
            <span class="s1">x = float(self.convert_xunits(x))</span>
        <span class="s2">if </span><span class="s1">s2 == </span><span class="s4">'data'</span><span class="s1">:</span>
            <span class="s1">y = float(self.convert_yunits(y))</span>
        <span class="s2">return </span><span class="s1">self._get_xy_transform(renderer</span><span class="s2">, </span><span class="s1">s).transform((x</span><span class="s2">, </span><span class="s1">y))</span>

    <span class="s2">def </span><span class="s1">_get_xy_transform(self</span><span class="s2">, </span><span class="s1">renderer</span><span class="s2">, </span><span class="s1">s):</span>

        <span class="s2">if </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">s1</span><span class="s2">, </span><span class="s1">s2 = s</span>
            <span class="s2">from </span><span class="s1">matplotlib.transforms </span><span class="s2">import </span><span class="s1">blended_transform_factory</span>
            <span class="s1">tr1 = self._get_xy_transform(renderer</span><span class="s2">, </span><span class="s1">s1)</span>
            <span class="s1">tr2 = self._get_xy_transform(renderer</span><span class="s2">, </span><span class="s1">s2)</span>
            <span class="s1">tr = blended_transform_factory(tr1</span><span class="s2">, </span><span class="s1">tr2)</span>
            <span class="s2">return </span><span class="s1">tr</span>
        <span class="s2">elif </span><span class="s1">callable(s):</span>
            <span class="s1">tr = s(renderer)</span>
            <span class="s2">if </span><span class="s1">isinstance(tr</span><span class="s2">, </span><span class="s1">BboxBase):</span>
                <span class="s2">return </span><span class="s1">BboxTransformTo(tr)</span>
            <span class="s2">elif </span><span class="s1">isinstance(tr</span><span class="s2">, </span><span class="s1">Transform):</span>
                <span class="s2">return </span><span class="s1">tr</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;Unknown return type&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">Artist):</span>
            <span class="s1">bbox = s.get_window_extent(renderer)</span>
            <span class="s2">return </span><span class="s1">BboxTransformTo(bbox)</span>
        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">BboxBase):</span>
            <span class="s2">return </span><span class="s1">BboxTransformTo(s)</span>
        <span class="s2">elif </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">Transform):</span>
            <span class="s2">return </span><span class="s1">s</span>
        <span class="s2">elif not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">f&quot;Unknown coordinate type: </span><span class="s2">{</span><span class="s1">s</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">s == </span><span class="s4">'data'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.axes.transData</span>
        <span class="s2">elif </span><span class="s1">s == </span><span class="s4">'polar'</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">matplotlib.projections </span><span class="s2">import </span><span class="s1">PolarAxes</span>
            <span class="s1">tr = PolarAxes.PolarTransform()</span>
            <span class="s1">trans = tr + self.axes.transData</span>
            <span class="s2">return </span><span class="s1">trans</span>

        <span class="s1">s_ = s.split()</span>
        <span class="s2">if </span><span class="s1">len(s_) != </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">s</span><span class="s2">!r} </span><span class="s4">is not a recognized coordinate&quot;</span><span class="s1">)</span>

        <span class="s1">bbox0</span><span class="s2">, </span><span class="s1">xy0 = </span><span class="s2">None, None</span>

        <span class="s1">bbox_name</span><span class="s2">, </span><span class="s1">unit = s_</span>
        <span class="s3"># if unit is offset-like</span>
        <span class="s2">if </span><span class="s1">bbox_name == </span><span class="s4">&quot;figure&quot;</span><span class="s1">:</span>
            <span class="s1">bbox0 = self.figure.figbbox</span>
        <span class="s2">elif </span><span class="s1">bbox_name == </span><span class="s4">&quot;subfigure&quot;</span><span class="s1">:</span>
            <span class="s1">bbox0 = self.figure.bbox</span>
        <span class="s2">elif </span><span class="s1">bbox_name == </span><span class="s4">&quot;axes&quot;</span><span class="s1">:</span>
            <span class="s1">bbox0 = self.axes.bbox</span>
        <span class="s3"># elif bbox_name == &quot;bbox&quot;:</span>
        <span class="s3">#     if bbox is None:</span>
        <span class="s3">#         raise RuntimeError(&quot;bbox is specified as a coordinate but &quot;</span>
        <span class="s3">#                            &quot;never set&quot;)</span>
        <span class="s3">#     bbox0 = self._get_bbox(renderer, bbox)</span>

        <span class="s2">if </span><span class="s1">bbox0 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">xy0 = bbox0.p0</span>
        <span class="s2">elif </span><span class="s1">bbox_name == </span><span class="s4">&quot;offset&quot;</span><span class="s1">:</span>
            <span class="s1">xy0 = self._get_ref_xy(renderer)</span>

        <span class="s2">if </span><span class="s1">xy0 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># reference x, y in display coordinate</span>
            <span class="s1">ref_x</span><span class="s2">, </span><span class="s1">ref_y = xy0</span>
            <span class="s2">if </span><span class="s1">unit == </span><span class="s4">&quot;points&quot;</span><span class="s1">:</span>
                <span class="s3"># dots per points</span>
                <span class="s1">dpp = self.figure.dpi / </span><span class="s5">72</span>
                <span class="s1">tr = Affine2D().scale(dpp)</span>
            <span class="s2">elif </span><span class="s1">unit == </span><span class="s4">&quot;pixels&quot;</span><span class="s1">:</span>
                <span class="s1">tr = Affine2D()</span>
            <span class="s2">elif </span><span class="s1">unit == </span><span class="s4">&quot;fontsize&quot;</span><span class="s1">:</span>
                <span class="s1">fontsize = self.get_size()</span>
                <span class="s1">dpp = fontsize * self.figure.dpi / </span><span class="s5">72</span>
                <span class="s1">tr = Affine2D().scale(dpp)</span>
            <span class="s2">elif </span><span class="s1">unit == </span><span class="s4">&quot;fraction&quot;</span><span class="s1">:</span>
                <span class="s1">w</span><span class="s2">, </span><span class="s1">h = bbox0.size</span>
                <span class="s1">tr = Affine2D().scale(w</span><span class="s2">, </span><span class="s1">h)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">!r} </span><span class="s4">is not a recognized unit&quot;</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">tr.translate(ref_x</span><span class="s2">, </span><span class="s1">ref_y)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">s</span><span class="s2">!r} </span><span class="s4">is not a recognized coordinate&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_ref_xy(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return x, y (in display coordinates) that is to be used for a reference 
        of any offset coordinate. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_xy(renderer</span><span class="s2">, </span><span class="s1">*self.xy</span><span class="s2">, </span><span class="s1">self.xycoords)</span>

    <span class="s3"># def _get_bbox(self, renderer):</span>
    <span class="s3">#     if hasattr(bbox, &quot;bounds&quot;):</span>
    <span class="s3">#         return bbox</span>
    <span class="s3">#     elif hasattr(bbox, &quot;get_window_extent&quot;):</span>
    <span class="s3">#         bbox = bbox.get_window_extent()</span>
    <span class="s3">#         return bbox</span>
    <span class="s3">#     else:</span>
    <span class="s3">#         raise ValueError(&quot;A bbox instance is expected but got %s&quot; %</span>
    <span class="s3">#                          str(bbox))</span>

    <span class="s2">def </span><span class="s1">set_annotation_clip(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the annotation's clipping behavior. 
 
        Parameters 
        ---------- 
        b : bool or None 
            - True: The annotation will be clipped when ``self.xy`` is 
              outside the axes. 
            - False: The annotation will always be drawn. 
            - None: The annotation will be clipped when ``self.xy`` is 
              outside the axes and ``self.xycoords == &quot;data&quot;``. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._annotation_clip = b</span>

    <span class="s2">def </span><span class="s1">get_annotation_clip(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the annotation's clipping behavior. 
 
        See `set_annotation_clip` for the meaning of return values. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._annotation_clip</span>

    <span class="s2">def </span><span class="s1">_get_position_xy(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot;Return the pixel position of the annotated point.&quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = self.xy</span>
        <span class="s2">return </span><span class="s1">self._get_xy(renderer</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">self.xycoords)</span>

    <span class="s2">def </span><span class="s1">_check_xy(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Check whether the annotation at *xy_pixel* should be drawn.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">renderer = self.figure._get_renderer()</span>
        <span class="s1">b = self.get_annotation_clip()</span>
        <span class="s2">if </span><span class="s1">b </span><span class="s2">or </span><span class="s1">(b </span><span class="s2">is None and </span><span class="s1">self.xycoords == </span><span class="s4">&quot;data&quot;</span><span class="s1">):</span>
            <span class="s3"># check if self.xy is inside the axes.</span>
            <span class="s1">xy_pixel = self._get_position_xy(renderer)</span>
            <span class="s2">return </span><span class="s1">self.axes.contains_point(xy_pixel)</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">draggable(self</span><span class="s2">, </span><span class="s1">state=</span><span class="s2">None, </span><span class="s1">use_blit=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set whether the annotation is draggable with the mouse. 
 
        Parameters 
        ---------- 
        state : bool or None 
            - True or False: set the draggability. 
            - None: toggle the draggability. 
 
        Returns 
        ------- 
        DraggableAnnotation or None 
            If the annotation is draggable, the corresponding 
            `.DraggableAnnotation` helper is returned. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">matplotlib.offsetbox </span><span class="s2">import </span><span class="s1">DraggableAnnotation</span>
        <span class="s1">is_draggable = self._draggable </span><span class="s2">is not None</span>

        <span class="s3"># if state is None we'll toggle</span>
        <span class="s2">if </span><span class="s1">state </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">state = </span><span class="s2">not </span><span class="s1">is_draggable</span>

        <span class="s2">if </span><span class="s1">state:</span>
            <span class="s2">if </span><span class="s1">self._draggable </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">self._draggable = DraggableAnnotation(self</span><span class="s2">, </span><span class="s1">use_blit)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._draggable </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._draggable.disconnect()</span>
            <span class="s1">self._draggable = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">self._draggable</span>


<span class="s2">class </span><span class="s1">Annotation(Text</span><span class="s2">, </span><span class="s1">_AnnotationBase):</span>
    <span class="s0">&quot;&quot;&quot; 
    An `.Annotation` is a `.Text` that can refer to a specific position *xy*. 
    Optionally an arrow pointing from the text to *xy* can be drawn. 
 
    Attributes 
    ---------- 
    xy 
        The annotated position. 
    xycoords 
        The coordinate system for *xy*. 
    arrow_patch 
        A `.FancyArrowPatch` to point from *xytext* to *xy*. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;Annotation(%g, %g, %r)&quot; </span><span class="s1">% (self.xy[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.xy[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._text)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">xy</span><span class="s2">,</span>
                 <span class="s1">xytext=</span><span class="s2">None,</span>
                 <span class="s1">xycoords=</span><span class="s4">'data'</span><span class="s2">,</span>
                 <span class="s1">textcoords=</span><span class="s2">None,</span>
                 <span class="s1">arrowprops=</span><span class="s2">None,</span>
                 <span class="s1">annotation_clip=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Annotate the point *xy* with text *text*. 
 
        In the simplest form, the text is placed at *xy*. 
 
        Optionally, the text can be displayed in another position *xytext*. 
        An arrow pointing from the text to the annotated point *xy* can then 
        be added by defining *arrowprops*. 
 
        Parameters 
        ---------- 
        text : str 
            The text of the annotation. 
 
        xy : (float, float) 
            The point *(x, y)* to annotate. The coordinate system is determined 
            by *xycoords*. 
 
        xytext : (float, float), default: *xy* 
            The position *(x, y)* to place the text at. The coordinate system 
            is determined by *textcoords*. 
 
        xycoords : single or two-tuple of str or `.Artist` or `.Transform` or \ 
callable, default: 'data' 
 
            The coordinate system that *xy* is given in. The following types 
            of values are supported: 
 
            - One of the following strings: 
 
              ==================== ============================================ 
              Value                Description 
              ==================== ============================================ 
              'figure points'      Points from the lower left of the figure 
              'figure pixels'      Pixels from the lower left of the figure 
              'figure fraction'    Fraction of figure from lower left 
              'subfigure points'   Points from the lower left of the subfigure 
              'subfigure pixels'   Pixels from the lower left of the subfigure 
              'subfigure fraction' Fraction of subfigure from lower left 
              'axes points'        Points from lower left corner of axes 
              'axes pixels'        Pixels from lower left corner of axes 
              'axes fraction'      Fraction of axes from lower left 
              'data'               Use the coordinate system of the object 
                                   being annotated (default) 
              'polar'              *(theta, r)* if not native 'data' 
                                   coordinates 
              ==================== ============================================ 
 
              Note that 'subfigure pixels' and 'figure pixels' are the same 
              for the parent figure, so users who want code that is usable in 
              a subfigure can use 'subfigure pixels'. 
 
            - An `.Artist`: *xy* is interpreted as a fraction of the artist's 
              `~matplotlib.transforms.Bbox`. E.g. *(0, 0)* would be the lower 
              left corner of the bounding box and *(0.5, 1)* would be the 
              center top of the bounding box. 
 
            - A `.Transform` to transform *xy* to screen coordinates. 
 
            - A function with one of the following signatures:: 
 
                def transform(renderer) -&gt; Bbox 
                def transform(renderer) -&gt; Transform 
 
              where *renderer* is a `.RendererBase` subclass. 
 
              The result of the function is interpreted like the `.Artist` and 
              `.Transform` cases above. 
 
            - A tuple *(xcoords, ycoords)* specifying separate coordinate 
              systems for *x* and *y*. *xcoords* and *ycoords* must each be 
              of one of the above described types. 
 
            See :ref:`plotting-guide-annotation` for more details. 
 
        textcoords : single or two-tuple of str or `.Artist` or `.Transform` \ 
or callable, default: value of *xycoords* 
            The coordinate system that *xytext* is given in. 
 
            All *xycoords* values are valid as well as the following 
            strings: 
 
            =================   ========================================= 
            Value               Description 
            =================   ========================================= 
            'offset points'     Offset (in points) from the *xy* value 
            'offset pixels'     Offset (in pixels) from the *xy* value 
            =================   ========================================= 
 
        arrowprops : dict, optional 
            The properties used to draw a `.FancyArrowPatch` arrow between the 
            positions *xy* and *xytext*.  Defaults to None, i.e. no arrow is 
            drawn. 
 
            For historical reasons there are two different ways to specify 
            arrows, &quot;simple&quot; and &quot;fancy&quot;: 
 
            **Simple arrow:** 
 
            If *arrowprops* does not contain the key 'arrowstyle' the 
            allowed keys are: 
 
            ==========   ====================================================== 
            Key          Description 
            ==========   ====================================================== 
            width        The width of the arrow in points 
            headwidth    The width of the base of the arrow head in points 
            headlength   The length of the arrow head in points 
            shrink       Fraction of total length to shrink from both ends 
            ?            Any key to :class:`matplotlib.patches.FancyArrowPatch` 
            ==========   ====================================================== 
 
            The arrow is attached to the edge of the text box, the exact 
            position (corners or centers) depending on where it's pointing to. 
 
            **Fancy arrow:** 
 
            This is used if 'arrowstyle' is provided in the *arrowprops*. 
 
            Valid keys are the following `~matplotlib.patches.FancyArrowPatch` 
            parameters: 
 
            ===============  ================================================== 
            Key              Description 
            ===============  ================================================== 
            arrowstyle       the arrow style 
            connectionstyle  the connection style 
            relpos           see below; default is (0.5, 0.5) 
            patchA           default is bounding box of the text 
            patchB           default is None 
            shrinkA          default is 2 points 
            shrinkB          default is 2 points 
            mutation_scale   default is text size (in points) 
            mutation_aspect  default is 1. 
            ?                any key for :class:`matplotlib.patches.PathPatch` 
            ===============  ================================================== 
 
            The exact starting point position of the arrow is defined by 
            *relpos*. It's a tuple of relative coordinates of the text box, 
            where (0, 0) is the lower left corner and (1, 1) is the upper 
            right corner. Values &lt;0 and &gt;1 are supported and specify points 
            outside the text box. By default (0.5, 0.5), so the starting point 
            is centered in the text box. 
 
        annotation_clip : bool or None, default: None 
            Whether to clip (i.e. not draw) the annotation when the annotation 
            point *xy* is outside the axes area. 
 
            - If *True*, the annotation will be clipped when *xy* is outside 
              the axes. 
            - If *False*, the annotation will always be drawn. 
            - If *None*, the annotation will be clipped when *xy* is outside 
              the axes and *xycoords* is 'data'. 
 
        **kwargs 
            Additional kwargs are passed to `~matplotlib.text.Text`. 
 
        Returns 
        ------- 
        `.Annotation` 
 
        See Also 
        -------- 
        :ref:`plotting-guide-annotation` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_AnnotationBase.__init__(self</span><span class="s2">,</span>
                                 <span class="s1">xy</span><span class="s2">,</span>
                                 <span class="s1">xycoords=xycoords</span><span class="s2">,</span>
                                 <span class="s1">annotation_clip=annotation_clip)</span>
        <span class="s3"># warn about wonky input data</span>
        <span class="s2">if </span><span class="s1">(xytext </span><span class="s2">is None and</span>
                <span class="s1">textcoords </span><span class="s2">is not None and</span>
                <span class="s1">textcoords != xycoords):</span>
            <span class="s1">_api.warn_external(</span><span class="s4">&quot;You have used the `textcoords` kwarg, but &quot;</span>
                               <span class="s4">&quot;not the `xytext` kwarg.  This can lead to &quot;</span>
                               <span class="s4">&quot;surprising results.&quot;</span><span class="s1">)</span>

        <span class="s3"># clean up textcoords and assign default</span>
        <span class="s2">if </span><span class="s1">textcoords </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">textcoords = self.xycoords</span>
        <span class="s1">self._textcoords = textcoords</span>

        <span class="s3"># cleanup xytext defaults</span>
        <span class="s2">if </span><span class="s1">xytext </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">xytext = self.xy</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y = xytext</span>

        <span class="s1">self.arrowprops = arrowprops</span>
        <span class="s2">if </span><span class="s1">arrowprops </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">arrowprops = arrowprops.copy()</span>
            <span class="s2">if </span><span class="s4">&quot;arrowstyle&quot; </span><span class="s2">in </span><span class="s1">arrowprops:</span>
                <span class="s1">self._arrow_relpos = arrowprops.pop(</span><span class="s4">&quot;relpos&quot;</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># modified YAArrow API to be used with FancyArrowPatch</span>
                <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">[</span>
                        <span class="s4">'width'</span><span class="s2">, </span><span class="s4">'headwidth'</span><span class="s2">, </span><span class="s4">'headlength'</span><span class="s2">, </span><span class="s4">'shrink'</span><span class="s2">, </span><span class="s4">'frac'</span><span class="s1">]:</span>
                    <span class="s1">arrowprops.pop(key</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">self.arrow_patch = FancyArrowPatch((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">**arrowprops)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.arrow_patch = </span><span class="s2">None</span>

        <span class="s3"># Must come last, as some kwargs may be propagated to arrow_patch.</span>
        <span class="s1">Text.__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">text</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">event):</span>
        <span class="s1">inside</span><span class="s2">, </span><span class="s1">info = self._default_contains(event)</span>
        <span class="s2">if </span><span class="s1">inside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inside</span><span class="s2">, </span><span class="s1">info</span>
        <span class="s1">contains</span><span class="s2">, </span><span class="s1">tinfo = Text.contains(self</span><span class="s2">, </span><span class="s1">event)</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">in_patch</span><span class="s2">, </span><span class="s1">_ = self.arrow_patch.contains(event)</span>
            <span class="s1">contains = contains </span><span class="s2">or </span><span class="s1">in_patch</span>
        <span class="s2">return </span><span class="s1">contains</span><span class="s2">, </span><span class="s1">tinfo</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">xycoords(self):</span>
        <span class="s2">return </span><span class="s1">self._xycoords</span>

    <span class="s1">@xycoords.setter</span>
    <span class="s2">def </span><span class="s1">xycoords(self</span><span class="s2">, </span><span class="s1">xycoords):</span>
        <span class="s2">def </span><span class="s1">is_offset(s):</span>
            <span class="s2">return </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">s.startswith(</span><span class="s4">&quot;offset&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(isinstance(xycoords</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">and </span><span class="s1">any(map(is_offset</span><span class="s2">, </span><span class="s1">xycoords))</span>
                <span class="s2">or </span><span class="s1">is_offset(xycoords)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;xycoords cannot be an offset coordinate&quot;</span><span class="s1">)</span>
        <span class="s1">self._xycoords = xycoords</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">xyann(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The text position. 
 
        See also *xytext* in `.Annotation`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_position()</span>

    <span class="s1">@xyann.setter</span>
    <span class="s2">def </span><span class="s1">xyann(self</span><span class="s2">, </span><span class="s1">xytext):</span>
        <span class="s1">self.set_position(xytext)</span>

    <span class="s2">def </span><span class="s1">get_anncoords(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the coordinate system to use for `.Annotation.xyann`. 
 
        See also *xycoords* in `.Annotation`. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._textcoords</span>

    <span class="s2">def </span><span class="s1">set_anncoords(self</span><span class="s2">, </span><span class="s1">coords):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the coordinate system to use for `.Annotation.xyann`. 
 
        See also *xycoords* in `.Annotation`. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._textcoords = coords</span>

    <span class="s1">anncoords = property(get_anncoords</span><span class="s2">, </span><span class="s1">set_anncoords</span><span class="s2">, </span><span class="s1">doc=</span><span class="s4">&quot;&quot;&quot; 
        The coordinate system to use for `.Annotation.xyann`.&quot;&quot;&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">set_figure(self</span><span class="s2">, </span><span class="s1">fig):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.arrow_patch.set_figure(fig)</span>
        <span class="s1">Artist.set_figure(self</span><span class="s2">, </span><span class="s1">fig)</span>

    <span class="s2">def </span><span class="s1">update_positions(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the pixel positions of the annotation text and the arrow patch. 
        &quot;&quot;&quot;</span>
        <span class="s3"># generate transformation</span>
        <span class="s1">self.set_transform(self._get_xy_transform(renderer</span><span class="s2">, </span><span class="s1">self.anncoords))</span>

        <span class="s1">arrowprops = self.arrowprops</span>
        <span class="s2">if </span><span class="s1">arrowprops </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">bbox = Text.get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer)</span>

        <span class="s1">arrow_end = x1</span><span class="s2">, </span><span class="s1">y1 = self._get_position_xy(renderer)  </span><span class="s3"># Annotated pos.</span>

        <span class="s1">ms = arrowprops.get(</span><span class="s4">&quot;mutation_scale&quot;</span><span class="s2">, </span><span class="s1">self.get_size())</span>
        <span class="s1">self.arrow_patch.set_mutation_scale(ms)</span>

        <span class="s2">if </span><span class="s4">&quot;arrowstyle&quot; </span><span class="s2">not in </span><span class="s1">arrowprops:</span>
            <span class="s3"># Approximately simulate the YAArrow.</span>
            <span class="s1">shrink = arrowprops.get(</span><span class="s4">'shrink'</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">)</span>
            <span class="s1">width = arrowprops.get(</span><span class="s4">'width'</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">headwidth = arrowprops.get(</span><span class="s4">'headwidth'</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s4">'frac' </span><span class="s2">in </span><span class="s1">arrowprops:</span>
                <span class="s1">_api.warn_external(</span>
                    <span class="s4">&quot;'frac' option in 'arrowprops' is no longer supported;&quot;</span>
                    <span class="s4">&quot; use 'headlength' to set the head length in points.&quot;</span><span class="s1">)</span>
            <span class="s1">headlength = arrowprops.get(</span><span class="s4">'headlength'</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)</span>

            <span class="s3"># NB: ms is in pts</span>
            <span class="s1">stylekw = dict(head_length=headlength / ms</span><span class="s2">,</span>
                           <span class="s1">head_width=headwidth / ms</span><span class="s2">,</span>
                           <span class="s1">tail_width=width / ms)</span>

            <span class="s1">self.arrow_patch.set_arrowstyle(</span><span class="s4">'simple'</span><span class="s2">, </span><span class="s1">**stylekw)</span>

            <span class="s3"># using YAArrow style:</span>
            <span class="s3"># pick the corner of the text bbox closest to annotated point.</span>
            <span class="s1">xpos = [(bbox.x0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">((bbox.x0 + bbox.x1) / </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(bbox.x1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s1">ypos = [(bbox.y0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">((bbox.y0 + bbox.y1) / </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(bbox.y1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">relposx = min(xpos</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">v: abs(v[</span><span class="s5">0</span><span class="s1">] - x1))</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">relposy = min(ypos</span><span class="s2">, </span><span class="s1">key=</span><span class="s2">lambda </span><span class="s1">v: abs(v[</span><span class="s5">0</span><span class="s1">] - y1))</span>
            <span class="s1">self._arrow_relpos = (relposx</span><span class="s2">, </span><span class="s1">relposy)</span>
            <span class="s1">r = np.hypot(y - y1</span><span class="s2">, </span><span class="s1">x - x1)</span>
            <span class="s1">shrink_pts = shrink * r / renderer.points_to_pixels(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">self.arrow_patch.shrinkA = self.arrow_patch.shrinkB = shrink_pts</span>

        <span class="s3"># adjust the starting point of the arrow relative to the textbox.</span>
        <span class="s3"># TODO : Rotation needs to be accounted.</span>
        <span class="s1">arrow_begin = bbox.p0 + bbox.size * self._arrow_relpos</span>
        <span class="s3"># The arrow is drawn from arrow_begin to arrow_end.  It will be first</span>
        <span class="s3"># clipped by patchA and patchB.  Then it will be shrunk by shrinkA and</span>
        <span class="s3"># shrinkB (in points).  If patchA is not set, self.bbox_patch is used.</span>
        <span class="s1">self.arrow_patch.set_positions(arrow_begin</span><span class="s2">, </span><span class="s1">arrow_end)</span>

        <span class="s2">if </span><span class="s4">&quot;patchA&quot; </span><span class="s2">in </span><span class="s1">arrowprops:</span>
            <span class="s1">patchA = arrowprops[</span><span class="s4">&quot;patchA&quot;</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">self._bbox_patch:</span>
            <span class="s1">patchA = self._bbox_patch</span>
        <span class="s2">elif </span><span class="s1">self.get_text() == </span><span class="s4">&quot;&quot;</span><span class="s1">:</span>
            <span class="s1">patchA = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pad = renderer.points_to_pixels(</span><span class="s5">4</span><span class="s1">)</span>
            <span class="s1">patchA = Rectangle(</span>
                <span class="s1">xy=(bbox.x0 - pad / </span><span class="s5">2</span><span class="s2">, </span><span class="s1">bbox.y0 - pad / </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">width=bbox.width + pad</span><span class="s2">, </span><span class="s1">height=bbox.height + pad</span><span class="s2">,</span>
                <span class="s1">transform=IdentityTransform()</span><span class="s2">, </span><span class="s1">clip_on=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.arrow_patch.set_patchA(patchA)</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if not </span><span class="s1">self.get_visible() </span><span class="s2">or not </span><span class="s1">self._check_xy(renderer):</span>
            <span class="s2">return</span>
        <span class="s3"># Update text positions before `Text.draw` would, so that the</span>
        <span class="s3"># FancyArrowPatch is correctly positioned.</span>
        <span class="s1">self.update_positions(renderer)</span>
        <span class="s1">self.update_bbox_position_size(renderer)</span>
        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:  </span><span class="s3"># FancyArrowPatch</span>
            <span class="s2">if </span><span class="s1">self.arrow_patch.figure </span><span class="s2">is None and </span><span class="s1">self.figure </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.arrow_patch.figure = self.figure</span>
            <span class="s1">self.arrow_patch.draw(renderer)</span>
        <span class="s3"># Draw text, including FancyBboxPatch, after FancyArrowPatch.</span>
        <span class="s3"># Otherwise, a wedge arrowstyle can land partly on top of the Bbox.</span>
        <span class="s1">Text.draw(self</span><span class="s2">, </span><span class="s1">renderer)</span>

    <span class="s2">def </span><span class="s1">get_window_extent(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s3"># This block is the same as in Text.get_window_extent, but we need to</span>
        <span class="s3"># set the renderer before calling update_positions().</span>
        <span class="s2">if not </span><span class="s1">self.get_visible() </span><span class="s2">or not </span><span class="s1">self._check_xy(renderer):</span>
            <span class="s2">return </span><span class="s1">Bbox.unit()</span>
        <span class="s2">if </span><span class="s1">renderer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._renderer = renderer</span>
        <span class="s2">if </span><span class="s1">self._renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._renderer = self.figure._get_renderer()</span>
        <span class="s2">if </span><span class="s1">self._renderer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">'Cannot get window extent w/o renderer'</span><span class="s1">)</span>

        <span class="s1">self.update_positions(self._renderer)</span>

        <span class="s1">text_bbox = Text.get_window_extent(self)</span>
        <span class="s1">bboxes = [text_bbox]</span>

        <span class="s2">if </span><span class="s1">self.arrow_patch </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">bboxes.append(self.arrow_patch.get_window_extent())</span>

        <span class="s2">return </span><span class="s1">Bbox.union(bboxes)</span>

    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s3"># docstring inherited</span>
        <span class="s2">if not </span><span class="s1">self._check_xy(renderer):</span>
            <span class="s2">return </span><span class="s1">Bbox.null()</span>
        <span class="s2">return </span><span class="s1">super().get_tightbbox(renderer)</span>


<span class="s1">_docstring.interpd.update(Annotation=Annotation.__init__.__doc__)</span>
</pre>
</body>
</html>