<html>
<head>
<title>axis3d.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
axis3d.py</font>
</center></td></tr></table>
<pre><span class="s0"># axis3d.py, original mplot3d version by John Porter</span>
<span class="s0"># Created: 23 Sep 2005</span>
<span class="s0"># Parts rewritten by Reinier Heeres &lt;reinier@heeres.eu&gt;</span>

<span class="s2">import </span><span class="s1">inspect</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_api</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">lines </span><span class="s2">as </span><span class="s1">mlines</span><span class="s2">, </span><span class="s1">axis </span><span class="s2">as </span><span class="s1">maxis</span><span class="s2">, </span><span class="s1">patches </span><span class="s2">as </span><span class="s1">mpatches</span><span class="s2">,</span>
    <span class="s1">transforms </span><span class="s2">as </span><span class="s1">mtransforms</span><span class="s2">, </span><span class="s1">colors </span><span class="s2">as </span><span class="s1">mcolors)</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">art3d</span><span class="s2">, </span><span class="s1">proj3d</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _move_from_center&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">move_from_center(coord</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">axmask=(</span><span class="s2">True, True, True</span><span class="s1">)):</span>
    <span class="s4">&quot;&quot;&quot; 
    For each coordinate where *axmask* is True, move *coord* away from 
    *centers* by *deltas*. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_move_from_center(coord</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">axmask=axmask)</span>


<span class="s2">def </span><span class="s1">_move_from_center(coord</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">axmask=(</span><span class="s2">True, True, True</span><span class="s1">)):</span>
    <span class="s4">&quot;&quot;&quot; 
    For each coordinate where *axmask* is True, move *coord* away from 
    *centers* by *deltas*. 
    &quot;&quot;&quot;</span>
    <span class="s1">coord = np.asarray(coord)</span>
    <span class="s2">return </span><span class="s1">coord + axmask * np.copysign(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">coord - centers) * deltas</span>


<span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;a vendored copy of _tick_update_position&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">tick_update_position(tick</span><span class="s2">, </span><span class="s1">tickxs</span><span class="s2">, </span><span class="s1">tickys</span><span class="s2">, </span><span class="s1">labelpos):</span>
    <span class="s4">&quot;&quot;&quot;Update tick line and label position and style.&quot;&quot;&quot;</span>
    <span class="s1">_tick_update_position(tick</span><span class="s2">, </span><span class="s1">tickxs</span><span class="s2">, </span><span class="s1">tickys</span><span class="s2">, </span><span class="s1">labelpos)</span>


<span class="s2">def </span><span class="s1">_tick_update_position(tick</span><span class="s2">, </span><span class="s1">tickxs</span><span class="s2">, </span><span class="s1">tickys</span><span class="s2">, </span><span class="s1">labelpos):</span>
    <span class="s4">&quot;&quot;&quot;Update tick line and label position and style.&quot;&quot;&quot;</span>

    <span class="s1">tick.label1.set_position(labelpos)</span>
    <span class="s1">tick.label2.set_position(labelpos)</span>
    <span class="s1">tick.tick1line.set_visible(</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">tick.tick2line.set_visible(</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">tick.tick1line.set_linestyle(</span><span class="s3">'-'</span><span class="s1">)</span>
    <span class="s1">tick.tick1line.set_marker(</span><span class="s3">''</span><span class="s1">)</span>
    <span class="s1">tick.tick1line.set_data(tickxs</span><span class="s2">, </span><span class="s1">tickys)</span>
    <span class="s1">tick.gridline.set_data([</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">Axis(maxis.XAxis):</span>
    <span class="s4">&quot;&quot;&quot;An Axis class for the 3D plots.&quot;&quot;&quot;</span>
    <span class="s0"># These points from the unit cube make up the x, y and z-planes</span>
    <span class="s1">_PLANES = (</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># yz planes</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># xz planes</span>
        <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s1">)</span><span class="s2">,  </span><span class="s0"># xy planes</span>
    <span class="s1">)</span>

    <span class="s0"># Some properties for the axes</span>
    <span class="s1">_AXINFO = {</span>
        <span class="s3">'x'</span><span class="s1">: {</span><span class="s3">'i'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">'tickdir'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'juggled'</span><span class="s1">: (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)}</span><span class="s2">,</span>
        <span class="s3">'y'</span><span class="s1">: {</span><span class="s3">'i'</span><span class="s1">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'tickdir'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">'juggled'</span><span class="s1">: (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)}</span><span class="s2">,</span>
        <span class="s3">'z'</span><span class="s1">: {</span><span class="s3">'i'</span><span class="s1">: </span><span class="s5">2</span><span class="s2">, </span><span class="s3">'tickdir'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">'juggled'</span><span class="s1">: (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)}</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">_old_init(self</span><span class="s2">, </span><span class="s1">adir</span><span class="s2">, </span><span class="s1">v_intervalx</span><span class="s2">, </span><span class="s1">d_intervalx</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                  <span class="s1">rotate_label=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">locals()</span>

    <span class="s2">def </span><span class="s1">_new_init(self</span><span class="s2">, </span><span class="s1">axes</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">rotate_label=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">locals()</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">params = _api.select_matching_signature(</span>
            <span class="s1">[self._old_init</span><span class="s2">, </span><span class="s1">self._new_init]</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">if </span><span class="s3">&quot;adir&quot; </span><span class="s2">in </span><span class="s1">params:</span>
            <span class="s1">_api.warn_deprecated(</span>
                <span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">message=</span><span class="s3">f&quot;The signature of 3D Axis constructors has &quot;</span>
                <span class="s3">f&quot;changed in %(since)s; the new signature is &quot;</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">inspect.signature(type(self).__init__)</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">params[</span><span class="s3">&quot;adir&quot;</span><span class="s1">] != self.axis_name:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Cannot instantiate </span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s3">&quot;</span>
                                 <span class="s3">f&quot;with adir=</span><span class="s2">{</span><span class="s1">params[</span><span class="s3">'adir'</span><span class="s1">]</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">axes = params[</span><span class="s3">&quot;axes&quot;</span><span class="s1">]</span>
        <span class="s1">rotate_label = params[</span><span class="s3">&quot;rotate_label&quot;</span><span class="s1">]</span>
        <span class="s1">args = params.get(</span><span class="s3">&quot;args&quot;</span><span class="s2">, </span><span class="s1">())</span>
        <span class="s1">kwargs = params[</span><span class="s3">&quot;kwargs&quot;</span><span class="s1">]</span>

        <span class="s1">name = self.axis_name</span>

        <span class="s0"># This is a temporary member variable.</span>
        <span class="s0"># Do not depend on this existing in future releases!</span>
        <span class="s1">self._axinfo = self._AXINFO[name].copy()</span>
        <span class="s0"># Common parts</span>
        <span class="s1">self._axinfo.update({</span>
            <span class="s3">'label'</span><span class="s1">: {</span><span class="s3">'va'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s2">, </span><span class="s3">'ha'</span><span class="s1">: </span><span class="s3">'center'</span><span class="s2">,</span>
                      <span class="s3">'rotation_mode'</span><span class="s1">: </span><span class="s3">'anchor'</span><span class="s1">}</span><span class="s2">,</span>
            <span class="s3">'color'</span><span class="s1">: mpl.rcParams[</span><span class="s3">f'axes3d.</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">axis.panecolor'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s3">'tick'</span><span class="s1">: {</span>
                <span class="s3">'inward_factor'</span><span class="s1">: </span><span class="s5">0.2</span><span class="s2">,</span>
                <span class="s3">'outward_factor'</span><span class="s1">: </span><span class="s5">0.1</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">})</span>

        <span class="s2">if </span><span class="s1">mpl.rcParams[</span><span class="s3">'_internal.classic_mode'</span><span class="s1">]:</span>
            <span class="s1">self._axinfo.update({</span>
                <span class="s3">'axisline'</span><span class="s1">: {</span><span class="s3">'linewidth'</span><span class="s1">: </span><span class="s5">0.75</span><span class="s2">, </span><span class="s3">'color'</span><span class="s1">: (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)}</span><span class="s2">,</span>
                <span class="s3">'grid'</span><span class="s1">: {</span>
                    <span class="s3">'color'</span><span class="s1">: (</span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s3">'linewidth'</span><span class="s1">: </span><span class="s5">1.0</span><span class="s2">,</span>
                    <span class="s3">'linestyle'</span><span class="s1">: </span><span class="s3">'-'</span><span class="s2">,</span>
                <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">})</span>
            <span class="s1">self._axinfo[</span><span class="s3">'tick'</span><span class="s1">].update({</span>
                <span class="s3">'linewidth'</span><span class="s1">: {</span>
                    <span class="s2">True</span><span class="s1">: mpl.rcParams[</span><span class="s3">'lines.linewidth'</span><span class="s1">]</span><span class="s2">,  </span><span class="s0"># major</span>
                    <span class="s2">False</span><span class="s1">: mpl.rcParams[</span><span class="s3">'lines.linewidth'</span><span class="s1">]</span><span class="s2">,  </span><span class="s0"># minor</span>
                <span class="s1">}</span>
            <span class="s1">})</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._axinfo.update({</span>
                <span class="s3">'axisline'</span><span class="s1">: {</span>
                    <span class="s3">'linewidth'</span><span class="s1">: mpl.rcParams[</span><span class="s3">'axes.linewidth'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'color'</span><span class="s1">: mpl.rcParams[</span><span class="s3">'axes.edgecolor'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">}</span><span class="s2">,</span>
                <span class="s3">'grid'</span><span class="s1">: {</span>
                    <span class="s3">'color'</span><span class="s1">: mpl.rcParams[</span><span class="s3">'grid.color'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'linewidth'</span><span class="s1">: mpl.rcParams[</span><span class="s3">'grid.linewidth'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s3">'linestyle'</span><span class="s1">: mpl.rcParams[</span><span class="s3">'grid.linestyle'</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">})</span>
            <span class="s1">self._axinfo[</span><span class="s3">'tick'</span><span class="s1">].update({</span>
                <span class="s3">'linewidth'</span><span class="s1">: {</span>
                    <span class="s2">True</span><span class="s1">: (  </span><span class="s0"># major</span>
                        <span class="s1">mpl.rcParams[</span><span class="s3">'xtick.major.width'</span><span class="s1">] </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">'xz'</span>
                        <span class="s2">else </span><span class="s1">mpl.rcParams[</span><span class="s3">'ytick.major.width'</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s2">False</span><span class="s1">: (  </span><span class="s0"># minor</span>
                        <span class="s1">mpl.rcParams[</span><span class="s3">'xtick.minor.width'</span><span class="s1">] </span><span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s3">'xz'</span>
                        <span class="s2">else </span><span class="s1">mpl.rcParams[</span><span class="s3">'ytick.minor.width'</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">}</span>
            <span class="s1">})</span>

        <span class="s1">super().__init__(axes</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s0"># data and viewing intervals for this direction</span>
        <span class="s2">if </span><span class="s3">&quot;d_intervalx&quot; </span><span class="s2">in </span><span class="s1">params:</span>
            <span class="s1">self.set_data_interval(*params[</span><span class="s3">&quot;d_intervalx&quot;</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s3">&quot;v_intervalx&quot; </span><span class="s2">in </span><span class="s1">params:</span>
            <span class="s1">self.set_view_interval(*params[</span><span class="s3">&quot;v_intervalx&quot;</span><span class="s1">])</span>
        <span class="s1">self.set_rotate_label(rotate_label)</span>
        <span class="s1">self._init3d()  </span><span class="s0"># Inline after init3d deprecation elapses.</span>

    <span class="s1">__init__.__signature__ = inspect.signature(_new_init)</span>
    <span class="s1">adir = _api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">True</span><span class="s1">)(</span>
        <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.axis_name))</span>

    <span class="s2">def </span><span class="s1">_init3d(self):</span>
        <span class="s1">self.line = mlines.Line2D(</span>
            <span class="s1">xdata=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ydata=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">linewidth=self._axinfo[</span><span class="s3">'axisline'</span><span class="s1">][</span><span class="s3">'linewidth'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">color=self._axinfo[</span><span class="s3">'axisline'</span><span class="s1">][</span><span class="s3">'color'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">antialiased=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s0"># Store dummy data in Polygon object</span>
        <span class="s1">self.pane = mpatches.Polygon([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">closed=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self.set_pane_color(self._axinfo[</span><span class="s3">'color'</span><span class="s1">])</span>

        <span class="s1">self.axes._set_artist_props(self.line)</span>
        <span class="s1">self.axes._set_artist_props(self.pane)</span>
        <span class="s1">self.gridlines = art3d.Line3DCollection([])</span>
        <span class="s1">self.axes._set_artist_props(self.gridlines)</span>
        <span class="s1">self.axes._set_artist_props(self.label)</span>
        <span class="s1">self.axes._set_artist_props(self.offsetText)</span>
        <span class="s0"># Need to be able to place the label at the correct location</span>
        <span class="s1">self.label._transform = self.axes.transData</span>
        <span class="s1">self.offsetText._transform = self.axes.transData</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">init3d(self):  </span><span class="s0"># After deprecation elapses, inline _init3d to __init__.</span>
        <span class="s1">self._init3d()</span>

    <span class="s2">def </span><span class="s1">get_major_ticks(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ticks = super().get_major_ticks(numticks)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">[</span>
                    <span class="s1">t.tick1line</span><span class="s2">, </span><span class="s1">t.tick2line</span><span class="s2">, </span><span class="s1">t.gridline</span><span class="s2">, </span><span class="s1">t.label1</span><span class="s2">, </span><span class="s1">t.label2]:</span>
                <span class="s1">obj.set_transform(self.axes.transData)</span>
        <span class="s2">return </span><span class="s1">ticks</span>

    <span class="s2">def </span><span class="s1">get_minor_ticks(self</span><span class="s2">, </span><span class="s1">numticks=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">ticks = super().get_minor_ticks(numticks)</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">[</span>
                    <span class="s1">t.tick1line</span><span class="s2">, </span><span class="s1">t.tick2line</span><span class="s2">, </span><span class="s1">t.gridline</span><span class="s2">, </span><span class="s1">t.label1</span><span class="s2">, </span><span class="s1">t.label2]:</span>
                <span class="s1">obj.set_transform(self.axes.transData)</span>
        <span class="s2">return </span><span class="s1">ticks</span>

    <span class="s1">@_api.deprecated(</span><span class="s3">&quot;3.6&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">set_pane_pos(self</span><span class="s2">, </span><span class="s1">xys):</span>
        <span class="s4">&quot;&quot;&quot;Set pane position.&quot;&quot;&quot;</span>
        <span class="s1">self._set_pane_pos(xys)</span>

    <span class="s2">def </span><span class="s1">_set_pane_pos(self</span><span class="s2">, </span><span class="s1">xys):</span>
        <span class="s1">xys = np.asarray(xys)</span>
        <span class="s1">xys = xys[:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">self.pane.xy = xys</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_pane_color(self</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Set pane color. 
 
        Parameters 
        ---------- 
        color : color 
            Color for axis pane. 
        alpha : float, optional 
            Alpha value for axis pane. If None, base it on *color*. 
        &quot;&quot;&quot;</span>
        <span class="s1">color = mcolors.to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s1">self._axinfo[</span><span class="s3">'color'</span><span class="s1">] = color</span>
        <span class="s1">self.pane.set_edgecolor(color)</span>
        <span class="s1">self.pane.set_facecolor(color)</span>
        <span class="s1">self.pane.set_alpha(color[-</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">set_rotate_label(self</span><span class="s2">, </span><span class="s1">val):</span>
        <span class="s4">&quot;&quot;&quot; 
        Whether to rotate the axis label: True, False or None. 
        If set to None the label will be rotated if longer than 4 chars. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._rotate_label = val</span>
        <span class="s1">self.stale = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">get_rotate_label(self</span><span class="s2">, </span><span class="s1">text):</span>
        <span class="s2">if </span><span class="s1">self._rotate_label </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._rotate_label</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">len(text) &gt; </span><span class="s5">4</span>

    <span class="s2">def </span><span class="s1">_get_coord_info(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">mins</span><span class="s2">, </span><span class="s1">maxs = np.array([</span>
            <span class="s1">self.axes.get_xbound()</span><span class="s2">,</span>
            <span class="s1">self.axes.get_ybound()</span><span class="s2">,</span>
            <span class="s1">self.axes.get_zbound()</span><span class="s2">,</span>
        <span class="s1">]).T</span>

        <span class="s0"># Get the mean value for each bound:</span>
        <span class="s1">centers = </span><span class="s5">0.5 </span><span class="s1">* (maxs + mins)</span>

        <span class="s0"># Add a small offset between min/max point and the edge of the</span>
        <span class="s0"># plot:</span>
        <span class="s1">deltas = (maxs - mins) / </span><span class="s5">12</span>
        <span class="s1">mins -= </span><span class="s5">0.25 </span><span class="s1">* deltas</span>
        <span class="s1">maxs += </span><span class="s5">0.25 </span><span class="s1">* deltas</span>

        <span class="s0"># Project the bounds along the current position of the cube:</span>
        <span class="s1">bounds = mins[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">maxs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mins[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">maxs[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mins[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">maxs[</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">bounds_proj = self.axes._tunit_cube(bounds</span><span class="s2">, </span><span class="s1">self.axes.M)</span>

        <span class="s0"># Determine which one of the parallel planes are higher up:</span>
        <span class="s1">means_z0 = np.zeros(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">means_z1 = np.zeros(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
            <span class="s1">means_z0[i] = np.mean(bounds_proj[self._PLANES[</span><span class="s5">2 </span><span class="s1">* i]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
            <span class="s1">means_z1[i] = np.mean(bounds_proj[self._PLANES[</span><span class="s5">2 </span><span class="s1">* i + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">highs = means_z0 &lt; means_z1</span>

        <span class="s0"># Special handling for edge-on views</span>
        <span class="s1">equals = np.abs(means_z0 - means_z1) &lt;= np.finfo(float).eps</span>
        <span class="s2">if </span><span class="s1">np.sum(equals) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">vertical = np.where(~equals)[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">vertical == </span><span class="s5">2</span><span class="s1">:  </span><span class="s0"># looking at XY plane</span>
                <span class="s1">highs = np.array([</span><span class="s2">True, True, </span><span class="s1">highs[</span><span class="s5">2</span><span class="s1">]])</span>
            <span class="s2">elif </span><span class="s1">vertical == </span><span class="s5">1</span><span class="s1">:  </span><span class="s0"># looking at XZ plane</span>
                <span class="s1">highs = np.array([</span><span class="s2">True, </span><span class="s1">highs[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, False</span><span class="s1">])</span>
            <span class="s2">elif </span><span class="s1">vertical == </span><span class="s5">0</span><span class="s1">:  </span><span class="s0"># looking at YZ plane</span>
                <span class="s1">highs = np.array([highs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, False, False</span><span class="s1">])</span>

        <span class="s2">return </span><span class="s1">mins</span><span class="s2">, </span><span class="s1">maxs</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">bounds_proj</span><span class="s2">, </span><span class="s1">highs</span>

    <span class="s2">def </span><span class="s1">_get_axis_line_edge_points(self</span><span class="s2">, </span><span class="s1">minmax</span><span class="s2">, </span><span class="s1">maxmin):</span>
        <span class="s4">&quot;&quot;&quot;Get the edge points for the black bolded axis line.&quot;&quot;&quot;</span>
        <span class="s0"># When changing vertical axis some of the axes has to be</span>
        <span class="s0"># moved to the other plane so it looks the same as if the z-axis</span>
        <span class="s0"># was the vertical axis.</span>
        <span class="s1">mb = [minmax</span><span class="s2">, </span><span class="s1">maxmin]</span>
        <span class="s1">mb_rev = mb[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">mm = [[mb</span><span class="s2">, </span><span class="s1">mb_rev</span><span class="s2">, </span><span class="s1">mb_rev]</span><span class="s2">, </span><span class="s1">[mb_rev</span><span class="s2">, </span><span class="s1">mb_rev</span><span class="s2">, </span><span class="s1">mb]</span><span class="s2">, </span><span class="s1">[mb</span><span class="s2">, </span><span class="s1">mb</span><span class="s2">, </span><span class="s1">mb]]</span>
        <span class="s1">mm = mm[self.axes._vertical_axis][self._axinfo[</span><span class="s3">&quot;i&quot;</span><span class="s1">]]</span>

        <span class="s1">juggled = self._axinfo[</span><span class="s3">&quot;juggled&quot;</span><span class="s1">]</span>
        <span class="s1">edge_point_0 = mm[</span><span class="s5">0</span><span class="s1">].copy()</span>
        <span class="s1">edge_point_0[juggled[</span><span class="s5">0</span><span class="s1">]] = mm[</span><span class="s5">1</span><span class="s1">][juggled[</span><span class="s5">0</span><span class="s1">]]</span>

        <span class="s1">edge_point_1 = edge_point_0.copy()</span>
        <span class="s1">edge_point_1[juggled[</span><span class="s5">1</span><span class="s1">]] = mm[</span><span class="s5">1</span><span class="s1">][juggled[</span><span class="s5">1</span><span class="s1">]]</span>

        <span class="s2">return </span><span class="s1">edge_point_0</span><span class="s2">, </span><span class="s1">edge_point_1</span>

    <span class="s2">def </span><span class="s1">_get_tickdir(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the direction of the tick. 
 
        Returns 
        ------- 
        tickdir : int 
            Index which indicates which coordinate the tick line will 
            align with. 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: Move somewhere else where it's triggered less:</span>
        <span class="s1">tickdirs_base = [v[</span><span class="s3">&quot;tickdir&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._AXINFO.values()]</span>
        <span class="s1">info_i = [v[</span><span class="s3">&quot;i&quot;</span><span class="s1">] </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._AXINFO.values()]</span>

        <span class="s1">i = self._axinfo[</span><span class="s3">&quot;i&quot;</span><span class="s1">]</span>
        <span class="s1">j = self.axes._vertical_axis - </span><span class="s5">2</span>
        <span class="s0"># tickdir = [[1, 2, 1], [2, 2, 0], [1, 0, 0]][i]</span>
        <span class="s1">tickdir = np.roll(info_i</span><span class="s2">, </span><span class="s1">-j)[np.roll(tickdirs_base</span><span class="s2">, </span><span class="s1">j)][i]</span>
        <span class="s2">return </span><span class="s1">tickdir</span>

    <span class="s2">def </span><span class="s1">draw_pane(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s4">&quot;&quot;&quot; 
        Draw pane. 
 
        Parameters 
        ---------- 
        renderer : `~matplotlib.backend_bases.RendererBase` subclass 
        &quot;&quot;&quot;</span>
        <span class="s1">renderer.open_group(</span><span class="s3">'pane3d'</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>

        <span class="s1">mins</span><span class="s2">, </span><span class="s1">maxs</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">tc</span><span class="s2">, </span><span class="s1">highs = self._get_coord_info(renderer)</span>

        <span class="s1">info = self._axinfo</span>
        <span class="s1">index = info[</span><span class="s3">'i'</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">highs[index]:</span>
            <span class="s1">plane = self._PLANES[</span><span class="s5">2 </span><span class="s1">* index]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">plane = self._PLANES[</span><span class="s5">2 </span><span class="s1">* index + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">xys = [tc[p] </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">plane]</span>
        <span class="s1">self._set_pane_pos(xys)</span>
        <span class="s1">self.pane.draw(renderer)</span>

        <span class="s1">renderer.close_group(</span><span class="s3">'pane3d'</span><span class="s1">)</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s2">def </span><span class="s1">draw(self</span><span class="s2">, </span><span class="s1">renderer):</span>
        <span class="s1">self.label._transform = self.axes.transData</span>
        <span class="s1">renderer.open_group(</span><span class="s3">&quot;axis3d&quot;</span><span class="s2">, </span><span class="s1">gid=self.get_gid())</span>

        <span class="s1">ticks = self._update_ticks()</span>

        <span class="s0"># Get general axis information:</span>
        <span class="s1">info = self._axinfo</span>
        <span class="s1">index = info[</span><span class="s3">&quot;i&quot;</span><span class="s1">]</span>
        <span class="s1">juggled = info[</span><span class="s3">&quot;juggled&quot;</span><span class="s1">]</span>

        <span class="s1">mins</span><span class="s2">, </span><span class="s1">maxs</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">deltas</span><span class="s2">, </span><span class="s1">tc</span><span class="s2">, </span><span class="s1">highs = self._get_coord_info(renderer)</span>

        <span class="s1">minmax = np.where(highs</span><span class="s2">, </span><span class="s1">maxs</span><span class="s2">, </span><span class="s1">mins)</span>
        <span class="s1">maxmin = np.where(~highs</span><span class="s2">, </span><span class="s1">maxs</span><span class="s2">, </span><span class="s1">mins)</span>

        <span class="s0"># Create edge points for the black bolded axis line:</span>
        <span class="s1">edgep1</span><span class="s2">, </span><span class="s1">edgep2 = self._get_axis_line_edge_points(minmax</span><span class="s2">, </span><span class="s1">maxmin)</span>

        <span class="s0"># Project the edge points along the current position and</span>
        <span class="s0"># create the line:</span>
        <span class="s1">pep = proj3d.proj_trans_points([edgep1</span><span class="s2">, </span><span class="s1">edgep2]</span><span class="s2">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">pep = np.asarray(pep)</span>
        <span class="s1">self.line.set_data(pep[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pep[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">self.line.draw(renderer)</span>

        <span class="s0"># Draw labels</span>
        <span class="s0"># The transAxes transform is used because the Text object</span>
        <span class="s0"># rotates the text relative to the display coordinate system.</span>
        <span class="s0"># Therefore, if we want the labels to remain parallel to the</span>
        <span class="s0"># axis regardless of the aspect ratio, we need to convert the</span>
        <span class="s0"># edge points of the plane to display coordinates and calculate</span>
        <span class="s0"># an angle from that.</span>
        <span class="s0"># TODO: Maybe Text objects should handle this themselves?</span>
        <span class="s1">dx</span><span class="s2">, </span><span class="s1">dy = (self.axes.transAxes.transform([pep[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]) -</span>
                  <span class="s1">self.axes.transAxes.transform([pep[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]]))[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">lxyz = </span><span class="s5">0.5 </span><span class="s1">* (edgep1 + edgep2)</span>

        <span class="s0"># A rough estimate; points are ambiguous since 3D plots rotate</span>
        <span class="s1">reltoinches = self.figure.dpi_scale_trans.inverted()</span>
        <span class="s1">ax_inches = reltoinches.transform(self.axes.bbox.size)</span>
        <span class="s1">ax_points_estimate = sum(</span><span class="s5">72. </span><span class="s1">* ax_inches)</span>
        <span class="s1">deltas_per_point = </span><span class="s5">48 </span><span class="s1">/ ax_points_estimate</span>
        <span class="s1">default_offset = </span><span class="s5">21.</span>
        <span class="s1">labeldeltas = (</span>
            <span class="s1">(self.labelpad + default_offset) * deltas_per_point * deltas)</span>
        <span class="s1">axmask = [</span><span class="s2">True, True, True</span><span class="s1">]</span>
        <span class="s1">axmask[index] = </span><span class="s2">False</span>
        <span class="s1">lxyz = _move_from_center(lxyz</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">labeldeltas</span><span class="s2">, </span><span class="s1">axmask)</span>
        <span class="s1">tlx</span><span class="s2">, </span><span class="s1">tly</span><span class="s2">, </span><span class="s1">tlz = proj3d.proj_transform(*lxyz</span><span class="s2">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">self.label.set_position((tlx</span><span class="s2">, </span><span class="s1">tly))</span>
        <span class="s2">if </span><span class="s1">self.get_rotate_label(self.label.get_text()):</span>
            <span class="s1">angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy</span><span class="s2">, </span><span class="s1">dx)))</span>
            <span class="s1">self.label.set_rotation(angle)</span>
        <span class="s1">self.label.set_va(info[</span><span class="s3">'label'</span><span class="s1">][</span><span class="s3">'va'</span><span class="s1">])</span>
        <span class="s1">self.label.set_ha(info[</span><span class="s3">'label'</span><span class="s1">][</span><span class="s3">'ha'</span><span class="s1">])</span>
        <span class="s1">self.label.set_rotation_mode(info[</span><span class="s3">'label'</span><span class="s1">][</span><span class="s3">'rotation_mode'</span><span class="s1">])</span>
        <span class="s1">self.label.draw(renderer)</span>

        <span class="s0"># Draw Offset text</span>

        <span class="s0"># Which of the two edge points do we want to</span>
        <span class="s0"># use for locating the offset text?</span>
        <span class="s2">if </span><span class="s1">juggled[</span><span class="s5">2</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">outeredgep = edgep1</span>
            <span class="s1">outerindex = </span><span class="s5">0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">outeredgep = edgep2</span>
            <span class="s1">outerindex = </span><span class="s5">1</span>

        <span class="s1">pos = _move_from_center(outeredgep</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">labeldeltas</span><span class="s2">, </span><span class="s1">axmask)</span>
        <span class="s1">olx</span><span class="s2">, </span><span class="s1">oly</span><span class="s2">, </span><span class="s1">olz = proj3d.proj_transform(*pos</span><span class="s2">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">self.offsetText.set_text(self.major.formatter.get_offset())</span>
        <span class="s1">self.offsetText.set_position((olx</span><span class="s2">, </span><span class="s1">oly))</span>
        <span class="s1">angle = art3d._norm_text_angle(np.rad2deg(np.arctan2(dy</span><span class="s2">, </span><span class="s1">dx)))</span>
        <span class="s1">self.offsetText.set_rotation(angle)</span>
        <span class="s0"># Must set rotation mode to &quot;anchor&quot; so that</span>
        <span class="s0"># the alignment point is used as the &quot;fulcrum&quot; for rotation.</span>
        <span class="s1">self.offsetText.set_rotation_mode(</span><span class="s3">'anchor'</span><span class="s1">)</span>

        <span class="s0"># ----------------------------------------------------------------------</span>
        <span class="s0"># Note: the following statement for determining the proper alignment of</span>
        <span class="s0"># the offset text. This was determined entirely by trial-and-error</span>
        <span class="s0"># and should not be in any way considered as &quot;the way&quot;.  There are</span>
        <span class="s0"># still some edge cases where alignment is not quite right, but this</span>
        <span class="s0"># seems to be more of a geometry issue (in other words, I might be</span>
        <span class="s0"># using the wrong reference points).</span>
        <span class="s0">#</span>
        <span class="s0"># (TT, FF, TF, FT) are the shorthand for the tuple of</span>
        <span class="s0">#   (centpt[info['tickdir']] &lt;= pep[info['tickdir'], outerindex],</span>
        <span class="s0">#    centpt[index] &lt;= pep[index, outerindex])</span>
        <span class="s0">#</span>
        <span class="s0"># Three-letters (e.g., TFT, FTT) are short-hand for the array of bools</span>
        <span class="s0"># from the variable 'highs'.</span>
        <span class="s0"># ---------------------------------------------------------------------</span>
        <span class="s1">centpt = proj3d.proj_transform(*centers</span><span class="s2">, </span><span class="s1">self.axes.M)</span>
        <span class="s2">if </span><span class="s1">centpt[info[</span><span class="s3">'tickdir'</span><span class="s1">]] &gt; pep[info[</span><span class="s3">'tickdir'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">outerindex]:</span>
            <span class="s0"># if FT and if highs has an even number of Trues</span>
            <span class="s2">if </span><span class="s1">(centpt[index] &lt;= pep[index</span><span class="s2">, </span><span class="s1">outerindex]</span>
                    <span class="s2">and </span><span class="s1">np.count_nonzero(highs) % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s0"># Usually, this means align right, except for the FTT case,</span>
                <span class="s0"># in which offset for axis 1 and 2 are aligned left.</span>
                <span class="s2">if </span><span class="s1">highs.tolist() == [</span><span class="s2">False, True, True</span><span class="s1">] </span><span class="s2">and </span><span class="s1">index </span><span class="s2">in </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
                    <span class="s1">align = </span><span class="s3">'left'</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">align = </span><span class="s3">'right'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># The FF case</span>
                <span class="s1">align = </span><span class="s3">'left'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># if TF and if highs has an even number of Trues</span>
            <span class="s2">if </span><span class="s1">(centpt[index] &gt; pep[index</span><span class="s2">, </span><span class="s1">outerindex]</span>
                    <span class="s2">and </span><span class="s1">np.count_nonzero(highs) % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">):</span>
                <span class="s0"># Usually mean align left, except if it is axis 2</span>
                <span class="s1">align = </span><span class="s3">'right' </span><span class="s2">if </span><span class="s1">index == </span><span class="s5">2 </span><span class="s2">else </span><span class="s3">'left'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># The TT case</span>
                <span class="s1">align = </span><span class="s3">'right'</span>

        <span class="s1">self.offsetText.set_va(</span><span class="s3">'center'</span><span class="s1">)</span>
        <span class="s1">self.offsetText.set_ha(align)</span>
        <span class="s1">self.offsetText.draw(renderer)</span>

        <span class="s2">if </span><span class="s1">self.axes._draw_grid </span><span class="s2">and </span><span class="s1">len(ticks):</span>
            <span class="s0"># Grid points where the planes meet</span>
            <span class="s1">xyz0 = np.tile(minmax</span><span class="s2">, </span><span class="s1">(len(ticks)</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">xyz0[:</span><span class="s2">, </span><span class="s1">index] = [tick.get_loc() </span><span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks]</span>

            <span class="s0"># Grid lines go from the end of one plane through the plane</span>
            <span class="s0"># intersection (at xyz0) to the end of the other plane.  The first</span>
            <span class="s0"># point (0) differs along dimension index-2 and the last (2) along</span>
            <span class="s0"># dimension index-1.</span>
            <span class="s1">lines = np.stack([xyz0</span><span class="s2">, </span><span class="s1">xyz0</span><span class="s2">, </span><span class="s1">xyz0]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">lines[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">index - </span><span class="s5">2</span><span class="s1">] = maxmin[index - </span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">lines[:</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">index - </span><span class="s5">1</span><span class="s1">] = maxmin[index - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.gridlines.set_segments(lines)</span>
            <span class="s1">gridinfo = info[</span><span class="s3">'grid'</span><span class="s1">]</span>
            <span class="s1">self.gridlines.set_color(gridinfo[</span><span class="s3">'color'</span><span class="s1">])</span>
            <span class="s1">self.gridlines.set_linewidth(gridinfo[</span><span class="s3">'linewidth'</span><span class="s1">])</span>
            <span class="s1">self.gridlines.set_linestyle(gridinfo[</span><span class="s3">'linestyle'</span><span class="s1">])</span>
            <span class="s1">self.gridlines.do_3d_projection()</span>
            <span class="s1">self.gridlines.draw(renderer)</span>

        <span class="s0"># Draw ticks:</span>
        <span class="s1">tickdir = self._get_tickdir()</span>
        <span class="s1">tickdelta = deltas[tickdir] </span><span class="s2">if </span><span class="s1">highs[tickdir] </span><span class="s2">else </span><span class="s1">-deltas[tickdir]</span>

        <span class="s1">tick_info = info[</span><span class="s3">'tick'</span><span class="s1">]</span>
        <span class="s1">tick_out = tick_info[</span><span class="s3">'outward_factor'</span><span class="s1">] * tickdelta</span>
        <span class="s1">tick_in = tick_info[</span><span class="s3">'inward_factor'</span><span class="s1">] * tickdelta</span>
        <span class="s1">tick_lw = tick_info[</span><span class="s3">'linewidth'</span><span class="s1">]</span>
        <span class="s1">edgep1_tickdir = edgep1[tickdir]</span>
        <span class="s1">out_tickdir = edgep1_tickdir + tick_out</span>
        <span class="s1">in_tickdir = edgep1_tickdir - tick_in</span>

        <span class="s1">default_label_offset = </span><span class="s5">8.  </span><span class="s0"># A rough estimate</span>
        <span class="s1">points = deltas_per_point * deltas</span>
        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s0"># Get tick line positions</span>
            <span class="s1">pos = edgep1.copy()</span>
            <span class="s1">pos[index] = tick.get_loc()</span>
            <span class="s1">pos[tickdir] = out_tickdir</span>
            <span class="s1">x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">z1 = proj3d.proj_transform(*pos</span><span class="s2">, </span><span class="s1">self.axes.M)</span>
            <span class="s1">pos[tickdir] = in_tickdir</span>
            <span class="s1">x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">z2 = proj3d.proj_transform(*pos</span><span class="s2">, </span><span class="s1">self.axes.M)</span>

            <span class="s0"># Get position of label</span>
            <span class="s1">labeldeltas = (tick.get_pad() + default_label_offset) * points</span>

            <span class="s1">pos[tickdir] = edgep1_tickdir</span>
            <span class="s1">pos = _move_from_center(pos</span><span class="s2">, </span><span class="s1">centers</span><span class="s2">, </span><span class="s1">labeldeltas</span><span class="s2">, </span><span class="s1">axmask)</span>
            <span class="s1">lx</span><span class="s2">, </span><span class="s1">ly</span><span class="s2">, </span><span class="s1">lz = proj3d.proj_transform(*pos</span><span class="s2">, </span><span class="s1">self.axes.M)</span>

            <span class="s1">_tick_update_position(tick</span><span class="s2">, </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">x2)</span><span class="s2">, </span><span class="s1">(y1</span><span class="s2">, </span><span class="s1">y2)</span><span class="s2">, </span><span class="s1">(lx</span><span class="s2">, </span><span class="s1">ly))</span>
            <span class="s1">tick.tick1line.set_linewidth(tick_lw[tick._major])</span>
            <span class="s1">tick.draw(renderer)</span>

        <span class="s1">renderer.close_group(</span><span class="s3">'axis3d'</span><span class="s1">)</span>
        <span class="s1">self.stale = </span><span class="s2">False</span>

    <span class="s0"># TODO: Get this to work (more) properly when mplot3d supports the</span>
    <span class="s0">#       transforms framework.</span>
    <span class="s2">def </span><span class="s1">get_tightbbox(self</span><span class="s2">, </span><span class="s1">renderer=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">for_layout_only=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s2">if not </span><span class="s1">self.get_visible():</span>
            <span class="s2">return</span>
        <span class="s0"># We have to directly access the internal data structures</span>
        <span class="s0"># (and hope they are up to date) because at draw time we</span>
        <span class="s0"># shift the ticks and their labels around in (x, y) space</span>
        <span class="s0"># based on the projection, the current view port, and their</span>
        <span class="s0"># position in 3D space.  If we extend the transforms framework</span>
        <span class="s0"># into 3D we would not need to do this different book keeping</span>
        <span class="s0"># than we do in the normal axis</span>
        <span class="s1">major_locs = self.get_majorticklocs()</span>
        <span class="s1">minor_locs = self.get_minorticklocs()</span>

        <span class="s1">ticks = [*self.get_minor_ticks(len(minor_locs))</span><span class="s2">,</span>
                 <span class="s1">*self.get_major_ticks(len(major_locs))]</span>
        <span class="s1">view_low</span><span class="s2">, </span><span class="s1">view_high = self.get_view_interval()</span>
        <span class="s2">if </span><span class="s1">view_low &gt; view_high:</span>
            <span class="s1">view_low</span><span class="s2">, </span><span class="s1">view_high = view_high</span><span class="s2">, </span><span class="s1">view_low</span>
        <span class="s1">interval_t = self.get_transform().transform([view_low</span><span class="s2">, </span><span class="s1">view_high])</span>

        <span class="s1">ticks_to_draw = []</span>
        <span class="s2">for </span><span class="s1">tick </span><span class="s2">in </span><span class="s1">ticks:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">loc_t = self.get_transform().transform(tick.get_loc())</span>
            <span class="s2">except </span><span class="s1">AssertionError:</span>
                <span class="s0"># Transform.transform doesn't allow masked values but</span>
                <span class="s0"># some scales might make them, so we need this try/except.</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">mtransforms._interval_contains_close(interval_t</span><span class="s2">, </span><span class="s1">loc_t):</span>
                    <span class="s1">ticks_to_draw.append(tick)</span>

        <span class="s1">ticks = ticks_to_draw</span>

        <span class="s1">bb_1</span><span class="s2">, </span><span class="s1">bb_2 = self._get_ticklabel_bboxes(ticks</span><span class="s2">, </span><span class="s1">renderer)</span>
        <span class="s1">other = []</span>

        <span class="s2">if </span><span class="s1">self.line.get_visible():</span>
            <span class="s1">other.append(self.line.get_window_extent(renderer))</span>
        <span class="s2">if </span><span class="s1">(self.label.get_visible() </span><span class="s2">and not </span><span class="s1">for_layout_only </span><span class="s2">and</span>
                <span class="s1">self.label.get_text()):</span>
            <span class="s1">other.append(self.label.get_window_extent(renderer))</span>

        <span class="s2">return </span><span class="s1">mtransforms.Bbox.union([*bb_1</span><span class="s2">, </span><span class="s1">*bb_2</span><span class="s2">, </span><span class="s1">*other])</span>

    <span class="s1">d_interval = _api.deprecated(</span>
        <span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_data_interval&quot;</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">True</span><span class="s1">)(</span>
            <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.get_data_interval()</span><span class="s2">,</span>
                     <span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">minmax: self.set_data_interval(*minmax)))</span>
    <span class="s1">v_interval = _api.deprecated(</span>
        <span class="s3">&quot;3.6&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s3">&quot;get_view_interval&quot;</span><span class="s2">, </span><span class="s1">pending=</span><span class="s2">True</span><span class="s1">)(</span>
            <span class="s1">property(</span><span class="s2">lambda </span><span class="s1">self: self.get_view_interval()</span><span class="s2">,</span>
                     <span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">minmax: self.set_view_interval(*minmax)))</span>


<span class="s2">class </span><span class="s1">XAxis(Axis):</span>
    <span class="s1">axis_name = </span><span class="s3">&quot;x&quot;</span>
    <span class="s1">get_view_interval</span><span class="s2">, </span><span class="s1">set_view_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;view&quot;</span><span class="s2">, </span><span class="s3">&quot;xy_viewLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervalx&quot;</span><span class="s1">)</span>
    <span class="s1">get_data_interval</span><span class="s2">, </span><span class="s1">set_data_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s3">&quot;xy_dataLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervalx&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">YAxis(Axis):</span>
    <span class="s1">axis_name = </span><span class="s3">&quot;y&quot;</span>
    <span class="s1">get_view_interval</span><span class="s2">, </span><span class="s1">set_view_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;view&quot;</span><span class="s2">, </span><span class="s3">&quot;xy_viewLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervaly&quot;</span><span class="s1">)</span>
    <span class="s1">get_data_interval</span><span class="s2">, </span><span class="s1">set_data_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s3">&quot;xy_dataLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervaly&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ZAxis(Axis):</span>
    <span class="s1">axis_name = </span><span class="s3">&quot;z&quot;</span>
    <span class="s1">get_view_interval</span><span class="s2">, </span><span class="s1">set_view_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;view&quot;</span><span class="s2">, </span><span class="s3">&quot;zz_viewLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervalx&quot;</span><span class="s1">)</span>
    <span class="s1">get_data_interval</span><span class="s2">, </span><span class="s1">set_data_interval = maxis._make_getset_interval(</span>
        <span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s3">&quot;zz_dataLim&quot;</span><span class="s2">, </span><span class="s3">&quot;intervalx&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>