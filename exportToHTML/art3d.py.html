<html>
<head>
<title>art3d.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
art3d.py</font>
</center></td></tr></table>
<pre><span class="s0"># art3d.py, original mplot3d version by John Porter</span>
<span class="s0"># Parts rewritten by Reinier Heeres &lt;reinier@heeres.eu&gt;</span>
<span class="s0"># Minor additions by Ben Axelrod &lt;baxelrod@coroware.com&gt;</span>

<span class="s2">&quot;&quot;&quot; 
Module containing 3D artist code and functions to convert 2D 
artists into 3D versions which can be added to an Axes3D. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">math</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">contextmanager</span>

<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">artist</span><span class="s3">, </span><span class="s1">cbook</span><span class="s3">, </span><span class="s1">colors </span><span class="s3">as </span><span class="s1">mcolors</span><span class="s3">, </span><span class="s1">lines</span><span class="s3">, </span><span class="s1">text </span><span class="s3">as </span><span class="s1">mtext</span><span class="s3">,</span>
    <span class="s1">path </span><span class="s3">as </span><span class="s1">mpath)</span>
<span class="s3">from </span><span class="s1">matplotlib.collections </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">LineCollection</span><span class="s3">, </span><span class="s1">PolyCollection</span><span class="s3">, </span><span class="s1">PatchCollection</span><span class="s3">, </span><span class="s1">PathCollection)</span>
<span class="s3">from </span><span class="s1">matplotlib.colors </span><span class="s3">import </span><span class="s1">Normalize</span>
<span class="s3">from </span><span class="s1">matplotlib.patches </span><span class="s3">import </span><span class="s1">Patch</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">proj3d</span>


<span class="s3">def </span><span class="s1">_norm_angle(a):</span>
    <span class="s2">&quot;&quot;&quot;Return the given angle normalized to -180 &lt; *a* &lt;= 180 degrees.&quot;&quot;&quot;</span>
    <span class="s1">a = (a + </span><span class="s4">360</span><span class="s1">) % </span><span class="s4">360</span>
    <span class="s3">if </span><span class="s1">a &gt; </span><span class="s4">180</span><span class="s1">:</span>
        <span class="s1">a = a - </span><span class="s4">360</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">_norm_text_angle(a):</span>
    <span class="s2">&quot;&quot;&quot;Return the given angle normalized to -90 &lt; *a* &lt;= 90 degrees.&quot;&quot;&quot;</span>
    <span class="s1">a = (a + </span><span class="s4">180</span><span class="s1">) % </span><span class="s4">180</span>
    <span class="s3">if </span><span class="s1">a &gt; </span><span class="s4">90</span><span class="s1">:</span>
        <span class="s1">a = a - </span><span class="s4">180</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">get_dir_vector(zdir):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return a direction vector. 
 
    Parameters 
    ---------- 
    zdir : {'x', 'y', 'z', None, 3-tuple} 
        The direction. Possible values are: 
 
        - 'x': equivalent to (1, 0, 0) 
        - 'y': equivalent to (0, 1, 0) 
        - 'z': equivalent to (0, 0, 1) 
        - *None*: equivalent to (0, 0, 0) 
        - an iterable (x, y, z) is converted to a NumPy array, if not already 
 
    Returns 
    ------- 
    x, y, z : array-like 
        The direction vector. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">zdir == </span><span class="s5">'x'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">zdir == </span><span class="s5">'y'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">zdir == </span><span class="s5">'z'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">zdir </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s3">elif </span><span class="s1">np.iterable(zdir) </span><span class="s3">and </span><span class="s1">len(zdir) == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.array(zdir)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;'x', 'y', 'z', None or vector of length 3 expected&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">Text3D(mtext.Text):</span>
    <span class="s2">&quot;&quot;&quot; 
    Text object with 3D position and direction. 
 
    Parameters 
    ---------- 
    x, y, z : float 
        The position of the text. 
    text : str 
        The text string to display. 
    zdir : {'x', 'y', 'z', None, 3-tuple} 
        The direction of the text. See `.get_dir_vector` for a description of 
        the values. 
 
    Other Parameters 
    ---------------- 
    **kwargs 
         All other parameters are passed on to `~matplotlib.text.Text`. 
   &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">x=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">y=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">z=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">text=</span><span class="s5">''</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">mtext.Text.__init__(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">text</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_3d_properties(z</span><span class="s3">, </span><span class="s1">zdir)</span>

    <span class="s3">def </span><span class="s1">get_position_3d(self):</span>
        <span class="s2">&quot;&quot;&quot;Return the (x, y, z) position of the text.&quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._x</span><span class="s3">, </span><span class="s1">self._y</span><span class="s3">, </span><span class="s1">self._z</span>

    <span class="s3">def </span><span class="s1">set_position_3d(self</span><span class="s3">, </span><span class="s1">xyz</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the (*x*, *y*, *z*) position of the text. 
 
        Parameters 
        ---------- 
        xyz : (float, float, float) 
            The position in 3D space. 
        zdir : {'x', 'y', 'z', None, 3-tuple} 
            The direction of the text. If unspecified, the *zdir* will not be 
            changed. See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().set_position(xyz[:</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s1">self.set_z(xyz[</span><span class="s4">2</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">zdir </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._dir_vec = get_dir_vector(zdir)</span>

    <span class="s3">def </span><span class="s1">set_z(self</span><span class="s3">, </span><span class="s1">z):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* position of the text. 
 
        Parameters 
        ---------- 
        z : float 
        &quot;&quot;&quot;</span>
        <span class="s1">self._z = z</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">z=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* position and direction of the text. 
 
        Parameters 
        ---------- 
        z : float 
            The z-position in 3D space. 
        zdir : {'x', 'y', 'z', 3-tuple} 
            The direction of the text. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._z = z</span>
        <span class="s1">self._dir_vec = get_dir_vector(zdir)</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">renderer):</span>
        <span class="s1">position3d = np.array((self._x</span><span class="s3">, </span><span class="s1">self._y</span><span class="s3">, </span><span class="s1">self._z))</span>
        <span class="s1">proj = proj3d.proj_trans_points(</span>
            <span class="s1">[position3d</span><span class="s3">, </span><span class="s1">position3d + self._dir_vec]</span><span class="s3">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">dx = proj[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] - proj[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">dy = proj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] - proj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">angle = math.degrees(math.atan2(dy</span><span class="s3">, </span><span class="s1">dx))</span>
        <span class="s3">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s3">, </span><span class="s1">_x=proj[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">_y=proj[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                               <span class="s1">_rotation=_norm_text_angle(angle)):</span>
            <span class="s1">mtext.Text.draw(self</span><span class="s3">, </span><span class="s1">renderer)</span>
        <span class="s1">self.stale = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">get_tightbbox(self</span><span class="s3">, </span><span class="s1">renderer=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Overwriting the 2d Text behavior which is not valid for 3d.</span>
        <span class="s0"># For now, just return None to exclude from layout calculation.</span>
        <span class="s3">return None</span>


<span class="s3">def </span><span class="s1">text_2d_to_3d(obj</span><span class="s3">, </span><span class="s1">z=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a `.Text` to a `.Text3D` object. 
 
    Parameters 
    ---------- 
    z : float 
        The z-position in 3D space. 
    zdir : {'x', 'y', 'z', 3-tuple} 
        The direction of the text. Default: 'z'. 
        See `.get_dir_vector` for a description of the values. 
    &quot;&quot;&quot;</span>
    <span class="s1">obj.__class__ = Text3D</span>
    <span class="s1">obj.set_3d_properties(z</span><span class="s3">, </span><span class="s1">zdir)</span>


<span class="s3">class </span><span class="s1">Line3D(lines.Line2D):</span>
    <span class="s2">&quot;&quot;&quot; 
    3D line object. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
 
        Parameters 
        ---------- 
        xs : array-like 
            The x-data to be plotted. 
        ys : array-like 
            The y-data to be plotted. 
        zs : array-like 
            The z-data to be plotted. 
 
        Additional arguments are passed onto :func:`~matplotlib.lines.Line2D`. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__([]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_data_3d(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs)</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* position and direction of the line. 
 
        Parameters 
        ---------- 
        zs : float or array of floats 
            The location along the *zdir* axis in 3D space to position the 
            line. 
        zdir : {'x', 'y', 'z'} 
            Plane to plot line orthogonal to. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">xs = self.get_xdata()</span>
        <span class="s1">ys = self.get_ydata()</span>
        <span class="s1">zs = cbook._to_unmasked_float_array(zs).ravel()</span>
        <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(xs))</span>
        <span class="s1">self._verts3d = juggle_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir)</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_data_3d(self</span><span class="s3">, </span><span class="s1">*args):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the x, y and z data 
 
        Parameters 
        ---------- 
        x : array-like 
            The x-data to be plotted. 
        y : array-like 
            The y-data to be plotted. 
        z : array-like 
            The z-data to be plotted. 
 
        Notes 
        ----- 
        Accepts x, y, z arguments or a single array-like (x, y, z) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(args) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">args = args[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">xyz </span><span class="s3">in </span><span class="s1">zip(</span><span class="s5">'xyz'</span><span class="s3">, </span><span class="s1">args):</span>
            <span class="s3">if not </span><span class="s1">np.iterable(xyz):</span>
                <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">must be a sequence'</span><span class="s1">)</span>
        <span class="s1">self._verts3d = args</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">get_data_3d(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Get the current data 
 
        Returns 
        ------- 
        verts3d : length-3 tuple or array-like 
            The current data as a tuple or array-like. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._verts3d</span>

    <span class="s1">@artist.allow_rasterization</span>
    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">renderer):</span>
        <span class="s1">xs3d</span><span class="s3">, </span><span class="s1">ys3d</span><span class="s3">, </span><span class="s1">zs3d = self._verts3d</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = proj3d.proj_transform(xs3d</span><span class="s3">, </span><span class="s1">ys3d</span><span class="s3">, </span><span class="s1">zs3d</span><span class="s3">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">self.set_data(xs</span><span class="s3">, </span><span class="s1">ys)</span>
        <span class="s1">super().draw(renderer)</span>
        <span class="s1">self.stale = </span><span class="s3">False</span>


<span class="s3">def </span><span class="s1">line_2d_to_3d(line</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a `.Line2D` to a `.Line3D` object. 
 
    Parameters 
    ---------- 
    zs : float 
        The location along the *zdir* axis in 3D space to position the line. 
    zdir : {'x', 'y', 'z'} 
        Plane to plot line orthogonal to. Default: 'z'. 
        See `.get_dir_vector` for a description of the values. 
    &quot;&quot;&quot;</span>

    <span class="s1">line.__class__ = Line3D</span>
    <span class="s1">line.set_3d_properties(zs</span><span class="s3">, </span><span class="s1">zdir)</span>


<span class="s3">def </span><span class="s1">_path_to_3d_segment(path</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert a path to a 3D segment.&quot;&quot;&quot;</span>

    <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(path))</span>
    <span class="s1">pathsegs = path.iter_segments(simplify=</span><span class="s3">False, </span><span class="s1">curves=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">seg = [(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z) </span><span class="s3">for </span><span class="s1">(((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">code)</span><span class="s3">, </span><span class="s1">z) </span><span class="s3">in </span><span class="s1">zip(pathsegs</span><span class="s3">, </span><span class="s1">zs)]</span>
    <span class="s1">seg3d = [juggle_axes(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">zdir) </span><span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z) </span><span class="s3">in </span><span class="s1">seg]</span>
    <span class="s3">return </span><span class="s1">seg3d</span>


<span class="s3">def </span><span class="s1">_paths_to_3d_segments(paths</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert paths from a collection object to 3D segments.&quot;&quot;&quot;</span>

    <span class="s3">if not </span><span class="s1">np.iterable(zs):</span>
        <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(paths))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">len(zs) != len(paths):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Number of z-coordinates does not match paths.'</span><span class="s1">)</span>

    <span class="s1">segs = [_path_to_3d_segment(path</span><span class="s3">, </span><span class="s1">pathz</span><span class="s3">, </span><span class="s1">zdir)</span>
            <span class="s3">for </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pathz </span><span class="s3">in </span><span class="s1">zip(paths</span><span class="s3">, </span><span class="s1">zs)]</span>
    <span class="s3">return </span><span class="s1">segs</span>


<span class="s3">def </span><span class="s1">_path_to_3d_segment_with_codes(path</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert a path to a 3D segment with path codes.&quot;&quot;&quot;</span>

    <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(path))</span>
    <span class="s1">pathsegs = path.iter_segments(simplify=</span><span class="s3">False, </span><span class="s1">curves=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">seg_codes = [((x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z)</span><span class="s3">, </span><span class="s1">code) </span><span class="s3">for </span><span class="s1">((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">code)</span><span class="s3">, </span><span class="s1">z </span><span class="s3">in </span><span class="s1">zip(pathsegs</span><span class="s3">, </span><span class="s1">zs)]</span>
    <span class="s3">if </span><span class="s1">seg_codes:</span>
        <span class="s1">seg</span><span class="s3">, </span><span class="s1">codes = zip(*seg_codes)</span>
        <span class="s1">seg3d = [juggle_axes(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">zdir) </span><span class="s3">for </span><span class="s1">(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z) </span><span class="s3">in </span><span class="s1">seg]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">seg3d = []</span>
        <span class="s1">codes = []</span>
    <span class="s3">return </span><span class="s1">seg3d</span><span class="s3">, </span><span class="s1">list(codes)</span>


<span class="s3">def </span><span class="s1">_paths_to_3d_segments_with_codes(paths</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert paths from a collection object to 3D segments with path codes. 
    &quot;&quot;&quot;</span>

    <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(paths))</span>
    <span class="s1">segments_codes = [_path_to_3d_segment_with_codes(path</span><span class="s3">, </span><span class="s1">pathz</span><span class="s3">, </span><span class="s1">zdir)</span>
                      <span class="s3">for </span><span class="s1">path</span><span class="s3">, </span><span class="s1">pathz </span><span class="s3">in </span><span class="s1">zip(paths</span><span class="s3">, </span><span class="s1">zs)]</span>
    <span class="s3">if </span><span class="s1">segments_codes:</span>
        <span class="s1">segments</span><span class="s3">, </span><span class="s1">codes = zip(*segments_codes)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">segments</span><span class="s3">, </span><span class="s1">codes = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s3">return </span><span class="s1">list(segments)</span><span class="s3">, </span><span class="s1">list(codes)</span>


<span class="s3">class </span><span class="s1">Line3DCollection(LineCollection):</span>
    <span class="s2">&quot;&quot;&quot; 
    A collection of 3D lines. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">set_sort_zpos(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2">&quot;&quot;&quot;Set the position to use for z-sorting.&quot;&quot;&quot;</span>
        <span class="s1">self._sort_zpos = val</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_segments(self</span><span class="s3">, </span><span class="s1">segments):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set 3D segments. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._segments3d = segments</span>
        <span class="s1">super().set_segments([])</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Project the points according to renderer matrix. 
        &quot;&quot;&quot;</span>
        <span class="s1">xyslist = [proj3d.proj_trans_points(points</span><span class="s3">, </span><span class="s1">self.axes.M)</span>
                   <span class="s3">for </span><span class="s1">points </span><span class="s3">in </span><span class="s1">self._segments3d]</span>
        <span class="s1">segments_2d = [np.column_stack([xs</span><span class="s3">, </span><span class="s1">ys]) </span><span class="s3">for </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs </span><span class="s3">in </span><span class="s1">xyslist]</span>
        <span class="s1">LineCollection.set_segments(self</span><span class="s3">, </span><span class="s1">segments_2d)</span>

        <span class="s0"># FIXME</span>
        <span class="s1">minz = </span><span class="s4">1e9</span>
        <span class="s3">for </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs </span><span class="s3">in </span><span class="s1">xyslist:</span>
            <span class="s1">minz = min(minz</span><span class="s3">, </span><span class="s1">min(zs))</span>
        <span class="s3">return </span><span class="s1">minz</span>


<span class="s3">def </span><span class="s1">line_collection_2d_to_3d(col</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert a `.LineCollection` to a `.Line3DCollection` object.&quot;&quot;&quot;</span>
    <span class="s1">segments3d = _paths_to_3d_segments(col.get_paths()</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir)</span>
    <span class="s1">col.__class__ = Line3DCollection</span>
    <span class="s1">col.set_segments(segments3d)</span>


<span class="s3">class </span><span class="s1">Patch3D(Patch):</span>
    <span class="s2">&quot;&quot;&quot; 
    3D patch object. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">zs=()</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        verts : 
        zs : float 
            The location along the *zdir* axis in 3D space to position the 
            patch. 
        zdir : {'x', 'y', 'z'} 
            Plane to plot patch orthogonal to. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_3d_properties(zs</span><span class="s3">, </span><span class="s1">zdir)</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">verts</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* position and direction of the patch. 
 
        Parameters 
        ---------- 
        verts : 
        zs : float 
            The location along the *zdir* axis in 3D space to position the 
            patch. 
        zdir : {'x', 'y', 'z'} 
            Plane to plot patch orthogonal to. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">zs = np.broadcast_to(zs</span><span class="s3">, </span><span class="s1">len(verts))</span>
        <span class="s1">self._segment3d = [juggle_axes(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">zdir)</span>
                           <span class="s3">for </span><span class="s1">((x</span><span class="s3">, </span><span class="s1">y)</span><span class="s3">, </span><span class="s1">z) </span><span class="s3">in </span><span class="s1">zip(verts</span><span class="s3">, </span><span class="s1">zs)]</span>

    <span class="s3">def </span><span class="s1">get_path(self):</span>
        <span class="s3">return </span><span class="s1">self._path2d</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s1">s = self._segment3d</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = zip(*s)</span>
        <span class="s1">vxs</span><span class="s3">, </span><span class="s1">vys</span><span class="s3">, </span><span class="s1">vzs</span><span class="s3">, </span><span class="s1">vis = proj3d.proj_transform_clip(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">,</span>
                                                        <span class="s1">self.axes.M)</span>
        <span class="s1">self._path2d = mpath.Path(np.column_stack([vxs</span><span class="s3">, </span><span class="s1">vys]))</span>
        <span class="s3">return </span><span class="s1">min(vzs)</span>


<span class="s3">class </span><span class="s1">PathPatch3D(Patch3D):</span>
    <span class="s2">&quot;&quot;&quot; 
    3D PathPatch object. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">zs=()</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        path : 
        zs : float 
            The location along the *zdir* axis in 3D space to position the 
            path patch. 
        zdir : {'x', 'y', 'z', 3-tuple} 
            Plane to plot path patch orthogonal to. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Not super().__init__!</span>
        <span class="s1">Patch.__init__(self</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_3d_properties(path</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir)</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* position and direction of the path patch. 
 
        Parameters 
        ---------- 
        path : 
        zs : float 
            The location along the *zdir* axis in 3D space to position the 
            path patch. 
        zdir : {'x', 'y', 'z', 3-tuple} 
            Plane to plot path patch orthogonal to. Default: 'z'. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">Patch3D.set_3d_properties(self</span><span class="s3">, </span><span class="s1">path.vertices</span><span class="s3">, </span><span class="s1">zs=zs</span><span class="s3">, </span><span class="s1">zdir=zdir)</span>
        <span class="s1">self._code3d = path.codes</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s1">s = self._segment3d</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = zip(*s)</span>
        <span class="s1">vxs</span><span class="s3">, </span><span class="s1">vys</span><span class="s3">, </span><span class="s1">vzs</span><span class="s3">, </span><span class="s1">vis = proj3d.proj_transform_clip(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">,</span>
                                                        <span class="s1">self.axes.M)</span>
        <span class="s1">self._path2d = mpath.Path(np.column_stack([vxs</span><span class="s3">, </span><span class="s1">vys])</span><span class="s3">, </span><span class="s1">self._code3d)</span>
        <span class="s3">return </span><span class="s1">min(vzs)</span>


<span class="s3">def </span><span class="s1">_get_patch_verts(patch):</span>
    <span class="s2">&quot;&quot;&quot;Return a list of vertices for the path of a patch.&quot;&quot;&quot;</span>
    <span class="s1">trans = patch.get_patch_transform()</span>
    <span class="s1">path = patch.get_path()</span>
    <span class="s1">polygons = path.to_polygons(trans)</span>
    <span class="s3">return </span><span class="s1">polygons[</span><span class="s4">0</span><span class="s1">] </span><span class="s3">if </span><span class="s1">len(polygons) </span><span class="s3">else </span><span class="s1">np.array([])</span>


<span class="s3">def </span><span class="s1">patch_2d_to_3d(patch</span><span class="s3">, </span><span class="s1">z=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert a `.Patch` to a `.Patch3D` object.&quot;&quot;&quot;</span>
    <span class="s1">verts = _get_patch_verts(patch)</span>
    <span class="s1">patch.__class__ = Patch3D</span>
    <span class="s1">patch.set_3d_properties(verts</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">zdir)</span>


<span class="s3">def </span><span class="s1">pathpatch_2d_to_3d(pathpatch</span><span class="s3">, </span><span class="s1">z=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert a `.PathPatch` to a `.PathPatch3D` object.&quot;&quot;&quot;</span>
    <span class="s1">path = pathpatch.get_path()</span>
    <span class="s1">trans = pathpatch.get_patch_transform()</span>

    <span class="s1">mpath = trans.transform_path(path)</span>
    <span class="s1">pathpatch.__class__ = PathPatch3D</span>
    <span class="s1">pathpatch.set_3d_properties(mpath</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">zdir)</span>


<span class="s3">class </span><span class="s1">Patch3DCollection(PatchCollection):</span>
    <span class="s2">&quot;&quot;&quot; 
    A collection of 3D patches. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">depthshade=</span><span class="s3">True, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a collection of flat 3D patches with its normal vector 
        pointed in *zdir* direction, and located at *zs* on the *zdir* 
        axis. 'zs' can be a scalar or an array-like of the same length as 
        the number of patches in the collection. 
 
        Constructor arguments are the same as for 
        :class:`~matplotlib.collections.PatchCollection`. In addition, 
        keywords *zs=0* and *zdir='z'* are available. 
 
        Also, the keyword argument *depthshade* is available to indicate 
        whether to shade the patches in order to give the appearance of depth 
        (default is *True*). This is typically desired in scatter plots. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._depthshade = depthshade</span>
        <span class="s1">super().__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_3d_properties(zs</span><span class="s3">, </span><span class="s1">zdir)</span>

    <span class="s3">def </span><span class="s1">get_depthshade(self):</span>
        <span class="s3">return </span><span class="s1">self._depthshade</span>

    <span class="s3">def </span><span class="s1">set_depthshade(self</span><span class="s3">, </span><span class="s1">depthshade):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether depth shading is performed on collection members. 
 
        Parameters 
        ---------- 
        depthshade : bool 
            Whether to shade the patches in order to give the appearance of 
            depth. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._depthshade = depthshade</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_sort_zpos(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2">&quot;&quot;&quot;Set the position to use for z-sorting.&quot;&quot;&quot;</span>
        <span class="s1">self._sort_zpos = val</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* positions and direction of the patches. 
 
        Parameters 
        ---------- 
        zs : float or array of floats 
            The location or locations to place the patches in the collection 
            along the *zdir* axis. 
        zdir : {'x', 'y', 'z'} 
            Plane to plot patches orthogonal to. 
            All patches must have the same direction. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Force the collection to initialize the face and edgecolors</span>
        <span class="s0"># just in case it is a scalarmappable with a colormap.</span>
        <span class="s1">self.update_scalarmappable()</span>
        <span class="s1">offsets = self.get_offsets()</span>
        <span class="s3">if </span><span class="s1">len(offsets) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys = offsets.T</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">xs = []</span>
            <span class="s1">ys = []</span>
        <span class="s1">self._offsets3d = juggle_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">np.atleast_1d(zs)</span><span class="s3">, </span><span class="s1">zdir)</span>
        <span class="s1">self._z_markers_idx = slice(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self._vzs = </span><span class="s3">None</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = self._offsets3d</span>
        <span class="s1">vxs</span><span class="s3">, </span><span class="s1">vys</span><span class="s3">, </span><span class="s1">vzs</span><span class="s3">, </span><span class="s1">vis = proj3d.proj_transform_clip(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">,</span>
                                                        <span class="s1">self.axes.M)</span>
        <span class="s1">self._vzs = vzs</span>
        <span class="s1">super().set_offsets(np.column_stack([vxs</span><span class="s3">, </span><span class="s1">vys]))</span>

        <span class="s3">if </span><span class="s1">vzs.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">min(vzs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.nan</span>

    <span class="s3">def </span><span class="s1">_maybe_depth_shade_and_sort_colors(self</span><span class="s3">, </span><span class="s1">color_array):</span>
        <span class="s1">color_array = (</span>
            <span class="s1">_zalpha(color_array</span><span class="s3">, </span><span class="s1">self._vzs)</span>
            <span class="s3">if </span><span class="s1">self._vzs </span><span class="s3">is not None and </span><span class="s1">self._depthshade</span>
            <span class="s3">else </span><span class="s1">color_array</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(color_array) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">color_array = color_array[self._z_markers_idx]</span>
        <span class="s3">return </span><span class="s1">mcolors.to_rgba_array(color_array</span><span class="s3">, </span><span class="s1">self._alpha)</span>

    <span class="s3">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s3">return </span><span class="s1">self._maybe_depth_shade_and_sort_colors(super().get_facecolor())</span>

    <span class="s3">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s0"># We need this check here to make sure we do not double-apply the depth</span>
        <span class="s0"># based alpha shading when the edge color is &quot;face&quot; which means the</span>
        <span class="s0"># edge colour should be identical to the face colour.</span>
        <span class="s3">if </span><span class="s1">cbook._str_equal(self._edgecolors</span><span class="s3">, </span><span class="s5">'face'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.get_facecolor()</span>
        <span class="s3">return </span><span class="s1">self._maybe_depth_shade_and_sort_colors(super().get_edgecolor())</span>


<span class="s3">class </span><span class="s1">Path3DCollection(PathCollection):</span>
    <span class="s2">&quot;&quot;&quot; 
    A collection of 3D paths. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">depthshade=</span><span class="s3">True, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a collection of flat 3D paths with its normal vector 
        pointed in *zdir* direction, and located at *zs* on the *zdir* 
        axis. 'zs' can be a scalar or an array-like of the same length as 
        the number of paths in the collection. 
 
        Constructor arguments are the same as for 
        :class:`~matplotlib.collections.PathCollection`. In addition, 
        keywords *zs=0* and *zdir='z'* are available. 
 
        Also, the keyword argument *depthshade* is available to indicate 
        whether to shade the patches in order to give the appearance of depth 
        (default is *True*). This is typically desired in scatter plots. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._depthshade = depthshade</span>
        <span class="s1">self._in_draw = </span><span class="s3">False</span>
        <span class="s1">super().__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.set_3d_properties(zs</span><span class="s3">, </span><span class="s1">zdir)</span>
        <span class="s1">self._offset_zordered = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">draw(self</span><span class="s3">, </span><span class="s1">renderer):</span>
        <span class="s3">with </span><span class="s1">self._use_zordered_offset():</span>
            <span class="s3">with </span><span class="s1">cbook._setattr_cm(self</span><span class="s3">, </span><span class="s1">_in_draw=</span><span class="s3">True</span><span class="s1">):</span>
                <span class="s1">super().draw(renderer)</span>

    <span class="s3">def </span><span class="s1">set_sort_zpos(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2">&quot;&quot;&quot;Set the position to use for z-sorting.&quot;&quot;&quot;</span>
        <span class="s1">self._sort_zpos = val</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the *z* positions and direction of the paths. 
 
        Parameters 
        ---------- 
        zs : float or array of floats 
            The location or locations to place the paths in the collection 
            along the *zdir* axis. 
        zdir : {'x', 'y', 'z'} 
            Plane to plot paths orthogonal to. 
            All paths must have the same direction. 
            See `.get_dir_vector` for a description of the values. 
        &quot;&quot;&quot;</span>
        <span class="s0"># Force the collection to initialize the face and edgecolors</span>
        <span class="s0"># just in case it is a scalarmappable with a colormap.</span>
        <span class="s1">self.update_scalarmappable()</span>
        <span class="s1">offsets = self.get_offsets()</span>
        <span class="s3">if </span><span class="s1">len(offsets) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys = offsets.T</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">xs = []</span>
            <span class="s1">ys = []</span>
        <span class="s1">self._offsets3d = juggle_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">np.atleast_1d(zs)</span><span class="s3">, </span><span class="s1">zdir)</span>
        <span class="s0"># In the base draw methods we access the attributes directly which</span>
        <span class="s0"># means we can not resolve the shuffling in the getter methods like</span>
        <span class="s0"># we do for the edge and face colors.</span>
        <span class="s0">#</span>
        <span class="s0"># This means we need to carry around a cache of the unsorted sizes and</span>
        <span class="s0"># widths (postfixed with 3d) and in `do_3d_projection` set the</span>
        <span class="s0"># depth-sorted version of that data into the private state used by the</span>
        <span class="s0"># base collection class in its draw method.</span>
        <span class="s0">#</span>
        <span class="s0"># Grab the current sizes and linewidths to preserve them.</span>
        <span class="s1">self._sizes3d = self._sizes</span>
        <span class="s1">self._linewidths3d = np.array(self._linewidths)</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = self._offsets3d</span>

        <span class="s0"># Sort the points based on z coordinates</span>
        <span class="s0"># Performance optimization: Create a sorted index array and reorder</span>
        <span class="s0"># points and point properties according to the index array</span>
        <span class="s1">self._z_markers_idx = slice(-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self._vzs = </span><span class="s3">None</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_sizes(self</span><span class="s3">, </span><span class="s1">sizes</span><span class="s3">, </span><span class="s1">dpi=</span><span class="s4">72.0</span><span class="s1">):</span>
        <span class="s1">super().set_sizes(sizes</span><span class="s3">, </span><span class="s1">dpi)</span>
        <span class="s3">if not </span><span class="s1">self._in_draw:</span>
            <span class="s1">self._sizes3d = sizes</span>

    <span class="s3">def </span><span class="s1">set_linewidth(self</span><span class="s3">, </span><span class="s1">lw):</span>
        <span class="s1">super().set_linewidth(lw)</span>
        <span class="s3">if not </span><span class="s1">self._in_draw:</span>
            <span class="s1">self._linewidths3d = np.array(self._linewidths)</span>

    <span class="s3">def </span><span class="s1">get_depthshade(self):</span>
        <span class="s3">return </span><span class="s1">self._depthshade</span>

    <span class="s3">def </span><span class="s1">set_depthshade(self</span><span class="s3">, </span><span class="s1">depthshade):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set whether depth shading is performed on collection members. 
 
        Parameters 
        ---------- 
        depthshade : bool 
            Whether to shade the patches in order to give the appearance of 
            depth. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._depthshade = depthshade</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = self._offsets3d</span>
        <span class="s1">vxs</span><span class="s3">, </span><span class="s1">vys</span><span class="s3">, </span><span class="s1">vzs</span><span class="s3">, </span><span class="s1">vis = proj3d.proj_transform_clip(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">,</span>
                                                        <span class="s1">self.axes.M)</span>
        <span class="s0"># Sort the points based on z coordinates</span>
        <span class="s0"># Performance optimization: Create a sorted index array and reorder</span>
        <span class="s0"># points and point properties according to the index array</span>
        <span class="s1">z_markers_idx = self._z_markers_idx = np.argsort(vzs)[::-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self._vzs = vzs</span>

        <span class="s0"># we have to special case the sizes because of code in collections.py</span>
        <span class="s0"># as the draw method does</span>
        <span class="s0">#      self.set_sizes(self._sizes, self.figure.dpi)</span>
        <span class="s0"># so we can not rely on doing the sorting on the way out via get_*</span>

        <span class="s3">if </span><span class="s1">len(self._sizes3d) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self._sizes = self._sizes3d[z_markers_idx]</span>

        <span class="s3">if </span><span class="s1">len(self._linewidths3d) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self._linewidths = self._linewidths3d[z_markers_idx]</span>

        <span class="s1">PathCollection.set_offsets(self</span><span class="s3">, </span><span class="s1">np.column_stack((vxs</span><span class="s3">, </span><span class="s1">vys)))</span>

        <span class="s0"># Re-order items</span>
        <span class="s1">vzs = vzs[z_markers_idx]</span>
        <span class="s1">vxs = vxs[z_markers_idx]</span>
        <span class="s1">vys = vys[z_markers_idx]</span>

        <span class="s0"># Store ordered offset for drawing purpose</span>
        <span class="s1">self._offset_zordered = np.column_stack((vxs</span><span class="s3">, </span><span class="s1">vys))</span>

        <span class="s3">return </span><span class="s1">np.min(vzs) </span><span class="s3">if </span><span class="s1">vzs.size </span><span class="s3">else </span><span class="s1">np.nan</span>

    <span class="s1">@contextmanager</span>
    <span class="s3">def </span><span class="s1">_use_zordered_offset(self):</span>
        <span class="s3">if </span><span class="s1">self._offset_zordered </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s0"># Do nothing</span>
            <span class="s3">yield</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Swap offset with z-ordered offset</span>
            <span class="s1">old_offset = self._offsets</span>
            <span class="s1">super().set_offsets(self._offset_zordered)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s3">yield</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">self._offsets = old_offset</span>

    <span class="s3">def </span><span class="s1">_maybe_depth_shade_and_sort_colors(self</span><span class="s3">, </span><span class="s1">color_array):</span>
        <span class="s1">color_array = (</span>
            <span class="s1">_zalpha(color_array</span><span class="s3">, </span><span class="s1">self._vzs)</span>
            <span class="s3">if </span><span class="s1">self._vzs </span><span class="s3">is not None and </span><span class="s1">self._depthshade</span>
            <span class="s3">else </span><span class="s1">color_array</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(color_array) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">color_array = color_array[self._z_markers_idx]</span>
        <span class="s3">return </span><span class="s1">mcolors.to_rgba_array(color_array</span><span class="s3">, </span><span class="s1">self._alpha)</span>

    <span class="s3">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s3">return </span><span class="s1">self._maybe_depth_shade_and_sort_colors(super().get_facecolor())</span>

    <span class="s3">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s0"># We need this check here to make sure we do not double-apply the depth</span>
        <span class="s0"># based alpha shading when the edge color is &quot;face&quot; which means the</span>
        <span class="s0"># edge colour should be identical to the face colour.</span>
        <span class="s3">if </span><span class="s1">cbook._str_equal(self._edgecolors</span><span class="s3">, </span><span class="s5">'face'</span><span class="s1">):</span>
            <span class="s3">return </span><span class="s1">self.get_facecolor()</span>
        <span class="s3">return </span><span class="s1">self._maybe_depth_shade_and_sort_colors(super().get_edgecolor())</span>


<span class="s3">def </span><span class="s1">patch_collection_2d_to_3d(col</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s3">, </span><span class="s1">depthshade=</span><span class="s3">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a `.PatchCollection` into a `.Patch3DCollection` object 
    (or a `.PathCollection` into a `.Path3DCollection` object). 
 
    Parameters 
    ---------- 
    zs : float or array of floats 
        The location or locations to place the patches in the collection along 
        the *zdir* axis. Default: 0. 
    zdir : {'x', 'y', 'z'} 
        The axis in which to place the patches. Default: &quot;z&quot;. 
        See `.get_dir_vector` for a description of the values. 
    depthshade 
        Whether to shade the patches to give a sense of depth. Default: *True*. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(col</span><span class="s3">, </span><span class="s1">PathCollection):</span>
        <span class="s1">col.__class__ = Path3DCollection</span>
    <span class="s3">elif </span><span class="s1">isinstance(col</span><span class="s3">, </span><span class="s1">PatchCollection):</span>
        <span class="s1">col.__class__ = Patch3DCollection</span>
    <span class="s1">col._depthshade = depthshade</span>
    <span class="s1">col._in_draw = </span><span class="s3">False</span>
    <span class="s1">col.set_3d_properties(zs</span><span class="s3">, </span><span class="s1">zdir)</span>


<span class="s3">class </span><span class="s1">Poly3DCollection(PolyCollection):</span>
    <span class="s2">&quot;&quot;&quot; 
    A collection of 3D polygons. 
 
    .. note:: 
        **Filling of 3D polygons** 
 
        There is no simple definition of the enclosed surface of a 3D polygon 
        unless the polygon is planar. 
 
        In practice, Matplotlib fills the 2D projection of the polygon. This 
        gives a correct filling appearance only for planar polygons. For all 
        other polygons, you'll find orientations in which the edges of the 
        polygon intersect in the projection. This will lead to an incorrect 
        visualization of the 3D area. 
 
        If you need filled areas, it is recommended to create them via 
        `~mpl_toolkits.mplot3d.axes3d.Axes3D.plot_trisurf`, which creates a 
        triangulation and thus generates consistent surfaces. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">verts</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">zsort=</span><span class="s5">'average'</span><span class="s3">, </span><span class="s1">shade=</span><span class="s3">False,</span>
                 <span class="s1">lightsource=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        verts : list of (N, 3) array-like 
            The sequence of polygons [*verts0*, *verts1*, ...] where each 
            element *verts_i* defines the vertices of polygon *i* as a 2D 
            array-like of shape (N, 3). 
        zsort : {'average', 'min', 'max'}, default: 'average' 
            The calculation method for the z-order. 
            See `~.Poly3DCollection.set_zsort` for details. 
        shade : bool, default: False 
            Whether to shade *facecolors* and *edgecolors*. When activating 
            *shade*, *facecolors* and/or *edgecolors* must be provided. 
 
            .. versionadded:: 3.7 
 
        lightsource : `~matplotlib.colors.LightSource` 
            The lightsource to use when *shade* is True. 
 
            .. versionadded:: 3.7 
 
        *args, **kwargs 
            All other parameters are forwarded to `.PolyCollection`. 
 
        Notes 
        ----- 
        Note that this class does a bit of magic with the _facecolors 
        and _edgecolors properties. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">shade:</span>
            <span class="s1">normals = _generate_normals(verts)</span>
            <span class="s1">facecolors = kwargs.get(</span><span class="s5">'facecolors'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">facecolors </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s5">'facecolors'</span><span class="s1">] = _shade_colors(</span>
                    <span class="s1">facecolors</span><span class="s3">, </span><span class="s1">normals</span><span class="s3">, </span><span class="s1">lightsource</span>
                <span class="s1">)</span>

            <span class="s1">edgecolors = kwargs.get(</span><span class="s5">'edgecolors'</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">edgecolors </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">kwargs[</span><span class="s5">'edgecolors'</span><span class="s1">] = _shade_colors(</span>
                    <span class="s1">edgecolors</span><span class="s3">, </span><span class="s1">normals</span><span class="s3">, </span><span class="s1">lightsource</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">facecolors </span><span class="s3">is None and </span><span class="s1">edgecolors </span><span class="s3">in None</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;You must provide facecolors, edgecolors, or both for &quot;</span>
                    <span class="s5">&quot;shade to work.&quot;</span><span class="s1">)</span>
        <span class="s1">super().__init__(verts</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s3">if </span><span class="s1">isinstance(verts</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
            <span class="s3">if </span><span class="s1">verts.ndim != </span><span class="s4">3</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'verts must be a list of (N, 3) array-like'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">any(len(np.shape(vert)) != </span><span class="s4">2 </span><span class="s3">for </span><span class="s1">vert </span><span class="s3">in </span><span class="s1">verts):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'verts must be a list of (N, 3) array-like'</span><span class="s1">)</span>
        <span class="s1">self.set_zsort(zsort)</span>
        <span class="s1">self._codes3d = </span><span class="s3">None</span>

    <span class="s1">_zsort_functions = {</span>
        <span class="s5">'average'</span><span class="s1">: np.average</span><span class="s3">,</span>
        <span class="s5">'min'</span><span class="s1">: np.min</span><span class="s3">,</span>
        <span class="s5">'max'</span><span class="s1">: np.max</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">def </span><span class="s1">set_zsort(self</span><span class="s3">, </span><span class="s1">zsort):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set the calculation method for the z-order. 
 
        Parameters 
        ---------- 
        zsort : {'average', 'min', 'max'} 
            The function applied on the z-coordinates of the vertices in the 
            viewer's coordinate system, to determine the z-order. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._zsortfunc = self._zsort_functions[zsort]</span>
        <span class="s1">self._sort_zpos = </span><span class="s3">None</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">get_vector(self</span><span class="s3">, </span><span class="s1">segments3d):</span>
        <span class="s2">&quot;&quot;&quot;Optimize points for projection.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">len(segments3d):</span>
            <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = np.row_stack(segments3d).T</span>
        <span class="s3">else</span><span class="s1">:  </span><span class="s0"># row_stack can't stack zero arrays.</span>
            <span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs = []</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span>
        <span class="s1">ones = np.ones(len(xs))</span>
        <span class="s1">self._vec = np.array([xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">ones])</span>

        <span class="s1">indices = [</span><span class="s4">0</span><span class="s3">, </span><span class="s1">*np.cumsum([len(segment) </span><span class="s3">for </span><span class="s1">segment </span><span class="s3">in </span><span class="s1">segments3d])]</span>
        <span class="s1">self._segslices = [*map(slice</span><span class="s3">, </span><span class="s1">indices[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">indices[</span><span class="s4">1</span><span class="s1">:])]</span>

    <span class="s3">def </span><span class="s1">set_verts(self</span><span class="s3">, </span><span class="s1">verts</span><span class="s3">, </span><span class="s1">closed=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Set 3D vertices. 
 
        Parameters 
        ---------- 
        verts : list of (N, 3) array-like 
            The sequence of polygons [*verts0*, *verts1*, ...] where each 
            element *verts_i* defines the vertices of polygon *i* as a 2D 
            array-like of shape (N, 3). 
        closed : bool, default: True 
            Whether the polygon should be closed by adding a CLOSEPOLY 
            connection at the end. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.get_vector(verts)</span>
        <span class="s0"># 2D verts will be updated at draw time</span>
        <span class="s1">super().set_verts([]</span><span class="s3">, False</span><span class="s1">)</span>
        <span class="s1">self._closed = closed</span>

    <span class="s3">def </span><span class="s1">set_verts_and_codes(self</span><span class="s3">, </span><span class="s1">verts</span><span class="s3">, </span><span class="s1">codes):</span>
        <span class="s2">&quot;&quot;&quot;Set 3D vertices with path codes.&quot;&quot;&quot;</span>
        <span class="s0"># set vertices with closed=False to prevent PolyCollection from</span>
        <span class="s0"># setting path codes</span>
        <span class="s1">self.set_verts(verts</span><span class="s3">, </span><span class="s1">closed=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s0"># and set our own codes instead.</span>
        <span class="s1">self._codes3d = codes</span>

    <span class="s3">def </span><span class="s1">set_3d_properties(self):</span>
        <span class="s0"># Force the collection to initialize the face and edgecolors</span>
        <span class="s0"># just in case it is a scalarmappable with a colormap.</span>
        <span class="s1">self.update_scalarmappable()</span>
        <span class="s1">self._sort_zpos = </span><span class="s3">None</span>
        <span class="s1">self.set_zsort(</span><span class="s5">'average'</span><span class="s1">)</span>
        <span class="s1">self._facecolor3d = PolyCollection.get_facecolor(self)</span>
        <span class="s1">self._edgecolor3d = PolyCollection.get_edgecolor(self)</span>
        <span class="s1">self._alpha3d = PolyCollection.get_alpha(self)</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">set_sort_zpos(self</span><span class="s3">, </span><span class="s1">val):</span>
        <span class="s2">&quot;&quot;&quot;Set the position to use for z-sorting.&quot;&quot;&quot;</span>
        <span class="s1">self._sort_zpos = val</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">do_3d_projection(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Perform the 3D projection for this object. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self._A </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s0"># force update of color mapping because we re-order them</span>
            <span class="s0"># below.  If we do not do this here, the 2D draw will call</span>
            <span class="s0"># this, but we will never port the color mapped values back</span>
            <span class="s0"># to the 3D versions.</span>
            <span class="s0">#</span>
            <span class="s0"># We hold the 3D versions in a fixed order (the order the user</span>
            <span class="s0"># passed in) and sort the 2D version by view depth.</span>
            <span class="s1">self.update_scalarmappable()</span>
            <span class="s3">if </span><span class="s1">self._face_is_mapped:</span>
                <span class="s1">self._facecolor3d = self._facecolors</span>
            <span class="s3">if </span><span class="s1">self._edge_is_mapped:</span>
                <span class="s1">self._edgecolor3d = self._edgecolors</span>
        <span class="s1">txs</span><span class="s3">, </span><span class="s1">tys</span><span class="s3">, </span><span class="s1">tzs = proj3d._proj_transform_vec(self._vec</span><span class="s3">, </span><span class="s1">self.axes.M)</span>
        <span class="s1">xyzlist = [(txs[sl]</span><span class="s3">, </span><span class="s1">tys[sl]</span><span class="s3">, </span><span class="s1">tzs[sl]) </span><span class="s3">for </span><span class="s1">sl </span><span class="s3">in </span><span class="s1">self._segslices]</span>

        <span class="s0"># This extra fuss is to re-order face / edge colors</span>
        <span class="s1">cface = self._facecolor3d</span>
        <span class="s1">cedge = self._edgecolor3d</span>
        <span class="s3">if </span><span class="s1">len(cface) != len(xyzlist):</span>
            <span class="s1">cface = cface.repeat(len(xyzlist)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(cedge) != len(xyzlist):</span>
            <span class="s3">if </span><span class="s1">len(cedge) == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">cedge = cface</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">cedge = cedge.repeat(len(xyzlist)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">xyzlist:</span>
            <span class="s0"># sort by depth (furthest drawn first)</span>
            <span class="s1">z_segments_2d = sorted(</span>
                <span class="s1">((self._zsortfunc(zs)</span><span class="s3">, </span><span class="s1">np.column_stack([xs</span><span class="s3">, </span><span class="s1">ys])</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">, </span><span class="s1">ec</span><span class="s3">, </span><span class="s1">idx)</span>
                 <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">((xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs)</span><span class="s3">, </span><span class="s1">fc</span><span class="s3">, </span><span class="s1">ec)</span>
                 <span class="s3">in </span><span class="s1">enumerate(zip(xyzlist</span><span class="s3">, </span><span class="s1">cface</span><span class="s3">, </span><span class="s1">cedge)))</span><span class="s3">,</span>
                <span class="s1">key=</span><span class="s3">lambda </span><span class="s1">x: x[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">reverse=</span><span class="s3">True</span><span class="s1">)</span>

            <span class="s1">_</span><span class="s3">, </span><span class="s1">segments_2d</span><span class="s3">, </span><span class="s1">self._facecolors2d</span><span class="s3">, </span><span class="s1">self._edgecolors2d</span><span class="s3">, </span><span class="s1">idxs = \</span>
                <span class="s1">zip(*z_segments_2d)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">segments_2d = []</span>
            <span class="s1">self._facecolors2d = np.empty((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
            <span class="s1">self._edgecolors2d = np.empty((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
            <span class="s1">idxs = []</span>

        <span class="s3">if </span><span class="s1">self._codes3d </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">codes = [self._codes3d[idx] </span><span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">idxs]</span>
            <span class="s1">PolyCollection.set_verts_and_codes(self</span><span class="s3">, </span><span class="s1">segments_2d</span><span class="s3">, </span><span class="s1">codes)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">PolyCollection.set_verts(self</span><span class="s3">, </span><span class="s1">segments_2d</span><span class="s3">, </span><span class="s1">self._closed)</span>

        <span class="s3">if </span><span class="s1">len(self._edgecolor3d) != len(cface):</span>
            <span class="s1">self._edgecolors2d = self._edgecolor3d</span>

        <span class="s0"># Return zorder value</span>
        <span class="s3">if </span><span class="s1">self._sort_zpos </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">zvec = np.array([[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[self._sort_zpos]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]])</span>
            <span class="s1">ztrans = proj3d._proj_transform_vec(zvec</span><span class="s3">, </span><span class="s1">self.axes.M)</span>
            <span class="s3">return </span><span class="s1">ztrans[</span><span class="s4">2</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s1">tzs.size &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># FIXME: Some results still don't look quite right.</span>
            <span class="s0">#        In particular, examine contourf3d_demo2.py</span>
            <span class="s0">#        with az = -54 and elev = -45.</span>
            <span class="s3">return </span><span class="s1">np.min(tzs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.nan</span>

    <span class="s3">def </span><span class="s1">set_facecolor(self</span><span class="s3">, </span><span class="s1">colors):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s1">super().set_facecolor(colors)</span>
        <span class="s1">self._facecolor3d = PolyCollection.get_facecolor(self)</span>

    <span class="s3">def </span><span class="s1">set_edgecolor(self</span><span class="s3">, </span><span class="s1">colors):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s1">super().set_edgecolor(colors)</span>
        <span class="s1">self._edgecolor3d = PolyCollection.get_edgecolor(self)</span>

    <span class="s3">def </span><span class="s1">set_alpha(self</span><span class="s3">, </span><span class="s1">alpha):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s1">artist.Artist.set_alpha(self</span><span class="s3">, </span><span class="s1">alpha)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self._facecolor3d = mcolors.to_rgba_array(</span>
                <span class="s1">self._facecolor3d</span><span class="s3">, </span><span class="s1">self._alpha)</span>
        <span class="s3">except </span><span class="s1">(AttributeError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">pass</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">self._edgecolors = mcolors.to_rgba_array(</span>
                    <span class="s1">self._edgecolor3d</span><span class="s3">, </span><span class="s1">self._alpha)</span>
        <span class="s3">except </span><span class="s1">(AttributeError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">IndexError):</span>
            <span class="s3">pass</span>
        <span class="s1">self.stale = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">get_facecolor(self):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s0"># self._facecolors2d is not initialized until do_3d_projection</span>
        <span class="s3">if not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s5">'_facecolors2d'</span><span class="s1">):</span>
            <span class="s1">self.axes.M = self.axes.get_proj()</span>
            <span class="s1">self.do_3d_projection()</span>
        <span class="s3">return </span><span class="s1">self._facecolors2d</span>

    <span class="s3">def </span><span class="s1">get_edgecolor(self):</span>
        <span class="s0"># docstring inherited</span>
        <span class="s0"># self._edgecolors2d is not initialized until do_3d_projection</span>
        <span class="s3">if not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s5">'_edgecolors2d'</span><span class="s1">):</span>
            <span class="s1">self.axes.M = self.axes.get_proj()</span>
            <span class="s1">self.do_3d_projection()</span>
        <span class="s3">return </span><span class="s1">self._edgecolors2d</span>


<span class="s3">def </span><span class="s1">poly_collection_2d_to_3d(col</span><span class="s3">, </span><span class="s1">zs=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">zdir=</span><span class="s5">'z'</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert a `.PolyCollection` into a `.Poly3DCollection` object. 
 
    Parameters 
    ---------- 
    zs : float or array of floats 
        The location or locations to place the polygons in the collection along 
        the *zdir* axis. Default: 0. 
    zdir : {'x', 'y', 'z'} 
        The axis in which to place the patches. Default: 'z'. 
        See `.get_dir_vector` for a description of the values. 
    &quot;&quot;&quot;</span>
    <span class="s1">segments_3d</span><span class="s3">, </span><span class="s1">codes = _paths_to_3d_segments_with_codes(</span>
            <span class="s1">col.get_paths()</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir)</span>
    <span class="s1">col.__class__ = Poly3DCollection</span>
    <span class="s1">col.set_verts_and_codes(segments_3d</span><span class="s3">, </span><span class="s1">codes)</span>
    <span class="s1">col.set_3d_properties()</span>


<span class="s3">def </span><span class="s1">juggle_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reorder coordinates so that 2D *xs*, *ys* can be plotted in the plane 
    orthogonal to *zdir*. *zdir* is normally 'x', 'y' or 'z'. However, if 
    *zdir* starts with a '-' it is interpreted as a compensation for 
    `rotate_axes`. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">zdir == </span><span class="s5">'x'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span>
    <span class="s3">elif </span><span class="s1">zdir == </span><span class="s5">'y'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">ys</span>
    <span class="s3">elif </span><span class="s1">zdir[</span><span class="s4">0</span><span class="s1">] == </span><span class="s5">'-'</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">rotate_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span>


<span class="s3">def </span><span class="s1">rotate_axes(xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">zdir):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reorder coordinates so that the axes are rotated with *zdir* along 
    the original z axis. Prepending the axis with a '-' does the 
    inverse transform, so *zdir* can be 'x', '-x', 'y', '-y', 'z' or '-z'. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">zdir </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'x'</span><span class="s3">, </span><span class="s5">'-y'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">xs</span>
    <span class="s3">elif </span><span class="s1">zdir </span><span class="s3">in </span><span class="s1">(</span><span class="s5">'-x'</span><span class="s3">, </span><span class="s5">'y'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">zs</span><span class="s3">, </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">xs</span><span class="s3">, </span><span class="s1">ys</span><span class="s3">, </span><span class="s1">zs</span>


<span class="s3">def </span><span class="s1">_zalpha(colors</span><span class="s3">, </span><span class="s1">zs):</span>
    <span class="s2">&quot;&quot;&quot;Modify the alphas of the color list according to depth.&quot;&quot;&quot;</span>
    <span class="s0"># FIXME: This only works well if the points for *zs* are well-spaced</span>
    <span class="s0">#        in all three dimensions. Otherwise, at certain orientations,</span>
    <span class="s0">#        the min and max zs are very close together.</span>
    <span class="s0">#        Should really normalize against the viewing depth.</span>
    <span class="s3">if </span><span class="s1">len(colors) == </span><span class="s4">0 </span><span class="s3">or </span><span class="s1">len(zs) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">np.zeros((</span><span class="s4">0</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
    <span class="s1">norm = Normalize(min(zs)</span><span class="s3">, </span><span class="s1">max(zs))</span>
    <span class="s1">sats = </span><span class="s4">1 </span><span class="s1">- norm(zs) * </span><span class="s4">0.7</span>
    <span class="s1">rgba = np.broadcast_to(mcolors.to_rgba_array(colors)</span><span class="s3">, </span><span class="s1">(len(zs)</span><span class="s3">, </span><span class="s4">4</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">np.column_stack([rgba[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">3</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rgba[:</span><span class="s3">, </span><span class="s4">3</span><span class="s1">] * sats])</span>


<span class="s3">def </span><span class="s1">_generate_normals(polygons):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the normals of a list of polygons, one normal per polygon. 
 
    Normals point towards the viewer for a face with its vertices in 
    counterclockwise order, following the right hand rule. 
 
    Uses three points equally spaced around the polygon. This method assumes 
    that the points are in a plane. Otherwise, more than one shade is required, 
    which is not supported. 
 
    Parameters 
    ---------- 
    polygons : list of (M_i, 3) array-like, or (..., M, 3) array-like 
        A sequence of polygons to compute normals for, which can have 
        varying numbers of vertices. If the polygons all have the same 
        number of vertices and array is passed, then the operation will 
        be vectorized. 
 
    Returns 
    ------- 
    normals : (..., 3) array 
        A normal vector estimated for the polygon. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(polygons</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
        <span class="s0"># optimization: polygons all have the same number of points, so can</span>
        <span class="s0"># vectorize</span>
        <span class="s1">n = polygons.shape[-</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">i1</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">, </span><span class="s1">i3 = </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n//</span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*n//</span><span class="s4">3</span>
        <span class="s1">v1 = polygons[...</span><span class="s3">, </span><span class="s1">i1</span><span class="s3">, </span><span class="s1">:] - polygons[...</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">, </span><span class="s1">:]</span>
        <span class="s1">v2 = polygons[...</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">, </span><span class="s1">:] - polygons[...</span><span class="s3">, </span><span class="s1">i3</span><span class="s3">, </span><span class="s1">:]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># The subtraction doesn't vectorize because polygons is jagged.</span>
        <span class="s1">v1 = np.empty((len(polygons)</span><span class="s3">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">v2 = np.empty((len(polygons)</span><span class="s3">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s3">for </span><span class="s1">poly_i</span><span class="s3">, </span><span class="s1">ps </span><span class="s3">in </span><span class="s1">enumerate(polygons):</span>
            <span class="s1">n = len(ps)</span>
            <span class="s1">i1</span><span class="s3">, </span><span class="s1">i2</span><span class="s3">, </span><span class="s1">i3 = </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n//</span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s1">*n//</span><span class="s4">3</span>
            <span class="s1">v1[poly_i</span><span class="s3">, </span><span class="s1">:] = ps[i1</span><span class="s3">, </span><span class="s1">:] - ps[i2</span><span class="s3">, </span><span class="s1">:]</span>
            <span class="s1">v2[poly_i</span><span class="s3">, </span><span class="s1">:] = ps[i2</span><span class="s3">, </span><span class="s1">:] - ps[i3</span><span class="s3">, </span><span class="s1">:]</span>
    <span class="s3">return </span><span class="s1">np.cross(v1</span><span class="s3">, </span><span class="s1">v2)</span>


<span class="s3">def </span><span class="s1">_shade_colors(color</span><span class="s3">, </span><span class="s1">normals</span><span class="s3">, </span><span class="s1">lightsource=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Shade *color* using normal vectors given by *normals*, 
    assuming a *lightsource* (using default position if not given). 
    *color* can also be an array of the same length as *normals*. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">lightsource </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s0"># chosen for backwards-compatibility</span>
        <span class="s1">lightsource = mcolors.LightSource(azdeg=</span><span class="s4">225</span><span class="s3">, </span><span class="s1">altdeg=</span><span class="s4">19.4712</span><span class="s1">)</span>

    <span class="s3">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">shade = ((normals / np.linalg.norm(normals</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">keepdims=</span><span class="s3">True</span><span class="s1">))</span>
                 <span class="s1">@ lightsource.direction)</span>
    <span class="s1">mask = ~np.isnan(shade)</span>

    <span class="s3">if </span><span class="s1">mask.any():</span>
        <span class="s0"># convert dot product to allowed shading fractions</span>
        <span class="s1">in_norm = mcolors.Normalize(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">out_norm = mcolors.Normalize(</span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">1</span><span class="s1">).inverse</span>

        <span class="s3">def </span><span class="s1">norm(x):</span>
            <span class="s3">return </span><span class="s1">out_norm(in_norm(x))</span>

        <span class="s1">shade[~mask] = </span><span class="s4">0</span>

        <span class="s1">color = mcolors.to_rgba_array(color)</span>
        <span class="s0"># shape of color should be (M, 4) (where M is number of faces)</span>
        <span class="s0"># shape of shade should be (M,)</span>
        <span class="s0"># colors should have final shape of (M, 4)</span>
        <span class="s1">alpha = color[:</span><span class="s3">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">colors = norm(shade)[:</span><span class="s3">, </span><span class="s1">np.newaxis] * color</span>
        <span class="s1">colors[:</span><span class="s3">, </span><span class="s4">3</span><span class="s1">] = alpha</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">colors = np.asanyarray(color).copy()</span>

    <span class="s3">return </span><span class="s1">colors</span>
</pre>
</body>
</html>